Directory structure:
└── vitejs-vite/
    ├── README.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── eslint.config.js
    ├── LICENSE
    ├── netlify.toml
    ├── package.json
    ├── pnpm-workspace.yaml
    ├── vitest.config.e2e.ts
    ├── vitest.config.ts
    ├── .editorconfig
    ├── .git-blame-ignore-revs
    ├── .prettierignore
    ├── .prettierrc.json
    ├── docs/
    │   ├── blog.md
    │   ├── index.md
    │   ├── package.json
    │   ├── releases.md
    │   ├── team.md
    │   ├── tsconfig.json
    │   ├── _data/
    │   │   ├── blog.data.ts
    │   │   └── team.js
    │   ├── blog/
    │   │   ├── announcing-vite2.md
    │   │   ├── announcing-vite3.md
    │   │   ├── announcing-vite4-3.md
    │   │   ├── announcing-vite4.md
    │   │   ├── announcing-vite5-1.md
    │   │   ├── announcing-vite5.md
    │   │   ├── announcing-vite6.md
    │   │   └── announcing-vite7.md
    │   ├── changes/
    │   │   ├── hotupdate-hook.md
    │   │   ├── index.md
    │   │   ├── per-environment-apis.md
    │   │   ├── shared-plugins-during-build.md
    │   │   ├── ssr-using-modulerunner.md
    │   │   └── this-environment-in-hooks.md
    │   ├── config/
    │   │   ├── build-options.md
    │   │   ├── dep-optimization-options.md
    │   │   ├── index.md
    │   │   ├── preview-options.md
    │   │   ├── server-options.md
    │   │   ├── shared-options.md
    │   │   ├── ssr-options.md
    │   │   └── worker-options.md
    │   ├── guide/
    │   │   ├── api-environment-frameworks.md
    │   │   ├── api-environment-instances.md
    │   │   ├── api-environment-plugins.md
    │   │   ├── api-environment-runtimes.md
    │   │   ├── api-environment.md
    │   │   ├── api-hmr.md
    │   │   ├── api-javascript.md
    │   │   ├── api-plugin.md
    │   │   ├── assets.md
    │   │   ├── backend-integration.md
    │   │   ├── build.md
    │   │   ├── cli.md
    │   │   ├── dep-pre-bundling.md
    │   │   ├── env-and-mode.md
    │   │   ├── features.md
    │   │   ├── index.md
    │   │   ├── migration.md
    │   │   ├── performance.md
    │   │   ├── philosophy.md
    │   │   ├── rolldown.md
    │   │   ├── ssr.md
    │   │   ├── static-deploy-github-pages.yaml
    │   │   ├── static-deploy.md
    │   │   ├── troubleshooting.md
    │   │   ├── using-plugins.md
    │   │   └── why.md
    │   ├── images/
    │   │   ├── diagrams.fig
    │   │   ├── vite5-1-10K-modules-loading-time.webp
    │   │   ├── vite6-npm-weekly-downloads.webp
    │   │   └── community/
    │   │       └── placeholder.webp
    │   ├── plugins/
    │   │   └── index.md
    │   ├── public/
    │   │   ├── _headers
    │   │   ├── _redirects
    │   │   ├── logo-uwu.webp
    │   │   └── logo-with-shadow.webp
    │   └── .vitepress/
    │       ├── buildEnd.config.ts
    │       ├── config.ts
    │       ├── inlined-scripts/
    │       │   ├── banner.d.ts
    │       │   └── banner.js
    │       └── theme/
    │           ├── index.ts
    │           ├── components/
    │           │   ├── AsideSponsors.vue
    │           │   ├── BlogIndex.vue
    │           │   ├── NonInheritBadge.vue
    │           │   ├── SponsorBanner.vue
    │           │   ├── SvgImage.vue
    │           │   ├── YouTubeVideo.vue
    │           │   └── landing/
    │           │       ├── 1. hero-section/
    │           │       │   ├── HeroDiagram.vue
    │           │       │   ├── HeroSection.vue
    │           │       │   └── svg-elements/
    │           │       │       ├── SvgBlueIndicator.vue
    │           │       │       ├── SvgInputs.vue
    │           │       │       ├── SvgOutputs.vue
    │           │       │       └── SvgPinkIndicator.vue
    │           │       ├── 2. feature-section/
    │           │       │   ├── FeatureCI.vue
    │           │       │   ├── FeatureFlexiblePlugins.vue
    │           │       │   ├── FeatureHMR.vue
    │           │       │   ├── FeatureInstantServerStart.vue
    │           │       │   ├── FeatureOptimizedBuild.vue
    │           │       │   ├── FeatureRichFeatures.vue
    │           │       │   ├── FeatureSection.vue
    │           │       │   ├── FeatureSSRSupport.vue
    │           │       │   └── FeatureTypedAPI.vue
    │           │       ├── 3. frameworks-section/
    │           │       │   ├── FrameworkCard.vue
    │           │       │   └── FrameworksSection.vue
    │           │       ├── 4. community-section/
    │           │       │   ├── CommunityCard.vue
    │           │       │   └── CommunitySection.vue
    │           │       ├── 5. sponsor-section/
    │           │       │   └── SponsorSection.vue
    │           │       ├── 6. get-started-section/
    │           │       │   └── GetStartedSection.vue
    │           │       └── common/
    │           │           ├── noise.webp
    │           │           └── SvgNode.vue
    │           ├── composables/
    │           │   ├── sponsor.ts
    │           │   ├── useCardAnimation.ts
    │           │   └── useSlideIn.ts
    │           └── styles/
    │               ├── landing.css
    │               └── vars.css
    ├── packages/
    │   ├── create-vite/
    │   │   ├── README.md
    │   │   ├── index.js
    │   │   ├── LICENSE
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── tsdown.config.ts
    │   │   ├── __tests__/
    │   │   │   └── cli.spec.ts
    │   │   ├── src/
    │   │   │   └── index.ts
    │   │   ├── template-lit/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   └── src/
    │   │   │       ├── index.css
    │   │   │       └── my-element.js
    │   │   ├── template-lit-ts/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   └── src/
    │   │   │       ├── index.css
    │   │   │       ├── my-element.ts
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-preact/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── app.jsx
    │   │   │       ├── index.css
    │   │   │       └── main.jsx
    │   │   ├── template-preact-ts/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.app.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── tsconfig.node.json
    │   │   │   ├── vite.config.ts
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── app.tsx
    │   │   │       ├── index.css
    │   │   │       ├── main.tsx
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-qwik/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── app.jsx
    │   │   │       ├── index.css
    │   │   │       ├── main.jsx
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-qwik-ts/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.app.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── tsconfig.node.json
    │   │   │   ├── vite.config.ts
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── app.tsx
    │   │   │       ├── index.css
    │   │   │       ├── main.tsx
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-react/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── eslint.config.js
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── App.css
    │   │   │       ├── App.jsx
    │   │   │       ├── index.css
    │   │   │       └── main.jsx
    │   │   ├── template-react-ts/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── eslint.config.js
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.app.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── tsconfig.node.json
    │   │   │   ├── vite.config.ts
    │   │   │   └── src/
    │   │   │       ├── App.css
    │   │   │       ├── App.tsx
    │   │   │       ├── index.css
    │   │   │       ├── main.tsx
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-solid/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── App.css
    │   │   │       ├── App.jsx
    │   │   │       ├── index.css
    │   │   │       └── index.jsx
    │   │   ├── template-solid-ts/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.app.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── tsconfig.node.json
    │   │   │   ├── vite.config.ts
    │   │   │   └── src/
    │   │   │       ├── App.css
    │   │   │       ├── App.tsx
    │   │   │       ├── index.css
    │   │   │       ├── index.tsx
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-svelte/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── jsconfig.json
    │   │   │   ├── package.json
    │   │   │   ├── svelte.config.js
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── App.svelte
    │   │   │       ├── main.js
    │   │   │       ├── vite-env.d.ts
    │   │   │       └── lib/
    │   │   │           └── Counter.svelte
    │   │   ├── template-svelte-ts/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── svelte.config.js
    │   │   │   ├── tsconfig.app.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── tsconfig.node.json
    │   │   │   ├── vite.config.ts
    │   │   │   └── src/
    │   │   │       ├── app.css
    │   │   │       ├── App.svelte
    │   │   │       ├── main.ts
    │   │   │       ├── vite-env.d.ts
    │   │   │       └── lib/
    │   │   │           └── Counter.svelte
    │   │   ├── template-vanilla/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   └── src/
    │   │   │       ├── counter.js
    │   │   │       ├── main.js
    │   │   │       └── style.css
    │   │   ├── template-vanilla-ts/
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   └── src/
    │   │   │       ├── counter.ts
    │   │   │       ├── main.ts
    │   │   │       ├── style.css
    │   │   │       └── vite-env.d.ts
    │   │   ├── template-vue/
    │   │   │   ├── README.md
    │   │   │   ├── _gitignore
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   ├── vite.config.js
    │   │   │   └── src/
    │   │   │       ├── App.vue
    │   │   │       ├── main.js
    │   │   │       ├── style.css
    │   │   │       └── components/
    │   │   │           └── HelloWorld.vue
    │   │   └── template-vue-ts/
    │   │       ├── README.md
    │   │       ├── _gitignore
    │   │       ├── index.html
    │   │       ├── package.json
    │   │       ├── tsconfig.app.json
    │   │       ├── tsconfig.json
    │   │       ├── tsconfig.node.json
    │   │       ├── vite.config.ts
    │   │       └── src/
    │   │           ├── App.vue
    │   │           ├── main.ts
    │   │           ├── style.css
    │   │           ├── vite-env.d.ts
    │   │           └── components/
    │   │               └── HelloWorld.vue
    │   ├── plugin-legacy/
    │   │   ├── README.md
    │   │   ├── LICENSE
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── tsdown.config.ts
    │   │   ├── src/
    │   │   │   ├── index.ts
    │   │   │   ├── shims.d.ts
    │   │   │   ├── snippets.ts
    │   │   │   ├── types.ts
    │   │   │   └── __tests__/
    │   │   │       ├── readme.spec.ts
    │   │   │       └── snippets.spec.ts
    │   │   └── types/
    │   │       └── legacy-for-rolldown-vite.d.ts
    │   └── vite/
    │       ├── README.md
    │       ├── client.d.ts
    │       ├── package.json
    │       ├── rolldown.config.ts
    │       ├── rolldown.dts.config.ts
    │       ├── rollupLicensePlugin.ts
    │       ├── tsconfig.base.json
    │       ├── tsconfig.check.json
    │       ├── tsconfig.json
    │       ├── misc/
    │       │   ├── false.d.ts
    │       │   ├── false.js
    │       │   ├── true.d.ts
    │       │   └── true.js
    │       ├── scripts/
    │       │   └── generateTarget.ts
    │       ├── src/
    │       │   ├── client/
    │       │   │   ├── client.ts
    │       │   │   ├── env.ts
    │       │   │   ├── overlay.ts
    │       │   │   └── tsconfig.json
    │       │   ├── module-runner/
    │       │   │   ├── constants.ts
    │       │   │   ├── createImportMeta.ts
    │       │   │   ├── esmEvaluator.ts
    │       │   │   ├── evaluatedModules.ts
    │       │   │   ├── hmrHandler.ts
    │       │   │   ├── hmrLogger.ts
    │       │   │   ├── importMetaResolver.ts
    │       │   │   ├── index.ts
    │       │   │   ├── runner.ts
    │       │   │   ├── tsconfig.json
    │       │   │   ├── types.ts
    │       │   │   ├── utils.ts
    │       │   │   └── sourcemap/
    │       │   │       ├── decoder.ts
    │       │   │       ├── index.ts
    │       │   │       └── interceptor.ts
    │       │   ├── node/
    │       │   │   ├── assetSource.ts
    │       │   │   ├── baseEnvironment.ts
    │       │   │   ├── build.ts
    │       │   │   ├── cli.ts
    │       │   │   ├── constants.ts
    │       │   │   ├── deprecations.ts
    │       │   │   ├── env.ts
    │       │   │   ├── environment.ts
    │       │   │   ├── external.ts
    │       │   │   ├── http.ts
    │       │   │   ├── idResolver.ts
    │       │   │   ├── index.ts
    │       │   │   ├── logger.ts
    │       │   │   ├── packages.ts
    │       │   │   ├── plugin.ts
    │       │   │   ├── preview.ts
    │       │   │   ├── publicDir.ts
    │       │   │   ├── shortcuts.ts
    │       │   │   ├── tsconfig.build.json
    │       │   │   ├── tsconfig.json
    │       │   │   ├── typeUtils.ts
    │       │   │   ├── utils.ts
    │       │   │   ├── watch.ts
    │       │   │   ├── __tests__/
    │       │   │   │   ├── assetSource.spec.ts
    │       │   │   │   ├── build.spec.ts
    │       │   │   │   ├── config.spec.ts
    │       │   │   │   ├── constants.spec.ts
    │       │   │   │   ├── dev.spec.ts
    │       │   │   │   ├── env.spec.ts
    │       │   │   │   ├── environment.spec.ts
    │       │   │   │   ├── external.spec.ts
    │       │   │   │   ├── package.json
    │       │   │   │   ├── resolve.spec.ts
    │       │   │   │   ├── runnerImport.spec.ts
    │       │   │   │   ├── scan.spec.ts
    │       │   │   │   ├── utils.spec.ts
    │       │   │   │   ├── __snapshots__/
    │       │   │   │   │   └── utils.spec.ts.snap
    │       │   │   │   ├── fixtures/
    │       │   │   │   │   ├── cjs-ssr-dep/
    │       │   │   │   │   │   ├── index.js
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   ├── config/
    │       │   │   │   │   │   ├── entry/
    │       │   │   │   │   │   │   ├── imports-field.ts
    │       │   │   │   │   │   │   ├── package.json
    │       │   │   │   │   │   │   ├── vite.config.import-attributes.ts
    │       │   │   │   │   │   │   └── vite.config.ts
    │       │   │   │   │   │   ├── import-meta/
    │       │   │   │   │   │   │   └── vite.config.ts
    │       │   │   │   │   │   ├── loadConfigFromFile/
    │       │   │   │   │   │   │   └── .gitkeep
    │       │   │   │   │   │   ├── native-import/
    │       │   │   │   │   │   │   └── basic.js
    │       │   │   │   │   │   ├── plugin-module-condition/
    │       │   │   │   │   │   │   ├── index.cjs
    │       │   │   │   │   │   │   ├── index.d.ts
    │       │   │   │   │   │   │   ├── index.mjs
    │       │   │   │   │   │   │   ├── module.mjs
    │       │   │   │   │   │   │   └── package.json
    │       │   │   │   │   │   └── siblings/
    │       │   │   │   │   │       ├── foo.ts
    │       │   │   │   │   │       └── package.json
    │       │   │   │   │   ├── dynamic-import/
    │       │   │   │   │   │   ├── dep.mjs
    │       │   │   │   │   │   └── entry.mjs
    │       │   │   │   │   ├── emit-assets/
    │       │   │   │   │   │   ├── css-module.module.css
    │       │   │   │   │   │   ├── css-normal.css
    │       │   │   │   │   │   └── entry.mjs
    │       │   │   │   │   ├── environment-alias/
    │       │   │   │   │   │   ├── test.client.js
    │       │   │   │   │   │   ├── test.rsc.js
    │       │   │   │   │   │   └── test.ssr.js
    │       │   │   │   │   ├── file-url/
    │       │   │   │   │   │   ├── entry.js
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   ├── runner-import/
    │       │   │   │   │   │   ├── basic.ts
    │       │   │   │   │   │   ├── cjs.js
    │       │   │   │   │   │   ├── dynamic-import-dep.ts
    │       │   │   │   │   │   ├── dynamic-import.ts
    │       │   │   │   │   │   ├── plugin.ts
    │       │   │   │   │   │   ├── vite.config.outside-pkg-import.mts
    │       │   │   │   │   │   └── vite.config.ts
    │       │   │   │   │   ├── scan-jsx-runtime/
    │       │   │   │   │   │   ├── entry-jsx.tsx
    │       │   │   │   │   │   ├── entry-no-jsx.js
    │       │   │   │   │   │   └── tsconfig.json
    │       │   │   │   │   ├── shared-plugins/
    │       │   │   │   │   │   └── minify/
    │       │   │   │   │   │       └── entry.js
    │       │   │   │   │   ├── test-dep-conditions/
    │       │   │   │   │   │   ├── index.browser.js
    │       │   │   │   │   │   ├── index.css
    │       │   │   │   │   │   ├── index.custom1.js
    │       │   │   │   │   │   ├── index.default.js
    │       │   │   │   │   │   ├── index.worker.js
    │       │   │   │   │   │   ├── package.json
    │       │   │   │   │   │   └── dir/
    │       │   │   │   │   │       ├── index.default.js
    │       │   │   │   │   │       └── index.module.js
    │       │   │   │   │   ├── test-dep-conditions-app/
    │       │   │   │   │   │   ├── entry-with-module.js
    │       │   │   │   │   │   ├── entry.css
    │       │   │   │   │   │   └── entry.js
    │       │   │   │   │   ├── watch-rebuild-manifest/
    │       │   │   │   │   │   ├── dep.js
    │       │   │   │   │   │   ├── entry.js
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   └── worker-dynamic/
    │       │   │   │   │       ├── dynamic.js
    │       │   │   │   │       ├── main.js
    │       │   │   │   │       └── worker.js
    │       │   │   │   ├── packages/
    │       │   │   │   │   ├── package.json
    │       │   │   │   │   ├── build-project/
    │       │   │   │   │   │   └── index.html
    │       │   │   │   │   ├── child/
    │       │   │   │   │   │   ├── index.js
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   ├── module/
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   ├── name/
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   ├── noname/
    │       │   │   │   │   │   └── package.json
    │       │   │   │   │   └── parent/
    │       │   │   │   │       ├── index.ts
    │       │   │   │   │       └── package.json
    │       │   │   │   ├── plugins/
    │       │   │   │   │   ├── assetImportMetaUrl.spec.ts
    │       │   │   │   │   ├── css.spec.ts
    │       │   │   │   │   ├── define.spec.ts
    │       │   │   │   │   ├── esbuild.spec.ts
    │       │   │   │   │   ├── hooks.spec.ts
    │       │   │   │   │   ├── import.spec.ts
    │       │   │   │   │   ├── index.spec.ts
    │       │   │   │   │   ├── json.spec.ts
    │       │   │   │   │   ├── pluginFilter.spec.ts
    │       │   │   │   │   ├── terser.spec.ts
    │       │   │   │   │   ├── workerImportMetaUrl.spec.ts
    │       │   │   │   │   ├── dynamicImportVar/
    │       │   │   │   │   │   ├── parse.spec.ts
    │       │   │   │   │   │   ├── __snapshots__/
    │       │   │   │   │   │   │   └── parse.spec.ts.snap
    │       │   │   │   │   │   └── mods/
    │       │   │   │   │   │       ├── hello.js
    │       │   │   │   │   │       └── hi.js
    │       │   │   │   │   ├── fixtures/
    │       │   │   │   │   │   └── css-module-compose/
    │       │   │   │   │   │       └── css/
    │       │   │   │   │   │           └── bar.module.css
    │       │   │   │   │   ├── importGlob/
    │       │   │   │   │   │   ├── fixture.spec.ts
    │       │   │   │   │   │   ├── parse.spec.ts
    │       │   │   │   │   │   ├── utils.spec.ts
    │       │   │   │   │   │   ├── __snapshots__/
    │       │   │   │   │   │   │   └── fixture.spec.ts.snap
    │       │   │   │   │   │   ├── fixture-a/
    │       │   │   │   │   │   │   ├── index.ts
    │       │   │   │   │   │   │   ├── sibling.ts
    │       │   │   │   │   │   │   └── modules/
    │       │   │   │   │   │   │       ├── a.ts
    │       │   │   │   │   │   │       ├── b.ts
    │       │   │   │   │   │   │       └── index.ts
    │       │   │   │   │   │   └── fixture-b/
    │       │   │   │   │   │       ├── a.ts
    │       │   │   │   │   │       ├── b.ts
    │       │   │   │   │   │       └── index.ts
    │       │   │   │   │   └── modulePreloadPolyfill/
    │       │   │   │   │       ├── modulePreloadPolyfill.spec.ts
    │       │   │   │   │       └── __snapshots__/
    │       │   │   │   │           └── modulePreloadPolyfill.spec.ts.snap
    │       │   │   │   └── utils/
    │       │   │   │       └── isFileReadable/
    │       │   │   │           └── permission-test-file
    │       │   │   ├── __tests_dts__/
    │       │   │   │   ├── config.ts
    │       │   │   │   ├── plugin.ts
    │       │   │   │   ├── typeOptions.ts
    │       │   │   │   └── utils.ts
    │       │   │   ├── optimizer/
    │       │   │   │   ├── esbuildDepPlugin.ts
    │       │   │   │   ├── index.ts
    │       │   │   │   ├── optimizer.ts
    │       │   │   │   ├── resolve.ts
    │       │   │   │   └── scan.ts
    │       │   │   ├── plugins/
    │       │   │   │   ├── asset.ts
    │       │   │   │   ├── assetImportMetaUrl.ts
    │       │   │   │   ├── clientInjections.ts
    │       │   │   │   ├── completeSystemWrap.ts
    │       │   │   │   ├── dataUri.ts
    │       │   │   │   ├── define.ts
    │       │   │   │   ├── dynamicImportVars.ts
    │       │   │   │   ├── esbuild.ts
    │       │   │   │   ├── importAnalysis.ts
    │       │   │   │   ├── importAnalysisBuild.ts
    │       │   │   │   ├── importMetaGlob.ts
    │       │   │   │   ├── index.ts
    │       │   │   │   ├── json.ts
    │       │   │   │   ├── loadFallback.ts
    │       │   │   │   ├── manifest.ts
    │       │   │   │   ├── metadata.ts
    │       │   │   │   ├── modulePreloadPolyfill.ts
    │       │   │   │   ├── optimizedDeps.ts
    │       │   │   │   ├── pluginFilter.ts
    │       │   │   │   ├── preAlias.ts
    │       │   │   │   ├── prepareOutDir.ts
    │       │   │   │   ├── reporter.ts
    │       │   │   │   ├── resolve.ts
    │       │   │   │   ├── terser.ts
    │       │   │   │   ├── wasm.ts
    │       │   │   │   ├── worker.ts
    │       │   │   │   └── workerImportMetaUrl.ts
    │       │   │   ├── server/
    │       │   │   │   ├── environment.ts
    │       │   │   │   ├── hmr.ts
    │       │   │   │   ├── index.ts
    │       │   │   │   ├── mixedModuleGraph.ts
    │       │   │   │   ├── moduleGraph.ts
    │       │   │   │   ├── openBrowser.ts
    │       │   │   │   ├── pluginContainer.ts
    │       │   │   │   ├── searchRoot.ts
    │       │   │   │   ├── send.ts
    │       │   │   │   ├── sourcemap.ts
    │       │   │   │   ├── transformRequest.ts
    │       │   │   │   ├── warmup.ts
    │       │   │   │   ├── ws.ts
    │       │   │   │   ├── __tests__/
    │       │   │   │   │   ├── moduleGraph.spec.ts
    │       │   │   │   │   ├── pluginContainer.spec.ts
    │       │   │   │   │   ├── search-root.spec.ts
    │       │   │   │   │   ├── watcher.spec.ts
    │       │   │   │   │   └── fixtures/
    │       │   │   │   │       ├── lerna/
    │       │   │   │   │       │   ├── lerna.json
    │       │   │   │   │       │   └── nested/
    │       │   │   │   │       │       └── package.json
    │       │   │   │   │       ├── none/
    │       │   │   │   │       │   └── nested/
    │       │   │   │   │       │       └── package.json
    │       │   │   │   │       ├── pnpm/
    │       │   │   │   │       │   ├── package.json
    │       │   │   │   │       │   ├── pnpm-workspace.yaml
    │       │   │   │   │       │   └── nested/
    │       │   │   │   │       │       └── package.json
    │       │   │   │   │       ├── watcher/
    │       │   │   │   │       │   ├── package.json
    │       │   │   │   │       │   ├── config-deps/
    │       │   │   │   │       │   │   └── foo.js
    │       │   │   │   │       │   ├── custom-public/
    │       │   │   │   │       │   │   └── foo.txt
    │       │   │   │   │       │   └── nested-root/
    │       │   │   │   │       │       └── vite.config.js
    │       │   │   │   │       └── yarn/
    │       │   │   │   │           ├── package.json
    │       │   │   │   │           └── nested/
    │       │   │   │   │               └── package.json
    │       │   │   │   ├── environments/
    │       │   │   │   │   ├── fetchableEnvironments.ts
    │       │   │   │   │   └── runnableEnvironment.ts
    │       │   │   │   └── middlewares/
    │       │   │   │       ├── base.ts
    │       │   │   │       ├── error.ts
    │       │   │   │       ├── hostCheck.ts
    │       │   │   │       ├── htmlFallback.ts
    │       │   │   │       ├── indexHtml.ts
    │       │   │   │       ├── notFound.ts
    │       │   │   │       ├── proxy.ts
    │       │   │   │       ├── rejectInvalidRequest.ts
    │       │   │   │       ├── static.ts
    │       │   │   │       ├── time.ts
    │       │   │   │       ├── transform.ts
    │       │   │   │       └── __tests__/
    │       │   │   │           └── hostCheck.spec.ts
    │       │   │   └── ssr/
    │       │   │       ├── fetchModule.ts
    │       │   │       ├── index.ts
    │       │   │       ├── runnerImport.ts
    │       │   │       ├── ssrManifestPlugin.ts
    │       │   │       ├── ssrModuleLoader.ts
    │       │   │       ├── ssrStacktrace.ts
    │       │   │       ├── ssrTransform.ts
    │       │   │       ├── __tests__/
    │       │   │       │   ├── ssrLoadModule.spec.ts
    │       │   │       │   ├── ssrStacktrace.spec.ts
    │       │   │       │   ├── ssrTransform.spec.ts
    │       │   │       │   ├── __snapshots__/
    │       │   │       │   │   └── ssrLoadModule.spec.ts.snap
    │       │   │       │   └── fixtures/
    │       │   │       │       ├── bundled-with-sourcemaps/
    │       │   │       │       │   └── bundle.js
    │       │   │       │       ├── errors/
    │       │   │       │       │   ├── syntax-error-dep.js
    │       │   │       │       │   ├── syntax-error-dep.ts
    │       │   │       │       │   ├── syntax-error.js
    │       │   │       │       │   └── syntax-error.ts
    │       │   │       │       ├── file-url/
    │       │   │       │       │   ├── test space.js
    │       │   │       │       │   └── test.js
    │       │   │       │       ├── global/
    │       │   │       │       │   ├── export.js
    │       │   │       │       │   └── test.js
    │       │   │       │       ├── json/
    │       │   │       │       │   └── test.json
    │       │   │       │       ├── modules/
    │       │   │       │       │   ├── has-error.js
    │       │   │       │       │   ├── has-invalid-import.js
    │       │   │       │       │   └── import-meta.js
    │       │   │       │       ├── multi-source-sourcemaps/
    │       │   │       │       │   ├── dist.js
    │       │   │       │       │   ├── entrypoint.js
    │       │   │       │       │   └── nested-directory/
    │       │   │       │       │       └── nested-file.js
    │       │   │       │       └── named-overwrite-all/
    │       │   │       │           ├── dep1.js
    │       │   │       │           ├── dep2.js
    │       │   │       │           └── main.js
    │       │   │       └── runtime/
    │       │   │           ├── serverModuleRunner.ts
    │       │   │           └── __tests__/
    │       │   │               ├── package.json
    │       │   │               ├── server-hmr.spec.ts
    │       │   │               ├── server-no-hmr.spec.ts
    │       │   │               ├── server-runtime.spec.ts
    │       │   │               ├── server-source-maps.spec.ts
    │       │   │               ├── server-worker-runner.invoke.spec.ts
    │       │   │               ├── server-worker-runner.spec.ts
    │       │   │               ├── utils.ts
    │       │   │               └── fixtures/
    │       │   │                   ├── a.ts
    │       │   │                   ├── assets.js
    │       │   │                   ├── b.ts
    │       │   │                   ├── basic.js
    │       │   │                   ├── c.ts
    │       │   │                   ├── cjs-external-existing.js
    │       │   │                   ├── cjs-external-non-existing.js
    │       │   │                   ├── d.ts
    │       │   │                   ├── default-string.ts
    │       │   │                   ├── dynamic-import.js
    │       │   │                   ├── esm-external-existing.js
    │       │   │                   ├── esm-external-non-existing.js
    │       │   │                   ├── has-error-deep.ts
    │       │   │                   ├── has-error-first-comment.ts
    │       │   │                   ├── has-error-first.js
    │       │   │                   ├── has-error.js
    │       │   │                   ├── hmr.js
    │       │   │                   ├── import-external.ts
    │       │   │                   ├── installed.js
    │       │   │                   ├── native.js
    │       │   │                   ├── simple.js
    │       │   │                   ├── string-literal-sourcemap.ts
    │       │   │                   ├── test.css
    │       │   │                   ├── test.module.css
    │       │   │                   ├── throws-error-method.ts
    │       │   │                   ├── top-level-object.js
    │       │   │                   ├── virtual.js
    │       │   │                   ├── worker.invoke.mjs
    │       │   │                   ├── worker.mjs
    │       │   │                   ├── assets/
    │       │   │                   │   ├── placeholder.txt
    │       │   │                   │   └── placeholder.webp
    │       │   │                   ├── circular/
    │       │   │                   │   ├── circular-a.js
    │       │   │                   │   ├── circular-b.js
    │       │   │                   │   └── circular-index.js
    │       │   │                   ├── cjs-external/
    │       │   │                   │   ├── index.cjs
    │       │   │                   │   └── package.json
    │       │   │                   ├── cyclic/
    │       │   │                   │   ├── action.js
    │       │   │                   │   ├── entry-cyclic.js
    │       │   │                   │   └── entry.js
    │       │   │                   ├── cyclic2/
    │       │   │                   │   ├── README.md
    │       │   │                   │   ├── package.json
    │       │   │                   │   ├── test1/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test2/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test3/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test4/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test5/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test6/
    │       │   │                   │   │   ├── dep1.js
    │       │   │                   │   │   ├── dep2.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test7/
    │       │   │                   │   │   ├── README.md
    │       │   │                   │   │   ├── Ion.js
    │       │   │                   │   │   ├── IonTypes.js
    │       │   │                   │   │   └── dom/
    │       │   │                   │   │       ├── Blob.js
    │       │   │                   │   │       └── index.js
    │       │   │                   │   └── test9/
    │       │   │                   │       ├── dep.js
    │       │   │                   │       └── index.js
    │       │   │                   ├── esm-external/
    │       │   │                   │   ├── index.mjs
    │       │   │                   │   └── package.json
    │       │   │                   ├── execution-order-re-export/
    │       │   │                   │   ├── dep1.js
    │       │   │                   │   ├── dep2.js
    │       │   │                   │   └── index.js
    │       │   │                   ├── live-binding/
    │       │   │                   │   ├── package.json
    │       │   │                   │   ├── test1/
    │       │   │                   │   │   ├── dep.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test2/
    │       │   │                   │   │   ├── dep.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   ├── test3/
    │       │   │                   │   │   ├── dep.js
    │       │   │                   │   │   └── index.js
    │       │   │                   │   └── test4/
    │       │   │                   │       ├── dep.js
    │       │   │                   │       └── index.js
    │       │   │                   └── no-this/
    │       │   │                       ├── importee.js
    │       │   │                       └── importer.js
    │       │   ├── shared/
    │       │   │   ├── constants.ts
    │       │   │   ├── hmr.ts
    │       │   │   ├── hmrHandler.ts
    │       │   │   ├── invokeMethods.ts
    │       │   │   ├── moduleRunnerTransport.ts
    │       │   │   ├── ssrTransform.ts
    │       │   │   ├── tsconfig.json
    │       │   │   └── utils.ts
    │       │   └── types/
    │       │       ├── alias.d.ts
    │       │       ├── anymatch.d.ts
    │       │       ├── chokidar.d.ts
    │       │       ├── commonjs.d.ts
    │       │       ├── connect.d.ts
    │       │       ├── dynamicImportVars.d.ts
    │       │       ├── package.json
    │       │       ├── shims.d.ts
    │       │       └── ws.d.ts
    │       └── types/
    │           ├── customEvent.d.ts
    │           ├── hmrPayload.d.ts
    │           ├── hot.d.ts
    │           ├── import-meta.d.ts
    │           ├── importGlob.d.ts
    │           ├── importMeta.d.ts
    │           ├── metadata.d.ts
    │           ├── package.json
    │           └── internal/
    │               ├── cssPreprocessorOptions.d.ts
    │               ├── lightningcssOptions.d.ts
    │               └── terserOptions.d.ts
    ├── patches/
    │   ├── chokidar@3.6.0.patch
    │   ├── dotenv-expand@12.0.2.patch
    │   └── sirv@3.0.1.patch
    ├── playground/
    │   ├── package.json
    │   ├── shims.d.ts
    │   ├── test-utils.ts
    │   ├── tsconfig.json
    │   ├── vitestGlobalSetup.ts
    │   ├── vitestSetup.ts
    │   ├── alias/
    │   │   ├── customResolver.js
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── test.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── alias.spec.ts
    │   │   └── dir/
    │   │       ├── from-script-src.js
    │   │       ├── test.css
    │   │       ├── test.js
    │   │       └── module/
    │   │           ├── index.js
    │   │           └── package.json
    │   ├── assets/
    │   │   ├── foo.js
    │   │   ├── index.html
    │   │   ├── manifest.json
    │   │   ├── package.json
    │   │   ├── vite.config-encoded-base.js
    │   │   ├── vite.config-relative-base.js
    │   │   ├── vite.config-runtime-base.js
    │   │   ├── vite.config-url-base.js
    │   │   ├── vite.config.js
    │   │   ├── テスト-測試-white space.js
    │   │   ├── __tests__/
    │   │   │   ├── assets.spec.ts
    │   │   │   ├── encoded-base/
    │   │   │   │   └── assets-encoded-base.spec.ts
    │   │   │   ├── relative-base/
    │   │   │   │   └── assets-relative-base.spec.ts
    │   │   │   ├── runtime-base/
    │   │   │   │   └── assets-runtime-base.spec.ts
    │   │   │   └── url-base/
    │   │   │       └── assets-url-base.spec.ts
    │   │   ├── asset/
    │   │   │   ├── main.js
    │   │   │   └── style.css
    │   │   ├── css/
    │   │   │   ├── css-url-url.css
    │   │   │   ├── css-url.css
    │   │   │   ├── fonts.css
    │   │   │   ├── foo.module.css
    │   │   │   ├── icons.css
    │   │   │   ├── import.css
    │   │   │   ├── manual-chunks.css
    │   │   │   └── nested/
    │   │   │       └── at-imported-css-url.css
    │   │   ├── nested/
    │   │   │   ├── foo.unknown
    │   │   │   ├── partial.html
    │   │   │   └── test.js
    │   │   └── static/
    │   │       ├── bar
    │   │       ├── foo.css
    │   │       ├── foo.json
    │   │       ├── foo.txt
    │   │       ├── import-expression.js
    │   │       ├── raw.css
    │   │       ├── raw.js
    │   │       ├── raw.mts
    │   │       └── raw.ts
    │   ├── assets-sanitize/
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── assets-sanitize.spec.ts
    │   ├── backend-integration/
    │   │   ├── package.json
    │   │   ├── references.css
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── backend-integration.spec.ts
    │   │   ├── dir/
    │   │   │   └── foo.css
    │   │   └── frontend/
    │   │       ├── entrypoints/
    │   │       │   ├── foo.pcss
    │   │       │   ├── global.css
    │   │       │   ├── index.html
    │   │       │   ├── main.ts
    │   │       │   └── nested/
    │   │       │       ├── blue.scss
    │   │       │       └── sub.ts
    │   │       └── styles/
    │   │           ├── background.css
    │   │           ├── imported.css
    │   │           ├── tailwind.css
    │   │           └── url.css
    │   ├── build-old/
    │   │   ├── dynamic.js
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── build-old.spec.ts
    │   ├── cli/
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       ├── cli.spec.ts
    │   │       └── serve.ts
    │   ├── cli-module/
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       ├── cli-module.spec.ts
    │   │       └── serve.ts
    │   ├── client-reload/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.ts
    │   │   └── __tests__/
    │   │       ├── client-reload.spec.ts
    │   │       └── serve.ts
    │   ├── csp/
    │   │   ├── dynamic.css
    │   │   ├── dynamic.js
    │   │   ├── from-js.css
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── linked.css
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── csp.spec.ts
    │   ├── css/
    │   │   ├── async-treeshaken.css
    │   │   ├── async-treeshaken.js
    │   │   ├── async.css
    │   │   ├── async.js
    │   │   ├── charset.css
    │   │   ├── composed.module.css
    │   │   ├── composed.module.less
    │   │   ├── composed.module.scss
    │   │   ├── composes-path-resolving.module.css
    │   │   ├── dep.css
    │   │   ├── empty.css
    │   │   ├── file-absolute.scss
    │   │   ├── glob-dep.css
    │   │   ├── imported-at-import.css
    │   │   ├── imported.css
    │   │   ├── imported.scss
    │   │   ├── imports-field.css
    │   │   ├── imports-imports-field.css
    │   │   ├── index.html
    │   │   ├── inline.module.css
    │   │   ├── inlined.css
    │   │   ├── jsfile.css.js
    │   │   ├── less-plugin.less
    │   │   ├── less.less
    │   │   ├── lightningcss-plugins.js
    │   │   ├── linked-at-import.css
    │   │   ├── linked.css
    │   │   ├── main.js
    │   │   ├── manual-chunk.css
    │   │   ├── minify.css
    │   │   ├── mod.module.css
    │   │   ├── mod.module.scss
    │   │   ├── package.json
    │   │   ├── postcss-inject-url.css
    │   │   ├── postcss-source-input.css
    │   │   ├── postcss.config.js
    │   │   ├── raw-imported.css
    │   │   ├── sass.scss
    │   │   ├── stylus.styl
    │   │   ├── sugarss.sss
    │   │   ├── unsupported.css
    │   │   ├── url-imported.css
    │   │   ├── vite.config-lightningcss.js
    │   │   ├── vite.config-no-css-minify.js
    │   │   ├── vite.config-relative-base.js
    │   │   ├── vite.config-same-file-name.js
    │   │   ├── vite.config-sass-modern-compiler-build.js
    │   │   ├── vite.config.js
    │   │   ├── weapp.wxss
    │   │   ├── __tests__/
    │   │   │   ├── css.spec.ts
    │   │   │   ├── sass-tests.ts
    │   │   │   ├── tests.ts
    │   │   │   ├── lightningcss/
    │   │   │   │   └── lightningcss.spec.ts
    │   │   │   ├── no-css-minify/
    │   │   │   │   └── css-no-css-minify.spec.ts
    │   │   │   ├── postcss-plugins-different-dir/
    │   │   │   │   ├── css-postcss-plugins-different-dir.spec.ts
    │   │   │   │   └── serve.ts
    │   │   │   ├── same-file-name/
    │   │   │   │   └── css-same-file-name.spec.ts
    │   │   │   └── sass-modern-compiler-build/
    │   │   │       └── sass-modern-compiler.spec.ts
    │   │   ├── aliased/
    │   │   │   ├── bar.module.css
    │   │   │   └── foo.css
    │   │   ├── async/
    │   │   │   ├── async-1.css
    │   │   │   ├── async-1.js
    │   │   │   ├── async-2.css
    │   │   │   ├── async-2.js
    │   │   │   ├── async-3.js
    │   │   │   ├── async-3.module.css
    │   │   │   ├── base.css
    │   │   │   ├── base.js
    │   │   │   └── index.js
    │   │   ├── css-dep/
    │   │   │   ├── index.css
    │   │   │   ├── index.js
    │   │   │   ├── index.scss
    │   │   │   ├── index.styl
    │   │   │   └── package.json
    │   │   ├── css-dep-exports/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   ├── style.css
    │   │   │   └── style.scss
    │   │   ├── css-js-dep/
    │   │   │   ├── bar.module.css
    │   │   │   ├── foo.css
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── css-proxy-dep/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   ├── css-proxy-dep-nested/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   ├── folder with space/
    │   │   │   └── space.css
    │   │   ├── glob-dep/
    │   │   │   ├── bar.css
    │   │   │   ├── foo.css
    │   │   │   └── nested (dir)/
    │   │   │       └── baz.css
    │   │   ├── glob-import/
    │   │   │   ├── bar.css
    │   │   │   └── foo.css
    │   │   ├── layered/
    │   │   │   ├── blue.css
    │   │   │   ├── green.css
    │   │   │   └── index.css
    │   │   ├── less/
    │   │   │   ├── ommer.less
    │   │   │   └── components/
    │   │   │       └── form.less
    │   │   ├── less-plugin/
    │   │   │   └── test.js
    │   │   ├── nested/
    │   │   │   ├── _index.scss
    │   │   │   ├── _partial.scss
    │   │   │   ├── css-in-less-2.less
    │   │   │   ├── css-in-less.css
    │   │   │   ├── css-in-less.less
    │   │   │   ├── css-in-scss.css
    │   │   │   ├── nested.less
    │   │   │   ├── nested.sss
    │   │   │   ├── nested.styl
    │   │   │   ├── relative.scss
    │   │   │   ├── replacement-alias.scss
    │   │   │   └── root-relative.scss
    │   │   ├── options/
    │   │   │   ├── absolute-import.styl
    │   │   │   └── relative-import.styl
    │   │   ├── pkg-dep/
    │   │   │   ├── _index.scss
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── postcss-caching/
    │   │   │   ├── css.spec.ts
    │   │   │   ├── serve.ts
    │   │   │   ├── blue-app/
    │   │   │   │   ├── imported.css
    │   │   │   │   ├── index.html
    │   │   │   │   ├── main.js
    │   │   │   │   ├── package.json
    │   │   │   │   └── postcss.config.js
    │   │   │   └── green-app/
    │   │   │       ├── imported.css
    │   │   │       ├── index.html
    │   │   │       ├── main.js
    │   │   │       ├── package.json
    │   │   │       └── postcss.config.js
    │   │   ├── same-name/
    │   │   │   ├── sub1/
    │   │   │   │   ├── sub.css
    │   │   │   │   └── sub.js
    │   │   │   └── sub2/
    │   │   │       ├── sub.css
    │   │   │       └── sub.js
    │   │   ├── sass-modern-compiler-build/
    │   │   │   ├── entry1.scss
    │   │   │   └── entry2.scss
    │   │   ├── scss-dir/
    │   │   │   ├── main.scss
    │   │   │   └── dir/
    │   │   │       └── index.scss
    │   │   ├── scss-proxy-dep/
    │   │   │   ├── index.scss
    │   │   │   └── package.json
    │   │   ├── scss-proxy-dep-nested/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   ├── treeshake-module/
    │   │   │   ├── a.js
    │   │   │   ├── a.module.css
    │   │   │   ├── b.js
    │   │   │   ├── b.module.css
    │   │   │   └── index.js
    │   │   └── treeshake-scoped/
    │   │       ├── a-scoped.css
    │   │       ├── a.js
    │   │       ├── b-scoped.css
    │   │       ├── b.js
    │   │       ├── c-scoped.css
    │   │       ├── c.js
    │   │       ├── d-scoped.css
    │   │       ├── d.js
    │   │       ├── index.html
    │   │       ├── index.js
    │   │       └── order/
    │   │           ├── a-scoped.css
    │   │           ├── a.js
    │   │           ├── after.css
    │   │           └── before.css
    │   ├── css-codesplit/
    │   │   ├── async-js.css
    │   │   ├── async-js.js
    │   │   ├── async.css
    │   │   ├── chunk.css
    │   │   ├── index.html
    │   │   ├── inline.css
    │   │   ├── main.css
    │   │   ├── main.js
    │   │   ├── mod.module.css
    │   │   ├── other.js
    │   │   ├── package.json
    │   │   ├── shared-css-empty-1.js
    │   │   ├── shared-css-empty-2.js
    │   │   ├── shared-css-main.js
    │   │   ├── shared-css-no-js.html
    │   │   ├── shared-css-theme.css
    │   │   ├── shared-css-with-js.html
    │   │   ├── style.css
    │   │   ├── style2.css
    │   │   ├── style2.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   ├── css-codesplit-consistent.spec.ts
    │   │   │   └── css-codesplit.spec.ts
    │   │   └── order/
    │   │       ├── base.css
    │   │       ├── dynamic.css
    │   │       ├── index.js
    │   │       └── insert.js
    │   ├── css-codesplit-cjs/
    │   │   ├── index.html
    │   │   ├── main.css
    │   │   ├── main.js
    │   │   ├── other.js
    │   │   ├── package.json
    │   │   ├── style.css
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── css-codesplit-cjs.spec.ts
    │   ├── css-dynamic-import/
    │   │   ├── dynamic.css
    │   │   ├── dynamic.js
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── static.css
    │   │   ├── static.js
    │   │   └── __tests__/
    │   │       ├── css-dynamic-import.spec.ts
    │   │       └── serve.ts
    │   ├── css-lightningcss/
    │   │   ├── composed.module.css
    │   │   ├── composes-path-resolving.module.css
    │   │   ├── css-url.css
    │   │   ├── external-url.css
    │   │   ├── imported-at-import.css
    │   │   ├── imported.css
    │   │   ├── index.html
    │   │   ├── inline.module.css
    │   │   ├── inlined.css
    │   │   ├── linked-at-import.css
    │   │   ├── linked.css
    │   │   ├── main.js
    │   │   ├── minify.css
    │   │   ├── mod.module.css
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── css-lightningcss.spec.ts
    │   │   └── nested/
    │   │       └── nested.css
    │   ├── css-lightningcss-proxy/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   └── __tests__/
    │   │       ├── css-lightningcss-proxy.spec.ts
    │   │       └── serve.ts
    │   ├── css-lightningcss-root/
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── css-lightningcss-root.spec.ts
    │   │   └── root/
    │   │       ├── index.html
    │   │       ├── main.js
    │   │       └── url-dep.css
    │   ├── css-no-codesplit/
    │   │   ├── async-js.css
    │   │   ├── async-js.js
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── shared-linked.css
    │   │   ├── sub.html
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── css-no-codesplit.spec.ts
    │   ├── css-sourcemap/
    │   │   ├── be-imported.css
    │   │   ├── imported-nested.sass
    │   │   ├── imported-with-import.css
    │   │   ├── imported.css
    │   │   ├── imported.less
    │   │   ├── imported.module.sass
    │   │   ├── imported.sass
    │   │   ├── imported.sss
    │   │   ├── imported.styl
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── input-map.css
    │   │   ├── input-map.src.css
    │   │   ├── linked-with-import.css
    │   │   ├── linked.css
    │   │   ├── package.json
    │   │   ├── vite.config-lib-entry.js
    │   │   ├── vite.config-lightningcss.js
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       ├── css-sourcemap.spec.ts
    │   │       ├── lib-entry/
    │   │       │   └── css-sourcemap-lib-entry.spec.ts
    │   │       └── lightningcss/
    │   │           └── lightningcss.spec.ts
    │   ├── data-uri/
    │   │   ├── index.html
    │   │   ├── main.js
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── data-uri.spec.ts
    │   ├── define/
    │   │   ├── data.json
    │   │   ├── index.html
    │   │   ├── optional-env.js
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── define.spec.ts
    │   │   └── commonjs-dep/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── dynamic-import/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── (app)/
    │   │   │   ├── main.js
    │   │   │   └── nest/
    │   │   │       └── index.js
    │   │   ├── __tests__/
    │   │   │   └── dynamic-import.spec.ts
    │   │   ├── alias/
    │   │   │   ├── hello.js
    │   │   │   ├── hi.js
    │   │   │   ├── url.js
    │   │   │   └── worker.js
    │   │   ├── css/
    │   │   │   └── index.css
    │   │   ├── files/
    │   │   │   ├── mxd.js
    │   │   │   └── mxd.json
    │   │   ├── nested/
    │   │   │   ├── deps.js
    │   │   │   ├── hello.js
    │   │   │   ├── index.js
    │   │   │   ├── self.js
    │   │   │   ├── shared.js
    │   │   │   ├── static.js
    │   │   │   ├── nested/
    │   │   │   │   └── self.js
    │   │   │   └── treeshaken/
    │   │   │       ├── syntax.js
    │   │   │       └── treeshaken.js
    │   │   └── views/
    │   │       ├── bar.js
    │   │       ├── baz.js
    │   │       ├── foo.js
    │   │       └── qux.js
    │   ├── dynamic-import-inline/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── dynamic-import-inline.spec.ts
    │   │   └── src/
    │   │       ├── foo.js
    │   │       └── index.js
    │   ├── env-nested/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── env-nested.spec.ts
    │   │   └── envs/
    │   │       ├── .env.development
    │   │       └── .env.production
    │   ├── environment-react-ssr/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   └── environment-react-ssr.spec.ts
    │   │   └── src/
    │   │       ├── entry-client.tsx
    │   │       ├── entry-server.tsx
    │   │       └── root.tsx
    │   ├── extensions/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── extensions.spec.ts
    │   ├── external/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── external.spec.ts
    │   │   ├── dep-that-imports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-that-requires/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── public/
    │   │   │   └── slash@3.0.0.js
    │   │   └── src/
    │   │       └── main.js
    │   ├── fs-serve/
    │   │   ├── entry.js
    │   │   ├── package.json
    │   │   ├── safe.json
    │   │   ├── unsafe.json
    │   │   ├── __tests__/
    │   │   │   ├── fs-serve.spec.ts
    │   │   │   ├── base/
    │   │   │   │   └── fs-serve-base.spec.ts
    │   │   │   └── deny/
    │   │   │       └── fs-serve-deny.spec.ts
    │   │   ├── nested/
    │   │   │   └── foo.js
    │   │   └── root/
    │   │       ├── svgVirtualModulePlugin.ts
    │   │       ├── unsafe.txt
    │   │       ├── vite.config-base.js
    │   │       ├── vite.config-deny.js
    │   │       ├── vite.config.js
    │   │       └── src/
    │   │           ├── code.js
    │   │           ├── dummy.crt
    │   │           ├── index.html
    │   │           ├── safe.txt
    │   │           ├── deny/
    │   │           │   ├── deny.txt
    │   │           │   └── .deny
    │   │           ├── special characters åäö/
    │   │           │   ├── safe.json
    │   │           │   └── safe.txt
    │   │           └── subdir/
    │   │               └── safe.txt
    │   ├── glob-import/
    │   │   ├── index.html
    │   │   ├── no-tree-shake.css
    │   │   ├── package.json
    │   │   ├── tree-shake.css
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   └── glob-import.spec.ts
    │   │   ├── dir/
    │   │   │   ├── alias.js
    │   │   │   ├── baz.json
    │   │   │   ├── foo.css
    │   │   │   ├── foo.js
    │   │   │   ├── index.js
    │   │   │   ├── quote'.js
    │   │   │   ├── nested/
    │   │   │   │   └── bar.js
    │   │   │   └── node_modules/
    │   │   │       └── hoge.js
    │   │   ├── escape/
    │   │   │   ├── (parenthesis)/
    │   │   │   │   ├── glob.js
    │   │   │   │   └── mod/
    │   │   │   │       └── index.js
    │   │   │   ├── [brackets]/
    │   │   │   │   ├── glob.js
    │   │   │   │   └── mod/
    │   │   │   │       └── index.js
    │   │   │   └── {curlies}/
    │   │   │       ├── glob.js
    │   │   │       └── mod/
    │   │   │           └── index.js
    │   │   ├── import-meta-glob-pkg/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── imports-path/
    │   │   │   ├── bar.js
    │   │   │   └── foo.js
    │   │   ├── pkg-pages/
    │   │   │   └── foo.js
    │   │   └── side-effect/
    │   │       ├── writedom.js
    │   │       └── writetodom.js
    │   ├── hmr/
    │   │   ├── customFile.js
    │   │   ├── event.d.ts
    │   │   ├── global.css
    │   │   ├── hmr.ts
    │   │   ├── hmrDep.js
    │   │   ├── hmrNestedDep.js
    │   │   ├── importedVirtual.js
    │   │   ├── index.html
    │   │   ├── modules.d.ts
    │   │   ├── package.json
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   └── hmr.spec.ts
    │   │   ├── accept-exports/
    │   │   │   ├── dynamic-imports/
    │   │   │   │   ├── deps-all-accepted.ts
    │   │   │   │   ├── deps-some-accepted.ts
    │   │   │   │   ├── dynamic-imports.ts
    │   │   │   │   └── index.html
    │   │   │   ├── export-from/
    │   │   │   │   ├── depA.ts
    │   │   │   │   ├── export-from.ts
    │   │   │   │   ├── hub.ts
    │   │   │   │   └── index.html
    │   │   │   ├── main-accepted/
    │   │   │   │   ├── callback.ts
    │   │   │   │   ├── dep.ts
    │   │   │   │   ├── index.html
    │   │   │   │   ├── main-accepted.ts
    │   │   │   │   └── target.ts
    │   │   │   ├── main-non-accepted/
    │   │   │   │   ├── default.ts
    │   │   │   │   ├── dep.ts
    │   │   │   │   ├── index.html
    │   │   │   │   ├── main-non-accepted.ts
    │   │   │   │   └── named.ts
    │   │   │   ├── side-effects/
    │   │   │   │   ├── index.html
    │   │   │   │   └── side-effects.ts
    │   │   │   ├── star-imports/
    │   │   │   │   ├── deps-all-accepted.ts
    │   │   │   │   ├── deps-some-accepted.ts
    │   │   │   │   ├── index.html
    │   │   │   │   └── star-imports.ts
    │   │   │   └── unused-exports/
    │   │   │       ├── index.html
    │   │   │       ├── index.ts
    │   │   │       ├── unused.ts
    │   │   │       └── used.ts
    │   │   ├── circular/
    │   │   │   ├── index.js
    │   │   │   ├── mod-a.js
    │   │   │   ├── mod-b.js
    │   │   │   └── mod-c.js
    │   │   ├── counter/
    │   │   │   ├── dep.ts
    │   │   │   ├── index.html
    │   │   │   └── index.ts
    │   │   ├── css-deps/
    │   │   │   ├── dep.js
    │   │   │   ├── index.html
    │   │   │   └── main.css
    │   │   ├── file-delete-restore/
    │   │   │   ├── child.js
    │   │   │   ├── index.js
    │   │   │   ├── parent.js
    │   │   │   └── runtime.js
    │   │   ├── importing-updated/
    │   │   │   ├── a.js
    │   │   │   ├── b.js
    │   │   │   └── index.js
    │   │   ├── intermediate-file-delete/
    │   │   │   ├── display.js
    │   │   │   ├── index.js
    │   │   │   └── re-export.js
    │   │   ├── invalidation/
    │   │   │   ├── child.js
    │   │   │   ├── parent.js
    │   │   │   └── root.js
    │   │   ├── invalidation-circular-deps/
    │   │   │   ├── index.js
    │   │   │   ├── circular-invalidate/
    │   │   │   │   ├── child.js
    │   │   │   │   └── parent.js
    │   │   │   └── invalidate-handled-in-circle/
    │   │   │       ├── child.js
    │   │   │       └── parent.js
    │   │   ├── missing-file/
    │   │   │   ├── index.html
    │   │   │   └── main.js
    │   │   ├── missing-import/
    │   │   │   ├── a.js
    │   │   │   ├── index.html
    │   │   │   └── main.js
    │   │   ├── optional-chaining/
    │   │   │   ├── child.js
    │   │   │   └── parent.js
    │   │   ├── self-accept-within-circular/
    │   │   │   ├── a.js
    │   │   │   ├── b.js
    │   │   │   ├── c.js
    │   │   │   ├── index.html
    │   │   │   └── index.js
    │   │   ├── soft-invalidation/
    │   │   │   ├── child.js
    │   │   │   └── index.js
    │   │   └── unicode-path/
    │   │       └── 中文-にほんご-한글-🌕🌖🌗/
    │   │           └── index.html
    │   ├── hmr-root/
    │   │   ├── foo.js
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   └── hmr-root.spec.ts
    │   │   └── root/
    │   │       └── index.html
    │   ├── hmr-ssr/
    │   │   ├── customFile.js
    │   │   ├── event.d.ts
    │   │   ├── hmr.ts
    │   │   ├── hmrDep.js
    │   │   ├── hmrNestedDep.js
    │   │   ├── importedVirtual.js
    │   │   ├── modules.d.ts
    │   │   ├── package.json
    │   │   ├── unresolved.ts
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   └── hmr-ssr.spec.ts
    │   │   ├── accept-exports/
    │   │   │   ├── dynamic-imports/
    │   │   │   │   ├── deps-all-accepted.ts
    │   │   │   │   ├── deps-some-accepted.ts
    │   │   │   │   ├── dynamic-imports.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── export-from/
    │   │   │   │   ├── depA.ts
    │   │   │   │   ├── export-from.ts
    │   │   │   │   ├── hub.ts
    │   │   │   │   └── index.html
    │   │   │   ├── main-accepted/
    │   │   │   │   ├── callback.ts
    │   │   │   │   ├── dep.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── main-accepted.ts
    │   │   │   │   └── target.ts
    │   │   │   ├── main-non-accepted/
    │   │   │   │   ├── default.ts
    │   │   │   │   ├── dep.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── main-non-accepted.ts
    │   │   │   │   └── named.ts
    │   │   │   ├── side-effects/
    │   │   │   │   ├── index.ts
    │   │   │   │   └── side-effects.ts
    │   │   │   ├── star-imports/
    │   │   │   │   ├── deps-all-accepted.ts
    │   │   │   │   ├── deps-some-accepted.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── star-imports.ts
    │   │   │   └── unused-exports/
    │   │   │       ├── index.html
    │   │   │       ├── index.ts
    │   │   │       ├── unused.ts
    │   │   │       └── used.ts
    │   │   ├── circular/
    │   │   │   ├── index.js
    │   │   │   ├── mod-a.js
    │   │   │   ├── mod-b.js
    │   │   │   └── mod-c.js
    │   │   ├── counter/
    │   │   │   ├── dep.ts
    │   │   │   └── index.ts
    │   │   ├── file-delete-restore/
    │   │   │   ├── child.js
    │   │   │   ├── index.js
    │   │   │   ├── parent.js
    │   │   │   └── runtime.js
    │   │   ├── importing-updated/
    │   │   │   ├── a.js
    │   │   │   ├── b.js
    │   │   │   └── index.js
    │   │   ├── intermediate-file-delete/
    │   │   │   ├── display.js
    │   │   │   ├── index.js
    │   │   │   └── re-export.js
    │   │   ├── invalidation/
    │   │   │   ├── child.js
    │   │   │   └── parent.js
    │   │   ├── invalidation-circular-deps/
    │   │   │   ├── index.js
    │   │   │   ├── circular-invalidate/
    │   │   │   │   ├── child.js
    │   │   │   │   └── parent.js
    │   │   │   └── invalidate-handled-in-circle/
    │   │   │       ├── child.js
    │   │   │       └── parent.js
    │   │   ├── missing-import/
    │   │   │   ├── a.js
    │   │   │   ├── index.js
    │   │   │   └── main.js
    │   │   ├── non-tested/
    │   │   │   ├── dep.js
    │   │   │   └── index.js
    │   │   ├── optional-chaining/
    │   │   │   ├── child.js
    │   │   │   └── parent.js
    │   │   ├── queries/
    │   │   │   ├── index.js
    │   │   │   └── multi-query.js
    │   │   ├── self-accept-within-circular/
    │   │   │   ├── a.js
    │   │   │   ├── b.js
    │   │   │   ├── c.js
    │   │   │   └── index.js
    │   │   └── soft-invalidation/
    │   │       ├── child.js
    │   │       └── index.js
    │   ├── html/
    │   │   ├── a á.html
    │   │   ├── common.css
    │   │   ├── emptyAttr.html
    │   │   ├── env.html
    │   │   ├── foo.html
    │   │   ├── importmapOrder.html
    │   │   ├── index.html
    │   │   ├── invalid.html
    │   │   ├── invalidClick.html
    │   │   ├── invalidEscape.html
    │   │   ├── link.html
    │   │   ├── main.css
    │   │   ├── main.js
    │   │   ├── noBody.html
    │   │   ├── noHead.html
    │   │   ├── package.json
    │   │   ├── relative-input.html
    │   │   ├── scriptAsync.html
    │   │   ├── scriptMixed.html
    │   │   ├── shared.js
    │   │   ├── transform-inline-js.html
    │   │   ├── valid.html
    │   │   ├── valid.js
    │   │   ├── vite.config.js
    │   │   ├── write.html
    │   │   ├── zeroJS.html
    │   │   ├── __tests__/
    │   │   │   └── html.spec.ts
    │   │   ├── inline/
    │   │   │   ├── common.js
    │   │   │   ├── dep1.js
    │   │   │   ├── dep2.js
    │   │   │   ├── dep3.js
    │   │   │   ├── module-graph.dot
    │   │   │   ├── shared-1.html
    │   │   │   ├── shared-2.html
    │   │   │   ├── shared.js
    │   │   │   ├── shared_a.html
    │   │   │   ├── unique.html
    │   │   │   └── unique.js
    │   │   ├── link-props/
    │   │   │   ├── index.html
    │   │   │   ├── print.css
    │   │   │   └── screen.css
    │   │   ├── nested/
    │   │   │   ├── index.html
    │   │   │   ├── nested.css
    │   │   │   ├── nested.js
    │   │   │   └── asset/
    │   │   │       ├── main.js
    │   │   │       └── style.css
    │   │   ├── relative-input/
    │   │   │   └── main.js
    │   │   ├── serve/
    │   │   │   ├── both.html
    │   │   │   ├── file.html
    │   │   │   ├── both/
    │   │   │   │   └── index.html
    │   │   │   └── folder/
    │   │   │       └── index.html
    │   │   ├── side-effects/
    │   │   │   ├── index.html
    │   │   │   ├── package.json
    │   │   │   └── sideEffects.js
    │   │   ├── unicode-path/
    │   │   │   └── 中文-にほんご-한글-🌕🌖🌗/
    │   │   │       └── index.html
    │   │   └── warmup/
    │   │       └── warm.js
    │   ├── import-assertion/
    │   │   ├── data.json
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── __tests__/
    │   │   │   └── import-assertion.spec.ts
    │   │   └── import-assertion-dep/
    │   │       ├── data.json
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── js-sourcemap/
    │   │   ├── after-preload-dynamic-hashbang.js
    │   │   ├── after-preload-dynamic-no-dep.js
    │   │   ├── after-preload-dynamic.js
    │   │   ├── bar.ts
    │   │   ├── foo-with-sourcemap-plugin.ts
    │   │   ├── foo-with-sourcemap.js
    │   │   ├── foo.js
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── plugin-foo.js
    │   │   ├── test-ssr-dev.js
    │   │   ├── vite.config.js
    │   │   ├── with-define-object-ssr.ts
    │   │   ├── with-define-object.ts
    │   │   ├── with-multiline-import.ts
    │   │   ├── zoo-with-sourcemap-plugin.ts
    │   │   ├── zoo.js
    │   │   ├── __tests__/
    │   │   │   └── js-sourcemap.spec.ts
    │   │   ├── dynamic/
    │   │   │   ├── dynamic-foo.css
    │   │   │   ├── dynamic-foo.js
    │   │   │   └── dynamic-no-dep.js
    │   │   └── importee-pkg/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── json/
    │   │   ├── hmr.json
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── test.json
    │   │   ├── __tests__/
    │   │   │   └── csr/
    │   │   │       └── json-csr.spec.ts
    │   │   ├── dep-json-require/
    │   │   │   ├── content.json
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── json-bom/
    │   │   │   └── has-bom.json
    │   │   ├── json-module/
    │   │   │   ├── index.json
    │   │   │   └── package.json
    │   │   └── public/
    │   │       └── public.json
    │   ├── legacy/
    │   │   ├── async.js
    │   │   ├── custom0.js
    │   │   ├── custom1.js
    │   │   ├── custom2.js
    │   │   ├── dynamic.css
    │   │   ├── entry-server-sequential.js
    │   │   ├── entry-server.js
    │   │   ├── immutable-chunk.js
    │   │   ├── index.html
    │   │   ├── main.js
    │   │   ├── module.js
    │   │   ├── no-polyfills-no-systemjs.html
    │   │   ├── no-polyfills-no-systemjs.js
    │   │   ├── no-polyfills.html
    │   │   ├── no-polyfills.js
    │   │   ├── package.json
    │   │   ├── style-only-entry.css
    │   │   ├── style.css
    │   │   ├── vite.config-custom-filename.js
    │   │   ├── vite.config-multiple-output.js
    │   │   ├── vite.config-no-polyfills-no-systemjs.js
    │   │   ├── vite.config-no-polyfills.js
    │   │   ├── vite.config-watch.js
    │   │   ├── vite.config.js
    │   │   ├── worker.js
    │   │   ├── __tests__/
    │   │   │   ├── legacy.spec.ts
    │   │   │   ├── client-and-ssr/
    │   │   │   │   ├── legacy-client-legacy-ssr-sequential-builds.spec.ts
    │   │   │   │   └── serve.ts
    │   │   │   ├── no-polyfills/
    │   │   │   │   └── legacy-no-polyfills.spec.ts
    │   │   │   ├── no-polyfills-no-systemjs/
    │   │   │   │   └── legacy-no-polyfills-no-systemjs.spec.ts
    │   │   │   ├── ssr/
    │   │   │   │   ├── legacy-ssr.spec.ts
    │   │   │   │   └── serve.ts
    │   │   │   └── watch/
    │   │   │       └── legacy-styles-only-entry-watch.spec.ts
    │   │   └── nested/
    │   │       └── index.html
    │   ├── lib/
    │   │   ├── index.dist.html
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── vite.css-code-split.config.js
    │   │   ├── vite.css-multi-entry.config.js
    │   │   ├── vite.css-single-entry.config.js
    │   │   ├── vite.dyimport.config.js
    │   │   ├── vite.helpers-injection.config.js
    │   │   ├── vite.multiple-output.config.js
    │   │   ├── vite.named-exports.config.js
    │   │   ├── vite.nominify.config.js
    │   │   ├── __tests__/
    │   │   │   ├── lib.spec.ts
    │   │   │   └── serve.ts
    │   │   └── src/
    │   │       ├── css-entry-1.js
    │   │       ├── css-entry-2.js
    │   │       ├── dynamic.css
    │   │       ├── entry-1.css
    │   │       ├── entry-2.css
    │   │       ├── index.css
    │   │       ├── main-helpers-injection.js
    │   │       ├── main-multiple-output.js
    │   │       ├── main-named.js
    │   │       ├── main.js
    │   │       ├── main2.js
    │   │       ├── message.js
    │   │       └── sub-multiple-output.js
    │   ├── minify/
    │   │   ├── index.html
    │   │   ├── main.js
    │   │   ├── package.json
    │   │   ├── test.css
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── minify.spec.ts
    │   │   └── dir/
    │   │       └── module/
    │   │           ├── index.css
    │   │           ├── index.js
    │   │           └── package.json
    │   ├── module-graph/
    │   │   ├── empty.js
    │   │   ├── imported-urls-order.js
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.ts
    │   │   └── __tests__/
    │   │       └── module-graph.spec.ts
    │   ├── multiple-entrypoints/
    │   │   ├── deps.json
    │   │   ├── dynamic-a.js
    │   │   ├── dynamic-b.js
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── reference.js
    │   │   ├── reference.scss
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── multiple-entrypoints.spec.ts
    │   │   └── entrypoints/
    │   │       ├── a0.js
    │   │       ├── a1.js
    │   │       ├── a10.js
    │   │       ├── a11.js
    │   │       ├── a12.js
    │   │       ├── a13.js
    │   │       ├── a14.js
    │   │       ├── a15.js
    │   │       ├── a16.js
    │   │       ├── a17.js
    │   │       ├── a18.js
    │   │       ├── a19.js
    │   │       ├── a2.js
    │   │       ├── a20.js
    │   │       ├── a21.js
    │   │       ├── a22.js
    │   │       ├── a23.js
    │   │       ├── a24.js
    │   │       ├── a3.js
    │   │       ├── a4.js
    │   │       ├── a5.js
    │   │       ├── a6.js
    │   │       ├── a7.js
    │   │       ├── a8.js
    │   │       └── a9.js
    │   ├── nested-deps/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── nested-deps.spec.ts
    │   │   ├── test-package-a/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── test-package-b/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── test-package-c/
    │   │   │   ├── index-es.js
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── side.js
    │   │   ├── test-package-d/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── test-package-d-nested/
    │   │   │       ├── index.js
    │   │   │       └── package.json
    │   │   ├── test-package-e/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   ├── test-package-e-excluded/
    │   │   │   │   ├── index.js
    │   │   │   │   └── package.json
    │   │   │   └── test-package-e-included/
    │   │   │       ├── index.js
    │   │   │       └── package.json
    │   │   └── test-package-f/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── object-hooks/
    │   │   ├── index.html
    │   │   ├── main.ts
    │   │   ├── package.json
    │   │   ├── vite.config.ts
    │   │   └── __tests__/
    │   │       └── object-hooks.spec.ts
    │   ├── optimize-deps/
    │   │   ├── cjs-dynamic.js
    │   │   ├── cjs.js
    │   │   ├── dedupe.js
    │   │   ├── dynamic-use-dep-alias-using-absolute-path.js
    │   │   ├── generics.vue
    │   │   ├── index.astro
    │   │   ├── index.html
    │   │   ├── long-file-name.js
    │   │   ├── package.json
    │   │   ├── unused-split-entry.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── optimize-deps.spec.ts
    │   │   ├── added-in-entries/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-alias-using-absolute-path/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-cjs-browser-field-bare/
    │   │   │   ├── events-shim.js
    │   │   │   ├── index.js
    │   │   │   ├── internal.js
    │   │   │   └── package.json
    │   │   ├── dep-cjs-compiled-from-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-cjs-compiled-from-esm/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-cjs-external-package-omit-js-suffix/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   ├── test.astro.js
    │   │   │   ├── test.okay.js
    │   │   │   ├── test.scss.js
    │   │   │   └── test.tsx.js
    │   │   ├── dep-cjs-with-assets/
    │   │   │   ├── foo.css
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-cjs-with-external-deps/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-css-require/
    │   │   │   ├── index.cjs
    │   │   │   ├── mod.cjs
    │   │   │   ├── mod.module.css
    │   │   │   ├── package.json
    │   │   │   └── style.css
    │   │   ├── dep-esbuild-plugin-transform/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-esm-dummy-node-builtin/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-esm-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-incompatible/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── sub.js
    │   │   ├── dep-linked/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-linked-include/
    │   │   │   ├── foo.js
    │   │   │   ├── index.mjs
    │   │   │   ├── package.json
    │   │   │   ├── test.css
    │   │   │   └── Test.vue
    │   │   ├── dep-node-env/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-non-optimized/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-not-js/
    │   │   │   ├── foo.js
    │   │   │   ├── index.notjs
    │   │   │   └── package.json
    │   │   ├── dep-optimize-exports-with-glob/
    │   │   │   ├── index.js
    │   │   │   ├── named.js
    │   │   │   ├── package.json
    │   │   │   └── glob/
    │   │   │       ├── bar.js
    │   │   │       ├── foo.js
    │   │   │       └── nested/
    │   │   │           └── baz.js
    │   │   ├── dep-optimize-exports-with-root-glob/
    │   │   │   ├── file1.js
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── dir/
    │   │   │       └── file2.js
    │   │   ├── dep-optimize-with-glob/
    │   │   │   ├── index.js
    │   │   │   ├── named.js
    │   │   │   ├── package.json
    │   │   │   └── glob/
    │   │   │       ├── bar.js
    │   │   │       ├── foo.js
    │   │   │       └── nested/
    │   │   │           └── baz.js
    │   │   ├── dep-relative-to-main/
    │   │   │   ├── entry.js
    │   │   │   ├── package.json
    │   │   │   └── lib/
    │   │   │       └── main.js
    │   │   ├── dep-source-map-no-sources/
    │   │   │   ├── all.js
    │   │   │   ├── package.json
    │   │   │   └── sub.js
    │   │   ├── dep-with-asset-ext/
    │   │   │   ├── dep1/
    │   │   │   │   ├── index.mjs
    │   │   │   │   └── package.json
    │   │   │   └── dep2/
    │   │   │       ├── index.js
    │   │   │       └── package.json
    │   │   ├── dep-with-builtin-module-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-with-builtin-module-esm/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-with-dynamic-import/
    │   │   │   ├── dynamic.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-with-optional-peer-dep/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-with-optional-peer-dep-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-with-optional-peer-dep-submodule/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── glob/
    │   │   │   └── foo.js
    │   │   ├── longfilename/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── nested-exclude/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── nested-include/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── non-optimizable-include/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   └── .hidden-dir/
    │   │       └── foo.js
    │   ├── optimize-deps-no-discovery/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── optimize-deps-no-discovery.spec.ts
    │   │   └── dep-no-discovery/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── optimize-missing-deps/
    │   │   ├── index.html
    │   │   ├── main.js
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── __test__/
    │   │   │   ├── optimize-missing-deps.spec.ts
    │   │   │   └── serve.ts
    │   │   ├── missing-dep/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   └── multi-entry-dep/
    │   │       ├── index.browser.js
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── preload/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config-preload-disabled.js
    │   │   ├── vite.config-resolve-deps.js
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   ├── preload.spec.ts
    │   │   │   ├── preload-disabled/
    │   │   │   │   └── preload-disabled.spec.ts
    │   │   │   └── resolve-deps/
    │   │   │       └── preload-resolve-deps.spec.ts
    │   │   ├── dep-a/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dep-including-a/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── public/
    │   │   │   └── preloaded.js
    │   │   └── src/
    │   │       ├── about.js
    │   │       ├── chunk.js
    │   │       ├── hello.js
    │   │       ├── hello.module.css
    │   │       └── main.js
    │   ├── preserve-symlinks/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── __tests__/
    │   │   │   └── preserve-symlinks.spec.ts
    │   │   ├── module-a/
    │   │   │   ├── package.json
    │   │   │   ├── linked.js -> index.js
    │   │   │   └── src/
    │   │   │       ├── data.js
    │   │   │       └── index.js
    │   │   └── src/
    │   │       └── main.js
    │   ├── proxy-bypass/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── proxy-bypass.spec.ts
    │   ├── proxy-hmr/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   ├── proxy-hmr.spec.ts
    │   │   │   └── serve.ts
    │   │   └── other-app/
    │   │       ├── index.html
    │   │       ├── package.json
    │   │       └── vite.config.js
    │   ├── resolve/
    │   │   ├── absolute.js
    │   │   ├── config-dep.cjs
    │   │   ├── custom-ext.es
    │   │   ├── dir.js
    │   │   ├── drive-relative.js
    │   │   ├── file-url.js
    │   │   ├── index.html
    │   │   ├── non-normalized.js
    │   │   ├── package.json
    │   │   ├── style.css
    │   │   ├── vite.config-mainfields-custom-first.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   ├── resolve.spec.ts
    │   │   │   └── mainfields-custom-first/
    │   │   │       └── resolve-mainfields-custom-first.spec.ts
    │   │   ├── browser-field/
    │   │   │   ├── bare-import.js
    │   │   │   ├── multiple.dot.path.js
    │   │   │   ├── no-ext.js
    │   │   │   ├── not-browser.js
    │   │   │   ├── package.json
    │   │   │   ├── relative.js
    │   │   │   └── no-ext-index/
    │   │   │       └── index.js
    │   │   ├── browser-field-bare-import-fail/
    │   │   │   ├── main.js
    │   │   │   ├── module.js
    │   │   │   └── package.json
    │   │   ├── browser-field-bare-import-success/
    │   │   │   ├── main.js
    │   │   │   ├── module.js
    │   │   │   └── package.json
    │   │   ├── browser-module-field1/
    │   │   │   ├── index.js
    │   │   │   ├── index.web.js
    │   │   │   └── package.json
    │   │   ├── browser-module-field2/
    │   │   │   ├── index.js
    │   │   │   ├── index.web.js
    │   │   │   └── package.json
    │   │   ├── browser-module-field3/
    │   │   │   ├── index.js
    │   │   │   ├── index.web.js
    │   │   │   └── package.json
    │   │   ├── custom-browser-main-field/
    │   │   │   ├── index.browser.js
    │   │   │   ├── index.custom.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── custom-condition/
    │   │   │   ├── index.custom.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── custom-main-field/
    │   │   │   ├── index.custom.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── dir/
    │   │   │   └── index.js
    │   │   ├── dir-with-ext/
    │   │   │   └── index.js
    │   │   ├── dir-with-ext.js/
    │   │   │   └── empty
    │   │   ├── exact-extension/
    │   │   │   ├── file.js
    │   │   │   ├── file.js.js
    │   │   │   └── file.json.js
    │   │   ├── exports-and-nested-scope/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── nested-scope/
    │   │   │       ├── file.js
    │   │   │       └── package.json
    │   │   ├── exports-env/
    │   │   │   ├── browser.js
    │   │   │   ├── browser.mjs
    │   │   │   ├── browser.prod.mjs
    │   │   │   ├── fallback.umd.js
    │   │   │   └── package.json
    │   │   ├── exports-from-root/
    │   │   │   ├── file.js
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── nested/
    │   │   │       ├── file.js
    │   │   │       └── package.json
    │   │   ├── exports-legacy-fallback/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   └── dir/
    │   │   │       ├── index.js
    │   │   │       ├── index.mjs
    │   │   │       └── package.json
    │   │   ├── exports-path/
    │   │   │   ├── cjs.js
    │   │   │   ├── deep.js
    │   │   │   ├── deep.json
    │   │   │   ├── main.js
    │   │   │   ├── package.json
    │   │   │   └── dir/
    │   │   │       └── dir.js
    │   │   ├── exports-with-module/
    │   │   │   ├── import.mjs
    │   │   │   ├── module.mjs
    │   │   │   └── package.json
    │   │   ├── exports-with-module-condition/
    │   │   │   ├── index.esm.js
    │   │   │   ├── index.js
    │   │   │   ├── index.mjs
    │   │   │   └── package.json
    │   │   ├── exports-with-module-condition-required/
    │   │   │   ├── index.cjs
    │   │   │   └── package.json
    │   │   ├── imports-path/
    │   │   │   ├── nested-path.js
    │   │   │   ├── query.json
    │   │   │   ├── same-level.js
    │   │   │   ├── top-level.js
    │   │   │   ├── other-pkg/
    │   │   │   │   ├── package.json
    │   │   │   │   └── nest/
    │   │   │   │       └── index.js
    │   │   │   ├── slash/
    │   │   │   │   └── index.js
    │   │   │   └── star/
    │   │   │       └── index.js
    │   │   ├── inline-package/
    │   │   │   ├── inline.js
    │   │   │   └── package.json
    │   │   ├── public/
    │   │   │   └── should-not-be-copied
    │   │   ├── require-pkg-with-module-field/
    │   │   │   ├── dep.cjs
    │   │   │   ├── index.cjs
    │   │   │   └── package.json
    │   │   ├── sharp-dir/
    │   │   │   ├── index.cjs
    │   │   │   └── package.json
    │   │   ├── side-effects-glob/
    │   │   │   ├── index.js
    │   │   │   ├── no-effect.js
    │   │   │   ├── package.json
    │   │   │   └── effects/
    │   │   │       └── file.js
    │   │   ├── ts-extension/
    │   │   │   ├── hello.ts
    │   │   │   ├── hellocjs.cts
    │   │   │   ├── hellojsx.tsx
    │   │   │   ├── hellomjs.mts
    │   │   │   ├── hellotsx.tsx
    │   │   │   ├── index-js.js
    │   │   │   └── index.ts
    │   │   ├── utf8-bom/
    │   │   │   └── main.js
    │   │   ├── utf8-bom-package/
    │   │   │   ├── index.mjs
    │   │   │   └── package.json
    │   │   └── util/
    │   │       ├── bar.util.js
    │   │       └── index.js
    │   ├── resolve-linked/
    │   │   ├── dep.js
    │   │   ├── package.json
    │   │   └── src/
    │   │       └── index.js
    │   ├── self-referencing/
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   └── test/
    │   │       └── index.js
    │   ├── ssr/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── vite.config.ts
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr.spec.ts
    │   │   └── src/
    │   │       ├── app.js
    │   │       ├── utils.js
    │   │       ├── circular-dep-init/
    │   │       │   ├── README.md
    │   │       │   ├── circular-dep-init.js
    │   │       │   ├── module-a.js
    │   │       │   └── module-b.js
    │   │       ├── circular-import/
    │   │       │   ├── a.js
    │   │       │   ├── b.js
    │   │       │   └── index.js
    │   │       ├── circular-import2/
    │   │       │   ├── a.js
    │   │       │   ├── b.js
    │   │       │   └── index.js
    │   │       └── forked-deadlock/
    │   │           ├── README.md
    │   │           ├── common-module.js
    │   │           ├── deadlock-fuse-module.js
    │   │           ├── fuse-stuck-bridge-module.js
    │   │           ├── middle-module.js
    │   │           ├── stuck-module.js
    │   │           └── dynamic-imports/
    │   │               ├── common-module.js
    │   │               ├── deadlock-fuse-module.js
    │   │               ├── fuse-stuck-bridge-module.js
    │   │               ├── middle-module.js
    │   │               └── stuck-module.js
    │   ├── ssr-alias/
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── ssr-alias.spec.ts
    │   │   ├── alias-original/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   └── src/
    │   │       ├── alias-process.js
    │   │       ├── alias-replaced.js
    │   │       └── main.js
    │   ├── ssr-conditions/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-conditions.spec.ts
    │   │   ├── external/
    │   │   │   ├── browser.js
    │   │   │   ├── default.js
    │   │   │   ├── edge.js
    │   │   │   ├── node.js
    │   │   │   ├── node.unbundled.js
    │   │   │   └── package.json
    │   │   ├── no-external/
    │   │   │   ├── browser.js
    │   │   │   ├── default.js
    │   │   │   ├── edge.js
    │   │   │   ├── node.js
    │   │   │   ├── node.unbundled.js
    │   │   │   └── package.json
    │   │   └── src/
    │   │       └── app.js
    │   ├── ssr-deps/
    │   │   ├── index.html
    │   │   ├── message
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-deps.spec.ts
    │   │   ├── css-lib/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   ├── define-properties-exports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── define-property-exports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── external-entry/
    │   │   │   ├── entry.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── external-using-external-entry/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── forwarded-export/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── import-builtin-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── linked-no-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── module-condition/
    │   │   │   ├── import.mjs
    │   │   │   ├── module.js
    │   │   │   └── package.json
    │   │   ├── nested-exclude/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── nested-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── nested-external-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── nested-include/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── no-external-cjs/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── no-external-css/
    │   │   │   ├── index.css
    │   │   │   └── package.json
    │   │   ├── non-optimized-with-nested-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── object-assigned-exports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── only-object-assigned-exports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── optimized-cjs-with-nested-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── optimized-with-nested-external/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── pkg-exports/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── primitive-export/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── read-file-content/
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── require-absolute/
    │   │   │   ├── foo.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   ├── src/
    │   │   │   ├── app.js
    │   │   │   ├── isomorphic-module-browser.js
    │   │   │   └── isomorphic-module-server.js
    │   │   └── ts-transpiled-exports/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── ssr-html/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── test-network-imports.js
    │   │   ├── test-stacktrace-runtime.js
    │   │   ├── test-stacktrace.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-html.spec.ts
    │   │   ├── public/
    │   │   │   └── slash@3.0.0.js
    │   │   └── src/
    │   │       ├── app.js
    │   │       ├── error-js.js
    │   │       ├── error-ts.ts
    │   │       ├── has-error-deep.ts
    │   │       ├── importedVirtual.js
    │   │       └── network-imports.js
    │   ├── ssr-noexternal/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-noexternal.spec.ts
    │   │   ├── external-cjs/
    │   │   │   ├── import.mjs
    │   │   │   ├── package.json
    │   │   │   └── require.cjs
    │   │   ├── require-external-cjs/
    │   │   │   ├── main.js
    │   │   │   └── package.json
    │   │   └── src/
    │   │       └── entry-server.js
    │   ├── ssr-pug/
    │   │   ├── index.pug
    │   │   ├── package.json
    │   │   ├── server.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-pug.spec.ts
    │   │   └── src/
    │   │       └── app.js
    │   ├── ssr-resolve/
    │   │   ├── main.js
    │   │   ├── package.json
    │   │   ├── util.js
    │   │   ├── vite.config.js
    │   │   ├── __tests__/
    │   │   │   └── ssr-resolve.spec.ts
    │   │   ├── deep-import/
    │   │   │   ├── index.js
    │   │   │   ├── package.json
    │   │   │   ├── bar/
    │   │   │   │   └── package.json
    │   │   │   ├── foo/
    │   │   │   │   ├── index.js
    │   │   │   │   └── package.json
    │   │   │   └── utils/
    │   │   │       └── bar.js
    │   │   ├── entries/
    │   │   │   ├── file.js
    │   │   │   ├── package.json
    │   │   │   └── dir/
    │   │   │       └── index.js
    │   │   ├── pkg-exports/
    │   │   │   ├── entry.js
    │   │   │   ├── index.js
    │   │   │   └── package.json
    │   │   └── pkg-module-sync/
    │   │       ├── index.js
    │   │       └── package.json
    │   ├── ssr-webworker/
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   ├── worker.js
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── ssr-webworker.spec.ts
    │   │   ├── browser-exports/
    │   │   │   ├── browser.js
    │   │   │   ├── node.js
    │   │   │   └── package.json
    │   │   ├── src/
    │   │   │   ├── dynamic.js
    │   │   │   └── entry-worker.jsx
    │   │   └── worker-exports/
    │   │       ├── browser.js
    │   │       ├── node.js
    │   │       ├── package.json
    │   │       └── worker.js
    │   ├── tailwind/
    │   │   ├── index.css
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── tailwind.config.ts
    │   │   ├── vite.config.ts
    │   │   ├── __test__/
    │   │   │   └── tailwind.spec.ts
    │   │   └── src/
    │   │       ├── main.js
    │   │       ├── components/
    │   │       │   └── component1.js
    │   │       └── views/
    │   │           └── view1.js
    │   ├── tailwind-sourcemap/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── postcss.config.js
    │   │   ├── tailwind.css
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       └── tailwind-sourcemap.spec.ts
    │   ├── tailwind-v3/
    │   │   ├── index.css
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── postcss.config.js
    │   │   ├── tailwind.config.ts
    │   │   ├── vite.config.ts
    │   │   ├── __test__/
    │   │   │   └── tailwind-v3.spec.ts
    │   │   └── src/
    │   │       ├── main.js
    │   │       ├── components/
    │   │       │   └── component1.js
    │   │       └── views/
    │   │           └── view1.js
    │   ├── transform-plugin/
    │   │   ├── index.html
    │   │   ├── index.js
    │   │   ├── package.json
    │   │   ├── plugin-dep-load.js
    │   │   ├── plugin-dep.js
    │   │   ├── vite.config-base.js
    │   │   ├── vite.config.js
    │   │   └── __tests__/
    │   │       ├── tests.ts
    │   │       ├── transform-plugin.spec.ts
    │   │       └── base/
    │   │           └── transform-plugin.spec.ts
    │   ├── tsconfig-json/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── __tests__/
    │   │   │   └── tsconfig-json.spec.ts
    │   │   ├── nested/
    │   │   │   ├── main.ts
    │   │   │   ├── not-used-type.ts
    │   │   │   └── tsconfig.json
    │   │   ├── nested-with-extends/
    │   │   │   ├── main.ts
    │   │   │   ├── not-used-type.ts
    │   │   │   └── tsconfig.json
    │   │   └── src/
    │   │       ├── decorator.ts
    │   │       ├── main.ts
    │   │       └── not-used-type.ts
    │   ├── tsconfig-json-load-error/
    │   │   ├── index.html
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── __tests__/
    │   │   │   ├── serve.ts
    │   │   │   └── tsconfig-json-load-error.spec.ts
    │   │   ├── has-error/
    │   │   │   ├── main.ts
    │   │   │   └── tsconfig.json
    │   │   └── src/
    │   │       └── main.ts
    │   ├── wasm/
    │   │   ├── add.wasm
    │   │   ├── heavy.wasm
    │   │   ├── index.html
    │   │   ├── light.wasm
    │   │   ├── package.json
    │   │   ├── vite.config.ts
    │   │   ├── worker.js
    │   │   └── __tests__/
    │   │       └── wasm.spec.ts
    │   └── worker/
    │       ├── classic-esm.js
    │       ├── classic-shared-worker.js
    │       ├── classic-worker.js
    │       ├── deeply-nested-second-worker.js
    │       ├── deeply-nested-third-worker.js
    │       ├── deeply-nested-worker.js
    │       ├── emit-chunk-dynamic-import-worker.js
    │       ├── emit-chunk-nested-worker.js
    │       ├── emit-chunk-sub-worker.js
    │       ├── importMetaGlob.worker.js
    │       ├── importMetaGlobEager.worker.js
    │       ├── index.html
    │       ├── module-and-worker.js
    │       ├── my-inline-shared-worker.ts
    │       ├── my-shared-worker.ts
    │       ├── my-worker.ts
    │       ├── package.json
    │       ├── possible-ts-output-worker.mjs
    │       ├── self-reference-url-worker.js
    │       ├── self-reference-worker.js
    │       ├── simple-worker.js
    │       ├── sub-worker.js
    │       ├── url-shared-worker.js
    │       ├── url-worker.js
    │       ├── vite.config-es.js
    │       ├── vite.config-iife.js
    │       ├── vite.config-relative-base-iife.js
    │       ├── vite.config-relative-base.js
    │       ├── vite.config-sourcemap-hidden.js
    │       ├── vite.config-sourcemap-inline.js
    │       ├── vite.config-sourcemap.js
    │       ├── worker-nested-worker.js
    │       ├── worker-plugin-test-plugin.js
    │       ├── worker-sourcemap-config.js
    │       ├── __tests__/
    │       │   ├── es/
    │       │   │   └── worker-es.spec.ts
    │       │   ├── iife/
    │       │   │   └── worker-iife.spec.ts
    │       │   ├── relative-base/
    │       │   │   └── worker-relative-base.spec.ts
    │       │   ├── relative-base-iife/
    │       │   │   └── worker-relative-base-iife.spec.ts
    │       │   ├── sourcemap/
    │       │   │   └── worker-sourcemap.spec.ts
    │       │   ├── sourcemap-hidden/
    │       │   │   └── worker-sourcemap-hidden.spec.ts
    │       │   └── sourcemap-inline/
    │       │       └── worker-sourcemap-inline.spec.ts
    │       ├── dep-cjs/
    │       │   ├── index.cjs
    │       │   └── package.json
    │       ├── dep-self-reference-url-worker/
    │       │   ├── index.js
    │       │   ├── package.json
    │       │   └── worker.js
    │       ├── dep-to-optimize/
    │       │   ├── index.js
    │       │   └── package.json
    │       ├── modules/
    │       │   ├── module0.js
    │       │   ├── module1.js
    │       │   ├── module2.js
    │       │   ├── module3.js
    │       │   ├── test-plugin.js
    │       │   └── workerImport.ts
    │       ├── public/
    │       │   └── classic.js
    │       └── worker/
    │           ├── main-classic.js
    │           ├── main-deeply-nested.js
    │           ├── main-format-es.js
    │           ├── main-module.js
    │           ├── main-url.js
    │           └── main.js
    ├── scripts/
    │   ├── docs-check.sh
    │   ├── publishCI.ts
    │   ├── release.ts
    │   ├── releaseUtils.ts
    │   └── tsconfig.json
    ├── .github/
    │   ├── commit-convention.md
    │   ├── copilot-instructions.md
    │   ├── PULL_REQUEST_TEMPLATE.md
    │   ├── renovate.json5
    │   ├── ISSUE_TEMPLATE/
    │   │   ├── bug_report.yml
    │   │   ├── config.yml
    │   │   ├── docs.yml
    │   │   └── feature_request.yml
    │   └── workflows/
    │       ├── ci.yml
    │       ├── copilot-setup-steps.yml
    │       ├── ecosystem-ci-trigger.yml
    │       ├── issue-close-require.yml
    │       ├── issue-labeled.yml
    │       ├── lock-closed-issues.yml
    │       ├── preview-release.yml
    │       ├── publish.yml
    │       ├── release-tag.yml
    │       └── semantic-pull-request.yml
    └── .stackblitz/
        └── codeflow.json

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Code Of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

- The use of sexualized language or imagery and unwelcome sexual attention or advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team by DM at [Vite Land](https://chat.vite.dev). All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org



================================================
FILE: CONTRIBUTING.md
================================================
# Vite Contributing Guide

Hi! We're really excited that you're interested in contributing to Vite! Before submitting your contribution, please read through the following guide. We also suggest you read the [Project Philosophy](https://vite.dev/guide/philosophy) in our documentation.

You can use [StackBlitz Codeflow](https://stackblitz.com/codeflow) to fix bugs or implement features. You'll see a Codeflow button on issues to start a PR to fix them. A button will also appear on PRs to review them without needing to check out the branch locally. When using Codeflow, the Vite repository will be cloned for you in an online editor, with the Vite package built in watch mode ready to test your changes. If you'd like to learn more, check out the [Codeflow docs](https://developer.stackblitz.com/codeflow/what-is-codeflow).

[![Open in Codeflow](https://developer.stackblitz.com/img/open_in_codeflow.svg)](https://pr.new/vitejs/vite)

## Repo Setup

To develop locally, fork the Vite repository and clone it in your local machine. The Vite repo is a monorepo using pnpm workspaces. The package manager used to install and link dependencies must be [pnpm](https://pnpm.io/). You can find the required pnpm version in `package.json` under the `packageManager` key.

To develop and test the core `vite` package:

1. Run `pnpm i` in Vite's root folder.

2. Run `pnpm run build` in Vite's root folder.

3. If you are developing Vite itself, you can go to `packages/vite` and run `pnpm run dev` to automatically rebuild Vite whenever you change its code.

> If you are working on multiple projects with different versions of pnpm, it's recommended to enable [Corepack](https://github.com/nodejs/corepack) by running `corepack enable`.

### Cloning the repo on Windows

On Windows, you may want to [activate Developer Mode](https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) to resolve [issues with symlink creation for non-admins](https://github.com/vitejs/vite/issues/7390). Also, you may want to [set git `core.symlinks` to `true` to resolve issues with symlinks in git](https://github.com/vitejs/vite/issues/5242).

### Ignoring commits when running `git blame`

We have a `.git-blame-ignore-revs` file to ignore formatting changes.
To make this file used by `git blame`, you need to run the following command.

```sh
git config --local blame.ignoreRevsFile .git-blame-ignore-revs
```

## Documentation

To develop the `docs/` site:

1. Run `pnpm run build` in Vite's root folder. This will generate the types for `twoslash` to work in the code examples. If the types are not available, errors will be logged in step 2 but does not prevent the site from working.

2. Run `pnpm run docs` in Vite's root folder.

### Docs Translation Contribution

To add a new language to the Vite docs, see [`vite-docs-template`](https://github.com/tony19/vite-docs-template/blob/main/.github/CONTRIBUTING.md).

## Notes on Dependencies

Vite aims to be lightweight, and this includes being aware of the number of npm dependencies and their size.

We use Rolldown to pre-bundle most dependencies before publishing! Therefore, most dependencies, even those used in runtime source code, should be added under `devDependencies` by default. This also creates the following constraints that we need to be aware of in the codebase.

### Usage of `require()`

In some cases, we intentionally lazy-require some dependencies to improve start-up performance. However, note that we cannot use simple `require('somedep')` calls since these are ignored in ESM files, so the dependency won't be included in the bundle, and the actual dependency won't even be there when published since they are in `devDependencies`.

Instead, use `(await import('somedep')).default`.

### Think Before Adding a Dependency

Most deps should be added to `devDependencies` even if they are needed at runtime. Some exceptions are:

- Type packages. Example: `@types/*`.
- Deps that cannot be properly bundled due to binary files. Example: `esbuild`.
- Deps that ship their own types that are used in Vite's own public types. Example: `rollup`.

Avoid deps with large transitive dependencies that result in bloated size compared to the functionality it provides. For example, `http-proxy` itself is around 380kB in size, but `http-proxy-middleware` pulls in a ton of dependencies that make it 3MB(!) when a minimal custom middleware on top of `http-proxy` only requires a couple of lines of code.

### Ensure Type Support

Vite aims to be fully usable as a dependency in a TypeScript project (e.g. it should provide proper typings for VitePress), and also in `vite.config.ts`. This means technically a dependency whose types are exposed needs to be part of `dependencies` instead of `devDependencies`. However, this also means we won't be able to bundle it.

To get around this, we inline some of these dependencies' types in `packages/vite/src/types`. This way, we can still expose the typing but bundle the dependency's source code.

Use `pnpm run build-types-check` to check that the bundled types do not rely on types in `devDependencies`.

For types shared between client and node, they should be added into `packages/vite/types`. These types are not bundled and are published as is (though they are still considered internal).

## Think Before Adding Yet Another Option

We already have many config options, and we should avoid fixing an issue by adding yet another one. Before adding an option, consider whether the problem:

- is really worth addressing
- can be fixed with a smarter default
- has workaround using existing options
- can be addressed with a plugin instead

## Debugging

To use breakpoints and explore code execution, you can use the ["Run and Debug"](https://code.visualstudio.com/docs/editor/debugging) feature from VS Code.

1. Add a `debugger` statement where you want to stop the code execution.

2. Click the "Run and Debug" icon in the activity bar of the editor, which opens the [_Run and Debug view_](https://code.visualstudio.com/docs/editor/debugging#_run-and-debug-view).

3. Click the "JavaScript Debug Terminal" button in the _Run and Debug view_, which opens a terminal in VS Code.

4. From that terminal, go to `playground/xxx`, and run `pnpm run dev`.

5. The execution will stop at the `debugger` statement, and you can use the [Debug toolbar](https://code.visualstudio.com/docs/editor/debugging#_debug-actions) to continue, step over, and restart the process...

### Debugging Errors in Vitest Tests Using Playwright (Chromium)

Some errors are masked and hidden away because of the layers of abstraction and sandboxed nature added by Vitest, Playwright, and Chromium. In order to see what's actually going wrong and the contents of the devtools console in those instances, follow this setup:

1. Add a `debugger` statement to the `playground/vitestSetup.ts` -> `afterAll` hook. This will pause execution before the tests quit and the Playwright browser instance exits.

2. Run the tests with the `debug-serve` script command, which will enable remote debugging: `pnpm run debug-serve resolve`.

3. Wait for inspector devtools to open in your browser and the debugger to attach.

4. In the sources panel in the right column, click the play button to resume execution, and allow the tests to run, which will open a Chromium instance.

5. Focusing the Chromium instance, you can open the browser devtools and inspect the console there to find the underlying problems.

6. To close everything, just stop the test process back in your terminal.

### Debug Logging

You can set the `--debug` option to turn on debugging logs (e.g. `vite --debug resolve`). To see all debug logs, you can set `vite --debug *`, but be warned that it will be quite noisy. You can run `grep -r "createDebugger('vite:" packages/vite/src/` to see a list of available debug scopes.

### Disabling Source Maps

Source maps for Vite's source code are enabled by default when Vite is placed outside `node_modules` so that you can easily debug it. When bundling Vite in watch mode, source maps will be generated.

However, this behavior may not be desirable when you are developing source map related features. In that case, you can disable source maps by setting the `DEBUG_DISABLE_SOURCE_MAP` environment variable to `1` when running Vite (e.g. `DEBUG_DISABLE_SOURCE_MAP=1 vite`). This environment variable can also be used to disable source map generation.

## Testing Vite against external packages

You may wish to test your locally modified copy of Vite against another package that is built with Vite. For pnpm, after building Vite, you can use [`pnpm.overrides`](https://pnpm.io/package_json#pnpmoverrides) to do this. Note that `pnpm.overrides` must be specified in the root `package.json`, and you must list the package as a dependency in the root `package.json`:

```json
{
  "dependencies": {
    "vite": "^7.0.0"
  },
  "pnpm": {
    "overrides": {
      "vite": "link:../path/to/vite/packages/vite"
    }
  }
}
```

And re-run `pnpm install` to link the package.

## Running Tests

### Integration Tests

Each package under `playground/` contains a `__tests__` directory. The tests are run using [Vitest](https://vitest.dev/) + [Playwright](https://playwright.dev/) with custom integrations to make writing tests simple. The detailed setup is inside `vitest.config.e2e.ts` and `playground/vitest*.ts` files.

Some playgrounds define variants to run the same app using different config setups. By convention, when running a test spec file in a nested folder in `__tests__`, the setup will try to use a config file named `vite.config-{folderName}.js` at the playground's root. You can see an example of variants in the [assets playground](https://github.com/vitejs/vite/tree/main/playground/assets).

Before running the tests, make sure that [Vite has been built](#repo-setup).

Each integration test can be run under either dev server mode or build mode.

- `pnpm test` by default runs every integration test in both serve and build mode, and also unit tests.

- `pnpm run test-serve` runs tests only under serve mode.

- `pnpm run test-build` runs tests only under build mode.

`pnpm run test-serve [match]` or `pnpm run test-build [match]` runs tests in specific packages that match the given filter. e.g. `pnpm run test-serve assets` runs tests for both `playground/assets` and `playground/assets-sanitize` under serve mode. Note package matching is not available for the `pnpm test` script, which always runs all tests.

### Unit Tests

Other than tests under `playground/` for integration tests, packages might contain unit tests under their `__tests__` directory. Unit tests are powered by [Vitest](https://vitest.dev/). The detailed config is inside `vitest.config.ts` files.

- `pnpm run test-unit` runs unit tests under each package.

`pnpm run test-unit [match]` runs tests in specific packages that match the given filter.

### Test Env and Helpers

Inside playground tests, you can import the `page` object from `~utils`, which is a Playwright [`Page`](https://playwright.dev/docs/api/class-page) instance that has already navigated to the served page of the current playground. So, writing a test is as simple as:

```js
import { page } from '~utils'

test('should work', async () => {
  expect(await page.textContent('.foo')).toMatch('foo')
})
```

Some common test helpers (e.g. `testDir`, `isBuild`, or `editFile`) are also available in the utils. Source code is located at `playground/test-utils.ts`.

Note: The test build environment uses a [different default set of Vite config](https://github.com/vitejs/vite/blob/main/playground/vitestSetup.ts#L207-L227) to skip transpilation during tests to make it faster. This may produce a different result compared to the default production build.

### Extending the Test Suite

To add new tests, you should find a related playground to the fix or feature (or create a new one). As an example, static assets loading is tested in the [assets playground](https://github.com/vitejs/vite/tree/main/playground/assets). In this Vite app, there is a test for `?raw` imports with [a section defined in the `index.html` for it](https://github.com/vitejs/vite/blob/v6.3.1/playground/assets/index.html#L266-L267):

```html
<h2>?raw import</h2>
<code class="raw"></code>
```

This will be modified [with the result of a file import](https://github.com/vitejs/vite/blob/v6.3.1/playground/assets/index.html#L543-L544):

```js
import rawSvg from './nested/fragment.svg?raw'
text('.raw', rawSvg)
```

...where the `text` util is defined as:

```js
function text(el, text) {
  document.querySelector(el).textContent = text
}
```

In the [spec tests](https://github.com/vitejs/vite/blob/v6.3.1/playground/assets/__tests__/assets.spec.ts#L469-L471), the modifications to the DOM listed above are used to test this feature:

```js
test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
})
```

### Note on Test Dependencies

In many test cases, we need to mock dependencies using `link:` and `file:` protocols. `pnpm` treats `link:` as symlinks and `file:` as hardlinks. To test dependencies as if they were copied into `node_modules`, use the `file:` protocol. Otherwise, use the `link:` protocol.

For a mock dependency, make sure you add a `@vitejs/test-` prefix to the package name. This will avoid possible issues like false-positive alerts.

## Pull Request Guidelines

- Checkout a topic branch from a base branch (e.g. `main`), and merge back against that branch.

- If adding a new feature:
  - Add accompanying test case.
  - Provide a convincing reason to add this feature. Ideally, you should open a suggestion issue first, and have it approved before working on it.

- If fixing a bug:
  - If you are resolving a special issue, add `(fix #xxxx[,#xxxx])` (#xxxx is the issue id) in your PR title for a better release log (e.g. `fix: update entities encoding/decoding (fix #3899)`).
  - Provide a detailed description of the bug in the PR. Live demo preferred.
  - Add appropriate test coverage if applicable.

- If it's a chore:
  - For typos and comment changes, try to combine multiple of them into a single PR.
  - **Note that we discourage contributors from submitting code refactors that are largely stylistic.** Code refactors are only accepted if it improves performance, or objectively improves code quality (e.g. makes a related bug fix or feature implementation easier, and it is as a separate PR to improve git history).
    - The reason is that code readability is subjective. The maintainers of this project have chosen to write the code in its current style based on our preferences, and we do not want to spend time explaining our stylistic preferences. Contributors should just respect the established conventions when contributing code. Another aspect of it is that large scale stylistic changes result in massive diffs that touch multiple files, adding noise to the git history and makes tracing behavior changes across commits more cumbersome.

- It's OK to have multiple small commits as you work on the PR. GitHub can automatically squash them before merging.

- Make sure tests pass!

- No need to worry about code style as long as you have installed the dev dependencies. Modified files are automatically formatted with Prettier on commit (by invoking [Git Hooks](https://git-scm.com/docs/githooks) via [simple-git-hooks](https://github.com/toplenboren/simple-git-hooks)).

- PR title must follow the [commit message convention](./.github/commit-convention.md) so that changelogs can be automatically generated.

## Maintenance Guidelines

> The following section is mostly for maintainers who have commit access, but it's helpful to go through if you intend to make non-trivial contributions to the codebase.

### Issue Triaging Workflow

```mermaid
flowchart TD
    start{Followed issue
        template?}
    start --NO--> close1["Close and ask to
        follow template"]
    start --YES--> dupe{Is duplicate?}
    dupe --YES--> close2[Close and point
        to duplicate]
    dupe --NO--> repro{Has proper
      reproduction?}
    repro --NO--> close3[Label: 'needs reproduction'
        bot will auto close if no update
        has been made in 3 days]
    repro --YES--> real{Is actually a bug?}
    real --NO--> intended{Is the intended
        behaviour?}
    intended --YES--> explain[Explain and close
        point to docs if needed]
    intended --NO--> open[Keep open for discussion
        Remove 'pending triage' label]
    real --YES--> real2["① Remove 'pending triage' label
        ② Add related feature label if applicable
        (e.g. 'feat: ssr')
        ③ Add priority and meta labels (see below)"]
    real2 --> unusable{Does the
        bug make Vite
        unusable?}
    unusable --YES--> maj{Does the bug
        affect the majority
        of Vite users?}
    maj --YES--> p5[p5: urgent]
    maj --NO--> p4[p4: important]
    unusable --NO--> workarounds{Are there
        workarounds for
        the bug?}
    workarounds --NO--> p3[p3: minor bug]
    workarounds --YES--> p2[p2: edge case
        has workaround]
```

### Pull Request Review Workflow

```mermaid
flowchart TD
    start{Bug fix
        or
        feature}
    start --BUG FIX--> strict_bug{"Is this a 'strict fix'?
        i.e. fixes an obvious oversight with no side effects"}
    start --FEATURE--> feature[• Discuss feature necessity
        • Is there a better way to address the need?
        • Review code quality
        • Add labels
        • Add to milestone
        • Add to Team Board]
    feature -.-> approve_non_strict[• Run vite-ecosystem-ci if needed
        • Approve if you feel strongly that the PR is needed and add to milestone]
    strict_bug --YES--> strict[• Verify the fix locally
        • Review code quality
        • Require test case if applicable
        • Request changes if necessary
        • Add labels]
    strict_bug --NO--> non_strict[Discuss the potential side effects of the fix, e.g.
        • Could it introduce implicit behavior changes in other cases?
        • Does it introduce too much changes?
        • Add labels
        • Add to Team Board]
    non_strict -.-> approve_non_strict
    strict --> approve_strict[Approve if ready to be merged]
    approve_strict --> merge_strict[Merge if approved by 2 or more team members]
    approve_non_strict -.-> merge_non_strict[Merge if approved by 2 or more team members and the PR has been discussed in a team meeting]
    merge_non_strict -.-> merge_extra
    merge_strict --> merge_extra["• Use 'Squash and Merge'
        • Edit commit message to follow convention
        • In commit message body, list relevant issues being fixed e.g. 'fix #1234, fix #1235'"]
```

### Release

If you have publish access, the steps below explain how to cut a release for a package. There are two phases for the release step: "Release" and "Publish".

"Release" is done locally to generate the changelogs and git tags:

1. Make sure the git remote for https://github.com/vitejs/vite is set as `origin`.
2. In the `vite` project root `main` branch, run `git pull` and `pnpm i` to get it up-to-date. Then run `pnpm build`.
3. Run `pnpm release` and follow the prompts to cut a release for a package. It will generate the changelog, a git release tag, and push them to `origin`. You can run with the `--dry` flag to test it out.
4. When the command finishes, it will provide a link to https://github.com/vitejs/vite/actions/workflows/publish.yml.
5. Click the link to visit the page, and follow the next steps below.

"Publish" is done on GitHub Actions to publish the package to npm:

1. Shortly in the workflows page, a new workflow will appear for the released package and is waiting for approval to publish to npm.
2. Click on the workflow to open its page.
3. Click on the "Review deployments" button in the yellow box, a popup will appear.
4. Check "Release" and click "Approve and deploy".
5. The package will start publishing to npm.



================================================
FILE: eslint.config.js
================================================
// @ts-check
import { createRequire } from 'node:module'
import eslint from '@eslint/js'
import pluginN from 'eslint-plugin-n'
import pluginImportX from 'eslint-plugin-import-x'
import pluginRegExp from 'eslint-plugin-regexp'
import tseslint from 'typescript-eslint'
import globals from 'globals'

const require = createRequire(import.meta.url)
const pkgVite = require('./packages/vite/package.json')

// Some rules work better with typechecking enabled, but as enabling it is slow,
// we only do so when linting in IDEs for now. If you want to lint with typechecking
// explicitly, set this to `true` manually.
const shouldTypeCheck = typeof process.env.VSCODE_PID === 'string'

export default tseslint.config(
  {
    ignores: [
      'packages/create-vite/template-*',
      '**/dist/**',
      '**/fixtures/**',
      '**/playground-temp/**',
      '**/temp/**',
      '**/.vitepress/cache/**',
      '**/*.snap',
    ],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommended,
  ...tseslint.configs.stylistic,
  pluginRegExp.configs['flat/recommended'],
  {
    name: 'main',
    languageOptions: {
      parser: tseslint.parser,
      parserOptions: {
        sourceType: 'module',
        ecmaVersion: 2022,
        project: shouldTypeCheck
          ? [
              './packages/*/tsconfig.json',
              './packages/vite/src/*/tsconfig.json',
            ]
          : undefined,
      },
      globals: {
        ...globals.es2021,
        ...globals.node,
      },
    },
    settings: {
      node: {
        version: '^20.19.0 || >=22.12.0',
      },
    },
    plugins: {
      n: pluginN,
      'import-x': pluginImportX,
    },
    rules: {
      'n/no-exports-assign': 'error',
      'n/no-unpublished-bin': 'error',
      'n/no-unsupported-features/es-builtins': 'error',
      'n/no-unsupported-features/node-builtins': [
        'error',
        {
          // TODO: remove this when we don't support Node 20 anymore
          ignores: ['Response', 'Request', 'fetch'],
        },
      ],
      'n/process-exit-as-throw': 'error',
      'n/hashbang': 'error',

      eqeqeq: ['warn', 'always', { null: 'never' }],
      'no-debugger': ['error'],
      'no-empty': ['warn', { allowEmptyCatch: true }],
      'no-process-exit': 'off',
      'prefer-const': [
        'warn',
        {
          destructuring: 'all',
        },
      ],

      'n/no-missing-require': [
        'error',
        {
          // for try-catching yarn pnp
          allowModules: ['pnpapi', 'vite'],
          tryExtensions: ['.ts', '.js', '.jsx', '.tsx', '.d.ts'],
        },
      ],
      'n/no-extraneous-import': [
        'error',
        {
          allowModules: [
            'vite',
            'less',
            'sass',
            'sass-embedded',
            'terser',
            'lightningcss',
            'vitest',
            'unbuild',
          ],
        },
      ],
      'n/no-extraneous-require': [
        'error',
        {
          allowModules: ['vite'],
        },
      ],
      'n/prefer-node-protocol': 'error',

      '@typescript-eslint/ban-ts-comment': 'error',
      '@typescript-eslint/no-unsafe-function-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': [
        'error',
        { allowArgumentsExplicitlyTypedAsAny: true },
      ],
      '@typescript-eslint/no-empty-function': [
        'error',
        { allow: ['arrowFunctions'] },
      ],
      '@typescript-eslint/no-empty-object-type': [
        'error',
        { allowInterfaces: 'with-single-extends' },
      ],
      '@typescript-eslint/no-empty-interface': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      'no-extra-semi': 'off',
      '@typescript-eslint/no-extra-semi': 'off', // conflicts with prettier
      '@typescript-eslint/no-inferrable-types': 'off',
      '@typescript-eslint/no-unused-vars': [
        'error',
        {
          args: 'all',
          argsIgnorePattern: '^_',
          caughtErrors: 'all',
          caughtErrorsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          ignoreRestSiblings: true,
        },
      ],
      '@typescript-eslint/no-require-imports': 'off',
      '@typescript-eslint/consistent-type-imports': [
        'error',
        { prefer: 'type-imports', disallowTypeAnnotations: false },
      ],
      // disable rules set in @typescript-eslint/stylistic which conflict with current code
      // we should discuss if we want to enable these as they encourage consistent code
      '@typescript-eslint/array-type': 'off',
      '@typescript-eslint/consistent-type-definitions': 'off',
      '@typescript-eslint/prefer-for-of': 'off',
      '@typescript-eslint/prefer-function-type': 'off',

      'import-x/no-duplicates': 'error',
      'import-x/order': [
        'error',
        {
          groups: [
            'builtin',
            'external',
            'internal',
            'parent',
            'sibling',
            'index',
          ],
        },
      ],
      'sort-imports': [
        'error',
        {
          ignoreCase: false,
          ignoreDeclarationSort: true,
          ignoreMemberSort: false,
          memberSyntaxSortOrder: ['none', 'all', 'multiple', 'single'],
          allowSeparatedGroups: false,
        },
      ],

      'regexp/prefer-regexp-exec': 'error',
      'regexp/prefer-regexp-test': 'error',
      // in some cases using explicit letter-casing is more performant than the `i` flag
      'regexp/use-ignore-case': 'off',
    },
  },
  {
    name: 'vite/globals',
    files: ['packages/**/*.?([cm])[jt]s?(x)'],
    ignores: ['**/__tests__/**'],
    rules: {
      'no-restricted-globals': ['error', 'require', '__dirname', '__filename'],
    },
  },
  {
    name: 'vite/node',
    files: ['packages/vite/src/node/**/*.?([cm])[jt]s?(x)'],
    rules: {
      'no-console': ['error'],
      'n/no-restricted-require': [
        'error',
        Object.keys(pkgVite.devDependencies).map((d) => ({
          name: d,
          message:
            `devDependencies can only be imported using ESM syntax so ` +
            `that they are included in the rolldown bundle. If you are trying to ` +
            `lazy load a dependency, use (await import('dependency')).default instead.`,
        })),
      ],
    },
  },
  {
    name: 'playground/enforce-esm',
    files: ['playground/**/*.?([cm])[jt]s?(x)'],
    ignores: [
      'playground/ssr-resolve/**',
      'playground/**/*{commonjs,cjs}*/**',
      'playground/**/*{commonjs,cjs}*',
      'playground/**/*dep*/**',
      'playground/resolve/browser-module-field2/index.web.js',
      'playground/resolve/browser-field/**',
    ],
    rules: {
      'import-x/no-commonjs': 'error',
    },
  },
  {
    name: 'tests',
    files: ['**/__tests__/**/*.?([cm])[jt]s?(x)'],
    rules: {
      'n/no-unsupported-features/node-builtins': [
        'error',
        {
          // ideally we would like to allow all experimental features
          // https://github.com/eslint-community/eslint-plugin-n/issues/199
          ignores: ['fetch', 'import.meta.dirname'],
        },
      ],
    },
  },

  {
    name: 'disables/vite/client',
    files: ['packages/vite/src/client/**/*.?([cm])[jt]s?(x)'],
    ignores: ['**/__tests__/**'],
    rules: {
      'n/no-unsupported-features/node-builtins': 'off',
    },
  },
  {
    name: 'disables/vite/types',
    files: [
      'packages/vite/src/types/**/*.?([cm])[jt]s?(x)',
      'packages/vite/scripts/**/*.?([cm])[jt]s?(x)',
      '**/*.spec.ts',
    ],
    rules: {
      'n/no-extraneous-import': 'off',
    },
  },
  {
    name: 'disables/vite/cjs',
    files: ['packages/vite/index.cjs'],
    rules: {
      'no-restricted-globals': 'off',
      'n/no-missing-require': 'off',
    },
  },
  {
    name: 'disables/create-vite/templates',
    files: [
      'packages/create-vite/template-*/**/*.?([cm])[jt]s?(x)',
      '**/build.config.ts',
    ],
    rules: {
      'no-undef': 'off',
      'n/no-missing-import': 'off',
      'n/no-extraneous-import': 'off',
      'n/no-extraneous-require': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
    },
  },
  {
    name: 'disables/playground',
    files: ['playground/**/*.?([cm])[jt]s?(x)', 'docs/**/*.?([cm])[jt]s?(x)'],
    rules: {
      'n/no-extraneous-import': 'off',
      'n/no-extraneous-require': 'off',
      'n/no-missing-import': 'off',
      'n/no-missing-require': 'off',
      'n/no-unsupported-features/es-builtins': 'off',
      'n/no-unsupported-features/node-builtins': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-unused-expressions': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
      'no-undef': 'off',
      'no-empty': 'off',
      'no-constant-condition': 'off',
      '@typescript-eslint/no-empty-function': 'off',
    },
  },
  {
    name: 'disables/playground/tsconfig-json',
    files: [
      'playground/tsconfig-json/**/*.?([cm])[jt]s?(x)',
      'playground/tsconfig-json-load-error/**/*.?([cm])[jt]s?(x)',
    ],
    ignores: ['**/__tests__/**'],
    rules: {
      '@typescript-eslint/ban-ts-comment': 'off',
    },
  },
  {
    name: 'disables/js',
    files: ['**/*.js', '**/*.mjs', '**/*.cjs'],
    rules: {
      '@typescript-eslint/explicit-module-boundary-types': 'off',
    },
  },
  {
    name: 'disables/dts',
    files: ['**/*.d.ts'],
    rules: {
      '@typescript-eslint/consistent-indexed-object-style': 'off',
      '@typescript-eslint/triple-slash-reference': 'off',
    },
  },
  {
    name: 'disables/test',
    files: ['**/__tests__/**/*.?([cm])[jt]s?(x)'],
    rules: {
      'no-console': 'off',
      '@typescript-eslint/ban-ts-comment': 'off',
    },
  },
  {
    name: 'disables/typechecking',
    files: [
      '**/*.js',
      '**/*.mjs',
      '**/*.cjs',
      '**/*.d.ts',
      '**/*.d.cts',
      '**/__tests__/**',
      'docs/**',
      'playground/**',
      'scripts/**',
      'vitest.config.ts',
      'vitest.config.e2e.ts',
    ],
    languageOptions: {
      parserOptions: {
        project: false,
      },
    },
  },
)



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2019-present, VoidZero Inc. and Vite contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: netlify.toml
================================================
[build.environment]
  NODE_VERSION = "22"
  # don't need playwright for docs build
  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD = "1"
[build]
  publish = "docs/.vitepress/dist"
  command = "pnpm ci-docs"
  ignore = "./scripts/docs-check.sh"



================================================
FILE: package.json
================================================
{
  "name": "@vitejs/vite-monorepo",
  "private": true,
  "type": "module",
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "homepage": "https://vite.dev/",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git"
  },
  "keywords": [
    "frontend",
    "hmr",
    "dev-server",
    "build-tool",
    "vite"
  ],
  "scripts": {
    "preinstall": "npx only-allow pnpm",
    "postinstall": "simple-git-hooks",
    "format": "prettier --write --cache .",
    "lint": "eslint --cache .",
    "typecheck": "tsc -p scripts && pnpm -r --parallel run typecheck",
    "test": "pnpm test-unit && pnpm test-serve && pnpm test-build",
    "test-serve": "vitest run -c vitest.config.e2e.ts",
    "test-build": "VITE_TEST_BUILD=1 vitest run -c vitest.config.e2e.ts",
    "test-unit": "vitest run",
    "test-docs": "pnpm run docs-build",
    "debug-serve": "VITE_DEBUG_SERVE=1 vitest run -c vitest.config.e2e.ts",
    "debug-build": "VITE_TEST_BUILD=1 VITE_PRESERVE_BUILD_ARTIFACTS=1 vitest run -c vitest.config.e2e.ts",
    "docs": "pnpm --filter=docs run docs",
    "docs-build": "pnpm --filter=docs run docs-build",
    "docs-serve": "pnpm --filter=docs run docs-serve",
    "build": "pnpm -r --filter='./packages/*' run build",
    "dev": "pnpm -r --parallel --filter='./packages/*' run dev",
    "release": "tsx scripts/release.ts",
    "ci-publish": "tsx scripts/publishCI.ts",
    "ci-docs": "pnpm build && pnpm docs-build"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@type-challenges/utils": "^0.1.1",
    "@types/babel__core": "^7.20.5",
    "@types/babel__preset-env": "^7.10.0",
    "@types/convert-source-map": "^2.0.3",
    "@types/cross-spawn": "^6.0.6",
    "@types/debug": "^4.1.12",
    "@types/estree": "^1.0.8",
    "@types/etag": "^1.8.4",
    "@types/less": "^3.0.8",
    "@types/node": "^22.17.1",
    "@types/picomatch": "^4.0.2",
    "@types/stylus": "^0.48.43",
    "@types/ws": "^8.18.1",
    "@vitejs/release-scripts": "^1.6.0",
    "eslint": "^9.33.0",
    "eslint-plugin-import-x": "^4.16.1",
    "eslint-plugin-n": "^17.21.3",
    "eslint-plugin-regexp": "^2.10.0",
    "execa": "^9.6.0",
    "globals": "^16.3.0",
    "lint-staged": "^16.1.5",
    "picocolors": "^1.1.1",
    "playwright-chromium": "^1.54.2",
    "prettier": "3.6.2",
    "rollup": "^4.43.0",
    "simple-git-hooks": "^2.13.1",
    "tsx": "^4.20.3",
    "typescript": "~5.9.2",
    "typescript-eslint": "^8.39.1",
    "vite": "workspace:*",
    "vitest": "^3.2.4"
  },
  "simple-git-hooks": {
    "pre-commit": "pnpm exec lint-staged --concurrent false"
  },
  "lint-staged": {
    "*": [
      "prettier --write --cache --ignore-unknown"
    ],
    "packages/*/{src,types}/**/*.ts": [
      "eslint --cache --fix"
    ],
    "packages/**/*.d.ts": [
      "eslint --cache --fix"
    ],
    "playground/**/__tests__/**/*.ts": [
      "eslint --cache --fix"
    ]
  },
  "packageManager": "pnpm@10.14.0",
  "stackblitz": {
    "startCommand": "pnpm --filter='./packages/vite' run dev"
  }
}



================================================
FILE: pnpm-workspace.yaml
================================================
packages:
  - 'packages/*'
  - 'playground/**'
  - 'packages/**/__tests__/**'
  - docs

hoistPattern:
  - postcss # package/vite
  - pug # playground/tailwind: @vue/compiler-sfc
  - eslint-import-resolver-* # eslint-plugin-import-x
shellEmulator: true
autoInstallPeers: false
dedupeInjectedDeps: false
overrides:
  vite: 'workspace:*'
patchedDependencies:
  "sirv@3.0.1": "patches/sirv@3.0.1.patch"
  "chokidar@3.6.0": "patches/chokidar@3.6.0.patch"
  "dotenv-expand@12.0.2": "patches/dotenv-expand@12.0.2.patch"
peerDependencyRules:
  allowedVersions:
    vite: "*"
packageExtensions:
  sass-embedded:
    peerDependencies:
      source-map-js: "*"
    peerDependenciesMeta:
      source-map-js:
        optional: true
ignoredBuiltDependencies:
  - core-js
  - es5-ext
onlyBuiltDependencies:
  - "@parcel/watcher"
  - "@tailwindcss/oxide"
  - "bcrypt"
  - "esbuild"
  - "playwright-chromium"
  - "sharp"
  - "simple-git-hooks"
  - "unrs-resolver"
  - "workerd"



================================================
FILE: vitest.config.e2e.ts
================================================
import { resolve } from 'node:path'
import { defineConfig } from 'vitest/config'

const timeout = process.env.PWDEBUG ? Infinity : process.env.CI ? 50000 : 30000

export default defineConfig({
  resolve: {
    alias: {
      '~utils': resolve(__dirname, './playground/test-utils'),
    },
  },
  test: {
    include: ['./playground/**/*.spec.[tj]s'],
    setupFiles: ['./playground/vitestSetup.ts'],
    globalSetup: ['./playground/vitestGlobalSetup.ts'],
    testTimeout: timeout,
    hookTimeout: timeout,
    reporters: 'dot',
    deps: {
      // Prevent Vitest from running the workspace packages in Vite's SSR runtime
      moduleDirectories: ['node_modules', 'packages'],
    },
    expect: {
      poll: {
        timeout: 50 * (process.env.CI ? 200 : 50),
      },
    },
  },
  esbuild: {
    target: 'node20',
  },
  publicDir: false,
})



================================================
FILE: vitest.config.ts
================================================
import path from 'node:path'
import url from 'node:url'
import { defineConfig } from 'vitest/config'

const _dirname = path.dirname(url.fileURLToPath(import.meta.url))

export default defineConfig({
  test: {
    include: ['**/__tests__/**/*.spec.[tj]s'],
    exclude: [
      '**/node_modules/**',
      '**/dist/**',
      './playground/**/*.*',
      './playground-temp/**/*.*',
    ],
    deps: {
      // we specify 'packages' so Vitest doesn't inline the files
      moduleDirectories: ['node_modules', 'packages'],
    },
    testTimeout: 20000,
    isolate: false,
  },
  esbuild: {
    target: 'node20',
  },
  publicDir: false,
  resolve: {
    alias: {
      'vite/module-runner': path.resolve(
        _dirname,
        './packages/vite/src/module-runner/index.ts',
      ),
    },
  },
})



================================================
FILE: .editorconfig
================================================
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true



================================================
FILE: .git-blame-ignore-revs
================================================
# chore: enable prettier trailing commas (#11167)
134ce6817984bad0f5fb043481502531fee9b1db
# chore: rename test packages (#11172)
5170e44920458090b8b43ee9cfe5010c25dfe22b



================================================
FILE: .prettierignore
================================================
packages/*/CHANGELOG.md
packages/vite/src/node/ssr/__tests__/fixtures/errors/syntax-error.*
playground-temp/
dist/
LICENSE.md
pnpm-lock.yaml
pnpm-workspace.yaml
playground/tsconfig-json-load-error/has-error/tsconfig.json
playground/html/invalid.html
playground/html/invalidClick.html
playground/html/invalidEscape.html
playground/html/valid.html
playground/external/public/slash@3.0.0.js
playground/ssr-html/public/slash@3.0.0.js
playground/worker/classic-worker.js
playground/css/weapp.wxss



================================================
FILE: .prettierrc.json
================================================
{
  "semi": false,
  "singleQuote": true,
  "overrides": [
    {
      "files": ["*.json5"],
      "options": {
        "singleQuote": false,
        "quoteProps": "preserve"
      }
    },
    {
      "files": ["*.yml"],
      "options": {
        "singleQuote": false
      }
    }
  ]
}



================================================
FILE: docs/blog.md
================================================
---
sidebar: false
editLink: false
outline: false
---

<script setup>
import BlogIndex from './.vitepress/theme/components/BlogIndex.vue'
</script>

# Latest From the Vite Blog

<BlogIndex/>



================================================
FILE: docs/index.md
================================================
---
title: Vite
titleTemplate: Next Generation Frontend Tooling
# add `dark` here to apply dark mode on initial load,
# since `onMounted` doesn't run during SSR
pageClass: landing dark

layout: home
aside: false
editLink: false
markdownStyles: false
---

<script setup>
import { useData } from 'vitepress'
import { onBeforeUnmount, onMounted, ref } from 'vue'

import Hero from './.vitepress/theme/components/landing/1. hero-section/HeroSection.vue'
import FeatureSection from './.vitepress/theme/components/landing/2. feature-section/FeatureSection.vue'
import FrameworksSection from './.vitepress/theme/components/landing/3. frameworks-section/FrameworksSection.vue'
import CommunitySection from './.vitepress/theme/components/landing/4. community-section/CommunitySection.vue'
import SponsorSection from './.vitepress/theme/components/landing/5. sponsor-section/SponsorSection.vue'
import GetStartedSection from './.vitepress/theme/components/landing/6. get-started-section/GetStartedSection.vue'
import FeatureInstantServerStart from './.vitepress/theme/components/landing/2. feature-section/FeatureInstantServerStart.vue'
import FeatureHMR from './.vitepress/theme/components/landing/2. feature-section/FeatureHMR.vue'
import FeatureRichFeatures from './.vitepress/theme/components/landing/2. feature-section/FeatureRichFeatures.vue'
import FeatureOptimizedBuild from './.vitepress/theme/components/landing/2. feature-section/FeatureOptimizedBuild.vue'
import FeatureFlexiblePlugins from './.vitepress/theme/components/landing/2. feature-section/FeatureFlexiblePlugins.vue'
import FeatureTypedAPI from './.vitepress/theme/components/landing/2. feature-section/FeatureTypedAPI.vue'
import FeatureSSRSupport from './.vitepress/theme/components/landing/2. feature-section/FeatureSSRSupport.vue'
import FeatureCI from './.vitepress/theme/components/landing/2. feature-section/FeatureCI.vue'

const { isDark } = useData()

onMounted(() => {
  document.documentElement.classList.add('dark')
})

onBeforeUnmount(() => {
  document.documentElement.classList.toggle('dark', isDark.value)
})
</script>

<div class="VPHome">
  <Hero/>
  <FeatureSection title="Redefining developer experience" description="Vite makes web development simple again" type="blue">
    <FeatureInstantServerStart />
    <FeatureHMR />
    <FeatureRichFeatures />
    <FeatureOptimizedBuild />
  </FeatureSection>
  <FeatureSection title="A shared foundation to build upon" type="pink" class="feature-section--flip">
    <FeatureFlexiblePlugins />
    <FeatureTypedAPI />
    <FeatureSSRSupport />
    <FeatureCI />
  </FeatureSection>
  <FrameworksSection />
  <CommunitySection />
  <SponsorSection />
  <GetStartedSection />
</div>



================================================
FILE: docs/package.json
================================================
{
  "name": "docs",
  "private": true,
  "type": "module",
  "scripts": {
    "typecheck": "vue-tsc",
    "docs": "vitepress dev",
    "docs-build": "vitepress build",
    "docs-serve": "vitepress serve"
  },
  "devDependencies": {
    "@shikijs/vitepress-twoslash": "^3.9.2",
    "@types/express": "^5.0.3",
    "feed": "^5.1.0",
    "gsap": "^3.13.0",
    "markdown-it-image-size": "^14.8.0",
    "vitepress": "^2.0.0-alpha.10",
    "vitepress-plugin-group-icons": "^1.6.2",
    "vitepress-plugin-llms": "^1.7.2",
    "vue": "^3.5.18",
    "vue-tsc": "^3.0.5"
  }
}



================================================
FILE: docs/releases.md
================================================
# Releases

Vite releases follow [Semantic Versioning](https://semver.org/). You can see the latest stable version of Vite in the [Vite npm package page](https://www.npmjs.com/package/vite).

A full changelog of past releases is [available on GitHub](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md).

## Release Cycle

Vite does not have a fixed release cycle.

- **Patch** releases are released as needed (usually every week).
- **Minor** releases always contain new features and are released as needed. Minor releases always have a beta pre-release phase (usually every two months).
- **Major** releases generally align with [Node.js EOL schedule](https://endoflife.date/nodejs), and will be announced ahead of time. These releases will go through long-term discussions with the ecosystem, and have alpha and beta pre-release phases (usually every year).

The Vite version ranges that are supported by the Vite team are automatically determined by:

- **Current Minor** gets regular fixes.
- **Previous Major** (only for its latest minor) and **Previous Minor** receives important fixes and security patches.
- **Second-to-last Major** (only for its latest minor) and **Second-to-last Minor** receives security patches.
- All versions before these are no longer supported.

As an example, if the Vite latest is at 5.3.10:

- Regular patches are released for `vite@5.3`.
- Important fixes and security patches are backported to `vite@4` and `vite@5.2`.
- Security patches are also backported to `vite@3`, and `vite@5.1`.
- `vite@2` and `vite@5.0` are no longer supported. Users should upgrade to receive updates.

We recommend updating Vite regularly. Check out the [Migration Guides](https://vite.dev/guide/migration.html) when you update to each Major. The Vite team works closely with the main projects in the ecosystem to ensure the quality of new versions. We test new Vite versions before releasing them through the [vite-ecosystem-ci project](https://github.com/vitejs/vite-ecosystem-ci). Most projects using Vite should be able to quickly offer support or migrate to new versions as soon as they are released.

## Semantic Versioning Edge Cases

### TypeScript Definitions

We may ship incompatible changes to TypeScript definitions between minor versions. This is because:

- Sometimes TypeScript itself ships incompatible changes between minor versions, and we may have to adjust types to support newer versions of TypeScript.
- Occasionally we may need to adopt features that are only available in a newer version of TypeScript, raising the minimum required version of TypeScript.
- If you are using TypeScript, you can use a semver range that locks the current minor and manually upgrade when a new minor version of Vite is released.

### esbuild

[esbuild](https://esbuild.github.io/) is pre-1.0.0 and sometimes it has a breaking change we may need to include to have access to newer features and performance improvements. We may bump the esbuild's version in a Vite Minor.

### Node.js non-LTS versions

Non-LTS Node.js versions (odd-numbered) are not tested as part of Vite's CI, but they should still work before their [EOL](https://endoflife.date/nodejs).

## Pre Releases

Minor releases typically go through a non-fixed number of beta releases. Major releases will go through an alpha phase and a beta phase.

Pre-releases allow early adopters and maintainers from the Ecosystem to do integration and stability testing, and provide feedback. Do not use pre-releases in production. All pre-releases are considered unstable and may ship breaking changes in between. Always pin to exact versions when using pre-releases.

## Deprecations

We periodically deprecate features that have been superseded by better alternatives in Minor releases. Deprecated features will continue to work with a type or logged warning. They will be removed in the next major release after entering deprecated status. The [Migration Guide](https://vite.dev/guide/migration.html) for each major will list these removals and document an upgrade path for them.

## Experimental Features

Some features are marked as experimental when released in a stable version of Vite. Experimental features allow us to gather real-world experience to influence their final design. The goal is to let users provide feedback by testing them in production. Experimental features themselves are considered unstable, and should only be used in a controlled manner. These features may change between Minors, so users must pin their Vite version when they rely on them. We will create [a GitHub discussion](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=is%3Aopen+label%3Aexperimental+category%3AFeedback) for each experimental feature.



================================================
FILE: docs/team.md
================================================
---
layout: page
title: Meet the Team
description: The development of Vite is guided by an international team.
---

<script setup>
import {
  VPTeamPage,
  VPTeamPageTitle,
  VPTeamPageSection,
  VPTeamMembers
} from 'vitepress/theme'
import { core, emeriti } from './_data/team'
</script>

<VPTeamPage>
  <VPTeamPageTitle>
    <template #title>Meet the Team</template>
    <template #lead>
      The development of Vite is guided by an international team, some of whom
      have chosen to be featured below.
    </template>
  </VPTeamPageTitle>
  <VPTeamMembers :members="core" />
  <VPTeamPageSection>
    <template #title>Team Emeriti</template>
    <template #lead>
      Here we honor some no-longer-active team members who have made valuable
      contributions in the past.
    </template>
    <template #members>
      <VPTeamMembers size="small" :members="emeriti" />
    </template>
  </VPTeamPageSection>
</VPTeamPage>



================================================
FILE: docs/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2023",
    "lib": ["ES2023", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["**/*.ts", ".vitepress/**/*.ts", ".vitepress/**/*.vue"]
}



================================================
FILE: docs/_data/blog.data.ts
================================================
import { createContentLoader } from 'vitepress'

interface Post {
  title: string
  url: string
  date: {
    time: number
    string: string
  }
}

declare const data: Post[]
export { data }

export default createContentLoader('blog/*.md', {
  // excerpt: true,
  transform(raw): Post[] {
    return raw
      .map(({ url, frontmatter }) => ({
        title: frontmatter.head.find(
          (e: any) => e[1].property === 'og:title',
        )[1].content,
        url,
        date: formatDate(frontmatter.date),
      }))
      .sort((a, b) => b.date.time - a.date.time)
  },
})

function formatDate(raw: string): Post['date'] {
  const date = new Date(raw)
  date.setUTCHours(12)
  return {
    time: +date,
    string: date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    }),
  }
}



================================================
FILE: docs/_data/team.js
================================================
export const core = [
  {
    avatar: 'https://www.github.com/yyx990803.png',
    name: 'Evan You',
    title: 'Creator',
    org: 'Vue.js',
    orgLink: 'https://vuejs.org/',
    desc: 'Independent open source developer, creator of Vue.js and Vite.',
    links: [
      { icon: 'github', link: 'https://github.com/yyx990803' },
      { icon: 'x', link: 'https://x.com/youyuxi' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/evanyou.me' },
    ],
    sponsor: 'https://github.com/sponsors/yyx990803',
  },
  {
    avatar: 'https://www.github.com/patak-dev.png',
    name: 'Patak',
    title: 'A collaborative being',
    org: 'StackBlitz',
    orgLink: 'https://stackblitz.com/',
    desc: 'Core team member of Vite. Team member of Vue.',
    links: [
      { icon: 'github', link: 'https://github.com/patak-dev' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/patak.dev' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@patak' },
    ],
    sponsor: 'https://github.com/sponsors/patak-dev',
  },
  {
    avatar: 'https://www.github.com/antfu.png',
    name: 'Anthony Fu',
    title: 'A fanatical open sourceror',
    org: 'NuxtLabs',
    orgLink: 'https://nuxtlabs.com/',
    desc: 'Core team member of Vite & Vue. Working at NuxtLabs.',
    links: [
      { icon: 'github', link: 'https://github.com/antfu' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/antfu.me' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@antfu' },
    ],
    sponsor: 'https://github.com/sponsors/antfu',
  },
  {
    avatar: 'https://github.com/bluwy.png',
    name: 'Bjorn Lu',
    title: 'Open Source Developer',
    desc: 'Building tools for fun.',
    links: [
      { icon: 'github', link: 'https://github.com/bluwy' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/bluwy.me' },
      { icon: 'twitter', link: 'https://twitter.com/bluwyoo' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@bluwy' },
    ],
    sponsor: 'https://bjornlu.com/sponsor',
  },
  {
    avatar: 'https://github.com/sapphi-red.png',
    name: 'green',
    title: 'Web Developer',
    desc: 'Vite core team member. Call me sapphi or green or midori ;)',
    links: [
      { icon: 'github', link: 'https://github.com/sapphi-red' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/sapphi.red' },
      { icon: 'twitter', link: 'https://twitter.com/sapphi_red' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@sapphi_red' },
    ],
    sponsor: 'https://github.com/sponsors/sapphi-red',
  },
  {
    avatar: 'https://github.com/ArnaudBarre.png',
    name: 'Arnaud Barré',
    title: 'Frontend Developer',
    desc: 'Passionate about tooling around TypeScript and React.',
    links: [
      { icon: 'github', link: 'https://github.com/ArnaudBarre' },
      {
        icon: 'bluesky',
        link: 'https://bsky.app/profile/arnaud-barre.bsky.social',
      },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@ArnaudBarre' },
    ],
    sponsor: 'https://github.com/sponsors/ArnaudBarre',
  },
  {
    avatar: 'https://github.com/dominikg.png',
    name: 'Dominik G.',
    title: 'Resident CI Expert',
    desc: 'Team Member of Vite and Svelte',
    links: [
      { icon: 'github', link: 'https://github.com/dominikg' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@dominikg' },
    ],
    sponsor: 'https://github.com/sponsors/dominikg',
  },
  {
    avatar: 'https://github.com/sheremet-va.png',
    name: 'Vladimir',
    title: 'Core team member of Vitest & Vite',
    desc: 'An open source fullstack developer',
    links: [
      { icon: 'github', link: 'https://github.com/sheremet-va' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/erus.dev' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@sheremet_va' },
    ],
    sponsor: 'https://github.com/sponsors/sheremet-va',
  },
  {
    avatar: 'https://github.com/hi-ogawa.png',
    name: 'Hiroshi Ogawa',
    title: 'Team Member of Vitest & Vite',
    desc: 'Open source enthusiast',
    links: [
      { icon: 'github', link: 'https://github.com/hi-ogawa' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/hiogawa.bsky.social' },
    ],
    sponsor: 'https://github.com/sponsors/hi-ogawa',
  },
  {
    avatar: 'https://github.com/btea.png',
    name: 'btea',
    title: 'Web Developer',
    links: [{ icon: 'github', link: 'https://github.com/btea' }],
  },
]

export const emeriti = [
  {
    avatar: 'https://i.imgur.com/KMed6rQ.jpeg',
    name: 'Alec Larson',
    title: 'Entrepreneur',
    desc: 'Dabbling in social ecommerce, meta frameworks, and board games',
    links: [
      { icon: 'github', link: 'https://github.com/aleclarson' },
      { icon: 'x', link: 'https://x.com/retropragma' },
      {
        icon: 'bluesky',
        link: 'https://bsky.app/profile/retropragma.bsky.social',
      },
    ],
  },
  {
    avatar: 'https://github.com/poyoho.png',
    name: 'yoho',
    title: 'Frontend Developer',
    desc: 'Frontend. Vite team member.',
    links: [
      { icon: 'github', link: 'https://github.com/poyoho' },
      { icon: 'x', link: 'https://x.com/yoho_po' },
    ],
  },
  {
    avatar: 'https://github.com/ygj6.png',
    name: 'ygj6',
    title: 'Developer',
    desc: 'Web Developer. Vue & Vite team member',
    links: [
      { icon: 'github', link: 'https://github.com/ygj6' },
      { icon: 'x', link: 'https://x.com/ygj_66' },
    ],
  },
  {
    avatar: 'https://github.com/Niputi.png',
    name: 'Niputi',
    title: 'Developer',
    org: 'Computershare Denmark',
    desc: 'weeb/JavaScript lover.',
    links: [
      { icon: 'github', link: 'https://github.com/Niputi' },
      { icon: 'x', link: 'https://x.com/Niputi_' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/niputi.bsky.social' },
    ],
  },
  {
    avatar: 'https://github.com/underfin.png',
    name: 'underfin',
    title: 'Developer',
    links: [{ icon: 'github', link: 'https://github.com/underfin' }],
  },
  {
    avatar: 'https://github.com/GrygrFlzr.png',
    name: 'GrygrFlzr',
    title: 'Developer',
    links: [
      { icon: 'github', link: 'https://github.com/GrygrFlzr' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/bsky.cybeast.dev' },
    ],
  },
  {
    avatar: 'https://github.com/nihalgonsalves.png',
    name: 'Nihal Gonsalves',
    title: 'Senior Software Engineer',
    links: [{ icon: 'github', link: 'https://github.com/nihalgonsalves' }],
  },
  {
    avatar: 'https://github.com/Shinigami92.png',
    name: 'Shinigami',
    title: 'Senior Frontend Engineer',
    org: 'Faker',
    orgLink: 'https://fakerjs.dev',
    desc: 'Passionate TypeScript enthusiast working extensively with Vue SPA.',
    links: [
      { icon: 'github', link: 'https://github.com/Shinigami92' },
      { icon: 'mastodon', link: 'https://elk.zone/mas.to/@Shini92' },
    ],
  },
  {
    avatar: 'https://github.com/haoqunjiang.png',
    name: 'Haoqun Jiang',
    title: 'Core Team Member',
    org: 'Vue.js',
    orgLink: 'https://vuejs.org/',
    desc: 'Curator of best practices for Vue.js tooling',
    links: [
      { icon: 'github', link: 'https://github.com/haoqunjiang' },
      { icon: 'bluesky', link: 'https://bsky.app/profile/haoqun.dev' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@haoqun' },
    ],
    sponsor: 'https://github.com/sponsors/haoqunjiang',
  },
]



================================================
FILE: docs/blog/announcing-vite2.md
================================================
---
title: Announcing Vite 2.0
author:
  - name: The Vite Team
sidebar: false
date: 2021-02-16
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 2.0
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite2
  - - meta
    - property: og:description
      content: Vite 2 Release Announcement
---

# Announcing Vite 2.0

_February 16, 2021_ - Check out the [Vite 3.0 announcement](./announcing-vite3.md)

<p style="text-align:center">
  <img src="/logo.svg" style="height:200px">
</p>

Today we are excited to announce the official release of Vite 2.0!

Vite (French word for "fast", pronounced `/vit/`) is a new kind of build tool for frontend web development. Think a pre-configured dev server + bundler combo, but leaner and faster. It leverages browser's [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) support and tools written in compile-to-native languages like [esbuild](https://esbuild.github.io/) to deliver a snappy and modern development experience.

To get a sense of how fast Vite is, check out [this video comparison](https://twitter.com/amasad/status/1355379680275128321) of booting up a React application on Repl.it using Vite vs. `create-react-app` (CRA).

If you've never heard of Vite before and would love to learn more about it, check out [the rationale behind the project](https://vite.dev/guide/why.html). If you are interested in how Vite differs from other similar tools, check out the [comparisons](https://v5.vite.dev/guide/comparisons.html).

## What's New in 2.0

Since we decided to completely refactor the internals before 1.0 got out of RC, this is in fact the first stable release of Vite. That said, Vite 2.0 brings about many big improvements over its previous incarnation:

### Framework Agnostic Core

The original idea of Vite started as a [hacky prototype that serves Vue single-file components over native ESM](https://github.com/vuejs/vue-dev-server). Vite 1 was a continuation of that idea with HMR implemented on top.

Vite 2.0 takes what we learned along the way and is redesigned from scratch with a more robust internal architecture. It is now completely framework agnostic, and all framework-specific support is delegated to plugins. There are now [official templates for Vue, React, Preact, Lit Element](https://github.com/vitejs/vite/tree/main/packages/create-vite), and ongoing community efforts for Svelte integration.

### New Plugin Format and API

Inspired by [WMR](https://github.com/preactjs/wmr), the new plugin system extends Rollup's plugin interface and is [compatible with many Rollup plugins](https://vite-rollup-plugins.patak.dev/) out of the box. Plugins can use Rollup-compatible hooks, with additional Vite-specific hooks and properties to adjust Vite-only behavior (e.g. differentiating dev vs. build or custom handling of HMR).

The [programmatic API](https://vite.dev/guide/api-javascript.html) has also been greatly improved to facilitate higher level tools / frameworks built on top of Vite.

### esbuild Powered Dep Pre-Bundling

Since Vite is a native ESM dev server, it pre-bundles dependencies to reduce the number browser requests and handle CommonJS to ESM conversion. Previously Vite did this using Rollup, and in 2.0 it now uses `esbuild` which results in 10-100x faster dependency pre-bundling. As a reference, cold-booting a test app with heavy dependencies like React Material UI previously took 28 seconds on an M1-powered MacBook Pro and now takes ~1.5 seconds. Expect similar improvements if you are switching from a traditional bundler based setup.

### First-class CSS Support

Vite treats CSS as a first-class citizen of the module graph and supports the following out of the box:

- **Resolver enhancement**: `@import` and `url()` paths in CSS are enhanced with Vite's resolver to respect aliases and npm dependencies.
- **URL rebasing**: `url()` paths are automatically rebased regardless of where the file is imported from.
- **CSS code splitting**: a code-split JS chunk also emits a corresponding CSS file, which is automatically loaded in parallel with the JS chunk when requested.

### Server-Side Rendering (SSR) Support

Vite 2.0 ships with [experimental SSR support](https://vite.dev/guide/ssr.html). Vite provides APIs to efficiently load and update ESM-based source code in Node.js during development (almost like server-side HMR), and automatically externalizes CommonJS-compatible dependencies to improve development and SSR build speed. The production server can be completely decoupled from Vite, and the same setup can be easily adapted to perform pre-rendering / SSG.

Vite SSR is provided as a low-level feature and we are expecting to see higher level frameworks leveraging it under the hood.

### Opt-in Legacy Browser Support

Vite targets modern browsers with native ESM support by default, but you can also opt-in to support legacy browsers via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). The plugin automatically generates dual modern/legacy bundles, and delivers the right bundle based on browser feature detection, ensuring more efficient code in modern browsers that support them.

## Give it a Try!

That was a lot of features, but getting started with Vite is simple! You can spin up a Vite-powered app literally in a minute, starting with the following command (make sure you have Node.js >=12):

```bash
npm init @vitejs/app
```

Then, check out [the guide](https://vite.dev/guide/) to see what Vite provides out of the box. You can also check out the source code on [GitHub](https://github.com/vitejs/vite), follow updates on [Twitter](https://twitter.com/vite_js), or join discussions with other Vite users on our [Discord chat server](http://chat.vite.dev/).



================================================
FILE: docs/blog/announcing-vite3.md
================================================
---
title: Vite 3.0 is out!
author:
  name: The Vite Team
date: 2022-07-23
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 3
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite3.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite3
  - - meta
    - property: og:description
      content: Vite 3 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 3.0 is out!

_July 23, 2022_ - Check out the [Vite 4.0 announcement](./announcing-vite4.md)

In February last year, [Evan You](https://twitter.com/youyuxi) released Vite 2. Since then, its adoption has grown non-stop, reaching more than 1 million npm downloads per week. A sprawling ecosystem rapidly formed after the release. Vite is powering a renewed innovation race in Web frameworks. [Nuxt 3](https://v3.nuxtjs.org/) uses Vite by default. [SvelteKit](https://kit.svelte.dev/), [Astro](https://astro.build/), [Hydrogen](https://hydrogen.shopify.dev/), and [SolidStart](https://docs.solidjs.com/quick-start) are all built with Vite. [Laravel has now decided to use Vite by default](https://laravel.com/docs/9.x/vite). [Vite Ruby](https://vite-ruby.netlify.app/) shows how Vite can improve Rails DX. [Vitest](https://vitest.dev) is making strides as a Vite-native alternative to Jest. Vite is behind [Cypress](https://docs.cypress.io/guides/component-testing/writing-your-first-component-test) and [Playwright](https://playwright.dev/docs/test-components)'s new Component Testing features, Storybook has [Vite as an official builder](https://github.com/storybookjs/builder-vite). And [the list goes on](https://patak.dev/vite/ecosystem.html). Maintainers from most of these projects got involved in improving the Vite core itself, working closely with the Vite [team](https://vite.dev/team) and other contributors.

![Vite 3 Announcement Cover Image](/og-image-announcing-vite3.webp)

Today, 16 months from the v2 launch we are happy to announce the release of Vite 3. We decided to release a new Vite major at least every year to align with [Node.js's EOL](https://nodejs.org/en/about/releases/), and take the opportunity to review Vite's API regularly with a short migration path for projects in the ecosystem.

Quick links:

- [Docs](/)
- [Migration Guide](https://v3.vite.dev/guide/migration.html)
- [Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#300-2022-07-13)

If you are new to Vite, we recommend reading the [Why Vite Guide](https://vite.dev/guide/why.html). Then check out [the Getting Started](https://vite.dev/guide/) and [Features guide](https://vite.dev/guide/features) to see what Vite provides out of the box. As usual, contributions are welcome at [GitHub](https://github.com/vitejs/vite). More than [600 collaborators](https://github.com/vitejs/vite/graphs/contributors) have helped improve Vite so far. Follow the updates on [Twitter](https://twitter.com/vite_js), or join discussions with other Vite users on our [Discord chat server](http://chat.vite.dev/).

## New Documentation

Go to [vite.dev](https://vite.dev) to enjoy the new v3 docs. Vite is now using the new [VitePress](https://vitepress.vuejs.org) default theme, with a stunning dark mode between other features.

[![Vite documentation frontpage](../images/v3-docs.webp)](https://vite.dev)

Several projects in the ecosystem have already migrated to it (see [Vitest](https://vitest.dev), [vite-plugin-pwa](https://vite-plugin-pwa.netlify.app/), and [VitePress](https://vitepress.vuejs.org/) itself).

If you need to access the Vite 2 docs, they will remain online at [v2.vite.dev](https://v2.vite.dev). There is also a new [main.vite.dev](https://main.vite.dev) subdomain, where each commit to Vite’s main branch is auto deployed. This is useful when testing beta versions or contributing to the core’s development.

There is also now an official Spanish translation, that has been added to the previous Chinese and Japanese translations:

- [简体中文](https://cn.vite.dev/)
- [日本語](https://ja.vite.dev/)
- [Español](https://es.vite.dev/)

## Create Vite Starter Templates

[create-vite](/guide/#trying-vite-online) templates have been a great tool to quickly test Vite with your favorite framework. In Vite 3, all of the templates got a new theme in line with the new docs. Open them online and start playing with Vite 3 now:

<div class="stackblitz-links">
<a target="_blank" href="https://vite.new"><img width="75" height="75" src="../images/vite.svg" alt="Vite logo"></a>
<a target="_blank" href="https://vite.new/vue"><img width="75" height="75" src="../images/vue.svg" alt="Vue logo"></a>
<a target="_blank" href="https://vite.new/svelte"><img width="60" height="60" src="../images/svelte.svg" alt="Svelte logo"></a>
<a target="_blank" href="https://vite.new/react"><img width="75" height="75" src="../images/react.svg" alt="React logo"></a>
<a target="_blank" href="https://vite.new/preact"><img width="65" height="65" src="../images/preact.svg" alt="Preact logo"></a>
<a target="_blank" href="https://vite.new/lit"><img width="60" height="60" src="../images/lit.svg" alt="Lit logo"></a>
</div>

<style>
.stackblitz-links {
  display: flex;
  width: 100%;
  justify-content: space-around;
  align-items: center;
}
@media screen and (max-width: 550px) {
  .stackblitz-links {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    width: 100%;
    gap: 2rem;
    padding-left: 3rem;
    padding-right: 3rem;
  }
}
.stackblitz-links > a {
  width: 70px;
  height: 70px;
  display: grid;
  align-items: center;
  justify-items: center;
}
.stackblitz-links > a:hover {
  filter: drop-shadow(0 0 0.5em #646cffaa);
}
</style>

The theme is now shared by all templates. This should help better convey the scope for these starters as minimal templates to get started with Vite. For more complete solutions including linting, testing setup, and other features, there are official Vite-powered templates for some frameworks like [create-vue](https://github.com/vuejs/create-vue) and [create-svelte](https://github.com/sveltejs/kit). There is a community-maintained list of templates at [Awesome Vite](https://github.com/vitejs/awesome-vite#templates).

## Dev Improvements

### Vite CLI

<pre style="background-color: var(--vp-code-block-bg);padding:2em;border-radius:8px;max-width:100%;overflow-x:auto;">
  <span style="color:lightgreen"><b>VITE</b></span> <span style="color:lightgreen">v3.0.0</span>  <span style="color:gray">ready in <b>320</b> ms</span>

  <span style="color:lightgreen"><b>➜</b></span>  <span style="color:white"><b>Local</b>:</span>   <span style="color:cyan">http://127.0.0.1:5173/</span>
  <span style="color:green"><b>➜</b></span>  <span style="color:gray"><b>Network</b>: use --host to expose</span>
</pre>

Apart from the CLI’s aesthetics improvements, you’ll notice that the default dev server port is now 5173 and the preview server listening at 4173. This change ensures Vite will avoid collisions with other tools.

### Improved WebSocket Connection Strategy

One of the pain points of Vite 2 was configuring the server when running behind a proxy. Vite 3 changes the default connection scheme so it works out of the box in most scenarios. All these setups are now tested as part of the Vite Ecosystem CI through [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue).

### Cold Start Improvements

Vite now avoids full reload during cold start when imports are injected by plugins while crawling the initial statically imported modules ([#8869](https://github.com/vitejs/vite/issues/8869)).

<details>
  <summary><b>Click to learn more</b></summary>

In Vite 2.9, both the scanner and optimizer were run in the background. In the best scenario, where the scanner would find every dependency, no reload was needed in cold start. But if the scanner missed a dependency, a new optimization phase and then a reload were needed. Vite was able to avoid some of these reloads in v2.9, as we detected if the new optimized chunks were compatible with the ones the browser had. But if there was a common dep, the sub-chunks could change and a reload was required to avoid duplicated state. In Vite 3, the optimized deps aren't handed to the browser until the crawling of static imports is done. A quick optimization phase is issued if there is a missing dep (for example, injected by a plugin), and only then, the bundled deps are sent. So, a page reload is no longer needed for these cases.

</details>

<img style="background-color: var(--vp-code-block-bg);padding:4%;border-radius:8px;" width="100%" height="auto" src="../images/vite-3-cold-start.svg" alt="Two graphs comparing Vite 2.9 and Vite 3 optimization strategy">

### import.meta.glob

`import.meta.glob` support was rewritten. Read about the new features in the [Glob Import Guide](/guide/features.html#glob-import):

[Multiple Patterns](/guide/features.html#multiple-patterns) can be passed as an array

```js
import.meta.glob(['./dir/*.js', './another/*.js'])
```

[Negative Patterns](/guide/features.html#negative-patterns) are now supported (prefixed with `!`) to ignore some specific files

```js
import.meta.glob(['./dir/*.js', '!**/bar.js'])
```

[Named Imports](/guide/features.html#named-imports) can be specified to improve tree-shaking

```js
import.meta.glob('./dir/*.js', { import: 'setup' })
```

[Custom Queries](/guide/features.html#custom-queries) can be passed to attach metadata

```js
import.meta.glob('./dir/*.js', { query: { custom: 'data' } })
```

[Eager Imports](/guide/features.html#glob-import) is now passed as a flag

```js
import.meta.glob('./dir/*.js', { eager: true })
```

### Aligning WASM Import with Future Standards

The WebAssembly import API has been revised to avoid collisions with future standards and to make it more flexible:

```js
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})
```

Learn more in the [WebAssembly guide](/guide/features.html#webassembly)

## Build Improvements

### ESM SSR Build by Default

Most SSR frameworks in the ecosystem were already using ESM builds. So, Vite 3 makes ESM the default format for SSR builds. This allows us to streamline previous [SSR externalization heuristics](https://vite.dev/guide/ssr.html#ssr-externals), externalizing dependencies by default.

### Improved Relative Base Support

Vite 3 now properly supports relative base (using `base: ''`), allowing built assets to be deployed to different bases without re-building. This is useful when the base isn't known at build time, for example when deploying to content-addressable networks like [IPFS](https://ipfs.io/).

## Experimental Features

### Built Asset Paths fine-grained Control (Experimental)

There are other deploy scenarios where this isn't enough. For example, if the generated hashed assets need to be deployed to a different CDN from the public files, then finer-grained control is required over path generation at build time. Vite 3 provides an experimental API to modify the built file paths. Check [Build Advanced Base Options](/guide/build.html#advanced-base-options) for more information.

### Esbuild Deps Optimization at Build Time (Experimental)

One of the main differences between dev and build time is how Vite handles dependencies. During build time, [`@rollup/plugin-commonjs`](https://github.com/rollup/plugins/tree/master/packages/commonjs) is used to allow importing CJS only dependencies (like React). When using the dev server, esbuild is used instead to pre-bundle and optimize dependencies, and an inline interop scheme is applied while transforming user code importing CJS deps. During the development of Vite 3, we introduced the changes needed to also allow the use of [esbuild to optimize dependencies during build time](https://v3.vite.dev/guide/migration.html#using-esbuild-deps-optimization-at-build-time). [`@rollup/plugin-commonjs`](https://github.com/rollup/plugins/tree/master/packages/commonjs) can then be avoided, making dev and build time work in the same way.

Given that Rollup v3 will be out in the next months, and we're going to follow up with another Vite major, we've decided to make this mode optional to reduce v3 scope and give Vite and the ecosystem more time to work out possible issues with the new CJS interop approach during build time. Frameworks may switch to using esbuild deps optimization during build time by default at their own pace before Vite 4.

### HMR Partial Accept (Experimental)

There is opt-in support for [HMR Partial Accept](https://github.com/vitejs/vite/pull/7324). This feature could unlock finer-grained HMR for framework components that export several bindings in the same module. You can learn more at [the discussion for this proposal](https://github.com/vitejs/vite/discussions/7309).

## Bundle Size Reduction

Vite cares about its publish and install footprint; a fast installation of a new app is a feature. Vite bundles most of its dependencies and tries to use modern lightweight alternatives where possible. Continuing with this ongoing goal, Vite 3 publish size is 30% smaller than v2.

|             | Publish Size | Install Size |
| ----------- | :----------: | :----------: |
| Vite 2.9.14 |    4.38MB    |    19.1MB    |
| Vite 3.0.0  |    3.05MB    |    17.8MB    |
| Reduction   |     -30%     |     -7%      |

In part, this reduction was possible by making some dependencies that most users weren't needing optional. First, [Terser](https://github.com/terser/terser) is no longer installed by default. This dependency was no longer needed since we already made esbuild the default minifier for both JS and CSS in Vite 2. If you use `build.minify: 'terser'`, you'll need to install it (`npm add -D terser`). We also moved [node-forge](https://github.com/digitalbazaar/forge) out of the monorepo, implementing support for automatic https certificate generation as a new plugin: [`@vitejs/plugin-basic-ssl`](https://v3.vite.dev/guide/migration.html#automatic-https-certificate-generation). Since this feature only creates untrusted certificates that are not added to the local store, it didn't justify the added size.

## Bug Fixing

A triaging marathon was spearheaded by [@bluwyoo](https://twitter.com/bluwyoo), [@sapphi_red](https://twitter.com/sapphi_red), that recently joined the Vite team. During the past three months, the Vite open issues were reduced from 770 to 400. And this dive was achieved while the newly open PRs were at an all-time high. At the same time, [@haoqunjiang](https://twitter.com/haoqunjiang) had also curated a comprehensive [overview of Vite issues](https://github.com/vitejs/vite/discussions/8232).

[![Graph of open issues and pull requests in Vite](../images/v3-open-issues-and-PRs.webp)](https://www.repotrends.com/vitejs/vite)

[![Graph of new issues and pull requests in Vite](../images/v3-new-open-issues-and-PRs.webp)](https://www.repotrends.com/vitejs/vite)

## Compatibility Notes

- Vite no longer supports Node.js 12 / 13 / 15, which reached its EOL. Node.js 14.18+ / 16+ is now required.
- Vite is now published as ESM, with a CJS proxy to the ESM entry for compatibility.
- The Modern Browser Baseline now targets browsers which support the [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) features.
- JS file extensions in SSR and library mode now use a valid extension (`js`, `mjs`, or `cjs`) for output JS entries and chunks based on their format and the package type.

Learn more in the [Migration Guide](https://v3.vite.dev/guide/migration.html).

## Upgrades to Vite Core

While working towards Vite 3, we also improved the contributing experience for collaborators to [Vite Core](https://github.com/vitejs/vite).

- Unit and E2E tests have been migrated to [Vitest](https://vitest.dev), providing a faster and more stable DX. This move also works as dog fooding for an important infrastructure project in the ecosystem.
- VitePress build is now tested as part of CI.
- Vite upgraded to [pnpm 7](https://pnpm.io/), following the rest of the ecosystem.
- Playgrounds have been moved to [`/playgrounds`](https://github.com/vitejs/vite/tree/main/playground) out of packages directory.
- The packages and playgrounds are now `"type": "module"`.
- Plugins are now bundled using [unbuild](https://github.com/unjs/unbuild), and [plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) and [plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) were moved to TypeScript.

## The Ecosystem is Ready for v3

We have worked closely with projects in the ecosystem to ensure that frameworks powered by Vite are ready for Vite 3. [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci) allows us to run the CI's from the leading players in the ecosystem against Vite's main branch and receive timely reports before introducing a regression. Today's release should soon be compatible with most projects using Vite.

## Acknowledgments

Vite 3 is the result of the aggregate effort of members of the [Vite Team](/team) working together with ecosystem project maintainers and other collaborators to Vite core.

We want to thank everyone that have implemented features, and fixes, given feedback, and have been involved in Vite 3:

- Vite team members [@youyuxi](https://twitter.com/youyuxi), [@patak_dev](https://twitter.com/patak_dev), [@antfu7](https://twitter.com/antfu7), [@bluwyoo](https://twitter.com/bluwyoo), [@sapphi_red](https://twitter.com/sapphi_red), [@haoqunjiang](https://twitter.com/haoqunjiang), [@poyoho](https://github.com/poyoho), [@Shini_92](https://twitter.com/Shini_92), and [@retropragma](https://twitter.com/retropragma).
- [@benmccann](https://github.com/benmccann), [@danielcroe](https://twitter.com/danielcroe), [@brillout](https://twitter.com/brillout), [@sheremet_va](https://twitter.com/sheremet_va), [@userquin](https://twitter.com/userquin), [@enzoinnocenzi](https://twitter.com/enzoinnocenzi), [@maximomussini](https://twitter.com/maximomussini), [@IanVanSchooten](https://twitter.com/IanVanSchooten), the [Astro team](https://astro.build/), and all other maintainers of frameworks and plugins in the ecosystem in that helped shape v3.
- [@dominikg](https://github.com/dominikg) for his work on vite-ecosystem-ci.
- [@ZoltanKochan](https://twitter.com/ZoltanKochan) for his work on [pnpm](https://pnpm.io/), and for his responsiveness when we needed support with it.
- [@rixo](https://github.com/rixo) for HMR Partial Accept support.
- [@KiaKing85](https://twitter.com/KiaKing85) for getting the theme ready for the Vite 3 release, and [@\_brc_dd](https://twitter.com/_brc_dd) for working on the VitePress internals.
- [@CodingWithCego](https://twitter.com/CodingWithCego) for the new Spanish translation, and [@ShenQingchuan](https://twitter.com/ShenQingchuan), [@hiro-lapis](https://github.com/hiro-lapis) and others in the Chinese and Japanese translations teams for keeping the translated docs up to date.

We also want to thank individuals and companies sponsoring the Vite team, and companies investing in Vite development: some of [@antfu7](https://twitter.com/antfu7)'s work on Vite and the ecosystem is part of his job at [Nuxt Labs](https://nuxtlabs.com/), and [StackBlitz](https://stackblitz.com/) hired [@patak_dev](https://twitter.com/patak_dev) to work full time on Vite.

## What's Next

We'll take the following months to ensure a smooth transition for all the projects built on top of Vite. So the first minors will be focused on continuing our triaging efforts with a focus on newly opened issues.

The Rollup team is [working on its next major](https://twitter.com/lukastaegert/status/1544186847399743488), to be released in the following months. Once the Rollup plugins ecosystem has time to update, we'll follow up with a new Vite major. This will give us another opportunity to introduce more significant changes this year, which we could take to stabilize some of the experimental features introduced in this release.

If you are interested in helping improve Vite, the best way to get on board is to help with triaging issues. Join [our Discord](https://chat.vite.dev) and look for the `#contributing` channel. Or get involved in our `#docs`, `#help` others, or create plugins. We are just getting started. There are many open ideas to keep improving Vite's DX.



================================================
FILE: docs/blog/announcing-vite4-3.md
================================================
---
title: Vite 4.3 is out!
author:
  name: The Vite Team
date: 2023-04-20
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 4.3
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite4-3.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite4-3
  - - meta
    - property: og:description
      content: Vite 4.3 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 4.3 is out!

_April 20, 2023_

![Vite 4.3 Announcement Cover Image](/og-image-announcing-vite4-3.webp)

Quick links:

- Docs: [English](/), [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/)
- [Vite 4.3 Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#430-2023-04-20)

## Performance Improvements

In this minor, we focused on improving the dev server performance. The resolve logic got streamlined, improving hot paths and implementing smarter caching for finding `package.json`, TS config files, and resolved URL in general.

You can read a detailed walkthrough of the performance work done in this blog post by one of Vite Contributors: [How we made Vite 4.3 faaaaster 🚀](https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html).

This sprint resulted in speed improvements across the board compared to Vite 4.2.

These are the performance improvements as measured by [sapphi-red/performance-compare](https://github.com/sapphi-red/performance-compare), which tests an app with 1000 React Components cold and warm dev server startup time as well as HMR times for a root and a leaf component:

| **Vite (babel)**   |  Vite 4.2 | Vite 4.3 | Improvement |
| :----------------- | --------: | -------: | ----------: |
| **dev cold start** | 17249.0ms | 5132.4ms |      -70.2% |
| **dev warm start** |  6027.8ms | 4536.1ms |      -24.7% |
| **Root HMR**       |    46.8ms |   26.7ms |      -42.9% |
| **Leaf HMR**       |    27.0ms |   12.9ms |      -52.2% |

| **Vite (swc)**     |  Vite 4.2 | Vite 4.3 | Improvement |
| :----------------- | --------: | -------: | ----------: |
| **dev cold start** | 13552.5ms | 3201.0ms |      -76.4% |
| **dev warm start** |  4625.5ms | 2834.4ms |      -38.7% |
| **Root HMR**       |    30.5ms |   24.0ms |      -21.3% |
| **Leaf HMR**       |    16.9ms |   10.0ms |      -40.8% |

![Vite 4.3 vs 4.2 startup time comparison](../images/vite4-3-startup-time.webp)

![Vite 4.3 vs 4.2 HMR time comparison](../images/vite4-3-hmr-time.webp)

You can read more information about the benchmark [here](https://gist.github.com/sapphi-red/25be97327ee64a3c1dce793444afdf6e). Specs and Versions for this performance run:

- CPU: Ryzen 9 5900X, Memory: DDR4-3600 32GB, SSD: WD Blue SN550 NVME SSD
- Windows 10 Pro 21H2 19044.2846
- Node.js 18.16.0
- Vite and React Plugin versions
  - Vite 4.2 (babel): Vite 4.2.1 + plugin-react 3.1.0
  - Vite 4.3 (babel): Vite 4.3.0 + plugin-react 4.0.0-beta.1
  - Vite 4.2 (swc): Vite 4.2.1 + plugin-react-swc 3.2.0
  - Vite 4.3 (swc): Vite 4.3.0 + plugin-react-swc 3.3.0

Early adopters have also reported seeing 1.5x-2x dev startup time improvement on real apps while testing the Vite 4.3 beta. We'd love to know the results for your apps.

## Profiling

We'll continue to work on Vite's performance. We're working on an official [Benchmark tool](https://github.com/vitejs/vite-benchmark) for Vite that let us get performance metrics for each Pull Request.

And [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) now has more performance-related features to help you identify which plugins or middlewares are the bottleneck for your applications.

Using `vite --profile` (and then pressing `p`) once the page loads will save a CPU profile of the dev server startup. You can open them in an app as [speedscope](https://www.speedscope.app/) to identify performance issues. And you can share your findings with the Vite Team in a [Discussion](https://github.com/vitejs/vite/discussions) or in [Vite's Discord](https://chat.vite.dev).

## Next Steps

We decided to do a single Vite Major this year aligning with the [EOL of Node.js 16](https://endoflife.date/nodejs) in September, dropping support for both Node.js 14 and 16 in it. If you would like to get involved, we started a [Vite 5 Discussion](https://github.com/vitejs/vite/discussions/12466) to gather early feedback.



================================================
FILE: docs/blog/announcing-vite4.md
================================================
---
title: Vite 4.0 is out!
author:
  name: The Vite Team
date: 2022-12-09
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 4
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite4.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite4
  - - meta
    - property: og:description
      content: Vite 4 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 4.0 is out!

_December 9, 2022_ - Check out the [Vite 5.0 announcement](./announcing-vite5.md)

Vite 3 [was released](./announcing-vite3.md) five months ago. npm downloads per week have gone from 1 million to 2.5 million since then. The ecosystem has matured too, and continues to grow. In this year's [Jamstack Conf survey](https://twitter.com/vite_js/status/1589665610119585793), usage among the community jumped from 14% to 32% while keeping a high 9.7 satisfaction score. We saw the stable releases of [Astro 1.0](https://astro.build/), [Nuxt 3](https://v3.nuxtjs.org/), and other Vite-powered frameworks that are innovating and collaborating: [SvelteKit](https://kit.svelte.dev/), [Solid Start](https://www.solidjs.com/blog/introducing-solidstart), [Qwik City](https://qwik.builder.io/qwikcity/overview/). Storybook announced first-class support for Vite as one of its main features for [Storybook 7.0](https://storybook.js.org/blog/first-class-vite-support-in-storybook/). Deno now [supports Vite](https://www.youtube.com/watch?v=Zjojo9wdvmY). [Vitest](https://vitest.dev) adoption is exploding, it will soon represent half of Vite's npm downloads. Nx is also investing in the ecosystem, and [officially supports Vite](https://nx.dev/packages/vite).

[![Vite 4 Ecosystem](../images/ecosystem-vite4.webp)](https://viteconf.org/2022/replay)

As a showcase of the growth Vite and related projects have experienced, the Vite ecosystem gathered on October 11th at [ViteConf 2022](https://viteconf.org/2022/replay). We saw representatives from the main web framework and tools tell stories of innovation and collaboration. And in a symbolic move, the Rollup team choose that exact day to release [Rollup 3](https://rollupjs.org).

Today, the Vite [team](https://vite.dev/team) with the help of our ecosystem partners, is happy to announce the release of Vite 4, powered during build time by Rollup 3. We've worked with the ecosystem to ensure a smooth upgrade path for this new major. Vite is now using [Rollup 3](https://github.com/vitejs/vite/issues/9870), which allowed us to simplify Vite's internal asset handling and has many improvements. See the [Rollup 3 release notes here](https://github.com/rollup/rollup/releases/tag/v3.0.0).

![Vite 4 Announcement Cover Image](/og-image-announcing-vite4.webp)

Quick links:

- [Docs](/)
- [Migration Guide](https://v4.vite.dev/guide/migration.html)
- [Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#400-2022-12-09)

Docs in other languages:

- [简体中文](https://cn.vite.dev/)
- [日本語](https://ja.vite.dev/)
- [Español](https://es.vite.dev/)

If you recently started using Vite, we suggest reading the [Why Vite Guide](https://vite.dev/guide/why.html) and checking out [the Getting Started](https://vite.dev/guide/) and [Features guide](https://vite.dev/guide/features). If you want to get involved, contributions are welcome at [GitHub](https://github.com/vitejs/vite). Almost [700 collaborators](https://github.com/vitejs/vite/graphs/contributors) have contributed to Vite. Follow the updates on [Twitter](https://twitter.com/vite_js) and [Mastodon](https://webtoo.ls/@vite), or join collaborate with others on our [Discord community](http://chat.vite.dev/).

## Start playing with Vite 4

Use `pnpm create vite` to scaffold a Vite project with your preferred framework, or open a started template online to play with Vite 4 using [vite.new](https://vite.new).

You can also run `pnpm create vite-extra` to get access to templates from other frameworks and runtimes (Solid, Deno, SSR, and library starters). `create vite-extra` templates are also available when you run `create vite` under the `Others` option.

Note that Vite starter templates are intended to be used as a playground to test Vite with different frameworks. When building your next project, we recommend reaching out to the starters recommended by each framework. Some frameworks now redirect in `create vite` to their starters too (`create-vue` and `Nuxt 3` for Vue, and `SvelteKit` for Svelte).

## New React plugin using SWC during development

[SWC](https://swc.rs/) is now a mature replacement for [Babel](https://babeljs.io/), especially in the context of React projects. SWC's React Fast Refresh implementation is a lot faster than Babel, and for some projects, it is now a better alternative. From Vite 4, two plugins are available for React projects with different tradeoffs. We believe that both approaches are worth supporting at this point, and we'll continue to explore improvements to both plugins in the future.

### @vitejs/plugin-react

[@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react) is a plugin that uses esbuild and Babel, achieving fast HMR with a small package footprint and the flexibility of being able to use the Babel transform pipeline.

### @vitejs/plugin-react-swc (new)

[@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) is a new plugin that uses esbuild during build, but replaces Babel with SWC during development. For big projects that don't require non-standard React extensions, cold start and Hot Module Replacement (HMR) can be significantly faster.

## Browser Compatibility

The modern browser build now targets `safari14` by default for wider ES2020 compatibility. This means that modern builds can now use [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) and that the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) isn't transpiled anymore. If you need to support older browsers, you can add [`@vitejs/plugin-legacy`](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) as usual.

## Importing CSS as a String

In Vite 3, importing the default export of a `.css` file could introduce a double loading of CSS.

```ts
import cssString from './global.css'
```

This double loading could occur since a `.css` file will be emitted and it's likely that the CSS string will also be used by the application code — for example, injected by the framework runtime. From Vite 4, the `.css` default export [has been deprecated](https://github.com/vitejs/vite/issues/11094). The `?inline` query suffix modifier needs to be used in this case, as that doesn't emit the imported `.css` styles.

```ts
import stuff from './global.css?inline'
```

Learn more in the [Migration Guide](https://v4.vite.dev/guide/migration.html).

## Environment Variables

Vite now uses `dotenv` 16 and `dotenv-expand` 9 (previously `dotenv` 14 and `dotenv-expand` 5). If you have a value including `#` or `` ` ``, you will need to wrap them with quotes.

```diff
-VITE_APP=ab#cd`ef
+VITE_APP="ab#cd`ef"
```

For more details, see the [`dotenv`](https://github.com/motdotla/dotenv/blob/master/CHANGELOG.md) and [`dotenv-expand` changelog](https://github.com/motdotla/dotenv-expand/blob/master/CHANGELOG.md).

## Other Features

- CLI Shortcuts (press `h` during dev to see them all) ([#11228](https://github.com/vitejs/vite/pull/11228))
- Support for patch-package when pre bundling dependencies ([#10286](https://github.com/vitejs/vite/issues/10286))
- Cleaner build logs output ([#10895](https://github.com/vitejs/vite/issues/10895)) and switch to `kB` to align with browser dev tools ([#10982](https://github.com/vitejs/vite/issues/10982))
- Improved error messages during SSR ([#11156](https://github.com/vitejs/vite/issues/11156))

## Reduced Package Size

Vite cares about its footprint, to speed up installation, especially in the use case of playgrounds for documentation and reproductions. And once more, this major brings improvements in Vite's package size. Vite 4 install size is 23% smaller compared to vite 3.2.5 (14.1 MB vs 18.3 MB).

## Upgrades to Vite Core

[Vite Core](https://github.com/vitejs/vite) and [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci) continue to evolve to provide a better experience to maintainers and collaborators and to ensure that Vite development scales to cope with the growth in the ecosystem.

### Framework plugins out of core

[`@vitejs/plugin-vue`](https://github.com/vitejs/vite-plugin-vue) and [`@vitejs/plugin-react`](https://github.com/vitejs/vite-plugin-react) have been part of Vite core monorepo since the first versions of Vite. This helped us to get a close feedback loop when making changes as we were getting both Core and the plugins tested and released together. With [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci) we can get this feedback with these plugins developed on independent repositories, so from Vite 4, [they have been moved out of the Vite core monorepo](https://github.com/vitejs/vite/pull/11158). This is meaningful for Vite's framework-agnostic story and will allow us to build independent teams to maintain each of the plugins. If you have bugs to report or features to request, please create issues on the new repositories moving forward: [`vitejs/vite-plugin-vue`](https://github.com/vitejs/vite-plugin-vue) and [`vitejs/vite-plugin-react`](https://github.com/vitejs/vite-plugin-react).

### vite-ecosystem-ci improvements

[vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci) extends Vite's CI by providing on-demand status reports on the state of the CIs of [most major downstream projects](https://github.com/vitejs/vite-ecosystem-ci/tree/main/tests). We run vite-ecosystem-ci three times a week against Vite's main branch and receive timely reports before introducing a regression. Vite 4 will soon be compatible with most projects using Vite, which already prepared branches with the needed changes and will be releasing them in the next few days. We are also able to run vite-ecosystem-ci on-demand on PRs using `/ecosystem-ci run` in a comment, allowing us to know [the effect of changes](https://github.com/vitejs/vite/pull/11269#issuecomment-1343365064) before they hit main.

## Acknowledgments

Vite 4 wouldn't be possible without uncountable hours of work by Vite contributors, many of them maintainers of downstream projects and plugins, and the efforts of the [Vite Team](/team). All of us have worked together to improve Vite's DX once more, for every framework and app using it. We're grateful to be able to improve a common base for such a vibrant ecosystem.

We're also thankful to individuals and companies sponsoring the Vite team, and companies investing directly in Vite's future: [@antfu7](https://twitter.com/antfu7)'s work on Vite and the ecosystem is part of his job at [Nuxt Labs](https://nuxtlabs.com/), [Astro](https://astro.build) is funding [@bluwyoo](https://twitter.com/bluwyoo)'s' Vite core work, and [StackBlitz](https://stackblitz.com/) hires [@patak_dev](https://twitter.com/patak_dev) to work full time on Vite.

## Next steps

Our immediate focus would be on triaging newly opened issues to avoid disruption by possible regressions. If you would like to get involved and help us improve Vite, we suggest starting with issues triaging. Join [our Discord](https://chat.vite.dev) and reach out on the `#contributing` channel. Polish our `#docs` story, and `#help` others. We need to continue to build a helpful and welcoming community for the next wave of users, as Vite's adoption continues to grow.

There are a lot of open fronts to keep improving the DX of everyone that has chosen Vite to power their frameworks and develop their apps. Onwards!



================================================
FILE: docs/blog/announcing-vite5-1.md
================================================
---
title: Vite 5.1 is out!
author:
  name: The Vite Team
date: 2024-02-08
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 5.1
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite5-1.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite5-1
  - - meta
    - property: og:description
      content: Vite 5.1 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 5.1 is out!

_February 8, 2024_

![Vite 5.1 Announcement Cover Image](/og-image-announcing-vite5-1.webp)

Vite 5 [was released](./announcing-vite5.md) last November, and it represented another big leap for Vite and the ecosystem. A few weeks ago we celebrated 10 million weekly npm downloads and 900 contributors to the Vite repo. Today, we're excited to announce the release of Vite 5.1.

Quick links: [Docs](/), [Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#510-2024-02-08)

Docs in other languages: [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/), [한국어](https://ko.vite.dev/), [Deutsch](https://de.vite.dev/)

Try Vite 5.1 online in StackBlitz: [vanilla](https://vite.new/vanilla-ts), [vue](https://vite.new/vue-ts), [react](https://vite.new/react-ts), [preact](https://vite.new/preact-ts), [lit](https://vite.new/lit-ts), [svelte](https://vite.new/svelte-ts), [solid](https://vite.new/solid-ts), [qwik](https://vite.new/qwik-ts).

If you're new to Vite, we suggest reading first the [Getting Started](/guide/) and [Features](/guide/features) guides.

To stay up to date, follow us on [X](https://x.com/vite_js) or [Mastodon](https://webtoo.ls/@vite).

## Vite Runtime API

Vite 5.1 adds experimental support for a new Vite Runtime API. It allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runtime implementation is decoupled from the server. This lets library and framework authors implement their own layer of communication between the server and the runtime. This new API is intended to replace Vite's current SSR primitives once it is stable.

The new API brings many benefits:

- Support for HMR during SSR.
- It is decoupled from the server, so there is no limit on how many clients can use a single server - every client has its own module cache (you can even communicate with it how you want - using message channel/fetch call/direct function call/websocket).
- It doesn't depend on any node/bun/deno built-in APIs, so it can run in any environment.
- It's easy to integrate with tools that have their own mechanism to run code (you can provide a runner to use `eval` instead of `new AsyncFunction` for example).

The initial idea [was proposed by Pooya Parsa](https://github.com/nuxt/vite/pull/201) and implemented by [Anthony Fu](https://github.com/antfu) as the [vite-node](https://github.com/vitest-dev/vitest/tree/main/packages/vite-node#readme) package to [power Nuxt 3 Dev SSR](https://antfu.me/posts/dev-ssr-on-nuxt) and later also used as the base for [Vitest](https://vitest.dev). So the general idea of vite-node has been battle-tested for quite some time now. This is a new iteration of the API by [Vladimir Sheremet](https://github.com/sheremet-va), who had already re-implemented vite-node in Vitest and took the learnings to make the API even more powerful and flexible when adding it to Vite Core. The PR was one year in the makings, you can see the evolution and discussions with ecosystem maintainers [here](https://github.com/vitejs/vite/issues/12165).

::: info
The Vite Runtime API evolved into the Module Runner API, released in Vite 6 as part of the [Environment API](/guide/api-environment).
:::

## Features

### Improved support for `.css?url`

Import CSS files as URLs now works reliably and correctly. This was the last remaining hurdle in Remix's move to Vite. See ([#15259](https://github.com/vitejs/vite/issues/15259)).

### `build.assetsInlineLimit` now supports a callback

Users can now [provide a callback](/config/build-options.html#build-assetsinlinelimit) that returns a boolean to opt-in or opt-out of inlining for specific assets. If `undefined` is returned, the default logic applies. See ([#15366](https://github.com/vitejs/vite/issues/15366)).

### Improved HMR for circular import

In Vite 5.0, accepted modules within circular imports always triggered a full page reload even if they can be handled fine in the client. This is now relaxed to allow HMR to apply without a full page reload, but if any error happens during HMR, the page will be reloaded. See ([#15118](https://github.com/vitejs/vite/issues/15118)).

### Support `ssr.external: true` to externalize all SSR packages

Historically, Vite externalizes all packages except for linked packages. This new option can be used to force externalize all packages including linked packages too. This is handy in tests within monorepos where we want to emulate the usual case of all packages externalized, or when using `ssrLoadModule` to load an arbitrary file and we want to always external packages as we don't care about HMR. See ([#10939](https://github.com/vitejs/vite/issues/10939)).

### Expose `close` method in the preview server

The preview server now exposes a `close` method, which will properly teardown the server including all opened socket connections. See ([#15630](https://github.com/vitejs/vite/issues/15630)).

## Performance improvements

Vite keeps getting faster with each release, and Vite 5.1 is packed with performance improvements. We measured the loading time for 10K modules (25 level deep tree) using [vite-dev-server-perf](https://github.com/yyx990803/vite-dev-server-perf) for all minor versions from Vite 4.0. This is a good benchmark to measure the effect of Vite's bundle-less approach. Each module is a small TypeScript file with a counter and imports to other files in the tree, so this mostly measuring the time it takes to do the requests a separate modules. In Vite 4.0, loading 10K modules took 8 seconds on a M1 MAX. We had a breakthrough in [Vite 4.3 were we focused on performance](./announcing-vite4-3.md), and we were able to load them in 6.35 seconds. In Vite 5.1, we managed to do another performance leap. Vite is now serving the 10K modules in 5.35 seconds.

![Vite 10K Modules Loading time progression](../images/vite5-1-10K-modules-loading-time.webp)

The results of this benchmark run on Headless Puppeteer and are a good way to compare versions. They don't represent the time as experienced by users though. When running the same 10K modules in an Incognito window is Chrome, we have:

| 10K Modules           | Vite 5.0 | Vite 5.1 |
| --------------------- | :------: | :------: |
| Loading time          |  2892ms  |  2765ms  |
| Loading time (cached) |  2778ms  |  2477ms  |
| Full reload           |  2003ms  |  1878ms  |
| Full reload (cached)  |  1682ms  |  1604ms  |

### Run CSS preprocessors in threads

Vite now has opt-in support for running CSS preprocessors in threads. You can enable it using [`css.preprocessorMaxWorkers: true`](/config/shared-options.html#css-preprocessormaxworkers). For a Vuetify 2 project, dev startup time was reduced by 40% with this feature enabled. There is [performance comparison for others setups in the PR](https://github.com/vitejs/vite/pull/13584#issuecomment-1678827918). See ([#13584](https://github.com/vitejs/vite/issues/13584)). [Give Feedback](https://github.com/vitejs/vite/discussions/15835).

### New options to improve server cold starts

You can set `optimizeDeps.holdUntilCrawlEnd: false` to switch to a new strategy for deps optimization that may help in big projects. We're considering switching to this strategy by default in the future. [Give Feedback](https://github.com/vitejs/vite/discussions/15834). ([#15244](https://github.com/vitejs/vite/issues/15244))

### Faster resolving with cached checks

The `fs.cachedChecks` optimization is now enabled by default. In Windows, `tryFsResolve` was ~14x faster with it, and resolving ids overall got a ~5x speed up in the triangle benchmark. ([#15704](https://github.com/vitejs/vite/issues/15704))

### Internal performance improvements

The dev server had several incremental performance gains. A new middleware to short-circuit on 304 ([#15586](https://github.com/vitejs/vite/issues/15586)). We avoided `parseRequest` in hot paths ([#15617](https://github.com/vitejs/vite/issues/15617)). Rollup is now properly lazy loaded ([#15621](https://github.com/vitejs/vite/issues/15621))

## Deprecations

We continue to reduce Vite's API surface where possible to make the project maintainable long term.

### Deprecated `as` option in `import.meta.glob`

The standard moved to [Import Attributes](https://github.com/tc39/proposal-import-attributes), but we don't plan to replace `as` with a new option at this point. Instead, it is recommended that the user switches to `query`. See ([#14420](https://github.com/vitejs/vite/issues/14420)).

### Removed experimental build-time pre-bundling

Build-time pre-bundling, an experimental feature added in Vite 3, is removed. With Rollup 4 switching its parser to native, and Rolldown being worked on, both the performance and the dev-vs-build inconsistency story for this feature are no longer valid. We want to continue improving dev/build consistency, and have concluded that using Rolldown for "prebundling during dev" and "production builds" is the better bet moving forward. Rolldown may also implement caching in a way that is a lot more efficient during build than deps prebundling. See ([#15184](https://github.com/vitejs/vite/issues/15184)).

## Get Involved

We are grateful to the [900 contributors to Vite Core](https://github.com/vitejs/vite/graphs/contributors), and the maintainers of plugins, integrations, tools, and translations that keeps pushing the ecosystem forward. If you're enjoying Vite, we invite you to participate and help us. Check out our [Contributing Guide](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md), and jump into [triaging issues](https://github.com/vitejs/vite/issues), [reviewing PRs](https://github.com/vitejs/vite/pulls), answering questions at [GitHub Discussions](https://github.com/vitejs/vite/discussions) and helping others in the community in [Vite Land](https://chat.vite.dev).

## Acknowledgments

Vite 5.1 is possible thanks to our community of contributors, maintainers in the ecosystem, and the [Vite Team](/team). A shout out to the individuals and companies sponsoring Vite development. [StackBlitz](https://stackblitz.com/), [Nuxt Labs](https://nuxtlabs.com/), and [Astro](https://astro.build) for hiring Vite team members. And also to the sponsors on [Vite's GitHub Sponsors](https://github.com/sponsors/vitejs), [Vite's Open Collective](https://opencollective.com/vite), and [Evan You's GitHub Sponsors](https://github.com/sponsors/yyx990803).



================================================
FILE: docs/blog/announcing-vite5.md
================================================
---
title: Vite 5.0 is out!
author:
  name: The Vite Team
date: 2023-11-16
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 5
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite5.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite5
  - - meta
    - property: og:description
      content: Vite 5 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 5.0 is out!

_November 16, 2023_

![Vite 5 Announcement Cover Image](/og-image-announcing-vite5.webp)

Vite 4 [was released](./announcing-vite4.md) almost a year ago, and it served as a solid base for the ecosystem. npm downloads per week jumped from 2.5 million to 7.5 million, as projects keep building on a shared infrastructure. Frameworks continued to innovate, and on top of [Astro](https://astro.build/), [Nuxt](https://nuxt.com/), [SvelteKit](https://kit.svelte.dev/), [Solid Start](https://www.solidjs.com/blog/introducing-solidstart), [Qwik City](https://qwik.builder.io/qwikcity/overview/), between others, we saw new frameworks joining and making the ecosystem stronger. [RedwoodJS](https://redwoodjs.com/) and [Remix](https://remix.run/) switching to Vite paves the way for further adoption in the React ecosystem. [Vitest](https://vitest.dev) kept growing at an even faster pace than Vite. Its team has been hard at work and will soon [release Vitest 1.0](https://github.com/vitest-dev/vitest/issues/3596). The story of Vite when used with other tools such as [Storybook](https://storybook.js.org), [Nx](https://nx.dev), and [Playwright](https://playwright.dev) kept improving, and the same goes for environments, with Vite dev working both in [Deno](https://deno.com) and [Bun](https://bun.sh).

We had the second edition of [ViteConf](https://viteconf.org/23/replay) a month ago, hosted by [StackBlitz](https://stackblitz.com). Like last year, most of the projects in the ecosystem got together to share ideas and connect to keep expanding the commons. We're also seeing new pieces complement the meta-framework tool belt like [Volar](https://volarjs.dev/) and [Nitro](https://nitro.build/). The Rollup team released [Rollup 4](https://rollupjs.org) that same day, a tradition Lukas started last year.

Six months ago, Vite 4.3 [was released](./announcing-vite4.md). This release significantly improved the dev server performance. However, there is still ample room for improvement. At ViteConf, [Evan You unveiled Vite's long-term plan to work on Rolldown](https://www.youtube.com/watch?v=hrdwQHoAp0M), a Rust-port of Rollup with compatible APIs. Once it is ready, we intend to use it in Vite Core to take on the tasks of both Rollup and esbuild. This will mean a boost in build performance (and later on in dev performance too as we move perf-sensitive parts of Vite itself to Rust), and a big reduction of inconsistencies between dev and build. Rolldown is currently in early stages and the team is preparing to open source the codebase before the end of the year. Stay tuned!

Today, we mark another big milestone in Vite's path. The Vite [team](/team), [contributors](https://github.com/vitejs/vite/graphs/contributors), and ecosystem partners, are excited to announce the release of Vite 5. Vite is now using [Rollup 4](https://github.com/vitejs/vite/pull/14508), which already represents a big boost in build performance. And there are also new options to improve your dev server performance profile.

Vite 5 focuses on cleaning up the API (removing deprecated features) and streamlines several features closing long-standing issues, for example switching `define` to use proper AST replacements instead of regexes. We also continue to take steps to future-proof Vite (Node.js 18+ is now required, and [the CJS Node API has been deprecated](/guide/migration#deprecate-cjs-node-api)).

Quick links:

- [Docs](/)
- [Migration Guide](/guide/migration)
- [Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#500-2023-11-16)

Docs in other languages:

- [简体中文](https://cn.vite.dev/)
- [日本語](https://ja.vite.dev/)
- [Español](https://es.vite.dev/)
- [Português](https://pt.vite.dev/)
- [한국어](https://ko.vite.dev/)
- [Deutsch](https://de.vite.dev/) (new translation!)

If you're new to Vite, we suggest reading first the [Getting Started](/guide/) and [Features](/guide/features) guides.

We appreciate the more than [850 contributors to Vite Core](https://github.com/vitejs/vite/graphs/contributors), and the maintainers and contributors of Vite plugins, integrations, tools, and translations that have helped us reach here. We encourage you to get involved and continue to improve Vite with us. You can learn more at our [Contributing Guide](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md). To get started, we recommend [triaging issues](https://github.com/vitejs/vite/issues), [reviewing PRs](https://github.com/vitejs/vite/pulls), sending failing tests PRs based on open issues, and helping others in [Discussions](https://github.com/vitejs/vite/discussions) and Vite Land's [help forum](https://discord.com/channels/804011606160703521/1019670660856942652). You'll learn a lot along the way and have a smooth path to further contributions to the project. If you have doubts, join us on our [Discord community](http://chat.vite.dev/) and say hi on the [#contributing channel](https://discord.com/channels/804011606160703521/804439875226173480).

To stay up to date, follow us on [X](https://twitter.com/vite_js) or [Mastodon](https://webtoo.ls/@vite).

## Quick start with Vite 5

Use `pnpm create vite` to scaffold a Vite project with your preferred framework, or open a started template online to play with Vite 5 using [vite.new](https://vite.new). You can also run `pnpm create vite-extra` to get access to templates from other frameworks and runtimes (Solid, Deno, SSR, and library starters). `create vite-extra` templates are also available when you run `create vite` under the `Others` option.

Note that Vite starter templates are intended to be used as a playground to test Vite with different frameworks. When building your next project, we recommend reaching out to the starters recommended by each framework. Some frameworks now redirect in `create vite` to their starters too (`create-vue` and `Nuxt 3` for Vue, and `SvelteKit` for Svelte).

## Node.js Support

Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.

## Performance

On top of Rollup 4's build performance improvements, there is a new guide to help you identify and fix common performance issues at [https://vite.dev/guide/performance](/guide/performance).

Vite 5 also introduces [server.warmup](/guide/performance.html#warm-up-frequently-used-files), a new feature to improve startup time. It lets you define a list of modules that should be pre-transformed as soon as the server starts. When using [`--open` or `server.open`](/config/server-options.html#server-open), Vite will also automatically warm up the entry point of your app or the provided URL to open.

## Main Changes

- [Vite is now powered by Rollup 4](/guide/migration#rollup-4)
- [The CJS Node API has been deprecated](/guide/migration#deprecate-cjs-node-api)
- [Rework `define` and `import.meta.env.*` replacement strategy](/guide/migration#rework-define-and-import-meta-env-replacement-strategy)
- [SSR externalized modules value now matches production](/guide/migration#ssr-externalized-modules-value-now-matches-production)
- [`worker.plugins` is now a function](/guide/migration#worker-plugins-is-now-a-function)
- [Allow path containing `.` to fallback to index.html](/guide/migration#allow-path-containing-to-fallback-to-index-html)
- [Align dev and preview HTML serving behavior](/guide/migration#align-dev-and-preview-html-serving-behaviour)
- [Manifest files are now generated in `.vite` directory by default](/guide/migration#manifest-files-are-now-generated-in-vite-directory-by-default)
- [CLI shortcuts require an additional `Enter` press](/guide/migration#cli-shortcuts-require-an-additional-enter-press)
- [Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behavior](/guide/migration#update-experimentaldecorators-and-usedefineforclassfields-typescript-behaviour)
- [Remove `--https` flag and `https: true`](/guide/migration#remove-https-flag-and-https-true)
- [Remove `resolvePackageEntry` and `resolvePackageData` APIs](/guide/migration#remove-resolvepackageentry-and-resolvepackagedata-apis)
- [Removes previously deprecated APIs](/guide/migration#removed-deprecated-apis)
- [Read more about advanced changes affecting plugin and tool authors](/guide/migration#advanced)

## Migrating to Vite 5

We have worked with ecosystem partners to ensure a smooth migration to this new major. Once again, [vite-ecosystem-ci](https://www.youtube.com/watch?v=7L4I4lDzO48) has been crucial to help us make bolder changes while avoiding regressions. We're thrilled to see other ecosystems adopt similar schemes to improve the collaboration between their projects and downstream maintainers.

For most projects, the update to Vite 5 should be straight forward. But we advise reviewing the [detailed Migration Guide](/guide/migration) before upgrading.

A low level breakdown with the full list of changes to Vite core can be found at the [Vite 5 Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#500-2023-11-16).

## Acknowledgments

Vite 5 is the result of long hours of work by our community of contributors, downstream maintainers, plugins authors, and the [Vite Team](/team). A big shout out to [Bjorn Lu](https://twitter.com/bluwyoo) for leading the release process for this major.

We're also thankful to individuals and companies sponsoring Vite development. [StackBlitz](https://stackblitz.com/), [Nuxt Labs](https://nuxtlabs.com/), and [Astro](https://astro.build) continue to invest in Vite by hiring Vite team members. A shout out to sponsors on [Vite's GitHub Sponsors](https://github.com/sponsors/vitejs), [Vite's Open Collective](https://opencollective.com/vite), and [Evan You's GitHub Sponsors](https://github.com/sponsors/yyx990803). A special mention to [Remix](https://remix.run/) for becoming a Gold sponsor and contributing back after switching to Vite.



================================================
FILE: docs/blog/announcing-vite6.md
================================================
---
title: Vite 6.0 is out!
author:
  name: The Vite Team
date: 2024-11-26
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 6
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite6.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite6
  - - meta
    - property: og:description
      content: Vite 6 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 6.0 is out!

_November 26, 2024_

![Vite 6 Announcement Cover Image](/og-image-announcing-vite6.webp)

Today, we're taking another big step in Vite's story. The Vite [team](/team), [contributors](https://github.com/vitejs/vite/graphs/contributors), and ecosystem partners are excited to announce the release of Vite 6.

It has been an eventful year. Vite adoption keeps growing, with npm downloads per week jumping from 7.5 million to 17 million since the release of Vite 5 a year ago. [Vitest](https://vitest.dev) is not only being favored more by users but is also starting to form an ecosystem of its own. For example, [Storybook](https://storybook.js.org) has new testing capabilities powered by Vitest.

New frameworks have also joined the Vite ecosystem, including [TanStack Start](https://tanstack.com/start), [One](https://onestack.dev/), [Ember](https://emberjs.com/), and others. Web frameworks are innovating at an increasingly faster pace. You can check out the improvements folks have been doing at [Astro](https://astro.build/), [Nuxt](https://nuxt.com/), [SvelteKit](https://kit.svelte.dev/), [Solid Start](https://www.solidjs.com/blog/introducing-solidstart), [Qwik City](https://qwik.builder.io/qwikcity/overview/), [RedwoodJS](https://redwoodjs.com/), [React Router](https://reactrouter.com/), and the list goes on.

Vite is used by OpenAI, Google, Apple, Microsoft, NASA, Shopify, Cloudflare, GitLab, Reddit, Linear, among many others. Two months ago, we started a list of [companies using Vite](https://github.com/vitejs/companies-using-vite). We're happy to see many developers sending us a PR to add their companies to the list. It's hard to believe how much the ecosystem we built together has grown since Vite gave its first steps.

![Vite weekly npm downloads](../images/vite6-npm-weekly-downloads.webp)

## Speeding up the Vite ecosystem

Last month, the community gathered for the third edition of [ViteConf](https://viteconf.org/24/replay), hosted once more by [StackBlitz](https://stackblitz.com). It was the biggest Vite conference, with a broad representation of builders from the ecosystem. Among other announcements, Evan You announced [VoidZero](https://staging.voidzero.dev/posts/announcing-voidzero-inc), a company dedicated to building an open-source, high-performance, and unified development toolchain for the JavaScript ecosystem. VoidZero is behind [Rolldown](https://rolldown.rs) and [Oxc](https://oxc.rs), and their team is making significant strides, getting them rapidly ready for being adopted by Vite. Watch Evan's keynote to learn more about the next steps for Vite's rust-powered future.

<YouTubeVideo videoId="EKvvptbTx6k?si=EZ-rFJn4pDW3tUvp" />

[Stackblitz](https://stackblitz.com) unveiled [bolt.new](https://bolt.new), a Remix app that combines Claude and WebContainers and lets you prompt, edit, run, and deploy full-stack apps. Nate Weiner announced [One](https://onestack.dev/), a new Vite-powered React framework for web and native. Storybook showcased their latest Vitest-powered [testing features](https://youtu.be/8t5wxrFpCQY?si=PYZoWKf-45goQYDt). And so much more. We encourage you to watch [all 43 talks](https://www.youtube.com/playlist?list=PLqGQbXn_GDmnObDzgjUF4Krsfl6OUKxtp). The speakers made a significant effort to share with us what each project has been up to.

Vite also got a refreshed landing page and a clean domain. You should update your URLs to point to the new [vite.dev](https://vite.dev) domain moving forward. The new design and implementation was done by VoidZero, by the same folks that made their website. Shoutout to [Vicente Rodriguez](https://bento.me/rmoon) and [Simon Le Marchant](https://marchantweb.com/).

## The next Vite major is here

Vite 6 is the most significant major release since Vite 2. We're eager to partner with the ecosystem to keep expanding our shared commons through new APIs and, as usual, a more polished base upon which to build.

Quick links:

- [Docs](/)
- Translations: [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/), [한국어](https://ko.vite.dev/), [Deutsch](https://de.vite.dev/)
- [Migration Guide](/guide/migration)
- [GitHub Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#600-2024-11-26)

If you're new to Vite, we suggest reading the [Getting Started](/guide/) and [Features](/guide/features) guides first.

We want to thank the more than [1K contributors to Vite Core](https://github.com/vitejs/vite/graphs/contributors) and the maintainers and contributors of Vite plugins, integrations, tools, and translations that have helped us craft this new major. We invite you to get involved and help us improve Vite for the whole ecosystem. Learn more at our [Contributing Guide](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md).

To get started, we suggest helping [triage issues](https://github.com/vitejs/vite/issues), [review PRs](https://github.com/vitejs/vite/pulls), send failing tests PRs based on open issues, and support others in [Discussions](https://github.com/vitejs/vite/discussions) and Vite Land's [help forum](https://discord.com/channels/804011606160703521/1019670660856942652). If you'd like to talk to us, join our [Discord community](http://chat.vite.dev/) and say hi on the [#contributing channel](https://discord.com/channels/804011606160703521/804439875226173480).

For the latest news about the Vite ecosystem and Vite core, follow us on [Bluesky](https://bsky.app/profile/vite.dev), [X](https://twitter.com/vite_js), or [Mastodon](https://webtoo.ls/@vite).

## Getting started with Vite 6

You can use `pnpm create vite` to quickly scaffold a Vite app with your preferred framework or play online with Vite 6 using [vite.new](https://vite.new). You can also run `pnpm create vite-extra` to get access to templates from other frameworks and runtimes (Solid, Deno, SSR, and library starters). `create vite-extra` templates are also available when you run `create vite` under the `Others` option.

The Vite starter templates are intended to be used as a playground to test Vite with different frameworks. When building your next project, you should reach out to the starter recommended by each framework. `create vite` also provides a shortcut to setup proper starters by some frameworks, like `create-vue`, `Nuxt 3`, `SvelteKit`, `Remix`, `Analog`, and `Angular`.

## Node.js Support

Vite 6 supports Node.js 18, 20, and 22+, similar to Vite 5. Node.js 21 support has been dropped. Vite drops Node.js support for older versions after their [EOL](https://endoflife.date/nodejs). The Node.js 18 EOL is at the end of April 2025, after which we may release a new major to bump the required Node.js version.

## Experimental Environment API

Vite is getting more flexible with the new Environment API. These new APIs will allow framework authors to offer a dev experience closer to production and for the Ecosystem to share new building blocks. Nothing changes if you're building a SPA; when you use Vite with a single client environment, everything works as before. And even for custom SSR apps, Vite 6 is backward compatible. The primary target audience for Environment API is framework authors.

For end users who are curious, [Sapphi](https://github.com/sapphi-red) wrote a great [Introduction to Environment API](https://green.sapphi.red/blog/increasing-vites-potential-with-the-environment-api) guide. It is a great place to start and understand why we're trying to make Vite even more flexible.

If you are a framework author or Vite plugin maintainer and would like to leverage the new APIs, you can learn more at the [Environment API Guides](https://main.vite.dev/guide/api-environment).

We want to thank everyone involved in defining and implementing the new APIs. The story begins with Vite 2 adopting the unbundled SSR dev scheme pioneered by [Rich Harris](https://github.com/Rich-Harris) and the [SvelteKit](https://svelte.dev/docs/kit) team. Vite's SSR transform then unlocked [Anthony Fu](https://github.com/antfu/) and [Pooya Parsa](https://github.com/pi0) to create vite-node and improve [Nuxt's Dev SSR story](https://antfu.me/posts/dev-ssr-on-nuxt). Anthony went to use vite-node to power [Vitest](https://vitest.dev), and [Vladimir Sheremet](https://github.com/sheremet-va) kept improving it as part of his work maintaining Vitest. At the beginning of 2023, Vladimir started working to upstream vite-node to Vite Core, and we released it as Runtime API in Vite 5.1 a year later. Feedback from ecosystem partners (special shout-out to the Cloudflare team) pushed us to do a more ambitious rework of Vite's environments. You can learn more about the story at [Patak's ViteConf 24 talk](https://www.youtube.com/watch?v=WImor3HDyqU?si=EZ-rFJn4pDW3tUvp).

Everyone on the Vite team participated in defining the new API, which was co-designed with feedback from many projects in the Ecosystem. Thanks to everyone involved! We encourage you to get involved if you're building a framework, plugin, or tool on top of Vite. The new APIs are experimental. We will work with the Ecosystem to review how the new APIs will be used and stabilize them for the next major. If you'd like to ask questions or give feedback, there is an [open GitHub discussion here](https://github.com/vitejs/vite/discussions/16358).

## Main Changes

- [Default value for `resolve.conditions`](/guide/migration#default-value-for-resolve-conditions)
- [JSON stringify](/guide/migration#json-stringify)
- [Extended support of asset references in HTML elements](/guide/migration#extended-support-of-asset-references-in-html-elements)
- [postcss-load-config](/guide/migration#postcss-load-config)
- [Sass now uses modern API by default](/guide/migration#sass-now-uses-modern-api-by-default)
- [Customize CSS output file name in library mode](/guide/migration#customize-css-output-file-name-in-library-mode)
- [And more changes that should only affect a few users](/guide/migration#advanced)

There is also a new [Breaking Changes](/changes/) page that lists all planned, considering, and past changes in Vite.

## Migrating to Vite 6

For most projects, the update to Vite 6 should be straightforward, but we advise reviewing the [detailed Migration Guide](/guide/migration) before upgrading.

The complete list of changes is at the [Vite 6 Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#500-2024-11-26).

## Acknowledgments

Vite 6 results from long work hours by our community of contributors, downstream maintainers, plugin authors, and the [Vite Team](/team). We appreciate the individuals and companies sponsoring Vite development. Vite is brought to you by [VoidZero](https://voidzero.dev), in partnership with [StackBlitz](https://stackblitz.com/), [Nuxt Labs](https://nuxtlabs.com/), and [Astro](https://astro.build). A shout-out to sponsors on [Vite's GitHub Sponsors](https://github.com/sponsors/vitejs) and [Vite's Open Collective](https://opencollective.com/vite).



================================================
FILE: docs/blog/announcing-vite7.md
================================================
---
title: Vite 7.0 is out!
author:
  name: The Vite Team
date: 2025-06-24
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 7
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite7.webp
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite7
  - - meta
    - property: og:description
      content: Vite 7 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 7.0 is out!

_June 24, 2025_

![Vite 7 Announcement Cover Image](/og-image-announcing-vite7.webp)

We're happy to share the release of Vite 7! It has been 5 years since Evan You sent the first commit to the Vite repo, and nobody could have predicted how much the frontend ecosystem would change since then. Most modern frontend frameworks and tools are now working together, building on top of Vite's shared infrastructure. And they can innovate at a faster pace by sharing at a higher level. Vite is now being downloaded 31 million times a week, with a 14 million increase in the last seven months since the previous major release.

This year, we're making several big steps. To start with, [ViteConf](https://viteconf.org) is going to be in person! The Vite Ecosystem will gather in Amsterdam on October 9-10! Organized by [JSWorld](https://jsworldconference.com/) in partnership with [Bolt](https://bolt.new), [VoidZero](https://voidzero.dev), and the Vite Core Team! We had three incredible [ViteConf online editions](https://www.youtube.com/@viteconf/playlists), and we can't wait to meet in real life. Check out the speakers and get your ticket at the [ViteConf site](https://viteconf.org)!

And [VoidZero](https://voidzero.dev/posts/announcing-voidzero-inc) continues to make significant strides in its mission to build an open source unified development toolchain for the JavaScript ecosystem. Over the last year, the VoidZero team has been working on [Rolldown](https://rolldown.rs/), a Rust-based next-generation bundler, as part of a broader effort to modernize Vite's core. You can try out the Rolldown-powered Vite today by using the `rolldown-vite` package instead of the default `vite` package. It is a drop-in replacement, as Rolldown will become the default bundler for Vite in the future. Switching should reduce your build time, especially for larger projects. Read more at the [Rolldown-vite announcement blog post](https://voidzero.dev/posts/announcing-rolldown-vite) and our [migration guide](https://vite.dev/rolldown).

Through a partnership between VoidZero and [NuxtLabs](https://nuxtlabs.com/), Anthony Fu is working on creating Vite DevTools. They will offer deeper and more insightful debugging and analysis for all Vite-based projects and frameworks. You can read more on the [VoidZero and NuxtLabs join forces on Vite Devtools blog post](https://voidzero.dev/posts/voidzero-nuxtlabs-vite-devtools).

Quick links:

- [Docs](/)
- New Translation: [فارسی](https://fa.vite.dev/)
- Other Translations: [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/), [한국어](https://ko.vite.dev/), [Deutsch](https://de.vite.dev/)
- [Migration Guide](/guide/migration)
- [GitHub Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md)

Play online with Vite 7 using [vite.new](https://vite.new) or scaffold a Vite app locally with your preferred framework running `pnpm create vite`. Check out the [Getting Started Guide](/guide/) for more information.

We invite you to help us improve Vite (joining the more than [1.1K contributors to Vite Core](https://github.com/vitejs/vite/graphs/contributors)), our dependencies, or plugins and projects in the ecosystem. Learn more at our [Contributing Guide](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md). A good way to get started is by [triaging issues](https://github.com/vitejs/vite/issues), [reviewing PRs](https://github.com/vitejs/vite/pulls), sending tests PRs based on open issues, and supporting others in [Discussions](https://github.com/vitejs/vite/discussions) or Vite Land's [help forum](https://discord.com/channels/804011606160703521/1019670660856942652). If you have questions, join our [Discord community](http://chat.vite.dev/) and talk to us in the [#contributing channel](https://discord.com/channels/804011606160703521/804439875226173480).

Stay updated and connect with others building on top of Vite by following us on [Bluesky](https://bsky.app/profile/vite.dev), [X](https://twitter.com/vite_js), or [Mastodon](https://webtoo.ls/@vite).

## Node.js Support

Vite now requires Node.js 20.19+, 22.12+. We have dropped Node.js 18, now that it has reached its [EOL](https://endoflife.date/nodejs) at the end of April 2025.

We require these new ranges so Node.js supports `require(esm)` without a flag. This allows us to distribute Vite 7.0 as ESM only without preventing the Vite JavaScript API from being required by CJS modules. Check out Anthony Fu's [Move on to ESM-only](https://antfu.me/posts/move-on-to-esm-only) for a detailed review of the current state of ESM in the ecosystem.

## Default Browser Target Changed to Baseline Widely Available

[Baseline](https://web-platform-dx.github.io/web-features/) gives us clear information about which web platform features work across their core browser set today. Baseline Widely Available indicates the feature is well-established and works across many devices and browser versions, being available across browsers for at least 30 months.

In Vite 7, the default browser target is changing from `'modules'` to a new default: `'baseline-widely-available'`. The set of browsers will be updated on each major to match the list of minimum browser versions compatible with Baseline Widely available features. The default browser value of `build.target` is changing in Vite 7.0:

- Chrome 87 → 107
- Edge 88 → 107
- Firefox 78 → 104
- Safari 14.0 → 16.0

This change adds predictability to the default browser target for future releases.

## Vitest

For Vitest users, Vite 7.0 is supported from Vitest 3.2. You can read more about how the Vitest team keeps improving Vite testing story in the [Vitest 3.2 release blog post](https://vitest.dev/blog/vitest-3-2.html).

## Environment API

Vite 6 was the most significant major release since Vite 2, adding new capabilities with the [new experimental Environment API](https://vite.dev/blog/announcing-vite6.html#experimental-environment-api). We are keeping the new APIs as experimental while the ecosystem reviews how the new APIs fit on their projects and provide feedback. If you're building on top of Vite, we encourage you to test the new APIs and reach out to us in the [open Feedback discussion here](https://github.com/vitejs/vite/discussions/16358).

In Vite 7, we added a new `buildApp` hook to let plugins coordinate the building of environments. Read more in the [Environment API for Frameworks guide](/guide/api-environment-frameworks.html#environments-during-build).

We want to thank the teams that have been testing the new APIs and helping us stabilize the new features. The Cloudflare team, for example, announced the 1.0 release of their Cloudflare Vite plugin, as well as official support for React Router v7. Their plugin shows the potential of Environment API for runtime providers. Learn more about their approach and future steps at ["Just use Vite”… with the Workers runtime](https://blog.cloudflare.com/introducing-the-cloudflare-vite-plugin/).

## Migrating to Vite 7

Vite 7 should be a smooth update from Vite 6. We're removing already deprecated features, like Sass legacy API support and the `splitVendorChunkPlugin` that shouldn't affect your projects. We still suggest you review the [detailed Migration Guide](/guide/migration) before upgrading.

The complete list of changes is at the [Vite 7 Changelog](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md).

## Acknowledgments

Vite 7 was crafted by the [Vite Team](/team) with the help of the wide community of contributors, downstream maintainers, plugin authors. A special shout-out to [sapphi-red](https://github.com/sapphi-red) for his remarkable work on `rolldown-vite` and this release. Vite is brought to you by [VoidZero](https://voidzero.dev), in partnership with [Bolt](https://bolt.new/) and [Nuxt Labs](https://nuxtlabs.com/). We also want to thank our sponsors on [Vite's GitHub Sponsors](https://github.com/sponsors/vitejs) and [Vite's Open Collective](https://opencollective.com/vite).



================================================
FILE: docs/changes/hotupdate-hook.md
================================================
# HMR `hotUpdate` Plugin Hook

::: tip Feedback
Give us feedback at [Environment API feedback discussion](https://github.com/vitejs/vite/discussions/16358)
:::

We're planning to deprecate the `handleHotUpdate` plugin hook in favor of [`hotUpdate` hook](/guide/api-environment#the-hotupdate-hook) to be [Environment API](/guide/api-environment.md) aware, and handle additional watch events with `create` and `delete`.

Affected scope: `Vite Plugin Authors`

::: warning Future Deprecation
`hotUpdate` was first introduced in `v6.0`. The deprecation of `handleHotUpdate` is planned for a future major. We don't recommend moving away from `handleHotUpdate` yet. If you want to experiment and give us feedback, you can use the `future.removePluginHookHandleHotUpdate` to `"warn"` in your vite config.
:::

## Motivation

The [`handleHotUpdate` hook](/guide/api-plugin.md#handlehotupdate) allows to perform custom HMR update handling. A list of modules to be updated is passed in the `HmrContext`.

```ts
interface HmrContext {
  file: string
  timestamp: number
  modules: Array<ModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

This hook is called once for all environments, and the passed modules have mixed information from the Client and SSR environments only. Once frameworks move to custom environments, a new hook that is called for each of them is needed.

The new `hotUpdate` hook works in the same way as `handleHotUpdate` but it is called for each environment and receives a new `HotUpdateOptions` instance:

```ts
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

The current dev environment can be accessed like in other Plugin hooks with `this.environment`. The `modules` list will now be module nodes from the current environment only. Each environment update can define different update strategies.

This hook is also now called for additional watch events and not only for `'update'`. Use `type` to differentiate between them.

## Migration Guide

Filter and narrow down the affected module list so that the HMR is more accurate.

```js
handleHotUpdate({ modules }) {
  return modules.filter(condition)
}

// Migrate to:

hotUpdate({ modules }) {
  return modules.filter(condition)
}
```

Return an empty array and perform a full reload:

```js
handleHotUpdate({ server, modules, timestamp }) {
  // Invalidate modules manually
  const invalidatedModules = new Set()
  for (const mod of modules) {
    server.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  server.ws.send({ type: 'full-reload' })
  return []
}

// Migrate to:

hotUpdate({ modules, timestamp }) {
  // Invalidate modules manually
  const invalidatedModules = new Set()
  for (const mod of modules) {
    this.environment.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  this.environment.hot.send({ type: 'full-reload' })
  return []
}
```

Return an empty array and perform complete custom HMR handling by sending custom events to the client:

```js
handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}

// Migrate to...

hotUpdate() {
  this.environment.hot.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}
```



================================================
FILE: docs/changes/index.md
================================================
# Breaking Changes

List of breaking changes in Vite including API deprecations, removals, and changes. Most of the changes below can be opt-in using the [`future` option](/config/shared-options.html#future) in your Vite config.

## Planned

These changes are planned for the next major version of Vite. The deprecation or usage warnings will guide you where possible, and we're reaching out to framework, plugin authors, and users to apply these changes.

- [`this.environment` in Hooks](/changes/this-environment-in-hooks)
- [HMR `hotUpdate` Plugin Hook](/changes/hotupdate-hook)
- [SSR Using `ModuleRunner` API](/changes/ssr-using-modulerunner)

## Considering

These changes are being considered and are often experimental APIs that intend to improve upon current usage patterns. As not all changes are listed here, please check out the [Experimental Label in Vite GitHub Discussions](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=label%3Aexperimental+category%3AFeedback) for the full list.

We don't recommend switching to these APIs yet. They are included in Vite to help us gather feedback. Please check these proposals and let us know how they work in your use case in each's linked GitHub Discussions.

- [Move to Per-environment APIs](/changes/per-environment-apis)
- [Shared Plugins During Build](/changes/shared-plugins-during-build)

## Past

The changes below have been done or reverted. They are no longer relevant in the current major version.

- _No past changes yet_



================================================
FILE: docs/changes/per-environment-apis.md
================================================
# Move to Per-environment APIs

::: tip Feedback
Give us feedback at [Environment API feedback discussion](https://github.com/vitejs/vite/discussions/16358)
:::

Multiple APIs from `ViteDevServer` related to module graph and modules transforms have been moved to the `DevEnvironment` instances.

Affected scope: `Vite Plugin Authors`

::: warning Future Deprecation
The `Environment` instance was first introduced at `v6.0`. The deprecation of `server.moduleGraph` and other methods that are now in environments is planned for a future major. We don't recommend moving away from server methods yet. To identify your usage, set these in your vite config.

```ts
future: {
  removeServerModuleGraph: 'warn',
  removeServerReloadModule: 'warn',
  removeServerPluginContainer: 'warn',
  removeServerHot: 'warn',
  removeServerTransformRequest: 'warn',
  removeServerWarmupRequest: 'warn',
}
```

:::

## Motivation

In Vite v5 and before, a single Vite dev server always had two environments (`client` and `ssr`). The `server.moduleGraph` had mixed modules from both of these environments. Nodes were connected through `clientImportedModules` and `ssrImportedModules` lists (but a single `importers` list was maintained for each). A transformed module was represented by an `id` and a `ssr` boolean. This boolean needed to be passed to APIs, for example `server.moduleGraph.getModuleByUrl(url, ssr)` and `server.transformRequest(url, { ssr })`.

In Vite v6, it is now possible to create any number of custom environments (`client`, `ssr`, `edge`, etc). A single `ssr` boolean isn't enough anymore. Instead of changing the APIs to be of the form `server.transformRequest(url, { environment })`, we moved these methods to the environment instance allowing them to be called without a Vite dev server.

## Migration Guide

- `server.moduleGraph` -> [`environment.moduleGraph`](/guide/api-environment-instances#separate-module-graphs)
- `server.reloadModule(module)` -> `environment.reloadModule(module)`
- `server.pluginContainer` -> `environment.pluginContainer`
- `server.transformRequest(url, ssr)` -> `environment.transformRequest(url)`
- `server.warmupRequest(url, ssr)` -> `environment.warmupRequest(url)`
- `server.hot` -> `server.client.environment.hot`



================================================
FILE: docs/changes/shared-plugins-during-build.md
================================================
# Shared Plugins during Build

::: tip Feedback
Give us feedback at [Environment API feedback discussion](https://github.com/vitejs/vite/discussions/16358)
:::

See [Shared plugins during build](/guide/api-environment-plugins.md#shared-plugins-during-build).

Affected scope: `Vite Plugin Authors`

::: warning Future Default Change
`builder.sharedConfigBuild` was first introduced in `v6.0`. You can set it true to check how your plugins work with a shared config. We're looking for feedback about changing the default in a future major once the plugin ecosystem is ready.
:::

## Motivation

Align dev and build plugin pipelines.

## Migration Guide

To be able to share plugins across environments, plugin state must be keyed by the current environment. A plugin of the following form will count the number of transformed modules across all environments.

```js
function CountTransformedModulesPlugin() {
  let transformedModules
  return {
    name: 'count-transformed-modules',
    buildStart() {
      transformedModules = 0
    },
    transform(id) {
      transformedModules++
    },
    buildEnd() {
      console.log(transformedModules)
    },
  }
}
```

If we instead want to count the number of transformed modules for each environment, we need to keep a map:

```js
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = new Map<Environment, { count: number }>()
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state.set(this.environment, { count: 0 })
    }
    transform(id) {
      state.get(this.environment).count++
    },
    buildEnd() {
      console.log(this.environment.name, state.get(this.environment).count)
    }
  }
}
```

To simplify this pattern, Vite exports a `perEnvironmentState` helper:

```js
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = perEnvironmentState<{ count: number }>(() => ({ count: 0 }))
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state(this).count = 0
    }
    transform(id) {
      state(this).count++
    },
    buildEnd() {
      console.log(this.environment.name, state(this).count)
    }
  }
}
```



================================================
FILE: docs/changes/ssr-using-modulerunner.md
================================================
# SSR Using `ModuleRunner` API

::: tip Feedback
Give us feedback at [Environment API feedback discussion](https://github.com/vitejs/vite/discussions/16358)
:::

`server.ssrLoadModule` has been replaced by importing from a [Module Runner](/guide/api-environment#modulerunner).

Affected scope: `Vite Plugin Authors`

::: warning Future Deprecation
`ModuleRunner` was first introduced in `v6.0`. The deprecation of `server.ssrLoadModule` is planned for a future major. To identify your usage, set `future.removeSsrLoadModule` to `"warn"` in your vite config.
:::

## Motivation

The `server.ssrLoadModule(url)` only allows importing modules in the `ssr` environment and can only execute the modules in the same process as the Vite dev server. For apps with custom environments, each is associated with a `ModuleRunner` that may be running in a separate thread or process. To import modules, we now have `moduleRunner.import(url)`.

## Migration Guide

Check out the [Environment API for Frameworks Guide](../guide/api-environment-frameworks.md).

`server.ssrFixStacktrace` and `server.ssrRewriteStacktrace` does not have to be called when using the Module Runner APIs. The stack traces will be updated unless `sourcemapInterceptor` is set to `false`.



================================================
FILE: docs/changes/this-environment-in-hooks.md
================================================
# `this.environment` in Hooks

::: tip Feedback
Give us feedback at [Environment API feedback discussion](https://github.com/vitejs/vite/discussions/16358)
:::

Before Vite 6, only two environments were available: `client` and `ssr`. A single `options.ssr` plugin hook argument in `resolveId`, `load` and `transform` allowed plugin authors to differentiate between these two environments when processing modules in plugin hooks. In Vite 6, a Vite application can define any number of named environments as needed. We're introducing `this.environment` in the plugin context to interact with the environment of the current module in hooks.

Affected scope: `Vite Plugin Authors`

::: warning Future Deprecation
`this.environment` was introduced in `v6.0`. The deprecation of `options.ssr` is planned for a future major. At that point we'll start recommending migrating your plugins to use the new API. To identify your usage, set `future.removePluginHookSsrArgument` to `"warn"` in your vite config.
:::

## Motivation

`this.environment` not only allow the plugin hook implementation to know the current environment name, it also gives access to the environment config options, module graph information, and transform pipeline (`environment.config`, `environment.moduleGraph`, `environment.transformRequest()`). Having the environment instance available in the context allows plugin authors to avoid the dependency of the whole dev server (typically cached at startup through the `configureServer` hook).

## Migration Guide

For the existing plugin to do a quick migration, replace the `options.ssr` argument with `this.environment.config.consumer === 'server'` in the `resolveId`, `load` and `transform` hooks:

```ts
import { Plugin } from 'vite'

export function myPlugin(): Plugin {
  return {
    name: 'my-plugin',
    resolveId(id, importer, options) {
      const isSSR = options.ssr // [!code --]
      const isSSR = this.environment.config.consumer === 'server' // [!code ++]

      if (isSSR) {
        // SSR specific logic
      } else {
        // Client specific logic
      }
    },
  }
}
```

For a more robust long term implementation, the plugin hook should handle for [multiple environments](/guide/api-environment-plugins.html#accessing-the-current-environment-in-hooks) using fine-grained environment options instead of relying on the environment name.



================================================
FILE: docs/config/build-options.md
================================================
# Build Options

Unless noted, the options in this section are only applied to build.

## build.target

- **Type:** `string | string[]`
- **Default:** `'baseline-widely-available'`
- **Related:** [Browser Compatibility](/guide/build#browser-compatibility)

Browser compatibility target for the final bundle. The default value is a Vite special value, `'baseline-widely-available'`, which targets browsers that are included in the [Baseline](https://web-platform-dx.github.io/web-features/) Widely Available on 2025-05-01. Specifically, it is `['chrome107', 'edge107', 'firefox104', 'safari16']`.

Another special value is `'esnext'` - which assumes native dynamic imports support and will only perform minimal transpiling.

The transform is performed with esbuild and the value should be a valid [esbuild target option](https://esbuild.github.io/api/#target). Custom targets can either be an ES version (e.g. `es2015`), a browser with version (e.g. `chrome58`), or an array of multiple target strings.

Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See [esbuild docs](https://esbuild.github.io/content-types/#javascript) for more details.

## build.modulePreload

- **Type:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`
- **Default:** `{ polyfill: true }`

By default, a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) is automatically injected. The polyfill is auto injected into the proxy module of each `index.html` entry. If the build is configured to use a non-HTML custom entry via `build.rollupOptions.input`, then it is necessary to manually import the polyfill in your custom entry:

```js
import 'vite/modulepreload-polyfill'
```

Note: the polyfill does **not** apply to [Library Mode](/guide/build#library-mode). If you need to support browsers without native dynamic import, you should probably avoid using it in your library.

The polyfill can be disabled using `{ polyfill: false }`.

The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the `base` will be used when loading these dependencies. If the `base` is relative (`''` or `'./'`), `import.meta.url` is used at runtime to avoid absolute paths that depend on the final deployed base.

There is experimental support for fine grained control over the dependencies list and their paths using the `resolveDependencies` function. [Give Feedback](https://github.com/vitejs/vite/discussions/13841). It expects a function of type `ResolveModulePreloadDependenciesFn`:

```ts
type ResolveModulePreloadDependenciesFn = (
  url: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]
```

The `resolveDependencies` function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The `deps` paths are relative to the `build.outDir`. The return value should be a relative path to the `build.outDir`.

```js twoslash
/** @type {import('vite').UserConfig} */
const config = {
  // prettier-ignore
  build: {
// ---cut-before---
modulePreload: {
  resolveDependencies: (filename, deps, { hostId, hostType }) => {
    return deps.filter(condition)
  },
},
// ---cut-after---
  },
}
```

The resolved dependency paths can be further modified using [`experimental.renderBuiltUrl`](../guide/build.md#advanced-base-options).

## build.polyfillModulePreload

- **Type:** `boolean`
- **Default:** `true`
- **Deprecated** use `build.modulePreload.polyfill` instead

Whether to automatically inject a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).

## build.outDir

- **Type:** `string`
- **Default:** `dist`

Specify the output directory (relative to [project root](/guide/#index-html-and-project-root)).

## build.assetsDir

- **Type:** `string`
- **Default:** `assets`

Specify the directory to nest generated assets under (relative to `build.outDir`. This is not used in [Library Mode](/guide/build#library-mode)).

## build.assetsInlineLimit

- **Type:** `number` | `((filePath: string, content: Buffer) => boolean | undefined)`
- **Default:** `4096` (4 KiB)

Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to `0` to disable inlining altogether.

If a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.

Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.

::: tip Note
If you specify `build.lib`, `build.assetsInlineLimit` will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.
:::

## build.cssCodeSplit

- **Type:** `boolean`
- **Default:** `true`

Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.

If disabled, all CSS in the entire project will be extracted into a single CSS file.

::: tip Note
If you specify `build.lib`, `build.cssCodeSplit` will be `false` as default.
:::

## build.cssTarget

- **Type:** `string | string[]`
- **Default:** the same as [`build.target`](#build-target)

This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.

It should only be used when you are targeting a non-mainstream browser.
One example is Android WeChat WebView, which supports most modern JavaScript features but not the [`#RGBA` hexadecimal color notation in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors).
In this case, you need to set `build.cssTarget` to `chrome61` to prevent vite from transforming `rgba()` colors into `#RGBA` hexadecimal notations.

## build.cssMinify

- **Type:** `boolean | 'esbuild' | 'lightningcss'`
- **Default:** the same as [`build.minify`](#build-minify) for client, `'esbuild'` for SSR

This option allows users to override CSS minification specifically instead of defaulting to `build.minify`, so you can configure minification for JS and CSS separately. Vite uses `esbuild` by default to minify CSS. Set the option to `'lightningcss'` to use [Lightning CSS](https://lightningcss.dev/minification.html) instead. If selected, it can be configured using [`css.lightningcss`](./shared-options.md#css-lightningcss).

## build.sourcemap

- **Type:** `boolean | 'inline' | 'hidden'`
- **Default:** `false`

Generate production source maps. If `true`, a separate sourcemap file will be created. If `'inline'`, the sourcemap will be appended to the resulting output file as a data URI. `'hidden'` works like `true` except that the corresponding sourcemap comments in the bundled files are suppressed.

## build.rollupOptions

- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See [Rollup options docs](https://rollupjs.org/configuration-options/) for more details.

## build.commonjsOptions

- **Type:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

Options to pass on to [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).

## build.dynamicImportVarsOptions

- **Type:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
- **Related:** [Dynamic Import](/guide/features#dynamic-import)

Options to pass on to [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).

## build.lib

- **Type:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string), cssFileName?: string }`
- **Related:** [Library Mode](/guide/build#library-mode)

Build as a library. `entry` is required since the library cannot use HTML as entry. `name` is the exposed global variable and is required when `formats` includes `'umd'` or `'iife'`. Default `formats` are `['es', 'umd']`, or `['es', 'cjs']`, if multiple entries are used.

`fileName` is the name of the package file output, which defaults to the `"name"` in `package.json`. It can also be defined as a function taking the `format` and `entryName` as arguments, and returning the file name.

If your package imports CSS, `cssFileName` can be used to specify the name of the CSS file output. It defaults to the same value as `fileName` if it's set a string, otherwise it also falls back to the `"name"` in `package.json`.

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})
```

## build.manifest

- **Type:** `boolean | string`
- **Default:** `false`
- **Related:** [Backend Integration](/guide/backend-integration)

Whether to generate a manifest file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links.

When the value is a string, it will be used as the manifest file path relative to `build.outDir`. When set to `true`, the path would be `.vite/manifest.json`.

## build.ssrManifest

- **Type:** `boolean | string`
- **Default:** `false`
- **Related:** [Server-Side Rendering](/guide/ssr)

Whether to generate a SSR manifest file for determining style links and asset preload directives in production.

When the value is a string, it will be used as the manifest file path relative to `build.outDir`. When set to `true`, the path would be `.vite/ssr-manifest.json`.

## build.ssr

- **Type:** `boolean | string`
- **Default:** `false`
- **Related:** [Server-Side Rendering](/guide/ssr)

Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or `true`, which requires specifying the SSR entry via `rollupOptions.input`.

## build.emitAssets

- **Type:** `boolean`
- **Default:** `false`

During non-client builds, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in other environments build. It is responsibility of the framework to merge the assets with a post build step.

## build.ssrEmitAssets

- **Type:** `boolean`
- **Default:** `false`

During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step. This option will be replaced by `build.emitAssets` once Environment API is stable.

## build.minify

- **Type:** `boolean | 'terser' | 'esbuild'`
- **Default:** `'esbuild'` for client build, `false` for SSR build

Set to `false` to disable minification, or specify the minifier to use. The default is [esbuild](https://github.com/evanw/esbuild) which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. [Benchmarks](https://github.com/privatenumber/minification-benchmarks)

Note the `build.minify` option does not minify whitespaces when using the `'es'` format in lib mode, as it removes pure annotations and breaks tree-shaking.

Terser must be installed when it is set to `'terser'`.

```sh
npm add -D terser
```

## build.terserOptions

- **Type:** `TerserOptions`

Additional [minify options](https://terser.org/docs/api-reference#minify-options) to pass on to Terser.

In addition, you can also pass a `maxWorkers: number` option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.

## build.write

- **Type:** `boolean`
- **Default:** `true`

Set to `false` to disable writing the bundle to disk. This is mostly used in [programmatic `build()` calls](/guide/api-javascript#build) where further post processing of the bundle is needed before writing to disk.

## build.emptyOutDir

- **Type:** `boolean`
- **Default:** `true` if `outDir` is inside `root`

By default, Vite will empty the `outDir` on build if it is inside project root. It will emit a warning if `outDir` is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as `--emptyOutDir`.

## build.copyPublicDir

- **Type:** `boolean`
- **Default:** `true`

By default, Vite will copy files from the `publicDir` into the `outDir` on build. Set to `false` to disable this.

## build.reportCompressedSize

- **Type:** `boolean`
- **Default:** `true`

Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.

## build.chunkSizeWarningLimit

- **Type:** `number`
- **Default:** `500`

Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the [JavaScript size itself is related to the execution time](https://v8.dev/blog/cost-of-javascript-2019).

## build.watch

- **Type:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch)`| null`
- **Default:** `null`

Set to `{}` to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.

::: warning Using Vite on Windows Subsystem for Linux (WSL) 2

There are cases that file system watching does not work with WSL2.
See [`server.watch`](./server-options.md#server-watch) for more details.

:::



================================================
FILE: docs/config/dep-optimization-options.md
================================================
# Dep Optimization Options

- **Related:** [Dependency Pre-Bundling](/guide/dep-pre-bundling)

Unless noted, the options in this section are only applied to the dependency optimizer, which is only used in dev.

## optimizeDeps.entries <NonInheritBadge />

- **Type:** `string | string[]`

By default, Vite will crawl all your `.html` files to detect dependencies that need to be pre-bundled (ignoring `node_modules`, `build.outDir`, `__tests__` and `coverage`). If `build.rollupOptions.input` is specified, Vite will crawl those entry points instead.

If neither of these fit your needs, you can specify custom entries using this option - the value should be a [`tinyglobby` pattern](https://github.com/SuperchupuDev/tinyglobby) or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only `node_modules` and `build.outDir` folders will be ignored by default when `optimizeDeps.entries` is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial `!`. `node_modules` will not be ignored for patterns that explicitly include the string `node_modules`.

## optimizeDeps.exclude <NonInheritBadge />

- **Type:** `string[]`

Dependencies to exclude from pre-bundling.

:::warning CommonJS
CommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to `optimizeDeps.include`. Example:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['esm-dep > cjs-dep'],
  },
})
```

:::

## optimizeDeps.include <NonInheritBadge />

- **Type:** `string[]`

By default, linked packages not inside `node_modules` are not pre-bundled. Use this option to force a linked package to be pre-bundled.

**Experimental:** If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. [Give Feedback](https://github.com/vitejs/vite/discussions/15833). For example:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['my-lib/components/**/*.vue'],
  },
})
```

## optimizeDeps.esbuildOptions <NonInheritBadge />

- **Type:** [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)`<`[`EsbuildBuildOptions`](https://esbuild.github.io/api/#general-options)`,
| 'bundle'
| 'entryPoints'
| 'external'
| 'write'
| 'watch'
| 'outdir'
| 'outfile'
| 'outbase'
| 'outExtension'
| 'metafile'>`

Options to pass to esbuild during the dep scanning and optimization.

Certain options are omitted since changing them would not be compatible with Vite's dep optimization.

- `external` is also omitted, use Vite's `optimizeDeps.exclude` option
- `plugins` are merged with Vite's dep plugin

## optimizeDeps.force <NonInheritBadge />

- **Type:** `boolean`

Set to `true` to force dependency pre-bundling, ignoring previously cached optimized dependencies.

## optimizeDeps.noDiscovery <NonInheritBadge />

- **Type:** `boolean`
- **Default:** `false`

When set to `true`, automatic dependency discovery will be disabled and only dependencies listed in `optimizeDeps.include` will be optimized. CJS-only dependencies must be present in `optimizeDeps.include` during dev.

## optimizeDeps.holdUntilCrawlEnd <NonInheritBadge />

- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15834)
- **Type:** `boolean`
- **Default:** `true`

When enabled, it will hold the first optimized deps results until all static imports are crawled on cold start. This avoids the need for full-page reloads when new dependencies are discovered and they trigger the generation of new common chunks. If all dependencies are found by the scanner plus the explicitly defined ones in `include`, it is better to disable this option to let the browser process more requests in parallel.

## optimizeDeps.disabled <NonInheritBadge />

- **Deprecated**
- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13839)
- **Type:** `boolean | 'build' | 'dev'`
- **Default:** `'build'`

This option is deprecated. As of Vite 5.1, pre-bundling of dependencies during build have been removed. Setting `optimizeDeps.disabled` to `true` or `'dev'` disables the optimizer, and configured to `false` or `'build'` leaves the optimizer during dev enabled.

To disable the optimizer completely, use `optimizeDeps.noDiscovery: true` to disallow automatic discovery of dependencies and leave `optimizeDeps.include` undefined or empty.

:::warning
Optimizing dependencies during build time was an **experimental** feature. Projects trying out this strategy also removed `@rollup/plugin-commonjs` using `build.commonjsOptions: { include: [] }`. If you did so, a warning will guide you to re-enable it to support CJS only packages while bundling.
:::

## optimizeDeps.needsInterop <NonInheritBadge />

- **Experimental**
- **Type:** `string[]`

Forces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to `needsInterop` can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config.



================================================
FILE: docs/config/index.md
================================================
---
title: Configuring Vite
---

# Configuring Vite

When running `vite` from the command line, Vite will automatically try to resolve a config file named `vite.config.js` inside [project root](/guide/#index-html-and-project-root) (other JS and TS extensions are also supported).

The most basic config file looks like this:

```js [vite.config.js]
export default {
  // config options
}
```

Note Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. `"type": "module"` in `package.json`. In this case, the config file is auto pre-processed before load.

You can also explicitly specify a config file to use with the `--config` CLI option (resolved relative to `cwd`):

```bash
vite --config my-config.js
```

::: tip CONFIG LOADING
By default, Vite uses `esbuild` to bundle the config into a temporary file and load it. This may cause issues when importing TypeScript files in a monorepo. If you encounter any issues with this approach, you can specify `--configLoader runner` to use the [module runner](/guide/api-environment-runtimes.html#modulerunner) instead, which will not create a temporary config and will transform any files on the fly. Note that module runner doesn't support CJS in config files, but external CJS packages should work as usual.

Alternatively, if you're using an environment that supports TypeScript (e.g. `node --experimental-strip-types`), or if you're only writing plain JavaScript, you can specify `--configLoader native` to use the environment's native runtime to load the config file. Note that updates to modules imported by the config file are not detected and hence would not auto-restart the Vite server.
:::

## Config Intellisense

Since Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:

```js
/** @type {import('vite').UserConfig} */
export default {
  // ...
}
```

Alternatively, you can use the `defineConfig` helper which should provide intellisense without the need for jsdoc annotations:

```js
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
})
```

Vite also supports TypeScript config files. You can use `vite.config.ts` with the `defineConfig` helper function above, or with the `satisfies` operator:

```ts
import type { UserConfig } from 'vite'

export default {
  // ...
} satisfies UserConfig
```

## Conditional Config

If the config needs to conditionally determine options based on the command (`serve` or `build`), the [mode](/guide/env-and-mode#modes) being used, if it's an SSR build (`isSsrBuild`), or is previewing the build (`isPreview`), it can export a function instead:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
  if (command === 'serve') {
    return {
      // dev specific config
    }
  } else {
    // command === 'build'
    return {
      // build specific config
    }
  }
})
```

It is important to note that in Vite's API the `command` value is `serve` during dev (in the cli [`vite`](/guide/cli#vite), `vite dev`, and `vite serve` are aliases), and `build` when building for production ([`vite build`](/guide/cli#vite-build)).

`isSsrBuild` and `isPreview` are additional optional flags to differentiate the kind of `build` and `serve` commands respectively. Some tools that load the Vite config may not support these flags and will pass `undefined` instead. Hence, it's recommended to use explicit comparison against `true` and `false`.

## Async Config

If the config needs to call async functions, it can export an async function instead. And this async function can also be passed through `defineConfig` for improved intellisense support:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(async ({ command, mode }) => {
  const data = await asyncFunction()
  return {
    // vite config
  }
})
```

## Using Environment Variables in Config

Environmental Variables can be obtained from `process.env` as usual.

Note that Vite doesn't load `.env` files by default as the files to load can only be determined after evaluating the Vite config, for example, the `root` and `envDir` options affect the loading behaviour. However, you can use the exported `loadEnv` helper to load the specific `.env` file if needed.

```js twoslash
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  // Load env file based on `mode` in the current working directory.
  // Set the third parameter to '' to load all env regardless of the
  // `VITE_` prefix.
  const env = loadEnv(mode, process.cwd(), '')
  return {
    // vite config
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
  }
})
```

## Debugging the Config File on VS Code

With the default `--configLoader bundle` behavior, Vite writes the generated temporary configuration file to the `node_modules/.vite-temp` folder and a file not found error will occur when setting breakpoint debugging in the Vite config file. To fix the issue, add the following configuration to `.vscode/settings.json`:

```json
{
  "debug.javascript.terminalOptions": {
    "resolveSourceMapLocations": [
      "${workspaceFolder}/**",
      "!**/node_modules/**",
      "**/node_modules/.vite-temp/**"
    ]
  }
}
```



================================================
FILE: docs/config/preview-options.md
================================================
# Preview Options

Unless noted, the options in this section are only applied to preview.

## preview.host

- **Type:** `string | boolean`
- **Default:** [`server.host`](./server-options#server-host)

Specify which IP addresses the server should listen on.
Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.

This can be set via the CLI using `--host 0.0.0.0` or `--host`.

::: tip NOTE

There are cases when other servers might respond instead of Vite.
See [`server.host`](./server-options#server-host) for more details.

:::

## preview.allowedHosts

- **Type:** `string | true`
- **Default:** [`server.allowedHosts`](./server-options#server-allowedhosts)

The hostnames that Vite is allowed to respond to.

See [`server.allowedHosts`](./server-options#server-allowedhosts) for more details.

## preview.port

- **Type:** `number`
- **Default:** `4173`

Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.

**Example:**

```js
export default defineConfig({
  server: {
    port: 3030,
  },
  preview: {
    port: 8080,
  },
})
```

## preview.strictPort

- **Type:** `boolean`
- **Default:** [`server.strictPort`](./server-options#server-strictport)

Set to `true` to exit if port is already in use, instead of automatically trying the next available port.

## preview.https

- **Type:** `https.ServerOptions`
- **Default:** [`server.https`](./server-options#server-https)

Enable TLS + HTTP/2.

See [`server.https`](./server-options#server-https) for more details.

## preview.open

- **Type:** `boolean | string`
- **Default:** [`server.open`](./server-options#server-open)

Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).

`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.

## preview.proxy

- **Type:** `Record<string, string | ProxyOptions>`
- **Default:** [`server.proxy`](./server-options#server-proxy)

Configure custom proxy rules for the preview server. Expects an object of `{ key: options }` pairs. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.

Uses [`http-proxy-3`](https://github.com/sagemathinc/http-proxy-3). Full options [here](https://github.com/sagemathinc/http-proxy-3#options).

## preview.cors

- **Type:** `boolean | CorsOptions`
- **Default:** [`server.cors`](./server-options#server-cors)

Configure CORS for the preview server.

See [`server.cors`](./server-options#server-cors) for more details.

## preview.headers

- **Type:** `OutgoingHttpHeaders`

Specify server response headers.



================================================
FILE: docs/config/server-options.md
================================================
# Server Options

Unless noted, the options in this section are only applied to dev.

## server.host

- **Type:** `string | boolean`
- **Default:** `'localhost'`

Specify which IP addresses the server should listen on.
Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.

This can be set via the CLI using `--host 0.0.0.0` or `--host`.

::: tip NOTE

There are cases when other servers might respond instead of Vite.

The first case is when `localhost` is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing `localhost`, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.

You can set [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) to disable the reordering behavior. Vite will then print the address as `localhost`.

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'
import dns from 'node:dns'

dns.setDefaultResultOrder('verbatim')

export default defineConfig({
  // omit
})
```

The second case is when wildcard hosts (e.g. `0.0.0.0`) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.

:::

::: tip Accessing the server on WSL2 from your LAN

When running Vite on WSL2, it is not sufficient to set `host: true` to access the server from your LAN.
See [the WSL document](https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan) for more details.

:::

## server.allowedHosts

- **Type:** `string[] | true`
- **Default:** `[]`

The hostnames that Vite is allowed to respond to.
`localhost` and domains under `.localhost` and all IP addresses are allowed by default.
When using HTTPS, this check is skipped.

If a string starts with `.`, it will allow that hostname without the `.` and all subdomains under the hostname. For example, `.example.com` will allow `example.com`, `foo.example.com`, and `foo.bar.example.com`. If set to `true`, the server is allowed to respond to requests for any hosts.

::: details What hosts are safe to be added?

Hosts that you have control over which IP addresses they resolve to are safe to add to the list of allowed hosts.

For example, if you own a domain `vite.dev`, you can add `vite.dev` and `.vite.dev` to the list. If you don't own that domain and you cannot trust the owner of that domain, you should not add it.

Especially, you should never add Top-Level Domains like `.com` to the list. This is because anyone can purchase a domain like `example.com` and control the IP address it resolves to.

:::

::: danger

Setting `server.allowedHosts` to `true` allows any website to send requests to your dev server through DNS rebinding attacks, allowing them to download your source code and content. We recommend always using an explicit list of allowed hosts. See [GHSA-vg6x-rcgg-rjx6](https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6) for more details.

:::

::: details Configure via environment variable
You can set the environment variable `__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS` to add an additional allowed host.
:::

## server.port

- **Type:** `number`
- **Default:** `5173`

Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.

## server.strictPort

- **Type:** `boolean`

Set to `true` to exit if port is already in use, instead of automatically trying the next available port.

## server.https

- **Type:** `https.ServerOptions`

Enable TLS + HTTP/2. The value is an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.

Note that this downgrades to TLS only when the [`server.proxy` option](#server-proxy) is also used.

A valid certificate is needed. For a basic setup, you can add [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.

## server.open

- **Type:** `boolean | string`

Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).

`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.

**Example:**

```js
export default defineConfig({
  server: {
    open: '/docs/index.html',
  },
})
```

## server.proxy

- **Type:** `Record<string, string | ProxyOptions>`

Configure custom proxy rules for the dev server. Expects an object of `{ key: options }` pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance. If a request matches any of the configured proxy rules, the request won't be transformed by Vite.

Note that if you are using non-relative [`base`](/config/shared-options.md#base), you must prefix each key with that `base`.

Extends [`http-proxy-3`](https://github.com/sagemathinc/http-proxy-3#options). Additional options are [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13).

In some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app). In order to do that, you need to write your own [plugin](/guide/using-plugins.html) and use [configureServer](/guide/api-plugin.html#configureserver) function.

**Example:**

```js
export default defineConfig({
  server: {
    proxy: {
      // string shorthand:
      // http://localhost:5173/foo
      //   -> http://localhost:4567/foo
      '/foo': 'http://localhost:4567',
      // with options:
      // http://localhost:5173/api/bar
      //   -> http://jsonplaceholder.typicode.com/bar
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
      // with RegExp:
      // http://localhost:5173/fallback/
      //   -> http://jsonplaceholder.typicode.com/
      '^/fallback/.*': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/fallback/, ''),
      },
      // Using the proxy instance
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        configure: (proxy, options) => {
          // proxy will be an instance of 'http-proxy'
        },
      },
      // Proxying websockets or socket.io:
      // ws://localhost:5173/socket.io
      //   -> ws://localhost:5174/socket.io
      // Exercise caution using `rewriteWsOrigin` as it can leave the
      // proxying open to CSRF attacks.
      '/socket.io': {
        target: 'ws://localhost:5174',
        ws: true,
        rewriteWsOrigin: true,
      },
    },
  },
})
```

## server.cors

- **Type:** `boolean | CorsOptions`
- **Default:** `{ origin: /^https?:\/\/(?:(?:[^:]+\.)?localhost|127\.0\.0\.1|\[::1\])(?::\d+)?$/ }` (allows localhost, `127.0.0.1` and `::1`)

Configure CORS for the dev server. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `true` to allow any origin.

::: danger

Setting `server.cors` to `true` allows any website to send requests to your dev server and download your source code and content. We recommend always using an explicit list of allowed origins.

:::

## server.headers

- **Type:** `OutgoingHttpHeaders`

Specify server response headers.

## server.hmr

- **Type:** `boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }`

Disable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).

Set `server.hmr.overlay` to `false` to disable the server error overlay.

`protocol` sets the WebSocket protocol used for the HMR connection: `ws` (WebSocket) or `wss` (WebSocket Secure).

`clientPort` is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.

When `server.hmr.server` is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.

Check out [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue) for some examples.

::: tip NOTE

With the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:

```
Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.
```

The error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:

- configure the reverse proxy to proxy WebSocket too
- set [`server.strictPort = true`](#server-strictport) and set `server.hmr.clientPort` to the same value with `server.port`
- set `server.hmr.port` to a different value from [`server.port`](#server-port)

:::

## server.warmup

- **Type:** `{ clientFiles?: string[], ssrFiles?: string[] }`
- **Related:** [Warm Up Frequently Used Files](/guide/performance.html#warm-up-frequently-used-files)

Warm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.

`clientFiles` are files that are used in the client only, while `ssrFiles` are files that are used in SSR only. They accept an array of file paths or [`tinyglobby`](https://github.com/SuperchupuDev/tinyglobby) patterns relative to the `root`.

Make sure to only add files that are frequently used to not overload the Vite dev server on startup.

```js
export default defineConfig({
  server: {
    warmup: {
      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],
      ssrFiles: ['./src/server/modules/*.js'],
    },
  },
})
```

## server.watch

- **Type:** `object | null`

File system watcher options to pass on to [chokidar](https://github.com/paulmillr/chokidar/tree/3.6.0#api).

The Vite server watcher watches the `root` and skips the `.git/`, `node_modules/`, `test-results/`, and Vite's `cacheDir` and `build.outDir` directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.

If set to `null`, no files will be watched. `server.watcher` will provide a compatible event emitter, but calling `add` or `unwatch` will have no effect.

::: warning Watching files in `node_modules`

It's currently not possible to watch files and packages in `node_modules`. For further progress and workarounds, you can follow [issue #8619](https://github.com/vitejs/vite/issues/8619).

:::

::: warning Using Vite on Windows Subsystem for Linux (WSL) 2

When running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to [a WSL2 limitation](https://github.com/microsoft/WSL/issues/4739). This also applies to running on Docker with a WSL2 backend.

To fix it, you could either:

- **Recommended**: Use WSL2 applications to edit your files.
  - It is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.
- Set `{ usePolling: true }`.
  - Note that [`usePolling` leads to high CPU utilization](https://github.com/paulmillr/chokidar/tree/3.6.0#performance).

:::

## server.middlewareMode

- **Type:** `boolean`
- **Default:** `false`

Create Vite server in middleware mode.

- **Related:** [appType](./shared-options#apptype), [SSR - Setting Up the Dev Server](/guide/ssr#setting-up-the-dev-server)

- **Example:**

```js twoslash
import express from 'express'
import { createServer as createViteServer } from 'vite'

async function createServer() {
  const app = express()

  // Create Vite server in middleware mode
  const vite = await createViteServer({
    server: { middlewareMode: true },
    // don't include Vite's default HTML handling middlewares
    appType: 'custom',
  })
  // Use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*', async (req, res) => {
    // Since `appType` is `'custom'`, should serve response here.
    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares
    // to handle HTML requests and 404s so user middlewares should be added
    // before Vite's middlewares to take effect instead
  })
}

createServer()
```

## server.fs.strict

- **Type:** `boolean`
- **Default:** `true` (enabled by default since Vite 2.7)

Restrict serving files outside of workspace root.

## server.fs.allow

- **Type:** `string[]`

Restrict files that could be served via `/@fs/`. When `server.fs.strict` is set to `true`, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.

Both directories and files can be provided.

Vite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the [project root](/guide/#index-html-and-project-root).

- contains `workspaces` field in `package.json`
- contains one of the following file
  - `lerna.json`
  - `pnpm-workspace.yaml`

Accepts a path to specify the custom workspace root. Could be a absolute path or a path relative to [project root](/guide/#index-html-and-project-root). For example:

```js
export default defineConfig({
  server: {
    fs: {
      // Allow serving files from one level up to the project root
      allow: ['..'],
    },
  },
})
```

When `server.fs.allow` is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility `searchForWorkspaceRoot` is exposed:

```js
import { defineConfig, searchForWorkspaceRoot } from 'vite'

export default defineConfig({
  server: {
    fs: {
      allow: [
        // search up for workspace root
        searchForWorkspaceRoot(process.cwd()),
        // your custom rules
        '/path/to/custom/allow_directory',
        '/path/to/custom/allow_file.demo',
      ],
    },
  },
})
```

## server.fs.deny

- **Type:** `string[]`
- **Default:** `['.env', '.env.*', '*.{crt,pem}', '**/.git/**']`

Blocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than [`server.fs.allow`](#server-fs-allow). [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) are supported.

::: tip NOTE

This blocklist does not apply to [the public directory](/guide/assets.md#the-public-directory). All files in the public directory are served without any filtering, since they are copied directly to the output directory during build.

:::

## server.origin

- **Type:** `string`

Defines the origin of the generated asset URLs during development.

```js
export default defineConfig({
  server: {
    origin: 'http://127.0.0.1:8080',
  },
})
```

## server.sourcemapIgnoreList

- **Type:** `false | (sourcePath: string, sourcemapPath: string) => boolean`
- **Default:** `(sourcePath) => sourcePath.includes('node_modules')`

Whether or not to ignore source files in the server sourcemap, used to populate the [`x_google_ignoreList` source map extension](https://developer.chrome.com/articles/x-google-ignore-list/).

`server.sourcemapIgnoreList` is the equivalent of [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) for the dev server. A difference between the two config options is that the rollup function is called with a relative path for `sourcePath` while `server.sourcemapIgnoreList` is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for `sourcePath` is the file name itself. In these cases, absolute paths makes it convenient to be used instead.

By default, it excludes all paths containing `node_modules`. You can pass `false` to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.

```js
export default defineConfig({
  server: {
    // This is the default value, and will add all files with node_modules
    // in their paths to the ignore list.
    sourcemapIgnoreList(sourcePath, sourcemapPath) {
      return sourcePath.includes('node_modules')
    },
  },
})
```

::: tip Note
[`server.sourcemapIgnoreList`](#server-sourcemapignorelist) and [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) need to be set independently. `server.sourcemapIgnoreList` is a server only config and doesn't get its default value from the defined rollup options.
:::



================================================
FILE: docs/config/shared-options.md
================================================
# Shared Options

Unless noted, the options in this section are applied to all dev, build, and preview.

## root

- **Type:** `string`
- **Default:** `process.cwd()`

Project root directory (where `index.html` is located). Can be an absolute path, or a path relative to the current working directory.

See [Project Root](/guide/#index-html-and-project-root) for more details.

## base

- **Type:** `string`
- **Default:** `/`
- **Related:** [`server.origin`](/config/server-options.md#server-origin)

Base public path when served in development or production. Valid values include:

- Absolute URL pathname, e.g. `/foo/`
- Full URL, e.g. `https://bar.com/foo/` (The origin part won't be used in development so the value is the same as `/foo/`)
- Empty string or `./` (for embedded deployment)

See [Public Base Path](/guide/build#public-base-path) for more details.

## mode

- **Type:** `string`
- **Default:** `'development'` for serve, `'production'` for build

Specifying this in config will override the default mode for **both serve and build**. This value can also be overridden via the command line `--mode` option.

See [Env Variables and Modes](/guide/env-and-mode) for more details.

## define

- **Type:** `Record<string, any>`

Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.

Vite uses [esbuild defines](https://esbuild.github.io/api/#define) to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with `JSON.stringify`.

**Example:**

```js
export default defineConfig({
  define: {
    __APP_VERSION__: JSON.stringify('v1.0.0'),
    __API_URL__: 'window.__backend_api_url',
  },
})
```

::: tip NOTE
For TypeScript users, make sure to add the type declarations in the `vite-env.d.ts` file to get type checks and Intellisense.

Example:

```ts
// vite-env.d.ts
declare const __APP_VERSION__: string
```

:::

## plugins

- **Type:** `(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]`

Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See [Plugin API](/guide/api-plugin) for more details on Vite plugins.

## publicDir

- **Type:** `string | false`
- **Default:** `"public"`

Directory to serve as plain static assets. Files in this directory are served at `/` during dev and copied to the root of `outDir` during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.

Defining `publicDir` as `false` disables this feature.

See [The `public` Directory](/guide/assets#the-public-directory) for more details.

## cacheDir

- **Type:** `string`
- **Default:** `"node_modules/.vite"`

Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use `--force` flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to `.vite` when no package.json is detected.

## resolve.alias

- **Type:**
  `Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`

Will be passed to `@rollup/plugin-alias` as its [entries option](https://github.com/rollup/plugins/tree/master/packages/alias#entries). Can either be an object, or an array of `{ find, replacement, customResolver }` pairs.

When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.

More advanced custom resolution can be achieved through [plugins](/guide/api-plugin).

::: warning Using with SSR
If you have configured aliases for [SSR externalized dependencies](/guide/ssr.md#ssr-externals), you may want to alias the actual `node_modules` packages. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.
:::

## resolve.dedupe

- **Type:** `string[]`

If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).

:::warning SSR + ESM
For SSR builds, deduplication does not work for ESM build outputs configured from `build.rollupOptions.output`. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.
:::

## resolve.conditions <NonInheritBadge />

- **Type:** `string[]`
- **Default:** `['module', 'browser', 'development|production']` (`defaultClientConditions`)

Additional allowed conditions when resolving [Conditional Exports](https://nodejs.org/api/packages.html#packages_conditional_exports) from a package.

A package with conditional exports may have the following `exports` field in its `package.json`:

```json
{
  "exports": {
    ".": {
      "import": "./index.mjs",
      "require": "./index.js"
    }
  }
}
```

Here, `import` and `require` are "conditions". Conditions can be nested and should be specified from most specific to least specific.

`development|production` is a special value that is replaced with `production` or `development` depending on the value of `process.env.NODE_ENV`. It is replaced with `production` when `process.env.NODE_ENV === 'production'` and `development` otherwise.

Note that `import`, `require`, `default` conditions are always applied if the requirements are met.

## resolve.mainFields <NonInheritBadge />

- **Type:** `string[]`
- **Default:** `['browser', 'module', 'jsnext:main', 'jsnext']` (`defaultClientMainFields`)

List of fields in `package.json` to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the `exports` field: if an entry point is successfully resolved from `exports`, the main field will be ignored.

## resolve.extensions

- **Type:** `string[]`
- **Default:** `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`

List of file extensions to try for imports that omit extensions. Note it is **NOT** recommended to omit extensions for custom import types (e.g. `.vue`) since it can interfere with IDE and type support.

## resolve.preserveSymlinks

- **Type:** `boolean`
- **Default:** `false`

Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).

- **Related:** [esbuild#preserve-symlinks](https://esbuild.github.io/api/#preserve-symlinks), [webpack#resolve.symlinks
  ](https://webpack.js.org/configuration/resolve/#resolvesymlinks)

## html.cspNonce

- **Type:** `string`
- **Related:** [Content Security Policy (CSP)](/guide/features#content-security-policy-csp)

A nonce value placeholder that will be used when generating script / style tags. Setting this value will also generate a meta tag with nonce value.

## css.modules

- **Type:**
  ```ts
  interface CSSModulesOptions {
    getJSON?: (
      cssFileName: string,
      json: Record<string, string>,
      outputFileName: string,
    ) => void
    scopeBehaviour?: 'global' | 'local'
    globalModulePaths?: RegExp[]
    exportGlobals?: boolean
    generateScopedName?:
      | string
      | ((name: string, filename: string, css: string) => string)
    hashPrefix?: string
    /**
     * default: undefined
     */
    localsConvention?:
      | 'camelCase'
      | 'camelCaseOnly'
      | 'dashes'
      | 'dashesOnly'
      | ((
          originalClassName: string,
          generatedClassName: string,
          inputFile: string,
        ) => string)
  }
  ```

Configure CSS modules behavior. The options are passed on to [postcss-modules](https://github.com/css-modules/postcss-modules).

This option doesn't have any effect when using [Lightning CSS](../guide/features.md#lightning-css). If enabled, [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) should be used instead.

## css.postcss

- **Type:** `string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })`

Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).

For inline PostCSS config, it expects the same format as `postcss.config.js`. But for `plugins` property, only [array format](https://github.com/postcss/postcss-load-config/blob/main/README.md#array) can be used.

The search is done using [postcss-load-config](https://github.com/postcss/postcss-load-config) and only the supported config file names are loaded. Config files outside the workspace root (or the [project root](/guide/#index-html-and-project-root) if no workspace is found) are not searched by default. You can specify a custom path outside of the root to load the specific config file instead if needed.

Note if an inline config is provided, Vite will not search for other PostCSS config sources.

## css.preprocessorOptions

- **Type:** `Record<string, object>`

Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessor can be found in their respective documentation:

- `sass`/`scss`:
  - Uses `sass-embedded` if installed, otherwise uses `sass`. For the best performance, it's recommended to install the `sass-embedded` package.
  - [Options](https://sass-lang.com/documentation/js-api/interfaces/stringoptions/)
- `less`: [Options](https://lesscss.org/usage/#less-options).
- `styl`/`stylus`: Only [`define`](https://stylus-lang.com/docs/js.html#define-name-node) is supported, which can be passed as an object.

**Example:**

```js
export default defineConfig({
  css: {
    preprocessorOptions: {
      less: {
        math: 'parens-division',
      },
      styl: {
        define: {
          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),
        },
      },
      scss: {
        importers: [
          // ...
        ],
      },
    },
  },
})
```

### css.preprocessorOptions[extension].additionalData

- **Type:** `string | ((source: string, filename: string) => (string | { content: string; map?: SourceMap }))`

This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.

**Example:**

```js
export default defineConfig({
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `$injectedColor: orange;`,
      },
    },
  },
})
```

## css.preprocessorMaxWorkers

- **Type:** `number | true`
- **Default:** `true`

Specifies the maximum number of threads CSS preprocessors can use. `true` means up to the number of CPUs minus 1. When set to `0`, Vite will not create any workers and will run the preprocessors in the main thread.

Depending on the preprocessor options, Vite may run the preprocessors on the main thread even if this option is not set to `0`.

## css.devSourcemap

- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13845)
- **Type:** `boolean`
- **Default:** `false`

Whether to enable sourcemaps during dev.

## css.transformer

- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)
- **Type:** `'postcss' | 'lightningcss'`
- **Default:** `'postcss'`

Selects the engine used for CSS processing. Check out [Lightning CSS](../guide/features.md#lightning-css) for more information.

::: info Duplicate `@import`s
Note that postcss (postcss-import) has a different behavior with duplicated `@import` from browsers. See [postcss/postcss-import#462](https://github.com/postcss/postcss-import/issues/462).
:::

## css.lightningcss

- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)
- **Type:**

```js
import type {
  CSSModulesConfig,
  Drafts,
  Features,
  NonStandard,
  PseudoClasses,
  Targets,
} from 'lightningcss'
```

```js
{
  targets?: Targets
  include?: Features
  exclude?: Features
  drafts?: Drafts
  nonStandard?: NonStandard
  pseudoClasses?: PseudoClasses
  unusedSymbols?: string[]
  cssModules?: CSSModulesConfig,
  // ...
}
```

Configures Lightning CSS. Full transform options can be found in [the Lightning CSS repo](https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts).

## json.namedExports

- **Type:** `boolean`
- **Default:** `true`

Whether to support named imports from `.json` files.

## json.stringify

- **Type:** `boolean | 'auto'`
- **Default:** `'auto'`

If set to `true`, imported JSON will be transformed into `export default JSON.parse("...")` which is significantly more performant than Object literals, especially when the JSON file is large.

If set to `'auto'`, the data will be stringified only if [the data is bigger than 10kB](https://v8.dev/blog/cost-of-javascript-2019#json:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger).

## esbuild

- **Type:** `ESBuildOptions | false`

`ESBuildOptions` extends [esbuild's own transform options](https://esbuild.github.io/api/#transform). The most common use case is customizing JSX:

```js
export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment',
  },
})
```

By default, esbuild is applied to `ts`, `jsx` and `tsx` files. You can customize this with `esbuild.include` and `esbuild.exclude`, which can be a regex, a [picomatch](https://github.com/micromatch/picomatch#globbing-features) pattern, or an array of either.

In addition, you can also use `esbuild.jsxInject` to automatically inject JSX helper imports for every file transformed by esbuild:

```js
export default defineConfig({
  esbuild: {
    jsxInject: `import React from 'react'`,
  },
})
```

When [`build.minify`](./build-options.md#build-minify) is `true`, all minify optimizations are applied by default. To disable [certain aspects](https://esbuild.github.io/api/#minify) of it, set any of `esbuild.minifyIdentifiers`, `esbuild.minifySyntax`, or `esbuild.minifyWhitespace` options to `false`. Note the `esbuild.minify` option can't be used to override `build.minify`.

Set to `false` to disable esbuild transforms.

## assetsInclude

- **Type:** `string | RegExp | (string | RegExp)[]`
- **Related:** [Static Asset Handling](/guide/assets)

Specify additional [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) to be treated as static assets so that:

- They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over `fetch` or XHR.

- Importing them from JS will return their resolved URL string (this can be overwritten if you have a `enforce: 'pre'` plugin to handle the asset type differently).

The built-in asset type list can be found [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts).

**Example:**

```js
export default defineConfig({
  assetsInclude: ['**/*.gltf'],
})
```

## logLevel

- **Type:** `'info' | 'warn' | 'error' | 'silent'`

Adjust console output verbosity. Default is `'info'`.

## customLogger

- **Type:**
  ```ts
  interface Logger {
    info(msg: string, options?: LogOptions): void
    warn(msg: string, options?: LogOptions): void
    warnOnce(msg: string, options?: LogOptions): void
    error(msg: string, options?: LogErrorOptions): void
    clearScreen(type: LogType): void
    hasErrorLogged(error: Error | RollupError): boolean
    hasWarned: boolean
  }
  ```

Use a custom logger to log messages. You can use Vite's `createLogger` API to get the default logger and customize it to, for example, change the message or filter out certain warnings.

```ts twoslash
import { createLogger, defineConfig } from 'vite'

const logger = createLogger()
const loggerWarn = logger.warn

logger.warn = (msg, options) => {
  // Ignore empty CSS files warning
  if (msg.includes('vite:css') && msg.includes(' is empty')) return
  loggerWarn(msg, options)
}

export default defineConfig({
  customLogger: logger,
})
```

## clearScreen

- **Type:** `boolean`
- **Default:** `true`

Set to `false` to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use `--clearScreen false`.

## envDir

- **Type:** `string | false`
- **Default:** `root`

The directory from which `.env` files are loaded. Can be an absolute path, or a path relative to the project root. `false` will disable the `.env` file loading.

See [here](/guide/env-and-mode#env-files) for more about environment files.

## envPrefix

- **Type:** `string | string[]`
- **Default:** `VITE_`

Env variables starting with `envPrefix` will be exposed to your client source code via `import.meta.env`.

:::warning SECURITY NOTES
`envPrefix` should not be set as `''`, which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting `''`.

If you would like to expose an unprefixed variable, you can use [define](#define) to expose it:

```js
define: {
  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)
}
```

:::

## appType

- **Type:** `'spa' | 'mpa' | 'custom'`
- **Default:** `'spa'`

Whether your application is a Single Page Application (SPA), a [Multi Page Application (MPA)](../guide/build#multi-page-app), or Custom Application (SSR and frameworks with custom HTML handling):

- `'spa'`: include HTML middlewares and use SPA fallback. Configure [sirv](https://github.com/lukeed/sirv) with `single: true` in preview
- `'mpa'`: include HTML middlewares
- `'custom'`: don't include HTML middlewares

Learn more in Vite's [SSR guide](/guide/ssr#vite-cli). Related: [`server.middlewareMode`](./server-options#server-middlewaremode).

## future

- **Type:** `Record<string, 'warn' | undefined>`
- **Related:** [Breaking Changes](/changes/)

Enable future breaking changes to prepare for a smooth migration to the next major version of Vite. The list may be updated, added, or removed at any time as new features are developed.

See the [Breaking Changes](/changes/) page for details of the possible options.



================================================
FILE: docs/config/ssr-options.md
================================================
# SSR Options

Unless noted, the options in this section are applied to both dev and build.

## ssr.external

- **Type:** `string[] | true`
- **Related:** [SSR Externals](/guide/ssr#ssr-externals)

Externalize the given dependencies and their transitive dependencies for SSR. By default, all dependencies are externalized except for linked dependencies (for HMR). If you prefer to externalize the linked dependency, you can pass its name to this option.

If `true`, all dependencies including linked dependencies are externalized.

Note that the explicitly listed dependencies (using `string[]` type) will always take priority if they're also listed in `ssr.noExternal` (using any type).

## ssr.noExternal

- **Type:** `string | RegExp | (string | RegExp)[] | true`
- **Related:** [SSR Externals](/guide/ssr#ssr-externals)

Prevent listed dependencies from being externalized for SSR, which they will get bundled in build. By default, only linked dependencies are not externalized (for HMR). If you prefer to externalize the linked dependency, you can pass its name to the `ssr.external` option.

If `true`, no dependencies are externalized. However, dependencies explicitly listed in `ssr.external` (using `string[]` type) can take priority and still be externalized. If `ssr.target: 'node'` is set, Node.js built-ins will also be externalized by default.

Note that if both `ssr.noExternal: true` and `ssr.external: true` are configured, `ssr.noExternal` takes priority and no dependencies are externalized.

## ssr.target

- **Type:** `'node' | 'webworker'`
- **Default:** `node`

Build target for the SSR server.

## ssr.resolve.conditions

- **Type:** `string[]`
- **Default:** `['module', 'node', 'development|production']` (`defaultServerConditions`) (`['module', 'browser', 'development|production']` (`defaultClientConditions`) for `ssr.target === 'webworker'`)
- **Related:** [Resolve Conditions](./shared-options.md#resolve-conditions)

These conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use `ssr.resolve.externalConditions` to affect externalized imports.

## ssr.resolve.externalConditions

- **Type:** `string[]`
- **Default:** `['node']`

Conditions that are used during ssr import (including `ssrLoadModule`) of externalized direct dependencies (external dependencies imported by Vite).

:::tip

When using this option, make sure to run Node with [`--conditions` flag](https://nodejs.org/docs/latest/api/cli.html#-c-condition---conditionscondition) with the same values in both dev and build to get a consistent behavior.

For example, when setting `['node', 'custom']`, you should run `NODE_OPTIONS='--conditions custom' vite` in dev and `NODE_OPTIONS="--conditions custom" node ./dist/server.js` after build.

:::

## ssr.resolve.mainFields

- **Type:** `string[]`
- **Default:** `['module', 'jsnext:main', 'jsnext']`

List of fields in `package.json` to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the `exports` field: if an entry point is successfully resolved from `exports`, the main field will be ignored. This setting only affects non-externalized dependencies.



================================================
FILE: docs/config/worker-options.md
================================================
# Worker Options

Unless noted, the options in this section are applied to all dev, build, and preview.

## worker.format

- **Type:** `'es' | 'iife'`
- **Default:** `'iife'`

Output format for worker bundle.

## worker.plugins

- **Type:** [`() => (Plugin | Plugin[])[]`](./shared-options#plugins)

Vite plugins that apply to the worker bundles. Note that [config.plugins](./shared-options#plugins) only applies to workers in dev, it should be configured here instead for build.
The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying `config.worker` options in the `config` hook will be ignored.

## worker.rollupOptions

- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

Rollup options to build worker bundle.



================================================
FILE: docs/guide/api-environment-frameworks.md
================================================
# Environment API for Frameworks

:::info Release Candidate
The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that [some specific APIs](/changes/#considering) are still considered experimental.

We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.

Resources:

- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.
- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API were implemented and reviewed.

Please share your feedback with us.
:::

## DevEnvironment Communication Levels

Since environments may run in different runtimes, communication against the environment may have constraints depending on the runtime. To allow frameworks to write runtime agnostic code easily, the Environment API provides three kinds of communication levels.

### `RunnableDevEnvironment`

`RunnableDevEnvironment` is an environment that can communicate arbitrary values. The implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks to migrate and enable HMR for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.

```ts
export class RunnableDevEnvironment extends DevEnvironment {
  public readonly runner: ModuleRunner
}

class ModuleRunner {
  /**
   * URL to execute.
   * Accepts file path, server path, or id relative to the root.
   * Returns an instantiated module (same as in ssrLoadModule)
   */
  public async import(url: string): Promise<Record<string, any>>
  /**
   * Other ModuleRunner methods...
   */
}

if (isRunnableDevEnvironment(server.environments.ssr)) {
  await server.environments.ssr.runner.import('/entry-point.js')
}
```

:::warning
The `runner` is evaluated lazily only when it's accessed for the first time. Beware that Vite enables source map support when the `runner` is created by calling `process.setSourceMapsEnabled` or by overriding `Error.prepareStackTrace` if it's not available.
:::

Given a Vite server configured in middleware mode as described by the [SSR setup guide](/guide/ssr#setting-up-the-dev-server), let's implement the SSR middleware using the environment API. Remember that it doesn't have to be called `ssr`, so we'll name it `server` in this example. Error handling is omitted.

```js
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const viteServer = await createServer({
  server: { middlewareMode: true },
  appType: 'custom',
  environments: {
    server: {
      // by default, modules are run in the same process as the vite server
    },
  },
})

// You might need to cast this to RunnableDevEnvironment in TypeScript or
// use isRunnableDevEnvironment to guard the access to the runner
const serverEnvironment = viteServer.environments.server

app.use('*', async (req, res, next) => {
  const url = req.originalUrl

  // 1. Read index.html
  const indexHtmlPath = path.resolve(__dirname, 'index.html')
  let template = fs.readFileSync(indexHtmlPath, 'utf-8')

  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,
  //    and also applies HTML transforms from Vite plugins, e.g. global
  //    preambles from @vitejs/plugin-react
  template = await viteServer.transformIndexHtml(url, template)

  // 3. Load the server entry. import(url) automatically transforms
  //    ESM source code to be usable in Node.js! There is no bundling
  //    required, and provides full HMR support.
  const { render } = await serverEnvironment.runner.import(
    '/src/entry-server.js',
  )

  // 4. render the app HTML. This assumes entry-server.js's exported
  //     `render` function calls appropriate framework SSR APIs,
  //    e.g. ReactDOMServer.renderToString()
  const appHtml = await render(url)

  // 5. Inject the app-rendered HTML into the template.
  const html = template.replace(`<!--ssr-outlet-->`, appHtml)

  // 6. Send the rendered HTML back.
  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
})
```

When using environments that support HMR (such as `RunnableDevEnvironment`), you should add `import.meta.hot.accept()` in your server entry file for optimal behavior. Without this, server file changes will invalidate the entire server module graph:

```js
// src/entry-server.js
export function render(...) { ... }

if (import.meta.hot) {
  import.meta.hot.accept()
}
```

### `FetchableDevEnvironment`

:::info

We are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).

:::

`FetchableDevEnvironment` is an environment that can communicate with its runtime via the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch) interface. Since the `RunnableDevEnvironment` is only possible to implement in a limited set of runtimes, we recommend to use the `FetchableDevEnvironment` instead of the `RunnableDevEnvironment`.

This environment provides a standardized way of handling requests via the `handleRequest` method:

```ts
import {
  createServer,
  createFetchableDevEnvironment,
  isFetchableDevEnvironment,
} from 'vite'

const server = await createServer({
  server: { middlewareMode: true },
  appType: 'custom',
  environments: {
    custom: {
      dev: {
        createEnvironment(name, config) {
          return createFetchableDevEnvironment(name, config, {
            handleRequest(request: Request): Promise<Response> | Response {
              // handle Request and return a Response
            },
          })
        },
      },
    },
  },
})

// Any consumer of the environment API can now call `dispatchFetch`
if (isFetchableDevEnvironment(server.environments.custom)) {
  const response: Response = await server.environments.custom.dispatchFetch(
    new Request('/request-to-handle'),
  )
}
```

:::warning
Vite validates the input and output of the `dispatchFetch` method: the request must be an instance of the global `Request` class and the response must be the instance of the global `Response` class. Vite will throw a `TypeError` if this is not the case.

Note that although the `FetchableDevEnvironment` is implemented as a class, it is considered an implementation detail by the Vite team and might change at any moment.
:::

### raw `DevEnvironment`

If the environment does not implement the `RunnableDevEnvironment` or `FetchableDevEnvironment` interfaces, you need to set up the communication manually.

If your code can run in the same runtime as the user modules (i.e., it does not rely on Node.js-specific APIs), you can use a virtual module. This approach eliminates the need to access the value from the code using Vite's APIs.

```ts
// code using the Vite's APIs
import { createServer } from 'vite'

const server = createServer({
  plugins: [
    // a plugin that handles `virtual:entrypoint`
    {
      name: 'virtual-module',
      /* plugin implementation */
    },
  ],
})
const ssrEnvironment = server.environment.ssr
const input = {}

// use exposed functions by each environment factories that runs the code
// check for each environment factories what they provide
if (ssrEnvironment instanceof CustomDevEnvironment) {
  ssrEnvironment.runEntrypoint('virtual:entrypoint')
} else {
  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)
}

// -------------------------------------
// virtual:entrypoint
const { createHandler } = await import('./entrypoint.js')
const handler = createHandler(input)
const response = handler(new Request('/'))

// -------------------------------------
// ./entrypoint.js
export function createHandler(input) {
  return function handler(req) {
    return new Response('hello')
  }
}
```

For example, to call `transformIndexHtml` on the user module, the following plugin can be used:

```ts {13-21}
function vitePluginVirtualIndexHtml(): Plugin {
  let server: ViteDevServer | undefined
  return {
    name: vitePluginVirtualIndexHtml.name,
    configureServer(server_) {
      server = server_
    },
    resolveId(source) {
      return source === 'virtual:index-html' ? '\0' + source : undefined
    },
    async load(id) {
      if (id === '\0' + 'virtual:index-html') {
        let html: string
        if (server) {
          this.addWatchFile('index.html')
          html = fs.readFileSync('index.html', 'utf-8')
          html = await server.transformIndexHtml('/', html)
        } else {
          html = fs.readFileSync('dist/client/index.html', 'utf-8')
        }
        return `export default ${JSON.stringify(html)}`
      }
      return
    },
  }
}
```

If your code requires Node.js APIs, you can use `hot.send` to communicate with the code that uses Vite's APIs from the user modules. However, be aware that this approach may not work the same way after the build process.

```ts
// code using the Vite's APIs
import { createServer } from 'vite'

const server = createServer({
  plugins: [
    // a plugin that handles `virtual:entrypoint`
    {
      name: 'virtual-module',
      /* plugin implementation */
    },
  ],
})
const ssrEnvironment = server.environment.ssr
const input = {}

// use exposed functions by each environment factories that runs the code
// check for each environment factories what they provide
if (ssrEnvironment instanceof RunnableDevEnvironment) {
  ssrEnvironment.runner.import('virtual:entrypoint')
} else if (ssrEnvironment instanceof CustomDevEnvironment) {
  ssrEnvironment.runEntrypoint('virtual:entrypoint')
} else {
  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)
}

const req = new Request('/')

const uniqueId = 'a-unique-id'
ssrEnvironment.send('request', serialize({ req, uniqueId }))
const response = await new Promise((resolve) => {
  ssrEnvironment.on('response', (data) => {
    data = deserialize(data)
    if (data.uniqueId === uniqueId) {
      resolve(data.res)
    }
  })
})

// -------------------------------------
// virtual:entrypoint
const { createHandler } = await import('./entrypoint.js')
const handler = createHandler(input)

import.meta.hot.on('request', (data) => {
  const { req, uniqueId } = deserialize(data)
  const res = handler(req)
  import.meta.hot.send('response', serialize({ res: res, uniqueId }))
})

const response = handler(new Request('/'))

// -------------------------------------
// ./entrypoint.js
export function createHandler(input) {
  return function handler(req) {
    return new Response('hello')
  }
}
```

## Environments During Build

In the CLI, calling `vite build` and `vite build --ssr` will still build the client only and ssr only environments for backward compatibility.

When `builder` is not `undefined` (or when calling `vite build --app`), `vite build` will opt-in into building the entire app instead. This would later on become the default in a future major. A `ViteBuilder` instance will be created (build-time equivalent to a `ViteDevServer`) to build all configured environments for production. By default the build of environments is run in series respecting the order of the `environments` record. A framework or user can further configure how the environments are built using:

```js
export default {
  builder: {
    buildApp: async (builder) => {
      const environments = Object.values(builder.environments)
      return Promise.all(
        environments.map((environment) => builder.build(environment)),
      )
    },
  },
}
```

Plugins can also define a `buildApp` hook. Order `'pre'` and `null` are executed before the configured `builder.buildApp`, and order `'post'` hooks are executed after it. `environment.isBuilt` can be used to check if an environment has already being build.

## Environment Agnostic Code

Most of the time, the current `environment` instance will be available as part of the context of the code being run so the need to access them through `server.environments` should be rare. For example, inside plugin hooks the environment is exposed as part of the `PluginContext`, so it can be accessed using `this.environment`. See [Environment API for Plugins](./api-environment-plugins.md) to learn about how to build environment aware plugins.



================================================
FILE: docs/guide/api-environment-instances.md
================================================
# Using `Environment` Instances

:::info Release Candidate
The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that [some specific APIs](/changes/#considering) are still considered experimental.

We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.

Resources:

- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.
- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API were implemented and reviewed.

Please share your feedback with us.
:::

## Accessing the Environments

During dev, the available environments in a dev server can be accessed using `server.environments`:

```js
// create the server, or get it from the configureServer hook
const server = await createServer(/* options */)

const clientEnvironment = server.environments.client
clientEnvironment.transformRequest(url)
console.log(server.environments.ssr.moduleGraph)
```

You can also access the current environment from plugins. See the [Environment API for Plugins](./api-environment-plugins.md#accessing-the-current-environment-in-hooks) for more details.

## `DevEnvironment` class

During dev, each environment is an instance of the `DevEnvironment` class:

```ts
class DevEnvironment {
  /**
   * Unique identifier for the environment in a Vite server.
   * By default Vite exposes 'client' and 'ssr' environments.
   */
  name: string
  /**
   * Communication channel to send and receive messages from the
   * associated module runner in the target runtime.
   */
  hot: NormalizedHotChannel
  /**
   * Graph of module nodes, with the imported relationship between
   * processed modules and the cached result of the processed code.
   */
  moduleGraph: EnvironmentModuleGraph
  /**
   * Resolved plugins for this environment, including the ones
   * created using the per-environment `create` hook
   */
  plugins: Plugin[]
  /**
   * Allows to resolve, load, and transform code through the
   * environment plugins pipeline
   */
  pluginContainer: EnvironmentPluginContainer
  /**
   * Resolved config options for this environment. Options at the server
   * global scope are taken as defaults for all environments, and can
   * be overridden (resolve conditions, external, optimizedDeps)
   */
  config: ResolvedConfig & ResolvedDevEnvironmentOptions

  constructor(
    name: string,
    config: ResolvedConfig,
    context: DevEnvironmentContext,
  )

  /**
   * Resolve the URL to an id, load it, and process the code using the
   * plugins pipeline. The module graph is also updated.
   */
  async transformRequest(url: string): Promise<TransformResult | null>

  /**
   * Register a request to be processed with low priority. This is useful
   * to avoid waterfalls. The Vite server has information about the
   * imported modules by other requests, so it can warmup the module graph
   * so the modules are already processed when they are requested.
   */
  async warmupRequest(url: string): Promise<void>
}
```

With `DevEnvironmentContext` being:

```ts
interface DevEnvironmentContext {
  hot: boolean
  transport?: HotChannel | WebSocketServer
  options?: EnvironmentOptions
  remoteRunner?: {
    inlineSourceMap?: boolean
  }
  depsOptimizer?: DepsOptimizer
}
```

and with `TransformResult` being:

```ts
interface TransformResult {
  code: string
  map: SourceMap | { mappings: '' } | null
  etag?: string
  deps?: string[]
  dynamicDeps?: string[]
}
```

An environment instance in the Vite server lets you process a URL using the `environment.transformRequest(url)` method. This function will use the plugin pipeline to resolve the `url` to a module `id`, load it (reading the file from the file system or through a plugin that implements a virtual module), and then transform the code. While transforming the module, imports and other metadata will be recorded in the environment module graph by creating or updating the corresponding module node. When processing is done, the transform result is also stored in the module.

:::info transformRequest naming
We are using `transformRequest(url)` and `warmupRequest(url)` in the current version of this proposal so it is easier to discuss and understand for users used to Vite's current API. Before releasing, we can take the opportunity to review these names too. For example, it could be named `environment.processModule(url)` or `environment.loadModule(url)` taking a page from Rollup's `context.load(id)` in plugin hooks. For the moment, we think keeping the current names and delaying this discussion is better.
:::

## Separate Module Graphs

Each environment has an isolated module graph. All module graphs have the same signature, so generic algorithms can be implemented to crawl or query the graph without depending on the environment. `hotUpdate` is a good example. When a file is modified, the module graph of each environment will be used to discover the affected modules and perform HMR for each environment independently.

::: info
Vite v5 had a mixed Client and SSR module graph. Given an unprocessed or invalidated node, it isn't possible to know if it corresponds to the Client, SSR, or both environments. Module nodes have some properties prefixed, like `clientImportedModules` and `ssrImportedModules` (and `importedModules` that returns the union of both). `importers` contains all importers from both the Client and SSR environment for each module node. A module node also has `transformResult` and `ssrTransformResult`. A backward compatibility layer allows the ecosystem to migrate from the deprecated `server.moduleGraph`.
:::

Each module is represented by a `EnvironmentModuleNode` instance. Modules may be registered in the graph without yet being processed (`transformResult` would be `null` in that case). `importers` and `importedModules` are also updated after the module is processed.

```ts
class EnvironmentModuleNode {
  environment: string

  url: string
  id: string | null = null
  file: string | null = null

  type: 'js' | 'css'

  importers = new Set<EnvironmentModuleNode>()
  importedModules = new Set<EnvironmentModuleNode>()
  importedBindings: Map<string, Set<string>> | null = null

  info?: ModuleInfo
  meta?: Record<string, any>
  transformResult: TransformResult | null = null

  acceptedHmrDeps = new Set<EnvironmentModuleNode>()
  acceptedHmrExports: Set<string> | null = null
  isSelfAccepting?: boolean
  lastHMRTimestamp = 0
  lastInvalidationTimestamp = 0
}
```

`environment.moduleGraph` is an instance of `EnvironmentModuleGraph`:

```ts
export class EnvironmentModuleGraph {
  environment: string

  urlToModuleMap = new Map<string, EnvironmentModuleNode>()
  idToModuleMap = new Map<string, EnvironmentModuleNode>()
  etagToModuleMap = new Map<string, EnvironmentModuleNode>()
  fileToModulesMap = new Map<string, Set<EnvironmentModuleNode>>()

  constructor(
    environment: string,
    resolveId: (url: string) => Promise<PartialResolvedId | null>,
  )

  async getModuleByUrl(
    rawUrl: string,
  ): Promise<EnvironmentModuleNode | undefined>

  getModuleById(id: string): EnvironmentModuleNode | undefined

  getModulesByFile(file: string): Set<EnvironmentModuleNode> | undefined

  onFileChange(file: string): void

  onFileDelete(file: string): void

  invalidateModule(
    mod: EnvironmentModuleNode,
    seen: Set<EnvironmentModuleNode> = new Set(),
    timestamp: number = monotonicDateNow(),
    isHmr: boolean = false,
  ): void

  invalidateAll(): void

  async ensureEntryFromUrl(
    rawUrl: string,
    setIsSelfAccepting = true,
  ): Promise<EnvironmentModuleNode>

  createFileOnlyEntry(file: string): EnvironmentModuleNode

  async resolveUrl(url: string): Promise<ResolvedUrl>

  updateModuleTransformResult(
    mod: EnvironmentModuleNode,
    result: TransformResult | null,
  ): void

  getModuleByEtag(etag: string): EnvironmentModuleNode | undefined
}
```



================================================
FILE: docs/guide/api-environment-plugins.md
================================================
# Environment API for Plugins

:::info Release Candidate
The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that [some specific APIs](/changes/#considering) are still considered experimental.

We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.

Resources:

- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.
- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API were implemented and reviewed.

Please share your feedback with us.
:::

## Accessing the Current Environment in Hooks

Given that there were only two Environments until Vite 6 (`client` and `ssr`), a `ssr` boolean was enough to identify the current environment in Vite APIs. Plugin Hooks received a `ssr` boolean in the last options parameter, and several APIs expected an optional last `ssr` parameter to properly associate modules to the correct environment (for example `server.moduleGraph.getModuleByUrl(url, { ssr })`).

With the advent of configurable environments, we now have a uniform way to access their options and instance in plugins. Plugin hooks now expose `this.environment` in their context, and APIs that previously expected a `ssr` boolean are now scoped to the proper environment (for example `environment.moduleGraph.getModuleByUrl(url)`).

The Vite server has a shared plugin pipeline, but when a module is processed it is always done in the context of a given environment. The `environment` instance is available in the plugin context.

A plugin could use the `environment` instance to change how a module is processed depending on the configuration for the environment (which can be accessed using `environment.config`).

```ts
  transform(code, id) {
    console.log(this.environment.config.resolve.conditions)
  }
```

## Registering New Environments Using Hooks

Plugins can add new environments in the `config` hook (for example to have a separate module graph for [RSC](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)):

```ts
  config(config: UserConfig) {
    config.environments.rsc ??= {}
  }
```

An empty object is enough to register the environment, default values from the root level environment config.

## Configuring Environment Using Hooks

While the `config` hook is running, the complete list of environments isn't yet known and the environments can be affected by both the default values from the root level environment config or explicitly through the `config.environments` record.
Plugins should set default values using the `config` hook. To configure each environment, they can use the new `configEnvironment` hook. This hook is called for each environment with its partially resolved config including resolution of final defaults.

```ts
  configEnvironment(name: string, options: EnvironmentOptions) {
    if (name === 'rsc') {
      options.resolve.conditions = // ...
```

## The `hotUpdate` Hook

- **Type:** `(this: { environment: DevEnvironment }, options: HotUpdateOptions) => Array<EnvironmentModuleNode> | void | Promise<Array<EnvironmentModuleNode> | void>`
- **See also:** [HMR API](./api-hmr)

The `hotUpdate` hook allows plugins to perform custom HMR update handling for a given environment. When a file changes, the HMR algorithm is run for each environment in series according to the order in `server.environments`, so the `hotUpdate` hook will be called multiple times. The hook receives a context object with the following signature:

```ts
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

- `this.environment` is the module execution environment where a file update is currently being processed.

- `modules` is an array of modules in this environment that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).

- `read` is an async read function that returns the content of the file. This is provided because, on some systems, the file change callback may fire too fast before the editor finishes updating the file, and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.

The hook can choose to:

- Filter and narrow down the affected module list so that the HMR is more accurate.

- Return an empty array and perform a full reload:

  ```js
  hotUpdate({ modules, timestamp }) {
    if (this.environment.name !== 'client')
      return

    // Invalidate modules manually
    const invalidatedModules = new Set()
    for (const mod of modules) {
      this.environment.moduleGraph.invalidateModule(
        mod,
        invalidatedModules,
        timestamp,
        true
      )
    }
    this.environment.hot.send({ type: 'full-reload' })
    return []
  }
  ```

- Return an empty array and perform complete custom HMR handling by sending custom events to the client:

  ```js
  hotUpdate() {
    if (this.environment.name !== 'client')
      return

    this.environment.hot.send({
      type: 'custom',
      event: 'special-update',
      data: {}
    })
    return []
  }
  ```

  Client code should register the corresponding handler using the [HMR API](./api-hmr) (this could be injected by the same plugin's `transform` hook):

  ```js
  if (import.meta.hot) {
    import.meta.hot.on('special-update', (data) => {
      // perform custom update
    })
  }
  ```

## Per-environment State in Plugins

Given that the same plugin instance is used for different environments, the plugin state needs to be keyed with `this.environment`. This is the same pattern the ecosystem has already been using to keep state about modules using the `ssr` boolean as key to avoid mixing client and ssr modules state. A `Map<Environment, State>` can be used to keep the state for each environment separately. Note that for backward compatibility, `buildStart` and `buildEnd` are only called for the client environment without the `perEnvironmentStartEndDuringDev: true` flag.

```js
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = new Map<Environment, { count: number }>()
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state.set(this.environment, { count: 0 })
    },
    transform(id) {
      state.get(this.environment).count++
    },
    buildEnd() {
      console.log(this.environment.name, state.get(this.environment).count)
    }
  }
}
```

## Per-environment Plugins

A plugin can define what are the environments it should apply to with the `applyToEnvironment` function.

```js
const UnoCssPlugin = () => {
  // shared global state
  return {
    buildStart() {
      // init per-environment state with WeakMap<Environment,Data>
      // using this.environment
    },
    configureServer() {
      // use global hooks normally
    },
    applyToEnvironment(environment) {
      // return true if this plugin should be active in this environment,
      // or return a new plugin to replace it.
      // if the hook is not used, the plugin is active in all environments
    },
    resolveId(id, importer) {
      // only called for environments this plugin apply to
    },
  }
}
```

If a plugin isn't environment aware and has state that isn't keyed on the current environment, the `applyToEnvironment` hook allows to easily make it per-environment.

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    {
      name: 'per-environment-plugin',
      applyToEnvironment(environment) {
        return nonShareablePlugin({ outputName: environment.name })
      },
    },
  ],
})
```

Vite exports a `perEnvironmentPlugin` helper to simplify these cases where no other hooks are required:

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    perEnvironmentPlugin('per-environment-plugin', (environment) =>
      nonShareablePlugin({ outputName: environment.name }),
    ),
  ],
})
```

The `applyToEnvironment` hook is called at config time, currently after `configResolved` due to projects in the ecosystem modifying the plugins in it. Environment plugins resolution may be moved before `configResolved` in the future.

## Environment in Build Hooks

In the same way as during dev, plugin hooks also receive the environment instance during build, replacing the `ssr` boolean.
This also works for `renderChunk`, `generateBundle`, and other build only hooks.

## Shared Plugins During Build

Before Vite 6, the plugins pipelines worked in a different way during dev and build:

- **During dev:** plugins are shared
- **During Build:** plugins are isolated for each environment (in different processes: `vite build` then `vite build --ssr`).

This forced frameworks to share state between the `client` build and the `ssr` build through manifest files written to the file system. In Vite 6, we are now building all environments in a single process so the way the plugins pipeline and inter-environment communication can be aligned with dev.

In a future major, we could have complete alignment:

- **During both dev and build:** plugins are shared, with [per-environment filtering](#per-environment-plugins)

There will also be a single `ResolvedConfig` instance shared during build, allowing for caching at entire app build process level in the same way as we have been doing with `WeakMap<ResolvedConfig, CachedData>` during dev.

For Vite 6, we need to do a smaller step to keep backward compatibility. Ecosystem plugins are currently using `config.build` instead of `environment.config.build` to access configuration, so we need to create a new `ResolvedConfig` per-environment by default. A project can opt-in into sharing the full config and plugins pipeline setting `builder.sharedConfigBuild` to `true`.

This option would only work of a small subset of projects at first, so plugin authors can opt-in for a particular plugin to be shared by setting the `sharedDuringBuild` flag to `true`. This allows for easily sharing state both for regular plugins:

```js
function myPlugin() {
  // Share state among all environments in dev and build
  const sharedState = ...
  return {
    name: 'shared-plugin',
    transform(code, id) { ... },

    // Opt-in into a single instance for all environments
    sharedDuringBuild: true,
  }
}
```



================================================
FILE: docs/guide/api-environment-runtimes.md
================================================
# Environment API for Runtimes

:::info Release Candidate
The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that [some specific APIs](/changes/#considering) are still considered experimental.

We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.

Resources:

- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.
- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API were implemented and reviewed.

Please share your feedback with us.
:::

## Environment Factories

Environments factories are intended to be implemented by Environment providers like Cloudflare, and not by end users. Environment factories return a `EnvironmentOptions` for the most common case of using the target runtime for both dev and build environments. The default environment options can also be set so the user doesn't need to do it.

```ts
function createWorkerdEnvironment(
  userConfig: EnvironmentOptions,
): EnvironmentOptions {
  return mergeConfig(
    {
      resolve: {
        conditions: [
          /*...*/
        ],
      },
      dev: {
        createEnvironment(name, config) {
          return createWorkerdDevEnvironment(name, config, {
            hot: true,
            transport: customHotChannel(),
          })
        },
      },
      build: {
        createEnvironment(name, config) {
          return createWorkerdBuildEnvironment(name, config)
        },
      },
    },
    userConfig,
  )
}
```

Then the config file can be written as:

```js
import { createWorkerdEnvironment } from 'vite-environment-workerd'

export default {
  environments: {
    ssr: createWorkerdEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
    rsc: createWorkerdEnvironment({
      build: {
        outDir: '/dist/rsc',
      },
    }),
  },
}
```

and frameworks can use an environment with the workerd runtime to do SSR using:

```js
const ssrEnvironment = server.environments.ssr
```

## Creating a New Environment Factory

A Vite dev server exposes two environments by default: a `client` environment and an `ssr` environment. The client environment is a browser environment by default, and the module runner is implemented by importing the virtual module `/@vite/client` to client apps. The SSR environment runs in the same Node runtime as the Vite server by default and allows application servers to be used to render requests during dev with full HMR support.

The transformed source code is called a module, and the relationships between the modules processed in each environment are kept in a module graph. The transformed code for these modules is sent to the runtimes associated with each environment to be executed. When a module is evaluated in the runtime, its imported modules will be requested triggering the processing of a section of the module graph.

A Vite Module Runner allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runner implementation is decoupled from the server. This allows library and framework authors to implement their layer of communication between the Vite server and the runner. The browser communicates with its corresponding environment using the server Web Socket and through HTTP requests. The Node Module runner can directly do function calls to process modules as it is running in the same process. Other environments could run modules connecting to a JS runtime like workerd, or a Worker Thread as Vitest does.

One of the goals of this feature is to provide a customizable API to process and run code. Users can create new environment factories using the exposed primitives.

```ts
import { DevEnvironment, HotChannel } from 'vite'

function createWorkerdDevEnvironment(
  name: string,
  config: ResolvedConfig,
  context: DevEnvironmentContext
) {
  const connection = /* ... */
  const transport: HotChannel = {
    on: (listener) => { connection.on('message', listener) },
    send: (data) => connection.send(data),
  }

  const workerdDevEnvironment = new DevEnvironment(name, config, {
    options: {
      resolve: { conditions: ['custom'] },
      ...context.options,
    },
    hot: true,
    transport,
  })
  return workerdDevEnvironment
}
```

There are [multiple communication levels for the `DevEnvironment`](/guide/api-environment-frameworks#devenvironment-communication-levels). To make it easier for frameworks to write runtime agnostic code, we recommend to implement the most flexible communication level possible.

## `ModuleRunner`

A module runner is instantiated in the target runtime. All APIs in the next section are imported from `vite/module-runner` unless stated otherwise. This export entry point is kept as lightweight as possible, only exporting the minimal needed to create module runners.

**Type Signature:**

```ts
export class ModuleRunner {
  constructor(
    public options: ModuleRunnerOptions,
    public evaluator: ModuleEvaluator = new ESModulesEvaluator(),
    private debug?: ModuleRunnerDebugger,
  ) {}
  /**
   * URL to execute.
   * Accepts file path, server path, or id relative to the root.
   */
  public async import<T = any>(url: string): Promise<T>
  /**
   * Clear all caches including HMR listeners.
   */
  public clearCache(): void
  /**
   * Clear all caches, remove all HMR listeners, reset sourcemap support.
   * This method doesn't stop the HMR connection.
   */
  public async close(): Promise<void>
  /**
   * Returns `true` if the runner has been closed by calling `close()`.
   */
  public isClosed(): boolean
}
```

The module evaluator in `ModuleRunner` is responsible for executing the code. Vite exports `ESModulesEvaluator` out of the box, it uses `new AsyncFunction` to evaluate the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.

Module runner exposes `import` method. When Vite server triggers `full-reload` HMR event, all affected modules will be re-executed. Be aware that Module Runner doesn't update `exports` object when this happens (it overrides it), you would need to run `import` or get the module from `evaluatedModules` again if you rely on having the latest `exports` object.

**Example Usage:**

```js
import {
  ModuleRunner,
  ESModulesEvaluator,
  createNodeImportMeta,
} from 'vite/module-runner'
import { transport } from './rpc-implementation.js'

const moduleRunner = new ModuleRunner(
  {
    transport,
    createImportMeta: createNodeImportMeta, // if the module runner runs in Node.js
  },
  new ESModulesEvaluator(),
)

await moduleRunner.import('/src/entry-point.js')
```

## `ModuleRunnerOptions`

```ts twoslash
import type {
  InterceptorOptions as InterceptorOptionsRaw,
  ModuleRunnerHmr as ModuleRunnerHmrRaw,
  EvaluatedModules,
} from 'vite/module-runner'
import type { Debug } from '@type-challenges/utils'

type InterceptorOptions = Debug<InterceptorOptionsRaw>
type ModuleRunnerHmr = Debug<ModuleRunnerHmrRaw>
/** see below */
type ModuleRunnerTransport = unknown

// ---cut---
interface ModuleRunnerOptions {
  /**
   * A set of methods to communicate with the server.
   */
  transport: ModuleRunnerTransport
  /**
   * Configure how source maps are resolved.
   * Prefers `node` if `process.setSourceMapsEnabled` is available.
   * Otherwise it will use `prepareStackTrace` by default which overrides
   * `Error.prepareStackTrace` method.
   * You can provide an object to configure how file contents and
   * source maps are resolved for files that were not processed by Vite.
   */
  sourcemapInterceptor?:
    | false
    | 'node'
    | 'prepareStackTrace'
    | InterceptorOptions
  /**
   * Disable HMR or configure HMR options.
   *
   * @default true
   */
  hmr?: boolean | ModuleRunnerHmr
  /**
   * Custom module cache. If not provided, it creates a separate module
   * cache for each module runner instance.
   */
  evaluatedModules?: EvaluatedModules
}
```

## `ModuleEvaluator`

**Type Signature:**

```ts twoslash
import type { ModuleRunnerContext as ModuleRunnerContextRaw } from 'vite/module-runner'
import type { Debug } from '@type-challenges/utils'

type ModuleRunnerContext = Debug<ModuleRunnerContextRaw>

// ---cut---
export interface ModuleEvaluator {
  /**
   * Number of prefixed lines in the transformed code.
   */
  startOffset?: number
  /**
   * Evaluate code that was transformed by Vite.
   * @param context Function context
   * @param code Transformed code
   * @param id ID that was used to fetch the module
   */
  runInlinedModule(
    context: ModuleRunnerContext,
    code: string,
    id: string,
  ): Promise<any>
  /**
   * evaluate externalized module.
   * @param file File URL to the external module
   */
  runExternalModule(file: string): Promise<any>
}
```

Vite exports `ESModulesEvaluator` that implements this interface by default. It uses `new AsyncFunction` to evaluate code, so if the code has inlined source map it should contain an [offset of 2 lines](https://tc39.es/ecma262/#sec-createdynamicfunction) to accommodate for new lines added. This is done automatically by the `ESModulesEvaluator`. Custom evaluators will not add additional lines.

## `ModuleRunnerTransport`

**Type Signature:**

```ts twoslash
import type { ModuleRunnerTransportHandlers } from 'vite/module-runner'
/** an object */
type HotPayload = unknown
// ---cut---
interface ModuleRunnerTransport {
  connect?(handlers: ModuleRunnerTransportHandlers): Promise<void> | void
  disconnect?(): Promise<void> | void
  send?(data: HotPayload): Promise<void> | void
  invoke?(data: HotPayload): Promise<{ result: any } | { error: any }>
  timeout?: number
}
```

Transport object that communicates with the environment via an RPC or by directly calling the function. When `invoke` method is not implemented, the `send` method and `connect` method is required to be implemented. Vite will construct the `invoke` internally.

You need to couple it with the `HotChannel` instance on the server like in this example where module runner is created in the worker thread:

::: code-group

```js [worker.js]
import { parentPort } from 'node:worker_threads'
import { fileURLToPath } from 'node:url'
import {
  ESModulesEvaluator,
  ModuleRunner,
  createNodeImportMeta,
} from 'vite/module-runner'

/** @type {import('vite/module-runner').ModuleRunnerTransport} */
const transport = {
  connect({ onMessage, onDisconnection }) {
    parentPort.on('message', onMessage)
    parentPort.on('close', onDisconnection)
  },
  send(data) {
    parentPort.postMessage(data)
  },
}

const runner = new ModuleRunner(
  {
    transport,
    createImportMeta: createNodeImportMeta,
  },
  new ESModulesEvaluator(),
)
```

```js [server.js]
import { BroadcastChannel } from 'node:worker_threads'
import { createServer, RemoteEnvironmentTransport, DevEnvironment } from 'vite'

function createWorkerEnvironment(name, config, context) {
  const worker = new Worker('./worker.js')
  const handlerToWorkerListener = new WeakMap()

  const workerHotChannel = {
    send: (data) => worker.postMessage(data),
    on: (event, handler) => {
      if (event === 'connection') return

      const listener = (value) => {
        if (value.type === 'custom' && value.event === event) {
          const client = {
            send(payload) {
              worker.postMessage(payload)
            },
          }
          handler(value.data, client)
        }
      }
      handlerToWorkerListener.set(handler, listener)
      worker.on('message', listener)
    },
    off: (event, handler) => {
      if (event === 'connection') return
      const listener = handlerToWorkerListener.get(handler)
      if (listener) {
        worker.off('message', listener)
        handlerToWorkerListener.delete(handler)
      }
    },
  }

  return new DevEnvironment(name, config, {
    transport: workerHotChannel,
  })
}

await createServer({
  environments: {
    worker: {
      dev: {
        createEnvironment: createWorkerEnvironment,
      },
    },
  },
})
```

:::

A different example using an HTTP request to communicate between the runner and the server:

```ts
import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'

export const runner = new ModuleRunner(
  {
    transport: {
      async invoke(data) {
        const response = await fetch(`http://my-vite-server/invoke`, {
          method: 'POST',
          body: JSON.stringify(data),
        })
        return response.json()
      },
    },
    hmr: false, // disable HMR as HMR requires transport.connect
  },
  new ESModulesEvaluator(),
)

await runner.import('/entry.js')
```

In this case, the `handleInvoke` method in the `NormalizedHotChannel` can be used:

```ts
const customEnvironment = new DevEnvironment(name, config, context)

server.onRequest((request: Request) => {
  const url = new URL(request.url)
  if (url.pathname === '/invoke') {
    const payload = (await request.json()) as HotPayload
    const result = customEnvironment.hot.handleInvoke(payload)
    return new Response(JSON.stringify(result))
  }
  return Response.error()
})
```

But note that for HMR support, `send` and `connect` methods are required. The `send` method is usually called when the custom event is triggered (like, `import.meta.hot.send("my-event")`).

Vite exports `createServerHotChannel` from the main entry point to support HMR during Vite SSR.



================================================
FILE: docs/guide/api-environment.md
================================================
# Environment API

:::info Release Candidate
The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that [some specific APIs](/changes/#considering) are still considered experimental.

We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.

Resources:

- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.
- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API were implemented and reviewed.

Please share your feedback with us.
:::

## Formalizing Environments

Vite 6 formalizes the concept of Environments. Until Vite 5, there were two implicit Environments (`client`, and optionally `ssr`). The new Environment API allows users and framework authors to create as many environments as needed to map the way their apps work in production. This new capability required a big internal refactoring, but a lot of effort has been placed on backward compatibility. The initial goal of Vite 6 is to move the ecosystem to the new major as smoothly as possible, delaying the adoption of the APIs until enough users have migrated and frameworks and plugin authors have validated the new design.

## Closing the Gap Between Build and Dev

For a simple SPA/MPA, no new APIs around environments are exposed to the config. Internally, Vite will apply the options to a `client` environment, but it's not necessary to know of this concept when configuring Vite. The config and behavior from Vite 5 should work seamlessly here.

When we move to a typical server-side rendered (SSR) app, we'll have two environments:

- `client`: runs the app in the browser.
- `ssr`: runs the app in node (or other server runtimes) which renders pages before sending them to the browser.

In dev, Vite executes the server code in the same Node process as the Vite dev server, giving a close approximation to the production environment. However, it is also possible for servers to run in other JS runtimes, like [Cloudflare's workerd](https://github.com/cloudflare/workerd) which have different constraints. Modern apps may also run in more than two environments, e.g. a browser, a node server, and an edge server. Vite 5 didn't allow to properly represent these environments.

Vite 6 allows users to configure their app during build and dev to map all of its environments. During dev, a single Vite dev server can now be used to run code in multiple different environments concurrently. The app source code is still transformed by Vite dev server. On top of the shared HTTP server, middlewares, resolved config, and plugins pipeline, the Vite dev server now has a set of independent dev environments. Each of them is configured to match the production environment as closely as possible, and is connected to a dev runtime where the code is executed (for workerd, the server code can now run in miniflare locally). In the client, the browser imports and executes the code. In other environments, a module runner fetches and evaluates the transformed code.

![Vite Environments](../images/vite-environments.svg)

## Environments Configuration

For an SPA/MPA, the configuration will look similar to Vite 5. Internally these options are used to configure the `client` environment.

```js
export default defineConfig({
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
})
```

This is important because we'd like to keep Vite approachable and avoid exposing new concepts until they are needed.

If the app is composed of several environments, then these environments can be configured explicitly with the `environments` config option.

```js
export default {
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
  environments: {
    server: {},
    edge: {
      resolve: {
        noExternal: true,
      },
    },
  },
}
```

When not explicitly documented, environment inherits the configured top-level config options (for example, the new `server` and `edge` environments will inherit the `build.sourcemap: false` option). A small number of top-level options, like `optimizeDeps`, only apply to the `client` environment, as they don't work well when applied as a default to server environments. Those options have <NonInheritBadge /> badge in [the reference](/config/). The `client` environment can also be configured explicitly through `environments.client`, but we recommend to do it with the top-level options so the client config remains unchanged when adding new environments.

The `EnvironmentOptions` interface exposes all the per-environment options. There are environment options that apply to both `build` and `dev`, like `resolve`. And there are `DevEnvironmentOptions` and `BuildEnvironmentOptions` for dev and build specific options (like `dev.warmup` or `build.outDir`). Some options like `optimizeDeps` only applies to dev, but is kept as top level instead of nested in `dev` for backward compatibility.

```ts
interface EnvironmentOptions {
  define?: Record<string, any>
  resolve?: EnvironmentResolveOptions
  optimizeDeps: DepOptimizationOptions
  consumer?: 'client' | 'server'
  dev: DevOptions
  build: BuildOptions
}
```

The `UserConfig` interface extends from the `EnvironmentOptions` interface, allowing to configure the client and defaults for other environments, configured through the `environments` option. The `client` and a server environment named `ssr` are always present during dev. This allows backward compatibility with `server.ssrLoadModule(url)` and `server.moduleGraph`. During build, the `client` environment is always present, and the `ssr` environment is only present if it is explicitly configured (using `environments.ssr` or for backward compatibility `build.ssr`). An app doesn't need to use the `ssr` name for its SSR environment, it could name it `server` for example.

```ts
interface UserConfig extends EnvironmentOptions {
  environments: Record<string, EnvironmentOptions>
  // other options
}
```

Note that the `ssr` top-level property is going to be deprecated once the Environment API is stable. This option has the same role as `environments`, but for the default `ssr` environment and only allowed configuring of a small set of options.

## Custom Environment Instances

Low level configuration APIs are available so runtime providers can provide environments with proper defaults for their runtimes. These environments can also spawn other processes or threads to run the modules during dev in a closer runtime to the production environment.

```js
import { customEnvironment } from 'vite-environment-provider'

export default {
  build: {
    outDir: '/dist/client',
  },
  environments: {
    ssr: customEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
  },
}
```

## Backward Compatibility

The current Vite server API is not yet deprecated and is backward compatible with Vite 5.

The `server.moduleGraph` returns a mixed view of the client and ssr module graphs. Backward compatible mixed module nodes will be returned from all its methods. The same scheme is used for the module nodes passed to `handleHotUpdate`.

We don't recommend switching to Environment API yet. We are aiming for a good portion of the user base to adopt Vite 6 before so plugins don't need to maintain two versions. Checkout the future breaking changes section for information on future deprecations and upgrade path:

- [`this.environment` in Hooks](/changes/this-environment-in-hooks)
- [HMR `hotUpdate` Plugin Hook](/changes/hotupdate-hook)
- [Move to Per-environment APIs](/changes/per-environment-apis)
- [SSR Using `ModuleRunner` API](/changes/ssr-using-modulerunner)
- [Shared Plugins During Build](/changes/shared-plugins-during-build)

## Target Users

This guide provides the basic concepts about environments for end users.

Plugin authors have a more consistent API available to interact with the current environment configuration. If you're building on top of Vite, the [Environment API Plugins Guide](./api-environment-plugins.md) guide describes the way extended plugin APIs available to support multiple custom environments.

Frameworks could decide to expose environments at different levels. If you're a framework author, continue reading the [Environment API Frameworks Guide](./api-environment-frameworks) to learn about the Environment API programmatic side.

For Runtime providers, the [Environment API Runtimes Guide](./api-environment-runtimes.md) explains how to offer custom environment to be consumed by frameworks and users.



================================================
FILE: docs/guide/api-hmr.md
================================================
# HMR API

:::tip Note
This is the client HMR API. For handling HMR update in plugins, see [handleHotUpdate](./api-plugin#handlehotupdate).

The manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.
:::

Vite exposes its manual HMR API via the special `import.meta.hot` object:

```ts twoslash
import type { ModuleNamespace } from 'vite/types/hot.d.ts'
import type {
  CustomEventName,
  InferCustomEventPayload,
} from 'vite/types/customEvent.d.ts'

// ---cut---
interface ImportMeta {
  readonly hot?: ViteHotContext
}

interface ViteHotContext {
  readonly data: any

  accept(): void
  accept(cb: (mod: ModuleNamespace | undefined) => void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept(
    deps: readonly string[],
    cb: (mods: Array<ModuleNamespace | undefined>) => void,
  ): void

  dispose(cb: (data: any) => void): void
  prune(cb: (data: any) => void): void
  invalidate(message?: string): void

  on<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  off<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  send<T extends CustomEventName>(
    event: T,
    data?: InferCustomEventPayload<T>,
  ): void
}
```

## Required Conditional Guard

First of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:

```js
if (import.meta.hot) {
  // HMR code
}
```

## IntelliSense for TypeScript

Vite provides type definitions for `import.meta.hot` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). You can create an `vite-env.d.ts` in the `src` directory so TypeScript picks up the type definitions:

```ts [vite-env.d.ts]
/// <reference types="vite/client" />
```

## `hot.accept(cb)`

For a module to self-accept, use `import.meta.hot.accept` with a callback which receives the updated module:

```js twoslash
import 'vite/client'
// ---cut---
export const count = 1

if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    if (newModule) {
      // newModule is undefined when SyntaxError happened
      console.log('updated: count is now ', newModule.count)
    }
  })
}
```

A module that "accepts" hot updates is considered an **HMR boundary**.

Vite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using `let`). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.

Vite requires that the call to this function appears as `import.meta.hot.accept(` (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.

## `hot.accept(deps, cb)`

A module can also accept updates from direct dependencies without reloading itself:

```js twoslash
// @filename: /foo.d.ts
export declare const foo: () => void

// @filename: /example.js
import 'vite/client'
// ---cut---
import { foo } from './foo.js'

foo()

if (import.meta.hot) {
  import.meta.hot.accept('./foo.js', (newFoo) => {
    // the callback receives the updated './foo.js' module
    newFoo?.foo()
  })

  // Can also accept an array of dep modules:
  import.meta.hot.accept(
    ['./foo.js', './bar.js'],
    ([newFooModule, newBarModule]) => {
      // The callback receives an array where only the updated module is
      // non null. If the update was not successful (syntax error for ex.),
      // the array is empty
    },
  )
}
```

## `hot.dispose(cb)`

A self-accepting module or a module that expects to be accepted by others can use `hot.dispose` to clean-up any persistent side effects created by its updated copy:

```js twoslash
import 'vite/client'
// ---cut---
function setupSideEffect() {}

setupSideEffect()

if (import.meta.hot) {
  import.meta.hot.dispose((data) => {
    // cleanup side effect
  })
}
```

## `hot.prune(cb)`

Register a callback that will call when the module is no longer imported on the page. Compared to `hot.dispose`, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for `.css` imports.

```js twoslash
import 'vite/client'
// ---cut---
function setupOrReuseSideEffect() {}

setupOrReuseSideEffect()

if (import.meta.hot) {
  import.meta.hot.prune((data) => {
    // cleanup side effect
  })
}
```

## `hot.data`

The `import.meta.hot.data` object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.

Note that re-assignment of `data` itself is not supported. Instead, you should mutate properties of the `data` object so information added from other handlers are preserved.

```js twoslash
import 'vite/client'
// ---cut---
// ok
import.meta.hot.data.someValue = 'hello'

// not supported
import.meta.hot.data = { someValue: 'hello' }
```

## `hot.decline()`

This is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use `hot.invalidate()`.

## `hot.invalidate(message?: string)`

A self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling `import.meta.hot.invalidate()`, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.

Note that you should always call `import.meta.hot.accept` even if you plan to call `invalidate` immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling `invalidate` within the `accept` callback like so:

```js twoslash
import 'vite/client'
// ---cut---
import.meta.hot.accept((module) => {
  // You may use the new module instance to decide whether to invalidate.
  if (cannotHandleUpdate(module)) {
    import.meta.hot.invalidate()
  }
})
```

## `hot.on(event, cb)`

Listen to an HMR event.

The following HMR events are dispatched by Vite automatically:

- `'vite:beforeUpdate'` when an update is about to be applied (e.g. a module will be replaced)
- `'vite:afterUpdate'` when an update has just been applied (e.g. a module has been replaced)
- `'vite:beforeFullReload'` when a full reload is about to occur
- `'vite:beforePrune'` when modules that are no longer needed are about to be pruned
- `'vite:invalidate'` when a module is invalidated with `import.meta.hot.invalidate()`
- `'vite:error'` when an error occurs (e.g. syntax error)
- `'vite:ws:disconnect'` when the WebSocket connection is lost
- `'vite:ws:connect'` when the WebSocket connection is (re-)established

Custom HMR events can also be sent from plugins. See [handleHotUpdate](./api-plugin#handlehotupdate) for more details.

## `hot.off(event, cb)`

Remove callback from the event listeners.

## `hot.send(event, data)`

Send custom events back to Vite's dev server.

If called before connected, the data will be buffered and sent once the connection is established.

See [Client-server Communication](/guide/api-plugin.html#client-server-communication) for more details, including a section on [Typing Custom Events](/guide/api-plugin.html#typescript-for-custom-events).

## Further Reading

If you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:

- [Hot Module Replacement is Easy](https://bjornlu.com/blog/hot-module-replacement-is-easy)



================================================
FILE: docs/guide/api-javascript.md
================================================
# JavaScript API

Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.

## `createServer`

**Type Signature:**

```ts
async function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>
```

**Example Usage:**

```ts twoslash
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

const server = await createServer({
  // any valid user config options, plus `mode` and `configFile`
  configFile: false,
  root: __dirname,
  server: {
    port: 1337,
  },
})
await server.listen()

server.printUrls()
server.bindCLIShortcuts({ print: true })
```

::: tip NOTE
When using `createServer` and `build` in the same Node.js process, both functions rely on `process.env.NODE_ENV` to work properly, which also depends on the `mode` config option. To prevent conflicting behavior, set `process.env.NODE_ENV` or the `mode` of the two APIs to `development`. Otherwise, you can spawn a child process to run the APIs separately.
:::

::: tip NOTE
When using [middleware mode](/config/server-options.html#server-middlewaremode) combined with [proxy config for WebSocket](/config/server-options.html#server-proxy), the parent http server should be provided in `middlewareMode` to bind the proxy correctly.

<details>
<summary>Example</summary>

```ts twoslash
import http from 'http'
import { createServer } from 'vite'

const parentServer = http.createServer() // or express, koa, etc.

const vite = await createServer({
  server: {
    // Enable middleware mode
    middlewareMode: {
      // Provide the parent http server for proxy WebSocket
      server: parentServer,
    },
    proxy: {
      '/ws': {
        target: 'ws://localhost:3000',
        // Proxying WebSocket
        ws: true,
      },
    },
  },
})

// @noErrors: 2339
parentServer.use(vite.middlewares)
```

</details>
:::

## `InlineConfig`

The `InlineConfig` interface extends `UserConfig` with additional properties:

- `configFile`: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to `false` to disable auto resolving.

## `ResolvedConfig`

The `ResolvedConfig` interface has all the same properties of a `UserConfig`, except most properties are resolved and non-undefined. It also contains utilities like:

- `config.assetsInclude`: A function to check if an `id` is considered an asset.
- `config.logger`: Vite's internal logger object.

## `ViteDevServer`

```ts
interface ViteDevServer {
  /**
   * The resolved Vite config object.
   */
  config: ResolvedConfig
  /**
   * A connect app instance
   * - Can be used to attach custom middlewares to the dev server.
   * - Can also be used as the handler function of a custom http server
   *   or as a middleware in any connect-style Node.js frameworks.
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * Native Node http server instance.
   * Will be null in middleware mode.
   */
  httpServer: http.Server | null
  /**
   * Chokidar watcher instance. If `config.server.watch` is set to `null`,
   * it will not watch any files and calling `add` or `unwatch` will have no effect.
   * https://github.com/paulmillr/chokidar/tree/3.6.0#api
   */
  watcher: FSWatcher
  /**
   * Web socket server with `send(payload)` method.
   */
  ws: WebSocketServer
  /**
   * Rollup plugin container that can run plugin hooks on a given file.
   */
  pluginContainer: PluginContainer
  /**
   * Module graph that tracks the import relationships, url to file mapping
   * and hmr state.
   */
  moduleGraph: ModuleGraph
  /**
   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`
   * in middleware mode or if the server is not listening on any port.
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * Programmatically resolve, load and transform a URL and get the result
   * without going through the http request pipeline.
   */
  transformRequest(
    url: string,
    options?: TransformOptions,
  ): Promise<TransformResult | null>
  /**
   * Apply Vite built-in HTML transforms and any plugin HTML transforms.
   */
  transformIndexHtml(
    url: string,
    html: string,
    originalUrl?: string,
  ): Promise<string>
  /**
   * Load a given URL as an instantiated module for SSR.
   */
  ssrLoadModule(
    url: string,
    options?: { fixStacktrace?: boolean },
  ): Promise<Record<string, any>>
  /**
   * Fix ssr error stacktrace.
   */
  ssrFixStacktrace(e: Error): void
  /**
   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
   */
  reloadModule(module: ModuleNode): Promise<void>
  /**
   * Start the server.
   */
  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
  /**
   * Restart the server.
   *
   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
   */
  restart(forceOptimize?: boolean): Promise<void>
  /**
   * Stop the server.
   */
  close(): Promise<void>
  /**
   * Bind CLI shortcuts
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
  /**
   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
   * are processed. If called from a load or transform plugin hook, the id needs to be
   * passed as a parameter to avoid deadlocks. Calling this function after the first
   * static imports section of the module graph has been processed will resolve immediately.
   * @experimental
   */
  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
}
```

:::info
`waitForRequestsIdle` is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting `optimizeDeps.crawlUntilStaticImports: false` by default to avoid the performance hit in large applications during cold start.
:::

## `build`

**Type Signature:**

```ts
async function build(
  inlineConfig?: InlineConfig,
): Promise<RollupOutput | RollupOutput[]>
```

**Example Usage:**

```ts twoslash [vite.config.js]
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { build } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

await build({
  root: path.resolve(__dirname, './project'),
  base: '/foo/',
  build: {
    rollupOptions: {
      // ...
    },
  },
})
```

## `preview`

**Type Signature:**

```ts
async function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>
```

**Example Usage:**

```ts twoslash
import { preview } from 'vite'

const previewServer = await preview({
  // any valid user config options, plus `mode` and `configFile`
  preview: {
    port: 8080,
    open: true,
  },
})

previewServer.printUrls()
previewServer.bindCLIShortcuts({ print: true })
```

## `PreviewServer`

```ts
interface PreviewServer {
  /**
   * The resolved vite config object
   */
  config: ResolvedConfig
  /**
   * A connect app instance.
   * - Can be used to attach custom middlewares to the preview server.
   * - Can also be used as the handler function of a custom http server
   *   or as a middleware in any connect-style Node.js frameworks
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * native Node http server instance
   */
  httpServer: http.Server
  /**
   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`
   * if the server is not listening on any port.
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * Print server urls
   */
  printUrls(): void
  /**
   * Bind CLI shortcuts
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void
}
```

## `resolveConfig`

**Type Signature:**

```ts
async function resolveConfig(
  inlineConfig: InlineConfig,
  command: 'build' | 'serve',
  defaultMode = 'development',
  defaultNodeEnv = 'development',
  isPreview = false,
): Promise<ResolvedConfig>
```

The `command` value is `serve` in dev and preview, and `build` in build.

## `mergeConfig`

**Type Signature:**

```ts
function mergeConfig(
  defaults: Record<string, any>,
  overrides: Record<string, any>,
  isRoot = true,
): Record<string, any>
```

Deeply merge two Vite configs. `isRoot` represents the level within the Vite config which is being merged. For example, set `false` if you're merging two `build` options.

::: tip NOTE
`mergeConfig` accepts only config in object form. If you have a config in callback form, you should call it before passing into `mergeConfig`.

You can use the `defineConfig` helper to merge a config in callback form with another config:

```ts twoslash
import {
  defineConfig,
  mergeConfig,
  type UserConfigFnObject,
  type UserConfig,
} from 'vite'
declare const configAsCallback: UserConfigFnObject
declare const configAsObject: UserConfig

// ---cut---
export default defineConfig((configEnv) =>
  mergeConfig(configAsCallback(configEnv), configAsObject),
)
```

:::

## `searchForWorkspaceRoot`

**Type Signature:**

```ts
function searchForWorkspaceRoot(
  current: string,
  root = searchForPackageRoot(current),
): string
```

**Related:** [server.fs.allow](/config/server-options.md#server-fs-allow)

Search for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to `root`:

- contains `workspaces` field in `package.json`
- contains one of the following file
  - `lerna.json`
  - `pnpm-workspace.yaml`

## `loadEnv`

**Type Signature:**

```ts
function loadEnv(
  mode: string,
  envDir: string,
  prefixes: string | string[] = 'VITE_',
): Record<string, string>
```

**Related:** [`.env` Files](./env-and-mode.md#env-files)

Load `.env` files within the `envDir`. By default, only env variables prefixed with `VITE_` are loaded, unless `prefixes` is changed.

## `normalizePath`

**Type Signature:**

```ts
function normalizePath(id: string): string
```

**Related:** [Path Normalization](./api-plugin.md#path-normalization)

Normalizes a path to interoperate between Vite plugins.

## `transformWithEsbuild`

**Type Signature:**

```ts
async function transformWithEsbuild(
  code: string,
  filename: string,
  options?: EsbuildTransformOptions,
  inMap?: object,
): Promise<ESBuildTransformResult>
```

Transform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.

## `loadConfigFromFile`

**Type Signature:**

```ts
async function loadConfigFromFile(
  configEnv: ConfigEnv,
  configFile?: string,
  configRoot: string = process.cwd(),
  logLevel?: LogLevel,
  customLogger?: Logger,
): Promise<{
  path: string
  config: UserConfig
  dependencies: string[]
} | null>
```

Load a Vite config file manually with esbuild.

## `preprocessCSS`

- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13815)

**Type Signature:**

```ts
async function preprocessCSS(
  code: string,
  filename: string,
  config: ResolvedConfig,
): Promise<PreprocessCSSResult>

interface PreprocessCSSResult {
  code: string
  map?: SourceMapInput
  modules?: Record<string, string>
  deps?: Set<string>
}
```

Pre-processes `.css`, `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the [built-in CSS pre-processing support](/guide/features#css-pre-processors), the corresponding pre-processor must be installed if used.

The pre-processor used is inferred from the `filename` extension. If the `filename` ends with `.module.{ext}`, it is inferred as a [CSS module](https://github.com/css-modules/css-modules) and the returned result will include a `modules` object mapping the original class names to the transformed ones.

Note that pre-processing will not resolve URLs in `url()` or `image-set()`.



================================================
FILE: docs/guide/api-plugin.md
================================================
# Plugin API

Vite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.

**It is recommended to go through [Rollup's plugin documentation](https://rollupjs.org/plugin-development/) first before reading the sections below.**

## Authoring a Plugin

Vite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the [Features guide](https://vite.dev/guide/features) to see if your need is covered. Also review available community plugins, both in the form of a [compatible Rollup plugin](https://github.com/rollup/awesome) and [Vite Specific plugins](https://github.com/vitejs/awesome-vite#plugins)

When creating a plugin, you can inline it in your `vite.config.js`. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others [in the ecosystem](https://chat.vite.dev).

::: tip
When learning, debugging, or authoring plugins, we suggest including [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit `localhost:5173/__inspect/` to inspect the modules and transformation stack of your project. Check out install instructions in the [vite-plugin-inspect docs](https://github.com/antfu/vite-plugin-inspect).
![vite-plugin-inspect](../images/vite-plugin-inspect.webp)
:::

## Conventions

If the plugin doesn't use Vite specific hooks and can be implemented as a [Compatible Rollup Plugin](#rollup-plugin-compatibility), then it is recommended to use the [Rollup Plugin naming conventions](https://rollupjs.org/plugin-development/#conventions).

- Rollup Plugins should have a clear name with `rollup-plugin-` prefix.
- Include `rollup-plugin` and `vite-plugin` keywords in package.json.

This exposes the plugin to be also used in pure Rollup or WMR based projects

For Vite only plugins

- Vite Plugins should have a clear name with `vite-plugin-` prefix.
- Include `vite-plugin` keyword in package.json.
- Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).

If your plugin is only going to work for a particular framework, its name should be included as part of the prefix

- `vite-plugin-vue-` prefix for Vue Plugins
- `vite-plugin-react-` prefix for React Plugins
- `vite-plugin-svelte-` prefix for Svelte Plugins

See also [Virtual Modules Convention](#virtual-modules-convention).

## Plugins Config

Users will add plugins to the project `devDependencies` and configure them using the `plugins` array option.

```js [vite.config.js]
import vitePlugin from 'vite-plugin-feature'
import rollupPlugin from 'rollup-plugin-feature'

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()],
})
```

Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.

`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.

```js
// framework-plugin
import frameworkRefresh from 'vite-plugin-framework-refresh'
import frameworkDevtools from 'vite-plugin-framework-devtools'

export default function framework(config) {
  return [frameworkRefresh(config), frameworkDevTools(config)]
}
```

```js [vite.config.js]
import { defineConfig } from 'vite'
import framework from 'vite-plugin-framework'

export default defineConfig({
  plugins: [framework()],
})
```

## Simple Examples

:::tip
It is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.
:::

### Transforming Custom File Types

```js
const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: 'transform-file',

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null, // provide source map if available
        }
      }
    },
  }
}
```

### Importing a Virtual File

See the example in the [next section](#virtual-modules-convention).

## Virtual Modules Convention

Virtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.

```js
export default function myPlugin() {
  const virtualModuleId = 'virtual:my-module'
  const resolvedVirtualModuleId = '\0' + virtualModuleId

  return {
    name: 'my-plugin', // required, will show up in warnings and errors
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId
      }
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `export const msg = "from virtual module"`
      }
    },
  }
}
```

Which allows importing the module in JavaScript:

```js
import { msg } from 'virtual:my-module'

console.log(msg)
```

Virtual modules in Vite (and Rollup) are prefixed with `virtual:` for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a `vite-plugin-posts` could ask users to import a `virtual:posts` or `virtual:posts/helpers` virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with `\0` while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. `\0` is not a permitted char in import URLs so we have to replace them during import analysis. A `\0{id}` virtual id ends up encoded as `/@id/__x00__{id}` during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.

Note that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using `\0` for these submodules would prevent sourcemaps from working correctly.

## Universal Hooks

During dev, the Vite dev server creates a plugin container that invokes [Rollup Build Hooks](https://rollupjs.org/plugin-development/#build-hooks) the same way Rollup does it.

The following hooks are called once on server start:

- [`options`](https://rollupjs.org/plugin-development/#options)
- [`buildStart`](https://rollupjs.org/plugin-development/#buildstart)

The following hooks are called on each incoming module request:

- [`resolveId`](https://rollupjs.org/plugin-development/#resolveid)
- [`load`](https://rollupjs.org/plugin-development/#load)
- [`transform`](https://rollupjs.org/plugin-development/#transform)

These hooks also have an extended `options` parameter with additional Vite-specific properties. You can read more in the [SSR documentation](/guide/ssr#ssr-specific-plugin-logic).

Some `resolveId` calls' `importer` value may be an absolute path for a generic `index.html` at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct `importer` value.

The following hooks are called when the server is closed:

- [`buildEnd`](https://rollupjs.org/plugin-development/#buildend)
- [`closeBundle`](https://rollupjs.org/plugin-development/#closebundle)

Note that the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook is **not** called during dev, because Vite avoids full AST parses for better performance.

[Output Generation Hooks](https://rollupjs.org/plugin-development/#output-generation-hooks) (except `closeBundle`) are **not** called during dev. You can think of Vite's dev server as only calling `rollup.rollup()` without calling `bundle.generate()`.

## Vite Specific Hooks

Vite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.

### `config`

- **Type:** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`
- **Kind:** `async`, `sequential`

  Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the `mode` and `command` being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).

  **Example:**

  ```js
  // return partial config (recommended)
  const partialConfigPlugin = () => ({
    name: 'return-partial',
    config: () => ({
      resolve: {
        alias: {
          foo: 'bar',
        },
      },
    }),
  })

  // mutate the config directly (use only when merging doesn't work)
  const mutateConfigPlugin = () => ({
    name: 'mutate-config',
    config(config, { command }) {
      if (command === 'build') {
        config.root = 'foo'
      }
    },
  })
  ```

  ::: warning Note
  User plugins are resolved before running this hook so injecting other plugins inside the `config` hook will have no effect.
  :::

### `configResolved`

- **Type:** `(config: ResolvedConfig) => void | Promise<void>`
- **Kind:** `async`, `parallel`

  Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.

  **Example:**

  ```js
  const examplePlugin = () => {
    let config

    return {
      name: 'read-config',

      configResolved(resolvedConfig) {
        // store the resolved config
        config = resolvedConfig
      },

      // use stored config in other hooks
      transform(code, id) {
        if (config.command === 'serve') {
          // dev: plugin invoked by dev server
        } else {
          // build: plugin invoked by Rollup
        }
      },
    }
  }
  ```

  Note that the `command` value is `serve` in dev (in the cli `vite`, `vite dev`, and `vite serve` are aliases).

### `configureServer`

- **Type:** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`
- **Kind:** `async`, `sequential`
- **See also:** [ViteDevServer](./api-javascript#vitedevserver)

  Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app:

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        // custom handle request...
      })
    },
  })
  ```

  **Injecting Post Middleware**

  The `configureServer` hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware **after** internal middlewares, you can return a function from `configureServer`, which will be called after internal middlewares are installed:

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      // return a post hook that is called after internal middlewares are
      // installed
      return () => {
        server.middlewares.use((req, res, next) => {
          // custom handle request...
        })
      }
    },
  })
  ```

  **Storing Server Access**

  In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:

  ```js
  const myPlugin = () => {
    let server
    return {
      name: 'configure-server',
      configureServer(_server) {
        server = _server
      },
      transform(code, id) {
        if (server) {
          // use server...
        }
      },
    }
  }
  ```

  Note `configureServer` is not called when running the production build so your other hooks need to guard against its absence.

### `configurePreviewServer`

- **Type:** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`
- **Kind:** `async`, `sequential`
- **See also:** [PreviewServer](./api-javascript#previewserver)

  Same as [`configureServer`](/guide/api-plugin.html#configureserver) but for the preview server. Similarly to `configureServer`, the `configurePreviewServer` hook is called before other middlewares are installed. If you want to inject a middleware **after** other middlewares, you can return a function from `configurePreviewServer`, which will be called after internal middlewares are installed:

  ```js
  const myPlugin = () => ({
    name: 'configure-preview-server',
    configurePreviewServer(server) {
      // return a post hook that is called after other middlewares are
      // installed
      return () => {
        server.middlewares.use((req, res, next) => {
          // custom handle request...
        })
      }
    },
  })
  ```

### `transformIndexHtml`

- **Type:** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`
- **Kind:** `async`, `sequential`

  Dedicated hook for transforming HTML entry point files such as `index.html`. The hook receives the current HTML string and a transform context. The context exposes the [`ViteDevServer`](./api-javascript#vitedevserver) instance during dev, and exposes the Rollup output bundle during build.

  The hook can be async and can return one of the following:
  - Transformed HTML string
  - An array of tag descriptor objects (`{ tag, attrs, children }`) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to `<head>`)
  - An object containing both as `{ html, tags }`

  By default `order` is `undefined`, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, `order: 'pre'` will apply the hook before processing the HTML. `order: 'post'` applies the hook after all hooks with `order` undefined are applied.

  **Basic Example:**

  ```js
  const htmlPlugin = () => {
    return {
      name: 'html-transform',
      transformIndexHtml(html) {
        return html.replace(
          /<title>(.*?)<\/title>/,
          `<title>Title replaced!</title>`,
        )
      },
    }
  }
  ```

  **Full Hook Signature:**

  ```ts
  type IndexHtmlTransformHook = (
    html: string,
    ctx: {
      path: string
      filename: string
      server?: ViteDevServer
      bundle?: import('rollup').OutputBundle
      chunk?: import('rollup').OutputChunk
    },
  ) =>
    | IndexHtmlTransformResult
    | void
    | Promise<IndexHtmlTransformResult | void>

  type IndexHtmlTransformResult =
    | string
    | HtmlTagDescriptor[]
    | {
        html: string
        tags: HtmlTagDescriptor[]
      }

  interface HtmlTagDescriptor {
    tag: string
    attrs?: Record<string, string | boolean>
    children?: string | HtmlTagDescriptor[]
    /**
     * default: 'head-prepend'
     */
    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'
  }
  ```

  ::: warning Note
  This hook won't be called if you are using a framework that has custom handling of entry files (for example [SvelteKit](https://github.com/sveltejs/kit/discussions/8269#discussioncomment-4509145)).
  :::

### `handleHotUpdate`

- **Type:** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`
- **See also:** [HMR API](./api-hmr)

  Perform custom HMR update handling. The hook receives a context object with the following signature:

  ```ts
  interface HmrContext {
    file: string
    timestamp: number
    modules: Array<ModuleNode>
    read: () => string | Promise<string>
    server: ViteDevServer
  }
  ```

  - `modules` is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).

  - `read` is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.

  The hook can choose to:
  - Filter and narrow down the affected module list so that the HMR is more accurate.

  - Return an empty array and perform a full reload:

    ```js
    handleHotUpdate({ server, modules, timestamp }) {
      // Invalidate modules manually
      const invalidatedModules = new Set()
      for (const mod of modules) {
        server.moduleGraph.invalidateModule(
          mod,
          invalidatedModules,
          timestamp,
          true
        )
      }
      server.ws.send({ type: 'full-reload' })
      return []
    }
    ```

  - Return an empty array and perform complete custom HMR handling by sending custom events to the client:

    ```js
    handleHotUpdate({ server }) {
      server.ws.send({
        type: 'custom',
        event: 'special-update',
        data: {}
      })
      return []
    }
    ```

    Client code should register corresponding handler using the [HMR API](./api-hmr) (this could be injected by the same plugin's `transform` hook):

    ```js
    if (import.meta.hot) {
      import.meta.hot.on('special-update', (data) => {
        // perform custom update
      })
    }
    ```

## Plugin Ordering

A Vite plugin can additionally specify an `enforce` property (similar to webpack loaders) to adjust its application order. The value of `enforce` can be either `"pre"` or `"post"`. The resolved plugins will be in the following order:

- Alias
- User plugins with `enforce: 'pre'`
- Vite core plugins
- User plugins without enforce value
- Vite build plugins
- User plugins with `enforce: 'post'`
- Vite post build plugins (minify, manifest, reporting)

Note that this is separate from hooks ordering, those are still separately subject to their `order` attribute [as usual for Rollup hooks](https://rollupjs.org/plugin-development/#build-hooks).

## Conditional Application

By default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:

```js
function myPlugin() {
  return {
    name: 'build-only',
    apply: 'build', // or 'serve'
  }
}
```

A function can also be used for more precise control:

```js
apply(config, { command }) {
  // apply only on build but not for SSR
  return command === 'build' && !config.build.ssr
}
```

## Rollup Plugin Compatibility

A fair number of Rollup plugins will work directly as a Vite plugin (e.g. `@rollup/plugin-alias` or `@rollup/plugin-json`), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.

In general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:

- It doesn't use the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook.
- It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.

If a Rollup plugin only makes sense for the build phase, then it can be specified under `build.rollupOptions.plugins` instead. It will work the same as a Vite plugin with `enforce: 'post'` and `apply: 'build'`.

You can also augment an existing Rollup plugin with Vite-only properties:

```js [vite.config.js]
import example from 'rollup-plugin-example'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...example(),
      enforce: 'post',
      apply: 'build',
    },
  ],
})
```

## Path Normalization

Vite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\ ) in Windows. However, Rollup plugins use a [`normalizePath` utility function](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath) from `@rollup/pluginutils` internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the `include` and `exclude` config pattern and other similar paths against resolved ids comparisons work correctly.

So, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent `normalizePath` utility function is exported from the `vite` module.

```js
import { normalizePath } from 'vite'

normalizePath('foo\\bar') // 'foo/bar'
normalizePath('foo/bar') // 'foo/bar'
```

## Filtering, include/exclude pattern

Vite exposes [`@rollup/pluginutils`'s `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.

## Client-server Communication

Since Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.

### Server to Client

On the plugin side, we could use `server.ws.send` to broadcast events to the client:

```js [vite.config.js]
export default defineConfig({
  plugins: [
    {
      // ...
      configureServer(server) {
        server.ws.on('connection', () => {
          server.ws.send('my:greetings', { msg: 'hello' })
        })
      },
    },
  ],
})
```

::: tip NOTE
We recommend **always prefixing** your event names to avoid collisions with other plugins.
:::

On the client side, use [`hot.on`](/guide/api-hmr.html#hot-on-event-cb) to listen to the events:

```ts twoslash
import 'vite/client'
// ---cut---
// client side
if (import.meta.hot) {
  import.meta.hot.on('my:greetings', (data) => {
    console.log(data.msg) // hello
  })
}
```

### Client to Server

To send events from the client to the server, we can use [`hot.send`](/guide/api-hmr.html#hot-send-event-payload):

```ts
// client side
if (import.meta.hot) {
  import.meta.hot.send('my:from-client', { msg: 'Hey!' })
}
```

Then use `server.ws.on` and listen to the events on the server side:

```js [vite.config.js]
export default defineConfig({
  plugins: [
    {
      // ...
      configureServer(server) {
        server.ws.on('my:from-client', (data, client) => {
          console.log('Message from client:', data.msg) // Hey!
          // reply only to the client (if needed)
          client.send('my:ack', { msg: 'Hi! I got your message!' })
        })
      },
    },
  ],
})
```

### TypeScript for Custom Events

Internally, vite infers the type of a payload from the `CustomEventMap` interface, it is possible to type custom events by extending the interface:

:::tip Note
Make sure to include the `.d.ts` extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.
:::

```ts [events.d.ts]
import 'vite/types/customEvent.d.ts'

declare module 'vite/types/customEvent.d.ts' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
    // 'event-key': payload
  }
}
```

This interface extension is utilized by `InferCustomEventPayload<T>` to infer the payload type for event `T`. For more information on how this interface is utilized, refer to the [HMR API Documentation](./api-hmr#hmr-api).

```ts twoslash
import 'vite/client'
import type { InferCustomEventPayload } from 'vite/types/customEvent.d.ts'
declare module 'vite/types/customEvent.d.ts' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
  }
}
// ---cut---
type CustomFooPayload = InferCustomEventPayload<'custom:foo'>
import.meta.hot?.on('custom:foo', (payload) => {
  // The type of payload will be { msg: string }
})
import.meta.hot?.on('unknown:event', (payload) => {
  // The type of payload will be any
})
```



================================================
FILE: docs/guide/assets.md
================================================
# Static Asset Handling

- Related: [Public Base Path](./build#public-base-path)
- Related: [`assetsInclude` config option](/config/shared-options.md#assetsinclude)

## Importing Asset as URL

Importing a static asset will return the resolved public URL when it is served:

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

For example, `imgUrl` will be `/src/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.

The behavior is similar to webpack's `file-loader`. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.

- `url()` references in CSS are handled the same way.

- If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.

- Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the [`assetsInclude` option](/config/shared-options.md#assetsinclude).

- Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.

- Assets smaller in bytes than the [`assetsInlineLimit` option](/config/build-options.md#build-assetsinlinelimit) will be inlined as base64 data URLs.

- Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.

- TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include [`vite/client`](./features#client-types).

::: tip Inlining SVGs through `url()`
When passing a URL of SVG to a manually constructed `url()` by JS, the variable should be wrapped within double quotes.

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.svg'
document.getElementById('hero-img').style.background = `url("${imgUrl}")`
```

:::

### Explicit URL Imports

Assets that are not included in the internal list or in `assetsInclude`, can be explicitly imported as a URL using the `?url` suffix. This is useful, for example, to import [Houdini Paint Worklets](https://developer.mozilla.org/en-US/docs/Web/API/CSS/paintWorklet_static).

```js twoslash
import 'vite/client'
// ---cut---
import workletURL from 'extra-scalloped-border/worklet.js?url'
CSS.paintWorklet.addModule(workletURL)
```

### Explicit Inline Handling

Assets can be explicitly imported with inlining or no inlining using the `?inline` or `?no-inline` suffix respectively.

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl1 from './img.svg?no-inline'
import imgUrl2 from './img.png?inline'
```

### Importing Asset as String

Assets can be imported as strings using the `?raw` suffix.

```js twoslash
import 'vite/client'
// ---cut---
import shaderString from './shader.glsl?raw'
```

### Importing Script as a Worker

Scripts can be imported as web workers with the `?worker` or `?sharedworker` suffix.

```js twoslash
import 'vite/client'
// ---cut---
// Separate chunk in the production build
import Worker from './shader.js?worker'
const worker = new Worker()
```

```js twoslash
import 'vite/client'
// ---cut---
// sharedworker
import SharedWorker from './shader.js?sharedworker'
const sharedWorker = new SharedWorker()
```

```js twoslash
import 'vite/client'
// ---cut---
// Inlined as base64 strings
import InlineWorker from './shader.js?worker&inline'
```

Check out the [Web Worker section](./features.md#web-workers) for more details.

## The `public` Directory

If you have assets that are:

- Never referenced in source code (e.g. `robots.txt`)
- Must retain the exact same file name (without hashing)
- ...or you simply don't want to have to import an asset first just to get its URL

Then you can place the asset in a special `public` directory under your project root. Assets in this directory will be served at root path `/` during dev, and copied to the root of the dist directory as-is.

The directory defaults to `<root>/public`, but can be configured via the [`publicDir` option](/config/shared-options.md#publicdir).

Note that you should always reference `public` assets using root absolute path - for example, `public/icon.png` should be referenced in source code as `/icon.png`.

## new URL(url, import.meta.url)

[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) is a native ESM feature that exposes the current module's URL. Combining it with the native [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL), we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:

```js
const imgUrl = new URL('./img.png', import.meta.url).href

document.getElementById('hero-img').src = imgUrl
```

This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!

This pattern also supports dynamic URLs via template literals:

```js
function getImageUrl(name) {
  // note that this does not include files in subdirectories
  return new URL(`./dir/${name}.png`, import.meta.url).href
}
```

During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if `build.target` does not support `import.meta.url`

```js
// Vite will not transform this
const imgUrl = new URL(imagePath, import.meta.url).href
```

::: details How it works

Vite will transform the `getImageUrl` function to:

```js
import __img0png from './dir/img0.png'
import __img1png from './dir/img1.png'

function getImageUrl(name) {
  const modules = {
    './dir/img0.png': __img0png,
    './dir/img1.png': __img1png,
  }
  return new URL(modules[`./dir/${name}.png`], import.meta.url).href
}
```

:::

::: warning Does not work with SSR
This pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.
:::



================================================
FILE: docs/guide/backend-integration.md
================================================
# Backend Integration

:::tip Note
If you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in [Awesome Vite](https://github.com/vitejs/awesome-vite#integrations-with-backends).

If you need a custom integration, you can follow the steps in this guide to configure it manually
:::

1. In your Vite config, configure the entry and enable build manifest:

   ```js twoslash [vite.config.js]
   import { defineConfig } from 'vite'
   // ---cut---
   export default defineConfig({
     server: {
       cors: {
         // the origin you will be accessing via browser
         origin: 'http://my-backend.example.com',
       },
     },
     build: {
       // generate .vite/manifest.json in outDir
       manifest: true,
       rollupOptions: {
         // overwrite default .html entry
         input: '/path/to/main.js',
       },
     },
   })
   ```

   If you haven't disabled the [module preload polyfill](/config/build-options.md#build-polyfillmodulepreload), you also need to import the polyfill in your entry

   ```js
   // add the beginning of your app entry
   import 'vite/modulepreload-polyfill'
   ```

2. For development, inject the following in your server's HTML template (substitute `http://localhost:5173` with the local URL Vite is running at):

   ```html
   <!-- if development -->
   <script type="module" src="http://localhost:5173/@vite/client"></script>
   <script type="module" src="http://localhost:5173/main.js"></script>
   ```

   In order to properly serve assets, you have two options:
   - Make sure the server is configured to proxy static assets requests to the Vite server
   - Set [`server.origin`](/config/server-options.md#server-origin) so that generated asset URLs will be resolved using the back-end server URL instead of a relative path

   This is needed for assets such as images to load properly.

   Note if you are using React with `@vitejs/plugin-react`, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute `http://localhost:5173` with the local URL Vite is running at):

   ```html
   <script type="module">
     import RefreshRuntime from 'http://localhost:5173/@react-refresh'
     RefreshRuntime.injectIntoGlobalHook(window)
     window.$RefreshReg$ = () => {}
     window.$RefreshSig$ = () => (type) => type
     window.__vite_plugin_react_preamble_installed__ = true
   </script>
   ```

3. For production: after running `vite build`, a `.vite/manifest.json` file will be generated alongside other asset files. An example manifest file looks like this:

   ```json [.vite/manifest.json]
   {
     "_shared-B7PI925R.js": {
       "file": "assets/shared-B7PI925R.js",
       "name": "shared",
       "css": ["assets/shared-ChJ_j-JJ.css"]
     },
     "_shared-ChJ_j-JJ.css": {
       "file": "assets/shared-ChJ_j-JJ.css",
       "src": "_shared-ChJ_j-JJ.css"
     },
     "logo.svg": {
       "file": "assets/logo-BuPIv-2h.svg",
       "src": "logo.svg"
     },
     "baz.js": {
       "file": "assets/baz-B2H3sXNv.js",
       "name": "baz",
       "src": "baz.js",
       "isDynamicEntry": true
     },
     "views/bar.js": {
       "file": "assets/bar-gkvgaI9m.js",
       "name": "bar",
       "src": "views/bar.js",
       "isEntry": true,
       "imports": ["_shared-B7PI925R.js"],
       "dynamicImports": ["baz.js"]
     },
     "views/foo.js": {
       "file": "assets/foo-BRBmoGS9.js",
       "name": "foo",
       "src": "views/foo.js",
       "isEntry": true,
       "imports": ["_shared-B7PI925R.js"],
       "css": ["assets/foo-5UjPuW-k.css"]
     }
   }
   ```

   The manifest has a `Record<name, chunk>` structure where each chunk follows the `ManifestChunk` interface:

   ```ts
   interface ManifestChunk {
     src?: string
     file: string
     css?: string[]
     assets?: string[]
     isEntry?: boolean
     name?: string
     names?: string[]
     isDynamicEntry?: boolean
     imports?: string[]
     dynamicImports?: string[]
   }
   ```

   Each entry in the manifest represents one of the following:
   - **Entry chunks**: Generated from files specified in [`build.rollupOptions.input`](https://rollupjs.org/configuration-options/#input). These chunks have `isEntry: true` and their key is the relative src path from project root.
   - **Dynamic entry chunks**: Generated from dynamic imports. These chunks have `isDynamicEntry: true` and their key is the relative src path from project root.
   - **Non-entry chunks**: Their key is the base name of the generated file prefixed with `_`.
   - **Asset chunks**: Generated from imported assets like images, fonts. Their key is the relative src path from project root.
   - **CSS files**: When [`build.cssCodeSplit`](/config/build-options.md#build-csscodesplit) is `false`, a single CSS file is generated with the key `style.css`. When `build.cssCodeSplit` is not `false`, the key is generated similar to JS chunks (i.e. entry chunks will not have `_` prefix and non-entry chunks will have `_` prefix).

   Chunks will contain information on their static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also their corresponding CSS and asset files (if any).

4. You can use this file to render links or preload directives with hashed filenames.

   Here is an example HTML template to render the proper links. The syntax here is for
   explanation only, substitute with your server templating language. The `importedChunks`
   function is for illustration and isn't provided by Vite.

   ```html
   <!-- if production -->

   <!-- for cssFile of manifest[name].css -->
   <link rel="stylesheet" href="/{{ cssFile }}" />

   <!-- for chunk of importedChunks(manifest, name) -->
   <!-- for cssFile of chunk.css -->
   <link rel="stylesheet" href="/{{ cssFile }}" />

   <script type="module" src="/{{ manifest[name].file }}"></script>

   <!-- for chunk of importedChunks(manifest, name) -->
   <link rel="modulepreload" href="/{{ chunk.file }}" />
   ```

   Specifically, a backend generating HTML should include the following tags given a manifest
   file and an entry point. Note that following this order is recommended for optimal performance:
   1. A `<link rel="stylesheet">` tag for each file in the entry point chunk's `css` list (if it exists)
   2. Recursively follow all chunks in the entry point's `imports` list and include a
      `<link rel="stylesheet">` tag for each CSS file of each imported chunk's `css` list (if it exists).
   3. A tag for the `file` key of the entry point chunk. This can be `<script type="module">` for JavaScript, `<link rel="stylesheet">` for CSS.
   4. Optionally, `<link rel="modulepreload">` tag for the `file` of each imported JavaScript
      chunk, again recursively following the imports starting from the entry point chunk.

   Following the above example manifest, for the entry point `views/foo.js` the following tags should be included in production:

   ```html
   <link rel="stylesheet" href="assets/foo-5UjPuW-k.css" />
   <link rel="stylesheet" href="assets/shared-ChJ_j-JJ.css" />
   <script type="module" src="assets/foo-BRBmoGS9.js"></script>
   <!-- optional -->
   <link rel="modulepreload" href="assets/shared-B7PI925R.js" />
   ```

   While the following should be included for the entry point `views/bar.js`:

   ```html
   <link rel="stylesheet" href="assets/shared-ChJ_j-JJ.css" />
   <script type="module" src="assets/bar-gkvgaI9m.js"></script>
   <!-- optional -->
   <link rel="modulepreload" href="assets/shared-B7PI925R.js" />
   ```

   ::: details Pseudo implementation of `importedChunks`
   An example pseudo implementation of `importedChunks` in TypeScript (This will
   need to be adapted for your programming language and templating language):

   ```ts
   import type { Manifest, ManifestChunk } from 'vite'

   export default function importedChunks(
     manifest: Manifest,
     name: string,
   ): ManifestChunk[] {
     const seen = new Set<string>()

     function getImportedChunks(chunk: ManifestChunk): ManifestChunk[] {
       const chunks: ManifestChunk[] = []
       for (const file of chunk.imports ?? []) {
         const importee = manifest[file]
         if (seen.has(file)) {
           continue
         }
         seen.add(file)

         chunks.push(...getImportedChunks(importee))
         chunks.push(importee)
       }

       return chunks
     }

     return getImportedChunks(manifest[name])
   }
   ```

   :::



================================================
FILE: docs/guide/build.md
================================================
# Building for Production

When it is time to deploy your app for production, simply run the `vite build` command. By default, it uses `<root>/index.html` as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the [Deploying a Static Site](./static-deploy) for guides about popular services.

## Browser Compatibility

By default, the production bundle assumes a modern browser that is included in the [Baseline](https://web-platform-dx.github.io/web-features/) Widely Available targets. The default browser support range is:

<!-- Search for the `ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET` constant for more information -->

- Chrome >=107
- Edge >=107
- Firefox >=104
- Safari >=16

You can specify custom targets via the [`build.target` config option](/config/build-options.md#build-target), where the lowest target is `es2015`. If a lower target is set, Vite will still require these minimum browser support ranges as it relies on [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta):

<!-- Search for the `defaultEsbuildSupported` constant for more information -->

- Chrome >=64
- Firefox >=67
- Safari >=11.1
- Edge >=79

Note that by default, Vite only handles syntax transforms and **does not cover polyfills**. You can check out https://cdnjs.cloudflare.com/polyfill/ which automatically generates polyfill bundles based on the user's browser UserAgent string.

Legacy browsers can be supported via [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy), which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.

## Public Base Path

- Related: [Asset Handling](./assets)

If you are deploying your project under a nested public path, simply specify the [`base` config option](/config/shared-options.md#base) and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. `vite build --base=/my/public/path/`.

JS-imported asset URLs, CSS `url()` references, and asset references in your `.html` files are all automatically adjusted to respect this option during build.

The exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected `import.meta.env.BASE_URL` variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. `import.meta.env['BASE_URL']` won't work).

For advanced base path control, check out [Advanced Base Options](#advanced-base-options).

### Relative base

If you don't know the base path in advance, you may set a relative base path with `"base": "./"` or `"base": ""`. This will make all generated URLs to be relative to each file.

:::warning Support for older browsers when using relative bases

`import.meta` support is required for relative bases. If you need to support [browsers that do not support `import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta), you can use [the `legacy` plugin](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy).

:::

## Customizing the Build

The build can be customized via various [build config options](/config/build-options.md). Specifically, you can directly adjust the underlying [Rollup options](https://rollupjs.org/configuration-options/) via `build.rollupOptions`:

```js [vite.config.js]
export default defineConfig({
  build: {
    rollupOptions: {
      // https://rollupjs.org/configuration-options/
    },
  },
})
```

For example, you can specify multiple Rollup outputs with plugins that are only applied during build.

## Chunking Strategy

You can configure how chunks are split using `build.rollupOptions.output.manualChunks` (see [Rollup docs](https://rollupjs.org/configuration-options/#output-manualchunks)). If you use a framework, refer to their documentation for configuring how chunks are split.

## Load Error Handling

Vite emits `vite:preloadError` event when it fails to load dynamic imports. `event.payload` contains the original import error. If you call `event.preventDefault()`, the error will not be thrown.

```js twoslash
window.addEventListener('vite:preloadError', (event) => {
  window.location.reload() // for example, refresh the page
})
```

When a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.

## Rebuild on Files Changes

You can enable rollup watcher with `vite build --watch`. Or, you can directly adjust the underlying [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) via `build.watch`:

```js [vite.config.js]
export default defineConfig({
  build: {
    watch: {
      // https://rollupjs.org/configuration-options/#watch
    },
  },
})
```

With the `--watch` flag enabled, changes to the `vite.config.js`, as well as any files to be bundled, will trigger a rebuild.

## Multi-Page App

Suppose you have the following source code structure:

```
├── package.json
├── vite.config.js
├── index.html
├── main.js
└── nested
    ├── index.html
    └── nested.js
```

During dev, simply navigate or link to `/nested/` - it works as expected, just like for a normal static file server.

During build, all you need to do is to specify multiple `.html` files as entry points:

```js twoslash [vite.config.js]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        nested: resolve(__dirname, 'nested/index.html'),
      },
    },
  },
})
```

If you specify a different root, remember that `__dirname` will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your `root` entry to the arguments for `resolve`.

Note that for HTML files, Vite ignores the name given to the entry in the `rollupOptions.input` object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.

## Library Mode

When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your `index.html` for that purpose to get the smooth development experience.

When it is time to bundle your library for distribution, use the [`build.lib` config option](/config/build-options.md#build-lib). Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. `vue` or `react`:

::: code-group

```js twoslash [vite.config.js (single entry)]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, 'lib/main.js'),
      name: 'MyLib',
      // the proper extensions will be added
      fileName: 'my-lib',
    },
    rollupOptions: {
      // make sure to externalize deps that shouldn't be bundled
      // into your library
      external: ['vue'],
      output: {
        // Provide global variables to use in the UMD build
        // for externalized deps
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})
```

```js twoslash [vite.config.js (multiple entries)]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    lib: {
      entry: {
        'my-lib': resolve(__dirname, 'lib/main.js'),
        secondary: resolve(__dirname, 'lib/secondary.js'),
      },
      name: 'MyLib',
    },
    rollupOptions: {
      // make sure to externalize deps that shouldn't be bundled
      // into your library
      external: ['vue'],
      output: {
        // Provide global variables to use in the UMD build
        // for externalized deps
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})
```

:::

The entry file would contain exports that can be imported by users of your package:

```js [lib/main.js]
import Foo from './Foo.vue'
import Bar from './Bar.vue'
export { Foo, Bar }
```

Running `vite build` with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats:

- `es` and `umd` (for single entry)
- `es` and `cjs` (for multiple entries)

The formats can be configured with the [`build.lib.formats`](/config/build-options.md#build-lib) option.

```
$ vite build
building for production...
dist/my-lib.js      0.08 kB / gzip: 0.07 kB
dist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB
```

Recommended `package.json` for your lib:

::: code-group

```json [package.json (single entry)]
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    }
  }
}
```

```json [package.json (multiple entries)]
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.cjs"
    },
    "./secondary": {
      "import": "./dist/secondary.js",
      "require": "./dist/secondary.cjs"
    }
  }
}
```

:::

### CSS support

If your library imports any CSS, it will be bundled as a single CSS file besides the built JS files, e.g. `dist/my-lib.css`. The name defaults to `build.lib.fileName`, but can also be changed with [`build.lib.cssFileName`](/config/build-options.md#build-lib).

You can export the CSS file in your `package.json` to be imported by users:

```json {12}
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    },
    "./style.css": "./dist/my-lib.css"
  }
}
```

::: tip File Extensions
If the `package.json` does not contain `"type": "module"`, Vite will generate different file extensions for Node.js compatibility. `.js` will become `.mjs` and `.cjs` will become `.js`.
:::

::: tip Environment Variables
In library mode, all [`import.meta.env.*`](./env-and-mode.md) usage are statically replaced when building for production. However, `process.env.*` usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use `define: { 'process.env.NODE_ENV': '"production"' }` for example to statically replace them, or use [`esm-env`](https://github.com/benmccann/esm-env) for better compatibility with bundlers and runtimes.
:::

::: warning Advanced Usage
Library mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use [Rollup](https://rollupjs.org) or [esbuild](https://esbuild.github.io) directly.
:::

## Advanced Base Options

::: warning
This feature is experimental. [Give Feedback](https://github.com/vitejs/vite/discussions/13834).
:::

For advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies.
A user may choose to deploy in three different paths:

- The generated entry HTML files (which may be processed during SSR)
- The generated hashed assets (JS, CSS, and other file types like images)
- The copied [public files](assets.md#the-public-directory)

A single static [base](#public-base-path) isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using `experimental.renderBuiltUrl`.

```ts twoslash
import type { UserConfig } from 'vite'
// prettier-ignore
const config: UserConfig = {
// ---cut-before---
experimental: {
  renderBuiltUrl(filename, { hostType }) {
    if (hostType === 'js') {
      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }
    } else {
      return { relative: true }
    }
  },
},
// ---cut-after---
}
```

If the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset `type` included in the second `context` param given to the function.

```ts twoslash
import type { UserConfig } from 'vite'
import path from 'node:path'
// prettier-ignore
const config: UserConfig = {
// ---cut-before---
experimental: {
  renderBuiltUrl(filename, { hostId, hostType, type }) {
    if (type === 'public') {
      return 'https://www.domain.com/' + filename
    } else if (path.extname(hostId) === '.js') {
      return {
        runtime: `window.__assetsPath(${JSON.stringify(filename)})`
      }
    } else {
      return 'https://cdn.domain.com/assets/' + filename
    }
  },
},
// ---cut-after---
}
```

Note that the `filename` passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with `runtime` is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.



================================================
FILE: docs/guide/cli.md
================================================
# Command Line Interface

## Dev server

### `vite`

Start Vite dev server in the current directory. `vite dev` and `vite serve` are aliases for `vite`.

#### Usage

```bash
vite [root]
```

#### Options

| Options                   |                                                                                                                                                                                      |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `--host [host]`           | Specify hostname (`string`)                                                                                                                                                          |
| `--port <port>`           | Specify port (`number`)                                                                                                                                                              |
| `--open [path]`           | Open browser on startup (`boolean \| string`)                                                                                                                                        |
| `--cors`                  | Enable CORS (`boolean`)                                                                                                                                                              |
| `--strictPort`            | Exit if specified port is already in use (`boolean`)                                                                                                                                 |
| `--force`                 | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                                                                                                    |
| `-c, --config <file>`     | Use specified config file (`string`)                                                                                                                                                 |
| `--base <path>`           | Public base path (default: `/`) (`string`)                                                                                                                                           |
| `-l, --logLevel <level>`  | info \| warn \| error \| silent (`string`)                                                                                                                                           |
| `--clearScreen`           | Allow/disable clear screen when logging (`boolean`)                                                                                                                                  |
| `--configLoader <loader>` | Use `bundle` to bundle the config with esbuild, or `runner` (experimental) to process it on the fly, or `native` (experimental) to load using the native runtime (default: `bundle`) |
| `--profile`               | Start built-in Node.js inspector (check [Performance bottlenecks](/guide/troubleshooting#performance-bottlenecks))                                                                   |
| `-d, --debug [feat]`      | Show debug logs (`string \| boolean`)                                                                                                                                                |
| `-f, --filter <filter>`   | Filter debug logs (`string`)                                                                                                                                                         |
| `-m, --mode <mode>`       | Set env mode (`string`)                                                                                                                                                              |
| `-h, --help`              | Display available CLI options                                                                                                                                                        |
| `-v, --version`           | Display version number                                                                                                                                                               |

## Build

### `vite build`

Build for production.

#### Usage

```bash
vite build [root]
```

#### Options

| Options                        |                                                                                                                        |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| `--target <target>`            | Transpile target (default: `"modules"`) (`string`)                                                                     |
| `--outDir <dir>`               | Output directory (default: `dist`) (`string`)                                                                          |
| `--assetsDir <dir>`            | Directory under outDir to place assets in (default: `"assets"`) (`string`)                                             |
| `--assetsInlineLimit <number>` | Static asset base64 inline threshold in bytes (default: `4096`) (`number`)                                             |
| `--ssr [entry]`                | Build specified entry for server-side rendering (`string`)                                                             |
| `--sourcemap [output]`         | Output source maps for build (default: `false`) (`boolean \| "inline" \| "hidden"`)                                    |
| `--minify [minifier]`          | Enable/disable minification, or specify minifier to use (default: `"esbuild"`) (`boolean \| "terser" \| "esbuild"`)    |
| `--manifest [name]`            | Emit build manifest json (`boolean \| string`)                                                                         |
| `--ssrManifest [name]`         | Emit ssr manifest json (`boolean \| string`)                                                                           |
| `--emptyOutDir`                | Force empty outDir when it's outside of root (`boolean`)                                                               |
| `-w, --watch`                  | Rebuilds when modules have changed on disk (`boolean`)                                                                 |
| `-c, --config <file>`          | Use specified config file (`string`)                                                                                   |
| `--base <path>`                | Public base path (default: `/`) (`string`)                                                                             |
| `-l, --logLevel <level>`       | Info \| warn \| error \| silent (`string`)                                                                             |
| `--clearScreen`                | Allow/disable clear screen when logging (`boolean`)                                                                    |
| `--configLoader <loader>`      | Use `bundle` to bundle the config with esbuild or `runner` (experimental) to process it on the fly (default: `bundle`) |
| `--profile`                    | Start built-in Node.js inspector (check [Performance bottlenecks](/guide/troubleshooting#performance-bottlenecks))     |
| `-d, --debug [feat]`           | Show debug logs (`string \| boolean`)                                                                                  |
| `-f, --filter <filter>`        | Filter debug logs (`string`)                                                                                           |
| `-m, --mode <mode>`            | Set env mode (`string`)                                                                                                |
| `-h, --help`                   | Display available CLI options                                                                                          |
| `--app`                        | Build all environments, same as `builder: {}` (`boolean`, experimental)                                                |

## Others

### `vite optimize`

Pre-bundle dependencies.

**Deprecated**: the pre-bundle process runs automatically and does not need to be called.

#### Usage

```bash
vite optimize [root]
```

#### Options

| Options                   |                                                                                                                        |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `--force`                 | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                                      |
| `-c, --config <file>`     | Use specified config file (`string`)                                                                                   |
| `--base <path>`           | Public base path (default: `/`) (`string`)                                                                             |
| `-l, --logLevel <level>`  | Info \| warn \| error \| silent (`string`)                                                                             |
| `--clearScreen`           | Allow/disable clear screen when logging (`boolean`)                                                                    |
| `--configLoader <loader>` | Use `bundle` to bundle the config with esbuild or `runner` (experimental) to process it on the fly (default: `bundle`) |
| `-d, --debug [feat]`      | Show debug logs (`string \| boolean`)                                                                                  |
| `-f, --filter <filter>`   | Filter debug logs (`string`)                                                                                           |
| `-m, --mode <mode>`       | Set env mode (`string`)                                                                                                |
| `-h, --help`              | Display available CLI options                                                                                          |

### `vite preview`

Locally preview the production build. Do not use this as a production server as it's not designed for it.

#### Usage

```bash
vite preview [root]
```

#### Options

| Options                   |                                                                                                                        |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `--host [host]`           | Specify hostname (`string`)                                                                                            |
| `--port <port>`           | Specify port (`number`)                                                                                                |
| `--strictPort`            | Exit if specified port is already in use (`boolean`)                                                                   |
| `--open [path]`           | Open browser on startup (`boolean \| string`)                                                                          |
| `--outDir <dir>`          | Output directory (default: `dist`)(`string`)                                                                           |
| `-c, --config <file>`     | Use specified config file (`string`)                                                                                   |
| `--base <path>`           | Public base path (default: `/`) (`string`)                                                                             |
| `-l, --logLevel <level>`  | Info \| warn \| error \| silent (`string`)                                                                             |
| `--clearScreen`           | Allow/disable clear screen when logging (`boolean`)                                                                    |
| `--configLoader <loader>` | Use `bundle` to bundle the config with esbuild or `runner` (experimental) to process it on the fly (default: `bundle`) |
| `-d, --debug [feat]`      | Show debug logs (`string \| boolean`)                                                                                  |
| `-f, --filter <filter>`   | Filter debug logs (`string`)                                                                                           |
| `-m, --mode <mode>`       | Set env mode (`string`)                                                                                                |
| `-h, --help`              | Display available CLI options                                                                                          |



================================================
FILE: docs/guide/dep-pre-bundling.md
================================================
# Dependency Pre-Bundling

When you run `vite` for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.

## The Why

This is Vite performing what we call "dependency pre-bundling". This process serves two purposes:

1. **CommonJS and UMD compatibility:** During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.

   When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):

   ```js
   // works as expected
   import React, { useState } from 'react'
   ```

2. **Performance:** Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.

   Some packages ship their ES modules builds as many separate files importing one another. For example, [`lodash-es` has over 600 internal modules](https://unpkg.com/browse/lodash-es/)! When we do `import { debounce } from 'lodash-es'`, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.

   By pre-bundling `lodash-es` into a single module, we now only need one HTTP request instead!

::: tip NOTE
Dependency pre-bundling only applies in development mode, and uses `esbuild` to convert dependencies to ESM. In production builds, `@rollup/plugin-commonjs` is used instead.
:::

## Automatic Dependency Discovery

If an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. "bare imports" that expect to be resolved from `node_modules`) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with `esbuild` so it's typically very fast.

After the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.

## Monorepos and Linked Dependencies

In a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from `node_modules` and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.

However, this requires the linked dep to be exported as ESM. If not, you can add the dependency to [`optimizeDeps.include`](/config/dep-optimization-options.md#optimizedeps-include) and [`build.commonjsOptions.include`](/config/build-options.md#build-commonjsoptions) in your config.

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['linked-dep'],
  },
  build: {
    commonjsOptions: {
      include: [/linked-dep/, /node_modules/],
    },
  },
})
```

When making changes to the linked dep, restart the dev server with the `--force` command line option for the changes to take effect.

## Customizing the Behavior

The default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the [`optimizeDeps` config options](/config/dep-optimization-options.md).

A typical use case for `optimizeDeps.include` or `optimizeDeps.exclude` is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.

Both `include` and `exclude` can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.

You can further customize esbuild too with the [`optimizeDeps.esbuildOptions` option](/config/dep-optimization-options.md#optimizedeps-esbuildoptions). For example, adding an esbuild plugin to handle special files in dependencies or changing the [build `target`](https://esbuild.github.io/api/#target).

## Caching

### File System Cache

Vite caches the pre-bundled dependencies in `node_modules/.vite`. It determines whether it needs to re-run the pre-bundling step based on a few sources:

- Package manager lockfile content, e.g. `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` or `bun.lock`.
- Patches folder modification time.
- Relevant fields in your `vite.config.js`, if present.
- `NODE_ENV` value.

The pre-bundling step will only need to be re-run when one of the above has changed.

If for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.

### Browser Cache

Resolved dependency requests are strongly cached with HTTP headers `max-age=31536000,immutable` to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:

1. Temporarily disable cache via the Network tab of your browser devtools.
2. Restart Vite dev server with the `--force` flag to re-bundle the deps.
3. Reload the page.



================================================
FILE: docs/guide/env-and-mode.md
================================================
# Env Variables and Modes

Vite exposes certain constants under the special `import.meta.env` object. These constants are defined as global variables during dev and statically replaced at build time to make tree-shaking effective.

## Built-in Constants

Some built-in constants are available in all cases:

- **`import.meta.env.MODE`**: {string} the [mode](#modes) the app is running in.

- **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the [`base` config option](/config/shared-options.md#base).

- **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with `NODE_ENV='production'` or running an app built with `NODE_ENV='production'`).

- **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of `import.meta.env.PROD`)

- **`import.meta.env.SSR`**: {boolean} whether the app is running in the [server](./ssr.md#conditional-logic).

## Env Variables

Vite exposes env variables under `import.meta.env` object as strings automatically.

To prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your Vite-processed code. e.g. for the following env variables:

```[.env]
VITE_SOME_KEY=123
DB_PASSWORD=foobar
```

Only `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD` will not.

```js
console.log(import.meta.env.VITE_SOME_KEY) // "123"
console.log(import.meta.env.DB_PASSWORD) // undefined
```

If you want to customize the env variables prefix, see the [envPrefix](/config/shared-options.html#envprefix) option.

:::tip Env parsing
As shown above, `VITE_SOME_KEY` is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.
:::

### `.env` Files

Vite uses [dotenv](https://github.com/motdotla/dotenv) to load additional environment variables from the following files in your [environment directory](/config/shared-options.md#envdir):

```
.env                # loaded in all cases
.env.local          # loaded in all cases, ignored by git
.env.[mode]         # only loaded in specified mode
.env.[mode].local   # only loaded in specified mode, ignored by git
```

:::tip Env Loading Priorities

An env file for a specific mode (e.g. `.env.production`) will take higher priority than a generic one (e.g. `.env`).

Vite will always load `.env` and `.env.local` in addition to the mode-specific `.env.[mode]` file. Variables declared in mode-specific files will take precedence over those in generic files, but variables defined only in `.env` or `.env.local` will still be available in the environment.

In addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by `.env` files. For example, when running `VITE_SOME_KEY=123 vite build`.

`.env` files are loaded at the start of Vite. Restart the server after making changes.

:::

Also, Vite uses [dotenv-expand](https://github.com/motdotla/dotenv-expand) to expand variables written in env files out of the box. To learn more about the syntax, check out [their docs](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow).

Note that if you want to use `$` inside your environment value, you have to escape it with `\`.

```[.env]
KEY=123
NEW_KEY1=test$foo   # test
NEW_KEY2=test\$foo  # test$foo
NEW_KEY3=test$KEY   # test123
```

:::warning SECURITY NOTES

- `.env.*.local` files are local-only and can contain sensitive variables. You should add `*.local` to your `.gitignore` to avoid them being checked into git.

- Since any variables exposed to your Vite source code will end up in your client bundle, `VITE_*` variables should _not_ contain any sensitive information.

:::

::: details Expanding variables in reverse order

Vite supports expanding variables in reverse order.
For example, the `.env` below will be evaluated as `VITE_FOO=foobar`, `VITE_BAR=bar`.

```[.env]
VITE_FOO=foo${VITE_BAR}
VITE_BAR=bar
```

This does not work in shell scripts and other tools like `docker-compose`.
That said, Vite supports this behavior as this has been supported by `dotenv-expand` for a long time and other tools in JavaScript ecosystem uses older versions that supports this behavior.

To avoid interop issues, it is recommended to avoid relying on this behavior. Vite may start emitting warnings for this behavior in the future.

:::

## IntelliSense for TypeScript

By default, Vite provides type definitions for `import.meta.env` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with `VITE_`.

To achieve this, you can create an `vite-env.d.ts` in `src` directory, then augment `ImportMetaEnv` like this:

```typescript [vite-env.d.ts]
/// <reference types="vite/client" />

interface ViteTypeOptions {
  // By adding this line, you can make the type of ImportMetaEnv strict
  // to disallow unknown keys.
  // strictImportMetaEnv: unknown
}

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

If your code relies on types from browser environments such as [DOM](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts) and [WebWorker](https://github.com/microsoft/TypeScript/blob/main/src/lib/webworker.generated.d.ts), you can update the [lib](https://www.typescriptlang.org/tsconfig#lib) field in `tsconfig.json`.

```json [tsconfig.json]
{
  "lib": ["WebWorker"]
}
```

:::warning Imports will break type augmentation

If the `ImportMetaEnv` augmentation does not work, make sure you do not have any `import` statements in `vite-env.d.ts`. See the [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined) for more information.

:::

## HTML Constant Replacement

Vite also supports replacing constants in HTML files. Any properties in `import.meta.env` can be used in HTML files with a special `%CONST_NAME%` syntax:

```html
<h1>Vite is running in %MODE%</h1>
<p>Using data from %VITE_API_URL%</p>
```

If the env doesn't exist in `import.meta.env`, e.g. `%NON_EXISTENT%`, it will be ignored and not replaced, unlike `import.meta.env.NON_EXISTENT` in JS where it's replaced as `undefined`.

Given that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using [an existing userland plugin](https://github.com/vitejs/awesome-vite#transformers) or a custom plugin that implements the [`transformIndexHtml` hook](./api-plugin#transformindexhtml).

## Modes

By default, the dev server (`dev` command) runs in `development` mode and the `build` command runs in `production` mode.

This means when running `vite build`, it will load the env variables from `.env.production` if there is one:

```[.env.production]
VITE_APP_TITLE=My App
```

In your app, you can render the title using `import.meta.env.VITE_APP_TITLE`.

In some cases, you may want to run `vite build` with a different mode to render a different title. You can overwrite the default mode used for a command by passing the `--mode` option flag. For example, if you want to build your app for a staging mode:

```bash
vite build --mode staging
```

And create a `.env.staging` file:

```[.env.staging]
VITE_APP_TITLE=My App (staging)
```

As `vite build` runs a production build by default, you can also change this and run a development build by using a different mode and `.env` file configuration:

```[.env.testing]
NODE_ENV=development
```

### NODE_ENV and Modes

It's important to note that `NODE_ENV` (`process.env.NODE_ENV`) and modes are two different concepts. Here's how different commands affect the `NODE_ENV` and mode:

| Command                                              | NODE_ENV        | Mode            |
| ---------------------------------------------------- | --------------- | --------------- |
| `vite build`                                         | `"production"`  | `"production"`  |
| `vite build --mode development`                      | `"production"`  | `"development"` |
| `NODE_ENV=development vite build`                    | `"development"` | `"production"`  |
| `NODE_ENV=development vite build --mode development` | `"development"` | `"development"` |

The different values of `NODE_ENV` and mode also reflect on its corresponding `import.meta.env` properties:

| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |
| ---------------------- | ---------------------- | --------------------- |
| `NODE_ENV=production`  | `true`                 | `false`               |
| `NODE_ENV=development` | `false`                | `true`                |
| `NODE_ENV=other`       | `false`                | `true`                |

| Command              | `import.meta.env.MODE` |
| -------------------- | ---------------------- |
| `--mode production`  | `"production"`         |
| `--mode development` | `"development"`        |
| `--mode staging`     | `"staging"`            |

:::tip `NODE_ENV` in `.env` files

`NODE_ENV=...` can be set in the command, and also in your `.env` file. If `NODE_ENV` is specified in a `.env.[mode]` file, the mode can be used to control its value. However, both `NODE_ENV` and modes remain as two different concepts.

The main benefit with `NODE_ENV=...` in the command is that it allows Vite to detect the value early. It also allows you to read `process.env.NODE_ENV` in your Vite config as Vite can only load the env files once the config is evaluated.
:::



================================================
FILE: docs/guide/features.md
================================================
# Features

At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.

## npm Dependency Resolving and Pre-Bundling

Native ES imports do not support bare module imports like the following:

```js
import { someMethod } from 'my-dep'
```

The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:

1. [Pre-bundle](./dep-pre-bundling) them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with [esbuild](http://esbuild.github.io/) and makes Vite's cold start time significantly faster than any JavaScript-based bundler.

2. Rewrite the imports to valid URLs like `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` so that the browser can import them properly.

**Dependencies are Strongly Cached**

Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps [here](./dep-pre-bundling#browser-cache).

## Hot Module Replacement

Vite provides an [HMR API](./api-hmr) over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for [Vue Single File Components](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) and [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react). There are also official integrations for Preact via [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).

Note you don't need to manually set these up - when you [create an app via `create-vite`](./), the selected templates would have these pre-configured for you already.

## TypeScript

Vite supports importing `.ts` files out of the box.

### Transpile Only

Note that Vite only performs transpilation on `.ts` files and does **NOT** perform type checking. It assumes type checking is taken care of by your IDE and build process.

The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.

Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.

- For production builds, you can run `tsc --noEmit` in addition to Vite's build command.

- During development, if you need more than IDE hints, we recommend running `tsc --noEmit --watch` in a separate process, or use [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker) if you prefer having type errors directly reported in the browser.

Vite uses [esbuild](https://github.com/evanw/esbuild) to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla `tsc`, and HMR updates can reflect in the browser in under 50ms.

Use the [Type-Only Imports and Export](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:

```ts
import type { T } from 'only/types'
export type { T }
```

### TypeScript Compiler Options

Some configuration fields under `compilerOptions` in `tsconfig.json` require special attention.

#### `isolatedModules`

- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#isolatedModules)

Should be set to `true`.

It is because `esbuild` only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.

You must set `"isolatedModules": true` in your `tsconfig.json` under `compilerOptions`, so that TS will warn you against the features that do not work with isolated transpilation.

If a dependency doesn't work well with `"isolatedModules": true`. You can use `"skipLibCheck": true` to temporarily suppress the errors until it is fixed upstream.

#### `useDefineForClassFields`

- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)

The default value will be `true` if the TypeScript target is `ES2022` or newer including `ESNext`. It is consistent with the [behavior of TypeScript 4.3.2+](https://github.com/microsoft/TypeScript/pull/42663).
Other TypeScript targets will default to `false`.

`true` is the standard ECMAScript runtime behavior.

If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
While most libraries expect `"useDefineForClassFields": true`, you can explicitly set `useDefineForClassFields` to `false` if your library doesn't support it.

#### `target`

- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#target)

Vite ignores the `target` value in the `tsconfig.json`, following the same behavior as `esbuild`.

To specify the target in dev, the [`esbuild.target`](/config/shared-options.html#esbuild) option can be used, which defaults to `esnext` for minimal transpilation. In builds, the [`build.target`](/config/build-options.html#build-target) option takes higher priority over `esbuild.target` and can also be set if needed.

::: warning `useDefineForClassFields`

If `target` in `tsconfig.json` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.

As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.
:::

#### Other Compiler Options Affecting the Build Result

- [`extends`](https://www.typescriptlang.org/tsconfig#extends)
- [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)
- [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)
- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)
- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)
- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)
- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)
- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)
- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)
- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)

::: tip `skipLibCheck`
Vite starter templates have `"skipLibCheck": "true"` by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688).
:::

### Client Types

Vite's default types are for its Node.js API. To shim the environment of client-side code in a Vite application, add a `d.ts` declaration file:

```typescript
/// <reference types="vite/client" />
```

::: details Using `compilerOptions.types`

Alternatively, you can add `vite/client` to `compilerOptions.types` inside `tsconfig.json`:

```json [tsconfig.json]
{
  "compilerOptions": {
    "types": ["vite/client", "some-other-global-lib"]
  }
}
```

Note that if [`compilerOptions.types`](https://www.typescriptlang.org/tsconfig#types) is specified, only these packages will be included in the global scope (instead of all visible ”@types” packages).

:::

`vite/client` provides the following type shims:

- Asset imports (e.g. importing an `.svg` file)
- Types for the Vite-injected [constants](./env-and-mode#env-variables) on `import.meta.env`
- Types for the [HMR API](./api-hmr) on `import.meta.hot`

::: tip
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before `vite/client`.

For example, to make the default import of `*.svg` a React component:

- `vite-env-override.d.ts` (the file that contains your typings):
  ```ts
  declare module '*.svg' {
    const content: React.FC<React.SVGProps<SVGElement>>
    export default content
  }
  ```
- The file containing the reference to `vite/client` (normally `vite-env.d.ts`):
  ```ts
  /// <reference types="./vite-env-override.d.ts" />
  /// <reference types="vite/client" />
  ```

:::

## HTML

HTML files stand [front-and-center](/guide/#index-html-and-project-root) of a Vite project, serving as the entry points for your application, making it simple to build single-page and [multi-page applications](/guide/build.html#multi-page-app).

Any HTML files in your project root can be directly accessed by its respective directory path:

- `<root>/index.html` -> `http://localhost:5173/`
- `<root>/about.html` -> `http://localhost:5173/about.html`
- `<root>/blog/index.html` -> `http://localhost:5173/blog/index.html`

Assets referenced by HTML elements such as `<script type="module" src>` and `<link href>` are processed and bundled as part of the app. The full list of supported elements are as below:

- `<audio src>`
- `<embed src>`
- `<img src>` and `<img srcset>`
- `<image href>` and `<image xlink:href>`
- `<input src>`
- `<link href>` and `<link imagesrcset>`
- `<object data>`
- `<script type="module" src>`
- `<source src>` and `<source srcset>`
- `<track src>`
- `<use href>` and `<use xlink:href>`
- `<video src>` and `<video poster>`
- `<meta content>`
  - Only if `name` attribute matches `msapplication-tileimage`, `msapplication-square70x70logo`, `msapplication-square150x150logo`, `msapplication-wide310x150logo`, `msapplication-square310x310logo`, `msapplication-config`, or `twitter:image`
  - Or only if `property` attribute matches `og:image`, `og:image:url`, `og:image:secure_url`, `og:audio`, `og:audio:secure_url`, `og:video`, or `og:video:secure_url`

```html {4-5,8-9}
<!doctype html>
<html>
  <head>
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/src/styles.css" />
  </head>
  <body>
    <img src="/src/images/logo.svg" alt="logo" />
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

To opt-out of HTML processing on certain elements, you can add the `vite-ignore` attribute on the element, which can be useful when referencing external assets or CDN.

## Frameworks

All modern frameworks maintain integrations with Vite. Most framework plugins are maintained by each framework team, with the exception of the official Vue and React Vite plugins that are maintained in the vite org:

- Vue support via [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)
- Vue JSX support via [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)
- React support via [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react)
- React using SWC support via [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react-swc)

Check out the [Plugins Guide](https://vite.dev/plugins) for more information.

## JSX

`.jsx` and `.tsx` files are also supported out of the box. JSX transpilation is also handled via [esbuild](https://esbuild.github.io).

Your framework of choice will already configure JSX out of the box (for example, Vue users should use the official [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots).

If using JSX with your own framework, custom `jsxFactory` and `jsxFragment` can be configured using the [`esbuild` option](/config/shared-options.md#esbuild). For example, the Preact plugin would use:

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment',
  },
})
```

More details in [esbuild docs](https://esbuild.github.io/content-types/#jsx).

You can inject the JSX helpers using `jsxInject` (which is a Vite-only option) to avoid manual imports:

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxInject: `import React from 'react'`,
  },
})
```

## CSS

Importing `.css` files will inject its content to the page via a `<style>` tag with HMR support.

### `@import` Inlining and Rebasing

Vite is pre-configured to support CSS `@import` inlining via `postcss-import`. Vite aliases are also respected for CSS `@import`. In addition, all CSS `url()` references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.

`@import` aliases and URL rebasing are also supported for Sass and Less files (see [CSS Pre-processors](#css-pre-processors)).

### PostCSS

If the project contains valid PostCSS config (any format supported by [postcss-load-config](https://github.com/postcss/postcss-load-config), e.g. `postcss.config.js`), it will be automatically applied to all imported CSS.

Note that CSS minification will run after PostCSS and will use [`build.cssTarget`](/config/build-options.md#build-csstarget) option.

### CSS Modules

Any CSS file ending with `.module.css` is considered a [CSS modules file](https://github.com/css-modules/css-modules). Importing such a file will return the corresponding module object:

```css [example.module.css]
.red {
  color: red;
}
```

```js twoslash
import 'vite/client'
// ---cut---
import classes from './example.module.css'
document.getElementById('foo').className = classes.red
```

CSS modules behavior can be configured via the [`css.modules` option](/config/shared-options.md#css-modules).

If `css.modules.localsConvention` is set to enable camelCase locals (e.g. `localsConvention: 'camelCaseOnly'`), you can also use named imports:

```js twoslash
import 'vite/client'
// ---cut---
// .apply-color -> applyColor
import { applyColor } from './example.module.css'
document.getElementById('foo').className = applyColor
```

### CSS Pre-processors

Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)) and author plain, future-standards-compliant CSS.

That said, Vite does provide built-in support for `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:

```bash
# .scss and .sass
npm add -D sass-embedded # or sass

# .less
npm add -D less

# .styl and .stylus
npm add -D stylus
```

If using Vue single file components, this also automatically enables `<style lang="sass">` et al.

Vite improves `@import` resolving for Sass and Less so that Vite aliases are also respected. In addition, relative `url()` references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness. Rebasing `url()` references that starts with a variable or a interpolation are not supported due to its API constraints.

`@import` alias and url rebasing are not supported for Stylus due to its API constraints.

You can also use CSS modules combined with pre-processors by prepending `.module` to the file extension, for example `style.module.scss`.

### Disabling CSS injection into the page

The automatic injection of CSS contents can be turned off via the `?inline` query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.

```js twoslash
import 'vite/client'
// ---cut---
import './foo.css' // will be injected into the page
import otherStyles from './bar.css?inline' // will not be injected
```

::: tip NOTE
Default and named imports from CSS files (e.g `import style from './foo.css'`) are removed since Vite 5. Use the `?inline` query instead.
:::

### Lightning CSS

Starting from Vite 4.4, there is experimental support for [Lightning CSS](https://lightningcss.dev/). You can opt into it by adding [`css.transformer: 'lightningcss'`](../config/shared-options.md#css-transformer) to your config file and install the optional [`lightningcss`](https://www.npmjs.com/package/lightningcss) dependency:

```bash
npm add -D lightningcss
```

If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the [`css.lightningcss`](../config/shared-options.md#css-lightningcss) config option.

To configure CSS Modules, you'll use [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) instead of [`css.modules`](../config/shared-options.md#css-modules) (which configures the way PostCSS handles CSS modules).

By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with [`build.cssMinify: 'lightningcss'`](../config/build-options.md#build-cssminify).

## Static Assets

Importing a static asset will return the resolved public URL when it is served:

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

Special queries can modify how assets are loaded:

```js twoslash
import 'vite/client'
// ---cut---
// Explicitly load assets as URL (automatically inlined depending on the file size)
import assetAsURL from './asset.js?url'
```

```js twoslash
import 'vite/client'
// ---cut---
// Load assets as strings
import assetAsString from './shader.glsl?raw'
```

```js twoslash
import 'vite/client'
// ---cut---
// Load Web Workers
import Worker from './worker.js?worker'
```

```js twoslash
import 'vite/client'
// ---cut---
// Web Workers inlined as base64 strings at build time
import InlineWorker from './worker.js?worker&inline'
```

More details in [Static Asset Handling](./assets).

## JSON

JSON files can be directly imported - named imports are also supported:

```js twoslash
import 'vite/client'
// ---cut---
// import the entire object
import json from './example.json'
// import a root field as named exports - helps with tree-shaking!
import { field } from './example.json'
```

## Glob Import

Vite supports importing multiple modules from the file system via the special `import.meta.glob` function:

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js')
```

The above will be transformed into the following:

```js
// code produced by vite
const modules = {
  './dir/bar.js': () => import('./dir/bar.js'),
  './dir/foo.js': () => import('./dir/foo.js'),
}
```

You can then iterate over the keys of the `modules` object to access the corresponding modules:

```js
for (const path in modules) {
  modules[path]().then((mod) => {
    console.log(path, mod)
  })
}
```

Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass `{ eager: true }` as the second argument:

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', { eager: true })
```

The above will be transformed into the following:

```js
// code produced by vite
import * as __vite_glob_0_0 from './dir/bar.js'
import * as __vite_glob_0_1 from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

### Multiple Patterns

The first argument can be an array of globs, for example

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob(['./dir/*.js', './another/*.js'])
```

### Negative Patterns

Negative glob patterns are also supported (prefixed with `!`). To ignore some files from the result, you can add exclude glob patterns to the first argument:

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])
```

```js
// code produced by vite
const modules = {
  './dir/foo.js': () => import('./dir/foo.js'),
}
```

#### Named Imports

It's possible to only import parts of the modules with the `import` options.

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', { import: 'setup' })
```

```ts
// code produced by vite
const modules = {
  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),
  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),
}
```

When combined with `eager` it's even possible to have tree-shaking enabled for those modules.

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  import: 'setup',
  eager: true,
})
```

```ts
// code produced by vite:
import { setup as __vite_glob_0_0 } from './dir/bar.js'
import { setup as __vite_glob_0_1 } from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

Set `import` to `default` to import the default export.

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  import: 'default',
  eager: true,
})
```

```ts
// code produced by vite:
import { default as __vite_glob_0_0 } from './dir/bar.js'
import { default as __vite_glob_0_1 } from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

#### Custom Queries

You can also use the `query` option to provide queries to imports, for example, to import assets [as a string](https://vite.dev/guide/assets.html#importing-asset-as-string) or [as a url](https://vite.dev/guide/assets.html#importing-asset-as-url):

```ts twoslash
import 'vite/client'
// ---cut---
const moduleStrings = import.meta.glob('./dir/*.svg', {
  query: '?raw',
  import: 'default',
})
const moduleUrls = import.meta.glob('./dir/*.svg', {
  query: '?url',
  import: 'default',
})
```

```ts
// code produced by vite:
const moduleStrings = {
  './dir/bar.svg': () => import('./dir/bar.svg?raw').then((m) => m['default']),
  './dir/foo.svg': () => import('./dir/foo.svg?raw').then((m) => m['default']),
}
const moduleUrls = {
  './dir/bar.svg': () => import('./dir/bar.svg?url').then((m) => m['default']),
  './dir/foo.svg': () => import('./dir/foo.svg?url').then((m) => m['default']),
}
```

You can also provide custom queries for other plugins to consume:

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  query: { foo: 'bar', bar: true },
})
```

#### Base Path

You can also use the `base` option to provide base path for the imports:

```ts twoslash
import 'vite/client'
// ---cut---
const modulesWithBase = import.meta.glob('./**/*.js', {
  base: './base',
})
```

```ts
// code produced by vite:
const modulesWithBase = {
  './dir/foo.js': () => import('./base/dir/foo.js'),
  './dir/bar.js': () => import('./base/dir/bar.js'),
}
```

The base option can only be a directory path relative to the importer file or absolute against the project root. Aliases and virtual modules aren't supported.

Only the globs that are relative paths are interpreted as relative to the resolved base.

All the resulting module keys are modified to be relative to the base if provided.

### Glob Import Caveats

Note that:

- This is a Vite-only feature and is not a web or ES standard.
- The glob patterns are treated like import specifiers: they must be either relative (start with `./`) or absolute (start with `/`, resolved relative to project root) or an alias path (see [`resolve.alias` option](/config/shared-options.md#resolve-alias)).
- The glob matching is done via [`tinyglobby`](https://github.com/SuperchupuDev/tinyglobby).
- You should also be aware that all the arguments in the `import.meta.glob` must be **passed as literals**. You can NOT use variables or expressions in them.

## Dynamic Import

Similar to [glob import](#glob-import), Vite also supports dynamic import with variables.

```ts
const module = await import(`./dir/${file}.js`)
```

Note that variables only represent file names one level deep. If `file` is `'foo/bar'`, the import would fail. For more advanced usage, you can use the [glob import](#glob-import) feature.

## WebAssembly

Pre-compiled `.wasm` files can be imported with `?init`.
The default export will be an initialization function that returns a Promise of the [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance):

```js twoslash
import 'vite/client'
// ---cut---
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})
```

The init function can also take an importObject which is passed along to [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) as its second argument:

```js twoslash
import 'vite/client'
import init from './example.wasm?init'
// ---cut---
init({
  imports: {
    someFunc: () => {
      /* ... */
    },
  },
}).then(() => {
  /* ... */
})
```

In the production build, `.wasm` files smaller than `assetInlineLimit` will be inlined as base64 strings. Otherwise, they will be treated as a [static asset](./assets) and fetched on-demand.

::: tip NOTE
[ES Module Integration Proposal for WebAssembly](https://github.com/WebAssembly/esm-integration) is not currently supported.
Use [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) or other community plugins to handle this.
:::

### Accessing the WebAssembly Module

If you need access to the `Module` object, e.g. to instantiate it multiple times, use an [explicit URL import](./assets#explicit-url-imports) to resolve the asset, and then perform the instantiation:

```js twoslash
import 'vite/client'
// ---cut---
import wasmUrl from 'foo.wasm?url'

const main = async () => {
  const responsePromise = fetch(wasmUrl)
  const { module, instance } =
    await WebAssembly.instantiateStreaming(responsePromise)
  /* ... */
}

main()
```

### Fetching the module in Node.js

In SSR, the `fetch()` happening as part of the `?init` import, may fail with `TypeError: Invalid URL`.
See the issue [Support wasm in SSR](https://github.com/vitejs/vite/issues/8882).

Here is an alternative, assuming the project base is the current directory:

```js twoslash
import 'vite/client'
// ---cut---
import wasmUrl from 'foo.wasm?url'
import { readFile } from 'node:fs/promises'

const main = async () => {
  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default
  const buffer = await readFile('.' + resolvedUrl)
  const { instance } = await WebAssembly.instantiate(buffer, {
    /* ... */
  })
  /* ... */
}

main()
```

## Web Workers

### Import with Constructors

A web worker script can be imported using [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) and [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker). Compared to the worker suffixes, this syntax leans closer to the standards and is the **recommended** way to create workers.

```ts
const worker = new Worker(new URL('./worker.js', import.meta.url))
```

The worker constructor also accepts options, which can be used to create "module" workers:

```ts
const worker = new Worker(new URL('./worker.js', import.meta.url), {
  type: 'module',
})
```

The worker detection will only work if the `new URL()` constructor is used directly inside the `new Worker()` declaration. Additionally, all options parameters must be static values (i.e. string literals).

### Import with Query Suffixes

A web worker script can be directly imported by appending `?worker` or `?sharedworker` to the import request. The default export will be a custom worker constructor:

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker'

const worker = new MyWorker()
```

The worker script can also use ESM `import` statements instead of `importScripts()`. **Note**: During development this relies on [browser native support](https://caniuse.com/?search=module%20worker), but for the production build it is compiled away.

By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the `inline` query:

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker&inline'
```

If you wish to retrieve the worker as a URL, add the `url` query:

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker&url'
```

See [Worker Options](/config/worker-options.md) for details on configuring the bundling of all workers.

## Content Security Policy (CSP)

To deploy CSP, certain directives or configs must be set due to Vite's internals.

### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)

When [`html.cspNonce`](/config/shared-options#html-cspnonce) is set, Vite adds a nonce attribute with the specified value to any `<script>` and `<style>` tags, as well as `<link>` tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (`<meta property="csp-nonce" nonce="PLACEHOLDER" />`).

The nonce value of a meta tag with `property="csp-nonce"` will be used by Vite whenever necessary during both dev and after build.

:::warning
Ensure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.
:::

### [`data:`](<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A>)

By default, during build, Vite inlines small assets as data URIs. Allowing `data:` for related directives (e.g. [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src), [`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)), or, disabling it by setting [`build.assetsInlineLimit: 0`](/config/build-options#build-assetsinlinelimit) is necessary.

:::warning
Do not allow `data:` for [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). It will allow injection of arbitrary scripts.
:::

## Build Optimizations

> Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.

### CSS Code Splitting

Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a `<link>` tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).

If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting [`build.cssCodeSplit`](/config/build-options.md#build-csscodesplit) to `false`.

### Preload Directives Generation

Vite automatically generates `<link rel="modulepreload">` directives for entry chunks and their direct imports in the built HTML.

### Async Chunk Loading Optimization

In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:

<script setup>
import graphSvg from '../images/graph.svg?raw'
</script>
<svg-image :svg="graphSvg" />

In the non-optimized scenarios, when async chunk `A` is imported, the browser will have to request and parse `A` before it can figure out that it also needs the common chunk `C`. This results in an extra network roundtrip:

```
Entry ---> A ---> C
```

Vite automatically rewrites code-split dynamic import calls with a preload step so that when `A` is requested, `C` is fetched **in parallel**:

```
Entry ---> (A + C)
```

It is possible for `C` to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.



================================================
FILE: docs/guide/index.md
================================================
# Getting Started

<audio id="vite-audio">
  <source src="/vite.mp3" type="audio/mpeg">
</audio>

## Overview

Vite (French word for "quick", pronounced `/vit/`<button style="border:none;padding:3px;border-radius:4px;vertical-align:bottom" id="play-vite-audio" aria-label="pronounce" onclick="document.getElementById('vite-audio').play();"><svg style="height:2em;width:2em"><use href="../images/voice.svg?no-inline#voice" /></svg></button>, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:

- A dev server that provides [rich feature enhancements](./features) over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), for example extremely fast [Hot Module Replacement (HMR)](./features#hot-module-replacement).

- A build command that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.

Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the [Features Guide](./features). Support for frameworks or integration with other tools is possible through [Plugins](./using-plugins). The [Config Section](../config/) explains how to adapt Vite to your project if needed.

Vite is also highly extensible via its [Plugin API](./api-plugin) and [JavaScript API](./api-javascript) with full typing support.

You can learn more about the rationale behind the project in the [Why Vite](./why) section.

## Browser Support

During development, Vite assumes that a modern browser is used. This means the browser supports most of the latest JavaScript and CSS features. For that reason, Vite sets [`esnext` as the transform target](https://esbuild.github.io/api/#target). This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code. Vite injects some runtime code to make the development server work. These code use features included in [Baseline](https://web-platform-dx.github.io/web-features/) Newly Available at the time of each major release (2025-05-01 for this major).

For production builds, Vite by default targets [Baseline](https://web-platform-dx.github.io/web-features/) Widely Available browsers. These are browsers that were released at least 2.5 years ago. The target can be lowered via configuration. Additionally, legacy browsers can be supported via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). See the [Building for Production](./build) section for more details.

## Trying Vite Online

You can try Vite online on [StackBlitz](https://vite.new/). It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to `vite.new/{template}` to select which framework to use.

The supported template presets are:

|             JavaScript              |                TypeScript                 |
| :---------------------------------: | :---------------------------------------: |
| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |
|     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |
|   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |
|  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |
|     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |
|  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |
|   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |
|    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |

## Scaffolding Your First Vite Project

::: code-group

```bash [npm]
$ npm create vite@latest
```

```bash [Yarn]
$ yarn create vite
```

```bash [pnpm]
$ pnpm create vite
```

```bash [Bun]
$ bun create vite
```

```bash [Deno]
$ deno init --npm vite
```

:::

Then follow the prompts!

::: tip Compatibility Note
Vite requires [Node.js](https://nodejs.org/en/) version 20.19+, 22.12+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
:::

:::: details Using create vite with command line options

You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:

::: code-group

```bash [npm]
# npm 7+, extra double-dash is needed:
$ npm create vite@latest my-vue-app -- --template vue
```

```bash [Yarn]
$ yarn create vite my-vue-app --template vue
```

```bash [pnpm]
$ pnpm create vite my-vue-app --template vue
```

```bash [Bun]
$ bun create vite my-vue-app --template vue
```

```bash [Deno]
$ deno init --npm vite my-vue-app --template vue
```

:::

See [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) for more details on each supported template: `vanilla`, `vanilla-ts`, `vue`, `vue-ts`, `react`, `react-ts`, `react-swc`, `react-swc-ts`, `preact`, `preact-ts`, `lit`, `lit-ts`, `svelte`, `svelte-ts`, `solid`, `solid-ts`, `qwik`, `qwik-ts`.

You can use `.` for the project name to scaffold in the current directory.

::::

## Community Templates

create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks.

For a template at `https://github.com/user/project`, you can try it out online using `https://github.stackblitz.com/user/project` (adding `.stackblitz` after `github` to the URL of the project).

You can also use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates. Assuming the project is on GitHub and uses `main` as the default branch, you can create a local copy using:

```bash
npx degit user/project#main my-project
cd my-project

npm install
npm run dev
```

## Manual Installation

In your project, you can install the `vite` CLI using:

::: code-group

```bash [npm]
$ npm install -D vite
```

```bash [Yarn]
$ yarn add -D vite
```

```bash [pnpm]
$ pnpm add -D vite
```

```bash [Bun]
$ bun add -D vite
```

```bash [Deno]
$ deno add -D npm:vite
```

:::

And create an `index.html` file like this:

```html
<p>Hello Vite!</p>
```

Then run the appropriate CLI command in your terminal:

::: code-group

```bash [npm]
$ npx vite
```

```bash [Yarn]
$ yarn vite
```

```bash [pnpm]
$ pnpm vite
```

```bash [Bun]
$ bunx vite
```

```bash [Deno]
$ deno run -A npm:vite
```

:::

The `index.html` will be served on `http://localhost:5173`.

## `index.html` and Project Root

One thing you may have noticed is that in a Vite project, `index.html` is front-and-central instead of being tucked away inside `public`. This is intentional: during development Vite is a server, and `index.html` is the entry point to your application.

Vite treats `index.html` as source code and part of the module graph. It resolves `<script type="module" src="...">` that references your JavaScript source code. Even inline `<script type="module">` and CSS referenced via `<link href>` also enjoy Vite-specific features. In addition, URLs inside `index.html` are automatically rebased so there's no need for special `%PUBLIC_URL%` placeholders.

Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as `<root>` throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.

Vite also supports [multi-page apps](./build#multi-page-app) with multiple `.html` entry points.

#### Specifying Alternative Root

Running `vite` starts the dev server using the current working directory as root. You can specify an alternative root with `vite serve some/sub/dir`.
Note that Vite will also resolve [its config file (i.e. `vite.config.js`)](/config/#configuring-vite) inside the project root, so you'll need to move it if the root is changed.

## Command Line Interface

In a project where Vite is installed, you can use the `vite` binary in your npm scripts, or run it directly with `npx vite`. Here are the default npm scripts in a scaffolded Vite project:

<!-- prettier-ignore -->
```json [package.json]
{
  "scripts": {
    "dev": "vite", // start dev server, aliases: `vite dev`, `vite serve`
    "build": "vite build", // build for production
    "preview": "vite preview" // locally preview production build
  }
}
```

You can specify additional CLI options like `--port` or `--open`. For a full list of CLI options, run `npx vite --help` in your project.

Learn more about the [Command Line Interface](./cli.md)

## Using Unreleased Commits

If you can't wait for a new release to test the latest features, you can install a specific commit of Vite with https://pkg.pr.new:

::: code-group

```bash [npm]
$ npm install -D https://pkg.pr.new/vite@SHA
```

```bash [Yarn]
$ yarn add -D https://pkg.pr.new/vite@SHA
```

```bash [pnpm]
$ pnpm add -D https://pkg.pr.new/vite@SHA
```

```bash [Bun]
$ bun add -D https://pkg.pr.new/vite@SHA
```

:::

Replace `SHA` with any of [Vite's commit SHAs](https://github.com/vitejs/vite/commits/main/). Note that only commits within the last month will work, as older commit releases are purged.

Alternatively, you can also clone the [vite repo](https://github.com/vitejs/vite) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):

```bash
git clone https://github.com/vitejs/vite.git
cd vite
pnpm install
cd packages/vite
pnpm run build
pnpm link --global # use your preferred package manager for this step
```

Then go to your Vite based project and run `pnpm link --global vite` (or the package manager that you used to link `vite` globally). Now restart the development server to ride on the bleeding edge!

::: tip Dependencies using Vite
To replace the Vite version used by dependencies transitively, you should use [npm overrides](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#overrides) or [pnpm overrides](https://pnpm.io/9.x/package_json#pnpmoverrides).
:::

## Community

If you have questions or need help, reach out to the community at [Discord](https://chat.vite.dev) and [GitHub Discussions](https://github.com/vitejs/vite/discussions).



================================================
FILE: docs/guide/migration.md
================================================
# Migration from v6

## Node.js Support

Vite no longer supports Node.js 18, which reached its EOL. Node.js 20.19+ / 22.12+ is now required.

## Default Browser Target change

The default browser value of `build.target` is updated to a newer browser.

- Chrome 87 → 107
- Edge 88 → 107
- Firefox 78 → 104
- Safari 14.0 → 16.0

These browser versions align with [Baseline](https://web-platform-dx.github.io/web-features/) Widely Available feature sets as of 2025-05-01. In other words, they were all released before 2022-11-01.

In Vite 5, the default target was named `'modules'`, but this is no longer available. Instead, a new default target `'baseline-widely-available'` is introduced.

## General Changes

### Removed Sass legacy API support

As planned, support for the Sass legacy API is removed. Vite now only supports the modern API. You can remove the `css.preprocessorOptions.sass.api` / `css.preprocessorOptions.scss.api` option.

## Removed deprecated features

- `splitVendorChunkPlugin` (deprecated in v5.2.7)
  - This plugin was originally provided to ease migration to Vite v2.9.
  - The `build.rollupOptions.output.manualChunks` option can be used to control the chunking behavior if needed.
- Hook-level `enforce` / `transform` for `transformIndexHtml` (deprecated in v4.0.0)
  - It was changed to align the interface with [Rollup's object hooks](https://rollupjs.org/plugin-development/#build-hooks:~:text=Instead%20of%20a%20function%2C%20hooks%20can%20also%20be%20objects.).
  - `order` should be used instead of `enforce`, and `handler` should be used instead of `transform`.

## Advanced

There are other breaking changes which only affect few users.

- [[#19979] chore: declare version range for peer dependencies](https://github.com/vitejs/vite/pull/19979)
  - Specified the peer dependencies version range for CSS preprocessors.
- [[#20013] refactor: remove no-op `legacy.proxySsrExternalModules`](https://github.com/vitejs/vite/pull/20013)
  - `legacy.proxySsrExternalModules` property had no effect since Vite 6. It is now removed.
- [[#19985] refactor!: remove deprecated no-op type only properties](https://github.com/vitejs/vite/pull/19985)
  - The following unused properties are now removed: `ModuleRunnerOptions.root`, `ViteDevServer._importGlobMap`, `ResolvePluginOptions.isFromTsImporter`, `ResolvePluginOptions.getDepsOptimizer`, `ResolvePluginOptions.shouldExternalize`, `ResolvePluginOptions.ssrConfig`
- [[#19986] refactor: remove deprecated env api properties](https://github.com/vitejs/vite/pull/19986)
  - These properties were deprecated from the beginning. It is now removed.
- [[#19987] refactor!: remove deprecated `HotBroadcaster` related types](https://github.com/vitejs/vite/pull/19987)
  - These types were introduced as part of the now-deprecated Runtime API. It is now removed: `HMRBroadcaster`, `HMRBroadcasterClient`, `ServerHMRChannel`, `HMRChannel`
- [[#19996] fix(ssr)!: don't access `Object` variable in ssr transformed code](https://github.com/vitejs/vite/pull/19996)
  - `__vite_ssr_exportName__` is now required for the module runner runtime context.
- [[#20045] fix: treat all `optimizeDeps.entries` values as globs](https://github.com/vitejs/vite/pull/20045)
  - `optimizeDeps.entries` now does not receive literal string paths. Instead, it always receives globs.
- [[#20222] feat: apply some middlewares before `configureServer` hook](https://github.com/vitejs/vite/pull/20222), [[#20224] feat: apply some middlewares before `configurePreviewServer` hook](https://github.com/vitejs/vite/pull/20224)
  - Some middlewares are now applied before the `configureServer` / `configurePreviewServer` hook. Note that if you don't expect a certain route to apply the [`server.cors`](../config/server-options.md#server-cors) / [`preview.cors`](../config/preview-options.md#preview-cors) option, make sure to remove the related headers from the response.

## Migration from v5

Check the [Migration from v5 Guide](https://v6.vite.dev/guide/migration.html) in the Vite v6 docs first to see the needed changes to port your app to Vite 6, and then proceed with the changes on this page.



================================================
FILE: docs/guide/performance.md
================================================
# Performance

While Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:

- Slow server starts
- Slow page loads
- Slow builds

## Review Your Browser Setup

Some browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.

The Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact on startup and full-page reload times. Please check that "Disable Cache" isn't enabled while you work with the Vite server.

## Audit Configured Vite Plugins

Vite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.

However, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:

1. Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: [vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) and [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244).

2. The `buildStart`, `config`, and `configResolved` hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.

3. The `resolveId`, `load`, and `transform` hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the `code` contains a specific keyword, or the `id` matches a specific extension, before doing the full transformation.

   The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.

   You can inspect the duration it takes to transform a file using `vite --debug plugin-transform` or [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect). Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.

::: tip Profiling
You can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vite.dev) with the Vite team to help us identify performance issues.
:::

## Reduce Resolve Operations

Resolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports "guessing" import paths with the [`resolve.extensions`](/config/shared-options.md#resolve-extensions) option, which defaults to `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`.

When you try to import `./Component.jsx` with `import './Component'`, Vite will run these steps to resolve it:

1. Check if `./Component` exists, no.
2. Check if `./Component.mjs` exists, no.
3. Check if `./Component.js` exists, no.
4. Check if `./Component.mts` exists, no.
5. Check if `./Component.ts` exists, no.
6. Check if `./Component.jsx` exists, yes!

As shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.

Hence, it's usually better to be explicit with your import paths, e.g. `import './Component.jsx'`. You can also narrow down the list for `resolve.extensions` to reduce the general filesystem checks, but you have to make sure it works for files in `node_modules` too.

If you're a plugin author, make sure to only call [`this.resolve`](https://rollupjs.org/plugin-development/#this-resolve) when needed to reduce the number of checks above.

::: tip TypeScript
If you are using TypeScript, enable `"moduleResolution": "bundler"` and `"allowImportingTsExtensions": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.
:::

## Avoid Barrel Files

Barrel files are files that re-export the APIs of other files in the same directory. For example:

```js [src/utils/index.js]
export * from './color.js'
export * from './dom.js'
export * from './slash.js'
```

When you only import an individual API, e.g. `import { slash } from './utils'`, all the files in that barrel file need to be fetched and transformed as they may contain the `slash` API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.

If possible, you should avoid barrel files and import the individual APIs directly, e.g. `import { slash } from './utils/slash.js'`. You can read [issue #8237](https://github.com/vitejs/vite/issues/8237) for more information.

## Warm Up Frequently Used Files

The Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:

Given an import graph where the left file imports the right file:

```
main.js -> BigComponent.vue -> big-utils.js -> large-data.json
```

The import relationship can only be known after the file is transformed. If `BigComponent.vue` takes some time to transform, `big-utils.js` has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.

Vite allows you to warm up files that you know are frequently used, e.g. `big-utils.js`, using the [`server.warmup`](/config/server-options.md#server-warmup) option. This way `big-utils.js` will be ready and cached to be served immediately when requested.

You can find files that are frequently used by running `vite --debug transform` and inspect the logs:

```bash
vite:transform 28.72ms /@vite/client +1ms
vite:transform 62.95ms /src/components/BigComponent.vue +1ms
vite:transform 102.54ms /src/utils/big-utils.js +1ms
```

```js [vite.config.js]
export default defineConfig({
  server: {
    warmup: {
      clientFiles: [
        './src/components/BigComponent.vue',
        './src/utils/big-utils.js',
      ],
    },
  },
})
```

Note that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the [`server.warmup`](/config/server-options.md#server-warmup) option for more information.

Using [`--open` or `server.open`](/config/server-options.html#server-open) also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.

## Use Lesser or Native Tooling

Keeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).

Examples of doing less work:

- Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)
- Don't transform SVGs into UI framework components (React, Vue, etc.). Import them as strings or URLs instead.
- When using `@vitejs/plugin-react`, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).

Examples of using native tooling:

Using native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.

- Use [Rolldown instead of Rollup and esbuild](./rolldown) for faster builds and a more aligned experience between dev and build.
- Try out the experimental support for [LightningCSS](https://github.com/vitejs/vite/discussions/13835)
- Use [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) in place of `@vitejs/plugin-react`.



================================================
FILE: docs/guide/philosophy.md
================================================
# Project Philosophy

## Lean Extendable Core

Vite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but [Vite core](https://github.com/vitejs/vite) must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to [Vite's rollup-based plugin system](./api-plugin.md). Features that can be implemented as external plugins will generally not be added to Vite core. [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) is a great example of what can be achieved out of Vite core, and there are a lot of [well maintained plugins](https://github.com/vitejs/awesome-vite#plugins) to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.

## Pushing the Modern Web

Vite provides opinionated features that push writing modern code. For example:

- The source code can only be written in ESM, where non-ESM dependencies need to be [pre-bundled as ESM](./dep-pre-bundling) in order to work.
- Web workers are encouraged to be written with the [`new Worker` syntax](./features#web-workers) to follow modern standards.
- Node.js modules cannot be used in the browser.

When adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.

## A Pragmatic Approach to Performance

Vite has been focused on performance since its [origins](./why.md). Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like [esbuild](https://esbuild.github.io/) and [SWC](https://github.com/vitejs/vite-plugin-react-swc) to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into [Babel](https://babeljs.io/) to compile user code. And during build time Vite currently uses [Rollup](https://rollupjs.org/) where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.

## Building Frameworks on Top of Vite

Although Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI framework. Its [JS API](./api-javascript.md) allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for [SSR primitives](./ssr.md), usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with [Backend frameworks](./backend-integration.md) like [Ruby](https://vite-ruby.netlify.app/) and [Laravel](https://laravel.com/docs/10.x/vite).

## An Active Ecosystem

Vite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci). It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join [Vite's Discord](https://chat.vite.dev) and get involved in the project too.



================================================
FILE: docs/guide/rolldown.md
================================================
# Rolldown Integration

Vite is planning to integrate [Rolldown](https://rolldown.rs), a Rust-powered JavaScript bundler, to improve build performance and capabilities.

<YouTubeVideo videoId="RRjfm8cMveQ" />

## What is Rolldown?

Rolldown is a modern, high-performance JavaScript bundler written in Rust. It's designed as a drop-in replacement for Rollup, aiming to provide significant performance improvements while maintaining compatibility with the existing ecosystem.

Rolldown focuses on three key principles:

- **Speed**: Built with Rust for maximum performance
- **Compatibility**: Works with existing Rollup plugins
- **Optimization**: Comes with features that go beyond what esbuild and Rollup implement

## Why Vite is Migrating to Rolldown

1. **Unification**: Vite currently uses esbuild for dependency pre-bundling and Rollup for production builds. Rolldown aims to unify these into a single, high-performance bundler that can be used for both purposes, reducing complexity.

2. **Performance**: Rolldown's Rust-based implementation offers significant performance improvements over JavaScript-based bundlers. While specific benchmarks may vary by project size and complexity, early tests show promising speed increases compared to Rollup.

3. **Additional Features**: Rolldown introduces features that are not available in Rollup or esbuild, such as advanced chunk splitting control, built-in HMR, and Module Federation.

For additional insights on the motivations behind Rolldown, see the [reasons why Rolldown is being built](https://rolldown.rs/guide/#why-rolldown).

## Benefits of Trying `rolldown-vite`

- Experience significantly faster build times, especially for larger projects
- Provide valuable feedback to help shape the future of Vite's bundling experience
- Prepare your projects for the eventual official Rolldown integration

## How to Try Rolldown

The rolldown-powered version of Vite is currently available as a separate package called `rolldown-vite`. If you have `vite` as a direct dependency, you can alias the `vite` package to `rolldown-vite` in your project's `package.json`, which should result in a drop-in replacement.

```json
{
  "dependencies": {
    "vite": "^7.0.0" // [!code --]
    "vite": "npm:rolldown-vite@latest" // [!code ++]
  }
}
```

If you use a Vitepress or a meta framework that has Vite as peer dependency, you have to override the `vite` dependency in your `package.json`, which works slightly different depending on your package manager:

:::code-group

```json [npm]
{
  "overrides": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

```json [Yarn]
{
  "resolutions": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

```json [pnpm]
{
  "pnpm": {
    "overrides": {
      "vite": "npm:rolldown-vite@latest"
    }
  }
}
```

```json [Bun]
{
  "overrides": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

:::

After adding these overrides, reinstall your dependencies and start your development server or build your project as usual. No further configuration changes are required.

## Known Limitations

While Rolldown aims to be a drop-in replacement for Rollup, there are features that are still being implemented and minor intentional behavior differences. For a comprehensive list, please refer to [this GitHub PR](https://github.com/vitejs/rolldown-vite/pull/84#issue-2903144667) which is regularly updated.

### Option Validation Warnings

Rolldown outputs an warning when unknown or invalid options are passed. Because some options available in Rollup are not supported by Rolldown, you may encounter warnings based on the options you or the meta framework you use set. Below, you can find an example of such an warning message:

> Warning validate output options.
>
> - For the "generatedCode". Invalid key: Expected never but received "generatedCode".

If you don't pass the option in yourself, this must be fixed by the utilized framework.

### API Differences

#### `manualChunks` to `advancedChunks`

While Rolldown has support for the `manualChunks` option that is also exposed by Rollup, it is marked deprecated. Instead of it, Rolldown offers a more fine-grained setting via the [`advancedChunks` option](https://rolldown.rs/guide/in-depth/advanced-chunks#advanced-chunks), which is more similar to webpack's `splitChunk`:

```js
// Old configuration (Rollup)
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (/\/react(?:-dom)?/.test(id)) {
            return 'vendor'
          }
        }
      }
    }
  }
}

// New configuration (Rolldown)
export default {
  build: {
    rollupOptions: {
      output: {
        advancedChunks: {
          groups: [{ name: 'vendor', test: /\/react(?:-dom)?/ }]
        }
      }
    }
  }
}
```

## Performance

`rolldown-vite` is focused on ensuring compatibility with the existing ecosystem, so defaults are geared towards a smooth transition. You can get further performance gains by switching over to faster Rust-based internal plugins and other customizations.

### Enabling Native Plugins

Thanks to Rolldown and Oxc, various internal Vite plugins, such as the alias or resolve plugin, have been converted to Rust. Native plugins are now enabled by default, with the default value set to `'v1'`.

If you encounter any issues, you can change the `experimental.enableNativePlugin` option in your Vite config to `'resolver'` or `false` as a workaround. Note that this option will be removed in the future.

### Utilizing Oxc's React refresh transform

`@vitejs/plugin-react` v5.0.0+ uses Oxc's React refresh transform. If you are not using any Babel plugins (including the React compiler), the full transform would now be done by Oxc and will improve the build performance without any changes other than updating `@vitejs/plugin-react`.

If you are using `@vitejs/plugin-react-swc` without SWC plugins and custom SWC options, you can switch to the `@vitejs/plugin-react` plugin to utilize Oxc.

::: details `@vitejs/plugin-react-oxc` plugin is deprecated

Previously, we recommended using `@vitejs/plugin-react-oxc` to utilize Oxc's React refresh transform. However, we have merged the implementation into `@vitejs/plugin-react` so that it is easier to switch to `rolldown-vite`. `@vitejs/plugin-react-oxc` is now deprecated and will no longer be updated.

:::

### `withFilter` Wrapper

Plugin authors have the option to use the [hook filter feature](#hook-filter-feature) to reduce the communication overhead between the Rust and JavaScript runtimes.
But in case some of the used plugins are not using this feature (yet) but you still want to benefit from it, you can use the `withFilter` wrapper to wrap the plugin with a filter yourself.

```js
// In your vite.config.ts
import { withFilter, defineConfig } from 'vite'
import svgr from 'vite-plugin-svgr'

export default defineConfig({
  plugins: [
    // Load the `svgr` plugin only for files which end in `.svg?react`
    withFilter(
      svgr({
        /*...*/
      }),
      { load: { id: /\.svg\?react$/ } },
    ),
  ],
})
```

## Reporting Issues

Since this is an experimental integration, you may encounter issues. If you do, please report them in the [`vitejs/rolldown-vite`](https://github.com/vitejs/rolldown-vite) repository, **not the main Vite repository**.

When [reporting issues](https://github.com/vitejs/rolldown-vite/issues/new), please follow the appropriate issue template and provide what is requested there, commonly including:

- A minimal reproduction of the issue
- Your environment details (OS, Node version, package manager)
- Any relevant error messages or logs

For real-time discussions and troubleshooting, make sure to join the [Rolldown Discord](https://chat.rolldown.rs/).

## Versioning Policy

The versioning policy for `rolldown-vite` aligns its major and minor versions with those of the normal Vite package. This synchronization ensures that features present in a specific normal Vite minor release are also included in the corresponding `rolldown-vite` minor release. However, it's important to note that patch versions are not synchronized between the two projects. If you're wondering whether a specific change from normal Vite has been included in `rolldown-vite`, you can always check [`rolldown-vite`'s separate changelog](https://github.com/vitejs/rolldown-vite/blob/rolldown-vite/packages/vite/CHANGELOG.md) for confirmation.

Furthermore, please be aware that `rolldown-vite` itself is considered experimental. Due to its experimental nature, breaking changes might be introduced even within its patch versions. Additionally, please note that `rolldown-vite` only receives updates for its most recent minor version. Even for important security or bug fixes, patches are not created for older major or minor versions.

## Future Plans

The `rolldown-vite` package is a temporary solution to gather feedback and stabilize the Rolldown integration. In the future, this functionality will be merged back into the main Vite repository.

We encourage you to try out `rolldown-vite` and contribute to its development through feedback and issue reports.

In the future, we will also introduce a "Full Bundle Mode" for Vite, which will serve bundled files in production _and development mode_.

### Why introducing a Full Bundle Mode?

Vite is known for its unbundled dev server approach, which is a main reason for Vite's speed and popularity when it was first introduced. This approach was initially an experiment to see just how far we could push the boundaries of development server performance without traditional bundling.

However, as projects scale in size and complexity, two main challenges have emerged:

1. **Development/Production inconsistency**: The unbundled JavaScript served in development versus the bundled production build creates different runtime behaviors. This can lead to issues that only manifest in production, making debugging more difficult.

2. **Performance degradation during development**: The unbundled approach results in each module being fetched separately, which creates a large number of network requests. While this has _no impact in production_, it causes significant overhead during dev server startup and when refreshing the page in development. The impact is especially noticeable in large applications where hundreds or even thousands of separate requests must be processed. These bottlenecks become even more severe when developers use network proxy, resulting in slower refresh times and degraded developer experience.

With the Rolldown integration, we have an opportunity to unify the development and production experiences while maintaining Vite's signature performance. A Full Bundle Mode would allow serving bundled files not only in production but also during development, combining the best of both worlds:

- Fast startup times even for large applications
- Consistent behavior between development and production
- Reduced network overhead on page refreshes
- Maintained efficient HMR on top of ESM output

When the Full Bundle Mode is introduced, it will be an opt-in feature at first. Similar to the Rolldown integration, we are aiming to make it the default after gathering feedback and ensuring stability.

## Plugin / Framework Authors Guide

::: tip
This section is mostly relevant for plugin and framework authors. If you are a user, you can skip this section.
:::

### Overview of Major Changes

- Rolldown is used for build (Rollup was used before)
- Rolldown is used for the optimizer (esbuild was used before)
- CommonJS support is handled by Rolldown (@rollup/plugin-commonjs was used before)
- Oxc is used for syntax lowering (esbuild was used before)
- Lightning CSS is used for CSS minification by default (esbuild was used before)
- Oxc minifier is used for JS minification by default (esbuild was used before)
- Rolldown is used for bundling the config (esbuild was used before)

### Detecting `rolldown-vite`

::: warning
In most cases, you don't need to detect whether your plugin runs with `rolldown-vite` or `vite` and you should aim for consistent behavior across both, without conditional branching.
:::

In case you need different behavior with `rolldown-vite`, you have two ways to detect if `rolldown-vite` is used:

Checking the existence of `this.meta.rolldownVersion`:

```js
const plugin = {
  resolveId() {
    if (this.meta.rolldownVersion) {
      // logic for rolldown-vite
    } else {
      // logic for rollup-vite
    }
  },
}
```

::: tip

Since Vite 7.0.0, `this.meta` is available in all hooks. In previous versions, `this.meta` was not available in Vite-specific hooks, such as the `config` hook.

:::

<br>

Checking the existence of the `rolldownVersion` export:

```js
import * as vite from 'vite'

if (vite.rolldownVersion) {
  // logic for rolldown-vite
} else {
  // logic for rollup-vite
}
```

If you have `vite` as a dependency (not a peer dependency), the `rolldownVersion` export is useful as it can be used from anywhere in your code.

### Ignoring option validation in Rolldown

As [mentioned above](#option-validation-errors), Rolldown outputs a warning when unknown or invalid options are passed.

This can be fixed by conditionally passing the option by checking whether it's running with `rolldown-vite` as [shown above](#detecting-rolldown-vite).

### `transformWithEsbuild` requires `esbuild` to be installed separately

Since Vite itself does not use `esbuild` any more, `esbuild` is now an optional peer dependency. If your plugin uses `transformWithEsbuild`, the plugin needs to add `esbuild` to its dependencies or the user needs to install it manually.

The recommended migration is to use the newly exported `transformWithOxc` function, which utilizes Oxc instead of `esbuild`.

### Compatibility layer for `esbuild` options

Rolldown-Vite has a compatibility layer to convert options for `esbuild` to the respective Oxc or `rolldown` ones. As tested in [the ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci/blob/rolldown-vite/README-temp.md), this works in many cases, including simple `esbuild` plugins.
That said, **we'll be removing the `esbuild` options support in the future** and encourage you to try the corresponding Oxc or `rolldown` options.
You can get the options set by the compatibility layer from the `configResolved` hook.

```js
const plugin = {
  name: 'log-config',
  configResolved(config) {
    console.log('options', config.optimizeDeps, config.oxc)
  },
},
```

### Hook filter feature

Rolldown introduced a [hook filter feature](https://rolldown.rs/guide/plugin-development#plugin-hook-filters) to reduce the communication overhead the between Rust and JavaScript runtimes. By using this feature you can make your plugin more performant.
This is also supported by Rollup 4.38.0+ and Vite 6.3.0+. To make your plugin backward compatible with the older versions, make sure to also run the filter inside the hook handlers.

::: tip

[`@rolldown/pluginutils`](https://www.npmjs.com/package/@rolldown/pluginutils) exports some utilities for hook filters like `exactRegex` and `prefixRegex`.

:::

### Converting content to JavaScript in `load` or `transform` hooks

If you are converting the content to JavaScript from other types in `load` or `transform` hooks, you may need to add `moduleType: 'js'` to the returned value.

```js
const plugin = {
  name: 'txt-loader',
  load(id) {
    if (id.endsWith('.txt')) {
      const content = fs.readFile(id, 'utf-8')
      return {
        code: `export default ${JSON.stringify(content)}`,
        moduleType: 'js', // [!code ++]
      }
    }
  },
}
```

This is because [Rolldown supports non-JavaScript modules](https://rolldown.rs/guide/in-depth/module-types) and infers the module type from extensions unless specified.



================================================
FILE: docs/guide/ssr.md
================================================
# Server-Side Rendering (SSR)

:::tip Note
SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](./backend-integration) instead.

The following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.
:::

:::warning Low-level API
This is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first. That said, many applications are successfully built directly on top of Vite's native low-level API.

Currently, Vite is working on an improved SSR API with the [Environment API](https://github.com/vitejs/vite/discussions/16358). Check out the link for more details.
:::

## Example Projects

Vite provides built-in support for server-side rendering (SSR). [`create-vite-extra`](https://github.com/bluwy/create-vite-extra) contains example SSR setups you can use as references for this guide:

- [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)
- [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)
- [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)
- [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)
- [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)
- [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)

You can also scaffold these projects locally by [running `create-vite`](./index.md#scaffolding-your-first-vite-project) and choose `Others > create-vite-extra` under the framework option.

## Source Structure

A typical SSR application will have the following source file structure:

```
- index.html
- server.js # main application server
- src/
  - main.js          # exports env-agnostic (universal) app code
  - entry-client.js  # mounts the app to a DOM element
  - entry-server.js  # renders the app using the framework's SSR API
```

The `index.html` will need to reference `entry-client.js` and include a placeholder where the server-rendered markup should be injected:

```html [index.html]
<div id="app"><!--ssr-outlet--></div>
<script type="module" src="/src/entry-client.js"></script>
```

You can use any placeholder you prefer instead of `<!--ssr-outlet-->`, as long as it can be precisely replaced.

## Conditional Logic

If you need to perform conditional logic based on SSR vs. client, you can use

```js twoslash
import 'vite/client'
// ---cut---
if (import.meta.env.SSR) {
  // ... server only logic
}
```

This is statically replaced during build so it will allow tree-shaking of unused branches.

## Setting Up the Dev Server

When building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with [express](https://expressjs.com/):

```js{15-18} twoslash [server.js]
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'
import { createServer as createViteServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

async function createServer() {
  const app = express()

  // Create Vite server in middleware mode and configure the app type as
  // 'custom', disabling Vite's own HTML serving logic so parent server
  // can take control
  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: 'custom'
  })

  // Use vite's connect instance as middleware. If you use your own
  // express router (express.Router()), you should use router.use
  // When the server restarts (for example after the user modifies
  // vite.config.js), `vite.middlewares` is still going to be the same
  // reference (with a new internal stack of Vite and plugin-injected
  // middlewares). The following is valid even after restarts.
  app.use(vite.middlewares)

  app.use('*all', async (req, res) => {
    // serve index.html - we will tackle this next
  })

  app.listen(5173)
}

createServer()
```

Here `vite` is an instance of [ViteDevServer](./api-javascript#vitedevserver). `vite.middlewares` is a [Connect](https://github.com/senchalabs/connect) instance which can be used as a middleware in any connect-compatible Node.js framework.

The next step is implementing the `*` handler to serve server-rendered HTML:

```js twoslash [server.js]
// @noErrors
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

/** @type {import('express').Express} */
var app
/** @type {import('vite').ViteDevServer}  */
var vite

// ---cut---
app.use('*all', async (req, res, next) => {
  const url = req.originalUrl

  try {
    // 1. Read index.html
    let template = fs.readFileSync(
      path.resolve(__dirname, 'index.html'),
      'utf-8',
    )

    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,
    //    and also applies HTML transforms from Vite plugins, e.g. global
    //    preambles from @vitejs/plugin-react
    template = await vite.transformIndexHtml(url, template)

    // 3. Load the server entry. ssrLoadModule automatically transforms
    //    ESM source code to be usable in Node.js! There is no bundling
    //    required, and provides efficient invalidation similar to HMR.
    const { render } = await vite.ssrLoadModule('/src/entry-server.js')

    // 4. render the app HTML. This assumes entry-server.js's exported
    //     `render` function calls appropriate framework SSR APIs,
    //    e.g. ReactDOMServer.renderToString()
    const appHtml = await render(url)

    // 5. Inject the app-rendered HTML into the template.
    const html = template.replace(`<!--ssr-outlet-->`, () => appHtml)

    // 6. Send the rendered HTML back.
    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
  } catch (e) {
    // If an error is caught, let Vite fix the stack trace so it maps back
    // to your actual source code.
    vite.ssrFixStacktrace(e)
    next(e)
  }
})
```

The `dev` script in `package.json` should also be changed to use the server script instead:

```diff [package.json]
  "scripts": {
-   "dev": "vite"
+   "dev": "node server"
  }
```

## Building for Production

To ship an SSR project for production, we need to:

1. Produce a client build as normal;
2. Produce an SSR build, which can be directly loaded via `import()` so that we don't have to go through Vite's `ssrLoadModule`;

Our scripts in `package.json` will look like this:

```json [package.json]
{
  "scripts": {
    "dev": "node server",
    "build:client": "vite build --outDir dist/client",
    "build:server": "vite build --outDir dist/server --ssr src/entry-server.js"
  }
}
```

Note the `--ssr` flag which indicates this is an SSR build. It should also specify the SSR entry.

Then, in `server.js` we need to add some production specific logic by checking `process.env.NODE_ENV`:

- Instead of reading the root `index.html`, use the `dist/client/index.html` as the template, since it contains the correct asset links to the client build.

- Instead of `await vite.ssrLoadModule('/src/entry-server.js')`, use `import('./dist/server/entry-server.js')` (this file is the result of the SSR build).

- Move the creation and all usage of the `vite` dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from `dist/client`.

Refer to the [example projects](#example-projects) for a working setup.

## Generating Preload Directives

`vite build` supports the `--ssrManifest` flag which will generate `.vite/ssr-manifest.json` in build output directory:

```diff
- "build:client": "vite build --outDir dist/client",
+ "build:client": "vite build --outDir dist/client --ssrManifest",
```

The above script will now generate `dist/client/.vite/ssr-manifest.json` for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.

To leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.

`@vitejs/plugin-vue` supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:

```js [src/entry-server.js]
const ctx = {}
const html = await vueServerRenderer.renderToString(app, ctx)
// ctx.modules is now a Set of module IDs that were used during the render
```

In the production branch of `server.js` we need to read and pass the manifest to the `render` function exported by `src/entry-server.js`. This would provide us with enough information to render preload directives for files used by async routes! See [demo source](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) for a full example. You can also use this information for [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).

## Pre-Rendering / SSG

If the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See [demo pre-render script](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) for working example.

## SSR Externals

Dependencies are "externalized" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.

If a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to [`ssr.noExternal`](../config/ssr-options.md#ssr-noexternal).

For linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to [`ssr.external`](../config/ssr-options.md#ssr-external).

:::warning Working with Aliases
If you have configured aliases that redirect one package to another, you may want to alias the actual `node_modules` packages instead to make it work for SSR externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.
:::

## SSR-specific Plugin Logic

Some frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional `ssr` property in the `options` object of the following plugin hooks:

- `resolveId`
- `load`
- `transform`

**Example:**

```js twoslash
/** @type {() => import('vite').Plugin} */
// ---cut---
export function mySSRPlugin() {
  return {
    name: 'my-ssr',
    transform(code, id, options) {
      if (options?.ssr) {
        // perform ssr-specific transform...
      }
    },
  }
}
```

The options object in `load` and `transform` is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.

:::tip Note
Before Vite 2.7, this was informed to plugin hooks with a positional `ssr` param instead of using the `options` object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.
:::

## SSR Target

The default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the `ssr.target` set to `'webworker'`.

## SSR Bundle

In some cases like `webworker` runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting `ssr.noExternal` to `true`. This will do two things:

- Treat all dependencies as `noExternal`
- Throw an error if any Node.js built-ins are imported

## SSR Resolve Conditions

By default package entry resolution will use the conditions set in [`resolve.conditions`](../config/shared-options.md#resolve-conditions) for the SSR build. You can use [`ssr.resolve.conditions`](../config/ssr-options.md#ssr-resolve-conditions) and [`ssr.resolve.externalConditions`](../config/ssr-options.md#ssr-resolve-externalconditions) to customize this behavior.

## Vite CLI

The CLI commands `$ vite dev` and `$ vite preview` can also be used for SSR apps. You can add your SSR middlewares to the development server with [`configureServer`](/guide/api-plugin#configureserver) and to the preview server with [`configurePreviewServer`](/guide/api-plugin#configurepreviewserver).

:::tip Note
Use a post hook so that your SSR middleware runs _after_ Vite's middlewares.
:::



================================================
FILE: docs/guide/static-deploy-github-pages.yaml
================================================
# Imported in static-deploy.md
# This file is extracted as a separate file so that renovate can update the action versions
#
#region content
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ['main']

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow one concurrent deployment
concurrency:
  group: 'pages'
  cancel-in-progress: true

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Build
        run: npm run build
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload dist folder
          path: './dist'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
#endregion content



================================================
FILE: docs/guide/static-deploy.md
================================================
# Deploying a Static Site

The following guides are based on some shared assumptions:

- You are using the default build output location (`dist`). This location [can be changed using `build.outDir`](/config/build-options.md#build-outdir), and you can extrapolate instructions from these guides in that case.
- You are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.
- Vite is installed as a local dev dependency in your project, and you have setup the following npm scripts:

```json [package.json]
{
  "scripts": {
    "build": "vite build",
    "preview": "vite preview"
  }
}
```

It is important to note that `vite preview` is intended for previewing the build locally and not meant as a production server.

::: tip NOTE
These guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server-Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the [SSR Guide](./ssr) to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](./backend-integration) instead.
:::

## Building the App

You may run `npm run build` command to build the app.

```bash
$ npm run build
```

By default, the build output will be placed at `dist`. You may deploy this `dist` folder to any of your preferred platforms.

### Testing the App Locally

Once you've built the app, you may test it locally by running `npm run preview` command.

```bash
$ npm run preview
```

The `vite preview` command will boot up a local static web server that serves the files from `dist` at `http://localhost:4173`. It's an easy way to check if the production build looks OK in your local environment.

You may configure the port of the server by passing the `--port` flag as an argument.

```json [package.json]
{
  "scripts": {
    "preview": "vite preview --port 8080"
  }
}
```

Now the `preview` command will launch the server at `http://localhost:8080`.

## GitHub Pages

1. Set the correct `base` in `vite.config.js`.

   If you are deploying to `https://<USERNAME>.github.io/`, or to a custom domain through GitHub Pages (eg. `www.example.com`), set `base` to `'/'`. Alternatively, you can remove `base` from the configuration, as it defaults to `'/'`.

   If you are deploying to `https://<USERNAME>.github.io/<REPO>/` (eg. your repository is at `https://github.com/<USERNAME>/<REPO>`), then set `base` to `'/<REPO>/'`.

2. Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as "GitHub Actions", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:

   <<< ./static-deploy-github-pages.yaml#content

## GitLab Pages and GitLab CI

1. Set the correct `base` in `vite.config.js`.

   If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/`, you can omit `base` as it defaults to `'/'`.

   If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/<REPO>/`, for example your repository is at `https://gitlab.com/<USERNAME>/<REPO>`, then set `base` to `'/<REPO>/'`.

2. Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:

   ```yaml [.gitlab-ci.yml]
   image: node:lts
   pages:
     stage: deploy
     cache:
       key:
         files:
           - package-lock.json
         prefix: npm
       paths:
         - node_modules/
     script:
       - npm install
       - npm run build
       - cp -a dist/. public/
     artifacts:
       paths:
         - public
     rules:
       - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
   ```

## Netlify

### Netlify CLI

1. Install the [Netlify CLI](https://cli.netlify.com/).
2. Create a new site using `ntl init`.
3. Deploy using `ntl deploy`.

```bash
# Install the Netlify CLI
$ npm install -g netlify-cli

# Create a new site in Netlify
$ ntl init

# Deploy to a unique preview URL
$ ntl deploy
```

The Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the `prod` flag:

```bash
# Deploy the site into production
$ ntl deploy --prod
```

### Netlify with Git

1. Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).
2. [Import the project](https://app.netlify.com/start) to Netlify.
3. Choose the branch, output directory, and set up environment variables if applicable.
4. Click on **Deploy**.
5. Your Vite app is deployed!

After your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate [Preview Deployments](https://docs.netlify.com/site-deploys/deploy-previews/), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://docs.netlify.com/site-deploys/overview/#definitions).

## Vercel

### Vercel CLI

1. Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.
2. Vercel will detect that you are using Vite and will enable the correct settings for your deployment.
3. Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))

```bash
$ npm i -g vercel
$ vercel init vite
Vercel CLI
> Success! Initialized "vite" example in ~/your-folder.
- To deploy, `cd vite` and run `vercel`.
```

### Vercel for Git

1. Push your code to your git repository (GitHub, GitLab, Bitbucket).
2. [Import your Vite project](https://vercel.com/new) into Vercel.
3. Vercel will detect that you are using Vite and will enable the correct settings for your deployment.
4. Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))

After your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/environments#preview), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).

Learn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).

## Cloudflare Pages

### Cloudflare Pages via Wrangler

1. Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).
2. Authenticate Wrangler with your Cloudflare account using `wrangler login`.
3. Run your build command.
4. Deploy using `npx wrangler pages deploy dist`.

```bash
# Install Wrangler CLI
$ npm install -g wrangler

# Login to Cloudflare account from CLI
$ wrangler login

# Run your build command
$ npm run build

# Create new deployment
$ npx wrangler pages deploy dist
```

After your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.

### Cloudflare Pages with Git

1. Push your code to your git repository (GitHub, GitLab).
2. Log in to the Cloudflare dashboard and select your account in **Account Home** > **Pages**.
3. Select **Create a new Project** and the **Connect Git** option.
4. Select the git project you want to deploy and click **Begin setup**
5. Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.
6. Then save and deploy!
7. Your application is deployed! (e.g `https://<PROJECTNAME>.pages.dev/`)

After your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://developers.cloudflare.com/pages/platform/preview-deployments/) unless specified not to in your [branch build controls](https://developers.cloudflare.com/pages/platform/branch-build-controls/). All changes to the Production Branch (commonly “main”) will result in a Production Deployment.

You can also add custom domains and handle custom build settings on Pages. Learn more about [Cloudflare Pages Git Integration](https://developers.cloudflare.com/pages/get-started/#manage-your-site).

## Google Firebase

1. Make sure you have [firebase-tools](https://www.npmjs.com/package/firebase-tools) installed.

2. Create `firebase.json` and `.firebaserc` at the root of your project with the following content:

   ```json [firebase.json]
   {
     "hosting": {
       "public": "dist",
       "ignore": [],
       "rewrites": [
         {
           "source": "**",
           "destination": "/index.html"
         }
       ]
     }
   }
   ```

   ```js [.firebaserc]
   {
     "projects": {
       "default": "<YOUR_FIREBASE_ID>"
     }
   }
   ```

3. After running `npm run build`, deploy using the command `firebase deploy`.

## Surge

1. First install [surge](https://www.npmjs.com/package/surge), if you haven’t already.

2. Run `npm run build`.

3. Deploy to surge by typing `surge dist`.

You can also deploy to a [custom domain](http://surge.sh/help/adding-a-custom-domain) by adding `surge dist yourdomain.com`.

## Azure Static Web Apps

You can quickly deploy your Vite app with Microsoft Azure [Static Web Apps](https://aka.ms/staticwebapps) service. You need:

- An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).
- Your app code pushed to [GitHub](https://github.com).
- The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com).

Install the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.

Follow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location `/dist`. The wizard will run and will create a GitHub action in your repo in a `.github` folder.

The action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.

## Render

You can deploy your Vite app as a Static Site on [Render](https://render.com/).

1. Create a [Render account](https://dashboard.render.com/register).

2. In the [Dashboard](https://dashboard.render.com/), click the **New** button and select **Static Site**.

3. Connect your GitHub/GitLab account or use a public repository.

4. Specify a project name and branch.
   - **Build Command**: `npm install && npm run build`
   - **Publish Directory**: `dist`

5. Click **Create Static Site**.

   Your app should be deployed at `https://<PROJECTNAME>.onrender.com/`.

By default, any new commit pushed to the specified branch will automatically trigger a new deployment. [Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) can be configured in the project settings.

You can also add a [custom domain](https://render.com/docs/custom-domains) to your project.

<!--
  NOTE: The sections below are reserved for more deployment platforms not listed above.
  Feel free to submit a PR that adds a new section with a link to your platform's
  deployment guide, as long as it meets these criteria:

  1. Users should be able to deploy their site for free.
  2. Free tier offerings should host the site indefinitely and are not time-bound.
     Offering a limited number of computation resource or site counts in exchange is fine.
  3. The linked guides should not contain any malicious content.

  The Vite team may change the criteria and audit the current list from time to time.
  If a section is removed, we will ping the original PR authors before doing so.
-->

## Flightcontrol

Deploy your static site using [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) by following these [instructions](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite).

## Kinsta Static Site Hosting

Deploy your static site using [Kinsta](https://kinsta.com/static-site-hosting/) by following these [instructions](https://kinsta.com/docs/react-vite-example/).

## xmit Static Site Hosting

Deploy your static site using [xmit](https://xmit.co) by following this [guide](https://xmit.dev/posts/vite-quickstart/).



================================================
FILE: docs/guide/troubleshooting.md
================================================
# Troubleshooting

See [Rollup's troubleshooting guide](https://rollupjs.org/troubleshooting/) for more information too.

If the suggestions here don't work, please try posting questions on [GitHub Discussions](https://github.com/vitejs/vite/discussions) or in the `#help` channel of [Vite Land Discord](https://chat.vite.dev).

## CLI

### `Error: Cannot find module 'C:\foo\bar&baz\vite\bin\vite.js'`

The path to your project folder may include `&`, which doesn't work with `npm` on Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).

You will need to either:

- Switch to another package manager (e.g. `pnpm`, `yarn`)
- Remove `&` from the path to your project

## Config

### This package is ESM only

When importing a ESM only package by `require`, the following error happens.

> Failed to resolve "foo". This package is ESM only but it was tried to load by `require`.

> Error [ERR_REQUIRE_ESM]: require() of ES Module /path/to/dependency.js from /path/to/vite.config.js not supported.
> Instead change the require of index.js in /path/to/vite.config.js to a dynamic import() which is available in all CommonJS modules.

In Node.js <=22, ESM files cannot be loaded by [`require`](https://nodejs.org/docs/latest-v22.x/api/esm.html#require) by default.

While it may work using [`--experimental-require-module`](https://nodejs.org/docs/latest-v22.x/api/modules.html#loading-ecmascript-modules-using-require), or Node.js >22, or in other runtimes, we still recommend converting your config to ESM by either:

- adding `"type": "module"` to the nearest `package.json`
- renaming `vite.config.js`/`vite.config.ts` to `vite.config.mjs`/`vite.config.mts`

## Dev Server

### Requests are stalled forever

If you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.

To solve this:

- Increase file descriptor limit by `ulimit`

  ```shell
  # Check current limit
  $ ulimit -Sn
  # Change limit (temporary)
  $ ulimit -Sn 10000 # You might need to change the hard limit too
  # Restart your browser
  ```

- Increase the following inotify related limits by `sysctl`

  ```shell
  # Check current limits
  $ sysctl fs.inotify
  # Change limits (temporary)
  $ sudo sysctl fs.inotify.max_queued_events=16384
  $ sudo sysctl fs.inotify.max_user_instances=8192
  $ sudo sysctl fs.inotify.max_user_watches=524288
  ```

If the above steps don't work, you can try adding `DefaultLimitNOFILE=65536` as an un-commented config to the following files:

- /etc/systemd/system.conf
- /etc/systemd/user.conf

For Ubuntu Linux, you may need to add the line `* - nofile 65536` to the file `/etc/security/limits.conf` instead of updating systemd config files.

Note that these settings persist but a **restart is required**.

Alternatively, if the server is running inside a VS Code devcontainer, the request may appear to be stalled. To fix this issue, see
[Dev Containers / VS Code Port Forwarding](#dev-containers-vs-code-port-forwarding).

### Network requests stop loading

When using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.

To resolve the problem use a trusted SSL cert.

See: [Cache problems](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)

#### macOS

You can install a trusted cert via the CLI with this command:

```
security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer
```

Or, by importing it into the Keychain Access app and updating the trust of your cert to "Always Trust."

### 431 Request Header Fields Too Large

When the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.

> Server responded with status code 431. See https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large.

This is because Node.js limits request header size to mitigate [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).

To avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) to change max header size.

### Dev Containers / VS Code Port Forwarding

If you are using a Dev Container or port forwarding feature in VS Code, you may need to set the [`server.host`](/config/server-options.md#server-host) option to `127.0.0.1` in the config to make it work.

This is because [the port forwarding feature in VS Code does not support IPv6](https://github.com/microsoft/vscode-remote-release/issues/7029).

See [#16522](https://github.com/vitejs/vite/issues/16522) for more details.

## HMR

### Vite detects a file change but the HMR is not working

You may be importing a file with a different case. For example, `src/foo.js` exists and `src/bar.js` contains:

```js
import './Foo.js' // should be './foo.js'
```

Related issue: [#964](https://github.com/vitejs/vite/issues/964)

### Vite does not detect a file change

If you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See [`server.watch` option](/config/server-options.md#server-watch).

### A full reload happens instead of HMR

If HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.

If HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run `vite --debug hmr` to log the circular dependency path if a file change triggered it.

## Build

### Built file does not work because of CORS error

If the HTML file output was opened with `file` protocol, the scripts won't run with the following error.

> Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

> Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).

See [Reason: CORS request not HTTP - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) for more information about why this happens.

You will need to access the file with `http` protocol. The easiest way to achieve this is to run `npx vite preview`.

### No such file or directory error due to case sensitivity

If you encounter errors like `ENOENT: no such file or directory` or `Module not found`, this often occurs when your project was developed on a case-insensitive filesystem (Windows / macOS) but built on a case-sensitive one (Linux). Please make sure that the imports have the correct casing.

## Optimized Dependencies

### Outdated pre-bundled deps when linking to a local package

The hash key used to invalidate optimized dependencies depends on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using `vite --force`. We recommend using overrides instead, which are supported now by every package manager (see also [pnpm overrides](https://pnpm.io/9.x/package_json#pnpmoverrides) and [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).

## Performance Bottlenecks

If you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:

::: code-group

```bash [dev server]
vite --profile --open
```

```bash [build]
vite build --profile
```

:::

::: tip Vite Dev Server
Once your application is opened in the browser, just await finish loading it and then go back to the terminal and press `p` key (will stop the Node.js inspector) then press `q` key to stop the dev server.
:::

Node.js inspector will generate `vite-profile-0.cpuprofile` in the root folder, go to https://www.speedscope.app/, and upload the CPU profile using the `BROWSE` button to inspect the result.

You can install [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.

## Others

### Module externalized for browser compatibility

When you use a Node.js module in the browser, Vite will output the following warning.

> Module "fs" has been externalized for browser compatibility. Cannot access "fs.readFile" in client code.

This is because Vite does not automatically polyfill Node.js modules.

We recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.

### Syntax Error / Type Error happens

Vite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) inside ESM.

For example, you might see these errors.

> [ERROR] With statements cannot be used with the "esm" output format due to strict mode

> TypeError: Cannot create property 'foo' on boolean 'false'

If these codes are used inside dependencies, you could use [`patch-package`](https://github.com/ds300/patch-package) (or [`yarn patch`](https://yarnpkg.com/cli/patch) or [`pnpm patch`](https://pnpm.io/cli/patch)) for an escape hatch.

### Browser extensions

Some browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.

### Cross drive links on Windows

If there's a cross drive links in your project on Windows, Vite may not work.

An example of cross drive links are:

- a virtual drive linked to a folder by `subst` command
- a symlink/junction to a different drive by `mklink` command (e.g. Yarn global cache)

Related issue: [#10802](https://github.com/vitejs/vite/issues/10802)

<script setup lang="ts">
// redirect old links with hash to old version docs
if (typeof window !== "undefined") {
  const hashForOldVersion = {
    'vite-cjs-node-api-deprecated': 6
  }

  const version = hashForOldVersion[location.hash.slice(1)]
  if (version) {
    // update the scheme and the port as well so that it works in local preview (it is http and 4173 locally)
    location.href = `https://v${version}.vite.dev` + location.pathname + location.search + location.hash
  }
}
</script>



================================================
FILE: docs/guide/using-plugins.md
================================================
# Using Plugins

Vite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.

## Adding a Plugin

To use a plugin, it needs to be added to the `devDependencies` of the project and included in the `plugins` array in the `vite.config.js` config file. For example, to provide support for legacy browsers, the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) can be used:

```
$ npm add -D @vitejs/plugin-legacy
```

```js twoslash [vite.config.js]
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11'],
    }),
  ],
})
```

`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.

Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.

## Finding Plugins

:::tip NOTE
Vite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the [Features Guide](../guide/features.md). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.
:::

Check out the [Plugins section](../plugins/) for information about official plugins. Community plugins are listed in [awesome-vite](https://github.com/vitejs/awesome-vite#plugins).

You can also find plugins that follow the [recommended conventions](./api-plugin.md#conventions) using a [npm search for vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) for Vite plugins or a [npm search for rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) for Rollup plugins.

## Enforcing Plugin Ordering

For compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the `enforce` modifier:

- `pre`: invoke plugin before Vite core plugins
- default: invoke plugin after Vite core plugins
- `post`: invoke plugin after Vite build plugins

```js twoslash [vite.config.js]
import image from '@rollup/plugin-image'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...image(),
      enforce: 'pre',
    },
  ],
})
```

Check out [Plugins API Guide](./api-plugin.md#plugin-ordering) for detailed information.

## Conditional Application

By default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:

```js twoslash [vite.config.js]
import typescript2 from 'rollup-plugin-typescript2'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...typescript2(),
      apply: 'build',
    },
  ],
})
```

## Building Plugins

Check out the [Plugins API Guide](./api-plugin.md) for documentation about creating plugins.



================================================
FILE: docs/guide/why.md
================================================
# Why Vite

## The Problems

Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of "bundling": using tools that crawl, process and concatenate our source modules into files that can run in the browser.

Over time we have seen tools like [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) and [Parcel](https://parceljs.org/), which greatly improved the development experience for frontend developers.

However, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.

Vite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.

### Slow Server Start

When cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.

Vite improves the dev server start time by first dividing the modules in an application into two categories: **dependencies** and **source code**.

- **Dependencies** are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).

  Vite [pre-bundles dependencies](./dep-pre-bundling.md) using [esbuild](https://esbuild.github.io/). esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.

- **Source code** often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).

  Vite serves source code over [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.

<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>
<svg-image :svg="bundlerSvg" />
<svg-image :svg="esmSvg" />

### Slow Updates

When a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.

In some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to "hot replace" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.

In Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.

Vite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via `304 Not Modified`, and dependency module requests are strongly cached via `Cache-Control: max-age=31536000,immutable` so they don't hit the server again once cached.

Once you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.

## Why Bundle for Production

Even though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).

Ensuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured [build command](./build.md) that bakes in many [performance optimizations](./features.md#build-optimizations) out of the box.

## Why Not Bundle with esbuild?

While Vite leverages esbuild to [pre-bundle some dependencies in dev](./dep-pre-bundling.md), Vite does not use esbuild as a bundler for production builds.

Vite's current plugin API isn't compatible with using `esbuild` as a bundler. In spite of `esbuild` being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.

Rollup has also been working on performance improvements, [switching its parser to SWC in v4](https://github.com/rollup/rollup/pull/5073). And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch [Evan You's ViteConf 2023 keynote for more details](https://youtu.be/hrdwQHoAp0M).

## How Vite Relates to Other Unbundled Build Tools?

[WMR](https://github.com/preactjs/wmr) by the Preact team looked to provide a similar feature set. Vite's universal Rollup plugin API for dev and build was inspired by it. WMR is no longer maintained. The Preact team now recommends Vite with [@preactjs/preset-vite](https://github.com/preactjs/preset-vite).

[Snowpack](https://www.snowpack.dev/) was also a no-bundle native ESM dev server, very similar in scope to Vite. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Snowpack is no longer being maintained. The Snowpack team is now working on [Astro](https://astro.build/), a static site builder powered by Vite.

[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (previously `es-dev-server`) is a great project and Vite 1.0's Koa-based server setup was inspired by it. The `@web` umbrella project is actively maintained and contains many other excellent tools that may benefit Vite users as well.



================================================
FILE: docs/images/diagrams.fig
================================================
[Binary file]


================================================
FILE: docs/images/vite5-1-10K-modules-loading-time.webp
================================================
[Binary file]


================================================
FILE: docs/images/vite6-npm-weekly-downloads.webp
================================================
[Binary file]


================================================
FILE: docs/images/community/placeholder.webp
================================================
[Binary file]


================================================
FILE: docs/plugins/index.md
================================================
# Plugins

:::tip NOTE
Vite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or Compatible Rollup plugin, check out the [Features Guide](../guide/features.md). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.
:::

Check out [Using Plugins](../guide/using-plugins) for information on how to use plugins.

## Official Plugins

### [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)

- Provides Vue 3 Single File Components support.

### [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)

- Provides Vue 3 JSX support (via [dedicated Babel transform](https://github.com/vuejs/jsx-next)).

### [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2)

- Provides Vue 2.7 Single File Components support.

### [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx)

- Provides Vue 2.7 JSX support (via [dedicated Babel transform](https://github.com/vuejs/jsx-vue2/)).

### [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react)

- Uses esbuild and Babel, achieving fast HMR with a small package footprint and the flexibility of being able to use the Babel transform pipeline. Without additional Babel plugins, only esbuild is used during builds.

### [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc)

- Replaces Babel with SWC during development. During production builds, SWC+esbuild are used when using plugins, and esbuild only otherwise. For big projects that don't require non-standard React extensions, cold start and Hot Module Replacement (HMR) can be significantly faster.

### [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)

- Provides legacy browsers support for the production build.

## Community Plugins

Check out [awesome-vite](https://github.com/vitejs/awesome-vite#plugins) - you can also submit a PR to list your plugins there.

## Rollup Plugins

[Vite plugins](../guide/api-plugin) are an extension of Rollup's plugin interface. Check out the [Rollup Plugin Compatibility section](../guide/api-plugin#rollup-plugin-compatibility) for more information.



================================================
FILE: docs/public/_headers
================================================
/assets/*
  cache-control: max-age=31536000
  cache-control: immutable

/*.svg
  cache-control: max-age=604800
  cache-control: immutable

/*.png
  cache-control: max-age=604800
  cache-control: immutable

/*.webp
  cache-control: max-age=604800
  cache-control: immutable



================================================
FILE: docs/public/_redirects
================================================
# temporary, we'll flip this around some day
https://vitejs.dev/* https://vite.dev/:splat 301!

/guide/api-vite-runtime /guide/api-environment 301
/guide/api-vite-runtime.html /guide/api-environment 301
/guide/api-vite-environment /guide/api-environment 301
/guide/api-vite-environment.html /guide/api-environment 301
/guide/comparisons /guide/why#how-vite-relates-to-other-unbundled-build-tools 301
/guide/comparisons.html /guide/why#how-vite-relates-to-other-unbundled-build-tools 301

# llms.txt
/*.txt           /:splat.md 301
/llms.md         /llms.txt 301
/llms.txt        /llms.txt 200!
/llms-full.txt   /llms-full.txt 200!

# short links
/rolldown /guide/rolldown 301



================================================
FILE: docs/public/logo-uwu.webp
================================================
[Binary file]


================================================
FILE: docs/public/logo-with-shadow.webp
================================================
[Binary file]


================================================
FILE: docs/.vitepress/buildEnd.config.ts
================================================
import path from 'node:path'
import { writeFileSync } from 'node:fs'
import { Feed } from 'feed'
import type { SiteConfig } from 'vitepress'
import { createContentLoader } from 'vitepress'

const siteUrl = 'https://vite.dev'
const blogUrl = `${siteUrl}/blog`

export const buildEnd = async (config: SiteConfig): Promise<void> => {
  const feed = new Feed({
    title: 'Vite',
    description: 'Next Generation Frontend Tooling',
    id: blogUrl,
    link: blogUrl,
    language: 'en',
    image: 'https://vite.dev/og-image.jpg',
    favicon: 'https://vite.dev/logo.svg',
    copyright: 'Copyright © 2019-present VoidZero Inc. & Vite Contributors',
  })

  const posts = await createContentLoader('blog/*.md', {
    excerpt: true,
    render: true,
  }).load()

  posts.sort(
    (a, b) =>
      +new Date(b.frontmatter.date as string) -
      +new Date(a.frontmatter.date as string),
  )

  for (const { url, excerpt, frontmatter, html } of posts) {
    feed.addItem({
      title: frontmatter.title,
      id: `${siteUrl}${url}`,
      link: `${siteUrl}${url}`,
      description: excerpt,
      content: html,
      author: [
        {
          name: frontmatter.author.name,
        },
      ],
      date: frontmatter.date,
    })
  }

  writeFileSync(path.join(config.outDir, 'blog.rss'), feed.rss2())
}



================================================
FILE: docs/.vitepress/config.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import type { DefaultTheme, HeadConfig } from 'vitepress'
import { defineConfig } from 'vitepress'
import { transformerTwoslash } from '@shikijs/vitepress-twoslash'
import {
  groupIconMdPlugin,
  groupIconVitePlugin,
} from 'vitepress-plugin-group-icons'
import llmstxt from 'vitepress-plugin-llms'
import type { PluginOption } from 'vite'
import { markdownItImageSize } from 'markdown-it-image-size'
import { buildEnd } from './buildEnd.config'

const ogDescription = 'Next Generation Frontend Tooling'
const ogImage = 'https://vite.dev/og-image.jpg'
const ogTitle = 'Vite'
const ogUrl = 'https://vite.dev'

// netlify envs
const deployURL = process.env.DEPLOY_PRIME_URL || ''
const commitRef = process.env.COMMIT_REF?.slice(0, 8) || 'dev'

const deployType = (() => {
  switch (deployURL) {
    case 'https://main--vite-docs-main.netlify.app':
      return 'main'
    case '':
      return 'local'
    default:
      return 'release'
  }
})()
const additionalTitle = ((): string => {
  switch (deployType) {
    case 'main':
      return ' (main branch)'
    case 'local':
      return ' (local)'
    case 'release':
      return ''
  }
})()
const versionLinks = ((): DefaultTheme.NavItemWithLink[] => {
  const oldVersions: DefaultTheme.NavItemWithLink[] = [
    {
      text: 'Vite 6 Docs',
      link: 'https://v6.vite.dev',
    },
    {
      text: 'Vite 5 Docs',
      link: 'https://v5.vite.dev',
    },
    {
      text: 'Vite 4 Docs',
      link: 'https://v4.vite.dev',
    },
    {
      text: 'Vite 3 Docs',
      link: 'https://v3.vite.dev',
    },
    {
      text: 'Vite 2 Docs',
      link: 'https://v2.vite.dev',
    },
  ]

  switch (deployType) {
    case 'main':
    case 'local':
      return [
        {
          text: 'Vite 7 Docs (release)',
          link: 'https://vite.dev',
        },
        ...oldVersions,
      ]
    case 'release':
      return oldVersions
  }
})()

function inlineScript(file: string): HeadConfig {
  return [
    'script',
    {},
    fs.readFileSync(
      path.resolve(__dirname, `./inlined-scripts/${file}`),
      'utf-8',
    ),
  ]
}

export default defineConfig({
  title: `Vite${additionalTitle}`,
  description: 'Next Generation Frontend Tooling',

  head: [
    ['link', { rel: 'icon', type: 'image/svg+xml', href: '/logo.svg' }],
    [
      'link',
      { rel: 'alternate', type: 'application/rss+xml', href: '/blog.rss' },
    ],
    ['link', { rel: 'preconnect', href: 'https://fonts.googleapis.com' }],
    [
      'link',
      {
        rel: 'preconnect',
        href: 'https://fonts.gstatic.com',
        crossorigin: 'true',
      },
    ],
    [
      'link',
      {
        rel: 'preload',
        href: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Manrope:wght@600&family=IBM+Plex+Mono:wght@400&display=swap',
        as: 'style',
      },
    ],
    [
      'link',
      {
        rel: 'stylesheet',
        href: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Manrope:wght@600&family=IBM+Plex+Mono:wght@400&display=swap',
      },
    ],
    inlineScript('banner.js'),
    ['link', { rel: 'me', href: 'https://m.webtoo.ls/@vite' }],
    ['meta', { property: 'og:type', content: 'website' }],
    ['meta', { property: 'og:title', content: ogTitle }],
    ['meta', { property: 'og:image', content: ogImage }],
    ['meta', { property: 'og:url', content: ogUrl }],
    ['meta', { property: 'og:description', content: ogDescription }],
    ['meta', { property: 'og:site_name', content: 'vitejs' }],
    ['meta', { name: 'twitter:card', content: 'summary_large_image' }],
    ['meta', { name: 'twitter:site', content: '@vite_js' }],
    ['meta', { name: 'theme-color', content: '#646cff' }],
    [
      'script',
      {
        src: 'https://cdn.usefathom.com/script.js',
        'data-site': 'CBDFBSLI',
        'data-spa': 'auto',
        defer: '',
      },
    ],
  ],

  locales: {
    root: { label: 'English' },
    zh: { label: '简体中文', link: 'https://cn.vite.dev' },
    ja: { label: '日本語', link: 'https://ja.vite.dev' },
    es: { label: 'Español', link: 'https://es.vite.dev' },
    pt: { label: 'Português', link: 'https://pt.vite.dev' },
    ko: { label: '한국어', link: 'https://ko.vite.dev' },
    de: { label: 'Deutsch', link: 'https://de.vite.dev' },
    fa: { label: 'فارسی', link: 'https://fa.vite.dev' },
  },

  themeConfig: {
    logo: '/logo.svg',

    editLink: {
      pattern: 'https://github.com/vitejs/vite/edit/main/docs/:path',
      text: 'Suggest changes to this page',
    },

    socialLinks: [
      { icon: 'bluesky', link: 'https://bsky.app/profile/vite.dev' },
      { icon: 'mastodon', link: 'https://elk.zone/m.webtoo.ls/@vite' },
      { icon: 'x', link: 'https://x.com/vite_js' },
      { icon: 'discord', link: 'https://chat.vite.dev' },
      { icon: 'github', link: 'https://github.com/vitejs/vite' },
    ],

    algolia: {
      appId: '7H67QR5P0A',
      apiKey: '208bb9c14574939326032b937431014b',
      indexName: 'vitejs',
      searchParameters: {
        facetFilters: ['tags:en'],
      },
    },

    carbonAds: {
      code: 'CEBIEK3N',
      placement: 'vitejsdev',
    },

    footer: {
      message: `Released under the MIT License. (${commitRef})`,
      copyright: 'Copyright © 2019-present VoidZero Inc. & Vite Contributors',
    },

    nav: [
      { text: 'Guide', link: '/guide/', activeMatch: '/guide/' },
      { text: 'Config', link: '/config/', activeMatch: '/config/' },
      { text: 'Plugins', link: '/plugins/', activeMatch: '/plugins/' },
      {
        text: 'Resources',
        items: [
          { text: 'Team', link: '/team' },
          { text: 'Blog', link: '/blog' },
          { text: 'Releases', link: '/releases' },
          {
            items: [
              {
                text: 'Bluesky',
                link: 'https://bsky.app/profile/vite.dev',
              },
              {
                text: 'Mastodon',
                link: 'https://elk.zone/m.webtoo.ls/@vite',
              },
              {
                text: 'X',
                link: 'https://x.com/vite_js',
              },
              {
                text: 'Discord Chat',
                link: 'https://chat.vite.dev',
              },
              {
                text: 'Awesome Vite',
                link: 'https://github.com/vitejs/awesome-vite',
              },
              {
                text: 'ViteConf',
                link: 'https://viteconf.org',
              },
              {
                text: 'DEV Community',
                link: 'https://dev.to/t/vite',
              },
              {
                text: 'Changelog',
                link: 'https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md',
              },
              {
                text: 'Contributing',
                link: 'https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md',
              },
            ],
          },
        ],
      },
      {
        text: 'Version',
        items: versionLinks,
      },
    ],

    sidebar: {
      '/guide/': [
        {
          text: 'Introduction',
          items: [
            {
              text: 'Getting Started',
              link: '/guide/',
            },
            {
              text: 'Philosophy',
              link: '/guide/philosophy',
            },
            {
              text: 'Why Vite',
              link: '/guide/why',
            },
          ],
        },
        {
          text: 'Guide',
          items: [
            {
              text: 'Features',
              link: '/guide/features',
            },
            {
              text: 'CLI',
              link: '/guide/cli',
            },
            {
              text: 'Using Plugins',
              link: '/guide/using-plugins',
            },
            {
              text: 'Dependency Pre-Bundling',
              link: '/guide/dep-pre-bundling',
            },
            {
              text: 'Static Asset Handling',
              link: '/guide/assets',
            },
            {
              text: 'Building for Production',
              link: '/guide/build',
            },
            {
              text: 'Deploying a Static Site',
              link: '/guide/static-deploy',
            },
            {
              text: 'Env Variables and Modes',
              link: '/guide/env-and-mode',
            },
            {
              text: 'Server-Side Rendering (SSR)',
              link: '/guide/ssr',
            },
            {
              text: 'Backend Integration',
              link: '/guide/backend-integration',
            },
            {
              text: 'Troubleshooting',
              link: '/guide/troubleshooting',
            },
            {
              text: 'Performance',
              link: '/guide/performance',
            },
            {
              text: 'Rolldown',
              link: '/guide/rolldown',
            },
            {
              text: 'Migration from v6',
              link: '/guide/migration',
            },
            {
              text: 'Breaking Changes',
              link: '/changes/',
            },
          ],
        },
        {
          text: 'APIs',
          items: [
            {
              text: 'Plugin API',
              link: '/guide/api-plugin',
            },
            {
              text: 'HMR API',
              link: '/guide/api-hmr',
            },
            {
              text: 'JavaScript API',
              link: '/guide/api-javascript',
            },
            {
              text: 'Config Reference',
              link: '/config/',
            },
          ],
        },
        {
          text: 'Environment API',
          items: [
            {
              text: 'Introduction',
              link: '/guide/api-environment',
            },
            {
              text: 'Environment Instances',
              link: '/guide/api-environment-instances',
            },
            {
              text: 'Plugins',
              link: '/guide/api-environment-plugins',
            },
            {
              text: 'Frameworks',
              link: '/guide/api-environment-frameworks',
            },
            {
              text: 'Runtimes',
              link: '/guide/api-environment-runtimes',
            },
          ],
        },
      ],
      '/config/': [
        {
          text: 'Config',
          items: [
            {
              text: 'Configuring Vite',
              link: '/config/',
            },
            {
              text: 'Shared Options',
              link: '/config/shared-options',
            },
            {
              text: 'Server Options',
              link: '/config/server-options',
            },
            {
              text: 'Build Options',
              link: '/config/build-options',
            },
            {
              text: 'Preview Options',
              link: '/config/preview-options',
            },
            {
              text: 'Dep Optimization Options',
              link: '/config/dep-optimization-options',
            },
            {
              text: 'SSR Options',
              link: '/config/ssr-options',
            },
            {
              text: 'Worker Options',
              link: '/config/worker-options',
            },
          ],
        },
      ],
      '/changes/': [
        {
          text: 'Breaking Changes',
          link: '/changes/',
        },
        {
          text: 'Current',
          items: [],
        },
        {
          text: 'Future',
          items: [
            {
              text: 'this.environment in Hooks',
              link: '/changes/this-environment-in-hooks',
            },
            {
              text: 'HMR hotUpdate Plugin Hook',
              link: '/changes/hotupdate-hook',
            },
            {
              text: 'Move to Per-environment APIs',
              link: '/changes/per-environment-apis',
            },
            {
              text: 'SSR Using ModuleRunner API',
              link: '/changes/ssr-using-modulerunner',
            },
            {
              text: 'Shared Plugins During Build',
              link: '/changes/shared-plugins-during-build',
            },
          ],
        },
        {
          text: 'Past',
          items: [],
        },
      ],
    },

    outline: {
      level: [2, 3],
    },
  },
  transformPageData(pageData) {
    const canonicalUrl = `${ogUrl}/${pageData.relativePath}`
      .replace(/\/index\.md$/, '/')
      .replace(/\.md$/, '')
    pageData.frontmatter.head ??= []
    pageData.frontmatter.head.unshift(
      ['link', { rel: 'canonical', href: canonicalUrl }],
      ['meta', { property: 'og:title', content: pageData.title }],
    )
    return pageData
  },
  markdown: {
    // languages used for twoslash and jsdocs in twoslash
    languages: ['ts', 'js', 'json'],
    codeTransformers: [transformerTwoslash()],
    config(md) {
      md.use(groupIconMdPlugin)
      md.use(markdownItImageSize, {
        publicDir: path.resolve(import.meta.dirname, '../public'),
      })
    },
  },
  vite: {
    plugins: [
      groupIconVitePlugin({
        customIcon: {
          firebase: 'vscode-icons:file-type-firebase',
          '.gitlab-ci.yml': 'vscode-icons:file-type-gitlab',
        },
      }),
      llmstxt({
        ignoreFiles: ['blog/*', 'blog.md', 'index.md', 'team.md'],
        description: 'The Build Tool for the Web',
        details: `\
- 💡 Instant Server Start
- ⚡️ Lightning Fast HMR
- 🛠️ Rich Features
- 📦 Optimized Build
- 🔩 Universal Plugin Interface
- 🔑 Fully Typed APIs

Vite is a new breed of frontend build tooling that significantly improves the frontend development experience. It consists of two major parts:

- A dev server that serves your source files over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), with [rich built-in features](https://vite.dev/guide/features.md) and astonishingly fast [Hot Module Replacement (HMR)](https://vite.dev/guide/features.md#hot-module-replacement).

- A [build command](https://vite.dev/guide/build.md) that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.

In addition, Vite is highly extensible via its [Plugin API](https://vite.dev/guide/api-plugin.md) and [JavaScript API](https://vite.dev/guide/api-javascript.md) with full typing support.`,
      }) as PluginOption,
    ],
    optimizeDeps: {
      include: [
        '@shikijs/vitepress-twoslash/client',
        'gsap',
        'gsap/dist/ScrollTrigger',
        'gsap/dist/MotionPathPlugin',
      ],
    },
  },
  buildEnd,
})



================================================
FILE: docs/.vitepress/inlined-scripts/banner.d.ts
================================================
interface Window {
  __VITE_BANNER_ID__: string
}



================================================
FILE: docs/.vitepress/inlined-scripts/banner.js
================================================
;(() => {
  const restore = (key, cls, def = false) => {
    const saved = localStorage.getItem(key)
    if (saved ? saved !== 'false' : def) {
      document.documentElement.classList.add(cls)
    }
  }

  window.__VITE_BANNER_ID__ = 'viteconf2025'
  restore(`vite-docs-banner-${__VITE_BANNER_ID__}`, 'banner-dismissed')
})()



================================================
FILE: docs/.vitepress/theme/index.ts
================================================
import { h } from 'vue'
import type { Theme } from 'vitepress'
import DefaultTheme from 'vitepress/theme'
import TwoslashFloatingVue from '@shikijs/vitepress-twoslash/client'
import '@shikijs/vitepress-twoslash/style.css'
import './styles/vars.css'
import './styles/landing.css'
import AsideSponsors from './components/AsideSponsors.vue'
import SvgImage from './components/SvgImage.vue'
import YouTubeVideo from './components/YouTubeVideo.vue'
import SponsorBanner from './components/SponsorBanner.vue'
import NonInheritBadge from './components/NonInheritBadge.vue'
import 'virtual:group-icons.css'

export default {
  extends: DefaultTheme,
  Layout() {
    return h(DefaultTheme.Layout, null, {
      'layout-top': () => h(SponsorBanner),
      'aside-ads-before': () => h(AsideSponsors),
    })
  },
  enhanceApp({ app }) {
    app.component('SvgImage', SvgImage)
    app.component('YouTubeVideo', YouTubeVideo)
    app.component('NonInheritBadge', NonInheritBadge)
    app.use(TwoslashFloatingVue)
  },
} satisfies Theme



================================================
FILE: docs/.vitepress/theme/components/AsideSponsors.vue
================================================
<script setup lang="ts">
import { computed } from 'vue'
import { VPDocAsideSponsors } from 'vitepress/theme'
import { useSponsor, voidZero } from '../composables/sponsor'

const { data } = useSponsor()

const sponsors = computed(() => {
  return [
    { size: 'small', items: [voidZero] },
    ...(data.value?.map((sponsor) => {
      return {
        size: sponsor.size === 'big' ? 'mini' : 'xmini',
        items: sponsor.items,
      }
    }) ?? []),
  ]
})
</script>

<template>
  <a
    class="viteconf"
    href="https://viteconf.org/?utm=vite-sidebar"
    target="_blank"
  >
    <img
      width="22"
      height="22"
      src="../../../images/viteconf.svg"
      alt="ViteConf Logo"
    />
    <span>
      <p class="extra-info">Building Together</p>
      <p class="heading">ViteConf 2025</p>
      <p class="extra-info">First time in-person!</p>
    </span>
  </a>
  <VPDocAsideSponsors v-if="data" :data="sponsors" />
</template>

<style>
.viteconf {
  margin-top: 1rem;
  margin-bottom: 1rem;
  border-radius: 14px;
  padding-top: 0.4rem;
  padding-bottom: 0.4rem;
  position: relative;
  font-size: 0.9rem;
  font-weight: 700;
  line-height: 1.1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  gap: 1rem;
  background-color: var(--vp-c-bg-alt);
  border: 2px solid var(--vp-c-bg-alt);
  transition: border-color 0.5s;
}
.viteconf:hover {
  border: 2px solid var(--vp-c-brand-light);
}
.viteconf img {
  transition: transform 0.5s;
  transform: scale(1.25);
}
.viteconf:hover img {
  transform: scale(1.75);
}
.viteconf .heading {
  background-image: linear-gradient(
    120deg,
    #b047ff 16%,
    var(--vp-c-brand-lighter),
    var(--vp-c-brand-lighter)
  );
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.viteconf .extra-info {
  color: var(--vp-c-text-1);
  opacity: 0;
  font-size: 0.7rem;
  padding-left: 0.1rem;
  transition: opacity 0.5s;
}
.viteconf:hover .extra-info {
  opacity: 0.9;
}
</style>



================================================
FILE: docs/.vitepress/theme/components/BlogIndex.vue
================================================
<script setup lang="ts">
import { data as posts } from '../../../_data/blog.data'

function getDateTime(time: number) {
  return new Date(time).toISOString()
}
</script>

<template>
  <ul class="blog-list">
    <li class="blog-entry" v-for="post of posts">
      <article>
        <time :datetime="getDateTime(post.date.time)">{{
          post.date.string
        }}</time>
        <h2 class="title">
          <a :href="post.url">{{ post.title }}</a>
        </h2>
      </article>
    </li>
  </ul>
</template>

<style scoped>
.blog-list {
  list-style-type: none;
  padding: 0;
}
.blog-entry {
  margin-top: 3em;
  border-bottom: 1px solid var(--vp-c-divider);
}
.blog-entry time {
  font-size: 14px;
}
.title {
  border: none;
  margin-top: 0;
  padding-top: 0;
  font-size: 22px;
}
.title a {
  font-weight: 600;
  text-decoration: none;
}
</style>



================================================
FILE: docs/.vitepress/theme/components/NonInheritBadge.vue
================================================
<template>
  <a
    href="/guide/api-environment#environments-configuration"
    class="ignore-header"
  >
    <Badge type="info" text="non-inherit" />
  </a>
</template>



================================================
FILE: docs/.vitepress/theme/components/SponsorBanner.vue
================================================
<script setup lang="ts">
/**
 * Adding a new banner:
 * 1. uncomment the banner slot in ../index.ts
 * 2. uncomment and update BANNER_ID in ../../inlined-scripts/restorePreferences.ts
 * 3. update --vp-layout-top-height if necessary
 */
import { ref } from 'vue'

const open = ref(true)

/**
 * Call this if the banner is dismissible
 */
function dismiss() {
  open.value = false
  document.documentElement.classList.add('banner-dismissed')
  localStorage.setItem(`vite-docs-banner-${window.__VITE_BANNER_ID__}`, 'true')
}
</script>

<template>
  <div class="banner" v-if="open">
    <svg
      style="margin-right: 0.5rem"
      width="20"
      height="20"
      viewBox="0 0 30 30"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g>
        <path
          d="M20.3653 1.01733L11.1779 2.87249C11.0895 2.87249 11.0012 2.96082 11.0012 2.96082C10.9128 3.04916 10.9128 3.13751 10.9128 3.13751L10.3828 13.2083C10.3828 13.2967 10.3828 13.2967 10.3828 13.3851C10.3828 13.4734 10.4711 13.4734 10.4711 13.4734C10.4711 13.4734 10.5595 13.5618 10.6478 13.5618C10.7361 13.5618 10.7361 13.5618 10.8245 13.5618L13.3864 12.9433C13.6514 12.855 13.8281 13.12 13.8281 13.3851L13.033 17.3603C12.9447 17.6254 13.2097 17.8905 13.4748 17.8021L15.0648 17.272C15.3299 17.1837 15.5066 17.4487 15.5066 17.7137L14.2697 23.8976C14.1815 24.251 14.7115 24.5159 14.8882 24.1626L15.0648 23.8976L22.5738 8.08458C22.5738 7.90789 22.3088 7.55453 22.0438 7.64287L19.3935 8.17292C19.1286 8.26125 18.9519 7.99624 19.0402 7.73122L20.7187 1.45903C20.807 1.19401 20.6304 0.928988 20.3653 1.01733Z"
          fill="url(#paint0_linear_648_13)"
        />
        <path
          d="M29.6424 3.75619C29.2891 3.22614 28.5824 2.96112 27.964 3.04945L20.985 4.37457L20.72 5.43465L28.2289 4.10955C28.494 4.02121 28.7591 4.19788 28.9357 4.37457C29.1124 4.63959 29.1124 4.90462 28.9357 5.16964L15.773 28.5799C15.6846 28.845 15.4196 28.9332 15.1545 28.9332C14.8896 28.9332 14.6245 28.7566 14.5361 28.5799L1.10836 5.08129C0.931674 4.90462 0.931674 4.55125 1.10836 4.37457C1.28504 4.19788 1.46172 4.10955 1.72674 4.10955C1.72674 4.10955 1.81508 4.10955 1.90342 4.10955L9.85411 5.523L9.94246 4.55125L1.99176 3.04945C1.28504 2.96112 0.666654 3.22614 0.313291 3.75619C-0.0400717 4.28623 -0.128412 4.99295 0.22495 5.61134L13.6528 29.1099C13.9178 29.64 14.5361 29.9933 15.1545 29.9933C15.773 29.9933 16.303 29.64 16.6563 29.1099L29.8191 5.61134C30.0842 4.99295 30.0842 4.28623 29.6424 3.75619Z"
          fill="url(#paint1_linear_648_13)"
        />
      </g>
      <defs>
        <linearGradient
          id="paint0_linear_648_13"
          x1="10.5947"
          y1="3.97762"
          x2="20.9471"
          y2="17.0584"
          gradientUnits="userSpaceOnUse"
        >
          <stop stop-color="#B047FF" />
          <stop offset="0.75" stop-color="#FFD0D0" />
          <stop offset="0.9167" stop-color="#FFF3E6" />
        </linearGradient>
        <linearGradient
          id="paint1_linear_648_13"
          x1="8.078"
          y1="1.32911"
          x2="23.118"
          y2="18.0977"
          gradientUnits="userSpaceOnUse"
        >
          <stop stop-color="#57CCFF" />
          <stop offset="1" stop-color="#AF48FF" />
        </linearGradient>
      </defs>
    </svg>
    <p class="vt-banner-text">
      <span class="vt-main">ViteConf 2025</span>
      <span class="vt-tagline">
        · First time <span style="font-weight: 900">in-person</span></span
      >
      <span class="vt-place"> · Amsterdam</span>
      <span class="vt-date"> · Oct 09-10</span>
      <a
        target="_blank"
        class="vt-primary-action"
        href="https://viteconf.amsterdam/?utm_source=vite&utm_content=top_banner"
      >
        Register
      </a>
    </p>
    <button aria-label="close" @click="dismiss">
      <svg
        class="close"
        xmlns="http://www.w3.org/2000/svg"
        aria-hidden="true"
        focusable="false"
        viewBox="0 0 24 24"
      >
        <path
          d="M18.9,10.9h-6v-6c0-0.6-0.4-1-1-1s-1,0.4-1,1v6h-6c-0.6,0-1,0.4-1,1s0.4,1,1,1h6v6c0,0.6,0.4,1,1,1s1-0.4,1-1v-6h6c0.6,0,1-0.4,1-1S19.5,10.9,18.9,10.9z"
        />
      </svg>
    </button>
    <div class="glow glow--purple"></div>
    <div class="glow glow--blue"></div>
  </div>
</template>

<style>
html:not(.banner-dismissed) {
  --vp-layout-top-height: 30px;
}
</style>

<style scoped>
.banner {
  position: fixed;
  z-index: 10;
  box-sizing: border-box;
  top: 0;
  left: 0;
  right: 0;
  height: var(--vp-layout-top-height);
  line-height: var(--vp-layout-top-height);
  text-align: center;
  font-size: 12px;
  font-weight: 600;
  color: white;
  background: #262626;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.glow.glow--purple {
  position: absolute;
  bottom: -15%;
  left: -75%;
  width: 80%;
  aspect-ratio: 1.5;
  pointer-events: none;
  border-radius: 100%;
  background: linear-gradient(270deg, #7a23a1, #715ebde6 60% 80%, #bd34fe00);
  filter: blur(15vw);
  transform: none;
  opacity: 0.6;
}

.glow.glow--blue {
  position: absolute;
  bottom: -15%;
  right: -40%;
  width: 80%;
  aspect-ratio: 1.5;
  pointer-events: none;
  border-radius: 100%;
  background: linear-gradient(180deg, #61d9ff, #0000);
  filter: blur(15vw);
  transform: none;
  opacity: 0.3;
}

@media (min-width: 768px) {
  .glow.glow--blue {
    top: -15%;
    right: -40%;
    width: 80%;
  }

  .glow.glow--purple {
    bottom: -15%;
    left: -40%;
    width: 80%;
  }
}

@media (min-width: 1025px) {
  .glow.glow--blue {
    top: -15%;
    right: -40%;
    width: 80%;
  }

  .glow.glow--purple {
    bottom: -15%;
    left: -40%;
    width: 80%;
  }
}

.banner-dismissed .banner {
  display: none;
}

button {
  position: absolute;
  right: 0;
  top: 0;
  padding: 5px 5px;
}

.close {
  width: 20px;
  height: 20px;
  fill: #fff;
  transform: rotate(45deg);
}

.vt-banner-text {
  color: #fff;
  font-size: 12px;
}

.vt-main {
  color: transparent;
  background-image: linear-gradient(120deg, #b047ff 16%, #9499ff, #9499ff);
  background-clip: text;
}

.vt-primary-action {
  background:
    radial-gradient(141.42% 141.42% at 100% 0%, #ffffff80, #fff0),
    radial-gradient(140.35% 140.35% at 100% 94.74%, #bd34fe, #bd34fe00),
    radial-gradient(89.94% 89.94% at 18.42% 15.79%, #41d1ff, #41d1ff00);
  color: #fff;
  padding: 4px 8px;
  border-radius: 5px;
  font-size: 10px;
  text-decoration: none;
  margin: 0 10px;
  transition: all 0.2s ease-in-out;

  &:hover {
    box-shadow: 0 1px #fffc inset;
  }
}

@media (max-width: 1280px) {
  .banner .vt-banner-text {
    font-size: 14px;
  }

  .vt-tagline {
    display: none;
  }
}

@media (max-width: 780px) {
  .vt-tagline {
    display: none;
  }

  .vt-coupon {
    display: none;
  }

  .vt-primary-action {
    margin: 0 10px;
    padding: 4px 8px;
  }

  .vt-time-now {
    display: none;
  }
}

@media (max-width: 560px) {
  .vt-place {
    display: none;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/SvgImage.vue
================================================
<script setup lang="ts">
defineProps<{ svg: string }>()
</script>

<template>
  <figure class="svg-image-root" v-html="svg" />
</template>

<style>
.svg-image-root {
  background-color: #eee;
  border-radius: 8px;
  padding: 1ch;
  margin: 1ch 0;
}
html.dark .svg-image-root {
  background-color: #313641;
}
.svg-image-root svg text {
  font-family: var(--vp-font-family-base);
}
</style>



================================================
FILE: docs/.vitepress/theme/components/YouTubeVideo.vue
================================================
<script setup lang="ts">
defineProps({
  videoId: String,
})
</script>

<template>
  <div class="full-width-youtube-video">
    <iframe
      width="560"
      height="315"
      :src="`https://www.youtube.com/embed/${videoId}`"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
    ></iframe>
  </div>
</template>

<style scoped>
.full-width-youtube-video {
  position: relative;
  padding-bottom: 56.25%;
  height: 0;
}

.full-width-youtube-video iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: none;
  border-radius: 0.5rem;
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/HeroDiagram.vue
================================================
<script setup lang="ts">
import { gsap } from 'gsap'
import { MotionPathPlugin } from 'gsap/dist/MotionPathPlugin'
import { onMounted, onUnmounted, type Ref, ref } from 'vue'
import SvgInputs from './svg-elements/SvgInputs.vue'
import SvgOutputs from './svg-elements/SvgOutputs.vue'
import SvgBlueIndicator from './svg-elements/SvgBlueIndicator.vue'
import SvgPinkIndicator from './svg-elements/SvgPinkIndicator.vue'
import { ScrollTrigger } from 'gsap/dist/ScrollTrigger'
import type { SvgNodeProps } from '../common/SvgNode.vue'

gsap.registerPlugin(MotionPathPlugin)

// Define the paths on the input side of the diagram
const inputPaths = [
  'M843.505 284.659L752.638 284.659C718.596 284.659 684.866 280.049 653.251 271.077L598.822 255.629L0.675021 1.00011',
  'M843.505 298.181L724.342 297.36C708.881 297.36 693.45 296.409 678.22 294.518L598.822 284.659C592.82 284.659 200.538 190.002 0.675028 164.892',
  'M843.505 311.703L701.108 310.061L598.822 305.136L0.675049 256.071',
  'M843.505 325.224L598.822 326.002L0.675049 321.858',
  'M843.505 338.746L701.108 340.388L598.822 345.442L0.675038 387.646',
  'M843.505 352.268L724.342 353.088C708.881 353.088 693.45 354.039 678.22 355.93L598.822 365.789L0.675067 478.825',
  'M843.505 365.789L752.638 365.789C718.596 365.789 684.866 370.399 653.251 379.372L598.822 394.82L0.675049 642.717',
]

// Setup objects representing each input line's animation state
const inputLines: Ref<SvgNodeProps>[] = inputPaths.map((path) =>
  ref({
    position: 0,
    visible: false,
    labelVisible: false,
    label: '',
    dotColor: undefined,
    glowColor: undefined,
    path,
  }),
)

// Define the file set "combinations" that can be shown on the input side
const inputFileSets = ref([
  [
    { label: '.jsx' },
    { label: '.sass' },
    { label: '.svelte', color: '#ff8d67' },
  ],
  [{ label: '.tsx' }, { label: '.scss' }, { label: '.vue', color: '#40b782' }],
  [
    { label: '.js' },
    { label: '.styl' },
    { label: '.svelte', color: '#ff8d67' },
  ],
  [{ label: '.ts' }, { label: '.less' }, { label: '.vue', color: '#40b782' }],
  [{ label: '.mts' }, { label: '.html' }, { label: '.json' }],
])

// Setup objects representing each output line's animation state
const outputLines: Ref[] = [
  ref({
    position: 0,
    visible: false,
    labelVisible: false,
    label: '.html',
  }),
  ref({
    position: 0,
    visible: false,
    labelVisible: false,
    label: '.css',
  }),
  ref({
    position: 0,
    visible: false,
    labelVisible: false,
    label: '.js',
  }),
]

// Add some flags for whether to display various subcomponents
const blueIndicator = ref(false)
const pinkIndicator = ref(false)
const illuminateLogo = ref(false)

// Set up a reference to our ScrollTrigger instance and timeline
let scrollTriggerInstance: ScrollTrigger | null
let timeline: gsap.core.Timeline | null

// Start all animations when mounted
onMounted(() => {
  scrollTriggerInstance = ScrollTrigger.create({
    trigger: '#hero-diagram',
    start: 'center 100%',
    once: true,
    onEnter: () => {
      animateDiagram()
    },
  })
})

// Clean up the scroll trigger and timeline when unmounted
onUnmounted(() => {
  scrollTriggerInstance?.kill()
  timeline?.kill()
})

/**
 * The core animation for the hero diagram.
 * Has both a desktop and mobile variation.
 */
const animateDiagram = () => {
  // Determine if we're showing the desktop or mobile variation of the animation
  // This is determined on each "loop" of the animation
  const isMobile = window.innerWidth < 768

  // Prepare a timeline
  timeline = gsap.timeline({
    onComplete: animateDiagram,
  })

  // Animate the input nodes/lines
  prepareInputs().forEach((lineIndex, fileIndex) => {
    timeline!.add(
      isMobile
        ? animateSingleInputMobile(inputLines[lineIndex])
        : animateSingleInputDesktop(inputLines[lineIndex]),
      fileIndex * (isMobile ? 0.4 : 0.2),
    )
  })

  // Illuminate the logo and colored indicators
  timeline.set(blueIndicator, { value: true }, isMobile ? '>-2' : '>-0.2')
  timeline.set(illuminateLogo, { value: true }, '<-0.3')
  timeline.set(pinkIndicator, { value: true }, '<+0.3')

  // Animate the output nodes/lines
  timeline.addLabel('showOutput', '<')
  outputLines.forEach((outputLine, index) => {
    timeline!.add(
      isMobile
        ? animateSingleOutputMobile(outputLine)
        : animateSingleOutputDesktop(outputLine, index),
      'showOutput+=' + (isMobile ? 0.3 : 0.1) * index,
    )
  })

  //  Desktop only reset
  if (!isMobile) {
    // Disable the colored indicators
    timeline.set(blueIndicator, { value: false }, '>-1')
    timeline.set(pinkIndicator, { value: false }, '<')

    // Pause briefly at the end of the animation
    timeline.set({}, {}, '+=0.2')
  }
}

/**
 * Randomly selects a set of input file nodes and assigns them to input lines.
 */
const prepareInputs = () => {
  // Randomly select a set of input file "nodes"
  const inputFileSet =
    inputFileSets.value[Math.floor(Math.random() * inputFileSets.value.length)]

  // Choose enough unique lines for the input file nodes to slide along
  const inputLineIndexes = new Set<number>()
  while (inputLineIndexes.size < 3) {
    const index: number = Math.floor(Math.random() * inputLines.length)
    inputLineIndexes.add(index)
  }

  // Assign each line it's appropriate node label
  const inputs = [...inputLineIndexes]
  inputs.forEach((lineIndex, fileIndex) => {
    inputLines[lineIndex].value.label = inputFileSet[fileIndex].label
    inputLines[lineIndex].value.dotColor = inputLines[
      lineIndex
    ].value.glowColor = inputFileSet[fileIndex].color
  })
  return inputs
}

/**
 * Animates a single output line for desktop.
 * There are technically 3 output lines, but they are stacked on top of each other.x
 */
const animateSingleOutputDesktop = (
  outputLine: Ref<SvgNodeProps>,
  index: number,
) => {
  const timeline = gsap.timeline()

  // Reset the line
  timeline.set(
    outputLine.value,
    {
      position: 0,
    },
    0,
  )

  // Animate the dot in
  timeline.to(
    outputLine.value,
    {
      position: (0.7 / 3) * (index + 1) + 0.05,
      duration: 1.5,
      ease: 'expo.out',
    },
    0,
  )

  // Show the dot
  timeline.set(
    outputLine.value,
    {
      visible: true,
    },
    0,
  )

  // Show the label
  timeline.set(
    outputLine.value,
    {
      labelVisible: true,
    },
    0.4,
  )

  // Animate the dot out
  timeline.to(
    outputLine.value,
    {
      position: 1,
      duration: 1.5,
      ease: 'power3.in',
    },
    2,
  )

  // Hide the label
  timeline.set(
    outputLine.value,
    {
      labelVisible: false,
    },
    2.5,
  )

  // Hide the dot
  timeline.set(
    outputLine.value,
    {
      visible: false,
    },
    3,
  )

  return timeline
}

/**
 * Animates a single output line for mobile.
 * There are technically 3 output lines, but they are stacked on top of each other.
 */
const animateSingleOutputMobile = (outputLine: Ref<SvgNodeProps>) => {
  const timeline = gsap.timeline()

  // Reset the line
  timeline.set(
    outputLine.value,
    {
      position: 0,
    },
    0,
  )

  // Animate the dot in
  timeline.to(
    outputLine.value,
    {
      position: 0.7,
      duration: 2,
      ease: 'power1.inOut',
    },
    0.3,
  )

  // Show the dot
  timeline.set(
    outputLine.value,
    {
      visible: true,
    },
    0.75,
  )

  // Hide the dot
  timeline.set(
    outputLine.value,
    {
      visible: false,
    },
    1.2,
  )

  return timeline
}

/**
 * Animates a single input line for desktop.
 */
const animateSingleInputDesktop = (inputLine: Ref<SvgNodeProps>) => {
  const timeline = gsap.timeline()

  // Reset the line
  timeline.set(
    inputLine.value,
    {
      position: 0,
    },
    0,
  )

  // Animate the dot in
  timeline.to(
    inputLine.value,
    {
      position: Math.random() * 0.1 + 0.4,
      duration: 1,
      ease: 'expo.out',
    },
    0,
  )

  // Show the dot
  timeline.set(
    inputLine.value,
    {
      visible: true,
    },
    0,
  )

  // Show the label
  timeline.set(
    inputLine.value,
    {
      labelVisible: true,
    },
    0.2,
  )

  // Animate the dot out
  timeline.to(
    inputLine.value,
    {
      position: 1,
      duration: 1.2,
      ease: 'power3.in',
    },
    1.2,
  )

  // Hide the label
  timeline.set(
    inputLine.value,
    {
      labelVisible: false,
    },
    1.6,
  )

  // Hide the dot
  timeline.set(
    inputLine.value,
    {
      visible: false,
    },
    1.9,
  )

  // Return the timeline
  return timeline
}

/**
 * Animates a single input line for mobile.
 */
const animateSingleInputMobile = (inputLine: Ref<SvgNodeProps>) => {
  const timeline = gsap.timeline()

  // Reset the line
  timeline.set(
    inputLine.value,
    {
      position: 0,
    },
    0,
  )

  // Animate the dot in
  timeline.to(
    inputLine.value,
    {
      position: 1,
      duration: 1.8,
      ease: 'power2.out',
    },
    0,
  )

  // Show the dot
  timeline.set(
    inputLine.value,
    {
      visible: true,
    },
    0,
  )

  // Hide the dot
  timeline.set(
    inputLine.value,
    {
      visible: false,
    },
    0.5,
  )

  // Return the timeline
  return timeline
}

// Animating borders only smoothly transitions in Chromium-based browsers
// We don't need extensive checking, just see if the `chrome` key exists on the window object
const isChromiumBrowser = ref(false)
onMounted(() => {
  isChromiumBrowser.value = 'chrome' in window
})

// Check for uwu query
const isUwu = ref(false)
onMounted(() => {
  isUwu.value = location.search.includes('?uwu')
})
</script>

<template>
  <div class="hero__diagram" id="hero-diagram">
    <!-- Input Lines -->
    <SvgInputs :input-lines="inputLines" />

    <!-- Output Line -->
    <SvgOutputs :output-lines="outputLines" />

    <!-- Blue Indicator -->
    <SvgBlueIndicator :active="blueIndicator" />

    <!-- Pink Indicator -->
    <SvgPinkIndicator :active="pinkIndicator" />

    <!-- Vite Chip -->
    <div class="vite-chip" :class="{ active: illuminateLogo }">
      <div class="vite-chip__background">
        <div class="vite-chip__border" />
        <div
          class="vite-chip__edge"
          :class="{ 'edge--animated': isChromiumBrowser }"
        ></div>
      </div>
      <div class="vite-chip__filter" />
      <img
        :src="isUwu ? '/logo-uwu.webp' : '/logo.svg'"
        :alt="isUwu ? 'Vite Kawaii Logo by @icarusgkx' : 'Vite Logo'"
        class="vite-chip__logo"
        :class="{ uwu: isUwu }"
      />
    </div>
  </div>

  <!-- Background -->
  <div class="hero__background" :class="{ active: illuminateLogo }" />
</template>

<style scoped>
.hero__diagram {
  pointer-events: none;
  position: relative;
  width: 1630px;
  overflow: hidden;
  margin: -100px auto 0;

  @media (max-width: 1630px) {
    left: 50%;
    transform: translate3d(-50%, 0, 0);
  }

  @media (max-width: 768px) {
    left: 50%;
    transform: translate3d(-50%, 0, 0) scale(0.9);
  }
}

.vite-chip {
  width: 134px;
  height: 134px;
  position: absolute;
  left: 750px;
  top: 260px;
  border-radius: 10px;
  overflow: hidden;
  transition: all 0.6s ease-out;
  transform: translate3d(0, 0, 0) scale(0.85);

  .vite-chip__filter {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    transform: translate3d(0, 0, 0) scale(1);
    transition: transform 0.3s ease-in-out;
    background:
      linear-gradient(
        130deg,
        rgba(61, 61, 61, 0.3) 0%,
        rgba(61, 61, 61, 0) 40%
      ),
      linear-gradient(
        130deg,
        rgba(42, 33, 63, 0) 60%,
        rgba(61, 61, 61, 0.3) 100%
      ),
      linear-gradient(to bottom, rgba(16, 14, 26, 0.3) 60%, rgba(12, 12, 12, 0));
    border-radius: 10px;
    display: none;

    @media (min-width: 768px) {
      display: block;
    }

    &:after {
      content: '';
      position: absolute;
      top: -10px;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 5;
      background: linear-gradient(
        130deg,
        rgba(61, 61, 61, 0) 45%,
        rgba(154, 152, 222, 0.3) 50%,
        rgba(61, 61, 61, 0) 60%
      );
      background-size: 500%;
      background-position-x: 100%;
      filter: blur(8px);
      border-radius: 100px;
      mix-blend-mode: color-dodge;
      display: none;
    }

    &:before {
      content: '';
      position: absolute;
      top: -10px;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 5;
      background: linear-gradient(
        -130deg,
        rgba(42, 33, 63, 0) 40%,
        rgba(154, 152, 222, 0.2) 50%,
        rgba(42, 33, 63, 0) 60%
      );
      background-size: 400%;
      background-position-x: 100%;
      filter: blur(10px);
      border-radius: 100px;
      mix-blend-mode: color-dodge;
      display: none;
    }

    @media (min-width: 768px) {
      &:before,
      &:after {
        display: block;
      }
    }
  }

  .vite-chip__edge {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 2px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(
      to bottom right,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
    opacity: 0;
    will-change: opacity, border;
    transition: all 1s ease-in-out;

    @media (min-width: 768px) {
      border-image-source: linear-gradient(
        to bottom right,
        rgba(0, 0, 0, 0) 50%,
        rgba(255, 255, 255, 0.15) 60%,
        rgba(0, 0, 0, 0) 90%
      );
    }
  }

  .vite-chip__border {
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    bottom: 0;
    border-radius: 10px;
    border: 0 solid rgba(89, 82, 108, 0.3);
    opacity: 0.8;
    background: rgba(40, 40, 40, 0.3);

    @media (min-width: 768px) {
      top: 2px;
      right: 2px;
      left: 2px;
      bottom: 2px;
    }
  }

  .vite-chip__logo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    width: 65px;
    opacity: 0.2;
    filter: grayscale(100%);
    transition: all 0.2s ease;
    z-index: 3;
  }

  .uwu.vite-chip__logo {
    width: 134px;
  }

  &.active {
    box-shadow: 0 30px 35px -10px rgba(0, 0, 0, 0.6);
    transform: translate3d(0, 0, 0) scale(1);

    .vite-chip__edge {
      opacity: 1;

      &.edge--animated {
        @media (min-width: 768px) {
          animation: rotateGradient 8s linear infinite;
        }
      }
    }

    .vite-chip__filter {
      transform: translate3d(0, 0, 0) scale(0.97);

      &:before {
        animation: shimmer 8s infinite linear;
      }

      &:after {
        animation: shimmer 6s infinite linear;
      }
    }

    .vite-chip__border {
      border-width: 5px;
      transition: all 1s ease;
    }

    .vite-chip__logo {
      opacity: 1;
      filter: grayscale(0);
      transform: translate(-50%, -50%) scale(1);
    }
  }
}

@keyframes shimmer {
  to {
    background-position-x: 0;
  }
}

.hero__background {
  position: absolute;
  top: -30%;
  left: 0;
  right: 0;
  bottom: -60%;
  width: 100%;
  z-index: -1;
  opacity: 0.4;
  transition: opacity 1s ease;

  @media (min-width: 768px) {
    opacity: 0.1;
  }

  background:
    url('../common/noise.webp'),
    radial-gradient(
      circle at right center,
      rgb(86, 50, 119) 0%,
      rgba(74, 55, 140, 1) 30%,
      rgb(65, 114, 194) 55%,
      rgba(50, 81, 115, 0.5) 100%
    );
  mask-image: radial-gradient(
    ellipse 300% 30% at center center,
    rgba(0, 0, 0, 1) 20%,
    rgba(0, 0, 0, 0.5) 50%,
    rgba(0, 0, 0, 0) 100%
  );

  @media (min-width: 1024px) {
    background:
      url('../common/noise.webp'),
      radial-gradient(
        circle at right center,
        rgba(75, 41, 105, 0.5) 0%,
        rgb(86, 50, 119) 25%,
        rgba(74, 55, 140, 1) 40%,
        rgb(64, 102, 168) 65%,
        rgba(50, 81, 115, 0.5) 100%
      );
    mask-image: radial-gradient(
      ellipse 150% 30% at center center,
      rgba(0, 0, 0, 1) 20%,
      rgba(0, 0, 0, 0.5) 50%,
      rgba(0, 0, 0, 0) 100%
    );
  }

  @media (min-width: 1500px) {
    background:
      url('../common/noise.webp'),
      radial-gradient(
        circle at right center,
        rgba(75, 41, 105, 0.5) 0%,
        rgb(86, 50, 119) 25%,
        rgba(74, 55, 140, 1) 45%,
        rgb(64, 102, 168) 65%,
        rgba(50, 81, 115, 0.5) 100%
      );
    mask-image: radial-gradient(
      ellipse 80% 40% at center center,
      rgba(0, 0, 0, 1) 20%,
      rgba(0, 0, 0, 0.5) 50%,
      rgba(0, 0, 0, 0) 100%
    );
  }

  @media (min-width: 1800px) {
    background:
      url('../common/noise.webp'),
      radial-gradient(
        circle at right center,
        rgba(75, 41, 105, 0.5) 0%,
        rgb(86, 50, 119) 25%,
        rgba(74, 55, 140, 1) 50%,
        rgb(64, 102, 168) 70%,
        rgba(50, 81, 115, 0.5) 100%
      );
    mask-image: radial-gradient(
      ellipse 80% 40% at center center,
      rgba(0, 0, 0, 1) 20%,
      rgba(0, 0, 0, 0.5) 50%,
      rgba(0, 0, 0, 0) 100%
    );
  }

  &.active {
    opacity: 0.4;

    @media (min-width: 768px) {
      opacity: 0.7;
    }
  }
}

@keyframes rotateGradient {
  0% {
    border-image-source: linear-gradient(
      to bottom right,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
  }
  25% {
    border-image-source: linear-gradient(
      to right top,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
  }
  50% {
    border-image-source: linear-gradient(
      to top left,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
  }
  75% {
    border-image-source: linear-gradient(
      to left bottom,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
  }
  100% {
    border-image-source: linear-gradient(
      to bottom right,
      rgba(0, 0, 0, 0) 60%,
      rgba(255, 255, 255, 0.15) 65%,
      rgba(0, 0, 0, 0) 90%
    );
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/HeroSection.vue
================================================
<script setup lang="ts">
import HeroDiagram from './HeroDiagram.vue'
</script>

<template>
  <div class="hero">
    <div class="container">
      <!-- ViteConf 2025 Button -->
      <a
        href="https://viteconf.org/?utm=vite"
        class="hero__pill"
        target="_blank"
      >
        <img
          src="../../../../../images/viteconf.svg"
          alt="Viteconf logo"
          width="20"
          height="20"
        />
        <span>ViteConf 2025</span>
      </a>

      <!-- Heading -->
      <h1>The Build Tool<br />for the Web</h1>
      <!-- Tagline -->
      <h3>
        Vite is a blazing fast frontend build tool powering the next generation
        of web applications.
      </h3>

      <!-- CTA Buttons -->
      <div class="hero__actions">
        <a href="/guide/" class="btn btn--primary">Get started</a>
        <a
          href="https://github.com/vitejs/vite"
          target="_blank"
          class="btn btn--outline"
        >
          <img src="./github.svg" alt="GitHub logo" width="20" height="20" />
          GitHub
        </a>
      </div>
    </div>

    <!-- Animated Diagram -->
    <HeroDiagram />
  </div>
</template>

<style scoped>
.hero {
  position: relative;
  z-index: 2;
  margin-bottom: 0;
  background-color: #101010;

  @media (min-width: 768px) {
    margin-bottom: 60px;
  }
}

.container {
  display: flex;
  flex-direction: column;
  max-width: 902px;
  margin: 60px auto 0;
  align-items: center;
  position: relative;
  z-index: 2;

  @media (min-width: 768px) {
    margin: 95px auto 0;
  }
}

.hero__pill {
  color: #fff;
  font-family: Inter, sans-serif;
  font-size: 14px;
  font-style: normal;
  font-weight: 500;
  line-height: normal;
  letter-spacing: -0.3px;
  display: inline-flex;
  padding: 6px 16px;
  align-items: center;
  gap: 8px;
  border-radius: 100px;
  border: 1px solid rgba(189, 52, 254, 0.5);
  background: radial-gradient(
    1686.42% 113.39% at 83.25% 2.56%,
    rgba(189, 52, 254, 0.1) 0%,
    rgba(189, 52, 254, 0) 100%
  );
  box-shadow: none;
  margin-bottom: 40px;

  @media (min-width: 768px) {
    margin-bottom: 25px;
  }

  span {
    color: #fff;
    font-family: Inter, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 500;
    line-height: normal;
    letter-spacing: -0.28px;
  }

  &:hover {
    animation: hero-pill-glow 1600ms ease-out infinite alternate;
  }
}

@keyframes hero-pill-glow {
  0% {
    border-color: rgba(189, 52, 254, 0.5);
    box-shadow:
      0 0 5px rgba(189, 52, 254, 0.01),
      inset 0 0 5px rgba(189, 52, 254, 0.1);
  }
  100% {
    border-color: rgba(189, 52, 254, 0.6);
    box-shadow:
      0 0 20px rgba(189, 52, 254, 0.2),
      inset 0 0 10px rgba(189, 52, 254, 0.2);
  }
}

.hero__actions {
  display: flex;
  flex-direction: row;
  gap: 20px;
  margin-top: 20px;

  @media (min-width: 768px) {
    margin-top: 0;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/svg-elements/SvgBlueIndicator.vue
================================================
<script setup lang="ts">
defineProps({
  active: {
    type: Boolean,
    required: true,
    default: false,
  },
})
</script>

<template>
  <svg
    width="142"
    height="82"
    viewBox="0 0 142 82"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    class="blue-indicator"
    :class="{ active: active }"
  >
    <g opacity="0.2" filter="url(#filter0_d_1_2)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M136.073 3V45.1271C136.073 51.5014 130.905 56.6688 124.531 56.6688H40.2769V54.3604H124.531C129.63 54.3604 133.764 50.2265 133.764 45.1271V3H136.073Z"
        fill="#0D0D0D"
      />
      <path
        d="M136.361 3V2.71146H136.073H133.764H133.476V3V45.1271C133.476 50.0672 129.471 54.0719 124.531 54.0719H40.2769H39.9883V54.3604V56.6688V56.9573H40.2769H124.531C131.065 56.9573 136.361 51.6607 136.361 45.1271V3Z"
        stroke="#404040"
        stroke-width="0.577083"
      />
    </g>
    <g filter="url(#filter1_i_1_2)">
      <rect
        x="12"
        y="69.9419"
        width="30.0083"
        height="30.0083"
        rx="5.01812"
        transform="rotate(-90 12 69.9419)"
        fill="#1F1F1F"
      />
    </g>
    <rect
      x="12"
      y="69.9419"
      width="30.0083"
      height="30.0083"
      rx="5.01812"
      transform="rotate(-90 12 69.9419)"
      stroke="#2C2C2C"
      stroke-opacity="0.4"
      stroke-width="3.75141"
    />
    <path
      d="M18.4048 57.9946C18.4048 57.3366 18.9382 56.8032 19.5961 56.8032H24.3614C25.0194 56.8032 25.5528 57.3366 25.5528 57.9946V62.7599C25.5528 63.4179 25.0194 63.9512 24.3614 63.9512H19.5961C18.9382 63.9512 18.4048 63.4179 18.4048 62.7599V57.9946Z"
      fill="#41D1FF"
      v-show="active"
    />
    <path
      d="M18.4048 57.9946C18.4048 57.3366 18.9382 56.8032 19.5961 56.8032H24.3614C25.0194 56.8032 25.5528 57.3366 25.5528 57.9946V62.7599C25.5528 63.4179 25.0194 63.9512 24.3614 63.9512H19.5961C18.9382 63.9512 18.4048 63.4179 18.4048 62.7599V57.9946Z"
      fill="white"
      fill-opacity="0.5"
    />
    <path
      d="M27.9354 57.9946C27.9354 57.3366 28.4688 56.8032 29.1268 56.8032H33.8921C34.5501 56.8032 35.0834 57.3366 35.0834 57.9946V62.7599C35.0834 63.4179 34.5501 63.9512 33.8921 63.9512H29.1268C28.4688 63.9512 27.9354 63.4179 27.9354 62.7599V57.9946Z"
      fill="#41D1FF"
      v-show="active"
    />
    <path
      d="M27.9354 57.9946C27.9354 57.3366 28.4688 56.8032 29.1268 56.8032H33.8921C34.5501 56.8032 35.0834 57.3366 35.0834 57.9946V62.7599C35.0834 63.4179 34.5501 63.9512 33.8921 63.9512H29.1268C28.4688 63.9512 27.9354 63.4179 27.9354 62.7599V57.9946Z"
      fill="white"
      fill-opacity="0.5"
    />
    <path
      d="M27.9354 47.6694C27.9354 47.0114 28.4688 46.478 29.1268 46.478H33.8921C34.5501 46.478 35.0834 47.0114 35.0834 47.6694V52.4347C35.0834 53.0926 34.5501 53.626 33.8921 53.626H29.1268C28.4688 53.626 27.9354 53.0926 27.9354 52.4347V47.6694Z"
      fill="#41D1FF"
      v-show="active"
    />
    <path
      d="M27.9354 47.6694C27.9354 47.0114 28.4688 46.478 29.1268 46.478H33.8921C34.5501 46.478 35.0834 47.0114 35.0834 47.6694V52.4347C35.0834 53.0926 34.5501 53.626 33.8921 53.626H29.1268C28.4688 53.626 27.9354 53.0926 27.9354 52.4347V47.6694Z"
      fill="white"
      fill-opacity="0.5"
    />
    <path
      d="M18.4048 47.6694C18.4048 47.0114 18.9382 46.478 19.5961 46.478H24.3614C25.0194 46.478 25.5528 47.0114 25.5528 47.6694V52.4347C25.5528 53.0926 25.0194 53.626 24.3614 53.626H19.5961C18.9382 53.626 18.4048 53.0926 18.4048 52.4347V47.6694Z"
      fill="#41D1FF"
      v-show="active"
    />
    <path
      d="M18.4048 47.6694C18.4048 47.0114 18.9382 46.478 19.5961 46.478H24.3614C25.0194 46.478 25.5528 47.0114 25.5528 47.6694V52.4347C25.5528 53.0926 25.0194 53.626 24.3614 53.626H19.5961C18.9382 53.626 18.4048 53.0926 18.4048 52.4347V47.6694Z"
      fill="white"
      fill-opacity="0.5"
    />
    <g filter="url(#filter2_f_1_2)" v-show="active">
      <path
        d="M18.4048 57.9946C18.4048 57.3366 18.9382 56.8032 19.5961 56.8032H24.3614C25.0194 56.8032 25.5528 57.3366 25.5528 57.9946V62.7599C25.5528 63.4179 25.0194 63.9512 24.3614 63.9512H19.5961C18.9382 63.9512 18.4048 63.4179 18.4048 62.7599V57.9946Z"
        fill="#41D1FF"
      />
      <path
        d="M27.9354 57.9946C27.9354 57.3366 28.4688 56.8032 29.1268 56.8032H33.8921C34.5501 56.8032 35.0834 57.3366 35.0834 57.9946V62.7599C35.0834 63.4179 34.5501 63.9512 33.8921 63.9512H29.1268C28.4688 63.9512 27.9354 63.4179 27.9354 62.7599V57.9946Z"
        fill="#41D1FF"
      />
      <path
        d="M27.9354 47.6694C27.9354 47.0114 28.4688 46.478 29.1268 46.478H33.8921C34.5501 46.478 35.0834 47.0114 35.0834 47.6694V52.4347C35.0834 53.0926 34.5501 53.626 33.8921 53.626H29.1268C28.4688 53.626 27.9354 53.0926 27.9354 52.4347V47.6694Z"
        fill="#41D1FF"
      />
    </g>
    <defs>
      <filter
        id="filter0_d_1_2"
        x="35.0831"
        y="0.114583"
        width="106.183"
        height="64.0563"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feColorMatrix
          in="SourceAlpha"
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          result="hardAlpha"
        />
        <feOffset dy="2.30833" />
        <feGaussianBlur stdDeviation="2.30833" />
        <feComposite in2="hardAlpha" operator="out" />
        <feColorMatrix
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.65 0"
        />
        <feBlend
          mode="normal"
          in2="BackgroundImageFix"
          result="effect1_dropShadow_1_2"
        />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="effect1_dropShadow_1_2"
          result="shape"
        />
      </filter>
      <filter
        id="filter1_i_1_2"
        x="10.1243"
        y="38.0579"
        width="33.7597"
        height="33.7597"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feColorMatrix
          in="SourceAlpha"
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          result="hardAlpha"
        />
        <feOffset />
        <feGaussianBlur stdDeviation="2.30833" />
        <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
        <feColorMatrix
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.85 0"
        />
        <feBlend mode="normal" in2="shape" result="effect1_innerShadow_1_2" />
      </filter>
      <filter
        id="filter2_f_1_2"
        x="0.802473"
        y="28.8757"
        width="51.8833"
        height="52.6778"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="8.80116"
          result="effect1_foregroundBlur_1_2"
        />
      </filter>
    </defs>
  </svg>
  <!-- Blue Glow -->
  <div class="blue-glow" :class="{ active: active }" />
</template>

<style scoped>
.blue-indicator {
  position: absolute;
  top: 387px;
  left: 680px;
  opacity: 0.2;
  transition: opacity 1s ease-in-out;

  &.active {
    transition: opacity 0.2s ease-in-out;
    opacity: 0.6;
  }
}

.blue-glow {
  background-color: #41d1ff;
  width: 100px;
  aspect-ratio: 2;
  position: absolute;
  top: 415px;
  left: 655px;
  z-index: -1;
  filter: blur(40px);
  opacity: 0;
  transition: all 3s ease-out;
  will-change: opacity;
  display: none;

  @media (min-width: 768px) {
    display: block;
    filter: blur(60px);
  }

  &.active {
    transition: all 0.2s ease-in-out;
    opacity: 0.8;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/svg-elements/SvgInputs.vue
================================================
<script setup lang="ts">
import SvgNode, { type SvgNodeProps } from '../../common/SvgNode.vue'
import type { Ref } from 'vue'

defineProps({
  inputLines: {
    type: Array as () => Ref<SvgNodeProps>[],
    required: true,
  },
})
</script>

<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="844"
    height="644"
    viewBox="0 0 844 644"
    fill="none"
    class="input-lines"
  >
    <!-- Input Lines -->
    <g v-for="inputLine in inputLines" :key="inputLine.value.path">
      <path
        :d="inputLine.value.path"
        stroke="url(#base_gradient)"
        stroke-width="1.2"
        style="opacity: 0.8"
      />
      <SvgNode v-bind="inputLine.value" />
    </g>

    <defs>
      <linearGradient
        id="base_gradient"
        x1="88.1032"
        y1="324.167"
        x2="843.505"
        y2="324.167"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0" stop-color="#c6caff" stop-opacity="0" />
        <stop offset="0.2" stop-color="#c6caff" stop-opacity="0.1" />
        <stop offset="0.4" stop-color="white" stop-opacity="0.4" />
        <stop offset="0.6" stop-color="#c6caff" stop-opacity="0.2" />
        <stop offset="0.8" stop-color="#c6caff" stop-opacity="0.2" />
        <stop offset="0.9" stop-color="#c6caff" stop-opacity="0" />
      </linearGradient>
    </defs>
  </svg>
</template>

<style scoped>
.input-lines {
  transform: translate3d(0, 0, 0);

  &:deep(.circle-dot) {
    display: none;

    @media (min-width: 768px) {
      display: block;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/svg-elements/SvgOutputs.vue
================================================
<script setup lang="ts">
import SvgNode, { type SvgNodeProps } from '../../common/SvgNode.vue'
import type { Ref } from 'vue'

defineProps({
  outputLines: {
    type: Array as () => Ref<SvgNodeProps>[],
    required: true,
  },
})
</script>

<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="844"
    height="80"
    viewBox="0 0 844 40"
    fill="none"
    class="output-line"
    style="opacity: 0.8"
  >
    <path
      d="M843.463 1.3315L245.316 5.47507L0.633077 4.69725"
      stroke="url(#output_gradient)"
      stroke-width="1.2"
    />
    <g v-for="outputLine in outputLines">
      <SvgNode
        path="M843.463 1.3315L245.316 5.47507L0.633077 4.69725"
        :position="outputLine.value.position"
        :visible="outputLine.value.visible"
        :label-visible="outputLine.value.labelVisible"
        :label="outputLine.value.label"
        dot-color="#d499ff"
        glow-color="#BD34FE"
      />
    </g>
    <defs>
      <linearGradient id="output_gradient" gradientUnits="userSpaceOnUse">
        <stop offset="0.1" stop-color="#E0C8FF" stop-opacity="0" />
        <stop offset="0.4" stop-color="#E0C8FF" stop-opacity="0.4" />
        <stop offset="1" stop-color="#E0C8FF" stop-opacity="0" />
      </linearGradient>
    </defs>
  </svg>
</template>

<style scoped>
.output-line {
  position: absolute;
  top: 300px;
  left: 785px;
  transform: translate3d(0, 0, 0);
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/1. hero-section/svg-elements/SvgPinkIndicator.vue
================================================
<script setup lang="ts">
defineProps({
  active: {
    type: Boolean,
    required: true,
    default: false,
  },
})
</script>

<template>
  <svg
    width="141"
    height="67"
    viewBox="0 0 141 67"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    class="pink-indicator"
    :class="{ active: active }"
  >
    <g opacity="0.2" filter="url(#filter0_d_1_8)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M5.48397 58.9922L5.48397 36.8651C5.48397 30.4908 10.6514 25.3234 17.0256 25.3234L101.28 25.3234L101.28 27.6318L17.0256 27.6318C11.9262 27.6318 7.7923 31.7657 7.7923 36.8651L7.7923 58.9922L5.48397 58.9922Z"
        fill="#0D0D0D"
      />
      <path
        d="M5.19543 58.9922L5.19543 59.2807L5.48397 59.2807L7.79231 59.2807L8.08085 59.2807L8.08085 58.9922L8.08085 36.8651C8.08085 31.925 12.0856 27.9203 17.0256 27.9203L101.28 27.9203L101.568 27.9203L101.568 27.6318L101.568 25.3234L101.568 25.0349L101.28 25.0349L17.0256 25.0349C10.492 25.0349 5.19542 30.3315 5.19543 36.8651L5.19543 58.9922Z"
        stroke="#404040"
        stroke-width="0.577083"
      />
    </g>
    <g filter="url(#filter1_i_1_8)">
      <rect
        x="130.134"
        y="12.0518"
        width="30.0083"
        height="30.0083"
        rx="5.01812"
        transform="rotate(90 130.134 12.0518)"
        fill="#1F1F1F"
      />
    </g>
    <rect
      x="130.134"
      y="12.0518"
      width="30.0083"
      height="30.0083"
      rx="5.01812"
      transform="rotate(90 130.134 12.0518)"
      stroke="#2C2C2C"
      stroke-opacity="0.4"
      stroke-width="3.75141"
    />
    <g filter="url(#filter2_f_1_8)">
      <path
        d="M123.152 23.9976C123.152 24.6556 122.619 25.1889 121.961 25.1889L117.196 25.1889C116.538 25.1889 116.004 24.6556 116.004 23.9976L116.004 19.2323C116.004 18.5743 116.538 18.041 117.196 18.041L121.961 18.041C122.619 18.041 123.152 18.5743 123.152 19.2323L123.152 23.9976Z"
        fill="#BD34FE"
      />
      <path
        d="M113.622 23.9976C113.622 24.6556 113.088 25.1889 112.43 25.1889L107.665 25.1889C107.007 25.1889 106.474 24.6556 106.474 23.9976L106.474 19.2323C106.474 18.5743 107.007 18.041 107.665 18.041L112.43 18.041C113.088 18.041 113.622 18.5743 113.622 19.2323L113.622 23.9976Z"
        fill="#BD34FE"
      />
      <path
        d="M113.622 34.3228C113.622 34.9808 113.088 35.5142 112.43 35.5142L107.665 35.5142C107.007 35.5142 106.474 34.9808 106.474 34.3228L106.474 29.5575C106.474 28.8996 107.007 28.3662 107.665 28.3662L112.43 28.3662C113.088 28.3662 113.622 28.8996 113.622 29.5575L113.622 34.3228Z"
        fill="#BD34FE"
      />
    </g>
    <rect
      x="110.513"
      y="22.439"
      width="9.23333"
      height="9.23333"
      rx="1.15417"
      fill="#BD34FE"
      v-show="active"
    />
    <rect
      x="110.513"
      y="22.439"
      width="9.23333"
      height="9.23333"
      rx="1.15417"
      fill="white"
      fill-opacity="0.5"
    />
    <g filter="url(#filter3_f_1_8)">
      <rect
        x="108.205"
        y="20.1309"
        width="13.85"
        height="13.85"
        rx="1.73125"
        fill="#BD34FE"
        fill-opacity="0.5"
        v-show="active"
      />
    </g>
    <defs>
      <filter
        id="filter0_d_1_8"
        x="0.290218"
        y="22.438"
        width="106.183"
        height="44.0563"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feColorMatrix
          in="SourceAlpha"
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          result="hardAlpha"
        />
        <feOffset dy="2.30833" />
        <feGaussianBlur stdDeviation="2.30833" />
        <feComposite in2="hardAlpha" operator="out" />
        <feColorMatrix
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.65 0"
        />
        <feBlend
          mode="normal"
          in2="BackgroundImageFix"
          result="effect1_dropShadow_1_8"
        />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="effect1_dropShadow_1_8"
          result="shape"
        />
      </filter>
      <filter
        id="filter1_i_1_8"
        x="98.2503"
        y="10.1761"
        width="33.7597"
        height="33.7597"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feColorMatrix
          in="SourceAlpha"
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          result="hardAlpha"
        />
        <feOffset />
        <feGaussianBlur stdDeviation="2.30833" />
        <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
        <feColorMatrix
          type="matrix"
          values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.85 0"
        />
        <feBlend mode="normal" in2="shape" result="effect1_innerShadow_1_8" />
      </filter>
      <filter
        id="filter2_f_1_8"
        x="88.8714"
        y="0.438646"
        width="51.8833"
        height="52.6778"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="8.80116"
          result="effect1_foregroundBlur_1_8"
        />
      </filter>
      <filter
        id="filter3_f_1_8"
        x="96.6634"
        y="8.58919"
        width="36.9333"
        height="36.9333"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="5.77083"
          result="effect1_foregroundBlur_1_8"
        />
      </filter>
    </defs>
  </svg>
  <!-- Pink Glow -->
  <div class="pink-glow" :class="{ active: active }" />
</template>

<style scoped>
.pink-indicator {
  position: absolute;
  top: 202px;
  left: 840px;
  opacity: 0.2;
  transition: opacity 1s ease-in-out;

  &.active {
    transition: opacity 0.2s ease-in-out;
    opacity: 0.6;
  }
}

.pink-glow {
  background-color: #bd34fe;
  width: 100px;
  aspect-ratio: 2;
  position: absolute;
  top: 202px;
  left: 905px;
  z-index: -1;
  filter: blur(40px);
  opacity: 0;
  transition: all 3s ease-out;
  will-change: opacity;
  display: none;

  @media (min-width: 768px) {
    display: block;
    filter: blur(60px);
  }

  &.active {
    transition: all 0.2s ease-in-out;
    opacity: 0.8;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureCI.vue
================================================
<script setup lang="ts">
import { type Ref, ref } from 'vue'
import SvgNode from '../common/SvgNode.vue'
import { gsap } from 'gsap'
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

// Animation state
const glowPosition: Ref<number> = ref(0)
const glowVisible: Ref<boolean> = ref(false)
const checkmarks = Array.from({ length: 13 }, (): Ref<boolean> => ref(false))

/**
 * Slide the card in when the page loads
 */
useSlideIn('#continuous-integration')

/**
 * Start the animation when the card is hovered
 */
const { startAnimation, isCardActive } = useCardAnimation(
  '#continuous-integration',
  () => {
    // Reset initial state
    glowPosition.value = 0
    glowVisible.value = false

    // Define the timeline
    const timeline = gsap.timeline()

    // Move the glowing lines from top to bottom
    timeline.to(
      glowPosition,
      {
        value: 1,
        duration: 1.5,
        ease: 'power2.in',
      },
      0,
    )

    // Make the glowing lines visible
    timeline.call(
      () => {
        glowVisible.value = true
      },
      undefined,
      0.2,
    )
    // Make the glowing lines hidden shortly after
    timeline.call(
      () => {
        glowVisible.value = false
      },
      undefined,
      1.1,
    )

    // Stagger the checkmarks
    checkmarks.forEach((checkmark, index) => {
      timeline.call(
        () => {
          checkmark.value = true
        },
        undefined,
        1.3 + index * 0.2,
      )
    })

    // All done
    return timeline
  },
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="continuous-integration"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization" :class="{ active: isCardActive }">
      <div class="camera-container">
        <svg
          class="grid"
          width="720"
          height="241"
          viewBox="0 0 720 241"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M1.00048 119.402L200.243 68.2732C213.283 65.4129 221.832 58.4923 221.832 50.7968V20.323V1M1.00048 136.779L231.212 68.7423C242.847 65.5523 250.195 59.0356 250.195 51.9076V20.323V1M1 165.731L263.267 69.1267C272.82 65.6348 278.558 59.7587 278.558 53.4667V20.323V1M719.001 154.23L464.019 69.1276C454.474 65.6348 448.743 59.7616 448.743 53.4731V20.323V1M719.001 125.219L496.078 68.7439C484.449 65.5528 477.106 59.0377 477.106 51.9119V20.323V1M719 107.817L527.05 68.2749C514.015 65.4134 505.469 58.4939 505.469 50.8001V20.323V1M719.001 96.2159L557.314 67.8323C543.291 65.2673 533.835 58.0756 533.835 49.976V20.323V9.78386C533.835 4.93267 529.902 1 525.051 1H505.469M1 107.817L169.982 67.8308C184.008 65.2668 193.467 58.0743 193.467 49.9735V20.323V9.78387C193.467 4.93267 197.4 1 202.251 1H221.832M221.832 1H250.195M250.195 1H278.558M278.558 1H306.924M306.924 1V20.323V55.7423C306.924 60.7337 303.306 65.5207 296.865 69.0509L62.8139 197.336C52.968 202.733 46.8471 213.068 46.8471 224.296V240.342M306.924 1H335.286M335.286 1V20.323V59.0919C335.286 62.0155 334.043 64.8989 331.656 67.5136L213.175 197.282C208.003 202.947 205.136 210.34 205.136 218.011V240.342M335.286 1H363.65M363.65 1V20.323L363.428 206.088V240.342M363.65 1H392.015M392.015 1V20.323V59.1056C392.015 62.0204 393.25 64.8954 395.624 67.5041L513.712 197.291C518.862 202.951 521.716 210.328 521.716 217.981V240.342M392.015 1H420.377M420.377 1V20.323V55.7518C420.377 60.7376 423.987 65.5197 430.415 69.0489L664.058 197.332C673.893 202.732 680.005 213.061 680.005 224.28V240.342M420.377 1H448.743M448.743 1H477.106M477.106 1H505.469"
            stroke="url(#paint0_linear_0_3)"
          />
          <defs>
            <linearGradient
              id="paint0_linear_0_3"
              x1="362.013"
              y1="-25.478"
              x2="362.013"
              y2="240.781"
              gradientUnits="userSpaceOnUse"
            >
              <stop offset="0" stop-color="white" stop-opacity="0" />
              <stop offset="0.7" stop-color="white" stop-opacity="0.35" />
              <stop offset="1" stop-color="white" stop-opacity="0" />
            </linearGradient>
          </defs>
        </svg>
        <span class="ci-text">CI Tests</span>
        <div class="checkmark-container">
          <svg
            class="checkmark"
            v-for="i in 5"
            :class="{ active: checkmarks[i].value }"
            width="52"
            height="52"
            viewBox="0 0 52 52"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <g
              class="circle-glow"
              opacity="0.4"
              filter="url(#filter-circle-glow)"
            >
              <circle cx="25.712" cy="25.9725" r="17.6105" fill="#13B351" />
            </g>
            <circle
              class="circle-bg"
              cx="25.712"
              cy="25.9725"
              r="18.0268"
              fill="#171717"
            />
            <circle
              class="circle-specular"
              cx="25.712"
              cy="25.9725"
              r="18.0268"
              stroke="url(#radial-circle-specular)"
              stroke-width="0.8"
            />
            <path
              class="checkmark-icon"
              d="M32.4256 21.1798C32.3326 21.086 32.2219 21.0115 32.1 20.9607C31.9781 20.9099 31.8473 20.8838 31.7152 20.8838C31.5831 20.8838 31.4523 20.9099 31.3304 20.9607C31.2085 21.0115 31.0978 21.086 31.0048 21.1798L23.5504 28.6442L20.4185 25.5023C20.3219 25.409 20.2079 25.3357 20.083 25.2864C19.9581 25.2372 19.8246 25.2131 19.6904 25.2154C19.5561 25.2177 19.4236 25.2465 19.3005 25.3C19.1773 25.3535 19.0659 25.4308 18.9726 25.5273C18.8793 25.6239 18.806 25.7379 18.7568 25.8629C18.7075 25.9878 18.6834 26.1212 18.6857 26.2555C18.688 26.3897 18.7168 26.5222 18.7703 26.6454C18.8238 26.7685 18.9011 26.8799 18.9977 26.9732L22.8399 30.8155C22.933 30.9093 23.0436 30.9837 23.1656 31.0345C23.2875 31.0853 23.4183 31.1115 23.5504 31.1115C23.6824 31.1115 23.8132 31.0853 23.9352 31.0345C24.0571 30.9837 24.1678 30.9093 24.2608 30.8155L32.4256 22.6506C32.5272 22.5569 32.6082 22.4432 32.6637 22.3166C32.7191 22.1901 32.7477 22.0534 32.7477 21.9152C32.7477 21.777 32.7191 21.6403 32.6637 21.5138C32.6082 21.3872 32.5272 21.2735 32.4256 21.1798Z"
              fill="#7fd5a0"
            />
            <g
              class="checkmark-icon__glow"
              filter="url(#filter-checkmark-icon-glow)"
            >
              <path
                d="M32.4256 21.1798C32.3326 21.086 32.2219 21.0115 32.1 20.9607C31.9781 20.9099 31.8473 20.8838 31.7152 20.8838C31.5831 20.8838 31.4523 20.9099 31.3304 20.9607C31.2085 21.0115 31.0978 21.086 31.0048 21.1798L23.5504 28.6442L20.4185 25.5023C20.3219 25.409 20.2079 25.3357 20.083 25.2864C19.9581 25.2372 19.8246 25.2131 19.6904 25.2154C19.5561 25.2177 19.4236 25.2465 19.3005 25.3C19.1773 25.3535 19.0659 25.4308 18.9726 25.5273C18.8793 25.6239 18.806 25.7379 18.7568 25.8629C18.7075 25.9878 18.6834 26.1212 18.6857 26.2555C18.688 26.3897 18.7168 26.5222 18.7703 26.6454C18.8238 26.7685 18.9011 26.8799 18.9977 26.9732L22.8399 30.8155C22.933 30.9093 23.0436 30.9837 23.1656 31.0345C23.2875 31.0853 23.4183 31.1115 23.5504 31.1115C23.6824 31.1115 23.8132 31.0853 23.9352 31.0345C24.0571 30.9837 24.1678 30.9093 24.2608 30.8155L32.4256 22.6506C32.5272 22.5569 32.6082 22.4432 32.6637 22.3166C32.7191 22.1901 32.7477 22.0534 32.7477 21.9152C32.7477 21.777 32.7191 21.6403 32.6637 21.5138C32.6082 21.3872 32.5272 21.2735 32.4256 21.1798Z"
                fill="#13B351"
              />
            </g>
            <defs>
              <filter
                id="filter-circle-glow"
                x="0.0968113"
                y="0.357309"
                width="51.2302"
                height="51.2304"
                filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB"
              >
                <feFlood flood-opacity="0" result="BackgroundImageFix" />
                <feBlend
                  mode="normal"
                  in="SourceGraphic"
                  in2="BackgroundImageFix"
                  result="shape"
                />
                <feGaussianBlur
                  stdDeviation="4.00238"
                  result="effect1_foregroundBlur_698_23226"
                />
              </filter>
              <filter
                id="filter-checkmark-icon-glow"
                x="-2.30491"
                y="-2.04392"
                width="56.0332"
                height="56.0332"
                filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB"
              >
                <feFlood flood-opacity="0" result="BackgroundImageFix" />
                <feBlend
                  mode="normal"
                  in="SourceGraphic"
                  in2="BackgroundImageFix"
                  result="shape"
                />
                <feGaussianBlur
                  stdDeviation="8.00475"
                  result="effect1_foregroundBlur_698_23226"
                />
              </filter>
              <radialGradient
                id="radial-circle-specular"
                cx="0"
                cy="0"
                r="1"
                gradientUnits="userSpaceOnUse"
                gradientTransform="translate(33.4166 23.1423) rotate(110.653) scale(21.8445)"
              >
                <stop offset="0" stop-color="white" />
                <stop offset="1" stop-opacity="0" />
              </radialGradient>
            </defs>
          </svg>
        </div>
        <svg
          class="grid"
          width="720"
          height="241"
          viewBox="0 0 720 241"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <SvgNode
            path="M1.00048 119.402L200.243 68.2732C213.283 65.4129 221.832 58.4923 221.832 50.7968V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M1.00048 136.779L231.212 68.7423C242.847 65.5523 250.195 59.0356 250.195 51.9076V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M1 165.731L263.267 69.1267C272.82 65.6348 278.558 59.7587 278.558 53.4667V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M719.001 154.23L464.019 69.1276C454.474 65.6348 448.743 59.7616 448.743 53.4731V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M719.001 125.219L496.078 68.7439C484.449 65.5528 477.106 59.0377 477.106 51.9119V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M719 107.817L527.05 68.2749C514.015 65.4134 505.469 58.4939 505.469 50.8001V20.323V1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M719.001 96.2159L557.314 67.8323C543.291 65.2673 533.835 58.0756 533.835 49.976V20.323V9.78386C533.835 4.93267 529.902 1 525.051 1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M1 107.817L169.982 67.8308C184.008 65.2668 193.467 58.0743 193.467 49.9735V20.323V9.78387C193.467 4.93267 197.4 1 202.251 1"
            :position="glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M306.924 1V20.323V55.7423C306.924 60.7337 303.306 65.5207 296.865 69.0509L62.8139 197.336C52.968 202.733 46.8471 213.068 46.8471 224.296V240.342"
            :position="1 - glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M335.286 1V20.323V59.0919C335.286 62.0155 334.043 64.8989 331.656 67.5136L213.175 197.282C208.003 202.947 205.136 210.34 205.136 218.011V240.342"
            :position="1 - glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M363.65 1V20.323L363.428 206.088V240.342"
            :position="1 - glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M392.015 1V20.323V59.1056C392.015 62.0204 393.25 64.8954 395.624 67.5041L513.712 197.291C518.862 202.951 521.716 210.328 521.716 217.981V240.342"
            :position="1 - glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
          <SvgNode
            path="M420.377 1V20.323V55.7518C420.377 60.7376 423.987 65.5197 430.415 69.0489L664.058 197.332C673.893 202.732 680.005 213.061 680.005 224.28V240.342"
            :position="1 - glowPosition"
            :visible="glowVisible"
            :dot-color="undefined"
            glow-color="#13B351"
          />
        </svg>
      </div>
    </div>
    <div class="feature__meta meta--center">
      <div class="meta__title">Continuous ecosystem integration</div>
      <div class="meta__description">
        Our CI continuously tests Vite changes against downstream projects,
        allowing us to improve Vite with stability and confidence.
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(60px, 0, 0);
  }

  .feature__meta {
    max-width: 500px;
  }

  /* Extend height on smaller devices, to make room for text */
  @media (max-width: 450px) {
    height: 420px;
  }

  /* Even smaller in some cases */
  @media (max-width: 380px) {
    height: 460px;
  }
}

.feature__visualization {
  mask-image: linear-gradient(
    to bottom,
    #ffffff,
    #ffffff 180px,
    transparent 240px
  );
  position: relative;

  .camera-container {
    width: 720px;
    left: 50%;
    position: relative;
    transition: transform 3s ease;
    transform: translate3d(-50%, 80px, 0) scale(1.05);
  }

  .grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 720px;
  }

  .ci-text {
    position: absolute;
    top: -10px;
    left: 319px;
    color: #fff;
    text-align: center;
    font-family:
      IBM Plex Mono,
      sans-serif;
    font-size: 12px;
    font-style: normal;
    font-weight: 500;
    line-height: 150%;
    display: block;
    border-radius: 6px;
    border: 1px solid #2c2c2c;
    background: #171717;
    padding: 6px 14px;
    z-index: 5;
  }

  .checkmark-container {
    position: relative;

    &:after {
      content: '';
      position: absolute;
      top: 160px;
      left: 0;
      right: 0;
      width: 100%;
      height: 200px;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(19, 179, 81, 0.5)
      );
      transition: all 3s ease;
      transform: translate3d(0, 0, 0) scaleY(0);
      opacity: 0;
      will-change: transform, opacity;
    }
  }

  .checkmark {
    position: absolute;
    top: 220px;
    filter: drop-shadow(0px 0px 0px rgba(19, 179, 81, 0));
    z-index: 5;

    .circle-glow,
    .checkmark-icon__glow,
    .checkmark-icon {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    &:nth-child(1) {
      left: 22px;
    }

    &:nth-child(2) {
      left: 180px;
    }

    &:nth-child(3) {
      left: 338px;
    }

    &:nth-child(4) {
      left: 497px;
    }

    &:nth-child(5) {
      left: 655px;
    }

    &:not(:nth-child(3)) {
      display: none;
    }

    @media (min-width: 500px) {
      &:not(:nth-child(3)) {
        display: block;
      }
    }

    @media (min-width: 640px) {
      &:not(:nth-child(3)) {
        display: none;
      }
    }

    @media (min-width: 1040px) {
      &:not(:nth-child(3)) {
        display: block;
      }
    }

    &.active {
      filter: drop-shadow(0px -20px 20px rgba(19, 179, 81, 0.7));

      .circle-glow,
      .checkmark-icon__glow,
      .checkmark-icon {
        transition: opacity 0.15s ease-in-out;
        opacity: 1;
      }
    }
  }

  &.active {
    .checkmark-container {
      &:after {
        transition-delay: 2.5s;
        transition-duration: 0.5s;
        transform: translate3d(0, 0, 0) scaleY(1);
        opacity: 1;
      }
    }

    .camera-container {
      transition: transform 1.5s ease 1s;
      transform: translate3d(-50%, -100px, 0) scale(1.05);
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureFlexiblePlugins.vue
================================================
<script setup lang="ts">
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

/**
 * Slide the card in when the page loads
 */
useSlideIn('#flexible-plugin-system')

/**
 * Start the animation when the card is hovered
 */
const { isCardActive, startAnimation } = useCardAnimation(
  '#flexible-plugin-system',
  undefined,
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="flexible-plugin-system"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization" :class="{ active: isCardActive }">
      <div class="diagram">
        <!-- Diagram -->
        <svg
          width="686"
          height="218"
          viewBox="0 0 686 218"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g>
            <g class="pink-chip__base">
              <rect
                width="35.0955"
                height="35.0923"
                rx="5.87331"
                transform="matrix(-0.845602 0.533814 -0.895247 -0.44557 611.937 102.855)"
                fill="#1F1F1F"
              />
              <rect
                width="35.0955"
                height="35.0923"
                rx="5.87331"
                transform="matrix(-0.845602 0.533814 -0.895247 -0.44557 611.937 102.855)"
                stroke="#2C2C2C"
                stroke-opacity="0.4"
                stroke-width="4"
              />
            </g>
            <g class="pink-chip__cube">
              <path
                d="M573.798 105.165L573.684 96.2398L581.79 90.9291L590.029 96.0306L590.143 104.956L582.027 109.523L573.798 105.165Z"
                fill="#BD34FE"
              />
              <path
                d="M573.798 105.165L573.684 96.2398L581.79 90.9291L590.029 96.0306L590.143 104.956L582.027 109.523L573.798 105.165Z"
                fill="white"
                fill-opacity="0.5"
              />
            </g>
            <path
              class="pink-chip__connection"
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M440.083 64.7972L456.9 53.3972C463.204 49.4177 473.724 48.8842 480.397 52.2055L565 94.5L562.717 95.9411L478.114 53.6466C472.776 50.9895 464.359 51.4164 459.316 54.6L442.5 66L440.083 64.7972Z"
              fill="#BD34FE"
              stroke-width="1.2"
              stroke="#BD34FE"
            />
            <path
              class="blue-chip__connection"
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M270 130L230.567 154.669C224.263 158.648 213.743 159.182 207.07 155.86L122.717 113.941L125 112.5L209.353 154.419C214.691 157.076 223.108 156.65 228.151 153.466L267.583 128.797L270 130Z"
              fill="#41d1ff"
              stroke-width="1.2"
              stroke="#41d1ff"
            />
            <g class="blue-chip__base">
              <rect
                width="35.0955"
                height="35.0923"
                rx="5.87331"
                transform="matrix(0.845602 -0.533814 0.895247 0.44557 76.1337 105.512)"
                fill="#1F1F1F"
                shape-rendering="crispEdges"
              />
              <rect
                width="35.0955"
                height="35.0923"
                rx="5.87331"
                transform="matrix(0.845602 -0.533814 0.895247 0.44557 76.1337 105.512)"
                stroke="#2C2C2C"
                stroke-opacity="0.4"
                stroke-width="4.39073"
                shape-rendering="crispEdges"
              />
            </g>
            <g class="blue-chip__cube">
              <path
                d="M99.902 97.3307L99.7304 90.3097L106.066 86.0571L112.601 89.995L112.773 97.016L106.423 100.684L99.902 97.3307Z"
                fill="#41D1FF"
              />
              <path
                d="M99.902 97.3307L99.7304 90.3097L106.066 86.0571L112.601 89.995L112.773 97.016L106.423 100.684L99.902 97.3307Z"
                fill="white"
                fill-opacity="0.5"
              />
              <path
                d="M110.272 103.431L110.1 96.4099L116.435 92.1574L122.971 96.0953L123.143 103.116L116.793 106.784L110.272 103.431Z"
                fill="#41D1FF"
              />
              <path
                d="M110.272 103.431L110.1 96.4099L116.435 92.1574L122.971 96.0953L123.143 103.116L116.793 106.784L110.272 103.431Z"
                fill="white"
                fill-opacity="0.5"
              />
              <path
                d="M89.6627 103.976L89.491 96.9545L95.8263 92.7019L102.362 96.6398L102.533 103.661L96.1839 107.328L89.6627 103.976Z"
                fill="#41D1FF"
              />
              <path
                d="M89.6627 103.976L89.491 96.9545L95.8263 92.7019L102.362 96.6398L102.533 103.661L96.1839 107.328L89.6627 103.976Z"
                fill="white"
                fill-opacity="0.5"
              />
              <path
                d="M99.4817 109.323L99.31 102.302L105.645 98.0495L112.181 101.987L112.352 109.008L106.003 112.676L99.4817 109.323Z"
                fill="#41D1FF"
              />
              <path
                d="M99.4817 109.323L99.31 102.302L105.645 98.0495L112.181 101.987L112.352 109.008L106.003 112.676L99.4817 109.323Z"
                fill="white"
                fill-opacity="0.5"
              />
            </g>
            <g class="vite-chip" filter="url(#filter-chip-shadow)">
              <g
                class="vite-chip__highlight"
                filter="url(#filter-vite-chip-highlight)"
              >
                <rect
                  width="153.998"
                  height="153.998"
                  rx="12.1578"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 330.524 11.7643)"
                  fill="black"
                  fill-opacity="0.3"
                />
                <rect
                  width="153.998"
                  height="153.998"
                  rx="12.1578"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 330.524 11.7643)"
                  fill="url(#gradient-vite-chip-highlight)"
                  fill-opacity="0.1"
                />
                <rect
                  x="-0.0335319"
                  y="-0.661506"
                  width="155.349"
                  height="155.349"
                  rx="12.8332"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 329.961 11.4709)"
                  stroke="#111111"
                  stroke-opacity="0.2"
                  stroke-width="1.35086"
                />
              </g>
              <g class="vite-chip__base" opacity="0.6">
                <rect
                  x="-0.0335319"
                  y="-0.661506"
                  width="152.647"
                  height="152.647"
                  rx="11.4823"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 330.028 12.7942)"
                  fill="#1E1E1E"
                  fill-opacity="0.4"
                />
                <rect
                  x="-0.0335319"
                  y="-0.661506"
                  width="152.647"
                  height="152.647"
                  rx="11.4823"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 330.028 12.7942)"
                  stroke="url(#gradient-vite-chip-right-specular)"
                  stroke-width="1.2"
                />
                <rect
                  x="-0.0335319"
                  y="-0.661506"
                  width="152.647"
                  height="152.647"
                  rx="11.4823"
                  transform="matrix(0.895247 0.44557 -0.845602 0.533814 330.028 12.7942)"
                  stroke="url(#gradient-vite-chip-left-specular)"
                  stroke-opacity="0.1"
                  stroke-width="1.2"
                />
              </g>
              <g class="vite-chip__logo">
                <path
                  class="vite-chip__v"
                  opacity="0.8"
                  d="M395.642 83.0289L299.921 103.639C297.944 104.064 296.066 103.138 296.569 101.986L321.062 45.9169C321.611 44.6617 324.458 44.2276 325.784 45.1971L355.04 66.5878C355.227 66.7242 355.458 66.8388 355.722 66.926L396.329 80.3179C398.203 80.9357 397.789 82.5664 395.642 83.0289Z"
                  fill="url(#gradient-vite-chip-logo-v)"
                />
                <path
                  class="vite-chip__bolt"
                  d="M385.841 66.1307L354.84 56.2356C354.33 56.0729 353.664 56.1348 353.22 56.386L325.622 71.9952C324.972 72.3629 325.084 72.9547 325.845 73.178L334.719 75.7797C335.549 76.0232 335.589 76.6913 334.794 77.0355L322.502 82.3582C321.675 82.7165 321.759 83.4171 322.656 83.6352L328.452 85.0438C329.35 85.2623 329.434 85.9642 328.604 86.3219L309.255 94.6628C308.045 95.1845 308.884 96.2149 310.314 95.9628L311.269 95.7944L373.22 80.696C374.258 80.4432 374.42 79.6472 373.495 79.3499L364.632 76.5008C363.799 76.233 363.829 75.5392 364.686 75.2218L385.79 67.4107C386.649 67.0927 386.677 66.3975 385.841 66.1307Z"
                  fill="url(#gradient-vite-chip-logo-bolt)"
                />
              </g>
            </g>
          </g>
          <defs>
            <filter
              id="filter-chip-shadow"
              x="158.878"
              y="-7.1193"
              width="350.919"
              height="231.696"
              filterUnits="userSpaceOnUse"
              color-interpolation-filters="sRGB"
            >
              <feFlood flood-opacity="0" result="BackgroundImageFix" />
              <feColorMatrix
                in="SourceAlpha"
                type="matrix"
                values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                result="hardAlpha"
              />
              <feOffset dy="21.6138" />
              <feGaussianBlur stdDeviation="19.5875" />
              <feComposite in2="hardAlpha" operator="out" />
              <feColorMatrix
                type="matrix"
                values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 0"
              />
              <feBlend
                mode="normal"
                in2="BackgroundImageFix"
                result="effect1_dropShadow_0_5"
              />
              <feBlend
                mode="normal"
                in="SourceGraphic"
                in2="effect1_dropShadow_0_5"
                result="shape"
              />
            </filter>
            <filter
              id="filter-vite-chip-highlight"
              x="177.815"
              y="-12.739"
              width="313.063"
              height="199.83"
              filterUnits="userSpaceOnUse"
              color-interpolation-filters="sRGB"
            >
              <feFlood flood-opacity="0" result="BackgroundImageFix" />
              <feGaussianBlur in="BackgroundImageFix" stdDeviation="13.5086" />
              <feComposite
                in2="SourceAlpha"
                operator="in"
                result="effect1_backgroundBlur_0_5"
              />
              <feBlend
                mode="normal"
                in="SourceGraphic"
                in2="effect1_backgroundBlur_0_5"
                result="shape"
              />
            </filter>
            <linearGradient
              id="gradient-vite-chip-highlight"
              x1="6.7543"
              y1="16.8858"
              x2="131.709"
              y2="135.086"
              gradientUnits="userSpaceOnUse"
            >
              <stop offset="0" stop-opacity="0" />
              <stop offset="0.4" stop-color="white" />
              <stop offset="1" stop-opacity="0" />
            </linearGradient>
            <radialGradient
              id="gradient-vite-chip-right-specular"
              cx="0"
              cy="0"
              r="1"
              gradientUnits="userSpaceOnUse"
              gradientTransform="translate(108.744 63.4905) rotate(110.653) scale(93.8362)"
            >
              <stop offset="0" stop-color="white" />
              <stop offset="1" stop-opacity="0" />
            </radialGradient>
            <radialGradient
              id="gradient-vite-chip-left-specular"
              cx="0"
              cy="0"
              r="1"
              gradientUnits="userSpaceOnUse"
              gradientTransform="translate(7.42974 141.165) rotate(-21.5713) scale(93.6927)"
            >
              <stop offset="0" stop-color="white" />
              <stop offset="1" stop-opacity="0" />
            </radialGradient>
            <linearGradient
              id="gradient-vite-chip-logo-v"
              x1="325.064"
              y1="42.3995"
              x2="323.283"
              y2="100.669"
              gradientUnits="userSpaceOnUse"
            >
              <stop offset="0" stop-color="#41D1FF" />
              <stop offset="1" stop-color="#BD34FE" />
            </linearGradient>
            <linearGradient
              id="gradient-vite-chip-logo-bolt"
              x1="365.666"
              y1="57.5919"
              x2="348.858"
              y2="104.372"
              gradientUnits="userSpaceOnUse"
            >
              <stop offset="0" stop-color="#FFEA83" />
              <stop offset="0.08" stop-color="#FFDD35" />
              <stop offset="1" stop-color="#FFA800" />
            </linearGradient>
          </defs>
        </svg>

        <!-- Blue Glow -->
        <div class="blue-glow" />

        <!-- Pink Glow -->
        <div class="pink-glow" />
      </div>
    </div>
    <div class="feature__meta">
      <div class="meta__title">Flexible plugin system</div>
      <div class="meta__description">
        Vite plugins extends Rollup's well-designed plugin interface with a few
        extra Vite-specific options.
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(-60px, 0, 0);
  }

  .feature__meta {
    max-width: 680px;
  }

  /* Extend height on smaller devices, to make room for text */
  @media (max-width: 330px) {
    height: 400px;
  }
}

.feature__visualization {
  .diagram {
    width: fit-content;
    position: absolute;
    left: 50%;
    transform-origin: center 40%;
    transform: translate3d(-50%, 0, 0) scale(0.5);
    margin-top: 0;

    @media (min-width: 480px) {
      transform-origin: center center;
      transform: translate3d(-50%, 0, 0) scale(0.7);
    }

    @media (min-width: 630px) {
      transform: translate3d(-50%, 0, 0) scale(1);
      margin-top: 20px;
    }

    @media (min-width: 768px) {
      transform: translate3d(-50%, 0, 0) scale(0.6);
      margin-top: 0;
    }

    @media (min-width: 1000px) {
      transform: translate3d(-50%, 0, 0) scale(0.8);
      margin-top: 20px;
    }

    @media (min-width: 1200px) {
      transform: translate3d(-50%, 0, 0) scale(1);
    }
  }

  .blue-chip__cube,
  .pink-chip__cube {
    transition:
      transform 0.5s ease-in-out,
      filter 0.05s ease 0.45s;
    will-change: filter, transform;

    @media (min-width: 768px) {
      transform: translate3d(0, -60px, 0);
    }
  }

  .blue-chip__cube {
    filter: grayscale(1) brightness(0.15)
      drop-shadow(0 0 0rem color-mix(in srgb, #40cffd 0%, transparent));
  }

  .pink-chip__cube {
    filter: grayscale(1) brightness(0.15)
      drop-shadow(0 0 0rem color-mix(in srgb, #bc33fc 0%, transparent));
  }

  .vite-chip__logo {
    transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.2);
    will-change: filter, transform;
    filter: grayscale(1) brightness(0.4)
      drop-shadow(0px 0px 1px rgba(0, 0, 0, 0.1));
    transform: translate3d(0, 0, 0);
  }

  .vite-chip__v {
    filter: drop-shadow(0 0 0rem color-mix(in srgb, #93bfff 0%, transparent));
    will-change: filter;
    transition-delay: 0.8s;
  }

  .blue-chip__connection {
    clip-path: polygon(0 0, 0 0, 0 100%, 0 100%);
    will-change: clip-path;
    filter: drop-shadow(
      0 0 0.2rem color-mix(in srgb, #40cffd 50%, transparent)
    );
    transition: all 0.6s ease-in-out;
  }

  .pink-chip__connection {
    clip-path: polygon(100% 0, 100% 0, 100% 100%, 100% 100%);
    will-change: clip-path;
    filter: drop-shadow(
      0 0 0.2rem color-mix(in srgb, #bc33fc 50%, transparent)
    );
    transition: all 0.6s ease-in-out;
  }

  .blue-glow {
    position: absolute;
    top: 50px;
    left: 55px;
    width: 100px;
    height: 100px;
    background: #41d1ff;
    filter: blur(80px);
    z-index: -1;
    opacity: 0;
    transition: opacity 0.5s ease-out;
    will-change: opacity;
  }

  .pink-glow {
    position: absolute;
    top: 50px;
    right: 55px;
    width: 100px;
    height: 100px;
    background: #bd34fe;
    filter: blur(80px);
    z-index: -1;
    opacity: 0;
    transition: opacity 0.5s ease-out;
    will-change: opacity;
  }

  &.active {
    .blue-chip__cube,
    .pink-chip__cube {
      transform: translate3d(0px, 0, 0);
    }

    .blue-chip__cube {
      filter: grayscale(0) brightness(1)
        drop-shadow(0 0 0.5rem color-mix(in srgb, #40cffd 100%, transparent));
    }

    .pink-chip__cube {
      filter: grayscale(0) brightness(1)
        drop-shadow(0 0 0.5rem color-mix(in srgb, #bc33fc 100%, transparent));
    }

    .blue-chip__connection {
      transition-delay: 0.3s;
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    }

    .pink-chip__connection {
      transition-delay: 0.3s;
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    }

    .vite-chip__logo {
      filter: grayscale(0) brightness(1)
        drop-shadow(0px 20px 4px rgba(0, 0, 0, 0.4));
      transform: translate3d(0, -20px, 0);
      transition-delay: 0.8s;
    }

    .vite-chip__v {
      filter: drop-shadow(
        0 0 0.3rem color-mix(in srgb, #93bfff 20%, transparent)
      );
    }

    .vite-chip__bolt {
      filter: drop-shadow(
        0 0 0.5rem color-mix(in srgb, yellow 20%, transparent)
      );
    }

    .blue-glow {
      opacity: 0.8;
    }

    .pink-glow {
      opacity: 0.8;
    }

    &:hover {
      .blue-glow {
        opacity: 1;
      }

      .pink-glow {
        opacity: 1;
      }
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureHMR.vue
================================================
<script setup>
import { ref } from 'vue'
import { gsap } from 'gsap'
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

// Animation state
const terminalActive = ref(false)
const connectionsActive = ref(false)
const browserActive = ref(false)

/**
 * Slide the card in when the page loads
 */
useSlideIn('#hmr-card')

/**
 * Start the animation when the card is hovered
 */
const { startAnimation } = useCardAnimation(
  '#hmr-card',
  () => {
    // Define the timeline
    const timeline = gsap.timeline()

    // Animate in the components, one at a time
    timeline.call(
      () => {
        terminalActive.value = true
      },
      null,
      0,
    )
    timeline.call(
      () => {
        connectionsActive.value = true
      },
      null,
      0.4,
    )
    timeline.call(
      () => {
        browserActive.value = true
      },
      null,
      1,
    )

    // All done
    return timeline
  },
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="hmr-card"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization">
      <!-- Terminal / IDE (left-side) -->
      <div class="terminal" :class="{ active: terminalActive }">
        <svg
          class="terminal__line-numbers"
          width="8"
          height="125"
          viewBox="0 0 8 121"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M5.06038 0.274872V10.2565H3.80614V1.63363L1.44697 3.06705L0.901974 2.17117L3.96292 0.274872H5.06038ZM7.21051 9.53237V10.5552H1.27526V9.53237H7.21051ZM3.50751 22.1106C4.15454 22.1106 4.70701 22.2351 5.1649 22.4839C5.62778 22.7328 5.98364 23.0737 6.2325 23.5067C6.48136 23.9397 6.60579 24.43 6.60579 24.9775C6.60579 25.4503 6.52367 25.9132 6.35942 26.3661C6.19517 26.814 5.93138 27.2869 5.56805 27.7846C5.2097 28.2773 4.73687 28.8248 4.14956 29.427C3.56724 30.0293 2.85053 30.7161 1.99944 31.4876H6.84469L6.68791 32.5552H0.573482V31.5324C1.34992 30.7908 2.00939 30.1413 2.5519 29.5838C3.09939 29.0264 3.54982 28.5386 3.9032 28.1205C4.26155 27.6975 4.54027 27.3142 4.73936 26.9708C4.94342 26.6274 5.08527 26.3014 5.1649 25.9928C5.24454 25.6792 5.28435 25.3557 5.28435 25.0223C5.28435 24.4449 5.12011 23.9895 4.79162 23.656C4.4681 23.3226 4.02016 23.1558 3.44779 23.1558C2.94012 23.1558 2.52452 23.2429 2.20101 23.4171C1.8775 23.5913 1.55398 23.87 1.23047 24.2533L0.364442 23.5814C0.772568 23.0837 1.22549 22.7154 1.7232 22.4764C2.22092 22.2326 2.81569 22.1106 3.50751 22.1106ZM3.49258 44.1106C4.13961 44.1106 4.69705 44.2276 5.1649 44.4615C5.63773 44.6905 6.00355 45.0015 6.26236 45.3947C6.52118 45.7829 6.65058 46.211 6.65058 46.6788C6.65058 47.0919 6.55851 47.4677 6.37435 47.8062C6.1902 48.1446 5.94632 48.4233 5.64271 48.6423C5.3391 48.8613 5.00563 49.0057 4.6423 49.0753C5.04545 49.1052 5.42371 49.2197 5.77709 49.4188C6.13047 49.6129 6.41914 49.8916 6.64312 50.2549C6.86709 50.6133 6.97907 51.0587 6.97907 51.5913C6.97907 52.1836 6.82976 52.7186 6.53113 53.1964C6.2325 53.6692 5.81442 54.0425 5.27689 54.3163C4.74433 54.59 4.12219 54.7269 3.41046 54.7269C2.83809 54.7269 2.26571 54.6174 1.69334 54.3984C1.12595 54.1794 0.645651 53.831 0.252456 53.3532L1.09608 52.6663C1.38973 53.0098 1.73814 53.2661 2.14128 53.4353C2.54941 53.6045 2.96251 53.6892 3.38059 53.6892C4.0973 53.6892 4.65723 53.5025 5.06038 53.1292C5.46353 52.751 5.66511 52.2383 5.66511 51.5913C5.66511 51.1035 5.57054 50.7178 5.38141 50.4341C5.19725 50.1504 4.94591 49.9488 4.62737 49.8294C4.30883 49.7049 3.9455 49.6427 3.53738 49.6427H2.67135L2.82813 48.6498H3.43285C3.76632 48.6498 4.07988 48.5876 4.37354 48.4631C4.67217 48.3337 4.91605 48.1347 5.10518 47.8659C5.29431 47.5971 5.38887 47.2612 5.38887 46.858C5.38887 46.2906 5.19974 45.8576 4.82148 45.559C4.44322 45.2603 3.98532 45.111 3.44779 45.111C2.99984 45.111 2.60914 45.1907 2.27567 45.3499C1.9422 45.5042 1.60624 45.7406 1.26779 46.0592L0.573482 45.2902C1.01147 44.8771 1.47683 44.5785 1.96957 44.3943C2.46231 44.2052 2.96998 44.1106 3.49258 44.1106ZM3.5747 66.1106L4.61991 66.5511L1.88745 73.0538H7.37476V74.0542H0.558551V73.1433L3.5747 66.1106ZM6.04586 70.1347V76.5552H4.83641L4.82895 73.2927L5.00066 70.1347H6.04586ZM6.7551 88.2749L6.56846 89.2753H2.50711V92.5154C2.82067 92.3462 3.11681 92.2317 3.39553 92.172C3.67922 92.1073 3.97536 92.0749 4.28395 92.0749C4.84139 92.0749 5.33164 92.2018 5.7547 92.4557C6.17775 92.7045 6.50625 93.0704 6.74017 93.5531C6.9741 94.0359 7.09106 94.6183 7.09106 95.3001C7.09106 95.982 6.94672 96.5817 6.65805 97.0994C6.37435 97.617 5.97369 98.0176 5.45607 98.3013C4.93844 98.585 4.32376 98.7269 3.61203 98.7269C2.99487 98.7269 2.4424 98.6174 1.95464 98.3984C1.47186 98.1794 1.03138 97.8758 0.633208 97.4876L1.40964 96.741C1.7232 97.0595 2.05916 97.2984 2.41752 97.4577C2.78085 97.612 3.184 97.6892 3.62696 97.6892C4.30386 97.6892 4.83143 97.4851 5.2097 97.077C5.58796 96.6639 5.77709 96.0591 5.77709 95.2628C5.77709 94.7103 5.69497 94.2748 5.53072 93.9563C5.36648 93.6378 5.14251 93.4113 4.85881 93.2769C4.58009 93.1375 4.26902 93.0679 3.92559 93.0679C3.62199 93.0679 3.35322 93.0977 3.11929 93.1575C2.88537 93.2122 2.61909 93.2968 2.32046 93.4113H1.31259V88.2749H6.7551ZM4.49299 110.111C4.89116 110.111 5.25698 110.163 5.59045 110.267C5.92392 110.367 6.23499 110.514 6.52366 110.708L6.03093 111.559C5.797 111.415 5.54814 111.308 5.28435 111.238C5.02554 111.163 4.75429 111.126 4.47059 111.126C3.9231 111.126 3.45774 111.31 3.0745 111.678C2.69126 112.042 2.40258 112.557 2.20848 113.224C2.01437 113.886 1.9198 114.665 1.92478 115.561L1.93971 116.046C1.93971 117.31 2.10644 118.238 2.43991 118.831C2.77338 119.418 3.31838 119.712 4.07491 119.712C4.72691 119.712 5.21467 119.48 5.53819 119.017C5.86668 118.554 6.03093 117.925 6.03093 117.128C6.03093 116.566 5.95378 116.123 5.79949 115.8C5.65018 115.471 5.43865 115.237 5.1649 115.098C4.89116 114.958 4.57262 114.889 4.20929 114.889C3.67674 114.889 3.20639 115.048 2.79827 115.366C2.39014 115.685 2.05916 116.093 1.80533 116.591L1.77546 115.486C2.11391 114.909 2.49964 114.493 2.93265 114.239C3.36566 113.985 3.85591 113.858 4.4034 113.858C4.93595 113.858 5.42123 113.975 5.85922 114.209C6.2972 114.443 6.64809 114.802 6.91188 115.284C7.18065 115.762 7.31503 116.367 7.31503 117.099C7.31503 117.855 7.17069 118.505 6.88202 119.047C6.59335 119.585 6.20264 120 5.7099 120.294C5.21716 120.583 4.67465 120.727 4.08237 120.727C3.45525 120.727 2.92519 120.61 2.49217 120.376C2.05916 120.137 1.70827 119.799 1.43951 119.361C1.17074 118.918 0.974143 118.388 0.849714 117.77C0.730262 117.148 0.670537 116.456 0.670537 115.695C0.670537 114.56 0.819851 113.575 1.11848 112.739C1.42209 111.902 1.85759 111.255 2.42498 110.797C2.99735 110.34 3.68669 110.111 4.49299 110.111Z"
            fill="#808080"
          />
        </svg>
        <svg
          class="terminal__skeleton-lines"
          width="198"
          height="106"
          viewBox="0 0 198 106"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M0.920898 2.53252C0.920898 1.15812 2.03507 0.0439453 3.40947 0.0439453H102.952C104.327 0.0439453 105.441 1.15812 105.441 2.53252V12.4868C105.441 13.8612 104.327 14.9754 102.952 14.9754H3.40948C2.03507 14.9754 0.920898 13.8612 0.920898 12.4868V2.53252Z"
          />
          <path
            d="M0.920898 24.9297C0.920898 23.5553 2.03507 22.4411 3.40947 22.4411H140.281C141.656 22.4411 142.77 23.5553 142.77 24.9297V34.884C142.77 36.2584 141.656 37.3726 140.281 37.3726H3.40948C2.03508 37.3726 0.920898 36.2584 0.920898 34.884V24.9297Z"
          />
          <path
            d="M0.920898 47.3268C0.920898 45.9524 2.03507 44.8383 3.40947 44.8383H32.0281C33.4025 44.8383 34.5167 45.9524 34.5167 47.3268V57.2811C34.5167 58.6555 33.4025 59.7697 32.0281 59.7697H3.40948C2.03507 59.7697 0.920898 58.6555 0.920898 57.2811V47.3268Z"
          />
          <path
            d="M0.920898 69.724C0.920898 68.3496 2.03507 67.2354 3.40947 67.2354H195.03C196.404 67.2354 197.518 68.3496 197.518 69.724V79.6783C197.518 81.0527 196.404 82.1669 195.03 82.1669H3.40948C2.03507 82.1669 0.920898 81.0527 0.920898 79.6783V69.724Z"
          />
          <path
            d="M0.920898 92.9102C0.920898 91.5358 2.03507 90.4217 3.40947 90.4217H89.2653C90.6397 90.4217 91.7539 91.5358 91.7539 92.9102V102.865C91.7539 104.239 90.6397 105.353 89.2653 105.353H3.40947C2.03507 105.353 0.920898 104.239 0.920898 102.865V92.9102Z"
          />
        </svg>
      </div>

      <!-- Browser (right-side) -->
      <svg
        class="browser"
        :class="{ active: browserActive }"
        width="350"
        height="223"
        viewBox="0 0 348 223"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g class="browser__background" filter="url(#shadow)">
          <rect
            x="17"
            y="-33"
            width="442"
            height="237"
            rx="18"
            fill="#242424"
            fill-opacity="1"
          />
        </g>
        <path
          d="M46.4409 148.062C46.4409 146.436 47.759 145.118 49.385 145.118H156.845C158.471 145.118 159.789 146.436 159.789 148.062V198.112C159.789 199.738 158.471 201.056 156.845 201.056H49.385C47.759 201.056 46.4409 199.738 46.4409 198.112V148.062Z"
          fill="url(#browser-bottom-left-square)"
        />
        <path
          d="M181.869 148.062C181.869 146.436 183.188 145.118 184.814 145.118H292.273C293.899 145.118 295.217 146.436 295.217 148.062V198.112C295.217 199.738 293.899 201.056 292.273 201.056H184.814C183.188 201.056 181.869 199.738 181.869 198.112V148.062Z"
          fill="url(#browser-bottom-middle-square)"
        />
        <path
          d="M317.298 148.062C317.298 146.436 318.616 145.118 320.242 145.118H427.702C429.328 145.118 430.646 146.436 430.646 148.062V198.112C430.646 199.738 429.328 201.056 427.702 201.056H320.242C318.616 201.056 317.298 199.738 317.298 198.112V148.062Z"
          fill="url(#browser-bottom-right-square)"
        />
        <path
          class="browser__major-edge"
          d="M46.4409 -7.97533C46.4409 -9.60131 47.759 -10.9194 49.385 -10.9194H427.702C429.328 -10.9194 430.646 -9.60132 430.646 -7.97533V74.4594C430.646 76.0854 429.328 77.4035 427.702 77.4035H49.385C47.759 77.4035 46.4409 76.0854 46.4409 74.4594V-7.97533Z"
          fill="#575757"
        />
        <path
          class="browser__heading-edge"
          d="M134.764 95.0681C134.764 93.4422 136.082 92.124 137.708 92.124H339.379C341.005 92.124 342.323 93.4422 342.323 95.0681V100.956C342.323 102.582 341.005 103.9 339.379 103.9H137.708C136.082 103.9 134.764 102.582 134.764 100.956V95.0681Z"
          fill="#575757"
        />
        <path
          class="browser__tagline-edge"
          d="M214.255 114.205C214.255 112.579 215.573 111.261 217.199 111.261H256.944C258.57 111.261 259.888 112.579 259.888 114.205V120.093C259.888 121.719 258.57 123.037 256.944 123.037H217.199C215.573 123.037 214.255 121.719 214.255 120.093V114.205Z"
          fill="#575757"
        />
        <g filter="url(#browser-glow-filter)">
          <path
            class="browser__major-glow"
            d="M46.4409 -7.97533C46.4409 -9.60131 47.759 -10.9194 49.385 -10.9194H427.702C429.328 -10.9194 430.646 -9.60132 430.646 -7.97533V74.4594C430.646 76.0854 429.328 77.4035 427.702 77.4035H49.385C47.759 77.4035 46.4409 76.0854 46.4409 74.4594V-7.97533Z"
            fill="#575757"
          />
          <path
            class="browser__heading-glow"
            d="M134.764 95.0681C134.764 93.4422 136.082 92.124 137.708 92.124H339.379C341.005 92.124 342.323 93.4422 342.323 95.0681V100.956C342.323 102.582 341.005 103.9 339.379 103.9H137.708C136.082 103.9 134.764 102.582 134.764 100.956V95.0681Z"
            fill="#575757"
          />
          <path
            class="browser__tagline-glow"
            d="M214.255 114.205C214.255 112.579 215.573 111.261 217.199 111.261H256.944C258.57 111.261 259.888 112.579 259.888 114.205V120.093C259.888 121.719 258.57 123.037 256.944 123.037H217.199C215.573 123.037 214.255 121.719 214.255 120.093V114.205Z"
            fill="#575757"
          />
        </g>
        <defs>
          <filter id="shadow" x="-20%" y="0" width="140%" height="160%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="10" result="blur" />
            <feOffset in="blur" dx="5" dy="5" result="offsetBlur" />
            <feComponentTransfer result="shadowOpacity">
              <feFuncA type="linear" slope="0.6" />
              <!-- Adjust the slope value to control opacity -->
            </feComponentTransfer>
            <feMerge>
              <feMergeNode in="shadowOpacity" />
              <!-- Use the result of feComponentTransfer -->
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
          <filter
            id="browser-glow-filter"
            x="24"
            y="-33"
            width="428"
            height="178"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur stdDeviation="8" result="glow-effect" />
          </filter>
          <linearGradient
            id="browser-bottom-left-square"
            x1="238.543"
            y1="145.118"
            x2="238.543"
            y2="201.056"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="#404040" />
            <stop offset="1" stop-color="#404040" stop-opacity="0" />
          </linearGradient>
          <linearGradient
            id="browser-bottom-middle-square"
            x1="238.543"
            y1="145.118"
            x2="238.543"
            y2="201.056"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="#404040" />
            <stop offset="1" stop-color="#404040" stop-opacity="0" />
          </linearGradient>
          <linearGradient
            id="browser-bottom-right-square"
            x1="238.543"
            y1="145.118"
            x2="238.543"
            y2="201.056"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="#404040" />
            <stop offset="1" stop-color="#404040" stop-opacity="0" />
          </linearGradient>
        </defs>
      </svg>

      <!-- Blue glow effect -->
      <div class="corner-glow" />

      <!-- Lines connecting the two sides  -->
      <div class="connecting-lines" :class="{ active: connectionsActive }">
        <div class="connecting-lines__line" />
        <div class="connecting-lines__line" />
        <div class="connecting-lines__line" />
      </div>
    </div>
    <div class="feature__meta meta--center">
      <div class="meta__title">Lightning fast HMR</div>
      <div class="meta__description">
        Hot Module Replacement (HMR) that stays fast regardless of app size.
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(60px, 0, 0);
  }

  &:hover {
    .corner-glow {
      opacity: 1;
    }
  }

  /* Extend height on smaller devices, to make room for text */
  @media (max-width: 400px) {
    height: 380px;
  }
}

.feature__visualization {
  --left-offset: calc(100% / 2);

  @media (min-width: 480px) {
    --left-offset: 140px;
  }

  @media (min-width: 900px) {
    --left-offset: 100px;
  }

  @media (min-width: 1100px) {
    --left-offset: 0px;
  }

  .terminal {
    position: absolute;
    top: 33px;
    left: calc(32px - var(--left-offset));
    width: 280px;
    height: 160px;
    border-radius: 12px;
    background: #1e1e1e;
    overflow: hidden;
    border: 1px solid transparent;

    .terminal__line-numbers {
      position: absolute;
      top: 16px;
      left: 22px;
    }

    .terminal__skeleton-lines {
      position: absolute;
      top: 14px;
      left: 45px;

      path {
        transition: all 0.3s ease;
        fill: #525252;
        opacity: 0.2;
      }
    }

    &.active {
      .terminal__skeleton-lines {
        path {
          opacity: 1;
          fill: #41d1ff;

          &:nth-child(2) {
            transition-delay: 0.1s;
            fill: #41d1ff;
          }

          &:nth-child(3) {
            transition-delay: 0.2s;
          }

          &:nth-child(4) {
            transition-delay: 0.3s;
          }

          &:nth-child(5) {
            transition-delay: 0.4s;
            fill: #c063ed;
          }
        }
      }
    }
  }

  .browser {
    position: absolute;
    top: 0;
    left: calc(360px - var(--left-offset));
    z-index: 2;

    @media (min-width: 640px) and (max-width: 768px) {
      left: unset;
      right: 0;
    }

    @media (min-width: 1200px) {
      left: unset;
      right: 0;
    }

    * {
      transition: all 0.5s ease;
    }

    /* Background */

    .browser__background {
      stroke: #2b2b2b;
      stroke-width: 3px;
    }

    /* Major "Screen" of Browser */

    .browser__major-glow,
    .browser__major-edge {
      fill: #41d1ff;
      filter: grayscale(1) brightness(40%);
    }

    .browser__major-glow {
      opacity: 0;
    }

    /* Heading */

    .browser__heading-glow,
    .browser__heading-edge {
      fill: #41d1ff;
      filter: grayscale(1) brightness(40%);
    }

    .browser__heading-glow {
      opacity: 0;
    }

    /* Tagline */

    .browser__tagline-glow,
    .browser__tagline-edge {
      fill: #c063ed;
      filter: grayscale(1) brightness(60%);
    }

    .browser__tagline-glow {
      opacity: 0;
    }

    &.active {
      /* Major "Screen" of Browser */

      .browser__major-glow,
      .browser__major-edge {
        filter: grayscale(0) brightness(100%);
      }

      .browser__major-glow {
        opacity: 1;
      }

      /* Heading */

      .browser__heading-glow,
      .browser__heading-edge {
        filter: grayscale(0) brightness(100%);
        transition-delay: 0.2s;
      }

      .browser__heading-glow {
        opacity: 1;
      }

      /* Tagline */

      .browser__tagline-glow,
      .browser__tagline-edge {
        filter: grayscale(0) brightness(100%);
        transition-delay: 0.3s;
      }

      .browser__tagline-glow {
        opacity: 1;
      }
    }
  }

  .corner-glow {
    position: absolute;
    top: 0;
    right: 0;
    width: 300px;
    height: 140px;
    background: #41d1ff;
    filter: blur(140px);
    z-index: -1;
    transform: translate3d(20px, 0, 0);
    opacity: 0.5;
    transition: opacity 1s ease-out;
    will-change: opacity;
  }

  .connecting-lines {
    &.active {
      .connecting-lines__line {
        transform: translate3d(0, 0, 0) scaleX(1);
      }
    }
  }

  .connecting-lines__line {
    height: 2px;
    border-radius: 1px;
    background: linear-gradient(to left, #41d1ff, #41d1ff00);
    position: absolute;
    width: calc(var(--base-width) - 35px);
    transform-origin: left center;
    transition: all 0.6s ease;
    transform: translate3d(0, 0, 0) scaleX(0);

    @media (min-width: 640px) and (max-width: 768px) {
      width: calc(
        (var(--base-width) - var(--left-offset)) + (100% - 350px) - 115px
      );
    }

    @media (min-width: 1200px) {
      width: var(--base-width);
    }

    &:nth-child(1) {
      --base-width: 225px;
      top: 54px;
      left: calc(185px - var(--left-offset));
    }

    &:nth-child(2) {
      --base-width: 190px;
      background: linear-gradient(to right, transparent, #7e5dee);
      top: 76px;
      left: calc(220px - var(--left-offset));
      transition-delay: 0.3s;
    }

    &:nth-child(3) {
      --base-width: 240px;
      background: linear-gradient(to right, #bd34fe00, #c063ed);
      top: 145px;
      left: calc(170px - var(--left-offset));
      transition-delay: 0.4s;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureInstantServerStart.vue
================================================
<script setup lang="ts">
import { onMounted, onUnmounted, ref } from 'vue'
import { gsap } from 'gsap'
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

// Animation state
const commandTriggered = ref(false)
const highlightEnter = ref(true)

/**
 * Slide the card in when the page loads
 */
useSlideIn('#instant-server-start-card')

/**
 * Start the animation when the card is hovered
 */
const { startAnimation } = useCardAnimation(
  '#instant-server-start-card',
  () => {
    const timeline = gsap.timeline()

    // Execute the `npm run dev` command
    timeline.call(() => {
      commandTriggered.value = true
      highlightEnter.value = false
    })
    return timeline
  },
  {
    once: true,
  },
)

/**
 * Run the command animation on enter press
 */
function handleEnterPress(event: KeyboardEvent) {
  if (event.key === 'Enter') {
    startAnimation()
    window.removeEventListener('keydown', handleEnterPress)
  }
}

/**
 * Listen for enter key presses
 */
onMounted(() => {
  window.addEventListener('keydown', handleEnterPress)
})

/**
 * Clean up when unmounting the component.
 */
onUnmounted(() => {
  window.removeEventListener('keydown', handleEnterPress)
})
</script>

<template>
  <div
    id="instant-server-start-card"
    class="feature-card"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization">
      <div class="terminal" :class="{ 'terminal--active': commandTriggered }">
        <div class="terminal__skeleton-line" />
        <div class="terminal__skeleton-line" />
        <Transition name="command-transition">
          <svg
            class="terminal__command"
            width="110"
            height="15"
            viewBox="0 0 110 15"
            v-show="!commandTriggered"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M0.253655 10.368L5.48951 7.40346V7.28547L0.253655 4.32095V3.06729L6.59567 6.73976V7.91967L0.253655 11.5921V10.368ZM17.5426 11.8281V4.2177H18.7225V5.45661H18.7815C18.8601 5.26979 18.9585 5.0928 19.0765 4.92565C19.1944 4.74866 19.337 4.59626 19.5042 4.46843C19.6812 4.34061 19.8876 4.23737 20.1236 4.15871C20.3596 4.08005 20.6349 4.04072 20.9496 4.04072C21.746 4.04072 22.3851 4.29636 22.8669 4.80766C23.3487 5.30912 23.5896 6.02198 23.5896 6.94625V11.8281H22.4097V7.15273C22.4097 6.45462 22.2573 5.93841 21.9525 5.6041C21.6477 5.25996 21.2003 5.08789 20.6103 5.08789C20.3744 5.08789 20.1433 5.11738 19.9171 5.17638C19.691 5.23538 19.4894 5.32387 19.3124 5.44186C19.1354 5.55985 18.9929 5.71226 18.8847 5.89908C18.7766 6.08589 18.7225 6.30221 18.7225 6.54803V11.8281H17.5426ZM26.0469 4.2177H27.2268V5.45661H27.2858C27.7774 4.51268 28.5591 4.04072 29.6309 4.04072C30.565 4.04072 31.2926 4.38977 31.8137 5.08789C32.3447 5.786 32.6102 6.76434 32.6102 8.02291C32.6102 9.28148 32.3447 10.2598 31.8137 10.9579C31.2926 11.6561 30.565 12.0051 29.6309 12.0051C28.5591 12.0051 27.7774 11.5331 27.2858 10.5892H27.2268V14.7779H26.0469V4.2177ZM29.1737 10.9579C29.862 10.9579 30.3929 10.7515 30.7666 10.3385C31.15 9.91569 31.3418 9.36015 31.3418 8.67186V7.37396C31.3418 6.68568 31.15 6.13506 30.7666 5.72209C30.3929 5.29929 29.862 5.08789 29.1737 5.08789C28.9082 5.08789 28.6575 5.1223 28.4215 5.19113C28.1855 5.25996 27.979 5.3632 27.802 5.50086C27.625 5.62868 27.4825 5.79092 27.3743 5.98757C27.276 6.17439 27.2268 6.39562 27.2268 6.65127V9.39456C27.2268 9.65021 27.276 9.87636 27.3743 10.073C27.4825 10.2598 27.625 10.4221 27.802 10.5597C27.979 10.6875 28.1855 10.7859 28.4215 10.8547C28.6575 10.9235 28.9082 10.9579 29.1737 10.9579ZM33.9908 11.8281V4.2177H35.0822V5.10264H35.1412C35.2592 4.80766 35.4264 4.55693 35.6427 4.35044C35.859 4.14396 36.1785 4.04072 36.6013 4.04072C37.0438 4.04072 37.3732 4.15379 37.5895 4.37994C37.8058 4.59626 37.9386 4.8814 37.9877 5.23538H38.032C38.1696 4.89124 38.3663 4.60609 38.6219 4.37994C38.8776 4.15379 39.2316 4.04072 39.6839 4.04072C40.3033 4.04072 40.7163 4.25703 40.9228 4.68967C41.1391 5.1223 41.2472 5.74175 41.2472 6.54803V11.8281H40.1558V6.73976C40.1558 6.09081 40.087 5.64343 39.9493 5.39761C39.8215 5.14197 39.5806 5.01414 39.2266 5.01414C38.912 5.01414 38.6564 5.11738 38.4597 5.32387C38.2631 5.52052 38.1647 5.82533 38.1647 6.2383V11.8281H37.0733V6.73976C37.0733 6.09081 37.0045 5.64343 36.8668 5.39761C36.739 5.14197 36.503 5.01414 36.1589 5.01414C35.8442 5.01414 35.5837 5.11738 35.3772 5.32387C35.1805 5.52052 35.0822 5.82533 35.0822 6.2383V11.8281H33.9908ZM51.4272 10.8252H53.6543V5.22063H51.4272V4.2177H54.8342V6.13506H54.9079C55.0653 5.53527 55.3602 5.06822 55.7929 4.73391C56.2353 4.38977 56.7958 4.2177 57.4742 4.2177H58.5362V5.39761H57.1055C56.4271 5.39761 55.8764 5.59426 55.4536 5.98757C55.0407 6.38087 54.8342 6.89708 54.8342 7.5362V10.8252H57.784V11.8281H51.4272V10.8252ZM65.0641 10.5892H65.0052C64.9265 10.776 64.8282 10.9579 64.7102 11.1349C64.5922 11.3021 64.4447 11.4496 64.2677 11.5774C64.1006 11.7052 63.899 11.8085 63.663 11.8871C63.427 11.9658 63.1517 12.0051 62.8371 12.0051C62.0406 12.0051 61.4015 11.7544 60.9197 11.2529C60.4379 10.7416 60.197 10.0238 60.197 9.09958V4.2177H61.3769V8.8931C61.3769 9.59121 61.5293 10.1123 61.8341 10.4565C62.139 10.7908 62.5863 10.9579 63.1763 10.9579C63.4123 10.9579 63.6433 10.9284 63.8695 10.8694C64.0956 10.8105 64.2972 10.722 64.4742 10.604C64.6512 10.486 64.7937 10.3385 64.9019 10.1615C65.0101 9.97468 65.0641 9.75345 65.0641 9.4978V4.2177H66.2441V11.8281H65.0641V10.5892ZM68.8341 11.8281V4.2177H70.014V5.45661H70.073C70.1517 5.26979 70.25 5.0928 70.368 4.92565C70.486 4.74866 70.6285 4.59626 70.7957 4.46843C70.9727 4.34061 71.1792 4.23737 71.4152 4.15871C71.6511 4.08005 71.9264 4.04072 72.2411 4.04072C73.0375 4.04072 73.6766 4.29636 74.1584 4.80766C74.6402 5.30912 74.8811 6.02198 74.8811 6.94625V11.8281H73.7012V7.15273C73.7012 6.45462 73.5488 5.93841 73.244 5.6041C72.9392 5.25996 72.4918 5.08789 71.9019 5.08789C71.6659 5.08789 71.4348 5.11738 71.2087 5.17638C70.9825 5.23538 70.781 5.32387 70.604 5.44186C70.427 5.55985 70.2844 5.71226 70.1762 5.89908C70.0681 6.08589 70.014 6.30221 70.014 6.54803V11.8281H68.8341ZM90.7542 10.5892H90.6952C90.2035 11.5331 89.4218 12.0051 88.3501 12.0051C87.416 12.0051 86.6835 11.6561 86.1525 10.9579C85.6314 10.2598 85.3708 9.28148 85.3708 8.02291C85.3708 6.76434 85.6314 5.786 86.1525 5.08789C86.6835 4.38977 87.416 4.04072 88.3501 4.04072C89.4218 4.04072 90.2035 4.51268 90.6952 5.45661H90.7542V0.913954H91.9341V11.8281H90.7542V10.5892ZM88.8073 10.9579C89.0728 10.9579 89.3235 10.9235 89.5595 10.8547C89.7955 10.7859 90.002 10.6875 90.179 10.5597C90.3559 10.4221 90.4936 10.2598 90.5919 10.073C90.7001 9.87636 90.7542 9.65021 90.7542 9.39456V6.65127C90.7542 6.39562 90.7001 6.17439 90.5919 5.98757C90.4936 5.79092 90.3559 5.62868 90.179 5.50086C90.002 5.3632 89.7955 5.25996 89.5595 5.19113C89.3235 5.1223 89.0728 5.08789 88.8073 5.08789C88.119 5.08789 87.5832 5.29929 87.1997 5.72209C86.826 6.13506 86.6392 6.68568 86.6392 7.37396V8.67186C86.6392 9.36015 86.826 9.91569 87.1997 10.3385C87.5832 10.7515 88.119 10.9579 88.8073 10.9579ZM97.5919 12.0051C97.0412 12.0051 96.5447 11.9117 96.1022 11.7249C95.6696 11.5381 95.296 11.2726 94.9813 10.9284C94.6765 10.5745 94.4405 10.1566 94.2734 9.67479C94.1062 9.18316 94.0226 8.63745 94.0226 8.03766C94.0226 7.42804 94.1062 6.87742 94.2734 6.38579C94.4504 5.89416 94.6913 5.47627 94.9961 5.13213C95.3009 4.77816 95.6647 4.50776 96.0875 4.32095C96.5201 4.13413 96.997 4.04072 97.5181 4.04072C98.0294 4.04072 98.4916 4.13413 98.9045 4.32095C99.3273 4.50776 99.6862 4.76833 99.9812 5.10264C100.276 5.42711 100.502 5.8155 100.66 6.2678C100.817 6.7201 100.896 7.21664 100.896 7.75743V8.31789H95.2616V8.67186C95.2616 9.00617 95.3156 9.3159 95.4238 9.60104C95.5319 9.88619 95.6844 10.132 95.881 10.3385C96.0875 10.545 96.3333 10.7072 96.6184 10.8252C96.9134 10.9334 97.2379 10.9874 97.5919 10.9874C98.1032 10.9874 98.5456 10.8694 98.9193 10.6335C99.2929 10.3975 99.5781 10.073 99.7747 9.66004L100.645 10.25C100.419 10.7613 100.04 11.1841 99.5092 11.5184C98.9881 11.8429 98.349 12.0051 97.5919 12.0051ZM97.5181 5.01414C97.1937 5.01414 96.8938 5.07314 96.6184 5.19113C96.3431 5.30912 96.1022 5.47136 95.8958 5.67784C95.6991 5.88433 95.5418 6.13014 95.4238 6.41529C95.3156 6.6906 95.2616 6.99541 95.2616 7.32972V7.43296H99.6272V7.27072C99.6272 6.93641 99.5731 6.6316 99.465 6.35629C99.3667 6.08098 99.2241 5.845 99.0373 5.64834C98.8603 5.44186 98.639 5.28454 98.3736 5.17638C98.1179 5.06822 97.8328 5.01414 97.5181 5.01414ZM105.256 11.8281L102.527 4.2177H103.722L104.813 7.40346L105.993 10.84H106.052L107.232 7.40346L108.323 4.2177H109.488L106.76 11.8281H105.256Z"
              fill="white"
            />
          </svg>
        </Transition>
        <Transition name="command-transition">
          <svg
            class="terminal__enter"
            width="28"
            height="28"
            viewBox="0 0 28 28"
            v-show="!commandTriggered"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <rect
              width="28"
              height="28"
              rx="4"
              fill="url(#paint0_linear_693_14840)"
            />
            <rect
              width="28"
              height="28"
              rx="4"
              fill="url(#paint1_linear_693_14840)"
            />
            <rect
              x="0.5"
              y="0.5"
              width="27"
              height="27"
              rx="3.92105"
              stroke="white"
              stroke-opacity="0.1"
            />
            <g filter="url(#filter0_f_693_14840)">
              <path
                d="M19.9999 8V14.75C19.9999 15.5456 19.6839 16.3087 19.1213 16.8713C18.5586 17.4339 17.7956 17.75 16.9999 17.75H10.1854L12.0604 19.625L10.9999 20.6855L7.31445 17L10.9999 13.3145L12.0604 14.375L10.1854 16.25H16.9999C17.3978 16.25 17.7793 16.092 18.0606 15.8106C18.3419 15.5293 18.4999 15.1478 18.4999 14.75V8H19.9999Z"
                fill="#FAFAFA"
              />
            </g>
            <path
              d="M19.9999 8V14.75C19.9999 15.5456 19.6839 16.3087 19.1213 16.8713C18.5586 17.4339 17.7956 17.75 16.9999 17.75H10.1854L12.0604 19.625L10.9999 20.6855L7.31445 17L10.9999 13.3145L12.0604 14.375L10.1854 16.25H16.9999C17.3978 16.25 17.7793 16.092 18.0606 15.8106C18.3419 15.5293 18.4999 15.1478 18.4999 14.75V8H19.9999Z"
              fill="#FAFAFA"
            />
            <defs>
              <filter
                id="filter0_f_693_14840"
                x="1.31445"
                y="2"
                width="24.6855"
                height="24.6855"
                filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB"
              >
                <feFlood flood-opacity="0" result="BackgroundImageFix" />
                <feBlend
                  mode="normal"
                  in="SourceGraphic"
                  in2="BackgroundImageFix"
                  result="shape"
                />
                <feGaussianBlur
                  stdDeviation="3"
                  result="effect1_foregroundBlur_693_14840"
                />
              </filter>
              <linearGradient
                id="paint0_linear_693_14840"
                x1="14"
                y1="0"
                x2="14"
                y2="28"
                gradientUnits="userSpaceOnUse"
              >
                <stop stop-color="#404040" />
                <stop offset="1" stop-color="#262626" />
              </linearGradient>
              <linearGradient
                id="paint1_linear_693_14840"
                x1="14"
                y1="0"
                x2="14"
                y2="28"
                gradientUnits="userSpaceOnUse"
              >
                <stop offset="0" stop-color="#404040" />
                <stop offset="1" stop-color="#262626" />
              </linearGradient>
            </defs>
          </svg>
        </Transition>
        <div class="terminal__enter-pulse" v-show="highlightEnter" />
        <Transition name="ready-label-transition">
          <span class="terminal__ready-label" v-if="commandTriggered"
            >Ready in 96ms</span
          >
        </Transition>
        <div class="terminal__glow" />
      </div>
      <div class="connection-line" :class="{ active: commandTriggered }" />
    </div>
    <div class="feature__meta">
      <div class="meta__title">Instant server start</div>
      <div class="meta__description">
        On demand file serving over native ESM, no bundling required!
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  perspective: 100px;

  @media (min-width: 768px) {
    transform: translate3d(-60px, 0, 0);
  }

  /* Extend height on smaller devices, to make room for text */
  @media (max-width: 420px) {
    height: 400px;
  }

  /* Or for really small screen */
  @media (max-width: 340px) {
    height: 420px;
  }

  .feature__meta {
    max-width: calc(100% - 30px);
  }
}

.feature__visualization {
  .terminal {
    position: absolute;
    top: 33px;
    left: 32px;
    right: 0;
    height: 170px;
    border-radius: 12px 0 0 12px;
    background: #171717;
    overflow: hidden;
    transition: all 0.4s ease-in-out;
    border: 1px solid transparent;
    border-right: none;

    .command-transition-enter-active,
    .command-transition-leave-active,
    .ready-label-transition-enter-active,
    .ready-label-transition-leave-active {
      transition: all 0.4s ease;
    }

    .command-transition-enter-active {
      transition: all 1s ease;
      transition-delay: 0.5s;
    }

    .ready-label-transition-enter-active {
      transition-delay: 0.2s;
    }

    .ready-label-transition-leave-active {
      transition: all 0.6s ease;
    }

    .command-transition-enter-from,
    .command-transition-leave-to {
      opacity: 0;
    }

    .ready-label-transition-enter-from,
    .ready-label-transition-leave-to {
      transform: translate3d(0, -20px, 0);
      opacity: 0;
    }

    * {
      user-select: none;
    }

    .terminal__skeleton-line {
      height: 10px;
      border-radius: 20px;
      opacity: 0.6;
      background: #404040;
      position: absolute;
      left: 32px;

      &:nth-child(1) {
        top: 33px;
        width: 45%;
        max-width: 170px;
      }

      &:nth-child(2) {
        top: 64px;
        width: 60%;
        max-width: 230px;
      }
    }

    .terminal__command {
      position: absolute;
      left: 32px;
      top: 100px;
      margin-bottom: 0;
      border-right: 1px solid white;
      animation: cursor-blink 1s linear infinite;
    }

    .terminal__enter {
      position: absolute;
      top: 93px;
      left: 165px;
      border-radius: 2px;
    }

    .terminal__enter-pulse {
      width: 28px;
      height: 28px;
      position: absolute;
      top: 93px;
      left: 165px;
      border-radius: 5px;
      pointer-events: none;
      border: 1px solid white;
      opacity: 0;
      box-shadow: 0 0 5px 0 rgb(255, 255, 255);
      animation: enter-pulse 4s ease-out infinite;
    }

    .terminal__ready-label {
      font-family: Inter, sans-serif;
      font-size: 22px;
      font-style: normal;
      font-weight: 600;
      line-height: normal;
      letter-spacing: -0.4px;
      background: linear-gradient(
        to left,
        #13b351 0%,
        rgba(19, 179, 81, 0.7) 120%
      );
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      position: absolute;
      left: 32px;
      top: 110px;
      pointer-events: none;
    }

    .terminal__glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
      border-radius: 12px 0 0 12px;
      background:
        url('../common/noise.webp'),
        radial-gradient(
          ellipse 140% 80% at 96% bottom,
          #13b351 0%,
          transparent 50%
        );
      filter: blur(15px);
      opacity: 0;
      pointer-events: none;
      will-change: opacity, transform;
      transition: all 2s ease-in-out;

      @media (min-width: 768px) {
        transform: translate3d(60px, 0, 0);
      }
    }

    &.terminal--active {
      border: 1px solid #13b351;
      border-right: none;
      box-shadow: 0 0 11px 0 rgba(19, 179, 81, 0.3);
      transition-delay: 0.2s;

      .terminal__glow {
        transition: all 0.6s ease-in-out;
        transform: translate3d(0, 20px, 0);
        opacity: 1;
      }
    }
  }

  .connection-line {
    position: absolute;
    top: 203px;
    right: 40px;
    width: 1px;
    height: calc(100% - 170px - 33px);
    background: url('../common/noise.webp'), #13b351;
    box-shadow: 0 0 10px 0 #13b351;
    transition: all 0.5s ease-in;
    will-change: transform, opacity;
    opacity: 0.5;
    transform-origin: center bottom;
    transform: scaleY(0);
    visibility: hidden;

    &.active {
      transition: all 0.3s ease-out;
      visibility: visible;
      opacity: 1;
      transform: scaleY(1);
    }
  }
}

@keyframes enter-pulse {
  0% {
    transform: scale(1) translate3d(0, 0, 0);
    opacity: 0.5;
  }
  100% {
    transform: scale(1.6) translate3d(0, 0, 0);
    opacity: 0;
  }
}

@keyframes cursor-blink {
  0% {
    border-color: transparent;
  }
  49% {
    border-color: transparent;
  }
  50% {
    border-color: #ffffff;
  }
  100% {
    border-color: #ffffff;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureOptimizedBuild.vue
================================================
<script setup lang="ts">
import SvgNode from '../common/SvgNode.vue'
import { ref, type Ref } from 'vue'
import { gsap } from 'gsap'
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

// Animation state
const isBoltActive: Ref<boolean> = ref(false)
const nodes = Array.from({ length: 10 }, () => {
  return {
    position: ref(0),
    visible: ref(false),
  }
})

/**
 * Slide the card in when the page loads
 */
useSlideIn('#optimized-build-card')

/**
 * Start the animation when the card is hovered
 */
const { startAnimation } = useCardAnimation(
  '#optimized-build-card',
  () => {
    // Define the timeline
    const timeline = gsap.timeline()

    // Animate in each node
    nodes.forEach((node) => {
      let subTimeline = gsap.timeline()
      subTimeline.call(() => {
        node.visible.value = true
      })
      subTimeline.to(node.position, {
        value: 1,
        duration: 0.8,
        ease: 'power3.out',
      })
      subTimeline.call(
        () => {
          node.visible.value = false
        },
        undefined,
        '-=0.6',
      )
      timeline.add(subTimeline, Math.random())
    })

    // Animate in the bolt
    timeline.call(
      () => {
        isBoltActive.value = true
      },
      undefined,
      '-=0.5',
    )

    // All done
    return timeline
  },
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="optimized-build-card"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization">
      <!-- Left-side lines/nodes -->
      <svg
        class="left-lines"
        width="195"
        height="138"
        viewBox="0 0 195 138"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M195 31.5L89.8055 30.377C76.1575 30.377 62.535 29.076 49.0906 26.4886L-21 13"
          stroke="url(#ob-linear-gradient-left)"
        />

        <SvgNode
          path="M195 31.5L89.8055 30.377C76.1575 30.377 62.535 29.076 49.0906 26.4886L-21 13"
          :position="nodes[0].position.value"
          :visible="nodes[0].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M195 50L69.295 47.754L-21 41.016"
          stroke="url(#ob-linear-gradient-left)"
        />

        <SvgNode
          path="M195 50L69.295 47.754L-21 41.016"
          :position="nodes[1].position.value"
          :visible="nodes[1].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M195 68.5L-21 69.5642"
          stroke="url(#ob-linear-gradient-left)"
        />

        <SvgNode
          path="M195 68.5L-21 69.5642"
          :position="nodes[2].position.value"
          :visible="nodes[2].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M195 87L69.2951 89.2463L-21 96.1614"
          stroke="url(#ob-linear-gradient-left)"
        />

        <SvgNode
          path="M195 87L69.2951 89.2463L-21 96.1614"
          :position="nodes[3].position.value"
          :visible="nodes[3].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M195 105.5L89.8055 106.623C76.1575 106.623 62.535 107.924 49.0906 110.511L-21 124"
          stroke="url(#ob-linear-gradient-left)"
        />

        <SvgNode
          path="M195 105.5L89.8055 106.623C76.1575 106.623 62.535 107.924 49.0906 110.511L-21 124"
          :position="nodes[4].position.value"
          :visible="nodes[4].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <defs>
          <linearGradient
            id="ob-linear-gradient-left"
            x1="-453.247"
            y1="167.386"
            x2="196.189"
            y2="125.855"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="white" stop-opacity="0" />
            <stop offset="0.7" stop-color="white" stop-opacity="0.2" />
            <stop offset="1" stop-color="white" stop-opacity="0" />
          </linearGradient>
        </defs>
      </svg>

      <!-- Right-side lines/nodes -->
      <svg
        class="right-lines"
        width="203"
        height="113"
        viewBox="0 0 203 113"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M0 93.5L105.194 94.623C118.843 94.623 132.465 95.924 145.909 98.5114L216 112"
          stroke="url(#ob-linear-gradient-right)"
        />

        <SvgNode
          path="M0 93.5L105.194 94.623C118.843 94.623 132.465 95.924 145.909 98.5114L216 112"
          :position="nodes[5].position.value"
          :visible="nodes[5].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M0 75L125.705 77.246L216 83.984"
          stroke="url(#ob-linear-gradient-right)"
        />

        <SvgNode
          path="M0 75L125.705 77.246L216 83.984"
          :position="nodes[6].position.value"
          :visible="nodes[6].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M4.65162e-08 56.5L216 55.4358"
          stroke="url(#ob-linear-gradient-right)"
        />

        <SvgNode
          path="M4.65162e-08 56.5L216 55.4358"
          :position="nodes[7].position.value"
          :visible="nodes[7].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M4.00455e-07 38L125.705 35.7537L216 28.8386"
          stroke="url(#ob-linear-gradient-right)"
        />

        <SvgNode
          path="M4.00455e-07 38L125.705 35.7537L216 28.8386"
          :position="nodes[8].position.value"
          :visible="nodes[8].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <path
          d="M8.0866e-07 19.5L105.194 18.377C118.843 18.377 132.465 17.076 145.909 14.4887L216 1"
          stroke="url(#ob-linear-gradient-right)"
        />

        <SvgNode
          path="M8.0866e-07 19.5L105.194 18.377C118.843 18.377 132.465 17.076 145.909 14.4887L216 1"
          :position="nodes[9].position.value"
          :visible="nodes[9].visible.value"
          :dot-color="undefined"
          glow-color="#FFE358"
        />

        <defs>
          <linearGradient
            id="ob-linear-gradient-right"
            x1="648.247"
            y1="-42.3859"
            x2="-1.18927"
            y2="-0.855247"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="white" stop-opacity="0" />
            <stop offset="0.7" stop-color="white" stop-opacity="0.2" />
            <stop offset="1" stop-color="white" stop-opacity="0" />
          </linearGradient>
        </defs>
      </svg>

      <!-- Lightning Bolt -->
      <svg
        class="bolt"
        :class="{ active: isBoltActive }"
        width="180"
        height="263"
        viewBox="0 0 180 263"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g filter="url(#filter-bolt-glow)" class="bolt__glow">
          <path
            d="M111.597 57.0439L61.562 69.1637C60.7396 69.3629 60.1308 70.2245 60.0812 71.2584L57.0033 135.519C56.9309 137.032 58.0553 138.207 59.2503 137.866L73.1807 133.892C74.4841 133.521 75.6618 134.94 75.3939 136.56L71.2552 161.613C70.9767 163.3 72.2573 164.741 73.5893 164.241L82.1934 161.01C83.5273 160.509 84.8089 161.955 84.5267 163.643L77.9496 202.996C77.538 205.458 80.1867 206.8 81.2913 204.689L82.0291 203.28L122.8 102.695C123.483 101.011 122.306 99.0908 120.809 99.4478L106.47 102.869C105.123 103.19 103.976 101.639 104.357 100.009L113.715 59.9023C114.096 58.2698 112.946 56.7172 111.597 57.0439Z"
            fill="url(#paint0_radial_693_18989)"
          />
        </g>
        <g filter="url(#filter-bolt-edge-glow)" class="bolt__glow">
          <path
            d="M111.597 57.0361L61.562 67.0126C60.7396 67.1765 60.1308 67.8857 60.0812 68.7368L57.0033 121.633C56.9309 122.879 58.0553 123.846 59.2503 123.565L73.1807 120.294C74.4841 119.988 75.6618 121.156 75.3939 122.49L71.2552 143.113C70.9767 144.501 72.2573 145.688 73.5893 145.276L82.1934 142.616C83.5273 142.204 84.8089 143.394 84.5267 144.783L77.9496 177.177C77.538 179.203 80.1867 180.308 81.2913 178.571L82.0291 177.41L122.8 94.6142C123.483 93.2278 122.306 91.6471 120.809 91.9409L106.47 94.757C105.123 95.0214 103.976 93.7444 104.357 92.4029L113.715 59.389C114.096 58.0452 112.946 56.7672 111.597 57.0361Z"
            stroke="url(#paint1_radial_693_18989)"
            stroke-width="3.34777"
          />
        </g>

        <mask
          id="bolt-mask"
          style="mask-type: alpha"
          maskUnits="userSpaceOnUse"
          x="56"
          y="56"
          width="68"
          height="124"
        >
          <path
            d="M111.597 57.0361L61.562 67.0126C60.7396 67.1765 60.1308 67.8857 60.0812 68.7368L57.0033 121.633C56.9309 122.879 58.0553 123.846 59.2503 123.565L73.1807 120.294C74.4841 119.988 75.6618 121.156 75.3939 122.49L71.2552 143.113C70.9767 144.501 72.2573 145.688 73.5893 145.276L82.1934 142.616C83.5273 142.204 84.8089 143.394 84.5267 144.783L77.9496 177.177C77.538 179.203 80.1867 180.308 81.2913 178.571L82.0291 177.41L122.8 94.6142C123.483 93.2278 122.306 91.6471 120.809 91.9409L106.47 94.757C105.123 95.0214 103.976 93.7444 104.357 92.4029L113.715 59.389C114.096 58.0452 112.946 56.7672 111.597 57.0361Z"
            fill="url(#linear-mask)"
          />
          <path
            d="M59.8424 68.7229L59.8424 68.7229L56.7646 121.619L57.0033 121.633L56.7646 121.619C56.6833 123.019 57.9486 124.116 59.305 123.798L73.2353 120.527C74.3622 120.262 75.3945 121.273 75.1595 122.443L75.3939 122.49L75.1595 122.443L71.0208 143.066C70.7081 144.624 72.147 145.972 73.6599 145.504L73.5893 145.276L73.6599 145.504L82.264 142.844C83.4168 142.488 84.54 143.516 84.2924 144.735L84.5267 144.783L84.2924 144.735L77.7152 177.129C77.255 179.395 80.235 180.678 81.4931 178.699L82.2309 177.539L82.2379 177.528L82.2436 177.516L123.015 94.7198C123.781 93.1646 122.463 91.3725 120.763 91.7063L106.424 94.5223C106.424 94.5223 106.424 94.5224 106.424 94.5224C105.259 94.7509 104.253 93.6453 104.587 92.4681L113.946 59.4542L113.946 59.4542C114.373 57.9459 113.082 56.4962 111.55 56.8016L111.597 57.0361L111.55 56.8016L61.5153 66.7781C60.5836 66.9638 59.8982 67.7658 59.8424 68.7229Z"
            stroke="white"
            stroke-opacity="0.3"
            stroke-width="0.478253"
          />
        </mask>
        <g mask="url(#bolt-mask)">
          <rect
            class="bolt__dark"
            x="41.2188"
            y="57"
            width="92.7811"
            height="136.78"
            fill="#1E1E1E"
          />
          <rect
            class="bolt__color"
            x="41.2188"
            y="57"
            width="92.7811"
            height="136.78"
            fill="url(#radial-bolt-color)"
          />
          <rect
            class="bolt__highlight"
            x="41.2188"
            y="57"
            width="92.7811"
            height="136.78"
            fill="white"
          />
          <path
            class="bolt__edge"
            d="M111.597 57.0361L61.562 67.0126C60.7396 67.1765 60.1308 67.8857 60.0812 68.7368L57.0033 121.633C56.9309 122.879 58.0553 123.846 59.2503 123.565L73.1807 120.294C74.4841 119.988 75.6618 121.156 75.3939 122.49L71.2552 143.113C70.9767 144.501 72.2573 145.688 73.5893 145.276L82.1934 142.616C83.5273 142.204 84.8089 143.394 84.5267 144.783L77.9496 177.177C77.538 179.203 80.1867 180.308 81.2913 178.571L82.0291 177.41L122.8 94.6142C123.483 93.2278 122.306 91.6471 120.809 91.9409L106.47 94.757C105.123 95.0214 103.976 93.7444 104.357 92.4029L113.715 59.389C114.096 58.0452 112.946 56.7672 111.597 57.0361Z"
            stroke="url(#radial-bolt-edge)"
            stroke-width="3"
          />
        </g>
        <defs>
          <filter
            id="filter-bolt-glow"
            x="0.0878601"
            y="0.0878601"
            width="179.823"
            height="262.561"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur
              stdDeviation="28.4561"
              result="effect1_foregroundBlur_693_18989"
            />
          </filter>
          <filter
            id="filter-bolt-edge-glow"
            x="48.6306"
            y="48.6283"
            width="82.7363"
            height="139.202"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur
              stdDeviation="3.34777"
              result="effect1_foregroundBlur_693_18989"
            />
          </filter>
          <radialGradient
            id="paint0_radial_693_18989"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(79.4533 63.5007) rotate(81.9567) scale(108.196 88.8357)"
          >
            <stop offset="0" stop-color="#FFEA83" />
            <stop offset="0.0833333" stop-color="#FFDD35" />
            <stop offset="1" stop-color="#FFA800" />
          </radialGradient>
          <radialGradient
            id="paint1_radial_693_18989"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(79.4533 62.3511) rotate(80.2589) scale(89.4759 88.4248)"
          >
            <stop offset="0" stop-color="#FFEA83" />
            <stop offset="0.0833333" stop-color="#FFDD35" />
            <stop offset="1" stop-color="#FFA800" />
          </radialGradient>
          <linearGradient
            id="linear-mask"
            x1="75.4703"
            y1="59.7447"
            x2="91.2207"
            y2="165.923"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="#FFEA83" />
            <stop offset="0.0833333" stop-color="#FFDD35" />
            <stop offset="1" stop-color="#FFA800" />
          </linearGradient>
          <radialGradient
            id="radial-bolt-color"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(72.7835 62.9782) rotate(77.8103) scale(100.793 123.282)"
          >
            <stop offset="0" stop-color="#FFEA83" />
            <stop offset="0.0833333" stop-color="#FFDD35" />
            <stop offset="1" stop-color="#FFA800" />
          </radialGradient>
          <radialGradient
            id="radial-bolt-edge"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(79.4533 62.3511) rotate(80.2589) scale(89.4759 88.4248)"
          >
            <stop offset="0" stop-color="#FFDD35" />
            <stop offset="1" stop-color="#FFA800" />
          </radialGradient>
        </defs>
      </svg>
    </div>
    <div class="feature__meta meta--center">
      <div class="meta__title">Optimized build</div>
      <div class="meta__description">
        Pre-configured Rollup build with multi-page and library mode support.
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  min-height: 370px;

  @media (min-width: 768px) {
    transform: translate3d(60px, 0, 0);
  }
}

.feature__visualization {
  .left-lines {
    position: absolute;
    top: 60px;
    left: unset;
    right: 50%;

    @media (min-width: 455px) {
      left: 0;
      right: unset;
    }

    @media (min-width: 768px) {
      left: unset;
      right: 50%;
    }

    @media (min-width: 900px) {
      left: 0;
      right: unset;
    }

    @media (min-width: 1200px) {
      left: unset;
      right: 50%;
    }
  }

  .right-lines {
    position: absolute;
    top: 71px;
    right: unset;
    left: 50%;

    @media (min-width: 455px) {
      right: 0;
      left: unset;
    }

    @media (min-width: 768px) {
      right: unset;
      left: 50%;
    }

    @media (min-width: 900px) {
      right: 0;
      left: unset;
    }

    @media (min-width: 1200px) {
      right: unset;
      left: 50%;
    }
  }

  .bolt {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translate3d(-50%, 0, 0);

    .bolt__glow {
      transition: opacity 0.3s ease;
      will-change: opacity;
      opacity: 0.6;
    }

    .bolt__color {
      opacity: 0.03;
    }

    .bolt__edge {
      opacity: 0.1;
    }

    .bolt__highlight {
      opacity: 0;
    }

    &.active {
      .bolt__color {
        animation: bolt-color-entrance 0.5s ease forwards;
      }

      .bolt__edge {
        animation: bolt-edge-entrance 0.5s ease forwards;
      }

      .bolt__glow {
        opacity: 0.7;
        transition: opacity 0.1s ease;
      }

      .bolt__highlight {
        opacity: 0.6;
        transition: opacity 0.1s ease;
        transition-delay: 0.5s;
      }
    }
  }
}

@keyframes bolt-edge-entrance {
  0% {
    opacity: 0;
  }
  2% {
    opacity: 0.6;
  }
  30% {
    opacity: 0.6;
  }
  31% {
    opacity: 0.01;
  }
  35% {
    opacity: 0.01;
  }
  36% {
    opacity: 0.8;
  }
  80% {
    opacity: 0.8;
  }
  80% {
    opacity: 0.3;
  }
  82% {
    opacity: 1;
  }
  100% {
    opacity: 1;
  }
}

@keyframes bolt-color-entrance {
  0% {
    opacity: 0.03;
  }
  2% {
    opacity: 0.4;
  }
  30% {
    opacity: 0.4;
  }
  31% {
    opacity: 0.01;
  }
  35% {
    opacity: 0.01;
  }
  36% {
    opacity: 0.45;
  }
  80% {
    opacity: 0.45;
  }
  80% {
    opacity: 0.3;
  }
  82% {
    opacity: 0.5;
  }
  100% {
    opacity: 0.9;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureRichFeatures.vue
================================================
<script setup lang="ts">
import logoJSON from './images/json.svg'
import logoCSS from './images/css3.svg'
import logoJS from './images/js.svg'
import logoTS from './images/ts.svg'
import logoWA from './images/wa.svg'
import logoPostCSS from './images/postcss.svg'
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

/**
 * Slide the card in when the page loads
 */
useSlideIn('#rich-features-card')

/**
 * Start the animation when the card is hovered
 */
const { isCardActive, startAnimation } = useCardAnimation(
  '#rich-features-card',
  undefined,
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="rich-features-card"
    :class="{ active: isCardActive }"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization">
      <div class="card-container">
        <svg
          class="background-cards"
          width="658"
          height="275"
          viewBox="0 0 658 275"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M105.376 201.33C105.376 193.847 111.442 187.781 118.925 187.781H176.507C183.99 187.781 190.056 193.847 190.056 201.33V258.912C190.056 266.395 183.99 272.461 176.507 272.461H118.925C111.442 272.461 105.376 266.395 105.376 258.912V201.33Z"
            class="background-card"
          />
          <path
            d="M525.389 96.3271C525.389 88.8443 531.455 82.7783 538.937 82.7783H596.518C604 82.7783 610.066 88.8443 610.066 96.3271V153.909C610.066 161.392 604 167.458 596.518 167.458H538.937C531.455 167.458 525.389 161.392 525.389 153.909V96.3271Z"
            class="background-card"
          />
          <path
            d="M210.38 -10.3692C210.38 -17.852 216.446 -23.9179 223.929 -23.9179H281.512C288.994 -23.9179 295.06 -17.852 295.06 -10.3692V47.2129C295.06 54.6957 288.994 60.7617 281.512 60.7617H223.929C216.446 60.7617 210.38 54.6957 210.38 47.2129V-10.3692Z"
            class="background-card"
          />
          <path
            d="M525.389 201.33C525.389 193.847 531.455 187.781 538.937 187.781H596.518C604 187.781 610.066 193.847 610.066 201.33V258.912C610.066 266.395 604 272.461 596.518 272.461H538.937C531.455 272.461 525.389 266.395 525.389 258.912V201.33Z"
            class="background-card"
          />
          <path
            d="M630.389 201.33C630.389 193.847 636.455 187.781 643.938 187.781H701.52C709.003 187.781 715.069 193.847 715.069 201.33V258.912C715.069 266.395 709.003 272.461 701.52 272.461H643.938C636.455 272.461 630.389 266.395 630.389 258.912V201.33Z"
            class="background-card"
          />
          <path
            d="M0.373901 201.33C0.373901 193.847 6.4399 187.781 13.9227 187.781H71.5045C78.9873 187.781 85.0531 193.847 85.0531 201.33V258.912C85.0531 266.395 78.9873 272.461 71.5045 272.461H13.9227C6.4399 272.461 0.373901 266.395 0.373901 258.912V201.33Z"
            class="background-card"
          />
          <path
            d="M630.389 96.3271C630.389 88.8443 636.455 82.7783 643.938 82.7783H701.52C709.003 82.7783 715.069 88.8443 715.069 96.3271V153.909C715.069 161.392 709.003 167.458 701.52 167.458H643.938C636.455 167.458 630.389 161.392 630.389 153.909V96.3271Z"
            class="background-card"
          />
          <path
            d="M0.373901 96.3271C0.373901 88.8443 6.4399 82.7783 13.9227 82.7783H71.5045C78.9873 82.7783 85.0531 88.8443 85.0531 96.327V153.909C85.0531 161.392 78.9873 167.458 71.5045 167.458H13.9227C6.4399 167.458 0.373901 161.392 0.373901 153.909V96.3271Z"
            class="background-card"
          />
          <path
            d="M630.389 -10.3692C630.389 -17.852 636.455 -23.918 643.938 -23.918H701.52C709.003 -23.918 715.069 -17.852 715.069 -10.3692V47.2129C715.069 54.6957 709.003 60.7616 701.52 60.7616H643.938C636.455 60.7616 630.389 54.6957 630.389 47.2129V-10.3692Z"
            class="background-card"
          />
          <path
            d="M0.373901 -10.3692C0.373901 -17.852 6.4399 -23.9179 13.9227 -23.9179H71.5045C78.9873 -23.9179 85.0531 -17.852 85.0531 -10.3692V47.2129C85.0531 54.6957 78.9873 60.7617 71.5045 60.7617H13.9227C6.4399 60.7617 0.373901 54.6957 0.373901 47.2129V-10.3692Z"
            class="background-card"
          />
          <path
            d="M525.389 -10.3692C525.389 -17.8519 531.455 -23.9179 538.937 -23.9179H596.518C604 -23.9179 610.066 -17.8519 610.066 -10.3692V47.213C610.066 54.6957 604 60.7617 596.518 60.7617H538.937C531.455 60.7617 525.389 54.6957 525.389 47.213V-10.3692Z"
            class="background-card"
          />
          <path
            d="M420.386 -10.3692C420.386 -17.852 426.452 -23.9179 433.935 -23.9179H491.517C499 -23.9179 505.066 -17.852 505.066 -10.3692V47.2129C505.066 54.6957 499 60.7617 491.517 60.7617H433.935C426.452 60.7617 420.386 54.6957 420.386 47.2129V-10.3692Z"
            class="background-card"
          />
          <path
            d="M315.383 -10.3692C315.383 -17.852 321.449 -23.9179 328.932 -23.9179H386.514C393.997 -23.9179 400.063 -17.852 400.063 -10.3692V47.2129C400.063 54.6957 393.997 60.7617 386.514 60.7617H328.932C321.449 60.7617 315.383 54.6957 315.383 47.2129V-10.3692Z"
            class="background-card"
          />
          <path
            d="M210.38 203.023C210.38 195.541 216.446 189.475 223.929 189.475H281.512C288.994 189.475 295.06 195.541 295.06 203.023V260.605C295.06 268.088 288.994 274.154 281.512 274.154H223.929C216.446 274.154 210.38 268.088 210.38 260.605V203.023Z"
            class="background-card"
          />
          <path
            d="M315.383 203.023C315.383 195.541 321.449 189.475 328.932 189.475H386.514C393.997 189.475 400.063 195.541 400.063 203.023V260.605C400.063 268.088 393.997 274.154 386.514 274.154H328.932C321.449 274.154 315.383 268.088 315.383 260.605V203.023Z"
            class="background-card"
          />
        </svg>
        <div class="card card--json">
          <img :src="logoJSON" alt="JSON" />
        </div>
        <div class="card card--css">
          <img :src="logoCSS" alt="CSS3" />
        </div>
        <div class="card card--js">
          <img :src="logoJS" alt="Javascript" />
        </div>
        <div class="card card--ts">
          <img :src="logoTS" alt="Typescript" />
        </div>
        <div class="card card--wa">
          <img :src="logoWA" alt="WebAssembly" />
        </div>
        <div class="card card--postcss">
          <img :src="logoPostCSS" alt="PostCSS" />
        </div>
      </div>
      <!-- Center glow effect -->
      <div class="center-glow" />
    </div>
    <div class="feature__meta meta--center">
      <div class="meta__title">Rich features</div>
      <div class="meta__description">
        Out-of-the-box support for TypeScript, JSX, CSS and more.
      </div>
    </div>
  </div>
</template>

<style scoped>
@property --opacity {
  syntax: '<number>';
  initial-value: 1;
  inherits: false;
}

.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(-60px, 0, 0);
  }

  &.active {
    .feature__visualization {
      .card {
        &:after {
          border-color: rgba(60, 60, 60, 0.8);
          --opacity: 0.8;
          box-shadow: var(--card-color) 0 10px 20px -10px;
        }
      }

      .center-glow {
        opacity: 1;
      }
    }
  }
}

.feature__visualization {
  display: flex;
  justify-content: center;
  align-content: flex-start;

  .card-container {
    flex-shrink: 0;
    mask-image: radial-gradient(
      ellipse 50% 45% at center 25%,
      rgba(0, 0, 0, 1) 50%,
      rgba(0, 0, 0, 0.7) 80%,
      rgba(0, 0, 0, 0) 100%
    );
    position: relative;
    background: #141414;

    .background-card {
      fill: #181818;
    }
  }

  .center-glow {
    position: absolute;
    top: 0;
    left: 50%;
    width: 300px;
    height: 140px;
    background: #ffffff;
    filter: blur(80px);
    z-index: 5;
    transform: translate3d(-50%, 0, 0);
    opacity: 0.5;
    transition: opacity 0.3s ease;
    will-change: opacity;
    mix-blend-mode: overlay;
  }

  .card {
    position: absolute;
    z-index: 1;
    display: flex;
    background: var(--card-color);
    width: 85px;
    aspect-ratio: 1;
    border-radius: 10px;
    align-items: center;
    justify-content: center;
    transform: translate3d(0, 0, 0);
    transition: all 0.3s ease;
    will-change: box-shadow;
    --card-color: #181818;

    * {
      position: relative;
      z-index: 2;
    }

    &:after {
      border: 1px solid rgba(60, 60, 60, 0.5);
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border-radius: 10px;
      --opacity: 0.99;
      background: linear-gradient(
        to bottom,
        #181818 30%,
        rgba(24 24 24 / var(--opacity)) 100%
      );
      will-change: background;
      box-shadow: var(--card-color) 0 5px 10px -30px;
      transition:
        --opacity 0.8s ease,
        box-shadow 0.5s ease;
      z-index: 1;
    }

    &.card--json {
      top: -23px;
      left: 105px;
    }

    &.card--css {
      top: 83px;
      left: 105px;
      --card-color: #2a53dd;
    }

    &.card--js {
      top: 83px;
      left: 210px;
      --card-color: #f7e425;
    }

    &.card--ts {
      top: 83px;
      left: 315px;
      --card-color: #3d95d2;
    }

    &.card--wa {
      top: 83px;
      left: 420px;
      --card-color: #7259f0;
    }

    &.card--postcss {
      top: 189px;
      left: 420px;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureSection.vue
================================================
<script setup lang="ts">
import SvgNode from '../common/SvgNode.vue'
import { onMounted, onUnmounted, type Ref, ref } from 'vue'
import { gsap } from 'gsap'

const props = defineProps({
  title: {
    type: String,
    default: null,
  },
  description: {
    type: String,
    default: null,
  },
  type: {
    type: String,
    default: 'blue',
  },
})

// Animation state
const animationPercentage: Ref<number> = ref(0)
const animationVisible: Ref<boolean> = ref(false)

// GSAP timeline for the icon above the section title
let timeline: gsap.core.Timeline | null

onMounted(() => {
  startAnimation()
})

onUnmounted(() => {
  if (timeline) {
    timeline.kill()
  }
})

/**
 * When the component scrolls into viewport, we start the animation.
 */
const startAnimation = () => {
  timeline = gsap
    .timeline({
      scrollTrigger: {
        trigger: `#feature_section_${props.type}`,
        start: 'top 80%',
        once: true,
      },
    })
    .call(
      () => {
        animationVisible.value = true
      },
      undefined,
      0,
    )
    .to(
      animationPercentage,
      {
        value: 0.55,
        duration: 2,
        ease: 'expo.out',
      },
      0,
    )
}
</script>

<template>
  <section class="feature-section" :id="`feature_section_${props.type}`">
    <!-- Section Title -->
    <div class="feature-section__title">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="70"
        height="61"
        viewBox="0 0 70 61"
        fill="none"
        style="overflow: visible"
      >
        <path
          d="M38.5 0.772461V60.5215M22.6301 60.7725V38.7905C22.6301 25.3784 17.3675 12.5156 8 3.03184M54.3699 60.7725V38.7905C54.3699 25.3784 59.6325 12.5156 69 3.03184"
          stroke="url(#linear-gradient-bg-lines)"
          stroke-width="2"
        />
        <SvgNode
          v-if="type === 'blue'"
          path="M22.6301 80.7725V38.7905C22.6301 25.3784 17.3675 12.5156 8 3.03184L-20 -20"
          :position="animationPercentage"
          :visible="animationVisible"
        />
        <SvgNode
          v-if="type === 'pink'"
          path="M54.3699 80.7725V38.7905C54.3699 25.3784 59.6325 12.5156 69 3.03184L90 -20"
          :position="animationPercentage"
          :visible="animationVisible"
          dot-color="#ce9bf4"
          glow-color="#BD34FE"
        />
        <defs>
          <linearGradient
            id="linear-gradient-bg-lines"
            x1="38.5"
            y1="0.772461"
            x2="38.5"
            y2="60.7725"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-color="#404040" stop-opacity="0" />
            <stop offset="0.5" stop-color="#737373" />
            <stop offset="1" stop-color="#404040" stop-opacity="0" />
          </linearGradient>
        </defs>
      </svg>
      <h2 :style="{ '--text-color': type === 'blue' ? '#41D1FF' : '#BD34FE' }">
        {{ title }}
      </h2>
      <h3 v-if="description">{{ description }}</h3>
    </div>

    <!-- Section Grid -->
    <div class="feature-section__grid">
      <!-- Feature Cards -->
      <slot></slot>
    </div>
  </section>
</template>

<style>
.feature-section {
  display: flex;
  flex-direction: column;
  margin: 0 auto;
  gap: 0;
  align-items: center;
  position: relative;
  z-index: 2;

  &:nth-of-type(1) {
    margin-top: -60px;

    @media (min-width: 768px) {
      margin-top: 0;
    }
  }

  &:nth-of-type(2) {
    margin-top: 160px;
  }

  svg {
    position: relative;
    margin-bottom: 15px;
    z-index: 2;
  }

  h2 {
    --text-color: #404040;
    background: radial-gradient(
      circle 300px at 30% -180%,
      var(--text-color) 0%,
      #ffffff 100%
    );
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow:
      0 0 4px rgba(255, 255, 255, 0.1),
      0 0 14px rgba(130, 168, 236, 0.2);
  }

  .feature-section__title {
    display: flex;
    flex-direction: column;
    margin: 0 auto;
    width: fit-content;
    align-items: center;
    gap: 10px;
    text-align: center;
  }

  .feature-section__grid {
    display: grid;
    grid: auto / repeat(1, 1fr);
    grid-gap: 30px;
    margin: 45px auto 0;
    width: 100%;
    padding: 0 32px;

    @media (min-width: 768px) {
      width: 1194px;
      max-width: 100%;
      grid: auto / repeat(6, 1fr);
      margin: 80px auto 0;
    }
  }

  .feature-card {
    border-radius: 12px;
    border: 1px solid rgba(38, 38, 38, 0.7);
    background: #141414;
    min-height: 350px;
    display: flex;
    justify-content: flex-start;
    align-items: flex-end;
    padding: 32px;
    position: relative;
    overflow: hidden;

    /* Extend height on smaller devices, to make room for text */
    @media (max-width: 380px) {
      padding: 24px;
    }

    .feature__meta {
      max-width: 275px;
      position: relative;
      z-index: 2;
      pointer-events: none;

      .meta__title {
        color: #fff;
        font-family: Manrope, sans-serif;
        font-size: 20px;
        font-style: normal;
        font-weight: 600;
        line-height: normal;
        letter-spacing: -0.4px;
        margin-bottom: 8px;
        cursor: default;
      }

      .meta__description {
        color: #a3a3a3;
        font-family: Inter, sans-serif;
        font-size: 16px;
        font-style: normal;
        font-weight: 400;
        line-height: 150%;
        letter-spacing: -0.32px;
        text-wrap: balance;
        cursor: default;
      }

      &.meta--center {
        margin: 0 auto;
        text-align: center;
      }
    }

    .feature__visualization {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
    }

    &:nth-child(1),
    &:nth-child(4) {
      grid-column: span 1;

      @media (min-width: 768px) {
        grid-column: span 3;
      }

      @media (min-width: 1200px) {
        grid-column: span 2;
      }
    }

    &:nth-child(2),
    &:nth-child(3) {
      grid-column: span 1;

      @media (min-width: 768px) {
        grid-column: span 3;
      }

      @media (min-width: 1200px) {
        grid-column: span 4;
      }
    }
  }

  &.feature-section--flip {
    .feature-card {
      &:nth-child(2),
      &:nth-child(3) {
        grid-column: span 1;

        @media (min-width: 768px) {
          grid-column: span 3;
        }

        @media (min-width: 1200px) {
          grid-column: span 2;
        }
      }

      &:nth-child(1),
      &:nth-child(4) {
        grid-column: span 1;

        @media (min-width: 768px) {
          grid-column: span 3;
        }

        @media (min-width: 1200px) {
          grid-column: span 4;
        }
      }
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureSSRSupport.vue
================================================
<script setup lang="ts">
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

/**
 * Slide the card in when the page loads
 */
useSlideIn('#ssr-support')

/**
 * Start the animation when the card is hovered
 */
const { isCardActive, startAnimation } = useCardAnimation(
  '#ssr-support',
  undefined,
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="ssr-support"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization" :class="{ active: isCardActive }">
      <svg
        width="402"
        height="166"
        viewBox="0 0 402 166"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        style="margin-top: 10px"
      >
        <!-- JS Box -->
        <g class="js">
          <g class="js__glow" filter="url(#filter-js-glow)">
            <rect
              x="30"
              y="31.0947"
              width="104"
              height="104"
              rx="16.2078"
              fill="url(#linear-js-glow)"
            />
            <rect
              x="30.6753"
              y="31.7701"
              width="102.649"
              height="102.649"
              rx="15.5325"
              stroke="#A3A3A3"
              stroke-width="1.35065"
            />
          </g>
          <g class="js__bg" filter="url(#filter-js-bg)">
            <rect
              x="30"
              y="31.0947"
              width="104"
              height="104"
              rx="16.2078"
              fill="url(#linear-js-bg)"
            />
          </g>
          <rect
            class="js__border"
            x="30.6753"
            y="31.7701"
            width="102.649"
            height="102.649"
            rx="15.5325"
            stroke="#A3A3A3"
            stroke-width="1.2"
          />
        </g>

        <!-- JS Text -->
        <text class="js-text" x="80" y="120">.JS</text>

        <!-- Connector -->
        <path
          class="connector"
          opacity="0.25"
          d="M133.5 84.5H164M164 84.5V58.5C164 52.4249 168.925 47.5 175 47.5H193.5M164 84.5V108C164 114.075 168.925 119 175 119H193.5"
        />

        <!-- Client Transform Box -->
        <g class="client" filter="url(#filter-client)">
          <g clip-path="url(#clip-client)">
            <rect
              class="client__bg"
              x="193"
              y="20"
              width="182"
              height="54"
              fill="url(#linear-client-bg)"
              fill-opacity="0.1"
            />
            <g class="client__glow" filter="url(#filter-client-glow)">
              <rect
                x="213"
                y="41.5342"
                width="12"
                height="12"
                rx="1"
                fill="#FFE358"
              />
            </g>
            <rect
              class="client__indicator"
              x="212.777"
              y="41.5338"
              width="12"
              height="12"
              rx="1"
            />
          </g>
          <rect
            class="client__border"
            x="193.507"
            y="22.507"
            width="180.986"
            height="50.0537"
            rx="11.661"
            stroke="#737373"
            stroke-opacity="0.3"
            stroke-width="1.014"
          />
        </g>

        <!-- Client Transform Text -->
        <text class="client-text" x="236" y="53">Client transform</text>

        <!-- Server Transform Box -->
        <g class="server" filter="url(#filter-server)">
          <g clip-path="url(#clip-server)">
            <rect
              class="server__bg"
              x="193"
              y="90"
              width="186"
              height="54"
              fill="url(#linear-server-bg)"
              fill-opacity="0.1"
            />
            <g class="server__glow" filter="url(#filter-server-glow)">
              <circle cx="218.933" cy="117.534" r="5.93296" fill="#FFE358" />
            </g>
            <rect
              class="server__indicator"
              x="212.777"
              y="111.74"
              width="12"
              height="12"
              rx="1"
            />
          </g>
          <rect
            x="193.507"
            y="92.7135"
            width="181.402"
            height="50.0537"
            rx="11.661"
            stroke="#737373"
            stroke-opacity="0.3"
            stroke-width="1.014"
          />
        </g>

        <!-- Server Transform Text -->
        <text class="server-text" x="236" y="122">Server transform</text>

        <!-- Definitions -->
        <defs>
          <filter
            id="filter-js-glow"
            x="0"
            y="1.09473"
            width="164"
            height="164"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur
              stdDeviation="15"
              result="effect1_foregroundBlur_1_6"
            />
          </filter>
          <filter
            id="filter-js-bg"
            x="30"
            y="31.0947"
            width="104"
            height="108"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feColorMatrix
              in="SourceAlpha"
              type="matrix"
              values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
              result="hardAlpha"
            />
            <feMorphology
              radius="3"
              operator="erode"
              in="SourceAlpha"
              result="effect1_innerShadow_1_6"
            />
            <feOffset dy="4" />
            <feGaussianBlur stdDeviation="5" />
            <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
            <feColorMatrix
              type="matrix"
              values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.35 0"
            />
            <feBlend
              mode="normal"
              in2="shape"
              result="effect1_innerShadow_1_6"
            />
          </filter>
          <filter
            id="filter-client"
            x="193"
            y="22"
            width="182"
            height="55.0677"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feColorMatrix
              in="SourceAlpha"
              type="matrix"
              values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
              result="hardAlpha"
            />
            <feOffset dy="4" />
            <feGaussianBlur stdDeviation="2" />
            <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
            <feColorMatrix
              type="matrix"
              values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"
            />
            <feBlend
              mode="normal"
              in2="shape"
              result="effect1_innerShadow_1_6"
            />
          </filter>
          <filter
            id="filter-client-glow"
            x="203"
            y="31.5342"
            width="32"
            height="32"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur
              stdDeviation="5"
              result="effect1_foregroundBlur_1_6"
            />
          </filter>
          <filter
            id="filter-server"
            x="193"
            y="92.2065"
            width="182.416"
            height="55.0677"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feColorMatrix
              in="SourceAlpha"
              type="matrix"
              values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
              result="hardAlpha"
            />
            <feOffset dy="4" />
            <feGaussianBlur stdDeviation="2" />
            <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
            <feColorMatrix
              type="matrix"
              values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"
            />
            <feBlend
              mode="normal"
              in2="shape"
              result="effect1_innerShadow_1_6"
            />
          </filter>
          <filter
            id="filter-server-glow"
            x="203"
            y="101.601"
            width="31.8659"
            height="31.8659"
            filterUnits="userSpaceOnUse"
            color-interpolation-filters="sRGB"
          >
            <feFlood flood-opacity="0" result="BackgroundImageFix" />
            <feBlend
              mode="normal"
              in="SourceGraphic"
              in2="BackgroundImageFix"
              result="shape"
            />
            <feGaussianBlur
              stdDeviation="5"
              result="effect1_foregroundBlur_1_6"
            />
          </filter>
          <linearGradient
            id="linear-js-glow"
            x1="130"
            y1="144"
            x2="22.5"
            y2="23.5002"
            gradientUnits="userSpaceOnUse"
          >
            <stop stop-color="#FFE358" />
            <stop offset="1" stop-color="#FFE358" stop-opacity="0" />
          </linearGradient>
          <linearGradient
            id="linear-js-bg"
            x1="130"
            y1="144"
            x2="22.5"
            y2="23.5002"
            gradientUnits="userSpaceOnUse"
          >
            <stop stop-color="#FFE358" />
            <stop offset="1" stop-color="#FFE358" stop-opacity="0" />
          </linearGradient>
          <linearGradient
            id="linear-client-bg"
            x1="193"
            y1="47"
            x2="375"
            y2="47"
            gradientUnits="userSpaceOnUse"
          >
            <stop stop-color="#FFE358" />
            <stop offset="1" stop-color="#FFE358" stop-opacity="0" />
          </linearGradient>
          <linearGradient
            id="linear-server-bg"
            x1="193"
            y1="117"
            x2="379"
            y2="117"
            gradientUnits="userSpaceOnUse"
          >
            <stop stop-color="#FFE358" />
            <stop offset="1" stop-color="#FFE358" stop-opacity="0" />
          </linearGradient>
          <clipPath id="clip-client">
            <rect
              x="193"
              y="22"
              width="182"
              height="51.0677"
              rx="12.168"
              fill="white"
            />
          </clipPath>
          <clipPath id="clip-server">
            <rect
              x="193"
              y="92.2065"
              width="182.416"
              height="51.0677"
              rx="12.168"
              fill="white"
            />
          </clipPath>
        </defs>
      </svg>
    </div>
    <div class="feature__meta">
      <div class="meta__title">First class SSR Support</div>
      <div class="meta__description">
        It's never been easier to setup custom SSR (Server-Side Rendering), or
        build your own SSR framework.
      </div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(-60px, 0, 0);
  }

  .feature__meta {
    max-width: calc(100%);
  }

  /* Extend height on smaller devices, to make room for text */
  @media (max-width: 380px) {
    height: 400px;
  }
}

.feature__visualization {
  margin-top: 10px;

  svg {
    width: calc(100% - 15px);
    margin: 0 auto;
  }

  .js-text {
    fill: #a3a3a3;
    font-family: Inter, sans-serif;
    font-size: 30px;
    font-weight: 500;
    line-height: normal;
    letter-spacing: -0.5px;
    user-select: none;
    pointer-events: none;
    transition: all 0.3s ease-in-out;
  }

  .connector {
    stroke: #a3a3a3;
    transition: all 0.3s ease-in-out;
  }

  .client__indicator,
  .server__indicator {
    fill: #1e1e1e;
    transition: all 0.1s ease-in-out;
  }

  .client-text,
  .server-text {
    fill: #565656;
    font-family: Inter, sans-serif;
    font-size: 15px;
    font-weight: 400;
    user-select: none;
    pointer-events: none;
    transition: all 0.3s ease-in-out;
  }

  .js__glow {
    opacity: 0;
    transition: all 0.3s ease-in-out;
  }

  .js__bg,
  .client__bg,
  .client__glow,
  .server__bg,
  .server__glow {
    opacity: 0;
    transition: all 0.3s ease-in-out;
  }

  &.active {
    .connector {
      stroke: #ffe358;
      transition-delay: 0.1s;
    }

    .client__indicator,
    .server__indicator {
      fill: #fdefab;
      transition-delay: 0.3s;
    }

    .js-text {
      fill: #171717;
    }

    .js__glow,
    .js__bg,
    .client__bg,
    .client__glow,
    .server__bg,
    .server__glow {
      opacity: 1;
    }

    .client__glow,
    .server__glow,
    .client__bg,
    .server__bg {
      transition-delay: 0.3s;
    }

    .client-text,
    .server-text {
      transition-delay: 0.3s;
      fill: #fafafa;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/2. feature-section/FeatureTypedAPI.vue
================================================
<script setup lang="ts">
import { useSlideIn } from '../../../composables/useSlideIn'
import { useCardAnimation } from '../../../composables/useCardAnimation'

/**
 * Slide the card in when the page loads
 */
useSlideIn('#fully-typed-api')

/**
 * Start the animation when the card is hovered
 */
const { isCardActive, startAnimation } = useCardAnimation(
  '#fully-typed-api',
  undefined,
  {
    once: true,
  },
)
</script>

<template>
  <div
    class="feature-card"
    id="fully-typed-api"
    @mouseover.stop.prevent="startAnimation"
  >
    <div class="feature__visualization" :class="{ active: isCardActive }">
      <div class="ide">
        <span class="code code__inactive">
          <span class="code--red">import</span> { createServer }
          <span class="code--red">from</span>
          <span class="code--blue">&nbsp;'vite'</span><br /><br />
          <span class="code--red">const</span> server =
          <span class="code--red">await</span>
          <span class="code--purple">&nbsp;createServer</span>({<br />
          <span class="code--grey"
            >&nbsp;&nbsp;&nbsp;// user config options</span
          ><br />
          })
        </span>
        <span class="code code__feature">
          <span class="code--red">await</span> server.<span
            class="code--highlight"
            >listen</span
          >()<br />
          <span class="code--extra"
            >server.<span class="code--purple">printUrls</span>()</span
          >
        </span>
      </div>
      <div class="tooltip">
        <span class="code">
          (method) ViteDevServer.<span class="code--blue">listen</span
          >(port<span class="code--blue">?:</span> number
          <span class="code--blue">| undefined,</span> isRestart<span
            class="code--blue"
            >?:</span
          >
          boolean <span class="code--blue">| undefined</span>):
          <span class="code--yellow">Promise</span
          ><span class="code--blue">&lt;</span>ViteDevServer<span
            class="code--blue"
            >&gt;</span
          ><br />
          <span class="code--descriptor">Start the server.</span>
        </span>
      </div>
    </div>
    <div class="feature__meta meta--center">
      <div class="meta__title">Fully typed API</div>
      <div class="meta__description">Designed to be built on top of.</div>
    </div>
  </div>
</template>

<style scoped>
.feature-card {
  @media (min-width: 768px) {
    transform: translate3d(60px, 0, 0);
  }
}

.feature__visualization {
  .ide {
    position: absolute;
    top: 0;
    left: 18px;
    right: 0;
    height: 195px;
    border-radius: 0 0 0 12px;
    overflow: hidden;
    transition: all 0.4s ease-in-out;
    border: 1px solid rgba(64, 64, 64, 0.5);
    border-right: none;
    border-top: none;
    background: linear-gradient(
      to top,
      rgba(23, 23, 23, 0.35) 0%,
      #171717 100%
    );
  }

  .tooltip {
    border-radius: 6px 0 0 6px;
    border: 1px solid #262626;
    background: linear-gradient(-45deg, #1f1f1f 40%, #282828 50%, #1f1f1f 60%);
    background-size: 400%;
    background-position-x: 100%;
    animation: shimmer 7s infinite linear;
    padding: 12px 2px 6px 12px;
    position: absolute;
    z-index: 5;
    top: 25px;
    left: 60px;
    right: 0;
    border-top: 1px solid #383838;
    opacity: 0;
    transition: all 0.2s ease-in-out;
    transform: translate3d(0, 20px, 0);
  }

  .code__inactive {
    opacity: 0.2;
    position: absolute;
    top: 15px;
    left: 15px;
    filter: blur(0);
    transition: all 0.4s ease-in-out;
  }

  .code__feature {
    position: absolute;
    top: 140px;
    left: 15px;
  }

  .code {
    color: #fff;
    text-shadow: 0 4px 4px rgba(0, 0, 0, 0.25);
    font-family:
      IBM Plex Mono,
      sans-serif;
    font-size: 11px;
    font-weight: 400;
    line-height: 150%;
    letter-spacing: -0.2px;
    display: block;
    margin: 0;
    user-select: none;
    pointer-events: none;

    .code--highlight {
      display: inline-block;
      position: relative;
      padding: 2px;
      color: #dc94ff;
      transition: all 0.1s ease-in-out;

      &:before {
        content: '';
        width: 100%;
        height: 100%;
        border-radius: 5px;
        opacity: 0;
        background: #94e2fb;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
        transition: all 0.1s ease-in-out;
      }
    }

    .code--purple {
      color: #dc94ff;
    }

    .code--red {
      color: #ff6b6b;
    }

    .code--blue {
      color: #94e2fb;
    }

    .code--grey {
      color: #737373;
    }

    .code--yellow {
      color: #ffe358;
    }

    .code--descriptor {
      margin-top: 8px;
      padding-top: 6px;
      display: block;
      border-top: 1px solid #363636;
    }

    .code--extra {
      transition: opacity 0.2s ease-in-out;
      opacity: 1;
    }
  }

  &.active {
    .code__inactive {
      filter: blur(5px);
    }

    .code--highlight {
      color: #94e2fb;

      &:before {
        opacity: 0.2;
      }
    }

    .tooltip {
      transition-delay: 0.1s;
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }

    .code--extra {
      opacity: 0.2;
    }
  }
}

@keyframes shimmer {
  to {
    background-position-x: 0;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/3. frameworks-section/FrameworkCard.vue
================================================
<script setup lang="ts">
import { type Ref, ref } from 'vue'

/**
 * A single framework or tool to display in the frameworks section.
 */
export interface Framework {
  /**
   * The name of the framework.
   */
  name?: string

  /**
   * A string representing the URL of the logo in SVG format.
   */
  logo?: string

  /**
   * A string representing the hex color of the glow effect.
   */
  color?: string

  /**
   * A string representing the URL of the framework/tool's homepage.
   */
  url?: string

  /**
   * Whether the framework card is visible or not.
   */
  visible: Ref<boolean>
}

interface Props {
  framework?: Framework
}

const props = withDefaults(defineProps<Props>(), {
  framework: (): Framework => ({
    visible: ref(true),
  }),
})
</script>

<template>
  <component
    :is="props.framework.url ? 'a' : 'div'"
    :href="props.framework.url ? props.framework.url : undefined"
    target="_blank"
    rel="noopener"
    class="framework-card"
    :style="{ '--glow-color': props.framework.color }"
    :class="{ active: props.framework.visible.value === true }"
  >
    <img
      v-if="props.framework.logo"
      :src="props.framework.logo"
      :alt="props.framework.name"
      loading="lazy"
    />
  </component>
</template>

<style scoped>
.framework-card {
  width: 96px;
  height: 96px;
  border-radius: 12px;
  border: 1px solid rgba(38, 38, 38, 0.7);
  background: #181818;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 24px;
  --glow-color: rgba(0, 0, 0, 0);
  opacity: 0;
  transition: opacity 0.4s ease;
  user-select: none;

  img {
    user-select: none;
    filter: drop-shadow(
      0 0 0.8rem color-mix(in srgb, var(--glow-color) 40%, transparent)
    );
  }

  &.active {
    opacity: 1;
  }
}

.framework-card:not(:has(img)) {
  transform: scale(1) translate3d(0, 0, 0);
  transition: transform 3s ease;

  &:hover {
    transform: scale(0.9) translate3d(0, 0, 0);
    transition: transform 0.2s ease-in-out;
  }
}

.framework-card:has(img) {
  cursor: pointer;
  position: relative;

  &:before {
    content: '';
    position: absolute;
    top: 10%;
    left: 10%;
    right: 10%;
    bottom: 10%;
    background-color: var(--glow-color);
    filter: blur(18px);
    z-index: -1;
    opacity: 0;
    transition: opacity 3s ease;
    will-change: opacity;
  }

  &:hover {
    &:before {
      opacity: 1;
      transition: opacity 0.2s ease;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/3. frameworks-section/FrameworksSection.vue
================================================
<script setup lang="ts">
import {
  computed,
  type ComputedRef,
  onMounted,
  onUnmounted,
  type Ref,
  ref,
} from 'vue'
import FrameworkCard, { type Framework } from './FrameworkCard.vue'
import { gsap } from 'gsap'
import { ScrollTrigger } from 'gsap/dist/ScrollTrigger'

gsap.registerPlugin(ScrollTrigger)

// Framework assets
import logoAstro from './images/astro.svg'
import logoNuxt from './images/nuxt.svg'
import logoVue from './images/vue.svg'
import logoAnalog from './images/analog.svg'
import logoPlaywright from './images/playwright.svg'
import logoMarko from './images/marko.svg'
import logoStorybook from './images/storybook.svg'
import logoQwik from './images/qwik.svg'
import logoVitest from './images/vitest.svg'
import logoRedwood from './images/redwood.svg'
import logoSolid from './images/solid.svg'
import logoAngular from './images/angular.svg'
import logoReact from './images/react.svg'
import logoRemix from './images/remix.svg'
import logoSvelte from './images/svelte.svg'
import logoLaravel from './images/laravel.svg'
import logoAdonis from './images/adonis.svg'
import logoEmber from './images/ember.svg'
import logoPreact from './images/preact.svg'
import logoHono from './images/hono.svg'

/**
 * The frameworks and tools to display in this section.
 */
const frameworks: Framework[] = [
  {
    name: 'Vitest',
    logo: logoVitest,
    color: '#fac52b',
    url: 'https://vitest.dev/',
    visible: ref(false),
  },
  {
    name: 'React',
    logo: logoReact,
    color: '#00d6fd',
    url: 'https://react.dev/',
    visible: ref(false),
  },
  {
    name: 'Angular',
    logo: logoAngular,
    color: '#e03237',
    url: 'https://angular.dev/',
    visible: ref(false),
  },
  {
    name: 'Vue',
    logo: logoVue,
    color: '#40b782',
    url: 'https://vuejs.org/',
    visible: ref(false),
  },
  {
    name: 'Solid',
    logo: logoSolid,
    color: '#75b2df',
    url: 'https://www.solidjs.com/',
    visible: ref(false),
  },
  {
    name: 'Svelte',
    logo: logoSvelte,
    color: '#fd3e00',
    url: 'https://svelte.dev/',
    visible: ref(false),
  },
  {
    name: 'Preact',
    logo: logoPreact,
    color: '#673ab8',
    url: 'https://preactjs.com/',
    visible: ref(false),
  },
  {
    name: 'Astro',
    logo: logoAstro,
    color: '#FFFFFF',
    url: 'https://astro.build',
    visible: ref(false),
  },
  {
    name: 'Remix',
    logo: logoRemix,
    color: '#3991fd',
    url: 'https://remix.run/',
    visible: ref(false),
  },
  {
    name: 'Nuxt',
    logo: logoNuxt,
    color: '#00da81',
    url: 'https://nuxt.com',
    visible: ref(false),
  },
  {
    name: 'Qwik',
    logo: logoQwik,
    color: '#18b5f4',
    url: 'https://qwik.dev/',
    visible: ref(false),
  },
  {
    name: 'Redwood',
    logo: logoRedwood,
    color: '#be4622',
    url: 'https://redwoodjs.com/',
    visible: ref(false),
  },
  {
    name: 'Analog',
    logo: logoAnalog,
    color: '#c10f2e',
    url: 'https://analogjs.org/',
    visible: ref(false),
  },
  {
    name: 'Playwright',
    logo: logoPlaywright,
    color: '#d45247',
    url: 'https://playwright.dev/',
    visible: ref(false),
  },
  {
    name: 'Storybook',
    logo: logoStorybook,
    color: '#fd4684',
    url: 'https://storybook.js.org/',
    visible: ref(false),
  },
  {
    name: 'Marko',
    logo: logoMarko,
    color: '#de2a87',
    url: 'https://markojs.com/',
    visible: ref(false),
  },
  {
    name: 'Laravel',
    logo: logoLaravel,
    color: '#eb4432',
    url: 'https://laravel.com/',
    visible: ref(false),
  },
  {
    name: 'AdonisJS',
    logo: logoAdonis,
    color: '#5a45ff',
    url: 'https://adonisjs.com/',
    visible: ref(false),
  },
  {
    name: 'EmberJS',
    logo: logoEmber,
    color: '#e04e39',
    url: 'https://emberjs.com/',
    visible: ref(false),
  },
  {
    name: 'Hono',
    logo: logoHono,
    color: '#ff5c13',
    url: 'https://hono.dev/',
    visible: ref(false),
  },
]

// Starting parameters
const screenWidth: Ref<number> = ref(1920)
let resizeTimeout: ReturnType<typeof setTimeout> | null = null
let timeline: gsap.core.Timeline | null = null

/**
 * When the resize event fires, update the screen width.
 */
const handleResize = () => {
  screenWidth.value = window.innerWidth
}

/**
 * Throttle the resize event handler.
 */
const throttledResizeHandler = () => {
  if (resizeTimeout === null) {
    resizeTimeout = setTimeout(() => {
      handleResize()
      resizeTimeout = null
    }, 100)
  }
}

onMounted(() => {
  // Set the initial size of the screen
  handleResize()

  // Listen for resize events
  window.addEventListener('resize', throttledResizeHandler)

  // Initialize the GSAP timeline
  timeline = gsap.timeline({
    scrollTrigger: {
      trigger: '#frameworks-section',
      start: 'top 70%',
      once: true,
    },
  })

  frameworks.forEach((framework, index) => {
    timeline!.set(framework.visible, { value: true }, index * 0.05)
  })
})

onUnmounted(() => {
  // Deregister the throttled event handler
  window.removeEventListener('resize', throttledResizeHandler)

  // Clear any pending execution of the resize handler
  if (resizeTimeout) {
    clearTimeout(resizeTimeout)
    resizeTimeout = null
  }

  // Kill the GSAP timeline
  if (timeline) {
    timeline.kill()
    timeline = null
  }
})

/**
 * How many total blocks (framework or empty) will fit in a single row?
 */
const numBlocksPerRow: ComputedRef<number> = computed(() => {
  return Math.floor(screenWidth.value / (96 + 24))
})

const paddedBlocksPerSide: ComputedRef<number> = computed(() => {
  if (screenWidth.value < 840) {
    return 0
  }
  if (screenWidth.value < 1280) {
    return 1
  }
  if (screenWidth.value < 1600) {
    return 2
  }
  return Math.max(Math.floor((screenWidth.value - 840) / 280), 0)
})

const numFrameworksPerRow = computed(
  () => numBlocksPerRow.value - paddedBlocksPerSide.value * 2,
)

/**
 * How many rows do we need to display all the frameworks?
 */
const numRows: ComputedRef<number> = computed(() => {
  return Math.ceil(frameworks.length / numFrameworksPerRow.value)
})

/**
 * The indexes of the blocks on each row that support framework cards.
 *
 * Note that the index of the returned array is 1-based.
 */
const centerIndexes: ComputedRef<{ start: number; end: number }[]> = computed(
  () => {
    const firstRowsStartIndex = paddedBlocksPerSide.value
    const frameworksPerFirstRows =
      numBlocksPerRow.value - 2 * paddedBlocksPerSide.value
    const lastRowStartIndex =
      paddedBlocksPerSide.value +
      Math.floor(
        (frameworksPerFirstRows -
          (frameworks.length % frameworksPerFirstRows)) /
          2,
      )
    return new Array(numRows.value + 1).fill(0).map((_, i) => {
      return i < numRows.value ||
        frameworks.length % frameworksPerFirstRows === 0
        ? {
            start: firstRowsStartIndex,
            end: numBlocksPerRow.value - paddedBlocksPerSide.value,
          }
        : {
            start: lastRowStartIndex,
            end:
              lastRowStartIndex +
              (frameworks.length % frameworksPerFirstRows) +
              1,
          }
    })
  },
)

/**
 * Generate CSS transformations for each row, to gracefully slide between horizontal positions.
 */
const rowStyle: ComputedRef<{ transform: string }> = computed(() => {
  return {
    transform: `translate3d(var(--row-offset), 0, 0)`,
  }
})
</script>

<template>
  <section class="frameworks-section" id="frameworks-section">
    <h2>Powering your favorite frameworks and tools</h2>
    <div class="frameworks-container">
      <!-- Top Row -->
      <div class="framework-row" :style="rowStyle">
        <FrameworkCard v-for="_ in numBlocksPerRow + 2" />
      </div>

      <!-- Logo Rows -->
      <template v-for="rowIndex in numRows">
        <div class="framework-row" :style="rowStyle">
          <template v-for="columnIndex in numBlocksPerRow + 2">
            <template
              v-if="
                columnIndex - 1 >= centerIndexes[rowIndex].start &&
                columnIndex - 1 < centerIndexes[rowIndex].end
              "
            >
              <FrameworkCard
                :framework="
                  frameworks[
                    (rowIndex - 1) * numFrameworksPerRow +
                      (columnIndex - 1) -
                      centerIndexes[rowIndex].start
                  ]
                "
              />
            </template>
            <template v-else>
              <FrameworkCard />
            </template>
          </template>
        </div>
      </template>

      <!-- Bottom Row -->
      <div class="framework-row" :style="rowStyle">
        <FrameworkCard v-for="_ in numBlocksPerRow + 2" />
      </div>
    </div>
  </section>
</template>

<style scoped>
.frameworks-section {
  margin-top: 150px;

  @media (min-width: 768px) {
    margin-top: 240px;
  }

  h2 {
    background: linear-gradient(0deg, #fff 0%, rgba(255, 255, 255, 0.76) 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    width: 668px;
    max-width: 100%;
    margin: 0 auto;
    text-align: center;
    position: relative;
    z-index: 3;
  }

  .frameworks-container {
    width: 100%;
    background-color: rgba(38, 38, 38, 0.15);
    position: relative;
    margin-top: -20px;
    overflow: hidden;

    @media (min-width: 840px) {
      mask-image: linear-gradient(
        90deg,
        transparent 0%,
        #ffffff 300px,
        #ffffff calc(100vw - 300px),
        transparent 100%
      );
    }

    &:before {
      content: '';
      display: block;
      width: 100%;
      height: 80px;
      background: linear-gradient(
        0deg,
        rgba(23, 23, 23, 0) 0%,
        rgba(16, 16, 16, 0.7) 50%,
        #101010 100%
      );
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2;
      pointer-events: none;
    }

    &:after {
      content: '';
      display: block;
      width: 100%;
      height: 100px;
      background: linear-gradient(
        180deg,
        rgba(23, 23, 23, 0) 0%,
        rgba(16, 16, 16, 0.7) 50%,
        #101010 100%
      );
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 2;
      pointer-events: none;
    }
  }

  .framework-row {
    display: grid;
    grid-auto-columns: 96px;
    grid-gap: 24px;
    justify-content: flex-start;
    margin-bottom: 24px;
    position: relative;
    white-space: nowrap;
    grid-auto-flow: column;

    &:nth-child(even) {
      --row-offset: 36px;
    }

    &:nth-child(odd) {
      --row-offset: 12px;
    }

    @media (min-width: 1080px) {
      &:nth-child(even) {
        --row-offset: 24px;
      }

      &:nth-child(odd) {
        --row-offset: -24px;
      }
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/4. community-section/CommunityCard.vue
================================================
<script setup lang="ts">
export interface Testimonial {
  /**
   * The URL to the avatar image.
   */
  avatar: string

  /**
   * The name of the Vite user.
   */
  name: string

  /**
   * Their social media handle.
   */
  handle: string

  /**
   * Their comment/testimonial about Vite.
   */
  comment: string[]
}

defineProps<{
  /**
   * A testimonial from a Vite user.
   */
  testimonial: Testimonial
}>()
</script>

<template>
  <div class="community-card">
    <div class="card__header">
      <img
        :src="testimonial.avatar"
        :alt="testimonial.name"
        class="card__avatar"
        loading="lazy"
      />
      <div class="card__meta">
        <span class="card__name">
          {{ testimonial.name }}
        </span>
        <span class="card__handle">
          {{ testimonial.handle }}
        </span>
      </div>
    </div>
    <div class="card__content">
      <p v-for="p of testimonial.comment">{{ p }}</p>
    </div>
  </div>
</template>

<style scoped>
.community-card {
  break-inside: avoid;
  width: 100%;
  margin-bottom: 25px;
  border-radius: 12px;
  border: 1px solid rgba(38, 38, 38, 0.7);
  background: #161616;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;

  .card__avatar {
    width: 48px;
    aspect-ratio: 1;
    border-radius: 100%;
  }

  .card__content {
    color: #a3a3a3;
    font-family: Inter, sans-serif;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 150%;
    letter-spacing: -0.32px;
    text-wrap: pretty;
    cursor: default;
  }

  .card__content p {
    margin-top: 10px;
  }

  .card__header {
    display: flex;
    flex-direction: row;
    gap: 20px;
    align-items: center;
  }

  .card__meta {
    display: flex;
    flex-direction: column;
  }

  .card__name {
    color: #fff;
    font-family: Inter, sans-serif;
    font-size: 16px;
    font-style: normal;
    font-weight: 500;
    line-height: 150%;
    letter-spacing: -0.3px;
  }

  .card__handle {
    color: #a3a3a3;
    font-family: Inter, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 500;
    line-height: 150%;
    letter-spacing: -0.3px;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/4. community-section/CommunitySection.vue
================================================
<script setup lang="ts">
import CommunityCard, { type Testimonial } from './CommunityCard.vue'

const testimonials: Testimonial[] = [
  {
    name: 'Ryan Carniato',
    handle: '@RyanCarniato',
    avatar:
      'https://pbs.twimg.com/profile_images/1810837163447308292/8Piov0f6_400x400.jpg',
    comment: [
      `I'm loving what Vite enables. We've found building SolidStart that it is less a metaframework but a system of symbiotic Vite plugins. While built with
SolidJS in mind, they should scale from our simplest template to opinionated starter. We're building an ecosystem on Vite.`,
    ],
  },
  {
    name: 'Rich Harris',
    handle: '@Rich_Harris',
    avatar:
      'https://pbs.twimg.com/profile_images/557940120184041473/bFyXy8Pu_400x400.jpeg',
    comment: [
      `Vite is basically the united nations of JavaScript at this point. I'll be there as a representative of Sveltelandia`,
    ],
  },
  {
    name: 'David East',
    handle: '@_davideast',
    avatar:
      'https://pbs.twimg.com/profile_images/1691627325794725888/voQFcYjY_400x400.jpg',
    comment: [
      'Each and every time I use Vite, I feel a true sense of pure and unbridled joy.',
    ],
  },
  {
    name: 'Mark Dalgleish',
    handle: '@markdalgleish',
    avatar:
      'https://pbs.twimg.com/profile_images/754886061872979968/BzaOWhs1_400x400.jpg',
    comment: [
      `It’s also a great platform to build a framework on since it provides a pluggable dev environment.`,
      `Community is amazing too.`,
    ],
  },
  {
    name: 'Jason Miller',
    handle: '@_developit',
    avatar:
      'https://pbs.twimg.com/profile_images/1374778373239681025/Sc9ehtAr_400x400.jpg',
    comment: [
      `Every time I suspect I've hit the bounds of what Vite can do, I end up being wrong.`,
    ],
  },
  {
    name: 'David Cramer',
    handle: '@zeeg',
    avatar:
      'https://pbs.twimg.com/profile_images/1911613315765133312/HVkULegC_400x400.jpg',
    comment: ['Vite has been a game changer for the industry.'],
  },
  {
    name: 'Dion Almaer',
    handle: '@dalmaer',
    avatar:
      'https://pbs.twimg.com/profile_images/3380865881/f73b3687ff39b795db05fcaf35972270_400x400.jpeg',
    comment: [
      'I am so excited to see so many great frameworks teaming up on top of vite. So many will benefit. ❤️ to the vite team.',
    ],
  },
  {
    name: 'Christoph Nakazawa',
    handle: '@cpojer',
    avatar:
      'https://pbs.twimg.com/profile_images/1910252462126313472/gXgT-jxL_400x400.jpg',
    comment: ['Vite is gonna eat the (JavaScript) world.'],
  },
  {
    name: 'Nikolaj',
    handle: '@lopugit',
    avatar: 'https://avatars.githubusercontent.com/u/13629190?v=4',
    comment: [
      'Wow, wow, wow, wow, wow, wow, Vite is..... Vite is.... Wow 🤤🤯🙏',
    ],
  },
]
</script>

<template>
  <section class="community-section">
    <h2>Loved by the community</h2>
    <h3>
      Don't take our word for it - listen to what Vite community members have to
      say.
    </h3>
    <div class="community-grid-container">
      <div class="community-grid">
        <CommunityCard
          :testimonial="testimonial"
          v-for="testimonial in testimonials"
          :key="testimonial.name"
        />
      </div>
    </div>
  </section>
</template>

<style scoped>
.community-section {
  margin-top: 140px;
  display: none;

  @media (min-width: 768px) {
    display: block;
  }

  h2 {
    background: linear-gradient(0deg, #fff 0%, rgba(255, 255, 255, 0.76) 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin: 0 auto 10px;
    text-align: center;
  }

  h3 {
    width: 455px;
    max-width: 100%;
    margin: 0 auto;
    text-align: center;
  }

  .community-grid-container {
    position: relative;
  }

  .community-grid {
    column-count: 2;
    column-gap: 25px;
    width: calc(100% - 50px);
    margin: 40px auto 0;

    @media (min-width: 1150px) {
      column-count: 3;
      width: 1100px;
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/5. sponsor-section/SponsorSection.vue
================================================
<script setup lang="ts">
import { useSponsor, voidZero } from '../../../composables/sponsor'
import { VPSponsors } from 'vitepress/theme'

const { data } = useSponsor()
</script>

<template>
  <div class="sponsor-section">
    <svg
      class="bg-lines"
      width="1793"
      height="1269"
      viewBox="0 0 1793 1269"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M752.613 0.717285L787.634 201.189C794.351 239.643 797.729 278.606 797.729 317.642L797.729 1268.54M649.493 0.717285L704.366 138.145C736.239 217.969 752.613 303.135 752.613 389.088L752.614 1268.54M572.153 0.717285L630.175 111.432C680.966 208.35 707.498 316.138 707.498 425.558L707.498 1268.54M505.862 0.717285L564.392 97.2923C628.492 203.058 662.383 324.367 662.383 448.041L662.383 1268.54M452.46 0.717285L511.009 92.4655C580.401 201.205 617.268 327.512 617.268 456.507L617.268 1268.54M407.345 0.717285L465.894 92.4655C535.286 201.205 572.153 327.512 572.153 456.507L572.153 1268.54M362.23 0.717285L420.779 92.4655C490.17 201.205 527.038 327.512 527.038 456.507L527.038 1268.54M317.115 0.717285L375.664 92.4655C445.055 201.205 481.923 327.512 481.923 456.507L481.923 1268.54M272 0.717285L330.549 92.4655C399.94 201.205 436.808 327.512 436.808 456.507L436.808 1268.54M226.885 0.717285L285.433 92.4655C354.825 201.205 391.693 327.512 391.693 456.507L391.693 1268.54M181.77 0.717285L240.318 92.4655C309.71 201.205 346.578 327.512 346.578 456.507L346.578 1268.54M136.655 0.717285L195.203 92.4655C264.595 201.205 301.463 327.512 301.463 456.507L301.463 1268.54M91.5395 0.717285L150.088 92.4655C219.48 201.205 256.348 327.512 256.348 456.507L256.348 1268.54M46.4244 0.717285L104.973 92.4655C174.365 201.205 211.233 327.512 211.233 456.507L211.233 1268.54M1.30933 0.717285L59.8581 92.4655C129.25 201.205 166.117 327.512 166.117 456.507L166.117 1268.54M1040.8 0.717285L1005.78 201.189C999.06 239.643 995.683 278.606 995.683 317.642V1268.54M1143.92 0.717285L1089.04 138.145C1057.17 217.969 1040.8 303.135 1040.8 389.088V1268.54M1221.26 0.717285L1163.24 111.432C1112.45 208.35 1085.91 316.138 1085.91 425.558V1268.54M1287.55 0.717285L1229.02 97.2923C1164.92 203.058 1131.03 324.367 1131.03 448.041V1268.54M1340.95 0.717285L1282.4 92.4655C1213.01 201.205 1176.14 327.512 1176.14 456.507V1268.54M1386.07 0.717285L1327.52 92.4655C1258.13 201.205 1221.26 327.512 1221.26 456.507V1268.54M1431.18 0.717285L1372.63 92.4655C1303.24 201.205 1266.37 327.512 1266.37 456.507V1268.54M1476.3 0.717285L1417.75 92.4655C1348.36 201.205 1311.49 327.512 1311.49 456.507V1268.54M1521.41 0.717285L1462.86 92.4655C1393.47 201.205 1356.6 327.512 1356.6 456.507V1268.54M1566.53 0.717285L1507.98 92.4655C1438.59 201.205 1401.72 327.512 1401.72 456.507V1268.54M1611.64 0.717285L1553.09 92.4655C1483.7 201.205 1446.83 327.512 1446.83 456.507V1268.54M1656.76 0.717285L1598.21 92.4655C1528.82 201.205 1491.95 327.512 1491.95 456.507V1268.54M1701.87 0.717285L1643.32 92.4655C1573.93 201.205 1537.06 327.512 1537.06 456.507V1268.54M1746.99 0.717285L1688.44 92.4655C1619.05 201.205 1582.18 327.512 1582.18 456.507V1268.54M1792.1 0.717285L1733.55 92.4655C1664.16 201.205 1627.29 327.512 1627.29 456.507V1268.54M968.061 0.717335L950.567 258.978V1268.54M893.943 0.717285L893.943 1268.54M824.89 0.717285L842.843 258.978L842.843 1268.54"
        stroke="url(#linear-sponsor-lines)"
      />
      <defs>
        <linearGradient
          id="linear-sponsor-lines"
          x1="0"
          y1="0"
          x2="0"
          y2="1200"
          gradientUnits="userSpaceOnUse"
        >
          <stop offset="0.1" stop-color="#1b1c20" stop-opacity="0" />
          <stop offset="0.35" stop-color="#1b1c20" />
          <stop offset="0.55" stop-color="#1b1c20" stop-opacity="0.2" />
          <stop offset="0.6" stop-color="#1b1c20" stop-opacity="0.2" />
          <stop offset="0.7" stop-color="#1b1c20" />
          <stop offset="1" stop-color="#1b1c20" stop-opacity="0" />
        </linearGradient>
      </defs>
    </svg>

    <!-- Title Section -->
    <img
      class="icon-heart"
      src="./heart.svg"
      alt="Vite is made possible by our contributors, partner companies, and sponsors"
      width="58"
      height="55"
      loading="lazy"
    />
    <h2>Free &amp; open source</h2>
    <h4>
      Vite is MIT Licensed and will always be free and open source. This is made
      possible by our contributors and these companies:
    </h4>

    <h4>Brought to you by</h4>
    <div class="voidzero">
      <a :href="voidZero.url" target="_blank">
        <img :src="voidZero.img" alt="VoidZero logo" loading="lazy" />
      </a>
    </div>

    <!-- Sponsor Grid -->
    <div class="sponsor-grid">
      <VPSponsors v-if="data" :data="data" />
    </div>

    <!-- Sponsorship Actions -->
    <div class="sponsor-actions">
      <a
        href="https://github.com/sponsors/vitejs"
        target="_blank"
        class="btn btn--outline btn--rounded"
        >Become a Sponsor</a
      >
    </div>
  </div>
</template>

<style scoped>
.sponsor-section {
  margin-top: 120px;
  position: relative;
  max-width: 100%;
  overflow: hidden;

  @media (min-width: 768px) {
    margin-top: 180px;
  }

  .bg-lines {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    width: 100%;
    z-index: 0;
    display: none;
    pointer-events: none;

    @media (min-width: 1240px) {
      display: block;
    }
  }

  .icon-heart {
    margin: 0 auto 10px;
  }

  h2 {
    background: linear-gradient(0deg, #fff 0%, rgba(255, 255, 255, 0.76) 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin: 0 auto 10px;
    text-align: center;
  }

  .voidzero {
    text-align: center;
    img {
      position: relative;
      display: inline-block;
      max-width: 260px;
      filter: grayscale(1) invert(1);
    }
  }

  h4 {
    color: #a3a3a3;
    text-align: center;
    font-family: Inter, sans-serif;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 150%; /* 24px */
    letter-spacing: -0.32px;
    width: 520px;
    max-width: 100%;
    margin: 0 auto 40px;
    padding: 0 20px;
  }

  .sponsor-grid {
    width: 1200px;
    margin: 40px auto 0;

    @media (max-width: 1240px) {
      width: 100%;
      padding: 0 20px;
    }

    &:deep(.vp-sponsor-tier) {
      color: #fff;
      text-align: center;
      font-family: Inter, sans-serif;
      font-size: 16px;
      font-style: normal;
      font-weight: 500;
      line-height: 150%;
      letter-spacing: -0.32px;
      width: 100%;
      max-width: unset;
      padding: 18px;
      display: block;
      border-radius: 12px;
      border: 1px solid rgba(38, 38, 38, 0.7);
      background: #161616;
      margin: 20px auto !important;

      @media (min-width: 768px) {
        background: rgba(38, 38, 38, 0.25);
        backdrop-filter: blur(1px);
      }
    }

    &:deep(.vp-sponsor-grid) {
      gap: 20px;
    }

    &:deep(.vp-sponsor-grid-item) {
      border-radius: 12px;
      border: 1px solid rgba(38, 38, 38, 0.7);
      background: #161616;

      @media (min-width: 768px) {
        background: rgba(38, 38, 38, 0.25);
        backdrop-filter: blur(1px);
      }
    }

    &:deep(.vp-sponsor-grid[data-vp-grid='2'] .vp-sponsor-grid-item) {
      width: calc((100% - 20px) / 2);
    }

    &:deep(.vp-sponsor-grid[data-vp-grid='3'] .vp-sponsor-grid-item) {
      width: calc((100% - 20px * 2) / 3);
    }

    &:deep(.vp-sponsor-grid[data-vp-grid='4'] .vp-sponsor-grid-item) {
      width: calc((100% - 20px * 3) / 4);
    }

    &:deep(.vp-sponsor-grid[data-vp-grid='5'] .vp-sponsor-grid-item) {
      width: calc((100% - 20px * 4) / 5);
    }

    &:deep(.vp-sponsor-grid-item .vp-sponsor-grid-image) {
      transition: transform 0.2s ease-in-out;
    }

    &:deep(.vp-sponsor-grid-item:hover .vp-sponsor-grid-image) {
      filter: grayscale(1) invert(1);
      transform: scale(1.05);
    }
  }

  .sponsor-actions {
    margin: 60px auto 0;
    width: fit-content;
    display: flex;
    flex-direction: row;
    gap: 20px;
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/6. get-started-section/GetStartedSection.vue
================================================
<template>
  <div class="get-started-section">
    <div class="vite-chip">
      <svg
        width="134"
        height="134"
        viewBox="0 0 134 134"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g>
          <rect
            class="vite-chip__background"
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            fill="black"
            fill-opacity="0.3"
          />
          <rect
            class="vite-chip__highlight"
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            fill="url(#linear-vite-chip-highlight)"
            fill-opacity="0.1"
          />
          <rect
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            stroke="#111111"
            stroke-opacity="0.2"
            stroke-width="1"
          />
        </g>
        <g opacity="0.6">
          <rect
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            fill="#1E1E1E"
            fill-opacity="0.4"
          />
          <rect
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            stroke="url(#radial-edge)"
            stroke-width="1.15417"
          />
          <rect
            x="1"
            y="1"
            width="132"
            height="132"
            rx="10"
            stroke="url(#radial-edge-2)"
            stroke-opacity="0.1"
            stroke-width="1.15417"
          />
        </g>
        <defs>
          <linearGradient
            id="linear-vite-chip-highlight"
            x1="6.92498"
            y1="15.5812"
            x2="113.685"
            y2="116.571"
            gradientUnits="userSpaceOnUse"
          >
            <stop offset="0" stop-opacity="0" />
            <stop offset="0.37" stop-color="white" />
            <stop offset="1" stop-opacity="0" />
          </linearGradient>
          <radialGradient
            id="radial-edge"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(95.2187 56.5541) rotate(110.653) scale(80.173)"
          >
            <stop offset="0" stop-color="white" />
            <stop offset="1" stop-opacity="0" />
          </radialGradient>
          <radialGradient
            id="radial-edge-2"
            cx="0"
            cy="0"
            r="1"
            gradientUnits="userSpaceOnUse"
            gradientTransform="translate(8.65624 122.919) rotate(-21.5713) scale(80.0504)"
          >
            <stop offset="0" stop-color="white" />
            <stop offset="1" stop-opacity="0" />
          </radialGradient>
        </defs>
      </svg>
      <img src="/logo.svg" alt="Vite Logo" class="vite-chip__logo" />
    </div>
    <h2>Start building with Vite</h2>
    <h3>
      Prepare for a development environment that can finally keep pace with the
      speed of your mind.
    </h3>
    <a href="/guide/" class="btn btn--primary">Get started</a>
    <div class="glow glow--purple" />
    <div class="glow glow--blue" />
  </div>
</template>

<style scoped>
.get-started-section {
  margin: 0 auto;
  padding-top: 260px;
  padding-bottom: 220px;
  position: relative;
  overflow: hidden;

  h2 {
    color: #fff;
    font-size: 44px;
    font-style: normal;
    font-weight: 600;
    line-height: 120%;
    letter-spacing: -1px;
    margin: 0 auto 20px;
    text-align: center;
    position: relative;
    z-index: 1;

    @media (min-width: 768px) {
      font-size: 52px;
    }
  }

  h3 {
    margin: 0 auto 40px;
    color: #d4d4d8;
    position: relative;
    z-index: 1;
  }

  .btn {
    margin: 0 auto;
    position: relative;
    z-index: 1;
  }

  .vite-chip {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 84px;
    aspect-ratio: 1;
    filter: drop-shadow(0px 18px 33px rgba(0, 0, 0, 0.5));
    margin: 0 auto 60px;
    border: 1px solid #2b4659;
    border-radius: 6px;
    position: relative;
    z-index: 1;

    &:before {
      content: '';
      position: absolute;
      bottom: -30px;
      left: -20px;
      width: 80px;
      height: 80px;
      background: linear-gradient(180deg, #61d9ff 0%, rgba(0, 0, 0, 0) 100%);
      z-index: -1;
      filter: blur(30px);
    }

    &:after {
      content: '';
      position: absolute;
      top: -20px;
      right: -20px;
      width: 80px;
      height: 80px;
      background: linear-gradient(
        270deg,
        #7a23a1 0%,
        rgba(113, 94, 189, 0.9) 60%,
        rgba(113, 94, 189, 0.9) 80%,
        rgba(189, 52, 254, 0) 100%
      );
      z-index: -1;
      filter: blur(30px);
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      max-width: 100%;
      z-index: 2;
      border: 1px solid #2f2f2f;
      border-radius: 5px;
      filter: drop-shadow(0px 10px 5px rgba(0, 0, 0, 0.5));
    }

    .vite-chip__logo {
      position: relative;
      width: 50%;
      opacity: 0.8;
      z-index: 3;
      filter: drop-shadow(
        0 0 0.6rem color-mix(in srgb, #ffffad 50%, transparent)
      );
    }
  }

  .glow {
    &.glow--blue {
      position: absolute;
      bottom: -15%;
      left: -20%;
      width: 80%;
      aspect-ratio: 1.5;
      pointer-events: none;
      z-index: 0;
      border-radius: 100%;
      background: linear-gradient(180deg, #61d9ff 0%, rgba(0, 0, 0, 0) 100%);
      filter: blur(15vw);
      transform: none;
      opacity: 0.5;

      @media (min-width: 768px) {
        filter: blur(10vw);
        bottom: -30%;
        left: -10%;
        opacity: 0.2;
      }

      @media (min-width: 1025px) {
        filter: blur(80px);
        width: 900px;
        left: calc(50% - 700px);
      }
    }

    &.glow--purple {
      position: absolute;
      bottom: -15%;
      right: -20%;
      width: 80%;
      aspect-ratio: 1.5;
      pointer-events: none;
      z-index: 0;
      border-radius: 100%;
      background: linear-gradient(
        270deg,
        #7a23a1 0%,
        rgba(113, 94, 189, 0.9) 60%,
        rgba(113, 94, 189, 0.9) 80%,
        rgba(189, 52, 254, 0) 100%
      );
      filter: blur(15vw);
      transform: none;
      opacity: 0.6;

      @media (min-width: 768px) {
        filter: blur(10vw);
        bottom: -30%;
        right: -10%;
        opacity: 0.3;
      }

      @media (min-width: 1025px) {
        filter: blur(90px);
        width: 1100px;
        right: calc(50% - 700px);
      }
    }
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/components/landing/common/noise.webp
================================================
[Binary file]


================================================
FILE: docs/.vitepress/theme/components/landing/common/SvgNode.vue
================================================
<script setup lang="ts">
import { computed, type Ref, ref, watch, type ComputedRef } from 'vue'
import { gsap } from 'gsap'

/**
 * A single glowing "node" (dot) on an SVG path.
 */
export interface SvgNodeProps {
  /**
   * The SVG path to draw the node on.
   */
  path: string

  /**
   * The position of the node along the path, represented as a percentage from 0-1.
   */
  position?: number

  /**
   * Whether the node is visible or not.
   */
  visible?: boolean

  /**
   * Whether the node label is visible or not.
   */
  labelVisible?: boolean

  /**
   * The label to display next to the node.
   */
  label?: string

  /**
   * The color of the glow effect.
   */
  glowColor?: string | undefined

  /**
   * The color of the dot.
   */
  dotColor?: string | undefined
}

const props = withDefaults(defineProps<SvgNodeProps>(), {
  position: 0,
  visible: false,
  labelVisible: false,
  glowColor: '#41D1FF',
  dotColor: '#9fe6fd',
})

/**
 * A unique id for the path, to avoid collisions in a single SVG output.
 */
const pathId: Ref<string> = ref(Math.random().toString(36))

/**
 * A ref for the path element in the SVG DOM.
 */
const pathElement: Ref<SVGPathElement | null> = ref(null)

/**
 * The radius on each side of the dot, represented as a glow on the SVG path.
 */
const gradientWidth: Ref<number> = ref(30)

/**
 * A scale factor for animating the gradient width.
 */
const gradientWidthScaleFactor: Ref<number> = ref(props.visible ? 1 : 0)

/**
 * The length of the SVG path.
 */
const pathLength: ComputedRef<number> = computed(() => {
  if (!pathElement.value) return 0
  return pathElement.value.getTotalLength()
})

/**
 * The position of the dot on the SVG path.
 */
const dotPosition: Ref<{ x: number; y: number }> = ref({ x: 0, y: 0 })

/**
 * Watch for changes to the position of the dot.
 */
watch(
  () => props.position,
  () => {
    if (!pathElement.value) return { x: 0, y: 0 }
    const position = (1 - props.position) * pathLength.value
    const { x, y } = pathElement.value.getPointAtLength(position)
    dotPosition.value = { x, y }
  },
)

/**
 * The radius of the dot.
 */
const dotRadius: Ref<number> = ref(props.visible ? 3 : 0)

/**
 * Watch for changes to the visible prop and animate the glow and dot radius.
 */
watch(
  () => props.visible,
  (visible) => {
    gsap.to(gradientWidthScaleFactor, {
      duration: 0.5,
      ease: 'power2.inOut',
      value: visible ? 1 : 0,
    })
    gsap.to(dotRadius, {
      duration: 0.6,
      ease: 'power2.inOut',
      value: visible ? 3 : 0,
    })
  },
)
</script>

<template>
  <g>
    <path
      ref="pathElement"
      :d="props.path"
      :stroke="`url(#glow_gradient_${pathId})`"
      stroke-width="1.2"
      :mask="`url(#glow_mask_${pathId})`"
      class="svg-path"
    />
    <circle
      v-if="props.dotColor"
      :cx="dotPosition.x"
      :cy="dotPosition.y"
      :r="dotRadius"
      :fill="props.dotColor ? props.dotColor : 'transparent'"
      class="circle-dot"
      :style="`--dot-color: ${props.dotColor}`"
      key="circle-dot"
    />
    <text
      v-if="props.label"
      :x="dotPosition.x"
      :y="dotPosition.y + 15"
      fill="#a3a3a3"
      font-family="Inter, sans-serif"
      font-size="11px"
      font-style="normal"
      font-weight="400"
      text-anchor="middle"
      alignment-baseline="hanging"
      class="label"
      :class="{ 'label--visible': props.labelVisible }"
    >
      {{ props.label }}
    </text>
    <defs>
      <mask :id="`glow_mask_${pathId}`">
        <path :d="props.path" fill="black" />
        <circle
          :cx="dotPosition.x"
          :cy="dotPosition.y"
          :r="gradientWidth * gradientWidthScaleFactor"
          fill="white"
        />
      </mask>
      <radialGradient
        :id="`glow_gradient_${pathId}`"
        :cx="dotPosition.x"
        :cy="dotPosition.y"
        :r="gradientWidth * gradientWidthScaleFactor"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0%" :stop-color="props.glowColor" :stop-opacity="1" />
        <stop offset="100%" :stop-color="props.glowColor" stop-opacity="0" />
      </radialGradient>
    </defs>
  </g>
</template>

<style scoped>
.svg-path {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
}

.label {
  opacity: 0;
  transition: opacity 0.4s ease-in-out;
  display: none;
  will-change: opacity;

  @media (min-width: 1180px) {
    display: block;
  }

  &.label--visible {
    opacity: 1;
  }
}

.circle-dot {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  --dot-color: white;

  @media (min-width: 768px) {
    filter: drop-shadow(0 0 3px var(--dot-color));
  }
}
</style>



================================================
FILE: docs/.vitepress/theme/composables/sponsor.ts
================================================
import { onMounted, onUnmounted, ref } from 'vue'
import voidZeroSvg from './images/voidzero.svg'
import boltSvg from './images/bolt.svg'
import nuxtLabsSvg from './images/nuxtlabs.svg'

interface Sponsors {
  special: Sponsor[]
  platinum: Sponsor[]
  platinum_china: Sponsor[]
  gold: Sponsor[]
  silver: Sponsor[]
  bronze: Sponsor[]
}

interface Sponsor {
  name: string
  img: string
  url: string
  /**
   * Expects to also have an **inversed** image with `-dark` postfix.
   */
  hasDark?: true
}

// shared data across instances so we load only once.
const data = ref<{ tier: string; size: string; items: Sponsor[] }[]>()

const dataHost = 'https://sponsors.vuejs.org'
const dataUrl = `${dataHost}/vite.json`

export const voidZero = {
  name: 'VoidZero',
  url: 'https://voidzero.dev',
  img: voidZeroSvg,
} satisfies Sponsor

const viteSponsors: Pick<Sponsors, 'special' | 'gold'> = {
  special: [
    // sponsors patak-dev
    {
      name: 'Bolt',
      url: 'https://bolt.new',
      img: boltSvg,
    },
    // sponsors antfu
    {
      name: 'NuxtLabs',
      url: 'https://nuxtlabs.com',
      img: nuxtLabsSvg,
    },
  ],
  gold: [
    // now automated via sponsors.vuejs.org too
  ],
}

function toggleDarkLogos() {
  if (data.value) {
    const isDark = document.documentElement.classList.contains('dark')
    data.value.forEach(({ items }) => {
      items.forEach((s: Sponsor) => {
        if (s.hasDark) {
          s.img = isDark
            ? s.img.replace(/(\.\w+)$/, '-dark$1')
            : s.img.replace(/-dark(\.\w+)$/, '$1')
        }
      })
    })
  }
}

export function useSponsor() {
  onMounted(async () => {
    const ob = new MutationObserver((list) => {
      for (const m of list) {
        if (m.attributeName === 'class') {
          toggleDarkLogos()
        }
      }
    })
    ob.observe(document.documentElement, { attributes: true })
    onUnmounted(() => {
      ob.disconnect()
    })

    if (data.value) {
      return
    }

    const result = await fetch(dataUrl)
    const json = await result.json()

    data.value = mapSponsors(json)
    toggleDarkLogos()
  })

  return {
    data,
  }
}

function mapSponsors(sponsors: Sponsors) {
  return [
    {
      tier: 'in partnership with',
      size: 'big',
      items: viteSponsors['special'],
    },
    {
      tier: 'Platinum Sponsors',
      size: 'big',
      items: mapImgPath(sponsors['platinum']),
    },
    {
      tier: 'Gold Sponsors',
      size: 'medium',
      items: [...mapImgPath(sponsors['gold']), ...viteSponsors['gold']],
    },
  ]
}

const viteSponsorNames = new Set(
  Object.values(viteSponsors).flatMap((sponsors) =>
    sponsors.map((s) => s.name),
  ),
)

/**
 * Map Vue/Vite sponsors data to objects and filter out Vite-specific sponsors
 */
function mapImgPath(sponsors: Sponsor[]) {
  return sponsors
    .filter((sponsor) => !viteSponsorNames.has(sponsor.name))
    .map((sponsor) => ({
      ...sponsor,
      img: `${dataHost}/images/${sponsor.img}`,
    }))
}



================================================
FILE: docs/.vitepress/theme/composables/useCardAnimation.ts
================================================
import { type Ref, onMounted, onUnmounted, ref } from 'vue'
import { gsap } from 'gsap'
import { ScrollTrigger } from 'gsap/dist/ScrollTrigger'

gsap.registerPlugin(ScrollTrigger)

/**
 * A custom hook for animating a card element.
 *
 * @param {HTMLElement | string} el - The element or selector for the element to be animated
 * @param {() => GSAPTimeline} animation - A function that returns a GSAP timeline for the animation
 * @param {object} options - Options for the animation
 */
export function useCardAnimation(
  el: HTMLElement | string,
  animation: (() => GSAPTimeline) | undefined = undefined,
  options?: {
    /**
     * A flag to indicate whether the animation should only run once, and not reset once complete.
     */
    once?: boolean
  },
) {
  /**
   * The GSAP timeline for this animation.
   */
  let timeline: GSAPTimeline | null

  /**
   * A flag to indicate whether the card is currently active or not.
   * May be inactive while the animation is still finishing up, due to CSS transitions.
   */
  const isCardActive: Ref<boolean> = ref(false)

  /**
   * An internal flag to prevent multiple animations from running at the same time.
   */
  const isAnimationRunning: Ref<boolean> = ref(false)

  /**
   * Starts the card's animation, managing the lifecycle internally to prevent multiple animations from running at the same time.
   */
  const startAnimation = () => {
    if (isAnimationRunning.value) {
      return
    } else {
      isAnimationRunning.value = true
      isCardActive.value = true
    }
    if (timeline) {
      timeline.kill()
    }
    if (!animation) {
      return
    }
    timeline = gsap.timeline({
      onComplete: () => {
        if (!options?.once) {
          isCardActive.value = false
          setTimeout(() => {
            isAnimationRunning.value = false
          }, 3000)
        }
      },
    })
    timeline.add(animation())
  }

  /**
   * The ScrollTrigger instance for this card.
   */
  let scrollTriggerInstance: ScrollTrigger | null = null

  /**
   * Trigger's the card's animation automatically on mobile devices (no hover method)
   */
  onMounted(() => {
    if (window.innerWidth < 768) {
      scrollTriggerInstance = ScrollTrigger.create({
        trigger: el,
        start: 'top 60%',
        onEnter: () => {
          startAnimation()
        },
      })
    }
  })

  /**
   * Remove the ScrollTrigger and GSAP timeline instances when the component is unmounted
   */
  onUnmounted(() => {
    if (scrollTriggerInstance) {
      scrollTriggerInstance.kill()
      scrollTriggerInstance = null
    }
    if (timeline) {
      timeline.kill()
      timeline = null
    }
  })

  return {
    startAnimation,
    isCardActive,
  }
}



================================================
FILE: docs/.vitepress/theme/composables/useSlideIn.ts
================================================
import { nextTick, onMounted } from 'vue'
import { gsap } from 'gsap'

export function useSlideIn(el: HTMLElement | string) {
  onMounted(async () => {
    await nextTick(() => {
      gsap.to(el, {
        x: 0,
        duration: 1,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: el,
          start: 'top 100%',
          once: true,
        },
      })
    })
  })
}



================================================
FILE: docs/.vitepress/theme/styles/landing.css
================================================
/* /////////////////////// */
/* Landing Page CSS Styles */
/* /////////////////////// */

html:has(.landing) {
  --vp-c-bg: #101010;
  background-color: #101010;
}

.landing {
  overflow-x: hidden;

  * {
    -webkit-font-smoothing: antialiased !important;
    -moz-osx-font-smoothing: grayscale !important;
    text-rendering: optimizeLegibility !important;
  }

  /* /////////////////// */
  /* VitePress Overrides */
  /* /////////////////// */

  .VPNavBar,
  .VPNavBar:not(.top) {
    background: transparent !important;

    @media (min-width: 768px) {
      backdrop-filter: blur(10px);
      background: rgba(15, 15, 15, 0.8) !important;
      border-bottom: 1px solid #262626 !important;
    }

    .content-body {
      background: none !important;
      transition: none;
    }
  }

  .VPNavBar *:not(.wrapper *) {
    transition: none;
  }

  .VPFooter {
    border-top: 1px solid #262626 !important;
    background: radial-gradient(circle at top center, #0f151a 30%, #000000 80%);
  }

  .VPHome {
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
  }

  /* /////////////// */
  /* Force Dark Mode */
  /* /////////////// */

  .VPNavBarAppearance {
    display: none;
  }

  .VPMenu .translations + .group {
    display: none;
  }

  .VPNavScreenAppearance {
    visibility: hidden;
  }

  .social-links::before {
    margin-left: 0 !important;
  }

  /* ////////// */
  /* Typography */
  /* ////////// */

  h1 {
    text-align: center;
    font-family: 'Manrope', sans-serif;
    font-style: normal;
    font-weight: 600;
    background: linear-gradient(
      180deg,
      #fff 0%,
      rgba(255, 255, 255, 0.31) 100%
    );
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-wrap: balance;
    cursor: default;
    font-size: 44px;
    line-height: 120%;
    letter-spacing: -0.88px;
    padding: 0 20px;
    margin-bottom: 15px;

    @media (min-width: 768px) {
      font-size: 64px;
      line-height: 81px;
      letter-spacing: -1.28px;
    }

    @media (min-width: 1025px) {
      font-size: 72px;
      letter-spacing: -1.44px;
      padding-bottom: 8px; /* Fix for hanging descender on "g" in "tooling" */
    }
  }

  h2 {
    display: block;
    width: fit-content;
    font-family: Manrope, sans-serif;
    font-size: 32px;
    font-style: normal;
    font-weight: 600;
    line-height: 120%;
    letter-spacing: -0.64px;
    cursor: default;
    text-wrap: balance;
    padding: 0 20px;

    @media (min-width: 768px) {
      font-size: 44px;
      letter-spacing: -0.88px;
    }
  }

  h3 {
    color: #a9a9a9;
    text-align: center;
    font-family: Inter, sans-serif;
    font-size: 20px;
    font-style: normal;
    font-weight: 400;
    line-height: 150%;
    letter-spacing: -0.4px;
    max-width: 500px;
    text-wrap: balance;
    cursor: default;
    margin-bottom: 25px;
    padding: 0 20px;
  }

  /* /////// */
  /* Buttons */
  /* /////// */

  .btn {
    display: flex;
    padding: 10px 18px;
    justify-content: center;
    align-items: center;
    gap: 8px;
    border-radius: 8px;
    color: #fff;
    font-family: Inter, sans-serif;
    font-size: 16px;
    font-style: normal;
    font-weight: 500;
    line-height: 24px;
    text-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease-in-out;
    width: fit-content;

    &:hover {
      transform: translate3d(0, -2px, 0);
    }

    &.btn--primary {
      position: relative;
      background:
        radial-gradient(
          141.42% 141.42% at 100% 0%,
          rgba(255, 255, 255, 0.4) 0%,
          rgba(255, 255, 255, 0) 100%
        ),
        radial-gradient(
          140.35% 140.35% at 100% 94.74%,
          #bd34fe 0%,
          rgba(189, 52, 254, 0) 100%
        ),
        radial-gradient(
          89.94% 89.94% at 18.42% 15.79%,
          #41d1ff 0%,
          rgba(65, 209, 255, 0) 100%
        );
      box-shadow: 0 1px 0 0 rgba(255, 255, 255, 0.75) inset;

      &:hover {
        background:
          radial-gradient(
            141.42% 141.42% at 100% 0%,
            rgba(255, 255, 255, 0.5) 0%,
            rgba(255, 255, 255, 0) 100%
          ),
          radial-gradient(
            140.35% 140.35% at 100% 94.74%,
            #bd34fe 0%,
            rgba(189, 52, 254, 0) 100%
          ),
          radial-gradient(
            89.94% 89.94% at 18.42% 15.79%,
            #41d1ff 0%,
            rgba(65, 209, 255, 0) 100%
          );
        box-shadow: 0 1.5px 0 0 rgba(255, 255, 255, 0.8) inset;
      }
    }

    &.btn--outline {
      border: 1px solid rgba(255, 255, 255, 0.2);

      &:hover {
        border: 1px solid rgba(255, 255, 255, 0.4);
      }
    }

    &.btn--rounded {
      border-radius: 100px;
    }
  }
}



================================================
FILE: docs/.vitepress/theme/styles/vars.css
================================================
/**
 * Colors
 * -------------------------------------------------------------------------- */

:root {
  --vp-c-brand: #646cff;
  --vp-c-brand-light: #747bff;
  --vp-c-brand-lighter: #9499ff;
  --vp-c-brand-lightest: #bcc0ff;
  --vp-c-brand-dark: #535bf2;
  --vp-c-brand-darker: #454ce1;
  --vp-c-brand-dimm: rgba(100, 108, 255, 0.08);
}

/**
 * Component: Button
 * -------------------------------------------------------------------------- */

:root {
  --vp-button-brand-border: var(--vp-c-brand-light);
  --vp-button-brand-text: var(--vp-c-white);
  --vp-button-brand-bg: var(--vp-c-brand);
  --vp-button-brand-hover-border: var(--vp-c-brand-light);
  --vp-button-brand-hover-text: var(--vp-c-white);
  --vp-button-brand-hover-bg: var(--vp-c-brand-light);
  --vp-button-brand-active-border: var(--vp-c-brand-light);
  --vp-button-brand-active-text: var(--vp-c-white);
  --vp-button-brand-active-bg: var(--vp-button-brand-bg);
}

/**
 * Component: Custom Block
 * -------------------------------------------------------------------------- */

:root {
  --vp-custom-block-tip-border: var(--vp-c-brand);
  --vp-custom-block-tip-text: var(--vp-c-brand-darker);
  --vp-custom-block-tip-bg: var(--vp-c-brand-dimm);
}

.dark {
  --vp-custom-block-tip-border: var(--vp-c-brand);
  --vp-custom-block-tip-text: var(--vp-c-brand-lightest);
  --vp-custom-block-tip-bg: var(--vp-c-brand-dimm);
}

/**
 * Component: Algolia
 * -------------------------------------------------------------------------- */

.DocSearch {
  --docsearch-primary-color: var(--vp-c-brand) !important;
  --docsearch-container-background: rgba(0, 0, 0, 0.7);
}

/**
 * VitePress: Custom fix
 * -------------------------------------------------------------------------- */

/*
  Use lighter colors for links in dark mode for a11y.
  Also specify some classes twice to have higher specificity
  over scoped class data attribute.
*/
.dark .vp-doc a,
.dark .vp-doc a > code,
.dark .VPNavBarMenuLink.VPNavBarMenuLink:hover,
.dark .VPNavBarMenuLink.VPNavBarMenuLink.active,
.dark .link.link:hover,
.dark .link.link.active,
.dark .edit-link-button.edit-link-button,
.dark .pager-link .title {
  color: var(--vp-c-brand-lighter);
}

.dark .vp-doc a:hover,
.dark .vp-doc a > code:hover {
  color: var(--vp-c-brand-lightest);
  opacity: 1;
}

/* Transition by color instead of opacity */
.dark .vp-doc .custom-block a {
  transition: color 0.25s;
}

.vp-sponsor.aside .vp-sponsor-grid.mini .vp-sponsor-grid-image {
  max-width: 124px;
}

.vp-sponsor-grid.big .vp-sponsor-grid-image {
  max-height: 56px;
}

.vp-sponsor-grid.mini .vp-sponsor-grid-image[alt='Bit'] {
  max-height: 48px;
}

.vp-sponsor-grid.xmini .vp-sponsor-grid-image[alt='JetBrains'] {
  max-height: 54px;
}

.vp-sponsor-grid.medium .vp-sponsor-grid-image[alt='JetBrains'] {
  max-height: 100px;
}



================================================
FILE: packages/create-vite/README.md
================================================
# create-vite <a href="https://npmjs.com/package/create-vite"><img src="https://img.shields.io/npm/v/create-vite" alt="npm package"></a>

## Scaffolding Your First Vite Project

> **Compatibility Note:**
> Vite requires [Node.js](https://nodejs.org/en/) version 20.19+, 22.12+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.

With NPM:

```bash
npm create vite@latest
```

With Yarn:

```bash
yarn create vite
```

With PNPM:

```bash
pnpm create vite
```

With Bun:

```bash
bun create vite
```

Then follow the prompts!

You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:

```bash
# npm 7+, extra double-dash is needed:
npm create vite@latest my-vue-app -- --template vue

# yarn
yarn create vite my-vue-app --template vue

# pnpm
pnpm create vite my-vue-app --template vue

# Bun
bun create vite my-vue-app --template vue
```

Currently supported template presets include:

- `vanilla`
- `vanilla-ts`
- `vue`
- `vue-ts`
- `react`
- `react-ts`
- `react-swc`
- `react-swc-ts`
- `preact`
- `preact-ts`
- `lit`
- `lit-ts`
- `svelte`
- `svelte-ts`
- `solid`
- `solid-ts`
- `qwik`
- `qwik-ts`

You can use `.` for the project name to scaffold in the current directory.

## Community Templates

create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks. You can use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates.

```bash
npx degit user/project my-project
cd my-project

npm install
npm run dev
```

If the project uses `main` as the default branch, suffix the project repo with `#main`

```bash
npx degit user/project#main my-project
```



================================================
FILE: packages/create-vite/index.js
================================================
#!/usr/bin/env node

import './dist/index.js'



================================================
FILE: packages/create-vite/LICENSE
================================================
# create-vite license
create-vite is released under the MIT license:

MIT License

Copyright (c) 2019-present, VoidZero Inc. and Vite contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

# License of the files in the directories starting with "template-" in create-vite
The files in the directories starting with "template-" in create-vite and files
generated from those files are licensed under the CC0 1.0 Universal license:

CC0 1.0 Universal

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator and
subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for the
purpose of contributing to a commons of creative, cultural and scientific
works ("Commons") that the public can reliably and without fear of later
claims of infringement build upon, modify, incorporate in other works, reuse
and redistribute as freely as possible in any form whatsoever and for any
purposes, including without limitation commercial purposes. These owners may
contribute to the Commons to promote the ideal of a free culture and the
further production of creative, cultural and scientific works, or to gain
reputation or greater distribution for their Work in part through the use and
efforts of others.

For these and/or other purposes and motivations, and without any expectation
of additional consideration or compensation, the person associating CC0 with a
Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
and Related Rights in the Work, voluntarily elects to apply CC0 to the Work
and publicly distribute the Work under its terms, with knowledge of his or her
Copyright and Related Rights in the Work and the meaning and intended legal
effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not limited
to, the following:

  i. the right to reproduce, adapt, distribute, perform, display, communicate,
  and translate a Work;

  ii. moral rights retained by the original author(s) and/or performer(s);

  iii. publicity and privacy rights pertaining to a person's image or likeness
  depicted in a Work;

  iv. rights protecting against unfair competition in regards to a Work,
  subject to the limitations in paragraph 4(a), below;

  v. rights protecting the extraction, dissemination, use and reuse of data in
  a Work;

  vi. database rights (such as those arising under Directive 96/9/EC of the
  European Parliament and of the Council of 11 March 1996 on the legal
  protection of databases, and under any national implementation thereof,
  including any amended or successor version of such directive); and

  vii. other similar, equivalent or corresponding rights throughout the world
  based on applicable law or treaty, and any national implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention of,
applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
and Related Rights and associated claims and causes of action, whether now
known or unknown (including existing as well as future claims and causes of
action), in the Work (i) in all territories worldwide, (ii) for the maximum
duration provided by applicable law or treaty (including future time
extensions), (iii) in any current or future medium and for any number of
copies, and (iv) for any purpose whatsoever, including without limitation
commercial, advertising or promotional purposes (the "Waiver"). Affirmer makes
the Waiver for the benefit of each member of the public at large and to the
detriment of Affirmer's heirs and successors, fully intending that such Waiver
shall not be subject to revocation, rescission, cancellation, termination, or
any other legal or equitable action to disrupt the quiet enjoyment of the Work
by the public as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason be
judged legally invalid or ineffective under applicable law, then the Waiver
shall be preserved to the maximum extent permitted taking into account
Affirmer's express Statement of Purpose. In addition, to the extent the Waiver
is so judged Affirmer hereby grants to each affected person a royalty-free,
non transferable, non sublicensable, non exclusive, irrevocable and
unconditional license to exercise Affirmer's Copyright and Related Rights in
the Work (i) in all territories worldwide, (ii) for the maximum duration
provided by applicable law or treaty (including future time extensions), (iii)
in any current or future medium and for any number of copies, and (iv) for any
purpose whatsoever, including without limitation commercial, advertising or
promotional purposes (the "License"). The License shall be deemed effective as
of the date CC0 was applied by Affirmer to the Work. Should any part of the
License for any reason be judged legally invalid or ineffective under
applicable law, such partial invalidity or ineffectiveness shall not
invalidate the remainder of the License, and in such case Affirmer hereby
affirms that he or she will not (i) exercise any of his or her remaining
Copyright and Related Rights in the Work or (ii) assert any associated claims
and causes of action with respect to the Work, in either case contrary to
Affirmer's express Statement of Purpose.

4. Limitations and Disclaimers.

  a. No trademark or patent rights held by Affirmer are waived, abandoned,
  surrendered, licensed or otherwise affected by this document.

  b. Affirmer offers the Work as-is and makes no representations or warranties
  of any kind concerning the Work, express, implied, statutory or otherwise,
  including without limitation warranties of title, merchantability, fitness
  for a particular purpose, non infringement, or the absence of latent or
  other defects, accuracy, or the present or absence of errors, whether or not
  discoverable, all to the greatest extent permissible under applicable law.

  c. Affirmer disclaims responsibility for clearing rights of other persons
  that may apply to the Work or any use thereof, including without limitation
  any person's Copyright and Related Rights in the Work. Further, Affirmer
  disclaims responsibility for obtaining any necessary consents, permissions
  or other rights required for any use of the Work.

  d. Affirmer understands and acknowledges that Creative Commons is not a
  party to this document and has no duty or obligation with respect to this
  CC0 or use of the Work.

For more information, please see
<http://creativecommons.org/publicdomain/zero/1.0/>

# Licenses of bundled dependencies
The published create-vite artifact additionally contains code with the following licenses:
ISC, MIT

# Bundled dependencies:
## @clack/core, @clack/prompts
License: MIT
By: Nate Moore
Repositories: git+https://github.com/bombshell-dev/clack.git, git+https://github.com/bombshell-dev/clack.git

> MIT License
> 
> Copyright (c) Nate Moore
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

---------------------------------------

## cross-spawn
License: MIT
By: André Cruz
Repository: git@github.com:moxystudio/node-cross-spawn.git

> The MIT License (MIT)
> 
> Copyright (c) 2018 Made With MOXY Lda <hello@moxy.studio>
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy
> of this software and associated documentation files (the "Software"), to deal
> in the Software without restriction, including without limitation the rights
> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
> copies of the Software, and to permit persons to whom the Software is
> furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in
> all copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
> AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
> LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
> OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
> THE SOFTWARE.

---------------------------------------

## isexe, which
License: ISC
By: Isaac Z. Schlueter
Repositories: git+https://github.com/isaacs/isexe.git, git://github.com/isaacs/node-which.git

> The ISC License
> 
> Copyright (c) Isaac Z. Schlueter and Contributors
> 
> Permission to use, copy, modify, and/or distribute this software for any
> purpose with or without fee is hereby granted, provided that the above
> copyright notice and this permission notice appear in all copies.
> 
> THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
> WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
> MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
> ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
> WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
> ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
> IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

---------------------------------------

## mri
License: MIT
By: Luke Edwards
Repository: lukeed/mri

> The MIT License (MIT)
> 
> Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy
> of this software and associated documentation files (the "Software"), to deal
> in the Software without restriction, including without limitation the rights
> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
> copies of the Software, and to permit persons to whom the Software is
> furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in
> all copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
> AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
> LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
> OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
> THE SOFTWARE.

---------------------------------------

## path-key, shebang-regex
License: MIT
By: Sindre Sorhus
Repositories: sindresorhus/path-key, sindresorhus/shebang-regex

> MIT License
> 
> Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

---------------------------------------

## picocolors
License: ISC
By: Alexey Raspopov
Repository: alexeyraspopov/picocolors

> ISC License
> 
> Copyright (c) 2021-2024 Oleksii Raspopov, Kostiantyn Denysov, Anton Verinov
> 
> Permission to use, copy, modify, and/or distribute this software for any
> purpose with or without fee is hereby granted, provided that the above
> copyright notice and this permission notice appear in all copies.
> 
> THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
> WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
> MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
> ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
> WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
> ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
> OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

---------------------------------------

## shebang-command
License: MIT
By: Kevin Mårtensson
Repository: kevva/shebang-command

> MIT License
> 
> Copyright (c) Kevin Mårtensson <kevinmartensson@gmail.com> (github.com/kevva)
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

---------------------------------------

## sisteransi
License: MIT
By: Terkel Gjervig
Repository: https://github.com/terkelg/sisteransi

> MIT License
> 
> Copyright (c) 2018 Terkel Gjervig Nielsen
> 
> Permission is hereby granted, free of charge, to any person obtaining a copy
> of this software and associated documentation files (the "Software"), to deal
> in the Software without restriction, including without limitation the rights
> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
> copies of the Software, and to permit persons to whom the Software is
> furnished to do so, subject to the following conditions:
> 
> The above copyright notice and this permission notice shall be included in all
> copies or substantial portions of the Software.
> 
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
> AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
> LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
> OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
> SOFTWARE.



================================================
FILE: packages/create-vite/package.json
================================================
{
  "name": "create-vite",
  "version": "7.1.1",
  "type": "module",
  "license": "MIT",
  "author": "Evan You",
  "bin": {
    "create-vite": "index.js",
    "cva": "index.js"
  },
  "files": [
    "index.js",
    "template-*",
    "dist"
  ],
  "scripts": {
    "dev": "tsdown --watch",
    "build": "tsdown",
    "typecheck": "tsc",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git",
    "directory": "packages/create-vite"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite/issues"
  },
  "homepage": "https://github.com/vitejs/vite/tree/main/packages/create-vite#readme",
  "funding": "https://github.com/vitejs/vite?sponsor=1",
  "devDependencies": {
    "@clack/prompts": "^0.11.0",
    "cross-spawn": "^7.0.6",
    "mri": "^1.2.0",
    "picocolors": "^1.1.1",
    "tsdown": "^0.14.0"
  }
}



================================================
FILE: packages/create-vite/tsconfig.json
================================================
{
  "include": ["tsdown.config.ts", "src", "__tests__"],
  "compilerOptions": {
    "outDir": "dist",
    "target": "ES2023",
    "module": "Preserve",
    "moduleResolution": "bundler",
    "types": [],
    "allowImportingTsExtensions": true,
    "strict": true,
    "skipLibCheck": true,
    "noUnusedLocals": true,
    "esModuleInterop": true,
    "noEmit": true
  }
}



================================================
FILE: packages/create-vite/tsdown.config.ts
================================================
import path from 'node:path'
import url from 'node:url'
import { defineConfig } from 'tsdown'
import licensePlugin from '../vite/rollupLicensePlugin.ts'

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

export default defineConfig(() => ({
  entry: ['src/index.ts'],
  target: 'node20',
  minify: true,
  plugins: [
    licensePlugin(
      path.resolve(__dirname, './LICENSE'),
      'create-vite license',
      'create-vite',
      '# License of the files in the directories starting with "template-" in create-vite\n' +
        'The files in the directories starting with "template-" in create-vite and files\n' +
        'generated from those files are licensed under the CC0 1.0 Universal license:\n\n' +
        cc0LicenseText +
        '\n\n',
    ),
  ],
}))

const cc0LicenseText = `
CC0 1.0 Universal

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator and
subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for the
purpose of contributing to a commons of creative, cultural and scientific
works ("Commons") that the public can reliably and without fear of later
claims of infringement build upon, modify, incorporate in other works, reuse
and redistribute as freely as possible in any form whatsoever and for any
purposes, including without limitation commercial purposes. These owners may
contribute to the Commons to promote the ideal of a free culture and the
further production of creative, cultural and scientific works, or to gain
reputation or greater distribution for their Work in part through the use and
efforts of others.

For these and/or other purposes and motivations, and without any expectation
of additional consideration or compensation, the person associating CC0 with a
Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
and Related Rights in the Work, voluntarily elects to apply CC0 to the Work
and publicly distribute the Work under its terms, with knowledge of his or her
Copyright and Related Rights in the Work and the meaning and intended legal
effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not limited
to, the following:

  i. the right to reproduce, adapt, distribute, perform, display, communicate,
  and translate a Work;

  ii. moral rights retained by the original author(s) and/or performer(s);

  iii. publicity and privacy rights pertaining to a person's image or likeness
  depicted in a Work;

  iv. rights protecting against unfair competition in regards to a Work,
  subject to the limitations in paragraph 4(a), below;

  v. rights protecting the extraction, dissemination, use and reuse of data in
  a Work;

  vi. database rights (such as those arising under Directive 96/9/EC of the
  European Parliament and of the Council of 11 March 1996 on the legal
  protection of databases, and under any national implementation thereof,
  including any amended or successor version of such directive); and

  vii. other similar, equivalent or corresponding rights throughout the world
  based on applicable law or treaty, and any national implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention of,
applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
and Related Rights and associated claims and causes of action, whether now
known or unknown (including existing as well as future claims and causes of
action), in the Work (i) in all territories worldwide, (ii) for the maximum
duration provided by applicable law or treaty (including future time
extensions), (iii) in any current or future medium and for any number of
copies, and (iv) for any purpose whatsoever, including without limitation
commercial, advertising or promotional purposes (the "Waiver"). Affirmer makes
the Waiver for the benefit of each member of the public at large and to the
detriment of Affirmer's heirs and successors, fully intending that such Waiver
shall not be subject to revocation, rescission, cancellation, termination, or
any other legal or equitable action to disrupt the quiet enjoyment of the Work
by the public as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason be
judged legally invalid or ineffective under applicable law, then the Waiver
shall be preserved to the maximum extent permitted taking into account
Affirmer's express Statement of Purpose. In addition, to the extent the Waiver
is so judged Affirmer hereby grants to each affected person a royalty-free,
non transferable, non sublicensable, non exclusive, irrevocable and
unconditional license to exercise Affirmer's Copyright and Related Rights in
the Work (i) in all territories worldwide, (ii) for the maximum duration
provided by applicable law or treaty (including future time extensions), (iii)
in any current or future medium and for any number of copies, and (iv) for any
purpose whatsoever, including without limitation commercial, advertising or
promotional purposes (the "License"). The License shall be deemed effective as
of the date CC0 was applied by Affirmer to the Work. Should any part of the
License for any reason be judged legally invalid or ineffective under
applicable law, such partial invalidity or ineffectiveness shall not
invalidate the remainder of the License, and in such case Affirmer hereby
affirms that he or she will not (i) exercise any of his or her remaining
Copyright and Related Rights in the Work or (ii) assert any associated claims
and causes of action with respect to the Work, in either case contrary to
Affirmer's express Statement of Purpose.

4. Limitations and Disclaimers.

  a. No trademark or patent rights held by Affirmer are waived, abandoned,
  surrendered, licensed or otherwise affected by this document.

  b. Affirmer offers the Work as-is and makes no representations or warranties
  of any kind concerning the Work, express, implied, statutory or otherwise,
  including without limitation warranties of title, merchantability, fitness
  for a particular purpose, non infringement, or the absence of latent or
  other defects, accuracy, or the present or absence of errors, whether or not
  discoverable, all to the greatest extent permissible under applicable law.

  c. Affirmer disclaims responsibility for clearing rights of other persons
  that may apply to the Work or any use thereof, including without limitation
  any person's Copyright and Related Rights in the Work. Further, Affirmer
  disclaims responsibility for obtaining any necessary consents, permissions
  or other rights required for any use of the Work.

  d. Affirmer understands and acknowledges that Creative Commons is not a
  party to this document and has no duty or obligation with respect to this
  CC0 or use of the Work.

For more information, please see
<http://creativecommons.org/publicdomain/zero/1.0/>
`.trim()



================================================
FILE: packages/create-vite/__tests__/cli.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import type { SyncOptions, SyncResult } from 'execa'
import { execaCommandSync } from 'execa'
import { afterEach, beforeAll, expect, test } from 'vitest'

const CLI_PATH = path.join(__dirname, '..')

const projectName = 'test-app'
const genPath = path.join(__dirname, projectName)
const genPathWithSubfolder = path.join(__dirname, 'subfolder', projectName)

const run = <SO extends SyncOptions>(
  args: string[],
  options?: SO,
): SyncResult<SO> => {
  return execaCommandSync(`node ${CLI_PATH} ${args.join(' ')}`, options)
}

// Helper to create a non-empty directory
const createNonEmptyDir = (overrideFolder?: string) => {
  // Create the temporary directory
  const newNonEmptyFolder = overrideFolder || genPath
  fs.mkdirSync(newNonEmptyFolder, { recursive: true })

  // Create a package.json file
  const pkgJson = path.join(newNonEmptyFolder, 'package.json')
  fs.writeFileSync(pkgJson, '{ "foo": "bar" }')
}

// Vue 3 starter template
const templateFiles = fs
  .readdirSync(path.join(CLI_PATH, 'template-vue'))
  // _gitignore is renamed to .gitignore
  .map((filePath) => (filePath === '_gitignore' ? '.gitignore' : filePath))
  .sort()

// React starter template
const templateFilesReact = fs
  .readdirSync(path.join(CLI_PATH, 'template-react'))
  // _gitignore is renamed to .gitignore
  .map((filePath) => (filePath === '_gitignore' ? '.gitignore' : filePath))
  .sort()

const clearAnyPreviousFolders = () => {
  if (fs.existsSync(genPath)) {
    fs.rmSync(genPath, { recursive: true, force: true })
  }
  if (fs.existsSync(genPathWithSubfolder)) {
    fs.rmSync(genPathWithSubfolder, { recursive: true, force: true })
  }
}

beforeAll(() => clearAnyPreviousFolders())
afterEach(() => clearAnyPreviousFolders())

test('prompts for the project name if none supplied', () => {
  const { stdout } = run([])
  expect(stdout).toContain('Project name:')
})

test('prompts for the framework if none supplied when target dir is current directory', () => {
  fs.mkdirSync(genPath, { recursive: true })
  const { stdout } = run(['.'], { cwd: genPath })
  expect(stdout).toContain('Select a framework:')
})

test('prompts for the framework if none supplied', () => {
  const { stdout } = run([projectName])
  expect(stdout).toContain('Select a framework:')
})

test('prompts for the framework on not supplying a value for --template', () => {
  const { stdout } = run([projectName, '--template'])
  expect(stdout).toContain('Select a framework:')
})

test('prompts for the framework on supplying an invalid template', () => {
  const { stdout } = run([projectName, '--template', 'unknown'])
  expect(stdout).toContain(
    `"unknown" isn't a valid template. Please choose from below:`,
  )
})

test('asks to overwrite non-empty target directory', () => {
  createNonEmptyDir()
  const { stdout } = run([projectName], { cwd: __dirname })
  expect(stdout).toContain(`Target directory "${projectName}" is not empty.`)
})

test('asks to overwrite non-empty target directory with subfolder', () => {
  createNonEmptyDir(genPathWithSubfolder)
  const { stdout } = run([`subfolder/${projectName}`], { cwd: __dirname })
  expect(stdout).toContain(
    `Target directory "subfolder/${projectName}" is not empty.`,
  )
})

test('asks to overwrite non-empty current directory', () => {
  createNonEmptyDir()
  const { stdout } = run(['.'], { cwd: genPath })
  expect(stdout).toContain(`Current directory is not empty.`)
})

test('successfully scaffolds a project based on vue starter template', () => {
  const { stdout } = run([projectName, '--template', 'vue'], {
    cwd: __dirname,
  })
  const generatedFiles = fs.readdirSync(genPath).sort()

  // Assertions
  expect(stdout).toContain(`Scaffolding project in ${genPath}`)
  expect(templateFiles).toEqual(generatedFiles)
})

test('successfully scaffolds a project with subfolder based on react starter template', () => {
  const { stdout } = run([`subfolder/${projectName}`, '--template', 'react'], {
    cwd: __dirname,
  })
  const generatedFiles = fs.readdirSync(genPathWithSubfolder).sort()

  // Assertions
  expect(stdout).toContain(`Scaffolding project in ${genPathWithSubfolder}`)
  expect(templateFilesReact).toEqual(generatedFiles)
})

test('works with the -t alias', () => {
  const { stdout } = run([projectName, '-t', 'vue'], {
    cwd: __dirname,
  })
  const generatedFiles = fs.readdirSync(genPath).sort()

  // Assertions
  expect(stdout).toContain(`Scaffolding project in ${genPath}`)
  expect(templateFiles).toEqual(generatedFiles)
})

test('accepts command line override for --overwrite', () => {
  createNonEmptyDir()
  const { stdout } = run(['.', '--overwrite', 'ignore'], { cwd: genPath })
  expect(stdout).not.toContain(`Current directory is not empty.`)
})

test('return help usage how to use create-vite', () => {
  const { stdout } = run(['--help'], { cwd: __dirname })
  const message = 'Usage: create-vite [OPTION]... [DIRECTORY]'
  expect(stdout).toContain(message)
})

test('return help usage how to use create-vite with -h alias', () => {
  const { stdout } = run(['--h'], { cwd: __dirname })
  const message = 'Usage: create-vite [OPTION]... [DIRECTORY]'
  expect(stdout).toContain(message)
})



================================================
FILE: packages/create-vite/src/index.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import spawn from 'cross-spawn'
import mri from 'mri'
import * as prompts from '@clack/prompts'
import colors from 'picocolors'

const {
  blue,
  blueBright,
  cyan,
  green,
  greenBright,
  magenta,
  red,
  redBright,
  reset,
  yellow,
} = colors

const argv = mri<{
  template?: string
  help?: boolean
  overwrite?: boolean
}>(process.argv.slice(2), {
  alias: { h: 'help', t: 'template' },
  boolean: ['help', 'overwrite'],
  string: ['template'],
})
const cwd = process.cwd()

// prettier-ignore
const helpMessage = `\
Usage: create-vite [OPTION]... [DIRECTORY]

Create a new Vite project in JavaScript or TypeScript.
With no arguments, start the CLI in interactive mode.

Options:
  -t, --template NAME        use a specific template

Available templates:
${yellow    ('vanilla-ts     vanilla'  )}
${green     ('vue-ts         vue'      )}
${cyan      ('react-ts       react'    )}
${cyan      ('react-swc-ts   react-swc')}
${magenta   ('preact-ts      preact'   )}
${redBright ('lit-ts         lit'      )}
${red       ('svelte-ts      svelte'   )}
${blue      ('solid-ts       solid'    )}
${blueBright('qwik-ts        qwik'     )}`

type ColorFunc = (str: string | number) => string
type Framework = {
  name: string
  display: string
  color: ColorFunc
  variants: FrameworkVariant[]
}
type FrameworkVariant = {
  name: string
  display: string
  color: ColorFunc
  customCommand?: string
}

const FRAMEWORKS: Framework[] = [
  {
    name: 'vanilla',
    display: 'Vanilla',
    color: yellow,
    variants: [
      {
        name: 'vanilla-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'vanilla',
        display: 'JavaScript',
        color: yellow,
      },
    ],
  },
  {
    name: 'vue',
    display: 'Vue',
    color: green,
    variants: [
      {
        name: 'vue-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'vue',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'custom-create-vue',
        display: 'Official Vue Starter ↗',
        color: green,
        customCommand: 'npm create vue@latest TARGET_DIR',
      },
      {
        name: 'custom-nuxt',
        display: 'Nuxt ↗',
        color: greenBright,
        customCommand: 'npm exec nuxi init TARGET_DIR',
      },
    ],
  },
  {
    name: 'react',
    display: 'React',
    color: cyan,
    variants: [
      {
        name: 'react-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'react-swc-ts',
        display: 'TypeScript + SWC',
        color: blue,
      },
      {
        name: 'react',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'react-swc',
        display: 'JavaScript + SWC',
        color: yellow,
      },
      {
        name: 'custom-react-router',
        display: 'React Router v7 ↗',
        color: cyan,
        customCommand: 'npm create react-router@latest TARGET_DIR',
      },
      {
        name: 'custom-tanstack-router',
        display: 'TanStack Router ↗',
        color: cyan,
        customCommand:
          'npm create -- tsrouter-app@latest TARGET_DIR --framework React --interactive',
      },
      {
        name: 'redwoodsdk-standard',
        display: 'RedwoodSDK ↗',
        color: red,
        customCommand:
          'npm exec degit redwoodjs/sdk/starters/standard TARGET_DIR',
      },
      {
        name: 'rsc',
        display: 'RSC ↗',
        color: magenta,
        customCommand:
          'npm exec degit vitejs/vite-plugin-react/packages/plugin-rsc/examples/starter TARGET_DIR',
      },
    ],
  },
  {
    name: 'preact',
    display: 'Preact',
    color: magenta,
    variants: [
      {
        name: 'preact-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'preact',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'custom-create-preact',
        display: 'Official Preact Starter ↗',
        color: magenta,
        customCommand: 'npm create preact@latest TARGET_DIR',
      },
    ],
  },
  {
    name: 'lit',
    display: 'Lit',
    color: redBright,
    variants: [
      {
        name: 'lit-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'lit',
        display: 'JavaScript',
        color: yellow,
      },
    ],
  },
  {
    name: 'svelte',
    display: 'Svelte',
    color: red,
    variants: [
      {
        name: 'svelte-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'svelte',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'custom-svelte-kit',
        display: 'SvelteKit ↗',
        color: red,
        customCommand: 'npm exec sv create TARGET_DIR',
      },
    ],
  },
  {
    name: 'solid',
    display: 'Solid',
    color: blue,
    variants: [
      {
        name: 'solid-ts',
        display: 'TypeScript',
        color: blue,
      },
      {
        name: 'solid',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'custom-tanstack-router',
        display: 'TanStack Router ↗',
        color: cyan,
        customCommand:
          'npm create -- tsrouter-app@latest TARGET_DIR --framework Solid --interactive',
      },
    ],
  },
  {
    name: 'qwik',
    display: 'Qwik',
    color: blueBright,
    variants: [
      {
        name: 'qwik-ts',
        display: 'TypeScript',
        color: blueBright,
      },
      {
        name: 'qwik',
        display: 'JavaScript',
        color: yellow,
      },
      {
        name: 'custom-qwik-city',
        display: 'QwikCity ↗',
        color: blueBright,
        customCommand: 'npm create qwik@latest basic TARGET_DIR',
      },
    ],
  },
  {
    name: 'angular',
    display: 'Angular',
    color: red,
    variants: [
      {
        name: 'custom-angular',
        display: 'Angular ↗',
        color: red,
        customCommand: 'npm exec @angular/cli@latest new TARGET_DIR',
      },
      {
        name: 'custom-analog',
        display: 'Analog ↗',
        color: yellow,
        customCommand: 'npm create analog@latest TARGET_DIR',
      },
    ],
  },
  {
    name: 'marko',
    display: 'Marko',
    color: magenta,
    variants: [
      {
        name: 'marko-run',
        display: 'Marko Run ↗',
        color: magenta,
        customCommand: 'npm create -- marko@latest --name TARGET_DIR',
      },
    ],
  },
  {
    name: 'others',
    display: 'Others',
    color: reset,
    variants: [
      {
        name: 'create-vite-extra',
        display: 'Extra Vite Starters ↗',
        color: reset,
        customCommand: 'npm create vite-extra@latest TARGET_DIR',
      },
      {
        name: 'create-electron-vite',
        display: 'Electron ↗',
        color: reset,
        customCommand: 'npm create electron-vite@latest TARGET_DIR',
      },
    ],
  },
]

const TEMPLATES = FRAMEWORKS.map((f) => f.variants.map((v) => v.name)).reduce(
  (a, b) => a.concat(b),
  [],
)

const renameFiles: Record<string, string | undefined> = {
  _gitignore: '.gitignore',
}

const defaultTargetDir = 'vite-project'

async function init() {
  const argTargetDir = argv._[0]
    ? formatTargetDir(String(argv._[0]))
    : undefined
  const argTemplate = argv.template
  const argOverwrite = argv.overwrite

  const help = argv.help
  if (help) {
    console.log(helpMessage)
    return
  }

  const pkgInfo = pkgFromUserAgent(process.env.npm_config_user_agent)
  const cancel = () => prompts.cancel('Operation cancelled')

  // 1. Get project name and target dir
  let targetDir = argTargetDir
  if (!targetDir) {
    const projectName = await prompts.text({
      message: 'Project name:',
      defaultValue: defaultTargetDir,
      placeholder: defaultTargetDir,
      validate: (value) => {
        return value.length === 0 || formatTargetDir(value).length > 0
          ? undefined
          : 'Invalid project name'
      },
    })
    if (prompts.isCancel(projectName)) return cancel()
    targetDir = formatTargetDir(projectName)
  }

  // 2. Handle directory if exist and not empty
  if (fs.existsSync(targetDir) && !isEmpty(targetDir)) {
    const overwrite = argOverwrite
      ? 'yes'
      : await prompts.select({
          message:
            (targetDir === '.'
              ? 'Current directory'
              : `Target directory "${targetDir}"`) +
            ` is not empty. Please choose how to proceed:`,
          options: [
            {
              label: 'Cancel operation',
              value: 'no',
            },
            {
              label: 'Remove existing files and continue',
              value: 'yes',
            },
            {
              label: 'Ignore files and continue',
              value: 'ignore',
            },
          ],
        })
    if (prompts.isCancel(overwrite)) return cancel()
    switch (overwrite) {
      case 'yes':
        emptyDir(targetDir)
        break
      case 'no':
        cancel()
        return
    }
  }

  // 3. Get package name
  let packageName = path.basename(path.resolve(targetDir))
  if (!isValidPackageName(packageName)) {
    const packageNameResult = await prompts.text({
      message: 'Package name:',
      defaultValue: toValidPackageName(packageName),
      placeholder: toValidPackageName(packageName),
      validate(dir) {
        if (!isValidPackageName(dir)) {
          return 'Invalid package.json name'
        }
      },
    })
    if (prompts.isCancel(packageNameResult)) return cancel()
    packageName = packageNameResult
  }

  // 4. Choose a framework and variant
  let template = argTemplate
  let hasInvalidArgTemplate = false
  if (argTemplate && !TEMPLATES.includes(argTemplate)) {
    template = undefined
    hasInvalidArgTemplate = true
  }
  if (!template) {
    const framework = await prompts.select({
      message: hasInvalidArgTemplate
        ? `"${argTemplate}" isn't a valid template. Please choose from below: `
        : 'Select a framework:',
      options: FRAMEWORKS.map((framework) => {
        const frameworkColor = framework.color
        return {
          label: frameworkColor(framework.display || framework.name),
          value: framework,
        }
      }),
    })
    if (prompts.isCancel(framework)) return cancel()

    const variant = await prompts.select({
      message: 'Select a variant:',
      options: framework.variants.map((variant) => {
        const variantColor = variant.color
        const command = variant.customCommand
          ? getFullCustomCommand(variant.customCommand, pkgInfo).replace(
              / TARGET_DIR$/,
              '',
            )
          : undefined
        return {
          label: variantColor(variant.display || variant.name),
          value: variant.name,
          hint: command,
        }
      }),
    })
    if (prompts.isCancel(variant)) return cancel()

    template = variant
  }

  const root = path.join(cwd, targetDir)
  fs.mkdirSync(root, { recursive: true })

  // determine template
  let isReactSwc = false
  if (template.includes('-swc')) {
    isReactSwc = true
    template = template.replace('-swc', '')
  }

  const pkgManager = pkgInfo ? pkgInfo.name : 'npm'

  const { customCommand } =
    FRAMEWORKS.flatMap((f) => f.variants).find((v) => v.name === template) ?? {}

  if (customCommand) {
    const fullCustomCommand = getFullCustomCommand(customCommand, pkgInfo)

    const [command, ...args] = fullCustomCommand.split(' ')
    // we replace TARGET_DIR here because targetDir may include a space
    const replacedArgs = args.map((arg) =>
      arg.replace('TARGET_DIR', () => targetDir),
    )
    const { status } = spawn.sync(command, replacedArgs, {
      stdio: 'inherit',
    })
    process.exit(status ?? 0)
  }

  prompts.log.step(`Scaffolding project in ${root}...`)

  const templateDir = path.resolve(
    fileURLToPath(import.meta.url),
    '../..',
    `template-${template}`,
  )

  const write = (file: string, content?: string) => {
    const targetPath = path.join(root, renameFiles[file] ?? file)
    if (content) {
      fs.writeFileSync(targetPath, content)
    } else {
      copy(path.join(templateDir, file), targetPath)
    }
  }

  const files = fs.readdirSync(templateDir)
  for (const file of files.filter((f) => f !== 'package.json')) {
    write(file)
  }

  const pkg = JSON.parse(
    fs.readFileSync(path.join(templateDir, `package.json`), 'utf-8'),
  )

  pkg.name = packageName

  write('package.json', JSON.stringify(pkg, null, 2) + '\n')

  if (isReactSwc) {
    setupReactSwc(root, template.endsWith('-ts'))
  }

  let doneMessage = ''
  const cdProjectName = path.relative(cwd, root)
  doneMessage += `Done. Now run:\n`
  if (root !== cwd) {
    doneMessage += `\n  cd ${
      cdProjectName.includes(' ') ? `"${cdProjectName}"` : cdProjectName
    }`
  }
  switch (pkgManager) {
    case 'yarn':
      doneMessage += '\n  yarn'
      doneMessage += '\n  yarn dev'
      break
    default:
      doneMessage += `\n  ${pkgManager} install`
      doneMessage += `\n  ${pkgManager} run dev`
      break
  }
  prompts.outro(doneMessage)
}

function formatTargetDir(targetDir: string) {
  return targetDir.trim().replace(/\/+$/g, '')
}

function copy(src: string, dest: string) {
  const stat = fs.statSync(src)
  if (stat.isDirectory()) {
    copyDir(src, dest)
  } else {
    fs.copyFileSync(src, dest)
  }
}

function isValidPackageName(projectName: string) {
  return /^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/.test(
    projectName,
  )
}

function toValidPackageName(projectName: string) {
  return projectName
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/^[._]/, '')
    .replace(/[^a-z\d\-~]+/g, '-')
}

function copyDir(srcDir: string, destDir: string) {
  fs.mkdirSync(destDir, { recursive: true })
  for (const file of fs.readdirSync(srcDir)) {
    const srcFile = path.resolve(srcDir, file)
    const destFile = path.resolve(destDir, file)
    copy(srcFile, destFile)
  }
}

function isEmpty(path: string) {
  const files = fs.readdirSync(path)
  return files.length === 0 || (files.length === 1 && files[0] === '.git')
}

function emptyDir(dir: string) {
  if (!fs.existsSync(dir)) {
    return
  }
  for (const file of fs.readdirSync(dir)) {
    if (file === '.git') {
      continue
    }
    fs.rmSync(path.resolve(dir, file), { recursive: true, force: true })
  }
}

interface PkgInfo {
  name: string
  version: string
}

function pkgFromUserAgent(userAgent: string | undefined): PkgInfo | undefined {
  if (!userAgent) return undefined
  const pkgSpec = userAgent.split(' ')[0]
  const pkgSpecArr = pkgSpec.split('/')
  return {
    name: pkgSpecArr[0],
    version: pkgSpecArr[1],
  }
}

function setupReactSwc(root: string, isTs: boolean) {
  // renovate: datasource=npm depName=@vitejs/plugin-react-swc
  const reactSwcPluginVersion = '4.0.0'

  editFile(path.resolve(root, 'package.json'), (content) => {
    return content.replace(
      /"@vitejs\/plugin-react": ".+?"/,
      `"@vitejs/plugin-react-swc": "^${reactSwcPluginVersion}"`,
    )
  })
  editFile(
    path.resolve(root, `vite.config.${isTs ? 'ts' : 'js'}`),
    (content) => {
      return content.replace('@vitejs/plugin-react', '@vitejs/plugin-react-swc')
    },
  )
}

function editFile(file: string, callback: (content: string) => string) {
  const content = fs.readFileSync(file, 'utf-8')
  fs.writeFileSync(file, callback(content), 'utf-8')
}

function getFullCustomCommand(customCommand: string, pkgInfo?: PkgInfo) {
  const pkgManager = pkgInfo ? pkgInfo.name : 'npm'
  const isYarn1 = pkgManager === 'yarn' && pkgInfo?.version.startsWith('1.')

  return (
    customCommand
      .replace(/^npm create (?:-- )?/, () => {
        // `bun create` uses it's own set of templates,
        // the closest alternative is using `bun x` directly on the package
        if (pkgManager === 'bun') {
          return 'bun x create-'
        }
        // pnpm doesn't support the -- syntax
        if (pkgManager === 'pnpm') {
          return 'pnpm create '
        }
        // For other package managers, preserve the original format
        return customCommand.startsWith('npm create -- ')
          ? `${pkgManager} create -- `
          : `${pkgManager} create `
      })
      // Only Yarn 1.x doesn't support `@version` in the `create` command
      .replace('@latest', () => (isYarn1 ? '' : '@latest'))
      .replace(/^npm exec/, () => {
        // Prefer `pnpm dlx`, `yarn dlx`, or `bun x`
        if (pkgManager === 'pnpm') {
          return 'pnpm dlx'
        }
        if (pkgManager === 'yarn' && !isYarn1) {
          return 'yarn dlx'
        }
        if (pkgManager === 'bun') {
          return 'bun x'
        }
        // Use `npm exec` in all other cases,
        // including Yarn 1.x and other custom npm clients.
        return 'npm exec'
      })
  )
}

init().catch((e) => {
  console.error(e)
})



================================================
FILE: packages/create-vite/template-lit/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-lit/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Lit</title>
    <link rel="stylesheet" href="./src/index.css" />
    <script type="module" src="/src/my-element.js"></script>
  </head>
  <body>
    <my-element>
      <h1>Vite + Lit</h1>
    </my-element>
  </body>
</html>



================================================
FILE: packages/create-vite/template-lit/package.json
================================================
{
  "name": "vite-lit-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "lit": "^3.3.1"
  },
  "devDependencies": {
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-lit/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
}



================================================
FILE: packages/create-vite/template-lit/src/my-element.js
================================================
import { LitElement, css, html } from 'lit'
import litLogo from './assets/lit.svg'
import viteLogo from '/vite.svg'

/**
 * An example element.
 *
 * @slot - This element has a slot
 * @csspart button - The button
 */
export class MyElement extends LitElement {
  static get properties() {
    return {
      /**
       * Copy for the read the docs hint.
       */
      docsHint: { type: String },

      /**
       * The number of times the button has been clicked.
       */
      count: { type: Number },
    }
  }

  constructor() {
    super()
    this.docsHint = 'Click on the Vite and Lit logos to learn more'
    this.count = 0
  }

  render() {
    return html`
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src=${viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://lit.dev" target="_blank">
          <img src=${litLogo} class="logo lit" alt="Lit logo" />
        </a>
      </div>
      <slot></slot>
      <div class="card">
        <button @click=${this._onClick} part="button">
          count is ${this.count}
        </button>
      </div>
      <p class="read-the-docs">${this.docsHint}</p>
    `
  }

  _onClick() {
    this.count++
  }

  static get styles() {
    return css`
      :host {
        max-width: 1280px;
        margin: 0 auto;
        padding: 2rem;
        text-align: center;
      }

      .logo {
        height: 6em;
        padding: 1.5em;
        will-change: filter;
        transition: filter 300ms;
      }
      .logo:hover {
        filter: drop-shadow(0 0 2em #646cffaa);
      }
      .logo.lit:hover {
        filter: drop-shadow(0 0 2em #325cffaa);
      }

      .card {
        padding: 2em;
      }

      .read-the-docs {
        color: #888;
      }

      a {
        font-weight: 500;
        color: #646cff;
        text-decoration: inherit;
      }
      a:hover {
        color: #535bf2;
      }

      ::slotted(h1) {
        font-size: 3.2em;
        line-height: 1.1;
      }

      button {
        border-radius: 8px;
        border: 1px solid transparent;
        padding: 0.6em 1.2em;
        font-size: 1em;
        font-weight: 500;
        font-family: inherit;
        background-color: #1a1a1a;
        cursor: pointer;
        transition: border-color 0.25s;
      }
      button:hover {
        border-color: #646cff;
      }
      button:focus,
      button:focus-visible {
        outline: 4px auto -webkit-focus-ring-color;
      }

      @media (prefers-color-scheme: light) {
        a:hover {
          color: #747bff;
        }
        button {
          background-color: #f9f9f9;
        }
      }
    `
  }
}

window.customElements.define('my-element', MyElement)



================================================
FILE: packages/create-vite/template-lit-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-lit-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Lit + TS</title>
    <link rel="stylesheet" href="./src/index.css" />
    <script type="module" src="/src/my-element.ts"></script>
  </head>
  <body>
    <my-element>
      <h1>Vite + Lit</h1>
    </my-element>
  </body>
</html>



================================================
FILE: packages/create-vite/template-lit-ts/package.json
================================================
{
  "name": "vite-lit-ts-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "lit": "^3.3.1"
  },
  "devDependencies": {
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-lit-ts/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-lit-ts/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
}



================================================
FILE: packages/create-vite/template-lit-ts/src/my-element.ts
================================================
import { LitElement, css, html } from 'lit'
import { customElement, property } from 'lit/decorators.js'
import litLogo from './assets/lit.svg'
import viteLogo from '/vite.svg'

/**
 * An example element.
 *
 * @slot - This element has a slot
 * @csspart button - The button
 */
@customElement('my-element')
export class MyElement extends LitElement {
  /**
   * Copy for the read the docs hint.
   */
  @property()
  docsHint = 'Click on the Vite and Lit logos to learn more'

  /**
   * The number of times the button has been clicked.
   */
  @property({ type: Number })
  count = 0

  render() {
    return html`
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src=${viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://lit.dev" target="_blank">
          <img src=${litLogo} class="logo lit" alt="Lit logo" />
        </a>
      </div>
      <slot></slot>
      <div class="card">
        <button @click=${this._onClick} part="button">
          count is ${this.count}
        </button>
      </div>
      <p class="read-the-docs">${this.docsHint}</p>
    `
  }

  private _onClick() {
    this.count++
  }

  static styles = css`
    :host {
      max-width: 1280px;
      margin: 0 auto;
      padding: 2rem;
      text-align: center;
    }

    .logo {
      height: 6em;
      padding: 1.5em;
      will-change: filter;
      transition: filter 300ms;
    }
    .logo:hover {
      filter: drop-shadow(0 0 2em #646cffaa);
    }
    .logo.lit:hover {
      filter: drop-shadow(0 0 2em #325cffaa);
    }

    .card {
      padding: 2em;
    }

    .read-the-docs {
      color: #888;
    }

    ::slotted(h1) {
      font-size: 3.2em;
      line-height: 1.1;
    }

    a {
      font-weight: 500;
      color: #646cff;
      text-decoration: inherit;
    }
    a:hover {
      color: #535bf2;
    }

    button {
      border-radius: 8px;
      border: 1px solid transparent;
      padding: 0.6em 1.2em;
      font-size: 1em;
      font-weight: 500;
      font-family: inherit;
      background-color: #1a1a1a;
      cursor: pointer;
      transition: border-color 0.25s;
    }
    button:hover {
      border-color: #646cff;
    }
    button:focus,
    button:focus-visible {
      outline: 4px auto -webkit-focus-ring-color;
    }

    @media (prefers-color-scheme: light) {
      a:hover {
        color: #747bff;
      }
      button {
        background-color: #f9f9f9;
      }
    }
  `
}

declare global {
  interface HTMLElementTagNameMap {
    'my-element': MyElement
  }
}



================================================
FILE: packages/create-vite/template-lit-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-preact/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-preact/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Preact</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-preact/package.json
================================================
{
  "name": "vite-preact-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.27.0"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.10.2",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-preact/vite.config.js
================================================
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact()],
})



================================================
FILE: packages/create-vite/template-preact/src/app.css
================================================
#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.preact:hover {
  filter: drop-shadow(0 0 2em #673ab8aa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-preact/src/app.jsx
================================================
import { useState } from 'preact/hooks'
import preactLogo from './assets/preact.svg'
import viteLogo from '/vite.svg'
import './app.css'

export function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://preactjs.com" target="_blank">
          <img src={preactLogo} class="logo preact" alt="Preact logo" />
        </a>
      </div>
      <h1>Vite + Preact</h1>
      <div class="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/app.jsx</code> and save to test HMR
        </p>
      </div>
      <p>
        Check out{' '}
        <a
          href="https://preactjs.com/guide/v10/getting-started#create-a-vite-powered-preact-app"
          target="_blank"
        >
          create-preact
        </a>
        , the official Preact + Vite starter
      </p>
      <p class="read-the-docs">
        Click on the Vite and Preact logos to learn more
      </p>
    </>
  )
}



================================================
FILE: packages/create-vite/template-preact/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-preact/src/main.jsx
================================================
import { render } from 'preact'
import './index.css'
import { App } from './app.jsx'

render(<App />, document.getElementById('app'))



================================================
FILE: packages/create-vite/template-preact-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-preact-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Preact + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-preact-ts/package.json
================================================
{
  "name": "vite-preact-ts-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.27.0"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.10.2",
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-preact-ts/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-preact-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-preact-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-preact-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact()],
})



================================================
FILE: packages/create-vite/template-preact-ts/src/app.css
================================================
#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.preact:hover {
  filter: drop-shadow(0 0 2em #673ab8aa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-preact-ts/src/app.tsx
================================================
import { useState } from 'preact/hooks'
import preactLogo from './assets/preact.svg'
import viteLogo from '/vite.svg'
import './app.css'

export function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://preactjs.com" target="_blank">
          <img src={preactLogo} class="logo preact" alt="Preact logo" />
        </a>
      </div>
      <h1>Vite + Preact</h1>
      <div class="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/app.tsx</code> and save to test HMR
        </p>
      </div>
      <p>
        Check out{' '}
        <a
          href="https://preactjs.com/guide/v10/getting-started#create-a-vite-powered-preact-app"
          target="_blank"
        >
          create-preact
        </a>
        , the official Preact + Vite starter
      </p>
      <p class="read-the-docs">
        Click on the Vite and Preact logos to learn more
      </p>
    </>
  )
}



================================================
FILE: packages/create-vite/template-preact-ts/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-preact-ts/src/main.tsx
================================================
import { render } from 'preact'
import './index.css'
import { App } from './app.tsx'

render(<App />, document.getElementById('app')!)



================================================
FILE: packages/create-vite/template-preact-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-qwik/README.md
================================================
# Qwik + Vite

## Qwik in CSR mode

This starter is using a pure CSR (Client-Side Rendering) mode. This means, that the application is fully bootstrapped in the browser. Most of Qwik innovations however take advantage of SSR (Server-Side Rendering) mode.

```ts
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})
```

Use `npm create qwik@latest` to create a full production ready Qwik application, using SSR and [QwikCity](https://qwik.dev/docs/qwikcity/), our server-side metaframwork.

## Usage

```bash
$ npm install # or pnpm install or yarn install
```

Learn more on the [Qwik Website](https://qwik.dev) and join our community on our [Discord](https://qwik.dev/chat)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>



================================================
FILE: packages/create-vite/template-qwik/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-qwik/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Qwik + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-qwik/package.json
================================================
{
  "name": "vite-qwik",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "serve dist"
  },
  "devDependencies": {
    "serve": "^14.2.4",
    "vite": "^7.1.2"
  },
  "dependencies": {
    "@builder.io/qwik": "^1.15.0"
  }
}



================================================
FILE: packages/create-vite/template-qwik/vite.config.js
================================================
import { defineConfig } from 'vite'
import { qwikVite } from '@builder.io/qwik/optimizer'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})



================================================
FILE: packages/create-vite/template-qwik/src/app.css
================================================
#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.qwik:hover {
  filter: drop-shadow(0 0 2em #673ab8aa);
}
.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-qwik/src/app.jsx
================================================
import { component$, useSignal } from '@builder.io/qwik'

import qwikLogo from './assets/qwik.svg'
import viteLogo from '/vite.svg'
import './app.css'

export const App = component$(() => {
  const count = useSignal(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://qwik.dev" target="_blank">
          <img src={qwikLogo} class="logo qwik" alt="Qwik logo" />
        </a>
      </div>
      <h1>Vite + Qwik</h1>
      <div class="card">
        <button onClick$={() => count.value++}>count is {count.value}</button>
        <p>
          Edit <code>src/app.jsx</code> and save to test HMR
        </p>
      </div>
      <p class="read-the-docs">
        Click on the Vite and Qwik logos to learn more
      </p>
    </>
  )
})



================================================
FILE: packages/create-vite/template-qwik/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-qwik/src/main.jsx
================================================
import '@builder.io/qwik/qwikloader.js'

import { render } from '@builder.io/qwik'
import './index.css'
import { App } from './app.jsx'

render(document.getElementById('app'), <App />)



================================================
FILE: packages/create-vite/template-qwik/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-qwik-ts/README.md
================================================
# Qwik + Vite

## Qwik in CSR mode

This starter is using a pure CSR (Client-Side Rendering) mode. This means, that the application is fully bootstrapped in the browser. Most of Qwik innovations however take advantage of SSR (Server-Side Rendering) mode.

```ts
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})
```

Use `npm create qwik@latest` to create a full production ready Qwik application, using SSR and [QwikCity](https://qwik.dev/docs/qwikcity/), our server-side metaframwork.

## Usage

```bash
$ npm install # or pnpm install or yarn install
```

Learn more on the [Qwik Website](https://qwik.dev) and join our community on our [Discord](https://qwik.dev/chat)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>



================================================
FILE: packages/create-vite/template-qwik-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-qwik-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Qwik + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-qwik-ts/package.json
================================================
{
  "name": "vite-qwik",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "serve dist"
  },
  "devDependencies": {
    "serve": "^14.2.4",
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  },
  "dependencies": {
    "@builder.io/qwik": "^1.15.0"
  }
}



================================================
FILE: packages/create-vite/template-qwik-ts/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "@builder.io/qwik",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-qwik-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-qwik-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-qwik-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import { qwikVite } from '@builder.io/qwik/optimizer'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})



================================================
FILE: packages/create-vite/template-qwik-ts/src/app.css
================================================
#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.qwik:hover {
  filter: drop-shadow(0 0 2em #673ab8aa);
}
.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-qwik-ts/src/app.tsx
================================================
import { component$, useSignal } from '@builder.io/qwik'

import qwikLogo from './assets/qwik.svg'
import viteLogo from '/vite.svg'
import './app.css'

export const App = component$(() => {
  const count = useSignal(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://qwik.dev" target="_blank">
          <img src={qwikLogo} class="logo qwik" alt="Qwik logo" />
        </a>
      </div>
      <h1>Vite + Qwik</h1>
      <div class="card">
        <button onClick$={() => count.value++}>count is {count.value}</button>
      </div>
      <p class="read-the-docs">
        Click on the Vite and Qwik logos to learn more
      </p>
    </>
  )
})



================================================
FILE: packages/create-vite/template-qwik-ts/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-qwik-ts/src/main.tsx
================================================
import '@builder.io/qwik/qwikloader.js'

import { render } from '@builder.io/qwik'
import './index.css'
import { App } from './app.tsx'

render(document.getElementById('app') as HTMLElement, <App />)



================================================
FILE: packages/create-vite/template-qwik-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-react/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.



================================================
FILE: packages/create-vite/template-react/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-react/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])



================================================
FILE: packages/create-vite/template-react/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-react/package.json
================================================
{
  "name": "vite-react-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-react/vite.config.js
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})



================================================
FILE: packages/create-vite/template-react/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-react/src/App.jsx
================================================
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App



================================================
FILE: packages/create-vite/template-react/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-react/src/main.jsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)



================================================
FILE: packages/create-vite/template-react-ts/README.md
================================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```



================================================
FILE: packages/create-vite/template-react-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-react-ts/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])



================================================
FILE: packages/create-vite/template-react-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-react-ts/package.json
================================================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.1",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-react-ts/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-react-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-react-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-react-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})



================================================
FILE: packages/create-vite/template-react-ts/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-react-ts/src/App.tsx
================================================
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App



================================================
FILE: packages/create-vite/template-react-ts/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-react-ts/src/main.tsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)



================================================
FILE: packages/create-vite/template-react-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-solid/README.md
================================================
## Usage

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

Learn more about deploying your application with the [documentations](https://vite.dev/guide/static-deploy.html)



================================================
FILE: packages/create-vite/template-solid/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-solid/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Solid</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-solid/package.json
================================================
{
  "name": "vite-solid-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "solid-js": "^1.9.8"
  },
  "devDependencies": {
    "vite": "^7.1.2",
    "vite-plugin-solid": "^2.11.8"
  }
}



================================================
FILE: packages/create-vite/template-solid/vite.config.js
================================================
import { defineConfig } from 'vite'
import solid from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solid()],
})



================================================
FILE: packages/create-vite/template-solid/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.solid:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-solid/src/App.jsx
================================================
import { createSignal } from 'solid-js'
import solidLogo from './assets/solid.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = createSignal(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://solidjs.com" target="_blank">
          <img src={solidLogo} class="logo solid" alt="Solid logo" />
        </a>
      </div>
      <h1>Vite + Solid</h1>
      <div class="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count()}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
      <p class="read-the-docs">
        Click on the Vite and Solid logos to learn more
      </p>
    </>
  )
}

export default App



================================================
FILE: packages/create-vite/template-solid/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-solid/src/index.jsx
================================================
/* @refresh reload */
import { render } from 'solid-js/web'
import './index.css'
import App from './App.jsx'

const root = document.getElementById('root')

render(() => <App />, root)



================================================
FILE: packages/create-vite/template-solid-ts/README.md
================================================
## Usage

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

Learn more about deploying your application with the [documentations](https://vite.dev/guide/static-deploy.html)



================================================
FILE: packages/create-vite/template-solid-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-solid-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Solid + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-solid-ts/package.json
================================================
{
  "name": "vite-solid-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "solid-js": "^1.9.8"
  },
  "devDependencies": {
    "typescript": "~5.8.3",
    "vite": "^7.1.2",
    "vite-plugin-solid": "^2.11.8"
  }
}



================================================
FILE: packages/create-vite/template-solid-ts/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-solid-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-solid-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-solid-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import solid from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solid()],
})



================================================
FILE: packages/create-vite/template-solid-ts/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.solid:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: packages/create-vite/template-solid-ts/src/App.tsx
================================================
import { createSignal } from 'solid-js'
import solidLogo from './assets/solid.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = createSignal(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} class="logo" alt="Vite logo" />
        </a>
        <a href="https://solidjs.com" target="_blank">
          <img src={solidLogo} class="logo solid" alt="Solid logo" />
        </a>
      </div>
      <h1>Vite + Solid</h1>
      <div class="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count()}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p class="read-the-docs">
        Click on the Vite and Solid logos to learn more
      </p>
    </>
  )
}

export default App



================================================
FILE: packages/create-vite/template-solid-ts/src/index.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-solid-ts/src/index.tsx
================================================
/* @refresh reload */
import { render } from 'solid-js/web'
import './index.css'
import App from './App.tsx'

const root = document.getElementById('root')

render(() => <App />, root!)



================================================
FILE: packages/create-vite/template-solid-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-svelte/README.md
================================================
# Svelte + Vite

This template should help get you started developing with Svelte in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `checkJs` in the JS template?**

It is likely that most cases of changing variable types in runtime are likely to be accidental, rather than deliberate. This provides advanced typechecking out of the box. Should you like to take advantage of the dynamically-typed nature of JavaScript, it is trivial to change the configuration.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/sveltejs/svelte-hmr/tree/master/packages/svelte-hmr#preservation-of-local-state).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```js
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```



================================================
FILE: packages/create-vite/template-svelte/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-svelte/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Svelte</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-svelte/jsconfig.json
================================================
{
  "compilerOptions": {
    "moduleResolution": "bundler",
    "target": "ESNext",
    "module": "ESNext",
    /**
     * svelte-preprocess cannot figure out whether you have
     * a value or a type, so tell TypeScript to enforce using
     * `import type` instead of `import` for Types.
     */
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "resolveJsonModule": true,
    /**
     * To have warnings / errors of the Svelte compiler at the
     * correct position, enable source maps by default.
     */
    "sourceMap": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    /**
     * Typecheck JS in `.svelte` and `.js` files by default.
     * Disable this if you'd like to use dynamic types.
     */
    "checkJs": true
  },
  /**
   * Use global.d.ts instead of compilerOptions.types
   * to avoid limiting type declarations.
   */
  "include": ["src/**/*.d.ts", "src/**/*.js", "src/**/*.svelte"]
}



================================================
FILE: packages/create-vite/template-svelte/package.json
================================================
{
  "name": "vite-svelte-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^6.1.1",
    "svelte": "^5.38.1",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-svelte/svelte.config.js
================================================
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

/** @type {import("@sveltejs/vite-plugin-svelte").SvelteConfig} */
export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}



================================================
FILE: packages/create-vite/template-svelte/vite.config.js
================================================
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vite.dev/config/
export default defineConfig({
  plugins: [svelte()],
})



================================================
FILE: packages/create-vite/template-svelte/src/app.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

.card {
  padding: 2em;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-svelte/src/App.svelte
================================================
<script>
  import svelteLogo from './assets/svelte.svg'
  import viteLogo from '/vite.svg'
  import Counter from './lib/Counter.svelte'
</script>

<main>
  <div>
    <a href="https://vite.dev" target="_blank" rel="noreferrer">
      <img src={viteLogo} class="logo" alt="Vite Logo" />
    </a>
    <a href="https://svelte.dev" target="_blank" rel="noreferrer">
      <img src={svelteLogo} class="logo svelte" alt="Svelte Logo" />
    </a>
  </div>
  <h1>Vite + Svelte</h1>

  <div class="card">
    <Counter />
  </div>

  <p>
    Check out <a href="https://github.com/sveltejs/kit#readme" target="_blank" rel="noreferrer">SvelteKit</a>, the official Svelte app framework powered by Vite!
  </p>

  <p class="read-the-docs">
    Click on the Vite and Svelte logos to learn more
  </p>
</main>

<style>
  .logo {
    height: 6em;
    padding: 1.5em;
    will-change: filter;
    transition: filter 300ms;
  }
  .logo:hover {
    filter: drop-shadow(0 0 2em #646cffaa);
  }
  .logo.svelte:hover {
    filter: drop-shadow(0 0 2em #ff3e00aa);
  }
  .read-the-docs {
    color: #888;
  }
</style>



================================================
FILE: packages/create-vite/template-svelte/src/main.js
================================================
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app'),
})

export default app



================================================
FILE: packages/create-vite/template-svelte/src/vite-env.d.ts
================================================
/// <reference types="svelte" />
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-svelte/src/lib/Counter.svelte
================================================
<script>
  let count = $state(0)
  const increment = () => {
    count += 1
  }
</script>

<button onclick={increment}>
  count is {count}
</button>



================================================
FILE: packages/create-vite/template-svelte-ts/README.md
================================================
# Svelte + TS + Vite

This template should help get you started developing with Svelte and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + TypeScript + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `allowJs` in the TS template?**

While `allowJs: false` would indeed prevent the use of `.js` files in the project, it does not prevent the use of JavaScript syntax in `.svelte` files. In addition, it would force `checkJs: false`, bringing the worst of both worlds: not being able to guarantee the entire codebase is TypeScript, and also having worse typechecking for the existing JavaScript. In addition, there are valid use cases in which a mixed codebase may be relevant.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/rixo/svelte-hmr#svelte-hmr).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```ts
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```



================================================
FILE: packages/create-vite/template-svelte-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-svelte-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Svelte + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-svelte-ts/package.json
================================================
{
  "name": "vite-svelte-ts-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-check --tsconfig ./tsconfig.app.json && tsc -p tsconfig.node.json"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^6.1.1",
    "@tsconfig/svelte": "^5.0.4",
    "svelte": "^5.38.1",
    "svelte-check": "^4.3.1",
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-svelte-ts/svelte.config.js
================================================
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

/** @type {import("@sveltejs/vite-plugin-svelte").SvelteConfig} */
export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}



================================================
FILE: packages/create-vite/template-svelte-ts/tsconfig.app.json
================================================
{
  "extends": "@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "resolveJsonModule": true,
    /**
     * Typecheck JS in `.svelte` and `.js` files by default.
     * Disable checkJs if you'd like to use dynamic types in JS.
     * Note that setting allowJs false does not prevent the use
     * of JS in `.svelte` files.
     */
    "allowJs": true,
    "checkJs": true,
    "isolatedModules": true,
    "moduleDetection": "force"
  },
  "include": ["src/**/*.ts", "src/**/*.js", "src/**/*.svelte"]
}



================================================
FILE: packages/create-vite/template-svelte-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-svelte-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-svelte-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vite.dev/config/
export default defineConfig({
  plugins: [svelte()],
})



================================================
FILE: packages/create-vite/template-svelte-ts/src/app.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

.card {
  padding: 2em;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-svelte-ts/src/App.svelte
================================================
<script lang="ts">
  import svelteLogo from './assets/svelte.svg'
  import viteLogo from '/vite.svg'
  import Counter from './lib/Counter.svelte'
</script>

<main>
  <div>
    <a href="https://vite.dev" target="_blank" rel="noreferrer">
      <img src={viteLogo} class="logo" alt="Vite Logo" />
    </a>
    <a href="https://svelte.dev" target="_blank" rel="noreferrer">
      <img src={svelteLogo} class="logo svelte" alt="Svelte Logo" />
    </a>
  </div>
  <h1>Vite + Svelte</h1>

  <div class="card">
    <Counter />
  </div>

  <p>
    Check out <a href="https://github.com/sveltejs/kit#readme" target="_blank" rel="noreferrer">SvelteKit</a>, the official Svelte app framework powered by Vite!
  </p>

  <p class="read-the-docs">
    Click on the Vite and Svelte logos to learn more
  </p>
</main>

<style>
  .logo {
    height: 6em;
    padding: 1.5em;
    will-change: filter;
    transition: filter 300ms;
  }
  .logo:hover {
    filter: drop-shadow(0 0 2em #646cffaa);
  }
  .logo.svelte:hover {
    filter: drop-shadow(0 0 2em #ff3e00aa);
  }
  .read-the-docs {
    color: #888;
  }
</style>



================================================
FILE: packages/create-vite/template-svelte-ts/src/main.ts
================================================
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app')!,
})

export default app



================================================
FILE: packages/create-vite/template-svelte-ts/src/vite-env.d.ts
================================================
/// <reference types="svelte" />
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-svelte-ts/src/lib/Counter.svelte
================================================
<script lang="ts">
  let count: number = $state(0)
  const increment = () => {
    count += 1
  }
</script>

<button onclick={increment}>
  count is {count}
</button>



================================================
FILE: packages/create-vite/template-vanilla/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-vanilla/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-vanilla/package.json
================================================
{
  "name": "vite-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-vanilla/src/counter.js
================================================
export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}



================================================
FILE: packages/create-vite/template-vanilla/src/main.js
================================================
import './style.css'
import javascriptLogo from './javascript.svg'
import viteLogo from '/vite.svg'
import { setupCounter } from './counter.js'

document.querySelector('#app').innerHTML = `
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="${viteLogo}" class="logo" alt="Vite logo" />
    </a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank">
      <img src="${javascriptLogo}" class="logo vanilla" alt="JavaScript logo" />
    </a>
    <h1>Hello Vite!</h1>
    <div class="card">
      <button id="counter" type="button"></button>
    </div>
    <p class="read-the-docs">
      Click on the Vite logo to learn more
    </p>
  </div>
`

setupCounter(document.querySelector('#counter'))



================================================
FILE: packages/create-vite/template-vanilla/src/style.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #f7df1eaa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-vanilla-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-vanilla-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-vanilla-ts/package.json
================================================
{
  "name": "vite-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-vanilla-ts/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: packages/create-vite/template-vanilla-ts/src/counter.ts
================================================
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0
  const setCounter = (count: number) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}



================================================
FILE: packages/create-vite/template-vanilla-ts/src/main.ts
================================================
import './style.css'
import typescriptLogo from './typescript.svg'
import viteLogo from '/vite.svg'
import { setupCounter } from './counter.ts'

document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="${viteLogo}" class="logo" alt="Vite logo" />
    </a>
    <a href="https://www.typescriptlang.org/" target="_blank">
      <img src="${typescriptLogo}" class="logo vanilla" alt="TypeScript logo" />
    </a>
    <h1>Vite + TypeScript</h1>
    <div class="card">
      <button id="counter" type="button"></button>
    </div>
    <p class="read-the-docs">
      Click on the Vite and TypeScript logos to learn more
    </p>
  </div>
`

setupCounter(document.querySelector<HTMLButtonElement>('#counter')!)



================================================
FILE: packages/create-vite/template-vanilla-ts/src/style.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #3178c6aa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-vanilla-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-vue/README.md
================================================
# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).



================================================
FILE: packages/create-vite/template-vue/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-vue/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-vue/package.json
================================================
{
  "name": "vite-vue-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.5.18"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "vite": "^7.1.2"
  }
}



================================================
FILE: packages/create-vite/template-vue/vite.config.js
================================================
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
})



================================================
FILE: packages/create-vite/template-vue/src/App.vue
================================================
<script setup>
import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="/vite.svg" class="logo" alt="Vite logo" />
    </a>
    <a href="https://vuejs.org/" target="_blank">
      <img src="./assets/vue.svg" class="logo vue" alt="Vue logo" />
    </a>
  </div>
  <HelloWorld msg="Vite + Vue" />
</template>

<style scoped>
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vue:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
</style>



================================================
FILE: packages/create-vite/template-vue/src/main.js
================================================
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app')



================================================
FILE: packages/create-vite/template-vue/src/style.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

.card {
  padding: 2em;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-vue/src/components/HelloWorld.vue
================================================
<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>



================================================
FILE: packages/create-vite/template-vue-ts/README.md
================================================
# Vue 3 + TypeScript + Vite

This template should help get you started developing with Vue 3 and TypeScript in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about the recommended Project Setup and IDE Support in the [Vue Docs TypeScript Guide](https://vuejs.org/guide/typescript/overview.html#project-setup).



================================================
FILE: packages/create-vite/template-vue-ts/_gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?



================================================
FILE: packages/create-vite/template-vue-ts/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: packages/create-vite/template-vue-ts/package.json
================================================
{
  "name": "vite-vue-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.5.18"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "@vue/tsconfig": "^0.7.0",
    "typescript": "~5.8.3",
    "vite": "^7.1.2",
    "vue-tsc": "^3.0.5"
  }
}



================================================
FILE: packages/create-vite/template-vue-ts/tsconfig.app.json
================================================
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]
}



================================================
FILE: packages/create-vite/template-vue-ts/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: packages/create-vite/template-vue-ts/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: packages/create-vite/template-vue-ts/vite.config.ts
================================================
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
})



================================================
FILE: packages/create-vite/template-vue-ts/src/App.vue
================================================
<script setup lang="ts">
import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="/vite.svg" class="logo" alt="Vite logo" />
    </a>
    <a href="https://vuejs.org/" target="_blank">
      <img src="./assets/vue.svg" class="logo vue" alt="Vue logo" />
    </a>
  </div>
  <HelloWorld msg="Vite + Vue" />
</template>

<style scoped>
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vue:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
</style>



================================================
FILE: packages/create-vite/template-vue-ts/src/main.ts
================================================
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app')



================================================
FILE: packages/create-vite/template-vue-ts/src/style.css
================================================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

.card {
  padding: 2em;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: packages/create-vite/template-vue-ts/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: packages/create-vite/template-vue-ts/src/components/HelloWorld.vue
================================================
<script setup lang="ts">
import { ref } from 'vue'

defineProps<{ msg: string }>()

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>



================================================
FILE: packages/plugin-legacy/README.md
================================================
# @vitejs/plugin-legacy [![npm](https://img.shields.io/npm/v/@vitejs/plugin-legacy.svg)](https://npmjs.com/package/@vitejs/plugin-legacy)

Vite's default browser support baseline is [Native ESM](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). This plugin provides support for legacy browsers that do not support those features when building for production.

By default, this plugin will:

- Generate a corresponding legacy chunk for every chunk in the final bundle, transformed with [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env) and emitted as [SystemJS modules](https://github.com/systemjs/systemjs) (code splitting is still supported!).

- Generate a polyfill chunk including SystemJS runtime, and any necessary polyfills determined by specified browser targets and **actual usage** in the bundle.

- Inject `<script nomodule>` tags into generated HTML to conditionally load the polyfills and legacy bundle only in browsers without widely-available features support.

- Inject the `import.meta.env.LEGACY` env variable, which will only be `true` in the legacy production build, and `false` in all other cases.

## Usage

```js
// vite.config.js
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11'],
    }),
  ],
}
```

Terser must be installed because plugin-legacy uses Terser for minification.

```sh
npm add -D terser
```

## Options

### `targets`

- **Type:** `string | string[] | { [key: string]: string }`
- **Default:** [`'last 2 versions and not dead, > 0.3%, Firefox ESR'`](https://browsersl.ist/#q=last+2+versions+and+not+dead%2C+%3E+0.3%25%2C+Firefox+ESR)

  It's passed on to [`@babel/preset-env`](https://babeljs.io/docs/en/babel-preset-env#targets) when rendering **legacy chunks**.

  The query is also [Browserslist compatible](https://github.com/browserslist/browserslist). See [Browserslist Best Practices](https://github.com/browserslist/browserslist#best-practices) for more details.

  If it's not set, plugin-legacy will load [the browserslist config sources](https://github.com/browserslist/browserslist#queries) and then fallback to the default value.

### `modernTargets`

- **Type:** `string | string[]`
- **Default:** [`'edge>=79, firefox>=67, chrome>=64, safari>=12, chromeAndroid>=64, iOS>=12'`](https://browsersl.ist/#q=edge%3E%3D79%2C+firefox%3E%3D67%2C+chrome%3E%3D64%2C+safari%3E%3D12%2C+chromeAndroid%3E%3D64%2C+iOS%3E%3D12)

  It's passed on to [`@babel/preset-env`](https://babeljs.io/docs/en/babel-preset-env#targets) when collecting polyfills for **modern chunks**. The value set here will override the `build.target` option.

  The query is also [Browserslist compatible](https://github.com/browserslist/browserslist). See [Browserslist Best Practices](https://github.com/browserslist/browserslist#best-practices) for more details.

  If it's not set, plugin-legacy will fallback to the default value.

  Note that this options should not be set unless `renderLegacyChunks` is set to `false`.

### `polyfills`

- **Type:** `boolean | string[]`
- **Default:** `true`

  By default, a polyfills chunk is generated based on the target browser ranges and actual usage in the final bundle (detected via `@babel/preset-env`'s `useBuiltIns: 'usage'`).

  Set to a list of strings to explicitly control which polyfills to include. See [Polyfill Specifiers](#polyfill-specifiers) for details.

  Set to `false` to avoid generating polyfills and handle it yourself (will still generate legacy chunks with syntax transformations).

### `additionalLegacyPolyfills`

- **Type:** `string[]`

  Add custom imports to the legacy polyfills chunk. Since the usage-based polyfill detection only covers ES language features, it may be necessary to manually specify additional DOM API polyfills using this option.

### `additionalModernPolyfills`

- **Type:** `string[]`

  Add custom imports to the modern polyfills chunk. Since the usage-based polyfill detection only covers ES language features, it may be necessary to manually specify additional DOM API polyfills using this option.

### `modernPolyfills`

- **Type:** `boolean | string[]`
- **Default:** `false`

  Defaults to `false`. Enabling this option will generate a separate polyfills chunk for the modern build (targeting [browsers that support widely-available features](#browsers-that-supports-esm-but-does-not-support-widely-available-features)).

  Set to a list of strings to explicitly control which polyfills to include. See [Polyfill Specifiers](#polyfill-specifiers) for details.

  If `modernTargets` is not set, it is **not recommended** to use the `true` value (which uses auto-detection) because `core-js@3` is very aggressive in polyfill inclusions due to all the bleeding edge features it supports. Even when targeting native ESM support, it injects 15kb of polyfills!

  If you don't have hard reliance on bleeding edge runtime features, it is not that hard to avoid having to use polyfills in the modern build altogether. Alternatively, consider setting `modernTargets` or using an on-demand service like https://cdnjs.cloudflare.com/polyfill/ to only inject necessary polyfills based on actual browser user-agents (most modern browsers will need nothing!).

### `renderLegacyChunks`

- **Type:** `boolean`
- **Default:** `true`

  Set to `false` to disable legacy chunks. This is only useful if you are using `modernPolyfills`, which essentially allows you to use this plugin for injecting polyfills to the modern build only:

  ```js
  import legacy from '@vitejs/plugin-legacy'

  export default {
    plugins: [
      legacy({
        modernPolyfills: [
          /* ... */
        ],
        renderLegacyChunks: false,
      }),
    ],
  }
  ```

### `externalSystemJS`

- **Type:** `boolean`
- **Default:** `false`

  Defaults to `false`. Enabling this option will exclude `systemjs/dist/s.min.js` inside polyfills-legacy chunk.

### `renderModernChunks`

- **Type:** `boolean`
- **Default:** `true`

  Set to `false` to only output the legacy bundles that support all target browsers.

  This is also useful when running the project locally using `file:` protocol, as loading modern chunks with `type="module"` may trigger CORS restrictions. To avoid this issue, simply set `renderModernChunks` to `false` to exclusively use legacy chunks instead.

## Browsers that supports ESM but does not support widely-available features

The legacy plugin offers a way to use widely-available features natively in the modern build, while falling back to the legacy build in browsers with native ESM but without those features supported (e.g. Legacy Edge). This feature works by injecting a runtime check and loading the legacy bundle with SystemJs runtime if needed. There are the following drawbacks:

- Modern bundle is downloaded in all ESM browsers
- Modern bundle throws `SyntaxError` in browsers without those features support

The following syntax are considered as widely-available:

- dynamic import
- `import.meta`
- async generator

## Polyfill Specifiers

Polyfill specifier strings for `polyfills` and `modernPolyfills` can be either of the following:

- Any [`core-js` 3 sub import paths](https://unpkg.com/browse/core-js@latest/) - e.g. `es/map` will import `core-js/es/map`

- Any [individual `core-js` 3 modules](https://unpkg.com/browse/core-js@latest/modules/) - e.g. `es.array.iterator` will import `core-js/modules/es.array.iterator.js`

**Example**

```js
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      polyfills: ['es.promise.finally', 'es/map', 'es/set'],
      modernPolyfills: ['es.promise.finally'],
    }),
  ],
}
```

## Content Security Policy

The legacy plugin requires inline scripts for [Safari 10.1 `nomodule` fix](https://gist.github.com/samthor/64b114e4a4f539915a95b91ffd340acc), SystemJS initialization, and dynamic import fallback. If you have a strict CSP policy requirement, you will need to [add the corresponding hashes to your `script-src` list](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#unsafe_inline_script).

The hash values (without the `sha256-` prefix) can be retrieved via:

```js
import { cspHashes } from '@vitejs/plugin-legacy'
```

The current values are:

- `sha256-MS6/3FCg4WjP9gwgaBGwLpRCY6fZBgwmhVCdrPrNf3E=`
- `sha256-tQjf8gvb2ROOMapIxFvFAYBeUJ0v1HCbOcSmDNXGtDo=`
- `sha256-ZxAi3a7m9Mzbc+Z1LGuCCK5Xee6reDkEPRas66H9KSo=`
- `sha256-+5XkZFazzJo8n0iOP4ti/cLCMUudTf//Mzkb7xNPXIc=`

<!--
Run `node --input-type=module -e "import {cspHashes} from '@vitejs/plugin-legacy'; console.log(cspHashes.map(h => 'sha256-'+h))"` to retrieve the value.
-->

Note that these values could change between minor versions. Thus, we recommend generating the CSP header from the exported `cspHashes` variable. If you copy the values manually, then you should pin the minor version using `~`.

When using the `regenerator-runtime` polyfill, it will attempt to use the `globalThis` object to register itself. If `globalThis` is not available (it is [fairly new](https://caniuse.com/?search=globalThis) and not widely supported, including IE 11), it attempts to perform dynamic `Function(...)` call which violates the CSP. To avoid dynamic `eval` in the absence of `globalThis` consider adding `core-js/proposals/global-this` to `additionalLegacyPolyfills` to define it.

## References

- [Vue CLI modern mode](https://cli.vuejs.org/guide/browser-compatibility.html#modern-mode)
- [Using Native JavaScript Modules in Production Today](https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/)
- [rollup-native-modules-boilerplate](https://github.com/philipwalton/rollup-native-modules-boilerplate)



================================================
FILE: packages/plugin-legacy/LICENSE
================================================
MIT License

Copyright (c) 2019-present, VoidZero Inc. and Vite contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: packages/plugin-legacy/package.json
================================================
{
  "name": "@vitejs/plugin-legacy",
  "version": "7.2.1",
  "type": "module",
  "license": "MIT",
  "author": "Evan You",
  "files": [
    "dist"
  ],
  "keywords": [
    "frontend",
    "vite",
    "vite-plugin",
    "@vitejs/plugin-legacy"
  ],
  "exports": "./dist/index.js",
  "scripts": {
    "dev": "tsdown --watch",
    "build": "tsdown",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git",
    "directory": "packages/plugin-legacy"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite/issues"
  },
  "homepage": "https://github.com/vitejs/vite/tree/main/packages/plugin-legacy#readme",
  "funding": "https://github.com/vitejs/vite?sponsor=1",
  "imports": {
    "#legacy-for-rolldown-vite": {
      "types": "./types/legacy-for-rolldown-vite.d.ts",
      "default": "./dist/vendor/rolldown-vite/index.js"
    }
  },
  "dependencies": {
    "@babel/core": "^7.28.0",
    "@babel/plugin-transform-dynamic-import": "^7.27.1",
    "@babel/plugin-transform-modules-systemjs": "^7.27.1",
    "@babel/preset-env": "^7.28.0",
    "babel-plugin-polyfill-corejs3": "^0.13.0",
    "babel-plugin-polyfill-regenerator": "^0.6.5",
    "browserslist": "^4.25.2",
    "browserslist-to-esbuild": "^2.1.1",
    "core-js": "^3.45.0",
    "magic-string": "^0.30.17",
    "regenerator-runtime": "^0.14.1",
    "systemjs": "^6.15.1"
  },
  "peerDependencies": {
    "terser": "^5.16.0",
    "vite": "^7.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-legacy-for-rolldown-vite": "https://pkg.pr.new/vitejs/rolldown-vite/@vitejs/plugin-legacy@a2594ec",
    "acorn": "^8.15.0",
    "fdir": "^6.4.6",
    "picocolors": "^1.1.1",
    "tsdown": "^0.14.0",
    "vite": "workspace:*"
  }
}



================================================
FILE: packages/plugin-legacy/tsconfig.json
================================================
{
  "include": ["tsdown.config.ts", "src"],
  "exclude": ["**/*.spec.ts"],
  "compilerOptions": {
    "outDir": "dist",
    "target": "ES2023",
    "module": "Preserve",
    "moduleResolution": "bundler",
    "strict": true,
    "declaration": true,
    "sourceMap": true,
    "noUnusedLocals": true,
    "esModuleInterop": true,
    "paths": {
      "vite": ["../vite/src/node/index.js"]
    }
  }
}



================================================
FILE: packages/plugin-legacy/tsdown.config.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import { defineConfig } from 'tsdown'
import { fdir } from 'fdir'

const pluginLegacyForRolldownVitePackagePath = path.resolve(
  import.meta.dirname,
  './node_modules/@vitejs/plugin-legacy-for-rolldown-vite',
)

export default defineConfig({
  entry: ['src/index.ts'],
  target: 'node20',
  tsconfig: false, // disable tsconfig `paths` when bundling
  dts: true,
  hooks: {
    async 'build:done'() {
      validateAllDepsForRolldownViteIsIncluded()

      const files = new fdir()
        .glob('!**/*.d.ts')
        .withRelativePaths()
        .crawl(path.join(pluginLegacyForRolldownVitePackagePath, 'dist'))
        .sync()
      for (const file of files) {
        const src = path.resolve(
          pluginLegacyForRolldownVitePackagePath,
          'dist',
          file,
        )
        const dist = path.resolve(
          import.meta.dirname,
          'dist/vendor/rolldown-vite',
          file,
        )
        fs.mkdirSync(path.dirname(dist), { recursive: true })
        fs.copyFileSync(src, dist)
      }
    },
  },
})

function validateAllDepsForRolldownViteIsIncluded() {
  const pkgJsonStr = fs.readFileSync(
    path.resolve(import.meta.dirname, 'package.json'),
    'utf-8',
  )
  const pkgJson = JSON.parse(pkgJsonStr)

  const pkgJsonForRolldownViteStr = fs.readFileSync(
    path.resolve(pluginLegacyForRolldownVitePackagePath, 'package.json'),
    'utf-8',
  )
  const pkgJsonForRolldownVite = JSON.parse(pkgJsonForRolldownViteStr)

  for (const depName of Object.keys(
    pkgJsonForRolldownVite.dependencies ?? {},
  )) {
    if (!pkgJson.dependencies[depName]) {
      throw new Error(
        `All deps for rolldown-vite version of @vitejs/plugin-legacy should be ` +
          `included in @vitejs/plugin-legacy, but ${depName} is not included.`,
      )
    }
  }
}



================================================
FILE: packages/plugin-legacy/src/index.ts
================================================
import path from 'node:path'
import crypto from 'node:crypto'
import { createRequire } from 'node:module'
import { fileURLToPath } from 'node:url'
import { build, normalizePath } from 'vite'
import * as vite from 'vite'
import MagicString from 'magic-string'
import type {
  BuildOptions,
  HtmlTagDescriptor,
  Plugin,
  ResolvedConfig,
  Rollup,
} from 'vite'
import type {
  PluginItem as BabelPlugin,
  types as BabelTypes,
} from '@babel/core'
import colors from 'picocolors'
import browserslist from 'browserslist'
import type { Options } from './types'
import {
  detectModernBrowserCode,
  dynamicFallbackInlineCode,
  legacyEntryId,
  legacyPolyfillId,
  modernChunkLegacyGuard,
  safari10NoModuleFix,
  systemJSInlineCode,
} from './snippets'

// lazy load babel since it's not used during dev
let babel: Promise<typeof import('@babel/core')> | undefined
async function loadBabel() {
  return (babel ??= import('@babel/core'))
}

// The requested module 'browserslist' is a CommonJS module
// which may not support all module.exports as named exports
const { loadConfig: browserslistLoadConfig } = browserslist

// Duplicated from build.ts in Vite Core, at least while the feature is experimental
// We should later expose this helper for other plugins to use
function toOutputFilePathInHtml(
  filename: string,
  type: 'asset' | 'public',
  hostId: string,
  hostType: 'js' | 'css' | 'html',
  config: ResolvedConfig,
  toRelative: (filename: string, importer: string) => string,
): string {
  const { renderBuiltUrl } = config.experimental
  let relative = config.base === '' || config.base === './'
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config.build.ssr,
    })
    if (typeof result === 'object') {
      if (result.runtime) {
        throw new Error(
          `{ runtime: "${result.runtime}" } is not supported for assets in ${hostType} files: ${filename}`,
        )
      }
      if (typeof result.relative === 'boolean') {
        relative = result.relative
      }
    } else if (result) {
      return result
    }
  }
  if (relative && !config.build.ssr) {
    return toRelative(filename, hostId)
  } else {
    return joinUrlSegments(config.decodedBase, filename)
  }
}
function getBaseInHTML(urlRelativePath: string, config: ResolvedConfig) {
  // Prefer explicit URL if defined for linking to assets and public files from HTML,
  // even when base relative is specified
  return config.base === './' || config.base === ''
    ? path.posix.join(
        path.posix.relative(urlRelativePath, '').slice(0, -2),
        './',
      )
    : config.base
}
function joinUrlSegments(a: string, b: string): string {
  if (!a || !b) {
    return a || b || ''
  }
  if (a.endsWith('/')) {
    a = a.substring(0, a.length - 1)
  }
  if (b[0] !== '/') {
    b = '/' + b
  }
  return a + b
}

function toAssetPathFromHtml(
  filename: string,
  htmlPath: string,
  config: ResolvedConfig,
): string {
  const relativeUrlPath = normalizePath(path.relative(config.root, htmlPath))
  const toRelative = (filename: string, _hostId: string) =>
    getBaseInHTML(relativeUrlPath, config) + filename
  return toOutputFilePathInHtml(
    filename,
    'asset',
    htmlPath,
    'html',
    config,
    toRelative,
  )
}

const legacyEnvVarMarker = `__VITE_IS_LEGACY__`

const _require = createRequire(import.meta.url)

const nonLeadingHashInFileNameRE = /[^/]+\[hash(?::\d+)?\]/
const prefixedHashInFileNameRE = /\W?\[hash(?::\d+)?\]/

// browsers supporting ESM + dynamic import + import.meta + async generator
const modernTargetsEsbuild = [
  'es2020',
  'edge79',
  'firefox67',
  'chrome64',
  'safari12',
]
// same with above but by browserslist syntax
// es2020 = chrome 80+, safari 13.1+, firefox 72+, edge 80+
// https://github.com/evanw/esbuild/issues/121#issuecomment-646956379
const modernTargetsBabel =
  'edge>=79, firefox>=67, chrome>=64, safari>=12, chromeAndroid>=64, iOS>=12'

function viteLegacyPlugin(options: Options = {}): Plugin[] {
  if ('rolldownVersion' in vite) {
    const { default: viteLegacyPluginForRolldownVite } = _require(
      '#legacy-for-rolldown-vite',
    )
    return viteLegacyPluginForRolldownVite(options)
  }

  let config: ResolvedConfig
  let targets: Options['targets']
  const modernTargets: Options['modernTargets'] =
    options.modernTargets || modernTargetsBabel

  const genLegacy = options.renderLegacyChunks !== false
  const genModern = options.renderModernChunks !== false
  if (!genLegacy && !genModern) {
    throw new Error(
      '`renderLegacyChunks` and `renderModernChunks` cannot be both false',
    )
  }

  const debugFlags = (process.env.DEBUG || '').split(',')
  const isDebug =
    debugFlags.includes('vite:*') || debugFlags.includes('vite:legacy')

  const assumptions = options.assumptions || {}

  const facadeToLegacyChunkMap = new Map()
  const facadeToLegacyPolyfillMap = new Map()
  const facadeToModernPolyfillMap = new Map()
  const modernPolyfills = new Set<string>()
  const legacyPolyfills = new Set<string>()
  // When discovering polyfills in `renderChunk`, the hook may be non-deterministic, so we group the
  // modern and legacy polyfills in a sorted chunks map for each rendered outputs before merging them.
  const outputToChunkFileNameToPolyfills = new WeakMap<
    Rollup.NormalizedOutputOptions,
    Map<string, { modern: Set<string>; legacy: Set<string> }> | null
  >()

  if (Array.isArray(options.modernPolyfills) && genModern) {
    options.modernPolyfills.forEach((i) => {
      modernPolyfills.add(
        i.includes('/') ? `core-js/${i}` : `core-js/modules/${i}.js`,
      )
    })
  }
  if (Array.isArray(options.additionalModernPolyfills)) {
    options.additionalModernPolyfills.forEach((i) => {
      modernPolyfills.add(i)
    })
  }
  if (Array.isArray(options.polyfills)) {
    options.polyfills.forEach((i) => {
      if (i.startsWith(`regenerator`)) {
        legacyPolyfills.add(`regenerator-runtime/runtime.js`)
      } else {
        legacyPolyfills.add(
          i.includes('/') ? `core-js/${i}` : `core-js/modules/${i}.js`,
        )
      }
    })
  }
  if (Array.isArray(options.additionalLegacyPolyfills)) {
    options.additionalLegacyPolyfills.forEach((i) => {
      legacyPolyfills.add(i)
    })
  }

  let overriddenBuildTarget = false
  let overriddenBuildTargetOnlyModern = false
  let overriddenDefaultModernTargets = false
  const legacyConfigPlugin: Plugin = {
    name: 'vite:legacy-config',

    async config(config, env) {
      if (env.command === 'build' && !config.build?.ssr) {
        if (!config.build) {
          config.build = {}
        }

        if (genLegacy && !config.build.cssTarget) {
          // Hint for esbuild that we are targeting legacy browsers when minifying CSS.
          // Full CSS compat table available at https://github.com/evanw/esbuild/blob/78e04680228cf989bdd7d471e02bbc2c8d345dc9/internal/compat/css_table.go
          // But note that only the `HexRGBA` feature affects the minify outcome.
          // HSL & rebeccapurple values will be minified away regardless the target.
          // So targeting `chrome61` suffices to fix the compatibility issue.
          config.build.cssTarget = 'chrome61'
        }

        if (genLegacy) {
          // Vite's default target browsers are **not** the same.
          // See https://github.com/vitejs/vite/pull/10052#issuecomment-1242076461
          overriddenBuildTarget = config.build.target !== undefined
          overriddenDefaultModernTargets = options.modernTargets !== undefined
        } else {
          overriddenBuildTargetOnlyModern = config.build.target !== undefined
        }

        if (options.modernTargets) {
          // Package is ESM only
          const { default: browserslistToEsbuild } = await import(
            'browserslist-to-esbuild'
          )
          config.build.target = browserslistToEsbuild(options.modernTargets)
        } else {
          config.build.target = modernTargetsEsbuild
        }
      }

      return {
        define: {
          'import.meta.env.LEGACY':
            env.command === 'serve' || config.build?.ssr
              ? false
              : legacyEnvVarMarker,
        },
      }
    },
    configResolved(config) {
      if (overriddenBuildTarget) {
        config.logger.warn(
          colors.yellow(
            `plugin-legacy overrode 'build.target'. You should pass 'targets' as an option to this plugin with the list of legacy browsers to support instead.`,
          ),
        )
      }
      if (overriddenBuildTargetOnlyModern) {
        config.logger.warn(
          colors.yellow(
            `plugin-legacy overrode 'build.target'. You should pass 'modernTargets' as an option to this plugin with the list of browsers to support instead.`,
          ),
        )
      }
      if (overriddenDefaultModernTargets) {
        config.logger.warn(
          colors.yellow(
            `plugin-legacy 'modernTargets' option overrode the builtin targets of modern chunks. Some versions of browsers between legacy and modern may not be supported.`,
          ),
        )
      }
      if (config.isWorker) {
        config.logger.warn(
          colors.yellow(
            `plugin-legacy should not be passed to 'worker.plugins'. Pass to 'plugins' instead. Note that generating legacy chunks for workers are not supported by plugin-legacy.`,
          ),
        )
      }
    },
  }

  const legacyGenerateBundlePlugin: Plugin = {
    name: 'vite:legacy-generate-polyfill-chunk',
    apply: 'build',

    async generateBundle(opts, bundle) {
      if (config.build.ssr) {
        return
      }

      const chunkFileNameToPolyfills =
        outputToChunkFileNameToPolyfills.get(opts)
      if (chunkFileNameToPolyfills == null) {
        throw new Error(
          'Internal @vitejs/plugin-legacy error: discovered polyfills should exist',
        )
      }

      if (!isLegacyBundle(bundle, opts)) {
        // Merge discovered modern polyfills to `modernPolyfills`
        for (const { modern } of chunkFileNameToPolyfills.values()) {
          modern.forEach((p) => modernPolyfills.add(p))
        }
        if (!modernPolyfills.size) {
          return
        }
        if (isDebug) {
          console.log(
            `[@vitejs/plugin-legacy] modern polyfills:`,
            modernPolyfills,
          )
        }
        await buildPolyfillChunk(
          config.mode,
          modernPolyfills,
          bundle,
          facadeToModernPolyfillMap,
          config.build,
          'es',
          opts,
          true,
          genLegacy,
        )
        return
      }

      if (!genLegacy) {
        return
      }

      // Merge discovered legacy polyfills to `legacyPolyfills`
      for (const { legacy } of chunkFileNameToPolyfills.values()) {
        legacy.forEach((p) => legacyPolyfills.add(p))
      }

      // legacy bundle
      if (options.polyfills !== false) {
        // check if the target needs Promise polyfill because SystemJS relies on it
        // https://github.com/systemjs/systemjs#ie11-support
        await detectPolyfills(
          `Promise.resolve(); Promise.all();`,
          targets,
          assumptions,
          legacyPolyfills,
        )
      }

      if (legacyPolyfills.size || !options.externalSystemJS) {
        if (isDebug) {
          console.log(
            `[@vitejs/plugin-legacy] legacy polyfills:`,
            legacyPolyfills,
          )
        }

        await buildPolyfillChunk(
          config.mode,
          legacyPolyfills,
          bundle,
          facadeToLegacyPolyfillMap,
          // force using terser for legacy polyfill minification, since esbuild
          // isn't legacy-safe
          config.build,
          'iife',
          opts,
          options.externalSystemJS,
        )
      }
    },
  }

  const legacyPostPlugin: Plugin = {
    name: 'vite:legacy-post-process',
    enforce: 'post',
    apply: 'build',

    renderStart(opts) {
      // Empty the nested map for this output
      outputToChunkFileNameToPolyfills.set(opts, null)
    },

    configResolved(_config) {
      if (_config.build.lib) {
        throw new Error('@vitejs/plugin-legacy does not support library mode.')
      }
      config = _config

      if (isDebug) {
        console.log(`[@vitejs/plugin-legacy] modernTargets:`, modernTargets)
      }

      if (!genLegacy || config.build.ssr) {
        return
      }

      targets =
        options.targets ||
        browserslistLoadConfig({ path: config.root }) ||
        'last 2 versions and not dead, > 0.3%, Firefox ESR'
      if (isDebug) {
        console.log(`[@vitejs/plugin-legacy] targets:`, targets)
      }

      const getLegacyOutputFileName = (
        fileNames:
          | string
          | ((chunkInfo: Rollup.PreRenderedChunk) => string)
          | undefined,
        defaultFileName = '[name]-legacy-[hash].js',
      ): string | ((chunkInfo: Rollup.PreRenderedChunk) => string) => {
        if (!fileNames) {
          return path.posix.join(config.build.assetsDir, defaultFileName)
        }

        return (chunkInfo) => {
          let fileName =
            typeof fileNames === 'function' ? fileNames(chunkInfo) : fileNames

          if (fileName.includes('[name]')) {
            // [name]-[hash].[format] -> [name]-legacy-[hash].[format]
            fileName = fileName.replace('[name]', '[name]-legacy')
          } else if (nonLeadingHashInFileNameRE.test(fileName)) {
            // custom[hash].[format] -> [name]-legacy[hash].[format]
            // custom-[hash].[format] -> [name]-legacy-[hash].[format]
            // custom.[hash].[format] -> [name]-legacy.[hash].[format]
            // custom.[hash:10].[format] -> custom-legacy.[hash:10].[format]
            fileName = fileName.replace(prefixedHashInFileNameRE, '-legacy$&')
          } else {
            // entry.js -> entry-legacy.js
            // entry.min.js -> entry-legacy.min.js
            fileName = fileName.replace(/(.+?)\.(.+)/, '$1-legacy.$2')
          }

          return fileName
        }
      }

      const createLegacyOutput = (
        options: Rollup.OutputOptions = {},
      ): Rollup.OutputOptions => {
        return {
          ...options,
          format: 'system',
          entryFileNames: getLegacyOutputFileName(options.entryFileNames),
          chunkFileNames: getLegacyOutputFileName(options.chunkFileNames),
        }
      }

      const { rollupOptions } = config.build
      const { output } = rollupOptions
      if (Array.isArray(output)) {
        rollupOptions.output = [
          ...output.map(createLegacyOutput),
          ...(genModern ? output : []),
        ]
      } else {
        rollupOptions.output = [
          createLegacyOutput(output),
          ...(genModern ? [output || {}] : []),
        ]
      }
    },

    async renderChunk(raw, chunk, opts, { chunks }) {
      if (config.build.ssr) {
        return null
      }

      // On first run, initialize the map with sorted chunk file names
      let chunkFileNameToPolyfills = outputToChunkFileNameToPolyfills.get(opts)
      if (chunkFileNameToPolyfills == null) {
        chunkFileNameToPolyfills = new Map()
        for (const fileName in chunks) {
          chunkFileNameToPolyfills.set(fileName, {
            modern: new Set(),
            legacy: new Set(),
          })
        }
        outputToChunkFileNameToPolyfills.set(opts, chunkFileNameToPolyfills)
      }
      const polyfillsDiscovered = chunkFileNameToPolyfills.get(chunk.fileName)
      if (polyfillsDiscovered == null) {
        throw new Error(
          `Internal @vitejs/plugin-legacy error: discovered polyfills for ${chunk.fileName} should exist`,
        )
      }

      if (!isLegacyChunk(chunk, opts)) {
        if (
          options.modernPolyfills &&
          !Array.isArray(options.modernPolyfills) &&
          genModern
        ) {
          // analyze and record modern polyfills
          await detectPolyfills(
            raw,
            modernTargets,
            assumptions,
            polyfillsDiscovered.modern,
          )
        }

        const ms = new MagicString(raw)

        if (genLegacy && chunk.isEntry) {
          // append this code to avoid modern chunks running on legacy targeted browsers
          ms.prepend(modernChunkLegacyGuard)
        }

        if (raw.includes(legacyEnvVarMarker)) {
          const re = new RegExp(legacyEnvVarMarker, 'g')
          let match
          while ((match = re.exec(raw))) {
            ms.overwrite(
              match.index,
              match.index + legacyEnvVarMarker.length,
              `false`,
            )
          }
        }

        if (config.build.sourcemap) {
          return {
            code: ms.toString(),
            map: ms.generateMap({ hires: 'boundary' }),
          }
        }
        return {
          code: ms.toString(),
        }
      }

      if (!genLegacy) {
        return null
      }

      // @ts-expect-error avoid esbuild transform on legacy chunks since it produces
      // legacy-unsafe code - e.g. rewriting object properties into shorthands
      opts.__vite_skip_esbuild__ = true

      // @ts-expect-error force terser for legacy chunks. This only takes effect if
      // minification isn't disabled, because that leaves out the terser plugin
      // entirely.
      opts.__vite_force_terser__ = true

      // @ts-expect-error In the `generateBundle` hook,
      // we'll delete the assets from the legacy bundle to avoid emitting duplicate assets.
      // But that's still a waste of computing resource.
      // So we add this flag to avoid emitting the asset in the first place whenever possible.
      opts.__vite_skip_asset_emit__ = true

      // avoid emitting assets for legacy bundle
      const needPolyfills =
        options.polyfills !== false && !Array.isArray(options.polyfills)

      // transform the legacy chunk with @babel/preset-env
      const sourceMaps = !!config.build.sourcemap
      const babel = await loadBabel()
      const result = babel.transform(raw, {
        babelrc: false,
        configFile: false,
        compact: !!config.build.minify,
        sourceMaps,
        inputSourceMap: undefined,
        targets,
        assumptions,
        browserslistConfigFile: false,
        presets: [
          // forcing our plugin to run before preset-env by wrapping it in a
          // preset so we can catch the injected import statements...
          [
            () => ({
              plugins: [
                recordAndRemovePolyfillBabelPlugin(polyfillsDiscovered.legacy),
                replaceLegacyEnvBabelPlugin(),
                wrapIIFEBabelPlugin(),
              ],
            }),
          ],
          [
            (await import('@babel/preset-env')).default,
            {
              bugfixes: true,
              modules: false,
              useBuiltIns: needPolyfills ? 'usage' : false,
              corejs: needPolyfills
                ? {
                    version: _require('core-js/package.json').version,
                    proposals: false,
                  }
                : undefined,
              shippedProposals: true,
            },
          ],
        ],
      })

      if (result) return { code: result.code!, map: result.map }
      return null
    },

    transformIndexHtml(html, { chunk }) {
      if (config.build.ssr) return
      if (!chunk) return
      if (chunk.fileName.includes('-legacy')) {
        // The legacy bundle is built first, and its index.html isn't actually emitted if
        // modern bundle will be generated. Here we simply record its corresponding legacy chunk.
        facadeToLegacyChunkMap.set(chunk.facadeModuleId, chunk.fileName)
        if (genModern) {
          return
        }
      }
      if (!genModern) {
        html = html.replace(/<script type="module".*?<\/script>/g, '')
      }

      const tags: HtmlTagDescriptor[] = []
      const htmlFilename = chunk.facadeModuleId?.replace(/\?.*$/, '')

      // 1. inject modern polyfills
      if (genModern) {
        const modernPolyfillFilename = facadeToModernPolyfillMap.get(
          chunk.facadeModuleId,
        )

        if (modernPolyfillFilename) {
          tags.push({
            tag: 'script',
            attrs: {
              type: 'module',
              crossorigin: true,
              src: toAssetPathFromHtml(
                modernPolyfillFilename,
                chunk.facadeModuleId!,
                config,
              ),
            },
          })
        } else if (modernPolyfills.size) {
          throw new Error(
            `No corresponding modern polyfill chunk found for ${htmlFilename}`,
          )
        }
      }

      if (!genLegacy) {
        return { html, tags }
      }

      // 2. inject Safari 10 nomodule fix
      if (genModern) {
        tags.push({
          tag: 'script',
          attrs: { nomodule: genModern },
          children: safari10NoModuleFix,
          injectTo: 'body',
        })
      }

      // 3. inject legacy polyfills
      const legacyPolyfillFilename = facadeToLegacyPolyfillMap.get(
        chunk.facadeModuleId,
      )
      if (legacyPolyfillFilename) {
        tags.push({
          tag: 'script',
          attrs: {
            nomodule: genModern,
            crossorigin: true,
            id: legacyPolyfillId,
            src: toAssetPathFromHtml(
              legacyPolyfillFilename,
              chunk.facadeModuleId!,
              config,
            ),
          },
          injectTo: 'body',
        })
      } else if (legacyPolyfills.size) {
        throw new Error(
          `No corresponding legacy polyfill chunk found for ${htmlFilename}`,
        )
      }

      // 4. inject legacy entry
      const legacyEntryFilename = facadeToLegacyChunkMap.get(
        chunk.facadeModuleId,
      )
      if (legacyEntryFilename) {
        // `assets/foo.js` means importing "named register" in SystemJS
        tags.push({
          tag: 'script',
          attrs: {
            nomodule: genModern,
            crossorigin: true,
            // we set the entry path on the element as an attribute so that the
            // script content will stay consistent - which allows using a constant
            // hash value for CSP.
            id: legacyEntryId,
            'data-src': toAssetPathFromHtml(
              legacyEntryFilename,
              chunk.facadeModuleId!,
              config,
            ),
          },
          children: systemJSInlineCode,
          injectTo: 'body',
        })
      } else {
        throw new Error(
          `No corresponding legacy entry chunk found for ${htmlFilename}`,
        )
      }

      // 5. inject dynamic import fallback entry
      if (legacyPolyfillFilename && legacyEntryFilename && genModern) {
        tags.push({
          tag: 'script',
          attrs: { type: 'module' },
          children: detectModernBrowserCode,
          injectTo: 'head',
        })
        tags.push({
          tag: 'script',
          attrs: { type: 'module' },
          children: dynamicFallbackInlineCode,
          injectTo: 'head',
        })
      }

      return {
        html,
        tags,
      }
    },

    generateBundle(opts, bundle) {
      if (config.build.ssr) {
        return
      }

      if (isLegacyBundle(bundle, opts) && genModern) {
        // avoid emitting duplicate assets
        for (const name in bundle) {
          if (bundle[name].type === 'asset' && !name.endsWith('.map')) {
            delete bundle[name]
          }
        }
      }
    },
  }

  return [legacyConfigPlugin, legacyGenerateBundlePlugin, legacyPostPlugin]
}

export async function detectPolyfills(
  code: string,
  targets: any,
  assumptions: Record<string, boolean>,
  list: Set<string>,
): Promise<void> {
  const babel = await loadBabel()
  const result = babel.transform(code, {
    ast: true,
    code: false,
    babelrc: false,
    configFile: false,
    compact: false,
    targets,
    assumptions,
    browserslistConfigFile: false,
    plugins: [
      [
        (await import('babel-plugin-polyfill-corejs3')).default,
        {
          method: 'usage-global',
          version: _require('core-js/package.json').version,
          shippedProposals: true,
        },
      ],
      [
        (await import('babel-plugin-polyfill-regenerator')).default,
        {
          method: 'usage-global',
        },
      ],
    ],
  })
  for (const node of result!.ast!.program.body) {
    if (node.type === 'ImportDeclaration') {
      const source = node.source.value
      if (
        source.startsWith('core-js/') ||
        source.startsWith('regenerator-runtime/')
      ) {
        list.add(source)
      }
    }
  }
}

async function buildPolyfillChunk(
  mode: string,
  imports: Set<string>,
  bundle: Rollup.OutputBundle,
  facadeToChunkMap: Map<string, string>,
  buildOptions: BuildOptions,
  format: 'iife' | 'es',
  rollupOutputOptions: Rollup.NormalizedOutputOptions,
  excludeSystemJS?: boolean,
  prependModenChunkLegacyGuard?: boolean,
) {
  let { minify, assetsDir, sourcemap } = buildOptions
  minify = minify ? 'terser' : false
  const res = await build({
    mode,
    // so that everything is resolved from here
    root: path.dirname(fileURLToPath(import.meta.url)),
    configFile: false,
    logLevel: 'error',
    plugins: [
      polyfillsPlugin(imports, excludeSystemJS),
      prependModenChunkLegacyGuard && prependModenChunkLegacyGuardPlugin(),
    ],
    build: {
      write: false,
      minify,
      assetsDir,
      sourcemap,
      rollupOptions: {
        input: {
          polyfills: polyfillId,
        },
        output: {
          format,
          hashCharacters: rollupOutputOptions.hashCharacters,
          entryFileNames: rollupOutputOptions.entryFileNames,
          sourcemapBaseUrl: rollupOutputOptions.sourcemapBaseUrl,
        },
      },
    },
    // Don't run esbuild for transpilation or minification
    // because we don't want to transpile code.
    esbuild: false,
    optimizeDeps: {
      esbuildOptions: {
        // If a value above 'es5' is set, esbuild injects helper functions which uses es2015 features.
        // This limits the input code not to include es2015+ codes.
        // But core-js is the only dependency which includes commonjs code
        // and core-js doesn't include es2015+ codes.
        target: 'es5',
      },
    },
  })
  const _polyfillChunk = Array.isArray(res) ? res[0] : res
  if (!('output' in _polyfillChunk)) return
  const polyfillChunk = _polyfillChunk.output.find(
    (chunk) => chunk.type === 'chunk' && chunk.isEntry,
  ) as Rollup.OutputChunk

  // associate the polyfill chunk to every entry chunk so that we can retrieve
  // the polyfill filename in index html transform
  for (const key in bundle) {
    const chunk = bundle[key]
    if (chunk.type === 'chunk' && chunk.facadeModuleId) {
      facadeToChunkMap.set(chunk.facadeModuleId, polyfillChunk.fileName)
    }
  }

  // add the chunk to the bundle
  bundle[polyfillChunk.fileName] = polyfillChunk
  if (polyfillChunk.sourcemapFileName) {
    const polyfillChunkMapAsset = _polyfillChunk.output.find(
      (chunk) =>
        chunk.type === 'asset' &&
        chunk.fileName === polyfillChunk.sourcemapFileName,
    ) as Rollup.OutputAsset | undefined
    if (polyfillChunkMapAsset) {
      bundle[polyfillChunk.sourcemapFileName] = polyfillChunkMapAsset
    }
  }
}

const polyfillId = '\0vite/legacy-polyfills'

function polyfillsPlugin(
  imports: Set<string>,
  excludeSystemJS?: boolean,
): Plugin {
  return {
    name: 'vite:legacy-polyfills',
    resolveId(id) {
      if (id === polyfillId) {
        return id
      }
    },
    load(id) {
      if (id === polyfillId) {
        return (
          [...imports].map((i) => `import ${JSON.stringify(i)};`).join('') +
          (excludeSystemJS ? '' : `import "systemjs/dist/s.min.js";`)
        )
      }
    },
  }
}

function prependModenChunkLegacyGuardPlugin(): Plugin {
  let sourceMapEnabled!: boolean
  return {
    name: 'vite:legacy-prepend-moden-chunk-legacy-guard',
    configResolved(config) {
      sourceMapEnabled = !!config.build.sourcemap
    },
    renderChunk(code) {
      if (!sourceMapEnabled) {
        return modernChunkLegacyGuard + code
      }

      const ms = new MagicString(code)
      ms.prepend(modernChunkLegacyGuard)
      return {
        code: ms.toString(),
        map: ms.generateMap({ hires: 'boundary' }),
      }
    },
  }
}

function isLegacyChunk(
  chunk: Rollup.RenderedChunk,
  options: Rollup.NormalizedOutputOptions,
) {
  return options.format === 'system' && chunk.fileName.includes('-legacy')
}

function isLegacyBundle(
  bundle: Rollup.OutputBundle,
  options: Rollup.NormalizedOutputOptions,
) {
  if (options.format === 'system') {
    const entryChunk = Object.values(bundle).find(
      (output) => output.type === 'chunk' && output.isEntry,
    )

    return !!entryChunk && entryChunk.fileName.includes('-legacy')
  }

  return false
}

function recordAndRemovePolyfillBabelPlugin(
  polyfills: Set<string>,
): BabelPlugin {
  return ({ types: t }: { types: typeof BabelTypes }): BabelPlugin => ({
    name: 'vite-remove-polyfill-import',
    post({ path }) {
      path.get('body').forEach((p) => {
        if (t.isImportDeclaration(p.node)) {
          polyfills.add(p.node.source.value)
          p.remove()
        }
      })
    },
  })
}

function replaceLegacyEnvBabelPlugin(): BabelPlugin {
  return ({ types: t }): BabelPlugin => ({
    name: 'vite-replace-env-legacy',
    visitor: {
      Identifier(path) {
        if (path.node.name === legacyEnvVarMarker) {
          path.replaceWith(t.booleanLiteral(true))
        }
      },
    },
  })
}

function wrapIIFEBabelPlugin(): BabelPlugin {
  return ({ types: t, template }): BabelPlugin => {
    const buildIIFE = template(';(function(){%%body%%})();')

    return {
      name: 'vite-wrap-iife',
      post({ path }) {
        if (!this.isWrapped) {
          this.isWrapped = true
          path.replaceWith(t.program(buildIIFE({ body: path.node.body })))
        }
      },
    }
  }
}

export const cspHashes = [
  safari10NoModuleFix,
  systemJSInlineCode,
  detectModernBrowserCode,
  dynamicFallbackInlineCode,
].map((i) => crypto.hash('sha256', i, 'base64'))

export type { Options }

export default viteLegacyPlugin

// Compat for require
function viteLegacyPluginCjs(this: unknown, options: Options): Plugin[] {
  return viteLegacyPlugin.call(this, options)
}
Object.assign(viteLegacyPluginCjs, {
  cspHashes,
  default: viteLegacyPluginCjs,
  detectPolyfills,
})

export { viteLegacyPluginCjs as 'module.exports' }



================================================
FILE: packages/plugin-legacy/src/shims.d.ts
================================================
declare module 'babel-plugin-polyfill-corejs3'

declare module 'babel-plugin-polyfill-regenerator'



================================================
FILE: packages/plugin-legacy/src/snippets.ts
================================================
// https://gist.github.com/samthor/64b114e4a4f539915a95b91ffd340acc
// DO NOT ALTER THIS CONTENT
export const safari10NoModuleFix = `!function(){var e=document,t=e.createElement("script");if(!("noModule"in t)&&"onbeforeload"in t){var n=!1;e.addEventListener("beforeload",(function(e){if(e.target===t)n=!0;else if(!e.target.hasAttribute("nomodule")||!n)return;e.preventDefault()}),!0),t.type="module",t.src=".",e.head.appendChild(t),t.remove()}}();`

export const legacyPolyfillId = 'vite-legacy-polyfill'
export const legacyEntryId = 'vite-legacy-entry'
export const systemJSInlineCode = `System.import(document.getElementById('${legacyEntryId}').getAttribute('data-src'))`

const detectModernBrowserVarName = '__vite_is_modern_browser'
export const detectModernBrowserDetector = `import.meta.url;import("_").catch(()=>1);(async function*(){})().next()`
export const detectModernBrowserCode = `${detectModernBrowserDetector};window.${detectModernBrowserVarName}=true`
export const dynamicFallbackInlineCode = `!function(){if(window.${detectModernBrowserVarName})return;console.warn("vite: loading legacy chunks, syntax error above and the same error below should be ignored");var e=document.getElementById("${legacyPolyfillId}"),n=document.createElement("script");n.src=e.src,n.onload=function(){${systemJSInlineCode}},document.body.appendChild(n)}();`

export const modernChunkLegacyGuard = `export function __vite_legacy_guard(){${detectModernBrowserDetector}};`



================================================
FILE: packages/plugin-legacy/src/types.ts
================================================
export interface Options {
  /**
   * default: 'defaults'
   */
  targets?: string | string[] | Record<string, string>
  /**
   * default: 'edge>=79, firefox>=67, chrome>=64, safari>=12, chromeAndroid>=64, iOS>=12'
   */
  modernTargets?: string | string[]
  /**
   * default: true
   */
  polyfills?: boolean | string[]
  additionalLegacyPolyfills?: string[]
  additionalModernPolyfills?: string[]
  /**
   * default: false
   */
  modernPolyfills?: boolean | string[]
  /**
   * default: true
   */
  renderLegacyChunks?: boolean
  /**
   * default: false
   */
  externalSystemJS?: boolean
  /**
   * default: true
   */
  renderModernChunks?: boolean
  /**
   * @see https://babeljs.io/docs/assumptions
   *
   * default: {}
   */
  assumptions?: Record<string, boolean>
}



================================================
FILE: packages/plugin-legacy/src/__tests__/readme.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { expect, test } from 'vitest'
import { cspHashes } from '..'

test('CSP hashes in README.md should be correct', () => {
  const readme = fs.readFileSync(
    path.resolve(__dirname, '../../README.md'),
    'utf-8',
  )
  const hashesInDoc = [...readme.matchAll(/`sha256-(.+)`/g)].map(
    (match) => match[1],
  )

  expect(hashesInDoc).toStrictEqual(cspHashes)
})



================================================
FILE: packages/plugin-legacy/src/__tests__/snippets.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import type { ecmaVersion } from 'acorn'
import { parse } from 'acorn'
import {
  detectModernBrowserCode,
  detectModernBrowserDetector,
  dynamicFallbackInlineCode,
  safari10NoModuleFix,
  systemJSInlineCode,
} from '../snippets'

const shouldFailVersions: ecmaVersion[] = []
for (let v = 2015; v <= 2019; v++) {
  shouldFailVersions.push(v as ecmaVersion)
}

const shouldPassVersions: ecmaVersion[] = []
for (let v = 2020; v <= 2024; v++) {
  shouldPassVersions.push(v as ecmaVersion)
}

for (const version of shouldFailVersions) {
  test(`detect code should not be able to be parsed with ES${version}`, () => {
    expect(() => {
      parse(detectModernBrowserDetector, {
        ecmaVersion: version,
        sourceType: 'module',
      })
    }).toThrow()
  })
}

for (const version of shouldPassVersions) {
  test(`detect code should be able to be parsed with ES${version}`, () => {
    expect(() => {
      parse(detectModernBrowserDetector, {
        ecmaVersion: version,
        sourceType: 'module',
      })
    }).not.toThrow()
  })
}

describe('snippets are valid', () => {
  const codes = {
    safari10NoModuleFix,
    systemJSInlineCode,
    detectModernBrowserCode,
    dynamicFallbackInlineCode,
  }

  for (const [name, value] of Object.entries(codes)) {
    test(`${name} is valid JS`, () => {
      expect(() => {
        parse(value, {
          ecmaVersion: 'latest',
          sourceType: 'module',
        })
      }).not.toThrow()
    })
  }
})



================================================
FILE: packages/plugin-legacy/types/legacy-for-rolldown-vite.d.ts
================================================
import type { Plugin } from 'vite'
import type { Options } from '../src/types'

declare const plugin: (options?: Options) => Plugin[]
export default plugin



================================================
FILE: packages/vite/README.md
================================================
# vite ⚡

> Next Generation Frontend Tooling

- 💡 Instant Server Start
- ⚡️ Lightning Fast HMR
- 🛠️ Rich Features
- 📦 Optimized Build
- 🔩 Universal Plugin Interface
- 🔑 Fully Typed APIs

Vite (French word for "fast", pronounced `/vit/`) is a new breed of frontend build tool that significantly improves the frontend development experience. It consists of two major parts:

- A dev server that serves your source files over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), with [rich built-in features](https://vite.dev/guide/features.html) and astonishingly fast [Hot Module Replacement (HMR)](https://vite.dev/guide/features.html#hot-module-replacement).

- A [build command](https://vite.dev/guide/build.html) that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.

In addition, Vite is highly extensible via its [Plugin API](https://vite.dev/guide/api-plugin.html) and [JavaScript API](https://vite.dev/guide/api-javascript.html) with full typing support.

[Read the Docs to Learn More](https://vite.dev).



================================================
FILE: packages/vite/client.d.ts
================================================
/// <reference path="./types/importMeta.d.ts" />

// CSS modules
type CSSModuleClasses = { readonly [key: string]: string }

declare module '*.module.css' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.scss' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.sass' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.less' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.styl' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.stylus' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.pcss' {
  const classes: CSSModuleClasses
  export default classes
}
declare module '*.module.sss' {
  const classes: CSSModuleClasses
  export default classes
}

// CSS
declare module '*.css' {}
declare module '*.scss' {}
declare module '*.sass' {}
declare module '*.less' {}
declare module '*.styl' {}
declare module '*.stylus' {}
declare module '*.pcss' {}
declare module '*.sss' {}

// Built-in asset types
// see `src/node/constants.ts`

// images
declare module '*.apng' {
  const src: string
  export default src
}
declare module '*.bmp' {
  const src: string
  export default src
}
declare module '*.png' {
  const src: string
  export default src
}
declare module '*.jpg' {
  const src: string
  export default src
}
declare module '*.jpeg' {
  const src: string
  export default src
}
declare module '*.jfif' {
  const src: string
  export default src
}
declare module '*.pjpeg' {
  const src: string
  export default src
}
declare module '*.pjp' {
  const src: string
  export default src
}
declare module '*.gif' {
  const src: string
  export default src
}
declare module '*.svg' {
  const src: string
  export default src
}
declare module '*.ico' {
  const src: string
  export default src
}
declare module '*.webp' {
  const src: string
  export default src
}
declare module '*.avif' {
  const src: string
  export default src
}
declare module '*.cur' {
  const src: string
  export default src
}
declare module '*.jxl' {
  const src: string
  export default src
}

// media
declare module '*.mp4' {
  const src: string
  export default src
}
declare module '*.webm' {
  const src: string
  export default src
}
declare module '*.ogg' {
  const src: string
  export default src
}
declare module '*.mp3' {
  const src: string
  export default src
}
declare module '*.wav' {
  const src: string
  export default src
}
declare module '*.flac' {
  const src: string
  export default src
}
declare module '*.aac' {
  const src: string
  export default src
}
declare module '*.opus' {
  const src: string
  export default src
}
declare module '*.mov' {
  const src: string
  export default src
}
declare module '*.m4a' {
  const src: string
  export default src
}
declare module '*.vtt' {
  const src: string
  export default src
}

// fonts
declare module '*.woff' {
  const src: string
  export default src
}
declare module '*.woff2' {
  const src: string
  export default src
}
declare module '*.eot' {
  const src: string
  export default src
}
declare module '*.ttf' {
  const src: string
  export default src
}
declare module '*.otf' {
  const src: string
  export default src
}

// other
declare module '*.webmanifest' {
  const src: string
  export default src
}
declare module '*.pdf' {
  const src: string
  export default src
}
declare module '*.txt' {
  const src: string
  export default src
}

// wasm?init
declare module '*.wasm?init' {
  const initWasm: (
    options?: WebAssembly.Imports,
  ) => Promise<WebAssembly.Instance>
  export default initWasm
}

// web worker
declare module '*?worker' {
  const workerConstructor: {
    new (options?: { name?: string }): Worker
  }
  export default workerConstructor
}

declare module '*?worker&inline' {
  const workerConstructor: {
    new (options?: { name?: string }): Worker
  }
  export default workerConstructor
}

declare module '*?worker&url' {
  const src: string
  export default src
}

declare module '*?sharedworker' {
  const sharedWorkerConstructor: {
    new (options?: { name?: string }): SharedWorker
  }
  export default sharedWorkerConstructor
}

declare module '*?sharedworker&inline' {
  const sharedWorkerConstructor: {
    new (options?: { name?: string }): SharedWorker
  }
  export default sharedWorkerConstructor
}

declare module '*?sharedworker&url' {
  const src: string
  export default src
}

declare module '*?raw' {
  const src: string
  export default src
}

declare module '*?url' {
  const src: string
  export default src
}

declare module '*?inline' {
  const src: string
  export default src
}

declare module '*?no-inline' {
  const src: string
  export default src
}

declare module '*?url&inline' {
  const src: string
  export default src
}

declare module '*?url&no-inline' {
  const src: string
  export default src
}

declare interface VitePreloadErrorEvent extends Event {
  payload: Error
}

declare interface WindowEventMap {
  'vite:preloadError': VitePreloadErrorEvent
}



================================================
FILE: packages/vite/package.json
================================================
{
  "name": "vite",
  "version": "7.1.2",
  "type": "module",
  "license": "MIT",
  "author": "Evan You",
  "description": "Native-ESM powered web dev build tool",
  "bin": {
    "vite": "bin/vite.js"
  },
  "keywords": [
    "frontend",
    "framework",
    "hmr",
    "dev-server",
    "build-tool",
    "vite"
  ],
  "main": "./dist/node/index.js",
  "types": "./dist/node/index.d.ts",
  "exports": {
    ".": "./dist/node/index.js",
    "./client": {
      "types": "./client.d.ts"
    },
    "./module-runner": "./dist/node/module-runner.js",
    "./dist/client/*": "./dist/client/*",
    "./types/*": {
      "types": "./types/*"
    },
    "./types/internal/*": null,
    "./package.json": "./package.json"
  },
  "typesVersions": {
    "*": {
      "module-runner": [
        "dist/node/module-runner.d.ts"
      ]
    }
  },
  "imports": {
    "#module-sync-enabled": {
      "module-sync": "./misc/true.js",
      "default": "./misc/false.js"
    }
  },
  "files": [
    "bin",
    "dist",
    "misc/**/*.js",
    "client.d.ts",
    "index.cjs",
    "index.d.cts",
    "types"
  ],
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitejs/vite.git",
    "directory": "packages/vite"
  },
  "bugs": {
    "url": "https://github.com/vitejs/vite/issues"
  },
  "homepage": "https://vite.dev",
  "funding": "https://github.com/vitejs/vite?sponsor=1",
  "scripts": {
    "dev": "premove dist && pnpm build-bundle -w",
    "build": "premove dist && pnpm build-bundle && pnpm build-types",
    "build-bundle": "rolldown --config rolldown.config.ts",
    "build-types": "pnpm build-types-roll && pnpm build-types-check",
    "build-types-roll": "rolldown --config rolldown.dts.config.ts",
    "build-types-check": "tsc --project tsconfig.check.json",
    "typecheck": "tsc && tsc -p src/node",
    "lint": "eslint --cache --ext .ts src/**",
    "format": "prettier --write --cache --parser typescript \"src/**/*.ts\"",
    "generate-target": "tsx scripts/generateTarget.ts",
    "prepublishOnly": "npm run build"
  },
  "//": "READ CONTRIBUTING.md to understand what to put under deps vs. devDeps!",
  "dependencies": {
    "esbuild": "^0.25.0",
    "fdir": "^6.4.6",
    "picomatch": "^4.0.3",
    "postcss": "^8.5.6",
    "rollup": "^4.43.0",
    "tinyglobby": "^0.2.14"
  },
  "optionalDependencies": {
    "fsevents": "~2.3.3"
  },
  "devDependencies": {
    "@babel/parser": "^7.28.0",
    "@jridgewell/remapping": "^2.3.4",
    "@jridgewell/trace-mapping": "^0.3.29",
    "@oxc-project/types": "0.77.0",
    "@polka/compression": "^1.0.0-next.25",
    "@rolldown/pluginutils": "^1.0.0-beta.32",
    "@rollup/plugin-alias": "^5.1.1",
    "@rollup/plugin-commonjs": "^28.0.6",
    "@rollup/plugin-dynamic-import-vars": "2.1.4",
    "@rollup/pluginutils": "^5.2.0",
    "@types/escape-html": "^1.0.4",
    "@types/pnpapi": "^0.0.5",
    "artichokie": "^0.3.2",
    "baseline-browser-mapping": "^2.6.3",
    "cac": "^6.7.14",
    "chokidar": "^3.6.0",
    "connect": "^3.7.0",
    "convert-source-map": "^2.0.0",
    "cors": "^2.8.5",
    "cross-spawn": "^7.0.6",
    "debug": "^4.4.1",
    "dep-types": "link:./src/types",
    "dotenv": "^17.2.1",
    "dotenv-expand": "^12.0.2",
    "es-module-lexer": "^1.7.0",
    "escape-html": "^1.0.3",
    "estree-walker": "^3.0.3",
    "etag": "^1.8.1",
    "host-validation-middleware": "^0.1.1",
    "http-proxy-3": "^1.20.10",
    "launch-editor-middleware": "^2.11.1",
    "lightningcss": "^1.30.1",
    "magic-string": "^0.30.17",
    "mlly": "^1.7.4",
    "mrmime": "^2.0.1",
    "nanoid": "^5.1.5",
    "open": "^10.2.0",
    "parse5": "^8.0.0",
    "pathe": "^2.0.3",
    "periscopic": "^4.0.2",
    "picocolors": "^1.1.1",
    "postcss-import": "^16.1.1",
    "postcss-load-config": "^6.0.1",
    "postcss-modules": "^6.0.1",
    "premove": "^4.0.0",
    "resolve.exports": "^2.0.3",
    "rolldown": "^1.0.0-beta.31",
    "rolldown-plugin-dts": "^0.15.6",
    "rollup-plugin-license": "^3.6.0",
    "sass": "^1.90.0",
    "sass-embedded": "^1.90.0",
    "sirv": "^3.0.1",
    "strip-literal": "^3.0.0",
    "terser": "^5.43.1",
    "tsconfck": "^3.1.6",
    "types": "link:./types",
    "ufo": "^1.6.1",
    "ws": "^8.18.3"
  },
  "peerDependencies": {
    "@types/node": "^20.19.0 || >=22.12.0",
    "jiti": ">=1.21.0",
    "less": "^4.0.0",
    "lightningcss": "^1.21.0",
    "sass": "^1.70.0",
    "sass-embedded": "^1.70.0",
    "stylus": ">=0.54.8",
    "sugarss": "^5.0.0",
    "terser": "^5.16.0",
    "tsx": "^4.8.1",
    "yaml": "^2.4.2"
  },
  "peerDependenciesMeta": {
    "@types/node": {
      "optional": true
    },
    "jiti": {
      "optional": true
    },
    "sass": {
      "optional": true
    },
    "sass-embedded": {
      "optional": true
    },
    "stylus": {
      "optional": true
    },
    "less": {
      "optional": true
    },
    "sugarss": {
      "optional": true
    },
    "lightningcss": {
      "optional": true
    },
    "terser": {
      "optional": true
    },
    "tsx": {
      "optional": true
    },
    "yaml": {
      "optional": true
    }
  }
}



================================================
FILE: packages/vite/rolldown.config.ts
================================================
import { readFileSync, writeFileSync } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import MagicString from 'magic-string'
import type { Plugin } from 'rolldown'
import { defineConfig } from 'rolldown'
import { init, parse } from 'es-module-lexer'
import licensePlugin from './rollupLicensePlugin'

const pkg = JSON.parse(
  readFileSync(new URL('./package.json', import.meta.url)).toString(),
)
const __dirname = fileURLToPath(new URL('.', import.meta.url))
const disableSourceMap = !!process.env.DEBUG_DISABLE_SOURCE_MAP

const envConfig = defineConfig({
  input: path.resolve(__dirname, 'src/client/env.ts'),
  platform: 'browser',
  transform: {
    target: 'es2020',
  },
  output: {
    dir: path.resolve(__dirname, 'dist'),
    entryFileNames: 'client/env.mjs',
  },
})

const clientConfig = defineConfig({
  input: path.resolve(__dirname, 'src/client/client.ts'),
  platform: 'browser',
  transform: {
    target: 'es2020',
  },
  external: ['@vite/env'],
  output: {
    dir: path.resolve(__dirname, 'dist'),
    entryFileNames: 'client/client.mjs',
  },
})

const sharedNodeOptions = defineConfig({
  platform: 'node',
  treeshake: {
    moduleSideEffects: [
      {
        test: /acorn|astring|escape-html/,
        sideEffects: false,
      },
      {
        external: true,
        sideEffects: false,
      },
    ],
    // TODO: not supported yet
    // propertyReadSideEffects: false,
  },
  output: {
    dir: './dist',
    entryFileNames: `node/[name].js`,
    chunkFileNames: 'node/chunks/dep-[hash].js',
    exports: 'named',
    format: 'esm',
    externalLiveBindings: false,
  },
  onwarn(warning, warn) {
    if (warning.message.includes('Circular dependency')) {
      return
    }
    warn(warning)
  },
})

const nodeConfig = defineConfig({
  ...sharedNodeOptions,
  input: {
    index: path.resolve(__dirname, 'src/node/index.ts'),
    cli: path.resolve(__dirname, 'src/node/cli.ts'),
    constants: path.resolve(__dirname, 'src/node/constants.ts'),
  },
  resolve: {
    alias: {
      // we can always use node version (the default entry point has browser support)
      debug: 'debug/src/node.js',
    },
  },
  output: {
    ...sharedNodeOptions.output,
    // When polyfillRequire is enabled, `require` gets renamed by rolldown.
    // But the current usage of require() inside inlined workers expects `require`
    // to not be renamed. To workaround, polyfillRequire is disabled and
    // the banner is used instead.
    // Ideally we should move workers to ESM
    polyfillRequire: false,
    banner:
      "import { createRequire as ___createRequire } from 'module'; const require = ___createRequire(import.meta.url);",
  },
  external: [
    /^vite\//,
    'fsevents',
    'rollup/parseAst',
    /^tsx\//,
    /^#/,
    'sugarss', // postcss-import -> sugarss
    'supports-color',
    'utf-8-validate', // ws
    'bufferutil', // ws
    ...Object.keys(pkg.dependencies),
    ...Object.keys(pkg.peerDependencies),
  ],
  plugins: [
    shimDepsPlugin({
      'postcss-load-config/src/req.js': [
        {
          src: "const { pathToFileURL } = require('node:url')",
          replacement: `const { fileURLToPath, pathToFileURL } = require('node:url')`,
        },
        {
          src: '__filename',
          replacement: 'fileURLToPath(import.meta.url)',
        },
      ],
      // postcss-import uses the `resolve` dep if the `resolve` option is not passed.
      // However, we always pass the `resolve` option. It also uses `read-cache` if
      // the `load` option is not passed, but we also always pass the `load` option.
      // Remove these two imports to avoid bundling them.
      'postcss-import/index.js': [
        {
          src: 'const resolveId = require("./lib/resolve-id")',
          replacement: 'const resolveId = (id) => id',
        },
        {
          src: 'const loadContent = require("./lib/load-content")',
          replacement: 'const loadContent = () => ""',
        },
      ],
      'postcss-import/lib/parse-styles.js': [
        {
          src: 'const resolveId = require("./resolve-id")',
          replacement: 'const resolveId = (id) => id',
        },
      ],
    }),
    buildTimeImportMetaUrlPlugin(),
    licensePlugin(
      path.resolve(__dirname, 'LICENSE.md'),
      'Vite core license',
      'Vite',
    ),
    writeTypesPlugin(),
    enableSourceMapsInWatchModePlugin(),
    externalizeDepsInWatchPlugin(),
  ],
})

const moduleRunnerConfig = defineConfig({
  ...sharedNodeOptions,
  input: {
    'module-runner': path.resolve(__dirname, 'src/module-runner/index.ts'),
  },
  external: [
    'fsevents',
    'lightningcss',
    'rollup/parseAst',
    ...Object.keys(pkg.dependencies),
  ],
  plugins: [bundleSizeLimit(54), enableSourceMapsInWatchModePlugin()],
  output: {
    ...sharedNodeOptions.output,
    minify: {
      compress: true,
      mangle: false,
      removeWhitespace: false,
    },
  },
})

export default defineConfig([
  envConfig,
  clientConfig,
  nodeConfig,
  moduleRunnerConfig,
])

// #region Plugins

function enableSourceMapsInWatchModePlugin(): Plugin {
  return {
    name: 'enable-source-maps',
    outputOptions(options) {
      if (this.meta.watchMode && !disableSourceMap) {
        options.sourcemap = 'inline'
      }
    },
  }
}

function writeTypesPlugin(): Plugin {
  return {
    name: 'write-types',
    async writeBundle() {
      if (this.meta.watchMode) {
        writeFileSync(
          'dist/node/index.d.ts',
          "export * from '../../src/node/index.ts'",
        )
        writeFileSync(
          'dist/node/module-runner.d.ts',
          "export * from '../../src/module-runner/index.ts'",
        )
      }
    },
  }
}

function externalizeDepsInWatchPlugin(): Plugin {
  return {
    name: 'externalize-deps-in-watch',
    options(options) {
      if (this.meta.watchMode) {
        options.external ||= []
        if (!Array.isArray(options.external))
          throw new Error('external must be an array')
        options.external = options.external.concat(
          Object.keys(pkg.devDependencies),
        )
      }
    },
  }
}

interface ShimOptions {
  src?: string
  replacement: string
  pattern?: RegExp
}

function shimDepsPlugin(deps: Record<string, ShimOptions[]>): Plugin {
  const transformed: Record<string, boolean> = {}

  return {
    name: 'shim-deps',
    transform: {
      filter: {
        id: new RegExp(`(?:${Object.keys(deps).join('|')})$`),
      },
      handler(code, id) {
        const file = Object.keys(deps).find((file) =>
          id.replace(/\\/g, '/').endsWith(file),
        )
        if (!file) return

        for (const { src, replacement, pattern } of deps[file]) {
          const magicString = new MagicString(code)

          if (src) {
            const pos = code.indexOf(src)
            if (pos < 0) {
              this.error(
                `Could not find expected src "${src}" in file "${file}"`,
              )
            }
            transformed[file] = true
            magicString.overwrite(pos, pos + src.length, replacement)
          }

          if (pattern) {
            let match
            while ((match = pattern.exec(code))) {
              transformed[file] = true
              const start = match.index
              const end = start + match[0].length
              let _replacement = replacement
              for (let i = 1; i <= match.length; i++) {
                _replacement = _replacement.replace(`$${i}`, match[i] || '')
              }
              magicString.overwrite(start, end, _replacement)
            }
            if (!transformed[file]) {
              this.error(
                `Could not find expected pattern "${pattern}" in file "${file}"`,
              )
            }
          }

          code = magicString.toString()
        }

        console.log(`shimmed: ${file}`)

        return code
      },
    },
    buildEnd(err) {
      if (this.meta.watchMode) return

      if (!err) {
        for (const file in deps) {
          if (!transformed[file]) {
            this.error(
              `Did not find "${file}" which is supposed to be shimmed, was the file renamed?`,
            )
          }
        }
      }
    },
  }
}

function buildTimeImportMetaUrlPlugin(): Plugin {
  const idMap: Record<string, number> = {}
  let lastIndex = 0

  const prefix = `__vite_buildTimeImportMetaUrl_`
  const keepCommentRE = /\/\*\*\s*[#@]__KEEP__\s*\*\/\s*$/

  return {
    name: 'import-meta-current-dirname',
    transform: {
      filter: {
        code: 'import.meta.url',
      },
      async handler(code, id) {
        const relativeId = path.relative(__dirname, id).replaceAll('\\', '/')
        // only replace import.meta.url in src/
        if (!relativeId.startsWith('src/')) return

        let index: number
        if (idMap[id]) {
          index = idMap[id]
        } else {
          index = idMap[id] = lastIndex
          lastIndex++
        }

        await init

        const s = new MagicString(code)
        const [imports] = parse(code)
        for (const { t, ss, se } of imports) {
          if (t === 3 && code.slice(se, se + 4) === '.url') {
            // ignore import.meta.url with /** #__KEEP__ */ comment
            if (keepCommentRE.test(code.slice(0, ss))) {
              keepCommentRE.lastIndex = 0
              continue
            }

            // import.meta.url
            s.overwrite(ss, se + 4, `${prefix}${index}`)
          }
        }
        return s.hasChanged() ? s.toString() : undefined
      },
    },
    renderChunk(code, chunk, outputOptions) {
      if (!code.includes(prefix)) return

      return code.replace(
        /__vite_buildTimeImportMetaUrl_(\d+)/g,
        (_, index) => {
          const originalFile = Object.keys(idMap).find(
            (key) => idMap[key] === +index,
          )
          if (!originalFile) {
            throw new Error(
              `Could not find original file for ${prefix}${index} in ${chunk.fileName}`,
            )
          }
          const outputFile = path.resolve(outputOptions.dir!, chunk.fileName)
          const relativePath = path
            .relative(path.dirname(outputFile), originalFile)
            .replaceAll('\\', '/')

          if (outputOptions.format === 'es') {
            return `new URL(${JSON.stringify(relativePath)}, import.meta.url)`
          } else if (outputOptions.format === 'cjs') {
            return `new URL(${JSON.stringify(
              relativePath,
            )}, require('node:url').pathToFileURL(__filename))`
          } else {
            throw new Error(`Unsupported output format ${outputOptions.format}`)
          }
        },
      )
    },
  }
}

/**
 * Guard the bundle size
 *
 * @param limit size in kB
 */
function bundleSizeLimit(limit: number): Plugin {
  let size = 0

  return {
    name: 'bundle-limit',
    generateBundle(_, bundle) {
      if (this.meta.watchMode) return

      size = Buffer.byteLength(
        Object.values(bundle)
          .map((i) => ('code' in i ? i.code : ''))
          .join(''),
        'utf-8',
      )
    },
    closeBundle() {
      if (this.meta.watchMode) return

      const kb = size / 1000
      if (kb > limit) {
        this.error(
          `Bundle size exceeded ${limit} kB, current size is ${kb.toFixed(
            2,
          )}kb.`,
        )
      }
    },
  }
}

// #endregion



================================================
FILE: packages/vite/rolldown.dts.config.ts
================================================
import { readFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { builtinModules } from 'node:module'
import { defineConfig } from 'rolldown'
import type {
  OutputChunk,
  Plugin,
  PluginContext,
  RenderedChunk,
} from 'rolldown'
import { parseAst } from 'rolldown/parseAst'
import { dts } from 'rolldown-plugin-dts'
import { parse as parseWithBabel } from '@babel/parser'
import { walk } from 'estree-walker'
import MagicString from 'magic-string'
import type {
  Directive,
  ModuleExportName,
  Program,
  Statement,
} from '@oxc-project/types'

const depTypesDir = new URL('./src/types/', import.meta.url)
const pkg = JSON.parse(
  readFileSync(new URL('./package.json', import.meta.url)).toString(),
)

const external = [
  /^node:*/,
  /^vite\//,
  'rollup/parseAst',
  ...Object.keys(pkg.dependencies),
  ...Object.keys(pkg.peerDependencies),
]

export default defineConfig({
  input: {
    index: './src/node/index.ts',
    'module-runner': './src/module-runner/index.ts',
  },
  output: {
    dir: './dist/node',
    format: 'esm',
  },
  treeshake: {
    moduleSideEffects: 'no-external',
  },
  external,
  plugins: [
    patchTypes(),
    addNodePrefix(),
    dts({
      tsconfig: './src/node/tsconfig.build.json',
      emitDtsOnly: true,
      resolve: true,
    }),
  ],
})

// Taken from https://stackoverflow.com/a/36328890
const multilineCommentsRE = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g
const licenseCommentsRE = /MIT License|MIT license|BSD license/
const consecutiveNewlinesRE = /\n{2,}/g
const identifierWithTrailingDollarRE = /\b(\w+)\$\d+\b/g

/**
 * Replace specific identifiers with a more readable name, grouped by
 * the module that imports the identifier as a named import alias
 */
const identifierReplacements: Record<string, Record<string, string>> = {
  rollup: {
    Plugin$2: 'Rollup.Plugin',
    TransformResult$1: 'Rollup.TransformResult',
  },
  esbuild: {
    TransformResult$2: 'esbuild_TransformResult',
    TransformOptions$1: 'esbuild_TransformOptions',
    BuildOptions$1: 'esbuild_BuildOptions',
  },
  'node:http': {
    Server$1: 'http.Server',
    IncomingMessage$1: 'http.IncomingMessage',
  },
  'node:https': {
    Server$2: 'HttpsServer',
    ServerOptions$2: 'HttpsServerOptions',
  },
  'node:url': {
    URL$1: 'url_URL',
  },
  'vite/module-runner': {
    FetchResult$1: 'moduleRunner_FetchResult',
  },
  '../../types/hmrPayload.js': {
    CustomPayload$1: 'hmrPayload_CustomPayload',
    HotPayload$1: 'hmrPayload_HotPayload',
  },
  '../../types/customEvent.js': {
    InferCustomEventPayload$1: 'hmrPayload_InferCustomEventPayload',
  },
  '../../types/internal/lightningcssOptions.js': {
    LightningCSSOptions$1: 'lightningcssOptions_LightningCSSOptions',
  },
}

// type names that are declared
const ignoreConfusingTypeNames = [
  'Plugin$1',
  'MinimalPluginContext$1',
  'ServerOptions$1',
  'ServerOptions$3',
]

/**
 * Patch the types files before passing to dts plugin
 * 1. Resolve `dep-types/*` and `types/*` imports
 * 2. Validate unallowed dependency imports
 * 3. Replace confusing type names
 * 4. Strip leftover internal types
 * 5. Clean unnecessary comments
 */
function patchTypes(): Plugin {
  return {
    name: 'patch-types',
    resolveId: {
      order: 'pre',
      filter: {
        id: /^(dep-)?types\//,
      },
      handler(id) {
        // Dep types should be bundled
        if (id.startsWith('dep-types/')) {
          const fileUrl = new URL(
            `./${id.slice('dep-types/'.length)}.d.ts`,
            depTypesDir,
          )
          return fileURLToPath(fileUrl)
        }
        // Ambient types are unbundled and externalized
        if (id.startsWith('types/')) {
          return {
            id: '../../' + (id.endsWith('.js') ? id : id + '.js'),
            external: true,
          }
        }
      },
    },
    generateBundle: {
      order: 'post',
      handler(_opts, bundle) {
        for (const chunk of Object.values(bundle)) {
          if (chunk.type !== 'chunk') continue

          const ast = parseAst(chunk.code, { lang: 'ts', sourceType: 'module' })
          const importBindings = getAllImportBindings(ast)
          if (
            chunk.fileName.startsWith('module-runner') ||
            // index and moduleRunner have a common chunk "moduleRunnerTransport"
            chunk.fileName.startsWith('moduleRunnerTransport') ||
            chunk.fileName.startsWith('types.d-')
          ) {
            validateRunnerChunk.call(this, chunk, importBindings)
          } else {
            validateChunkImports.call(this, chunk, importBindings)
            replaceConfusingTypeNames.call(this, chunk, importBindings)
            stripInternalTypes.call(this, chunk)
            cleanUnnecessaryComments(chunk)
          }
        }
      },
    },
  }
}

function stringifyModuleExportName(node: ModuleExportName): string {
  if (node.type === 'Identifier') {
    return node.name
  }
  return node.value
}

type ImportBindings = { id: string; bindings: string[]; locals: string[] }

function getImportBindings(
  node: Directive | Statement,
): ImportBindings | undefined {
  if (node.type === 'ImportDeclaration') {
    return {
      id: node.source.value,
      bindings: node.specifiers.map((s) =>
        s.type === 'ImportDefaultSpecifier'
          ? 'default'
          : s.type === 'ImportNamespaceSpecifier'
            ? '*'
            : stringifyModuleExportName(s.imported),
      ),
      locals: node.specifiers.map((s) => s.local.name),
    }
  }
  if (node.type === 'ExportNamedDeclaration') {
    if (!node.source) return undefined
    return {
      id: node.source.value,
      bindings: node.specifiers.map((s) => stringifyModuleExportName(s.local)),
      locals: [],
    }
  }
  if (node.type === 'ExportAllDeclaration') {
    if (!node.source) return undefined
    return { id: node.source.value, bindings: ['*'], locals: [] }
  }
}

function getAllImportBindings(ast: Program): ImportBindings[] {
  return ast.body.flatMap((node) => getImportBindings(node) ?? [])
}

/**
 * Runner chunk should only import local dependencies to stay lightweight
 */
function validateRunnerChunk(
  this: PluginContext,
  chunk: RenderedChunk,
  importBindings: ImportBindings[],
) {
  for (const { id, bindings } of importBindings) {
    if (
      !id.startsWith('./') &&
      !id.startsWith('../') &&
      // index and moduleRunner have a common chunk "moduleRunnerTransport"
      !id.startsWith('moduleRunnerTransport.d') &&
      !id.startsWith('types.d')
    ) {
      this.warn(
        `${chunk.fileName} imports "${bindings.join(', ')}" from "${id}" which is not allowed`,
      )
      process.exitCode = 1
    }
  }
}

/**
 * Validate that chunk imports do not import dev deps
 */
function validateChunkImports(
  this: PluginContext,
  chunk: RenderedChunk,
  importBindings: ImportBindings[],
) {
  const deps = Object.keys(pkg.dependencies)
  for (const { id, bindings } of importBindings) {
    if (
      !id.startsWith('./') &&
      !id.startsWith('../') &&
      !id.startsWith('node:') &&
      !id.startsWith('types.d') &&
      !id.startsWith('vite/') &&
      // index and moduleRunner have a common chunk "moduleRunnerTransport"
      !id.startsWith('moduleRunnerTransport.d') &&
      !deps.includes(id) &&
      !deps.some((name) => id.startsWith(name + '/'))
    ) {
      // If validation failed, only warn and set exit code 1 so that files
      // are written to disk for inspection, but the build will fail
      this.warn(
        `${chunk.fileName} imports "${bindings.join(', ')}" from "${id}" which is not allowed`,
      )
      process.exitCode = 1
    }
  }
}

/**
 * Rollup deduplicate type names with a trailing `$1` or `$2`, which can be
 * confusing when showed in autocompletions. Try to replace with a better name
 */
function replaceConfusingTypeNames(
  this: PluginContext,
  chunk: OutputChunk,
  importBindings: ImportBindings[],
) {
  for (const modName in identifierReplacements) {
    const imp = importBindings.filter((imp) => imp.id === modName)
    // Validate that `identifierReplacements` is not outdated if there's no match
    if (imp.length === 0) {
      this.warn(
        `${chunk.fileName} does not import "${modName}" for replacement`,
      )
      process.exitCode = 1
      continue
    }

    const replacements = identifierReplacements[modName]
    for (const id in replacements) {
      // Validate that `identifierReplacements` is not outdated if there's no match
      if (!imp.some((i) => i.locals.includes(id))) {
        this.warn(
          `${chunk.fileName} does not import "${id}" from "${modName}" for replacement`,
        )
        process.exitCode = 1
        continue
      }

      const betterId = replacements[id]
      const regexEscapedId = escapeRegex(id)
      // If the better id accesses a namespace, the existing `Foo as Foo$1`
      // named import cannot be replaced with `Foo as Namespace.Foo`, so we
      // pre-emptively remove the whole named import
      if (betterId.includes('.')) {
        chunk.code = chunk.code.replace(
          new RegExp(`\\b\\w+\\b as ${regexEscapedId},?\\s?`),
          '',
        )
      }
      chunk.code = chunk.code.replace(
        new RegExp(`\\b${regexEscapedId}\\b`, 'g'),
        betterId,
      )
    }
  }

  const identifiers = unique(
    Array.from(
      chunk.code.matchAll(identifierWithTrailingDollarRE),
      (m) => m[0],
    ),
  )
  const unreplacedIds = identifiers.filter(
    (id) => !ignoreConfusingTypeNames.includes(id),
  )
  if (unreplacedIds.length) {
    const unreplacedStr = unreplacedIds.map((id) => `\n- ${id}`).join('')
    this.warn(
      `${chunk.fileName} contains confusing identifier names${unreplacedStr}`,
    )
    process.exitCode = 1
  }
  const notUsedConfusingTypeNames = ignoreConfusingTypeNames.filter(
    (id) => !identifiers.includes(id),
  )
  // Validate that `identifierReplacements` is not outdated if there's no match
  if (notUsedConfusingTypeNames.length) {
    const notUsedStr = notUsedConfusingTypeNames
      .map((id) => `\n- ${id}`)
      .join('')
    this.warn(`${chunk.fileName} contains unused identifier names${notUsedStr}`)
    process.exitCode = 1
  }
}

/**
 * While we already enable `compilerOptions.stripInternal`, some internal comments
 * like internal parameters are still not stripped by TypeScript, so we run another
 * pass here.
 */
function stripInternalTypes(this: PluginContext, chunk: OutputChunk) {
  if (chunk.code.includes('@internal')) {
    const s = new MagicString(chunk.code)
    // need to parse with babel to get the comments
    const ast = parseWithBabel(chunk.code, {
      plugins: ['typescript'],
      sourceType: 'module',
    })

    walk(ast as any, {
      enter(node: any) {
        if (removeInternal(s, node)) {
          this.skip()
        }
      },
    })

    chunk.code = s.toString()

    if (chunk.code.includes('@internal')) {
      this.warn(`${chunk.fileName} has unhandled @internal declarations`)
      process.exitCode = 1
    }
  }
}

/**
 * Remove `@internal` comments not handled by `compilerOptions.stripInternal`
 * Reference: https://github.com/vuejs/core/blob/main/rollup.dts.config.js
 */
function removeInternal(s: MagicString, node: any): boolean {
  if (
    node.leadingComments &&
    node.leadingComments.some((c: any) => {
      return c.type === 'CommentBlock' && c.value.includes('@internal')
    })
  ) {
    // Examples:
    // function a(foo: string, /* @internal */ bar: number, baz: boolean)
    //                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // type Enum = Foo | /* @internal */ Bar | Baz
    //                   ^^^^^^^^^^^^^^^^^^^^^
    // strip trailing comma or pipe
    const trailingRe = /\s*[,|]/y
    trailingRe.lastIndex = node.end
    const trailingStr = trailingRe.exec(s.original)?.[0] ?? ''
    s.remove(node.leadingComments[0].start, node.end + trailingStr.length)
    return true
  }
  return false
}

function cleanUnnecessaryComments(chunk: OutputChunk) {
  chunk.code = chunk.code
    .replace(multilineCommentsRE, (m) => {
      return licenseCommentsRE.test(m) ? '' : m
    })
    .replace(consecutiveNewlinesRE, '\n\n')
}

const escapeRegexRE = /[-/\\^$*+?.()|[\]{}]/g
function escapeRegex(str: string): string {
  return str.replace(escapeRegexRE, '\\$&')
}

function unique<T>(arr: T[]): T[] {
  return Array.from(new Set(arr))
}

function addNodePrefix(): Plugin {
  return {
    name: 'add-node-prefix',
    resolveId: {
      order: 'pre',
      filter: {
        id: new RegExp(`^(?:${builtinModules.join('|')})$`),
      },
      handler(id) {
        return { id: `node:${id}`, external: true }
      },
    },
  }
}



================================================
FILE: packages/vite/rollupLicensePlugin.ts
================================================
import fs from 'node:fs'
import license from 'rollup-plugin-license'
import type { Dependency } from 'rollup-plugin-license'
import colors from 'picocolors'
import type { Plugin, PluginContext } from 'rollup'

export default function licensePlugin(
  licenseFilePath: string,
  licenseTitle: string,
  packageName: string,
  additionalSection?: string,
): Plugin {
  const originalPlugin = license({
    thirdParty(dependencies) {
      // https://github.com/rollup/rollup/blob/master/build-plugins/generate-license-file.js
      // MIT Licensed https://github.com/rollup/rollup/blob/master/LICENSE-CORE.md
      const coreLicense = fs.readFileSync(
        new URL('../../LICENSE', import.meta.url),
      )

      const deps = sortDependencies(dependencies)
      const licenses = sortLicenses(
        new Set(
          dependencies.map((dep) => dep.license).filter(Boolean) as string[],
        ),
      )

      let dependencyLicenseTexts = ''
      for (let i = 0; i < deps.length; i++) {
        // Find dependencies with the same license text so it can be shared
        const licenseText = deps[i].licenseText
        const sameDeps = [deps[i]]
        if (licenseText) {
          for (let j = i + 1; j < deps.length; j++) {
            if (licenseText === deps[j].licenseText) {
              sameDeps.push(...deps.splice(j, 1))
              j--
            }
          }
        }

        let text = `## ${sameDeps.map((d) => d.name).join(', ')}\n`
        const depInfos = sameDeps.map((d) => getDependencyInformation(d))

        // If all same dependencies have the same license and contributor names, show them only once
        if (
          depInfos.length > 1 &&
          depInfos.every(
            (info) =>
              info.license === depInfos[0].license &&
              info.names === depInfos[0].names,
          )
        ) {
          const { license, names } = depInfos[0]
          const repositoryText = depInfos
            .map((info) => info.repository)
            .filter(Boolean)
            .join(', ')

          if (license) text += `License: ${license}\n`
          if (names) text += `By: ${names}\n`
          if (repositoryText) text += `Repositories: ${repositoryText}\n`
        }
        // Else show each dependency separately
        else {
          for (let j = 0; j < depInfos.length; j++) {
            const { license, names, repository } = depInfos[j]

            if (license) text += `License: ${license}\n`
            if (names) text += `By: ${names}\n`
            if (repository) text += `Repository: ${repository}\n`
            if (j !== depInfos.length - 1) text += '\n'
          }
        }

        if (licenseText) {
          text +=
            '\n' +
            licenseText
              .trim()
              .replace(/\r\n|\r/g, '\n')
              .split('\n')
              .map((line) => `> ${line}`)
              .join('\n') +
            '\n'
        }

        if (i !== deps.length - 1) {
          text += '\n---------------------------------------\n\n'
        }

        dependencyLicenseTexts += text
      }

      const licenseText =
        `# ${licenseTitle}\n` +
        `${packageName} is released under the MIT license:\n\n` +
        coreLicense +
        `\n` +
        (additionalSection || '') +
        `# Licenses of bundled dependencies\n` +
        `The published ${packageName} artifact additionally contains code with the following licenses:\n` +
        `${licenses.join(', ')}\n\n` +
        `# Bundled dependencies:\n` +
        dependencyLicenseTexts

      const existingLicenseText = fs.readFileSync(licenseFilePath, 'utf-8')
      if (existingLicenseText !== licenseText) {
        fs.writeFileSync(licenseFilePath, licenseText)
        console.warn(
          colors.yellow(
            '\nLICENSE.md updated. You should commit the updated file.\n',
          ),
        )
      }
    },
  })
  // skip for watch mode
  for (const hook of ['renderChunk', 'generateBundle'] as const) {
    const originalHook = originalPlugin[hook]!
    originalPlugin[hook] = function (this: PluginContext, ...args: unknown[]) {
      if (this.meta.watchMode) return
      return (originalHook as Function).apply(this, args)
    }
  }
  return originalPlugin
}

function sortDependencies(dependencies: Dependency[]) {
  return dependencies.sort(({ name: nameA }, { name: nameB }) => {
    return nameA! > nameB! ? 1 : nameB! > nameA! ? -1 : 0
  })
}

function sortLicenses(licenses: Set<string>) {
  let withParenthesis: string[] = []
  let noParenthesis: string[] = []
  licenses.forEach((license) => {
    if (license[0] === '(') {
      withParenthesis.push(license)
    } else {
      noParenthesis.push(license)
    }
  })
  withParenthesis = withParenthesis.sort()
  noParenthesis = noParenthesis.sort()
  return [...noParenthesis, ...withParenthesis]
}

interface DependencyInfo {
  license?: string
  names?: string
  repository?: string
}

function getDependencyInformation(dep: Dependency): DependencyInfo {
  const info: DependencyInfo = {}
  const { license, author, maintainers, contributors, repository } = dep

  if (license) {
    info.license = license
  }

  const names = new Set<string>()
  for (const person of [author, ...maintainers, ...contributors]) {
    const name = typeof person === 'string' ? person : person?.name
    if (name) {
      names.add(name)
    }
  }
  if (names.size > 0) {
    info.names = Array.from(names).join(', ')
  }

  if (repository) {
    info.repository =
      typeof repository === 'string' ? repository : repository.url
  }

  return info
}



================================================
FILE: packages/vite/tsconfig.base.json
================================================
{
  "compilerOptions": {
    "rootDir": ".",
    "target": "ES2023",
    "module": "Preserve",
    "types": ["node"],
    "noEmit": true,
    "moduleResolution": "bundler",
    "strict": true,
    "noImplicitOverride": true,
    "noUnusedLocals": true,
    "esModuleInterop": true,
    "useUnknownInCatchVariables": false
  }
}



================================================
FILE: packages/vite/tsconfig.check.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "moduleResolution": "node16",
    "module": "Node16",
    "lib": ["ES2020"], // ES2020 is very conservative check for client types, could be bumped if needed
    "types": [], // Avoid checking unrelated node_modules types
    "noEmit": true,
    "strict": true,
    "noUncheckedSideEffectImports": true,
    "exactOptionalPropertyTypes": true
  },
  "include": [
    // dist
    "dist/**/*",
    "types/**/*"
  ]
}



================================================
FILE: packages/vite/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "include": ["rolldown.config.ts", "rolldown.dts.config.ts", "scripts"],
  "compilerOptions": {
    "esModuleInterop": true,
    "declaration": false,
    "resolveJsonModule": true
  }
}



================================================
FILE: packages/vite/misc/false.d.ts
================================================
declare const result: boolean
export default result



================================================
FILE: packages/vite/misc/false.js
================================================
export default false



================================================
FILE: packages/vite/misc/true.d.ts
================================================
declare const result: boolean
export default result



================================================
FILE: packages/vite/misc/true.js
================================================
export default true



================================================
FILE: packages/vite/scripts/generateTarget.ts
================================================
import { getCompatibleVersions } from 'baseline-browser-mapping'

// Update on each major release
const targetDate = '2025-05-01'

// https://esbuild.github.io/api/#target
const esbuildSupportedBrowsers = new Set([
  'chrome',
  'edge',
  'firefox',
  'safari',
])

const results = getCompatibleVersions({
  widelyAvailableOnDate: targetDate,
})

const esbuildTargets = results
  .filter((target) => esbuildSupportedBrowsers.has(target.browser))
  .map((target) => `${target.browser}${target.version}`)

console.log('ESBuild Targets:', esbuildTargets)



================================================
FILE: packages/vite/src/client/client.ts
================================================
import type { ErrorPayload, HotPayload } from 'types/hmrPayload'
import type { ViteHotContext } from 'types/hot'
import { HMRClient, HMRContext } from '../shared/hmr'
import {
  createWebSocketModuleRunnerTransport,
  normalizeModuleRunnerTransport,
} from '../shared/moduleRunnerTransport'
import { createHMRHandler } from '../shared/hmrHandler'
import { ErrorOverlay, overlayId } from './overlay'
import '@vite/env'

// injected by the hmr plugin when served
declare const __BASE__: string
declare const __SERVER_HOST__: string
declare const __HMR_PROTOCOL__: string | null
declare const __HMR_HOSTNAME__: string | null
declare const __HMR_PORT__: number | null
declare const __HMR_DIRECT_TARGET__: string
declare const __HMR_BASE__: string
declare const __HMR_TIMEOUT__: number
declare const __HMR_ENABLE_OVERLAY__: boolean
declare const __WS_TOKEN__: string

console.debug('[vite] connecting...')

const importMetaUrl = new URL(import.meta.url)

// use server configuration, then fallback to inference
const serverHost = __SERVER_HOST__
const socketProtocol =
  __HMR_PROTOCOL__ || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws')
const hmrPort = __HMR_PORT__
const socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${
  hmrPort || importMetaUrl.port
}${__HMR_BASE__}`
const directSocketHost = __HMR_DIRECT_TARGET__
const base = __BASE__ || '/'
const hmrTimeout = __HMR_TIMEOUT__
const wsToken = __WS_TOKEN__

const transport = normalizeModuleRunnerTransport(
  (() => {
    let wsTransport = createWebSocketModuleRunnerTransport({
      createConnection: () =>
        new WebSocket(
          `${socketProtocol}://${socketHost}?token=${wsToken}`,
          'vite-hmr',
        ),
      pingInterval: hmrTimeout,
    })

    return {
      async connect(handlers) {
        try {
          await wsTransport.connect(handlers)
        } catch (e) {
          // only use fallback when port is inferred and was not connected before to prevent confusion
          if (!hmrPort) {
            wsTransport = createWebSocketModuleRunnerTransport({
              createConnection: () =>
                new WebSocket(
                  `${socketProtocol}://${directSocketHost}?token=${wsToken}`,
                  'vite-hmr',
                ),
              pingInterval: hmrTimeout,
            })
            try {
              await wsTransport.connect(handlers)
              console.info(
                '[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.',
              )
            } catch (e) {
              if (
                e instanceof Error &&
                e.message.includes('WebSocket closed without opened.')
              ) {
                const currentScriptHostURL = new URL(import.meta.url)
                const currentScriptHost =
                  currentScriptHostURL.host +
                  currentScriptHostURL.pathname.replace(/@vite\/client$/, '')
                console.error(
                  '[vite] failed to connect to websocket.\n' +
                    'your current setup:\n' +
                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n` +
                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\n` +
                    'Check out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .',
                )
              }
            }
            return
          }
          console.error(`[vite] failed to connect to websocket (${e}). `)
          throw e
        }
      },
      async disconnect() {
        await wsTransport.disconnect()
      },
      send(data) {
        wsTransport.send(data)
      },
    }
  })(),
)

let willUnload = false
if (typeof window !== 'undefined') {
  // window can be misleadingly defined in a worker if using define (see #19307)
  window.addEventListener?.('beforeunload', () => {
    willUnload = true
  })
}

function cleanUrl(pathname: string): string {
  const url = new URL(pathname, 'http://vite.dev')
  url.searchParams.delete('direct')
  return url.pathname + url.search
}

let isFirstUpdate = true
const outdatedLinkTags = new WeakSet<HTMLLinkElement>()

const debounceReload = (time: number) => {
  let timer: ReturnType<typeof setTimeout> | null
  return () => {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(() => {
      location.reload()
    }, time)
  }
}
const pageReload = debounceReload(20)

const hmrClient = new HMRClient(
  {
    error: (err) => console.error('[vite]', err),
    debug: (...msg) => console.debug('[vite]', ...msg),
  },
  transport,
  async function importUpdatedModule({
    acceptedPath,
    timestamp,
    explicitImportRequired,
    isWithinCircularImport,
  }) {
    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`)
    const importPromise = import(
      /* @vite-ignore */
      base +
        acceptedPathWithoutQuery.slice(1) +
        `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${
          query ? `&${query}` : ''
        }`
    )
    if (isWithinCircularImport) {
      importPromise.catch(() => {
        console.info(
          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. ` +
            `To debug and break the circular import, you can run \`vite --debug hmr\` to log the circular dependency path if a file change triggered it.`,
        )
        pageReload()
      })
    }
    return await importPromise
  },
)
transport.connect!(createHMRHandler(handleMessage))

async function handleMessage(payload: HotPayload) {
  switch (payload.type) {
    case 'connected':
      console.debug(`[vite] connected.`)
      break
    case 'update':
      await hmrClient.notifyListeners('vite:beforeUpdate', payload)
      if (hasDocument) {
        // if this is the first update and there's already an error overlay, it
        // means the page opened with existing server compile error and the whole
        // module script failed to load (since one of the nested imports is 500).
        // in this case a normal update won't work and a full reload is needed.
        if (isFirstUpdate && hasErrorOverlay()) {
          location.reload()
          return
        } else {
          if (enableOverlay) {
            clearErrorOverlay()
          }
          isFirstUpdate = false
        }
      }
      await Promise.all(
        payload.updates.map(async (update): Promise<void> => {
          if (update.type === 'js-update') {
            return hmrClient.queueUpdate(update)
          }

          // css-update
          // this is only sent when a css file referenced with <link> is updated
          const { path, timestamp } = update
          const searchUrl = cleanUrl(path)
          // can't use querySelector with `[href*=]` here since the link may be
          // using relative paths so we need to use link.href to grab the full
          // URL for the include check.
          const el = Array.from(
            document.querySelectorAll<HTMLLinkElement>('link'),
          ).find(
            (e) =>
              !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl),
          )

          if (!el) {
            return
          }

          const newPath = `${base}${searchUrl.slice(1)}${
            searchUrl.includes('?') ? '&' : '?'
          }t=${timestamp}`

          // rather than swapping the href on the existing tag, we will
          // create a new link tag. Once the new stylesheet has loaded we
          // will remove the existing link tag. This removes a Flash Of
          // Unstyled Content that can occur when swapping out the tag href
          // directly, as the new stylesheet has not yet been loaded.
          return new Promise((resolve) => {
            const newLinkTag = el.cloneNode() as HTMLLinkElement
            newLinkTag.href = new URL(newPath, el.href).href
            const removeOldEl = () => {
              el.remove()
              console.debug(`[vite] css hot updated: ${searchUrl}`)
              resolve()
            }
            newLinkTag.addEventListener('load', removeOldEl)
            newLinkTag.addEventListener('error', removeOldEl)
            outdatedLinkTags.add(el)
            el.after(newLinkTag)
          })
        }),
      )
      await hmrClient.notifyListeners('vite:afterUpdate', payload)
      break
    case 'custom': {
      await hmrClient.notifyListeners(payload.event, payload.data)
      if (payload.event === 'vite:ws:disconnect') {
        if (hasDocument && !willUnload) {
          console.log(`[vite] server connection lost. Polling for restart...`)
          const socket = payload.data.webSocket as WebSocket
          const url = new URL(socket.url)
          url.search = '' // remove query string including `token`
          await waitForSuccessfulPing(url.href)
          location.reload()
        }
      }
      break
    }
    case 'full-reload':
      await hmrClient.notifyListeners('vite:beforeFullReload', payload)
      if (hasDocument) {
        if (payload.path && payload.path.endsWith('.html')) {
          // if html file is edited, only reload the page if the browser is
          // currently on that page.
          const pagePath = decodeURI(location.pathname)
          const payloadPath = base + payload.path.slice(1)
          if (
            pagePath === payloadPath ||
            payload.path === '/index.html' ||
            (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)
          ) {
            pageReload()
          }
          return
        } else {
          pageReload()
        }
      }
      break
    case 'prune':
      await hmrClient.notifyListeners('vite:beforePrune', payload)
      await hmrClient.prunePaths(payload.paths)
      break
    case 'error': {
      await hmrClient.notifyListeners('vite:error', payload)
      if (hasDocument) {
        const err = payload.err
        if (enableOverlay) {
          createErrorOverlay(err)
        } else {
          console.error(
            `[vite] Internal Server Error\n${err.message}\n${err.stack}`,
          )
        }
      }
      break
    }
    case 'ping': // noop
      break
    default: {
      const check: never = payload
      return check
    }
  }
}

const enableOverlay = __HMR_ENABLE_OVERLAY__
const hasDocument = 'document' in globalThis

function createErrorOverlay(err: ErrorPayload['err']) {
  clearErrorOverlay()
  const { customElements } = globalThis
  if (customElements) {
    const ErrorOverlayConstructor = customElements.get(overlayId)!
    document.body.appendChild(new ErrorOverlayConstructor(err))
  }
}

function clearErrorOverlay() {
  document.querySelectorAll<ErrorOverlay>(overlayId).forEach((n) => n.close())
}

function hasErrorOverlay() {
  return document.querySelectorAll(overlayId).length
}

function waitForSuccessfulPing(socketUrl: string) {
  if (typeof SharedWorker === 'undefined') {
    const visibilityManager: VisibilityManager = {
      currentState: document.visibilityState,
      listeners: new Set(),
    }
    const onVisibilityChange = () => {
      visibilityManager.currentState = document.visibilityState
      for (const listener of visibilityManager.listeners) {
        listener(visibilityManager.currentState)
      }
    }
    document.addEventListener('visibilitychange', onVisibilityChange)
    return waitForSuccessfulPingInternal(socketUrl, visibilityManager)
  }

  // needs to be inlined to
  //   - load the worker after the server is closed
  //   - make it work with backend integrations
  const blob = new Blob(
    [
      '"use strict";',
      `const waitForSuccessfulPingInternal = ${waitForSuccessfulPingInternal.toString()};`,
      `const fn = ${pingWorkerContentMain.toString()};`,
      `fn(${JSON.stringify(socketUrl)})`,
    ],
    { type: 'application/javascript' },
  )
  const objURL = URL.createObjectURL(blob)
  const sharedWorker = new SharedWorker(objURL)
  return new Promise<void>((resolve, reject) => {
    const onVisibilityChange = () => {
      sharedWorker.port.postMessage({ visibility: document.visibilityState })
    }
    document.addEventListener('visibilitychange', onVisibilityChange)

    sharedWorker.port.addEventListener('message', (event) => {
      document.removeEventListener('visibilitychange', onVisibilityChange)
      sharedWorker.port.close()

      const data: { type: 'success' } | { type: 'error'; error: unknown } =
        event.data
      if (data.type === 'error') {
        reject(data.error)
        return
      }
      resolve()
    })

    onVisibilityChange()
    sharedWorker.port.start()
  })
}

type VisibilityManager = {
  currentState: DocumentVisibilityState
  listeners: Set<(newVisibility: DocumentVisibilityState) => void>
}

function pingWorkerContentMain(socketUrl: string) {
  self.addEventListener('connect', (_event) => {
    const event = _event as MessageEvent
    const port = event.ports[0]

    if (!socketUrl) {
      port.postMessage({
        type: 'error',
        error: new Error('socketUrl not found'),
      })
      return
    }

    const visibilityManager: VisibilityManager = {
      currentState: 'visible',
      listeners: new Set(),
    }
    port.addEventListener('message', (event) => {
      const { visibility } = event.data
      visibilityManager.currentState = visibility
      console.debug('[vite] new window visibility', visibility)
      for (const listener of visibilityManager.listeners) {
        listener(visibility)
      }
    })
    port.start()

    console.debug('[vite] connected from window')
    waitForSuccessfulPingInternal(socketUrl, visibilityManager).then(
      () => {
        console.debug('[vite] ping successful')
        try {
          port.postMessage({ type: 'success' })
        } catch (error) {
          port.postMessage({ type: 'error', error })
        }
      },
      (error) => {
        console.debug('[vite] error happened', error)
        try {
          port.postMessage({ type: 'error', error })
        } catch (error) {
          port.postMessage({ type: 'error', error })
        }
      },
    )
  })
}

async function waitForSuccessfulPingInternal(
  socketUrl: string,
  visibilityManager: VisibilityManager,
  ms = 1000,
) {
  function wait(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  async function ping() {
    try {
      const socket = new WebSocket(socketUrl, 'vite-ping')
      return new Promise<boolean>((resolve) => {
        function onOpen() {
          resolve(true)
          close()
        }
        function onError() {
          resolve(false)
          close()
        }
        function close() {
          socket.removeEventListener('open', onOpen)
          socket.removeEventListener('error', onError)
          socket.close()
        }
        socket.addEventListener('open', onOpen)
        socket.addEventListener('error', onError)
      })
    } catch {
      return false
    }
  }

  function waitForWindowShow(visibilityManager: VisibilityManager) {
    return new Promise<void>((resolve) => {
      const onChange = (newVisibility: DocumentVisibilityState) => {
        if (newVisibility === 'visible') {
          resolve()
          visibilityManager.listeners.delete(onChange)
        }
      }
      visibilityManager.listeners.add(onChange)
    })
  }

  if (await ping()) {
    return
  }
  await wait(ms)

  while (true) {
    if (visibilityManager.currentState === 'visible') {
      if (await ping()) {
        break
      }
      await wait(ms)
    } else {
      await waitForWindowShow(visibilityManager)
    }
  }
}

const sheetsMap = new Map<string, HTMLStyleElement>()

// collect existing style elements that may have been inserted during SSR
// to avoid FOUC or duplicate styles
if ('document' in globalThis) {
  document
    .querySelectorAll<HTMLStyleElement>('style[data-vite-dev-id]')
    .forEach((el) => {
      sheetsMap.set(el.getAttribute('data-vite-dev-id')!, el)
    })
}

const cspNonce =
  'document' in globalThis
    ? document.querySelector<HTMLMetaElement>('meta[property=csp-nonce]')?.nonce
    : undefined

// all css imports should be inserted at the same position
// because after build it will be a single css file
let lastInsertedStyle: HTMLStyleElement | undefined

export function updateStyle(id: string, content: string): void {
  let style = sheetsMap.get(id)
  if (!style) {
    style = document.createElement('style')
    style.setAttribute('type', 'text/css')
    style.setAttribute('data-vite-dev-id', id)
    style.textContent = content
    if (cspNonce) {
      style.setAttribute('nonce', cspNonce)
    }

    if (!lastInsertedStyle) {
      document.head.appendChild(style)

      // reset lastInsertedStyle after async
      // because dynamically imported css will be split into a different file
      setTimeout(() => {
        lastInsertedStyle = undefined
      }, 0)
    } else {
      lastInsertedStyle.insertAdjacentElement('afterend', style)
    }
    lastInsertedStyle = style
  } else {
    style.textContent = content
  }
  sheetsMap.set(id, style)
}

export function removeStyle(id: string): void {
  const style = sheetsMap.get(id)
  if (style) {
    document.head.removeChild(style)
    sheetsMap.delete(id)
  }
}

export function createHotContext(ownerPath: string): ViteHotContext {
  return new HMRContext(hmrClient, ownerPath)
}

/**
 * urls here are dynamic import() urls that couldn't be statically analyzed
 */
export function injectQuery(url: string, queryToInject: string): string {
  // skip urls that won't be handled by vite
  if (url[0] !== '.' && url[0] !== '/') {
    return url
  }

  // can't use pathname from URL since it may be relative like ../
  const pathname = url.replace(/[?#].*$/, '')
  const { search, hash } = new URL(url, 'http://vite.dev')

  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${
    hash || ''
  }`
}

export { ErrorOverlay }



================================================
FILE: packages/vite/src/client/env.ts
================================================
declare const __DEFINES__: Record<string, any>

const context = (() => {
  if (typeof globalThis !== 'undefined') {
    return globalThis
  } else if (typeof self !== 'undefined') {
    return self
  } else if (typeof window !== 'undefined') {
    return window
  } else {
    return Function('return this')()
  }
})()

// assign defines
const defines = __DEFINES__
Object.keys(defines).forEach((key) => {
  const segments = key.split('.')
  let target = context
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i]
    if (i === segments.length - 1) {
      target[segment] = defines[key]
    } else {
      target = target[segment] || (target[segment] = {})
    }
  }
})



================================================
FILE: packages/vite/src/client/overlay.ts
================================================
import type { ErrorPayload } from 'types/hmrPayload'

// injected by the hmr plugin when served
declare const __BASE__: string
declare const __HMR_CONFIG_NAME__: string

const hmrConfigName = __HMR_CONFIG_NAME__
const base = __BASE__ || '/'

// Create an element with provided attributes and optional children
function h(
  e: string,
  attrs: Record<string, string> = {},
  ...children: (string | Node)[]
) {
  const elem = document.createElement(e)
  for (const [k, v] of Object.entries(attrs)) {
    elem.setAttribute(k, v)
  }
  elem.append(...children)
  return elem
}

// set :host styles to make playwright detect the element as visible
const templateStyle = /*css*/ `
:host {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 99999;
  --monospace: 'SFMono-Regular', Consolas,
  'Liberation Mono', Menlo, Courier, monospace;
  --red: #ff5555;
  --yellow: #e2aa53;
  --purple: #cfa4ff;
  --cyan: #2dd9da;
  --dim: #c9c9c9;

  --window-background: #181818;
  --window-color: #d8d8d8;
}

.backdrop {
  position: fixed;
  z-index: 99999;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: scroll;
  margin: 0;
  background: rgba(0, 0, 0, 0.66);
}

.window {
  font-family: var(--monospace);
  line-height: 1.5;
  max-width: 80vw;
  color: var(--window-color);
  box-sizing: border-box;
  margin: 30px auto;
  padding: 2.5vh 4vw;
  position: relative;
  background: var(--window-background);
  border-radius: 6px 6px 8px 8px;
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);
  overflow: hidden;
  border-top: 8px solid var(--red);
  direction: ltr;
  text-align: left;
}

pre {
  font-family: var(--monospace);
  font-size: 16px;
  margin-top: 0;
  margin-bottom: 1em;
  overflow-x: scroll;
  scrollbar-width: none;
}

pre::-webkit-scrollbar {
  display: none;
}

pre.frame::-webkit-scrollbar {
  display: block;
  height: 5px;
}

pre.frame::-webkit-scrollbar-thumb {
  background: #999;
  border-radius: 5px;
}

pre.frame {
  scrollbar-width: thin;
}

.message {
  line-height: 1.3;
  font-weight: 600;
  white-space: pre-wrap;
}

.message-body {
  color: var(--red);
}

.plugin {
  color: var(--purple);
}

.file {
  color: var(--cyan);
  margin-bottom: 0;
  white-space: pre-wrap;
  word-break: break-all;
}

.frame {
  color: var(--yellow);
}

.stack {
  font-size: 13px;
  color: var(--dim);
}

.tip {
  font-size: 13px;
  color: #999;
  border-top: 1px dotted #999;
  padding-top: 13px;
  line-height: 1.8;
}

code {
  font-size: 13px;
  font-family: var(--monospace);
  color: var(--yellow);
}

.file-link {
  text-decoration: underline;
  cursor: pointer;
}

kbd {
  line-height: 1.5;
  font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.75rem;
  font-weight: 700;
  background-color: rgb(38, 40, 44);
  color: rgb(166, 167, 171);
  padding: 0.15rem 0.3rem;
  border-radius: 0.25rem;
  border-width: 0.0625rem 0.0625rem 0.1875rem;
  border-style: solid;
  border-color: rgb(54, 57, 64);
  border-image: initial;
}
`

// Error Template
const createTemplate = () =>
  h(
    'div',
    { class: 'backdrop', part: 'backdrop' },
    h(
      'div',
      { class: 'window', part: 'window' },
      h(
        'pre',
        { class: 'message', part: 'message' },
        h('span', { class: 'plugin', part: 'plugin' }),
        h('span', { class: 'message-body', part: 'message-body' }),
      ),
      h('pre', { class: 'file', part: 'file' }),
      h('pre', { class: 'frame', part: 'frame' }),
      h('pre', { class: 'stack', part: 'stack' }),
      h(
        'div',
        { class: 'tip', part: 'tip' },
        'Click outside, press ',
        h('kbd', {}, 'Esc'),
        ' key, or fix the code to dismiss.',
        h('br'),
        'You can also disable this overlay by setting ',
        h('code', { part: 'config-option-name' }, 'server.hmr.overlay'),
        ' to ',
        h('code', { part: 'config-option-value' }, 'false'),
        ' in ',
        h('code', { part: 'config-file-name' }, hmrConfigName),
        '.',
      ),
    ),
    h('style', {}, templateStyle),
  )

const fileRE = /(?:file:\/\/)?(?:[a-zA-Z]:\\|\/).*?:\d+:\d+/g
const codeframeRE = /^(?:>?\s*\d+\s+\|.*|\s+\|\s*\^.*)\r?\n/gm

// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where
// `HTMLElement` was not originally defined.
const { HTMLElement = class {} as typeof globalThis.HTMLElement } = globalThis
export class ErrorOverlay extends HTMLElement {
  root: ShadowRoot
  closeOnEsc: (e: KeyboardEvent) => void

  constructor(err: ErrorPayload['err'], links = true) {
    super()
    this.root = this.attachShadow({ mode: 'open' })
    this.root.appendChild(createTemplate())

    codeframeRE.lastIndex = 0
    const hasFrame = err.frame && codeframeRE.test(err.frame)
    const message = hasFrame
      ? err.message.replace(codeframeRE, '')
      : err.message
    if (err.plugin) {
      this.text('.plugin', `[plugin:${err.plugin}] `)
    }
    this.text('.message-body', message.trim())

    const [file] = (err.loc?.file || err.id || 'unknown file').split(`?`)
    if (err.loc) {
      this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links)
    } else if (err.id) {
      this.text('.file', file)
    }

    if (hasFrame) {
      this.text('.frame', err.frame!.trim())
    }
    this.text('.stack', err.stack, links)

    this.root.querySelector('.window')!.addEventListener('click', (e) => {
      e.stopPropagation()
    })

    this.addEventListener('click', () => {
      this.close()
    })

    this.closeOnEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape' || e.code === 'Escape') {
        this.close()
      }
    }

    document.addEventListener('keydown', this.closeOnEsc)
  }

  text(selector: string, text: string, linkFiles = false): void {
    const el = this.root.querySelector(selector)!
    if (!linkFiles) {
      el.textContent = text
    } else {
      let curIndex = 0
      let match: RegExpExecArray | null
      fileRE.lastIndex = 0
      while ((match = fileRE.exec(text))) {
        const { 0: file, index } = match
        const frag = text.slice(curIndex, index)
        el.appendChild(document.createTextNode(frag))
        const link = document.createElement('a')
        link.textContent = file
        link.className = 'file-link'
        link.onclick = () => {
          fetch(
            new URL(
              `${base}__open-in-editor?file=${encodeURIComponent(file)}`,
              import.meta.url,
            ),
          )
        }
        el.appendChild(link)
        curIndex += frag.length + file.length
      }
      if (curIndex < text.length) {
        el.appendChild(document.createTextNode(text.slice(curIndex)))
      }
    }
  }
  close(): void {
    this.parentNode?.removeChild(this)
    document.removeEventListener('keydown', this.closeOnEsc)
  }
}

export const overlayId = 'vite-error-overlay'
const { customElements } = globalThis // Ensure `customElements` is defined before the next line.
if (customElements && !customElements.get(overlayId)) {
  customElements.define(overlayId, ErrorOverlay)
}



================================================
FILE: packages/vite/src/client/tsconfig.json
================================================
{
  "extends": "../../tsconfig.base.json",
  "include": ["./", "../types"],
  "compilerOptions": {
    "types": [],
    "target": "ES2020",
    "lib": ["ESNext", "DOM"],
    "declaration": false
  }
}



================================================
FILE: packages/vite/src/module-runner/constants.ts
================================================
// they are exported from ssrTransform plugin, but we can't import from there for performance reasons
export const ssrModuleExportsKey = `__vite_ssr_exports__`
export const ssrImportKey = `__vite_ssr_import__`
export const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`
export const ssrExportAllKey = `__vite_ssr_exportAll__`
export const ssrExportNameKey = `__vite_ssr_exportName__`
export const ssrImportMetaKey = `__vite_ssr_import_meta__`



================================================
FILE: packages/vite/src/module-runner/createImportMeta.ts
================================================
import { isWindows } from '../shared/utils'
import {
  type ImportMetaResolver,
  createImportMetaResolver,
} from './importMetaResolver'
import type { ModuleRunnerImportMeta } from './types'
import { posixDirname, posixPathToFileHref, toWindowsPath } from './utils'

const envProxy = new Proxy({} as any, {
  get(_, p) {
    throw new Error(
      `[module runner] Dynamic access of "import.meta.env" is not supported. Please, use "import.meta.env.${String(p)}" instead.`,
    )
  },
})

export function createDefaultImportMeta(
  modulePath: string,
): ModuleRunnerImportMeta {
  const href = posixPathToFileHref(modulePath)
  const filename = modulePath
  const dirname = posixDirname(modulePath)
  return {
    filename: isWindows ? toWindowsPath(filename) : filename,
    dirname: isWindows ? toWindowsPath(dirname) : dirname,
    url: href,
    env: envProxy,
    resolve(_id: string, _parent?: string) {
      throw new Error('[module runner] "import.meta.resolve" is not supported.')
    },
    // should be replaced during transformation
    glob() {
      throw new Error(
        `[module runner] "import.meta.glob" is statically replaced during ` +
          `file transformation. Make sure to reference it by the full name.`,
      )
    },
  }
}

let importMetaResolverCache: Promise<ImportMetaResolver | undefined> | undefined

/**
 * Create import.meta object for Node.js.
 */
export async function createNodeImportMeta(
  modulePath: string,
): Promise<ModuleRunnerImportMeta> {
  const defaultMeta = createDefaultImportMeta(modulePath)
  const href = defaultMeta.url

  importMetaResolverCache ??= createImportMetaResolver()
  const importMetaResolver = await importMetaResolverCache

  return {
    ...defaultMeta,
    main: false,
    resolve(id: string, parent?: string) {
      const resolver = importMetaResolver ?? defaultMeta.resolve
      return resolver(id, parent ?? href)
    },
  }
}



================================================
FILE: packages/vite/src/module-runner/esmEvaluator.ts
================================================
import {
  AsyncFunction,
  getAsyncFunctionDeclarationPaddingLineCount,
} from '../shared/utils'
import {
  ssrDynamicImportKey,
  ssrExportAllKey,
  ssrExportNameKey,
  ssrImportKey,
  ssrImportMetaKey,
  ssrModuleExportsKey,
} from './constants'
import type { ModuleEvaluator, ModuleRunnerContext } from './types'

export class ESModulesEvaluator implements ModuleEvaluator {
  public readonly startOffset = getAsyncFunctionDeclarationPaddingLineCount()

  async runInlinedModule(
    context: ModuleRunnerContext,
    code: string,
  ): Promise<any> {
    // use AsyncFunction instead of vm module to support broader array of environments out of the box
    const initModule = new AsyncFunction(
      ssrModuleExportsKey,
      ssrImportMetaKey,
      ssrImportKey,
      ssrDynamicImportKey,
      ssrExportAllKey,
      ssrExportNameKey,
      // source map should already be inlined by Vite
      '"use strict";' + code,
    )

    await initModule(
      context[ssrModuleExportsKey],
      context[ssrImportMetaKey],
      context[ssrImportKey],
      context[ssrDynamicImportKey],
      context[ssrExportAllKey],
      context[ssrExportNameKey],
    )

    Object.seal(context[ssrModuleExportsKey])
  }

  runExternalModule(filepath: string): Promise<any> {
    return import(filepath)
  }
}



================================================
FILE: packages/vite/src/module-runner/evaluatedModules.ts
================================================
import { cleanUrl, isWindows, slash, unwrapId } from '../shared/utils'
import { SOURCEMAPPING_URL } from '../shared/constants'
import { decodeBase64 } from './utils'
import { DecodedMap } from './sourcemap/decoder'
import type { ResolvedResult } from './types'

const MODULE_RUNNER_SOURCEMAPPING_REGEXP = new RegExp(
  `//# ${SOURCEMAPPING_URL}=data:application/json;base64,(.+)`,
)

export class EvaluatedModuleNode {
  public importers = new Set<string>()
  public imports = new Set<string>()
  public evaluated = false
  public meta: ResolvedResult | undefined
  public promise: Promise<any> | undefined
  public exports: any | undefined
  public file: string
  public map: DecodedMap | undefined

  constructor(
    public id: string,
    public url: string,
  ) {
    this.file = cleanUrl(id)
  }
}

export class EvaluatedModules {
  public readonly idToModuleMap = new Map<string, EvaluatedModuleNode>()
  public readonly fileToModulesMap = new Map<string, Set<EvaluatedModuleNode>>()
  public readonly urlToIdModuleMap = new Map<string, EvaluatedModuleNode>()

  /**
   * Returns the module node by the resolved module ID. Usually, module ID is
   * the file system path with query and/or hash. It can also be a virtual module.
   *
   * Module runner graph will have 1 to 1 mapping with the server module graph.
   * @param id Resolved module ID
   */
  public getModuleById(id: string): EvaluatedModuleNode | undefined {
    return this.idToModuleMap.get(id)
  }

  /**
   * Returns all modules related to the file system path. Different modules
   * might have different query parameters or hash, so it's possible to have
   * multiple modules for the same file.
   * @param file The file system path of the module
   */
  public getModulesByFile(file: string): Set<EvaluatedModuleNode> | undefined {
    return this.fileToModulesMap.get(file)
  }

  /**
   * Returns the module node by the URL that was used in the import statement.
   * Unlike module graph on the server, the URL is not resolved and is used as is.
   * @param url Server URL that was used in the import statement
   */
  public getModuleByUrl(url: string): EvaluatedModuleNode | undefined {
    return this.urlToIdModuleMap.get(unwrapId(url))
  }

  /**
   * Ensure that module is in the graph. If the module is already in the graph,
   * it will return the existing module node. Otherwise, it will create a new
   * module node and add it to the graph.
   * @param id Resolved module ID
   * @param url URL that was used in the import statement
   */
  public ensureModule(id: string, url: string): EvaluatedModuleNode {
    id = normalizeModuleId(id)
    if (this.idToModuleMap.has(id)) {
      const moduleNode = this.idToModuleMap.get(id)!
      this.urlToIdModuleMap.set(url, moduleNode)
      return moduleNode
    }
    const moduleNode = new EvaluatedModuleNode(id, url)
    this.idToModuleMap.set(id, moduleNode)
    this.urlToIdModuleMap.set(url, moduleNode)

    const fileModules = this.fileToModulesMap.get(moduleNode.file) || new Set()
    fileModules.add(moduleNode)
    this.fileToModulesMap.set(moduleNode.file, fileModules)
    return moduleNode
  }

  public invalidateModule(node: EvaluatedModuleNode): void {
    node.evaluated = false
    node.meta = undefined
    node.map = undefined
    node.promise = undefined
    node.exports = undefined
    // remove imports in case they are changed,
    // don't remove the importers because otherwise it will be empty after evaluation
    // this can create a bug when file was removed but it still triggers full-reload
    // we are fine with the bug for now because it's not a common case
    node.imports.clear()
  }

  /**
   * Extracts the inlined source map from the module code and returns the decoded
   * source map. If the source map is not inlined, it will return null.
   * @param id Resolved module ID
   */
  getModuleSourceMapById(id: string): DecodedMap | null {
    const mod = this.getModuleById(id)
    if (!mod) return null
    if (mod.map) return mod.map
    if (!mod.meta || !('code' in mod.meta)) return null

    const pattern = `//# ${SOURCEMAPPING_URL}=data:application/json;base64,`
    const lastIndex = mod.meta.code.lastIndexOf(pattern)
    if (lastIndex === -1) return null

    const mapString = MODULE_RUNNER_SOURCEMAPPING_REGEXP.exec(
      mod.meta.code.slice(lastIndex),
    )?.[1]
    if (!mapString) return null
    mod.map = new DecodedMap(JSON.parse(decodeBase64(mapString)), mod.file)
    return mod.map
  }

  public clear(): void {
    this.idToModuleMap.clear()
    this.fileToModulesMap.clear()
    this.urlToIdModuleMap.clear()
  }
}

// unique id that is not available as "$bare_import" like "test"
// https://nodejs.org/api/modules.html#built-in-modules-with-mandatory-node-prefix
const prefixedBuiltins = new Set([
  'node:sea',
  'node:sqlite',
  'node:test',
  'node:test/reporters',
])

// transform file url to id
// virtual:custom -> virtual:custom
// \0custom -> \0custom
// node:fs -> fs
// /@fs/C:/root/id.js => C:/root/id.js
// file:///C:/root/id.js -> C:/root/id.js
export function normalizeModuleId(file: string): string {
  if (prefixedBuiltins.has(file)) return file

  // unix style, but Windows path still starts with the drive letter to check the root
  const unixFile = slash(file)
    .replace(/^\/@fs\//, isWindows ? '' : '/')
    .replace(/^node:/, '')
    .replace(/^\/+/, '/')

  // if it's not in the root, keep it as a path, not a URL
  return unixFile.replace(/^file:\/+/, isWindows ? '' : '/')
}



================================================
FILE: packages/vite/src/module-runner/hmrHandler.ts
================================================
import type { HotPayload } from 'types/hmrPayload'
import { slash, unwrapId } from '../shared/utils'
import { ERR_OUTDATED_OPTIMIZED_DEP } from '../shared/constants'
import { createHMRHandler } from '../shared/hmrHandler'
import type { ModuleRunner } from './runner'

export function createHMRHandlerForRunner(
  runner: ModuleRunner,
): (payload: HotPayload) => Promise<void> {
  return createHMRHandler(async (payload) => {
    const hmrClient = runner.hmrClient
    if (!hmrClient || runner.isClosed()) return
    switch (payload.type) {
      case 'connected':
        hmrClient.logger.debug(`connected.`)
        break
      case 'update':
        await hmrClient.notifyListeners('vite:beforeUpdate', payload)
        await Promise.all(
          payload.updates.map(async (update): Promise<void> => {
            if (update.type === 'js-update') {
              // runner always caches modules by their full path without /@id/ prefix
              update.acceptedPath = unwrapId(update.acceptedPath)
              update.path = unwrapId(update.path)
              return hmrClient.queueUpdate(update)
            }

            hmrClient.logger.error('css hmr is not supported in runner mode.')
          }),
        )
        await hmrClient.notifyListeners('vite:afterUpdate', payload)
        break
      case 'custom': {
        await hmrClient.notifyListeners(payload.event, payload.data)
        break
      }
      case 'full-reload': {
        const { triggeredBy } = payload
        const clearEntrypointUrls = triggeredBy
          ? getModulesEntrypoints(
              runner,
              getModulesByFile(runner, slash(triggeredBy)),
            )
          : findAllEntrypoints(runner)

        if (!clearEntrypointUrls.size) break

        hmrClient.logger.debug(`program reload`)
        await hmrClient.notifyListeners('vite:beforeFullReload', payload)
        runner.evaluatedModules.clear()

        for (const url of clearEntrypointUrls) {
          try {
            await runner.import(url)
          } catch (err) {
            if (err.code !== ERR_OUTDATED_OPTIMIZED_DEP) {
              hmrClient.logger.error(
                `An error happened during full reload\n${err.message}\n${err.stack}`,
              )
            }
          }
        }
        break
      }
      case 'prune':
        await hmrClient.notifyListeners('vite:beforePrune', payload)
        await hmrClient.prunePaths(payload.paths)
        break
      case 'error': {
        await hmrClient.notifyListeners('vite:error', payload)
        const err = payload.err
        hmrClient.logger.error(
          `Internal Server Error\n${err.message}\n${err.stack}`,
        )
        break
      }
      case 'ping': // noop
        break
      default: {
        const check: never = payload
        return check
      }
    }
  })
}

function getModulesByFile(runner: ModuleRunner, file: string): string[] {
  const nodes = runner.evaluatedModules.getModulesByFile(file)
  if (!nodes) {
    return []
  }
  return [...nodes].map((node) => node.id)
}

function getModulesEntrypoints(
  runner: ModuleRunner,
  modules: string[],
  visited = new Set<string>(),
  entrypoints = new Set<string>(),
) {
  for (const moduleId of modules) {
    if (visited.has(moduleId)) continue
    visited.add(moduleId)
    const module = runner.evaluatedModules.getModuleById(moduleId)
    if (!module) {
      continue
    }
    if (!module.importers.size) {
      entrypoints.add(module.url)
      continue
    }
    for (const importer of module.importers) {
      getModulesEntrypoints(runner, [importer], visited, entrypoints)
    }
  }
  return entrypoints
}

function findAllEntrypoints(
  runner: ModuleRunner,
  entrypoints = new Set<string>(),
): Set<string> {
  for (const mod of runner.evaluatedModules.idToModuleMap.values()) {
    if (!mod.importers.size) {
      entrypoints.add(mod.url)
    }
  }
  return entrypoints
}



================================================
FILE: packages/vite/src/module-runner/hmrLogger.ts
================================================
import type { HMRLogger } from '../shared/hmr'

const noop = (): void => {}

export const silentConsole: HMRLogger = {
  debug: noop,
  error: noop,
}

export const hmrLogger: HMRLogger = {
  debug: (...msg) => console.log('[vite]', ...msg),
  error: (error) => console.log('[vite]', error),
}



================================================
FILE: packages/vite/src/module-runner/importMetaResolver.ts
================================================
export type ImportMetaResolver = (specifier: string, importer: string) => string

const customizationHookNamespace = 'vite-module-runner:import-meta-resolve/v1/'
const customizationHooksModule = /* js */ `

export async function resolve(specifier, context, nextResolve) {
  if (specifier.startsWith(${JSON.stringify(customizationHookNamespace)})) {
    const data = specifier.slice(${JSON.stringify(customizationHookNamespace)}.length)
    const [parsedSpecifier, parsedImporter] = JSON.parse(data)
    specifier = parsedSpecifier
    context.parentURL = parsedImporter
  }

  return nextResolve(specifier, context)
}

`

export async function createImportMetaResolver(): Promise<
  ImportMetaResolver | undefined
> {
  let module: typeof import('node:module')
  try {
    module = (await import('node:module')).Module
  } catch {
    return
  }
  // `module.Module` may be `undefined` when `node:module` is mocked
  if (!module?.register) {
    return
  }

  try {
    const hookModuleContent = `data:text/javascript,${encodeURI(customizationHooksModule)}`
    module.register(hookModuleContent)
  } catch (e) {
    // For `--experimental-network-imports` flag that exists in Node before v22
    if ('code' in e && e.code === 'ERR_NETWORK_IMPORT_DISALLOWED') {
      return
    }
    throw e
  }

  return (specifier: string, importer: string) =>
    import.meta.resolve(
      `${customizationHookNamespace}${JSON.stringify([specifier, importer])}`,
    )
}



================================================
FILE: packages/vite/src/module-runner/index.ts
================================================
// this file should re-export only things that don't rely on Node.js or other runner features

export {
  EvaluatedModules,
  normalizeModuleId,
  type EvaluatedModuleNode,
} from './evaluatedModules'
export { ModuleRunner } from './runner'
export { ESModulesEvaluator } from './esmEvaluator'
export {
  createDefaultImportMeta,
  createNodeImportMeta,
} from './createImportMeta'

export { createWebSocketModuleRunnerTransport } from '../shared/moduleRunnerTransport'

export type { FetchFunctionOptions, FetchResult } from '../shared/invokeMethods'
export type {
  ModuleRunnerTransportHandlers,
  ModuleRunnerTransport,
} from '../shared/moduleRunnerTransport'
export type { HMRLogger } from '../shared/hmr'
export type {
  ModuleEvaluator,
  ModuleRunnerContext,
  FetchFunction,
  ResolvedResult,
  SSRImportMetadata,
  ModuleRunnerImportMeta,
  ModuleRunnerOptions,
  ModuleRunnerHmr,
} from './types'
export {
  ssrDynamicImportKey,
  ssrExportAllKey,
  ssrExportNameKey,
  ssrImportKey,
  ssrImportMetaKey,
  ssrModuleExportsKey,
} from './constants'
export type { InterceptorOptions } from './sourcemap/interceptor'



================================================
FILE: packages/vite/src/module-runner/runner.ts
================================================
import type { ViteHotContext } from 'types/hot'
import { HMRClient, HMRContext, type HMRLogger } from '../shared/hmr'
import { cleanUrl, isPrimitive } from '../shared/utils'
import { analyzeImportedModDifference } from '../shared/ssrTransform'
import {
  type NormalizedModuleRunnerTransport,
  normalizeModuleRunnerTransport,
} from '../shared/moduleRunnerTransport'
import type { EvaluatedModuleNode } from './evaluatedModules'
import { EvaluatedModules } from './evaluatedModules'
import type {
  ModuleEvaluator,
  ModuleRunnerContext,
  ModuleRunnerOptions,
  ResolvedResult,
  SSRImportMetadata,
} from './types'
import { posixDirname, posixPathToFileHref, posixResolve } from './utils'
import {
  ssrDynamicImportKey,
  ssrExportAllKey,
  ssrExportNameKey,
  ssrImportKey,
  ssrImportMetaKey,
  ssrModuleExportsKey,
} from './constants'
import { hmrLogger, silentConsole } from './hmrLogger'
import { createHMRHandlerForRunner } from './hmrHandler'
import { enableSourceMapSupport } from './sourcemap/index'
import { ESModulesEvaluator } from './esmEvaluator'
import { createDefaultImportMeta } from './createImportMeta'

interface ModuleRunnerDebugger {
  (formatter: unknown, ...args: unknown[]): void
}

export class ModuleRunner {
  public evaluatedModules: EvaluatedModules
  public hmrClient?: HMRClient

  private readonly transport: NormalizedModuleRunnerTransport
  private readonly resetSourceMapSupport?: () => void
  private readonly concurrentModuleNodePromises = new Map<
    string,
    Promise<EvaluatedModuleNode>
  >()

  private closed = false

  constructor(
    public options: ModuleRunnerOptions,
    public evaluator: ModuleEvaluator = new ESModulesEvaluator(),
    private debug?: ModuleRunnerDebugger,
  ) {
    this.evaluatedModules = options.evaluatedModules ?? new EvaluatedModules()
    this.transport = normalizeModuleRunnerTransport(options.transport)
    if (options.hmr !== false) {
      const optionsHmr = options.hmr ?? true
      const resolvedHmrLogger: HMRLogger =
        optionsHmr === true || optionsHmr.logger === undefined
          ? hmrLogger
          : optionsHmr.logger === false
            ? silentConsole
            : optionsHmr.logger
      this.hmrClient = new HMRClient(
        resolvedHmrLogger,
        this.transport,
        ({ acceptedPath }) => this.import(acceptedPath),
      )
      if (!this.transport.connect) {
        throw new Error(
          'HMR is not supported by this runner transport, but `hmr` option was set to true',
        )
      }
      this.transport.connect(createHMRHandlerForRunner(this))
    } else {
      this.transport.connect?.()
    }
    if (options.sourcemapInterceptor !== false) {
      this.resetSourceMapSupport = enableSourceMapSupport(this)
    }
  }

  /**
   * URL to execute. Accepts file path, server path or id relative to the root.
   */
  public async import<T = any>(url: string): Promise<T> {
    const fetchedModule = await this.cachedModule(url)
    return await this.cachedRequest(url, fetchedModule)
  }

  /**
   * Clear all caches including HMR listeners.
   */
  public clearCache(): void {
    this.evaluatedModules.clear()
    this.hmrClient?.clear()
  }

  /**
   * Clears all caches, removes all HMR listeners, and resets source map support.
   * This method doesn't stop the HMR connection.
   */
  public async close(): Promise<void> {
    this.resetSourceMapSupport?.()
    this.clearCache()
    this.hmrClient = undefined
    this.closed = true
    await this.transport.disconnect?.()
  }

  /**
   * Returns `true` if the runtime has been closed by calling `close()` method.
   */
  public isClosed(): boolean {
    return this.closed
  }

  private processImport(
    exports: Record<string, any>,
    fetchResult: ResolvedResult,
    metadata?: SSRImportMetadata,
  ) {
    if (!('externalize' in fetchResult)) {
      return exports
    }
    const { url, type } = fetchResult
    if (type !== 'module' && type !== 'commonjs') return exports
    analyzeImportedModDifference(exports, url, type, metadata)
    return exports
  }

  private isCircularModule(mod: EvaluatedModuleNode) {
    for (const importedFile of mod.imports) {
      if (mod.importers.has(importedFile)) {
        return true
      }
    }
    return false
  }

  private isCircularImport(
    importers: Set<string>,
    moduleUrl: string,
    visited = new Set<string>(),
  ) {
    for (const importer of importers) {
      if (visited.has(importer)) {
        continue
      }
      visited.add(importer)
      if (importer === moduleUrl) {
        return true
      }
      const mod = this.evaluatedModules.getModuleById(importer)
      if (
        mod &&
        mod.importers.size &&
        this.isCircularImport(mod.importers, moduleUrl, visited)
      ) {
        return true
      }
    }
    return false
  }

  private async cachedRequest(
    url: string,
    mod: EvaluatedModuleNode,
    callstack: string[] = [],
    metadata?: SSRImportMetadata,
  ): Promise<any> {
    const meta = mod.meta!
    const moduleId = meta.id

    const { importers } = mod

    const importee = callstack[callstack.length - 1]

    if (importee) importers.add(importee)

    // check circular dependency
    if (
      callstack.includes(moduleId) ||
      this.isCircularModule(mod) ||
      this.isCircularImport(importers, moduleId)
    ) {
      if (mod.exports) return this.processImport(mod.exports, meta, metadata)
    }

    let debugTimer: any
    if (this.debug) {
      debugTimer = setTimeout(() => {
        const getStack = () =>
          `stack:\n${[...callstack, moduleId]
            .reverse()
            .map((p) => `  - ${p}`)
            .join('\n')}`

        this.debug!(
          `[module runner] module ${moduleId} takes over 2s to load.\n${getStack()}`,
        )
      }, 2000)
    }

    try {
      // cached module
      if (mod.promise)
        return this.processImport(await mod.promise, meta, metadata)

      const promise = this.directRequest(url, mod, callstack)
      mod.promise = promise
      mod.evaluated = false
      return this.processImport(await promise, meta, metadata)
    } finally {
      mod.evaluated = true
      if (debugTimer) clearTimeout(debugTimer)
    }
  }

  private async cachedModule(
    url: string,
    importer?: string,
  ): Promise<EvaluatedModuleNode> {
    let cached = this.concurrentModuleNodePromises.get(url)
    if (!cached) {
      const cachedModule = this.evaluatedModules.getModuleByUrl(url)
      cached = this.getModuleInformation(url, importer, cachedModule).finally(
        () => {
          this.concurrentModuleNodePromises.delete(url)
        },
      )
      this.concurrentModuleNodePromises.set(url, cached)
    } else {
      this.debug?.('[module runner] using cached module info for', url)
    }

    return cached
  }

  private async getModuleInformation(
    url: string,
    importer: string | undefined,
    cachedModule: EvaluatedModuleNode | undefined,
  ): Promise<EvaluatedModuleNode> {
    if (this.closed) {
      throw new Error(`Vite module runner has been closed.`)
    }

    this.debug?.('[module runner] fetching', url)

    const isCached = !!(typeof cachedModule === 'object' && cachedModule.meta)

    const fetchedModule = // fast return for established externalized pattern
      (
        url.startsWith('data:')
          ? { externalize: url, type: 'builtin' }
          : await this.transport.invoke('fetchModule', [
              url,
              importer,
              {
                cached: isCached,
                startOffset: this.evaluator.startOffset,
              },
            ])
      ) as ResolvedResult

    if ('cache' in fetchedModule) {
      if (!cachedModule || !cachedModule.meta) {
        throw new Error(
          `Module "${url}" was mistakenly invalidated during fetch phase.`,
        )
      }
      return cachedModule
    }

    const moduleId =
      'externalize' in fetchedModule
        ? fetchedModule.externalize
        : fetchedModule.id
    const moduleUrl = 'url' in fetchedModule ? fetchedModule.url : url
    const module = this.evaluatedModules.ensureModule(moduleId, moduleUrl)

    if ('invalidate' in fetchedModule && fetchedModule.invalidate) {
      this.evaluatedModules.invalidateModule(module)
    }

    fetchedModule.url = moduleUrl
    fetchedModule.id = moduleId
    module.meta = fetchedModule

    return module
  }

  // override is allowed, consider this a public API
  protected async directRequest(
    url: string,
    mod: EvaluatedModuleNode,
    _callstack: string[],
  ): Promise<any> {
    const fetchResult = mod.meta!
    const moduleId = fetchResult.id
    const callstack = [..._callstack, moduleId]

    const request = async (dep: string, metadata?: SSRImportMetadata) => {
      const importer = ('file' in fetchResult && fetchResult.file) || moduleId
      const depMod = await this.cachedModule(dep, importer)
      depMod.importers.add(moduleId)
      mod.imports.add(depMod.id)

      return this.cachedRequest(dep, depMod, callstack, metadata)
    }

    const dynamicRequest = async (dep: string) => {
      // it's possible to provide an object with toString() method inside import()
      dep = String(dep)
      if (dep[0] === '.') {
        dep = posixResolve(posixDirname(url), dep)
      }
      return request(dep, { isDynamicImport: true })
    }

    if ('externalize' in fetchResult) {
      const { externalize } = fetchResult
      this.debug?.('[module runner] externalizing', externalize)
      const exports = await this.evaluator.runExternalModule(externalize)
      mod.exports = exports
      return exports
    }

    const { code, file } = fetchResult

    if (code == null) {
      const importer = callstack[callstack.length - 2]
      throw new Error(
        `[module runner] Failed to load "${url}"${
          importer ? ` imported from ${importer}` : ''
        }`,
      )
    }

    const createImportMeta =
      this.options.createImportMeta ?? createDefaultImportMeta

    const modulePath = cleanUrl(file || moduleId)
    // disambiguate the `<UNIT>:/` on windows: see nodejs/node#31710
    const href = posixPathToFileHref(modulePath)
    const meta = await createImportMeta(modulePath)
    const exports = Object.create(null)
    Object.defineProperty(exports, Symbol.toStringTag, {
      value: 'Module',
      enumerable: false,
      configurable: false,
    })

    mod.exports = exports

    let hotContext: ViteHotContext | undefined
    if (this.hmrClient) {
      Object.defineProperty(meta, 'hot', {
        enumerable: true,
        get: () => {
          if (!this.hmrClient) {
            throw new Error(`[module runner] HMR client was closed.`)
          }
          this.debug?.('[module runner] creating hmr context for', mod.url)
          hotContext ||= new HMRContext(this.hmrClient, mod.url)
          return hotContext
        },
        set: (value) => {
          hotContext = value
        },
      })
    }

    const context: ModuleRunnerContext = {
      [ssrImportKey]: request,
      [ssrDynamicImportKey]: dynamicRequest,
      [ssrModuleExportsKey]: exports,
      [ssrExportAllKey]: (obj: any) => exportAll(exports, obj),
      [ssrExportNameKey]: (name, getter) =>
        Object.defineProperty(exports, name, {
          enumerable: true,
          configurable: true,
          get: getter,
        }),
      [ssrImportMetaKey]: meta,
    }

    this.debug?.('[module runner] executing', href)

    await this.evaluator.runInlinedModule(context, code, mod)

    return exports
  }
}

function exportAll(exports: any, sourceModule: any) {
  // when a module exports itself it causes
  // call stack error
  if (exports === sourceModule) return

  if (
    isPrimitive(sourceModule) ||
    Array.isArray(sourceModule) ||
    sourceModule instanceof Promise
  )
    return

  for (const key in sourceModule) {
    if (key !== 'default' && key !== '__esModule' && !(key in exports)) {
      try {
        Object.defineProperty(exports, key, {
          enumerable: true,
          configurable: true,
          get: () => sourceModule[key],
        })
      } catch {}
    }
  }
}



================================================
FILE: packages/vite/src/module-runner/tsconfig.json
================================================
{
  "extends": "../../tsconfig.base.json",
  "include": ["./", "../node", "../dep-types", "../types"],
  "exclude": ["**/__tests__", "**/__tests_dts__"],
  "compilerOptions": {
    "lib": ["ESNext", "DOM"],
    "stripInternal": true
  }
}



================================================
FILE: packages/vite/src/module-runner/types.ts
================================================
import type { ViteHotContext } from 'types/hot'
import type { HMRLogger } from '../shared/hmr'
import type {
  DefineImportMetadata,
  SSRImportMetadata,
} from '../shared/ssrTransform'
import type {
  ExternalFetchResult,
  FetchFunctionOptions,
  FetchResult,
  ViteFetchResult,
} from '../shared/invokeMethods'
import type { ModuleRunnerTransport } from '../shared/moduleRunnerTransport'
import type { EvaluatedModuleNode, EvaluatedModules } from './evaluatedModules'
import type {
  ssrDynamicImportKey,
  ssrExportAllKey,
  ssrExportNameKey,
  ssrImportKey,
  ssrImportMetaKey,
  ssrModuleExportsKey,
} from './constants'
import type { InterceptorOptions } from './sourcemap/interceptor'

export type { DefineImportMetadata, SSRImportMetadata }

export interface ModuleRunnerImportMeta extends ImportMeta {
  url: string
  env: ImportMetaEnv
  hot?: ViteHotContext
  [key: string]: any
}

export interface ModuleRunnerContext {
  [ssrModuleExportsKey]: Record<string, any>
  [ssrImportKey]: (id: string, metadata?: DefineImportMetadata) => Promise<any>
  [ssrDynamicImportKey]: (
    id: string,
    options?: ImportCallOptions,
  ) => Promise<any>
  [ssrExportAllKey]: (obj: any) => void
  [ssrExportNameKey]: (name: string, getter: () => unknown) => void
  [ssrImportMetaKey]: ModuleRunnerImportMeta
}

export interface ModuleEvaluator {
  /**
   * Number of prefixed lines in the transformed code.
   */
  startOffset?: number
  /**
   * Run code that was transformed by Vite.
   * @param context Function context
   * @param code Transformed code
   * @param module The module node
   */
  runInlinedModule(
    context: ModuleRunnerContext,
    code: string,
    module: Readonly<EvaluatedModuleNode>,
  ): Promise<any>
  /**
   * Run externalized module.
   * @param file File URL to the external module
   */
  runExternalModule(file: string): Promise<any>
}

export type ResolvedResult = (ExternalFetchResult | ViteFetchResult) & {
  url: string
  id: string
}

export type FetchFunction = (
  id: string,
  importer?: string,
  options?: FetchFunctionOptions,
) => Promise<FetchResult>

export interface ModuleRunnerHmr {
  /**
   * Configure HMR logger.
   */
  logger?: false | HMRLogger
}

export interface ModuleRunnerOptions {
  /**
   * A set of methods to communicate with the server.
   */
  transport: ModuleRunnerTransport
  /**
   * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.
   * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.
   * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.
   */
  sourcemapInterceptor?:
    | false
    | 'node'
    | 'prepareStackTrace'
    | InterceptorOptions
  /**
   * Disable HMR or configure HMR options.
   *
   * @default true
   */
  hmr?: boolean | ModuleRunnerHmr
  /**
   * Create import.meta object for the module.
   *
   * @default createDefaultImportMeta
   */
  createImportMeta?: (
    modulePath: string,
  ) => ModuleRunnerImportMeta | Promise<ModuleRunnerImportMeta>
  /**
   * Custom module cache. If not provided, creates a separate module cache for each ModuleRunner instance.
   */
  evaluatedModules?: EvaluatedModules
}

export interface ImportMetaEnv {
  [key: string]: any
  BASE_URL: string
  MODE: string
  DEV: boolean
  PROD: boolean
  SSR: boolean
}



================================================
FILE: packages/vite/src/module-runner/utils.ts
================================================
import * as pathe from 'pathe'
import { isWindows } from '../shared/utils'

export const decodeBase64 =
  typeof atob !== 'undefined'
    ? atob
    : (str: string) => Buffer.from(str, 'base64').toString('utf-8')

const CHAR_FORWARD_SLASH = 47
const CHAR_BACKWARD_SLASH = 92

const percentRegEx = /%/g
const backslashRegEx = /\\/g
const newlineRegEx = /\n/g
const carriageReturnRegEx = /\r/g
const tabRegEx = /\t/g
const questionRegex = /\?/g
const hashRegex = /#/g

function encodePathChars(filepath: string) {
  if (filepath.indexOf('%') !== -1)
    filepath = filepath.replace(percentRegEx, '%25')
  // In posix, backslash is a valid character in paths:
  if (!isWindows && filepath.indexOf('\\') !== -1)
    filepath = filepath.replace(backslashRegEx, '%5C')
  if (filepath.indexOf('\n') !== -1)
    filepath = filepath.replace(newlineRegEx, '%0A')
  if (filepath.indexOf('\r') !== -1)
    filepath = filepath.replace(carriageReturnRegEx, '%0D')
  if (filepath.indexOf('\t') !== -1)
    filepath = filepath.replace(tabRegEx, '%09')
  return filepath
}

export const posixDirname = pathe.dirname
export const posixResolve = pathe.resolve

export function posixPathToFileHref(posixPath: string): string {
  let resolved = posixResolve(posixPath)
  // path.resolve strips trailing slashes so we must add them back
  const filePathLast = posixPath.charCodeAt(posixPath.length - 1)
  if (
    (filePathLast === CHAR_FORWARD_SLASH ||
      (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&
    resolved[resolved.length - 1] !== '/'
  )
    resolved += '/'

  // Call encodePathChars first to avoid encoding % again for ? and #.
  resolved = encodePathChars(resolved)

  // Question and hash character should be included in pathname.
  // Therefore, encoding is required to eliminate parsing them in different states.
  // This is done as an optimization to not creating a URL instance and
  // later triggering pathname setter, which impacts performance
  if (resolved.indexOf('?') !== -1)
    resolved = resolved.replace(questionRegex, '%3F')
  if (resolved.indexOf('#') !== -1)
    resolved = resolved.replace(hashRegex, '%23')
  return new URL(`file://${resolved}`).href
}

export function toWindowsPath(path: string): string {
  return path.replace(/\//g, '\\')
}



================================================
FILE: packages/vite/src/module-runner/sourcemap/decoder.ts
================================================
import type { OriginalMapping } from '@jridgewell/trace-mapping'
import { originalPositionFor } from '@jridgewell/trace-mapping'
import { posixResolve } from '../utils'

interface SourceMapLike {
  version: number
  mappings?: string
  names?: string[]
  sources?: string[]
  sourcesContent?: string[]
}

type Needle = {
  line: number
  column: number
}

export class DecodedMap {
  _encoded: string
  _decoded: undefined | number[][][]
  _decodedMemo: Stats
  url: string
  version: number
  names: string[] = []
  resolvedSources: string[]

  constructor(
    public map: SourceMapLike,
    from: string,
  ) {
    const { mappings, names, sources } = map
    this.version = map.version
    this.names = names || []
    this._encoded = mappings || ''
    this._decodedMemo = memoizedState()
    this.url = from
    this.resolvedSources = (sources || []).map((s) =>
      posixResolve(s || '', from),
    )
  }
}

interface Stats {
  lastKey: number
  lastNeedle: number
  lastIndex: number
}
function memoizedState(): Stats {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1,
  }
}
export function getOriginalPosition(
  map: DecodedMap,
  needle: Needle,
): OriginalMapping | null {
  const result = originalPositionFor(map as any, needle)
  if (result.column == null) {
    return null
  }
  return result
}



================================================
FILE: packages/vite/src/module-runner/sourcemap/index.ts
================================================
import type { ModuleRunner } from '../runner'
import { interceptStackTrace } from './interceptor'

export function enableSourceMapSupport(runner: ModuleRunner): () => void {
  if (runner.options.sourcemapInterceptor === 'node') {
    if (typeof process === 'undefined') {
      throw new TypeError(
        `Cannot use "sourcemapInterceptor: 'node'" because global "process" variable is not available.`,
      )
    }
    /* eslint-disable n/no-unsupported-features/node-builtins -- process.setSourceMapsEnabled and process.sourceMapsEnabled */
    if (typeof process.setSourceMapsEnabled !== 'function') {
      throw new TypeError(
        `Cannot use "sourcemapInterceptor: 'node'" because "process.setSourceMapsEnabled" function is not available. Please use Node >= 16.6.0.`,
      )
    }
    const isEnabledAlready = process.sourceMapsEnabled ?? false
    process.setSourceMapsEnabled(true)
    return () => !isEnabledAlready && process.setSourceMapsEnabled(false)
    /* eslint-enable n/no-unsupported-features/node-builtins */
  }
  return interceptStackTrace(
    runner,
    typeof runner.options.sourcemapInterceptor === 'object'
      ? runner.options.sourcemapInterceptor
      : undefined,
  )
}



================================================
FILE: packages/vite/src/module-runner/sourcemap/interceptor.ts
================================================
import type { OriginalMapping } from '@jridgewell/trace-mapping'
import type { ModuleRunner } from '../runner'
import { posixDirname, posixResolve } from '../utils'
import type { EvaluatedModules } from '../evaluatedModules'
import { slash } from '../../shared/utils'
import { DecodedMap, getOriginalPosition } from './decoder'

interface RetrieveFileHandler {
  (path: string): string | null | undefined | false
}

interface RetrieveSourceMapHandler {
  (path: string): null | { url: string; map: any }
}

export interface InterceptorOptions {
  retrieveFile?: RetrieveFileHandler
  retrieveSourceMap?: RetrieveSourceMapHandler
}

const sourceMapCache: Record<string, CachedMapEntry> = {}
const fileContentsCache: Record<string, string> = {}

const evaluatedModulesCache = new Set<EvaluatedModules>()
const retrieveFileHandlers = new Set<RetrieveFileHandler>()
const retrieveSourceMapHandlers = new Set<RetrieveSourceMapHandler>()

const createExecHandlers = <T extends (...args: any) => any>(
  handlers: Set<T>,
) => {
  return ((...args: Parameters<T>) => {
    for (const handler of handlers) {
      const result = handler(...args)
      if (result) return result
    }
    return null
  }) as T
}

const retrieveFileFromHandlers = createExecHandlers(retrieveFileHandlers)
const retrieveSourceMapFromHandlers = createExecHandlers(
  retrieveSourceMapHandlers,
)

let overridden = false
const originalPrepare = Error.prepareStackTrace

function resetInterceptor(runner: ModuleRunner, options: InterceptorOptions) {
  evaluatedModulesCache.delete(runner.evaluatedModules)
  if (options.retrieveFile) retrieveFileHandlers.delete(options.retrieveFile)
  if (options.retrieveSourceMap)
    retrieveSourceMapHandlers.delete(options.retrieveSourceMap)
  if (evaluatedModulesCache.size === 0) {
    Error.prepareStackTrace = originalPrepare
    overridden = false
  }
}

export function interceptStackTrace(
  runner: ModuleRunner,
  options: InterceptorOptions = {},
): () => void {
  if (!overridden) {
    Error.prepareStackTrace = prepareStackTrace
    overridden = true
  }
  evaluatedModulesCache.add(runner.evaluatedModules)
  if (options.retrieveFile) retrieveFileHandlers.add(options.retrieveFile)
  if (options.retrieveSourceMap)
    retrieveSourceMapHandlers.add(options.retrieveSourceMap)
  return () => resetInterceptor(runner, options)
}

interface CallSite extends NodeJS.CallSite {
  getScriptNameOrSourceURL(): string
}

interface State {
  nextPosition: null | OriginalMapping
  curPosition: null | OriginalMapping
}

interface CachedMapEntry {
  url: string | null
  map: DecodedMap | null
  vite?: boolean
}

// Support URLs relative to a directory, but be careful about a protocol prefix
function supportRelativeURL(file: string, url: string) {
  if (!file) return url
  const dir = posixDirname(slash(file))
  const match = /^\w+:\/\/[^/]*/.exec(dir)
  let protocol = match ? match[0] : ''
  const startPath = dir.slice(protocol.length)
  if (protocol && /^\/\w:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/'
    return protocol + slash(posixResolve(startPath, url))
  }
  return protocol + posixResolve(startPath, url)
}

function getRunnerSourceMap(position: OriginalMapping): CachedMapEntry | null {
  for (const moduleGraph of evaluatedModulesCache) {
    const sourceMap = moduleGraph.getModuleSourceMapById(position.source!)
    if (sourceMap) {
      return {
        url: position.source,
        map: sourceMap,
        vite: true,
      }
    }
  }
  return null
}

function retrieveFile(path: string): string | null | undefined | false {
  if (path in fileContentsCache) return fileContentsCache[path]
  const content = retrieveFileFromHandlers(path)
  if (typeof content === 'string') {
    fileContentsCache[path] = content
    return content
  }
  return null
}

function retrieveSourceMapURL(source: string) {
  // Get the URL of the source map
  const fileData = retrieveFile(source)
  if (!fileData) return null
  const re =
    /\/\/[@#]\s*sourceMappingURL=([^\s'"]+)\s*$|\/\*[@#]\s*sourceMappingURL=[^\s*'"]+\s*\*\/\s*$/gm
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  let lastMatch, match

  while ((match = re.exec(fileData))) lastMatch = match
  if (!lastMatch) return null
  return lastMatch[1]
}

const reSourceMap = /^data:application\/json[^,]+base64,/

function retrieveSourceMap(source: string) {
  const urlAndMap = retrieveSourceMapFromHandlers(source)
  if (urlAndMap) return urlAndMap

  let sourceMappingURL = retrieveSourceMapURL(source)
  if (!sourceMappingURL) return null

  // Read the contents of the source map
  let sourceMapData
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    const rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)
    sourceMapData = Buffer.from(rawData, 'base64').toString()
    sourceMappingURL = source
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL)
    sourceMapData = retrieveFile(sourceMappingURL)
  }

  if (!sourceMapData) return null

  return {
    url: sourceMappingURL,
    map: sourceMapData,
  }
}

function mapSourcePosition(position: OriginalMapping) {
  if (!position.source) return position
  let sourceMap = getRunnerSourceMap(position)
  if (!sourceMap) sourceMap = sourceMapCache[position.source]
  if (!sourceMap) {
    // Call the (overridable) retrieveSourceMap function to get the source map.
    const urlAndMap = retrieveSourceMap(position.source)
    if (urlAndMap && urlAndMap.map) {
      const url = urlAndMap.url
      sourceMap = sourceMapCache[position.source] = {
        url,
        map: new DecodedMap(
          typeof urlAndMap.map === 'string'
            ? JSON.parse(urlAndMap.map)
            : urlAndMap.map,
          url,
        ),
      }

      const contents = sourceMap.map?.map.sourcesContent
      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map && contents) {
        sourceMap.map.resolvedSources.forEach((source, i) => {
          const content = contents[i]
          if (content && source && url) {
            const contentUrl = supportRelativeURL(url, source)
            fileContentsCache[contentUrl] = content
          }
        })
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null,
      }
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap.map && sourceMap.url) {
    const originalPosition = getOriginalPosition(sourceMap.map, position)

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition && originalPosition.source != null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url,
        originalPosition.source,
      )
      if (sourceMap.vite) {
        // @ts-expect-error vite is not defined
        originalPosition._vite = true
      }
      return originalPosition
    }
  }

  return position
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin: string): string {
  // Most eval() calls are in this format
  let match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin)
  if (match) {
    const position = mapSourcePosition({
      name: null,
      source: match[2],
      line: +match[3],
      column: +match[4] - 1,
    })
    return `eval at ${match[1]} (${position.source}:${position.line}:${position.column + 1})`
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin)
  if (match) return `eval at ${match[1]} (${mapEvalOrigin(match[2])})`

  // Make sure we still return useful information if we didn't find anything
  return origin
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString(this: CallSite) {
  let fileName
  let fileLocation = ''
  if (this.isNative()) {
    fileLocation = 'native'
  } else {
    fileName = this.getScriptNameOrSourceURL()
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin() as string
      fileLocation += ', ' // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += '<anonymous>'
    }
    const lineNumber = this.getLineNumber()
    if (lineNumber != null) {
      fileLocation += `:${lineNumber}`
      const columnNumber = this.getColumnNumber()
      if (columnNumber) fileLocation += `:${columnNumber}`
    }
  }

  let line = ''
  const functionName = this.getFunctionName()
  let addSuffix = true
  const isConstructor = this.isConstructor()
  const isMethodCall = !(this.isToplevel() || isConstructor)
  if (isMethodCall) {
    let typeName = this.getTypeName()
    // Fixes shim to be backward compatible with Node v0 to v4
    if (typeName === '[object Object]') typeName = 'null'

    const methodName = this.getMethodName()
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0)
        line += `${typeName}.`

      line += functionName
      if (
        methodName &&
        functionName.indexOf(`.${methodName}`) !==
          functionName.length - methodName.length - 1
      )
        line += ` [as ${methodName}]`
    } else {
      line += `${typeName}.${methodName || '<anonymous>'}`
    }
  } else if (isConstructor) {
    line += `new ${functionName || '<anonymous>'}`
  } else if (functionName) {
    line += functionName
  } else {
    line += fileLocation
    addSuffix = false
  }
  if (addSuffix) line += ` (${fileLocation})`

  return line
}

function cloneCallSite(frame: CallSite) {
  const object = {} as CallSite
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach((name) => {
    const key = name as keyof CallSite
    // @ts-expect-error difficult to type
    object[key] = /^(?:is|get)/.test(name)
      ? function () {
          return frame[key].call(frame)
        }
      : frame[key]
  })
  object.toString = CallSiteToString
  return object
}

function wrapCallSite(frame: CallSite, state: State) {
  // provides interface backward compatibility
  if (state === undefined) state = { nextPosition: null, curPosition: null }

  if (frame.isNative()) {
    state.curPosition = null
    return frame
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  const source = frame.getFileName() || frame.getScriptNameOrSourceURL()
  if (source) {
    const line = frame.getLineNumber() as number
    let column = (frame.getColumnNumber() as number) - 1

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    const headerLength = 62
    if (line === 1 && column > headerLength && !frame.isEval())
      column -= headerLength

    const position = mapSourcePosition({
      name: null,
      source,
      line,
      column,
    })
    state.curPosition = position
    frame = cloneCallSite(frame)
    const originalFunctionName = frame.getFunctionName
    frame.getFunctionName = function () {
      const name = (() => {
        if (state.nextPosition == null) return originalFunctionName()

        return state.nextPosition.name || originalFunctionName()
      })()
      return name === 'eval' && '_vite' in position ? null : name
    }
    frame.getFileName = function () {
      return position.source ?? null
    }
    frame.getLineNumber = function () {
      return position.line
    }
    frame.getColumnNumber = function () {
      return position.column + 1
    }
    frame.getScriptNameOrSourceURL = function () {
      return position.source as string
    }
    return frame
  }

  // Code called using eval() needs special handling
  let origin = frame.isEval() && frame.getEvalOrigin()
  if (origin) {
    origin = mapEvalOrigin(origin)
    frame = cloneCallSite(frame)
    frame.getEvalOrigin = function () {
      return origin || undefined
    }
    return frame
  }

  // If we get here then we were unable to change the source position
  return frame
}

function prepareStackTrace(error: Error, stack: CallSite[]) {
  const name = error.name || 'Error'
  const message = error.message || ''
  const errorString = `${name}: ${message}`

  const state = { nextPosition: null, curPosition: null }
  const processedStack = []
  for (let i = stack.length - 1; i >= 0; i--) {
    processedStack.push(`\n    at ${wrapCallSite(stack[i], state)}`)
    state.nextPosition = state.curPosition
  }
  state.curPosition = state.nextPosition = null
  return errorString + processedStack.reverse().join('')
}



================================================
FILE: packages/vite/src/node/assetSource.ts
================================================
import type { DefaultTreeAdapterMap, Token } from 'parse5'

interface HtmlAssetSource {
  srcAttributes?: string[]
  srcsetAttributes?: string[]
  /**
   * Called before handling an attribute to determine if it should be processed.
   */
  filter?: (data: HtmlAssetSourceFilterData) => boolean
}

interface HtmlAssetSourceFilterData {
  key: string
  value: string
  attributes: Record<string, string>
}

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name
// https://wiki.whatwg.org/wiki/MetaExtensions
const ALLOWED_META_NAME = [
  'msapplication-tileimage',
  'msapplication-square70x70logo',
  'msapplication-square150x150logo',
  'msapplication-wide310x150logo',
  'msapplication-square310x310logo',
  'msapplication-config',
  'twitter:image',
]

// https://ogp.me
const ALLOWED_META_PROPERTY = [
  'og:image',
  'og:image:url',
  'og:image:secure_url',
  'og:audio',
  'og:audio:secure_url',
  'og:video',
  'og:video:secure_url',
]

const DEFAULT_HTML_ASSET_SOURCES: Record<string, HtmlAssetSource> = {
  audio: {
    srcAttributes: ['src'],
  },
  embed: {
    srcAttributes: ['src'],
  },
  img: {
    srcAttributes: ['src'],
    srcsetAttributes: ['srcset'],
  },
  image: {
    srcAttributes: ['href', 'xlink:href'],
  },
  input: {
    srcAttributes: ['src'],
  },
  link: {
    srcAttributes: ['href'],
    srcsetAttributes: ['imagesrcset'],
  },
  object: {
    srcAttributes: ['data'],
  },
  source: {
    srcAttributes: ['src'],
    srcsetAttributes: ['srcset'],
  },
  track: {
    srcAttributes: ['src'],
  },
  use: {
    srcAttributes: ['href', 'xlink:href'],
  },
  video: {
    srcAttributes: ['src', 'poster'],
  },
  meta: {
    srcAttributes: ['content'],
    filter({ attributes }) {
      if (
        attributes.name &&
        ALLOWED_META_NAME.includes(attributes.name.trim().toLowerCase())
      ) {
        return true
      }

      if (
        attributes.property &&
        ALLOWED_META_PROPERTY.includes(attributes.property.trim().toLowerCase())
      ) {
        return true
      }

      return false
    },
  },
}

interface HtmlAssetAttribute {
  type: 'src' | 'srcset' | 'remove'
  key: string
  value: string
  attributes: Record<string, string>
  location: Token.Location
}

/**
 * Given a HTML node, find all attributes that references an asset to be processed
 */
export function getNodeAssetAttributes(
  node: DefaultTreeAdapterMap['element'],
): HtmlAssetAttribute[] {
  const matched = DEFAULT_HTML_ASSET_SOURCES[node.nodeName]
  if (!matched) return []

  const attributes: Record<string, string> = {}
  for (const attr of node.attrs) {
    attributes[getAttrKey(attr)] = attr.value
  }

  // If the node has a `vite-ignore` attribute, remove the attribute and early out
  // to skip processing any attributes
  if ('vite-ignore' in attributes) {
    return [
      {
        type: 'remove',
        key: 'vite-ignore',
        value: '',
        attributes,
        location: node.sourceCodeLocation!.attrs!['vite-ignore'],
      },
    ]
  }

  const actions: HtmlAssetAttribute[] = []
  function handleAttributeKey(key: string, type: 'src' | 'srcset') {
    const value = attributes[key]
    if (!value) return
    if (matched.filter && !matched.filter({ key, value, attributes })) return
    const location = node.sourceCodeLocation!.attrs![key]
    actions.push({ type, key, value, attributes, location })
  }
  matched.srcAttributes?.forEach((key) => handleAttributeKey(key, 'src'))
  matched.srcsetAttributes?.forEach((key) => handleAttributeKey(key, 'srcset'))
  return actions
}

function getAttrKey(attr: Token.Attribute): string {
  return attr.prefix === undefined ? attr.name : `${attr.prefix}:${attr.name}`
}



================================================
FILE: packages/vite/src/node/baseEnvironment.ts
================================================
import colors from 'picocolors'
import type { Logger } from './logger'
import type { ResolvedConfig, ResolvedEnvironmentOptions } from './config'
import type { Plugin } from './plugin'

const environmentColors = [
  colors.blue,
  colors.magenta,
  colors.green,
  colors.gray,
]

export class PartialEnvironment {
  name: string
  getTopLevelConfig(): ResolvedConfig {
    return this._topLevelConfig
  }

  config: ResolvedConfig & ResolvedEnvironmentOptions

  logger: Logger

  /**
   * @internal
   */
  _options: ResolvedEnvironmentOptions
  /**
   * @internal
   */
  _topLevelConfig: ResolvedConfig

  constructor(
    name: string,
    topLevelConfig: ResolvedConfig,
    options: ResolvedEnvironmentOptions = topLevelConfig.environments[name],
  ) {
    // only allow some characters so that we can use name without escaping for directory names
    // and make users easier to access with `environments.*`
    if (!/^[\w$]+$/.test(name)) {
      throw new Error(
        `Invalid environment name "${name}". Environment names must only contain alphanumeric characters and "$", "_".`,
      )
    }
    this.name = name
    this._topLevelConfig = topLevelConfig
    this._options = options
    this.config = new Proxy(
      options as ResolvedConfig & ResolvedEnvironmentOptions,
      {
        get: (target, prop: keyof ResolvedConfig) => {
          if (prop === 'logger') {
            return this.logger
          }
          if (prop in target) {
            return this._options[prop as keyof ResolvedEnvironmentOptions]
          }
          return this._topLevelConfig[prop]
        },
      },
    )
    const environment = colors.dim(`(${this.name})`)
    const colorIndex =
      [...this.name].reduce((acc, c) => acc + c.charCodeAt(0), 0) %
      environmentColors.length
    const infoColor = environmentColors[colorIndex || 0]
    this.logger = {
      get hasWarned() {
        return topLevelConfig.logger.hasWarned
      },
      info(msg, opts) {
        return topLevelConfig.logger.info(msg, {
          ...opts,
          environment: infoColor(environment),
        })
      },
      warn(msg, opts) {
        return topLevelConfig.logger.warn(msg, {
          ...opts,
          environment: colors.yellow(environment),
        })
      },
      warnOnce(msg, opts) {
        return topLevelConfig.logger.warnOnce(msg, {
          ...opts,
          environment: colors.yellow(environment),
        })
      },
      error(msg, opts) {
        return topLevelConfig.logger.error(msg, {
          ...opts,
          environment: colors.red(environment),
        })
      },
      clearScreen(type) {
        return topLevelConfig.logger.clearScreen(type)
      },
      hasErrorLogged(error) {
        return topLevelConfig.logger.hasErrorLogged(error)
      },
    }
  }
}

export class BaseEnvironment extends PartialEnvironment {
  get plugins(): readonly Plugin[] {
    return this.config.plugins
  }

  /**
   * @internal
   */
  _initiated: boolean = false

  constructor(
    name: string,
    config: ResolvedConfig,
    options: ResolvedEnvironmentOptions = config.environments[name],
  ) {
    super(name, config, options)
  }
}

/**
 * This class discourages users from inversely checking the `mode`
 * to determine the type of environment, e.g.
 *
 * ```js
 * const isDev = environment.mode !== 'build' // bad
 * const isDev = environment.mode === 'dev'   // good
 * ```
 *
 * You should also not check against `"unknown"` specifically. It's
 * a placeholder for more possible environment types.
 */
export class UnknownEnvironment extends BaseEnvironment {
  mode = 'unknown' as const
}



================================================
FILE: packages/vite/src/node/build.ts
================================================
import path from 'node:path'
import colors from 'picocolors'
import type {
  ExternalOption,
  InputOption,
  InternalModuleFormat,
  LogLevel,
  LogOrStringHandler,
  MinimalPluginContext,
  ModuleFormat,
  OutputOptions,
  PluginContext,
  RollupBuild,
  RollupError,
  RollupLog,
  RollupOptions,
  RollupOutput,
  RollupWatcher,
  WarningHandlerWithDefault,
  WatcherOptions,
} from 'rollup'
import commonjsPlugin from '@rollup/plugin-commonjs'
import type { RollupCommonJSOptions } from 'dep-types/commonjs'
import type { RollupDynamicImportVarsOptions } from 'dep-types/dynamicImportVars'
import type { TransformOptions } from 'esbuild'
import {
  DEFAULT_ASSETS_INLINE_LIMIT,
  ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET,
  ROLLUP_HOOKS,
  VERSION,
} from './constants'
import type {
  EnvironmentOptions,
  InlineConfig,
  ResolvedConfig,
  ResolvedEnvironmentOptions,
} from './config'
import { resolveConfig } from './config'
import type { PartialEnvironment } from './baseEnvironment'
import { buildReporterPlugin } from './plugins/reporter'
import { buildEsbuildPlugin } from './plugins/esbuild'
import { type TerserOptions, terserPlugin } from './plugins/terser'
import {
  arraify,
  asyncFlatten,
  createDebugger,
  displayTime,
  getPkgName,
  joinUrlSegments,
  mergeConfig,
  mergeWithDefaults,
  partialEncodeURIPath,
} from './utils'
import { perEnvironmentPlugin } from './plugin'
import { manifestPlugin } from './plugins/manifest'
import type { Logger } from './logger'
import { dataURIPlugin } from './plugins/dataUri'
import { buildImportAnalysisPlugin } from './plugins/importAnalysisBuild'
import { ssrManifestPlugin } from './ssr/ssrManifestPlugin'
import { buildLoadFallbackPlugin } from './plugins/loadFallback'
import { findNearestMainPackageData, findNearestPackageData } from './packages'
import type { PackageCache } from './packages'
import {
  getResolvedOutDirs,
  resolveChokidarOptions,
  resolveEmptyOutDir,
} from './watch'
import { completeSystemWrapPlugin } from './plugins/completeSystemWrap'
import { webWorkerPostPlugin } from './plugins/worker'
import { getHookHandler } from './plugins'
import { BaseEnvironment } from './baseEnvironment'
import type { MinimalPluginContextWithoutEnvironment, Plugin } from './plugin'
import type { RollupPluginHooks } from './typeUtils'
import {
  BasicMinimalPluginContext,
  basePluginContextMeta,
} from './server/pluginContainer'
import {
  isFutureDeprecationEnabled,
  warnFutureDeprecation,
} from './deprecations'
import { prepareOutDirPlugin } from './plugins/prepareOutDir'
import type { Environment } from './environment'

export interface BuildEnvironmentOptions {
  /**
   * Compatibility transform target. The transform is performed with esbuild
   * and the lowest supported target is es2015. Note this only handles
   * syntax transformation and does not cover polyfills
   *
   * Default: 'baseline-widely-available' - transpile targeting browsers that
   * are included in the Baseline Widely Available on 2025-05-01.
   * (Chrome 107+, Edge 107+, Firefox 104+, Safari 16+).
   *
   * Another special value is 'esnext' - which only performs minimal transpiling
   * (for minification compat).
   *
   * For custom targets, see https://esbuild.github.io/api/#target and
   * https://esbuild.github.io/content-types/#javascript for more details.
   * @default 'baseline-widely-available'
   */
  target?: 'baseline-widely-available' | TransformOptions['target'] | false
  /**
   * whether to inject module preload polyfill.
   * Note: does not apply to library mode.
   * @default true
   * @deprecated use `modulePreload.polyfill` instead
   */
  polyfillModulePreload?: boolean
  /**
   * Configure module preload
   * Note: does not apply to library mode.
   * @default true
   */
  modulePreload?: boolean | ModulePreloadOptions
  /**
   * Directory relative from `root` where build output will be placed. If the
   * directory exists, it will be removed before the build.
   * @default 'dist'
   */
  outDir?: string
  /**
   * Directory relative from `outDir` where the built js/css/image assets will
   * be placed.
   * @default 'assets'
   */
  assetsDir?: string
  /**
   * Static asset files smaller than this number (in bytes) will be inlined as
   * base64 strings. If a callback is passed, a boolean can be returned to opt-in
   * or opt-out of inlining. If nothing is returned the default logic applies.
   *
   * Default limit is `4096` (4 KiB). Set to `0` to disable.
   * @default 4096
   */
  assetsInlineLimit?:
    | number
    | ((filePath: string, content: Buffer) => boolean | undefined)
  /**
   * Whether to code-split CSS. When enabled, CSS in async chunks will be
   * inlined as strings in the chunk and inserted via dynamically created
   * style tags when the chunk is loaded.
   * @default true
   */
  cssCodeSplit?: boolean
  /**
   * An optional separate target for CSS minification.
   * As esbuild only supports configuring targets to mainstream
   * browsers, users may need this option when they are targeting
   * a niche browser that comes with most modern JavaScript features
   * but has poor CSS support, e.g. Android WeChat WebView, which
   * doesn't support the #RGBA syntax.
   * @default target
   */
  cssTarget?: TransformOptions['target'] | false
  /**
   * Override CSS minification specifically instead of defaulting to `build.minify`,
   * so you can configure minification for JS and CSS separately.
   * @default 'esbuild'
   */
  cssMinify?: boolean | 'esbuild' | 'lightningcss'
  /**
   * If `true`, a separate sourcemap file will be created. If 'inline', the
   * sourcemap will be appended to the resulting output file as data URI.
   * 'hidden' works like `true` except that the corresponding sourcemap
   * comments in the bundled files are suppressed.
   * @default false
   */
  sourcemap?: boolean | 'inline' | 'hidden'
  /**
   * Set to `false` to disable minification, or specify the minifier to use.
   * Available options are 'terser' or 'esbuild'.
   * @default 'esbuild'
   */
  minify?: boolean | 'terser' | 'esbuild'
  /**
   * Options for terser
   * https://terser.org/docs/api-reference#minify-options
   *
   * In addition, you can also pass a `maxWorkers: number` option to specify the
   * max number of workers to spawn. Defaults to the number of CPUs minus 1.
   */
  terserOptions?: TerserOptions
  /**
   * Will be merged with internal rollup options.
   * https://rollupjs.org/configuration-options/
   */
  rollupOptions?: RollupOptions
  /**
   * Options to pass on to `@rollup/plugin-commonjs`
   */
  commonjsOptions?: RollupCommonJSOptions
  /**
   * Options to pass on to `@rollup/plugin-dynamic-import-vars`
   */
  dynamicImportVarsOptions?: RollupDynamicImportVarsOptions
  /**
   * Whether to write bundle to disk
   * @default true
   */
  write?: boolean
  /**
   * Empty outDir on write.
   * @default true when outDir is a sub directory of project root
   */
  emptyOutDir?: boolean | null
  /**
   * Copy the public directory to outDir on write.
   * @default true
   */
  copyPublicDir?: boolean
  /**
   * Whether to emit a .vite/manifest.json in the output dir to map hash-less filenames
   * to their hashed versions. Useful when you want to generate your own HTML
   * instead of using the one generated by Vite.
   *
   * Example:
   *
   * ```json
   * {
   *   "main.js": {
   *     "file": "main.68fe3fad.js",
   *     "css": "main.e6b63442.css",
   *     "imports": [...],
   *     "dynamicImports": [...]
   *   }
   * }
   * ```
   * @default false
   */
  manifest?: boolean | string
  /**
   * Build in library mode. The value should be the global name of the lib in
   * UMD mode. This will produce esm + cjs + umd bundle formats with default
   * configurations that are suitable for distributing libraries.
   * @default false
   */
  lib?: LibraryOptions | false
  /**
   * Produce SSR oriented build. Note this requires specifying SSR entry via
   * `rollupOptions.input`.
   * @default false
   */
  ssr?: boolean | string
  /**
   * Generate SSR manifest for determining style links and asset preload
   * directives in production.
   * @default false
   */
  ssrManifest?: boolean | string
  /**
   * Emit assets during SSR.
   * @default false
   */
  ssrEmitAssets?: boolean
  /**
   * Emit assets during build. Frameworks can set environments.ssr.build.emitAssets
   * By default, it is true for the client and false for other environments.
   */
  emitAssets?: boolean
  /**
   * Set to false to disable reporting compressed chunk sizes.
   * Can slightly improve build speed.
   * @default true
   */
  reportCompressedSize?: boolean
  /**
   * Adjust chunk size warning limit (in kB).
   * @default 500
   */
  chunkSizeWarningLimit?: number
  /**
   * Rollup watch options
   * https://rollupjs.org/configuration-options/#watch
   * @default null
   */
  watch?: WatcherOptions | null
  /**
   * create the Build Environment instance
   */
  createEnvironment?: (
    name: string,
    config: ResolvedConfig,
  ) => Promise<BuildEnvironment> | BuildEnvironment
}

export type BuildOptions = BuildEnvironmentOptions

export interface LibraryOptions {
  /**
   * Path of library entry
   */
  entry: InputOption
  /**
   * The name of the exposed global variable. Required when the `formats` option includes
   * `umd` or `iife`
   */
  name?: string
  /**
   * Output bundle formats
   * @default ['es', 'umd']
   */
  formats?: LibraryFormats[]
  /**
   * The name of the package file output. The default file name is the name option
   * of the project package.json. It can also be defined as a function taking the
   * format as an argument.
   */
  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
  /**
   * The name of the CSS file output if the library imports CSS. Defaults to the
   * same value as `build.lib.fileName` if it's set a string, otherwise it falls
   * back to the name option of the project package.json.
   */
  cssFileName?: string
}

export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system'

export interface ModulePreloadOptions {
  /**
   * Whether to inject a module preload polyfill.
   * Note: does not apply to library mode.
   * @default true
   */
  polyfill?: boolean
  /**
   * Resolve the list of dependencies to preload for a given dynamic import
   * @experimental
   */
  resolveDependencies?: ResolveModulePreloadDependenciesFn
}
export interface ResolvedModulePreloadOptions {
  polyfill: boolean
  resolveDependencies?: ResolveModulePreloadDependenciesFn
}

export type ResolveModulePreloadDependenciesFn = (
  filename: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]

export interface ResolvedBuildEnvironmentOptions
  extends Required<Omit<BuildEnvironmentOptions, 'polyfillModulePreload'>> {
  modulePreload: false | ResolvedModulePreloadOptions
}

export interface ResolvedBuildOptions
  extends Required<Omit<BuildOptions, 'polyfillModulePreload'>> {
  modulePreload: false | ResolvedModulePreloadOptions
}

export const buildEnvironmentOptionsDefaults = Object.freeze({
  target: 'baseline-widely-available',
  /** @deprecated */
  polyfillModulePreload: true,
  modulePreload: true,
  outDir: 'dist',
  assetsDir: 'assets',
  assetsInlineLimit: DEFAULT_ASSETS_INLINE_LIMIT,
  // cssCodeSplit
  // cssTarget
  // cssMinify
  sourcemap: false,
  // minify
  terserOptions: {},
  rollupOptions: {},
  commonjsOptions: {
    include: [/node_modules/],
    extensions: ['.js', '.cjs'],
  },
  dynamicImportVarsOptions: {
    warnOnError: true,
    exclude: [/node_modules/],
  },
  write: true,
  emptyOutDir: null,
  copyPublicDir: true,
  manifest: false,
  lib: false,
  // ssr
  ssrManifest: false,
  ssrEmitAssets: false,
  // emitAssets
  reportCompressedSize: true,
  chunkSizeWarningLimit: 500,
  watch: null,
  // createEnvironment
})

export function resolveBuildEnvironmentOptions(
  raw: BuildEnvironmentOptions,
  logger: Logger,
  consumer: 'client' | 'server' | undefined,
): ResolvedBuildEnvironmentOptions {
  const deprecatedPolyfillModulePreload = raw.polyfillModulePreload
  const { polyfillModulePreload, ...rest } = raw
  raw = rest
  if (deprecatedPolyfillModulePreload !== undefined) {
    logger.warn(
      'polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.',
    )
  }
  if (
    deprecatedPolyfillModulePreload === false &&
    raw.modulePreload === undefined
  ) {
    raw.modulePreload = { polyfill: false }
  }

  const merged = mergeWithDefaults(
    {
      ...buildEnvironmentOptionsDefaults,
      cssCodeSplit: !raw.lib,
      minify: consumer === 'server' ? false : 'esbuild',
      ssr: consumer === 'server',
      emitAssets: consumer === 'client',
      createEnvironment: (name, config) => new BuildEnvironment(name, config),
    } satisfies BuildEnvironmentOptions,
    raw,
  )

  // handle special build targets
  if (merged.target === 'baseline-widely-available') {
    merged.target = ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET
  }

  // normalize false string into actual false
  if ((merged.minify as string) === 'false') {
    merged.minify = false
  } else if (merged.minify === true) {
    merged.minify = 'esbuild'
  }

  const defaultModulePreload = {
    polyfill: true,
  }

  const resolved: ResolvedBuildEnvironmentOptions = {
    ...merged,
    cssTarget: merged.cssTarget ?? merged.target,
    cssMinify:
      merged.cssMinify ?? (consumer === 'server' ? 'esbuild' : !!merged.minify),
    // Resolve to false | object
    modulePreload:
      merged.modulePreload === false
        ? false
        : merged.modulePreload === true
          ? defaultModulePreload
          : {
              ...defaultModulePreload,
              ...merged.modulePreload,
            },
  }

  return resolved
}

export async function resolveBuildPlugins(config: ResolvedConfig): Promise<{
  pre: Plugin[]
  post: Plugin[]
}> {
  return {
    pre: [
      completeSystemWrapPlugin(),
      ...(!config.isWorker ? [prepareOutDirPlugin()] : []),
      perEnvironmentPlugin('commonjs', (environment) => {
        const { commonjsOptions } = environment.config.build
        const usePluginCommonjs =
          !Array.isArray(commonjsOptions.include) ||
          commonjsOptions.include.length !== 0
        return usePluginCommonjs ? commonjsPlugin(commonjsOptions) : false
      }),
      dataURIPlugin(),
      perEnvironmentPlugin(
        'vite:rollup-options-plugins',
        async (environment) =>
          (
            await asyncFlatten(
              arraify(environment.config.build.rollupOptions.plugins),
            )
          ).filter(Boolean) as Plugin[],
      ),
      ...(config.isWorker ? [webWorkerPostPlugin()] : []),
    ],
    post: [
      buildImportAnalysisPlugin(config),
      buildEsbuildPlugin(),
      terserPlugin(config),
      ...(!config.isWorker
        ? [manifestPlugin(), ssrManifestPlugin(), buildReporterPlugin(config)]
        : []),
      buildLoadFallbackPlugin(),
    ],
  }
}

/**
 * Bundles a single environment for production.
 * Returns a Promise containing the build result.
 */
export async function build(
  inlineConfig: InlineConfig = {},
): Promise<RollupOutput | RollupOutput[] | RollupWatcher> {
  const builder = await createBuilder(inlineConfig, true)
  const environment = Object.values(builder.environments)[0]
  if (!environment) throw new Error('No environment found')
  return builder.build(environment)
}

function resolveConfigToBuild(
  inlineConfig: InlineConfig = {},
  patchConfig?: (config: ResolvedConfig) => void,
  patchPlugins?: (resolvedPlugins: Plugin[]) => void,
): Promise<ResolvedConfig> {
  return resolveConfig(
    inlineConfig,
    'build',
    'production',
    'production',
    false,
    patchConfig,
    patchPlugins,
  )
}

function resolveRollupOptions(environment: Environment) {
  const { root, packageCache, build: options } = environment.config
  const libOptions = options.lib
  const { logger } = environment
  const ssr = environment.config.consumer === 'server'

  const resolve = (p: string) => path.resolve(root, p)
  const input = libOptions
    ? options.rollupOptions.input ||
      (typeof libOptions.entry === 'string'
        ? resolve(libOptions.entry)
        : Array.isArray(libOptions.entry)
          ? libOptions.entry.map(resolve)
          : Object.fromEntries(
              Object.entries(libOptions.entry).map(([alias, file]) => [
                alias,
                resolve(file),
              ]),
            ))
    : typeof options.ssr === 'string'
      ? resolve(options.ssr)
      : options.rollupOptions.input || resolve('index.html')

  if (ssr && typeof input === 'string' && input.endsWith('.html')) {
    throw new Error(
      `rollupOptions.input should not be an html file when building for SSR. ` +
        `Please specify a dedicated SSR entry.`,
    )
  }
  if (options.cssCodeSplit === false) {
    const inputs =
      typeof input === 'string'
        ? [input]
        : Array.isArray(input)
          ? input
          : Object.values(input)
    if (inputs.some((input) => input.endsWith('.css'))) {
      throw new Error(
        `When "build.cssCodeSplit: false" is set, "rollupOptions.input" should not include CSS files.`,
      )
    }
  }

  const outDir = resolve(options.outDir)

  // inject environment and ssr arg to plugin load/transform hooks
  const plugins = environment.plugins.map((p) =>
    injectEnvironmentToHooks(environment, p),
  )

  const rollupOptions: RollupOptions = {
    preserveEntrySignatures: ssr
      ? 'allow-extension'
      : libOptions
        ? 'strict'
        : false,
    cache: options.watch ? undefined : false,
    ...options.rollupOptions,
    output: options.rollupOptions.output,
    input,
    plugins,
    external: options.rollupOptions.external,
    onLog(level, log) {
      onRollupLog(level, log, environment)
    },
  }

  const isSsrTargetWebworkerEnvironment =
    environment.name === 'ssr' &&
    environment.getTopLevelConfig().ssr?.target === 'webworker'

  const buildOutputOptions = (output: OutputOptions = {}): OutputOptions => {
    // @ts-expect-error See https://github.com/vitejs/vite/issues/5812#issuecomment-984345618
    if (output.output) {
      logger.warn(
        `You've set "rollupOptions.output.output" in your config. ` +
          `This is deprecated and will override all Vite.js default output options. ` +
          `Please use "rollupOptions.output" instead.`,
      )
    }
    if (output.file) {
      throw new Error(
        `Vite does not support "rollupOptions.output.file". ` +
          `Please use "rollupOptions.output.dir" and "rollupOptions.output.entryFileNames" instead.`,
      )
    }
    if (output.sourcemap) {
      logger.warnOnce(
        colors.yellow(
          `Vite does not support "rollupOptions.output.sourcemap". ` +
            `Please use "build.sourcemap" instead.`,
        ),
      )
    }

    const format = output.format || 'es'
    const jsExt =
      (ssr && !isSsrTargetWebworkerEnvironment) || libOptions
        ? resolveOutputJsExtension(
            format,
            findNearestPackageData(root, packageCache)?.data.type,
          )
        : 'js'
    return {
      dir: outDir,
      // Default format is 'es' for regular and for SSR builds
      format,
      exports: 'auto',
      sourcemap: options.sourcemap,
      name: libOptions ? libOptions.name : undefined,
      hoistTransitiveImports: libOptions ? false : undefined,
      // es2015 enables `generatedCode.symbols`
      // - #764 add `Symbol.toStringTag` when build es module into cjs chunk
      // - #1048 add `Symbol.toStringTag` for module default export
      generatedCode: 'es2015',
      entryFileNames: ssr
        ? `[name].${jsExt}`
        : libOptions
          ? ({ name }) =>
              resolveLibFilename(
                libOptions,
                format,
                name,
                root,
                jsExt,
                packageCache,
              )
          : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
      chunkFileNames: libOptions
        ? `[name]-[hash].${jsExt}`
        : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
      assetFileNames: libOptions
        ? `[name].[ext]`
        : path.posix.join(options.assetsDir, `[name]-[hash].[ext]`),
      inlineDynamicImports:
        output.format === 'umd' ||
        output.format === 'iife' ||
        (isSsrTargetWebworkerEnvironment &&
          (typeof input === 'string' || Object.keys(input).length === 1)),
      ...output,
    }
  }

  // resolve lib mode outputs
  const outputs = resolveBuildOutputs(
    options.rollupOptions.output,
    libOptions,
    logger,
  )

  if (Array.isArray(outputs)) {
    rollupOptions.output = outputs.map(buildOutputOptions)
  } else {
    rollupOptions.output = buildOutputOptions(outputs)
  }

  return rollupOptions
}

/**
 * Build an App environment, or a App library (if libraryOptions is provided)
 **/
async function buildEnvironment(
  environment: BuildEnvironment,
): Promise<RollupOutput | RollupOutput[] | RollupWatcher> {
  const { logger, config } = environment
  const { root, build: options } = config
  const ssr = config.consumer === 'server'

  logger.info(
    colors.cyan(
      `vite v${VERSION} ${colors.green(
        `building ${ssr ? `SSR bundle ` : ``}for ${environment.config.mode}...`,
      )}`,
    ),
  )

  let bundle: RollupBuild | undefined
  let startTime: number | undefined
  try {
    const rollupOptions = resolveRollupOptions(environment)

    // watch file changes with rollup
    if (options.watch) {
      logger.info(colors.cyan(`\nwatching for file changes...`))

      const resolvedOutDirs = getResolvedOutDirs(
        root,
        options.outDir,
        options.rollupOptions.output,
      )
      const emptyOutDir = resolveEmptyOutDir(
        options.emptyOutDir,
        root,
        resolvedOutDirs,
        logger,
      )
      const resolvedChokidarOptions = resolveChokidarOptions(
        options.watch.chokidar,
        resolvedOutDirs,
        emptyOutDir,
        environment.config.cacheDir,
      )

      const { watch } = await import('rollup')
      const watcher = watch({
        ...rollupOptions,
        watch: {
          ...options.watch,
          chokidar: resolvedChokidarOptions,
        },
      })

      watcher.on('event', (event) => {
        if (event.code === 'BUNDLE_START') {
          logger.info(colors.cyan(`\nbuild started...`))
        } else if (event.code === 'BUNDLE_END') {
          event.result.close()
          logger.info(colors.cyan(`built in ${event.duration}ms.`))
        } else if (event.code === 'ERROR') {
          const e = event.error
          enhanceRollupError(e)
          clearLine()
          logger.error(e.message, { error: e })
        }
      })

      return watcher
    }

    // write or generate files with rollup
    const { rollup } = await import('rollup')
    startTime = Date.now()
    bundle = await rollup(rollupOptions)

    const res: RollupOutput[] = []
    for (const output of arraify(rollupOptions.output!)) {
      res.push(await bundle[options.write ? 'write' : 'generate'](output))
    }
    logger.info(
      `${colors.green(`✓ built in ${displayTime(Date.now() - startTime)}`)}`,
    )
    return Array.isArray(rollupOptions.output) ? res : res[0]
  } catch (e) {
    enhanceRollupError(e)
    clearLine()
    if (startTime) {
      logger.error(
        `${colors.red('✗')} Build failed in ${displayTime(Date.now() - startTime)}`,
      )
      startTime = undefined
    }
    throw e
  } finally {
    if (bundle) await bundle.close()
  }
}

function enhanceRollupError(e: RollupError) {
  const stackOnly = extractStack(e)

  let msg = colors.red((e.plugin ? `[${e.plugin}] ` : '') + e.message)
  if (e.loc && e.loc.file && e.loc.file !== e.id) {
    msg += `\nfile: ${colors.cyan(
      `${e.loc.file}:${e.loc.line}:${e.loc.column}` +
        (e.id ? ` (${e.id})` : ''),
    )}`
  } else if (e.id) {
    msg += `\nfile: ${colors.cyan(
      e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : ''),
    )}`
  }
  if (e.frame) {
    msg += `\n` + colors.yellow(normalizeCodeFrame(e.frame))
  }

  e.message = msg

  // We are rebuilding the stack trace to include the more detailed message at the top.
  // Previously this code was relying on mutating e.message changing the generated stack
  // when it was accessed, but we don't have any guarantees that the error we are working
  // with hasn't already had its stack accessed before we get here.
  if (stackOnly !== undefined) {
    e.stack = `${e.message}\n${stackOnly}`
  }
}

/**
 * The stack string usually contains a copy of the message at the start of the stack.
 * If the stack starts with the message, we remove it and just return the stack trace
 * portion. Otherwise the original stack trace is used.
 */
function extractStack(e: RollupError) {
  const { stack, name = 'Error', message } = e

  // If we don't have a stack, not much we can do.
  if (!stack) {
    return stack
  }

  const expectedPrefix = `${name}: ${message}\n`
  if (stack.startsWith(expectedPrefix)) {
    return stack.slice(expectedPrefix.length)
  }

  return stack
}

/**
 * Esbuild code frames have newlines at the start and end of the frame, rollup doesn't
 * This function normalizes the frame to match the esbuild format which has more pleasing padding
 */
function normalizeCodeFrame(frame: string) {
  const trimmedPadding = frame.replace(/^\n|\n$/g, '')
  return `\n${trimmedPadding}\n`
}

type JsExt = 'js' | 'cjs' | 'mjs'

function resolveOutputJsExtension(
  format: ModuleFormat,
  type: string = 'commonjs',
): JsExt {
  if (type === 'module') {
    return format === 'cjs' || format === 'umd' ? 'cjs' : 'js'
  } else {
    return format === 'es' ? 'mjs' : 'js'
  }
}

export function resolveLibFilename(
  libOptions: LibraryOptions,
  format: ModuleFormat,
  entryName: string,
  root: string,
  extension?: JsExt,
  packageCache?: PackageCache,
): string {
  if (typeof libOptions.fileName === 'function') {
    return libOptions.fileName(format, entryName)
  }

  const packageJson = findNearestMainPackageData(root, packageCache)?.data
  const name =
    libOptions.fileName ||
    (packageJson && typeof libOptions.entry === 'string'
      ? getPkgName(packageJson.name)
      : entryName)

  if (!name)
    throw new Error(
      'Name in package.json is required if option "build.lib.fileName" is not provided.',
    )

  extension ??= resolveOutputJsExtension(format, packageJson?.type)

  if (format === 'cjs' || format === 'es') {
    return `${name}.${extension}`
  }

  return `${name}.${format}.${extension}`
}

export function resolveBuildOutputs(
  outputs: OutputOptions | OutputOptions[] | undefined,
  libOptions: LibraryOptions | false,
  logger: Logger,
): OutputOptions | OutputOptions[] | undefined {
  if (libOptions) {
    const libHasMultipleEntries =
      typeof libOptions.entry !== 'string' &&
      Object.values(libOptions.entry).length > 1
    const libFormats =
      libOptions.formats ||
      (libHasMultipleEntries ? ['es', 'cjs'] : ['es', 'umd'])

    if (!Array.isArray(outputs)) {
      if (libFormats.includes('umd') || libFormats.includes('iife')) {
        if (libHasMultipleEntries) {
          throw new Error(
            'Multiple entry points are not supported when output formats include "umd" or "iife".',
          )
        }

        if (!libOptions.name) {
          throw new Error(
            'Option "build.lib.name" is required when output formats include "umd" or "iife".',
          )
        }
      }

      return libFormats.map((format) => ({ ...outputs, format }))
    }

    // By this point, we know "outputs" is an Array.
    if (libOptions.formats) {
      logger.warn(
        colors.yellow(
          '"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.',
        ),
      )
    }

    outputs.forEach((output) => {
      if (
        (output.format === 'umd' || output.format === 'iife') &&
        !output.name
      ) {
        throw new Error(
          'Entries in "build.rollupOptions.output" must specify "name" when the format is "umd" or "iife".',
        )
      }
    })
  }

  return outputs
}

const warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`]
const dynamicImportWarningIgnoreList = [
  `Unsupported expression`,
  `statically analyzed`,
]

function clearLine() {
  const tty = process.stdout.isTTY && !process.env.CI
  if (tty) {
    process.stdout.clearLine(0)
    process.stdout.cursorTo(0)
  }
}

export function onRollupLog(
  level: LogLevel,
  log: RollupLog,
  environment: Environment,
): void {
  const debugLogger = createDebugger('vite:build')
  const viteLog: LogOrStringHandler = (logLeveling, rawLogging) => {
    const logging =
      typeof rawLogging === 'object' ? rawLogging : { message: rawLogging }

    if (logging.code === 'UNRESOLVED_IMPORT') {
      const id = logging.id
      const exporter = logging.exporter
      // throw unless it's commonjs external...
      if (!id || !id.endsWith('?commonjs-external')) {
        throw new Error(
          `[vite]: Rollup failed to resolve import "${exporter}" from "${id}".\n` +
            `This is most likely unintended because it can break your application at runtime.\n` +
            `If you do want to externalize this module explicitly add it to\n` +
            `\`build.rollupOptions.external\``,
        )
      }
    }

    if (logLeveling === 'warn') {
      if (
        logging.plugin === 'rollup-plugin-dynamic-import-variables' &&
        dynamicImportWarningIgnoreList.some((msg) =>
          logging.message.includes(msg),
        )
      ) {
        return
      }

      if (warningIgnoreList.includes(logging.code!)) {
        return
      }
    }

    switch (logLeveling) {
      case 'info':
        environment.logger.info(logging.message)
        return
      case 'warn':
        environment.logger.warn(colors.yellow(logging.message))
        return
      case 'error':
        environment.logger.error(colors.red(logging.message))
        return
      case 'debug':
        debugLogger?.(logging.message)
        return
      default:
        logLeveling satisfies never
        // fallback to info if a unknown log level is passed
        environment.logger.info(logging.message)
        return
    }
  }

  clearLine()
  const userOnLog = environment.config.build.rollupOptions?.onLog
  const userOnWarn = environment.config.build.rollupOptions?.onwarn
  if (userOnLog) {
    if (userOnWarn) {
      const normalizedUserOnWarn = normalizeUserOnWarn(userOnWarn, viteLog)
      userOnLog(level, log, normalizedUserOnWarn)
    } else {
      userOnLog(level, log, viteLog)
    }
  } else if (userOnWarn) {
    const normalizedUserOnWarn = normalizeUserOnWarn(userOnWarn, viteLog)
    normalizedUserOnWarn(level, log)
  } else {
    viteLog(level, log)
  }
}

function normalizeUserOnWarn(
  userOnWarn: WarningHandlerWithDefault,
  defaultHandler: LogOrStringHandler,
): LogOrStringHandler {
  return (logLevel, logging) => {
    if (logLevel === 'warn') {
      userOnWarn(normalizeLog(logging), (log) =>
        defaultHandler('warn', typeof log === 'function' ? log() : log),
      )
    } else {
      defaultHandler(logLevel, logging)
    }
  }
}

const normalizeLog = (log: RollupLog | string): RollupLog =>
  typeof log === 'string' ? { message: log } : log

export function resolveUserExternal(
  user: ExternalOption,
  id: string,
  parentId: string | undefined,
  isResolved: boolean,
): boolean | null | void {
  if (typeof user === 'function') {
    return user(id, parentId, isResolved)
  } else if (Array.isArray(user)) {
    return user.some((test) => isExternal(id, test))
  } else {
    return isExternal(id, user)
  }
}

function isExternal(id: string, test: string | RegExp) {
  if (typeof test === 'string') {
    return id === test
  } else {
    return test.test(id)
  }
}

export function injectEnvironmentToHooks(
  environment: Environment,
  plugin: Plugin,
): Plugin {
  const { resolveId, load, transform } = plugin

  const clone = { ...plugin }

  for (const hook of Object.keys(clone) as RollupPluginHooks[]) {
    switch (hook) {
      case 'resolveId':
        clone[hook] = wrapEnvironmentResolveId(
          environment,
          resolveId,
          plugin.name,
        )
        break
      case 'load':
        clone[hook] = wrapEnvironmentLoad(environment, load, plugin.name)
        break
      case 'transform':
        clone[hook] = wrapEnvironmentTransform(
          environment,
          transform,
          plugin.name,
        )
        break
      default:
        if (ROLLUP_HOOKS.includes(hook)) {
          ;(clone as any)[hook] = wrapEnvironmentHook(environment, clone[hook])
        }
        break
    }
  }

  return clone
}

function wrapEnvironmentResolveId(
  environment: Environment,
  hook: Plugin['resolveId'] | undefined,
  pluginName: string,
): Plugin['resolveId'] {
  if (!hook) return

  const fn = getHookHandler(hook)
  const handler: Plugin['resolveId'] = function (id, importer, options) {
    return fn.call(
      injectEnvironmentInContext(this, environment),
      id,
      importer,
      injectSsrFlag(options, environment, pluginName),
    )
  }

  if ('handler' in hook) {
    return {
      ...hook,
      handler,
    } as Plugin['resolveId']
  } else {
    return handler
  }
}

function wrapEnvironmentLoad(
  environment: Environment,
  hook: Plugin['load'] | undefined,
  pluginName: string,
): Plugin['load'] {
  if (!hook) return

  const fn = getHookHandler(hook)
  const handler: Plugin['load'] = function (id, ...args) {
    return fn.call(
      injectEnvironmentInContext(this, environment),
      id,
      injectSsrFlag(args[0], environment, pluginName),
    )
  }

  if ('handler' in hook) {
    return {
      ...hook,
      handler,
    } as Plugin['load']
  } else {
    return handler
  }
}

function wrapEnvironmentTransform(
  environment: Environment,
  hook: Plugin['transform'] | undefined,
  pluginName: string,
): Plugin['transform'] {
  if (!hook) return

  const fn = getHookHandler(hook)
  const handler: Plugin['transform'] = function (code, importer, ...args) {
    return fn.call(
      injectEnvironmentInContext(this, environment),
      code,
      importer,
      injectSsrFlag(args[0], environment, pluginName),
    )
  }

  if ('handler' in hook) {
    return {
      ...hook,
      handler,
    } as Plugin['transform']
  } else {
    return handler
  }
}

function wrapEnvironmentHook<HookName extends keyof Plugin>(
  environment: Environment,
  hook?: Plugin[HookName],
): Plugin[HookName] {
  if (!hook) return

  const fn = getHookHandler(hook)
  if (typeof fn !== 'function') return hook

  const handler: Plugin[HookName] = function (
    this: PluginContext,
    ...args: any[]
  ) {
    return fn.call(injectEnvironmentInContext(this, environment), ...args)
  }

  if ('handler' in hook) {
    return {
      ...hook,
      handler,
    } as Plugin[HookName]
  } else {
    return handler
  }
}

function injectEnvironmentInContext<Context extends MinimalPluginContext>(
  context: Context,
  environment: Environment,
) {
  context.meta.viteVersion ??= VERSION
  context.environment ??= environment
  return context
}

function injectSsrFlag<T extends Record<string, any>>(
  options: T | undefined,
  environment: Environment,
  pluginName: string,
): T & { ssr?: boolean } {
  let ssr = environment.config.consumer === 'server'
  const newOptions = { ...(options ?? {}), ssr } as T & {
    ssr?: boolean
  }

  if (
    isFutureDeprecationEnabled(
      environment?.getTopLevelConfig(),
      'removePluginHookSsrArgument',
    )
  ) {
    Object.defineProperty(newOptions, 'ssr', {
      get() {
        warnFutureDeprecation(
          environment?.getTopLevelConfig(),
          'removePluginHookSsrArgument',
          `Used in plugin "${pluginName}".`,
        )
        return ssr
      },
      set(v) {
        ssr = v
      },
    })
  }

  return newOptions
}

/*
  The following functions are copied from rollup
  https://github.com/rollup/rollup/blob/ce6cb93098850a46fa242e37b74a919e99a5de28/src/ast/nodes/MetaProperty.ts#L155-L203

  https://github.com/rollup/rollup
  The MIT License (MIT)
  Copyright (c) 2017 [these people](https://github.com/rollup/rollup/graphs/contributors)
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/
const quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g
const backSlashRegEx = /\\/g

function escapeId(id: string): string {
  if (!needsEscapeRegEx.test(id)) return id
  return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1')
}

const getResolveUrl = (path: string, URL = 'URL') => `new ${URL}(${path}).href`

const getRelativeUrlFromDocument = (relativePath: string, umd = false) =>
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`,
  )

const getFileUrlFromFullPath = (path: string) =>
  `require('u' + 'rl').pathToFileURL(${path}).href`

const getFileUrlFromRelativePath = (path: string) =>
  getFileUrlFromFullPath(`__dirname + '/${escapeId(path)}'`)

const relativeUrlMechanisms: Record<
  InternalModuleFormat,
  (relativePath: string) => string
> = {
  amd: (relativePath) => {
    if (relativePath[0] !== '.') relativePath = './' + relativePath
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`,
    )
  },
  cjs: (relativePath) =>
    `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
      relativePath,
    )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =>
    getResolveUrl(
      `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`,
    ),
  iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =>
    getResolveUrl(
      `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`,
    ),
  umd: (relativePath) =>
    `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
      relativePath,
    )} : ${getRelativeUrlFromDocument(relativePath, true)})`,
}
/* end of copy */

const customRelativeUrlMechanisms = {
  ...relativeUrlMechanisms,
  'worker-iife': (relativePath) =>
    getResolveUrl(
      `'${escapeId(partialEncodeURIPath(relativePath))}', self.location.href`,
    ),
} as const satisfies Record<string, (relativePath: string) => string>

export type RenderBuiltAssetUrl = (
  filename: string,
  type: {
    type: 'asset' | 'public'
    hostId: string
    hostType: 'js' | 'css' | 'html'
    ssr: boolean
  },
) => string | { relative?: boolean; runtime?: string } | undefined

export function toOutputFilePathInJS(
  environment: PartialEnvironment,
  filename: string,
  type: 'asset' | 'public',
  hostId: string,
  hostType: 'js' | 'css' | 'html',
  toRelative: (
    filename: string,
    hostType: string,
  ) => string | { runtime: string },
): string | { runtime: string } {
  const { experimental, base, decodedBase } = environment.config
  const ssr = environment.config.consumer === 'server' // was !!environment.config.build.ssr
  const { renderBuiltUrl } = experimental
  let relative = base === '' || base === './'
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr,
    })
    if (typeof result === 'object') {
      if (result.runtime) {
        return { runtime: result.runtime }
      }
      if (typeof result.relative === 'boolean') {
        relative = result.relative
      }
    } else if (result) {
      return result
    }
  }
  if (relative && !ssr) {
    return toRelative(filename, hostId)
  }
  return joinUrlSegments(decodedBase, filename)
}

export function createToImportMetaURLBasedRelativeRuntime(
  format: InternalModuleFormat,
  isWorker: boolean,
): (filename: string, importer: string) => { runtime: string } {
  const formatLong = isWorker && format === 'iife' ? 'worker-iife' : format
  const toRelativePath = customRelativeUrlMechanisms[formatLong]
  return (filename, importer) => ({
    runtime: toRelativePath(
      path.posix.relative(path.dirname(importer), filename),
    ),
  })
}

export function toOutputFilePathWithoutRuntime(
  filename: string,
  type: 'asset' | 'public',
  hostId: string,
  hostType: 'js' | 'css' | 'html',
  config: ResolvedConfig,
  toRelative: (filename: string, hostId: string) => string,
): string {
  const { renderBuiltUrl } = config.experimental
  let relative = config.base === '' || config.base === './'
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config.build.ssr,
    })
    if (typeof result === 'object') {
      if (result.runtime) {
        throw new Error(
          `{ runtime: "${result.runtime}" } is not supported for assets in ${hostType} files: ${filename}`,
        )
      }
      if (typeof result.relative === 'boolean') {
        relative = result.relative
      }
    } else if (result) {
      return result
    }
  }
  if (relative && !config.build.ssr) {
    return toRelative(filename, hostId)
  } else {
    return joinUrlSegments(config.decodedBase, filename)
  }
}

export const toOutputFilePathInCss = toOutputFilePathWithoutRuntime
export const toOutputFilePathInHtml = toOutputFilePathWithoutRuntime

export class BuildEnvironment extends BaseEnvironment {
  mode = 'build' as const

  isBuilt = false
  constructor(
    name: string,
    config: ResolvedConfig,
    setup?: {
      options?: EnvironmentOptions
    },
  ) {
    let options = config.environments[name]
    if (!options) {
      throw new Error(`Environment "${name}" is not defined in the config.`)
    }
    if (setup?.options) {
      options = mergeConfig(
        options,
        setup.options,
      ) as ResolvedEnvironmentOptions
    }
    super(name, config, options)
  }

  async init(): Promise<void> {
    if (this._initiated) {
      return
    }
    this._initiated = true
  }
}

export interface ViteBuilder {
  environments: Record<string, BuildEnvironment>
  config: ResolvedConfig
  buildApp(): Promise<void>
  build(
    environment: BuildEnvironment,
  ): Promise<RollupOutput | RollupOutput[] | RollupWatcher>
}

export interface BuilderOptions {
  /**
   * Whether to share the config instance among environments to align with the behavior of dev server.
   *
   * @default false
   * @experimental
   */
  sharedConfigBuild?: boolean
  /**
   * Whether to share the plugin instances among environments to align with the behavior of dev server.
   *
   * @default false
   * @experimental
   */
  sharedPlugins?: boolean
  buildApp?: (builder: ViteBuilder) => Promise<void>
}

export const builderOptionsDefaults = Object.freeze({
  sharedConfigBuild: false,
  sharedPlugins: false,
  // buildApp
})

export function resolveBuilderOptions(
  options: BuilderOptions | undefined,
): ResolvedBuilderOptions | undefined {
  if (!options) return
  return mergeWithDefaults(
    { ...builderOptionsDefaults, buildApp: async () => {} },
    options,
  )
}

export type ResolvedBuilderOptions = Required<BuilderOptions>

/**
 * Creates a ViteBuilder to orchestrate building multiple environments.
 * @experimental
 */
export async function createBuilder(
  inlineConfig: InlineConfig = {},
  useLegacyBuilder: null | boolean = false,
): Promise<ViteBuilder> {
  const patchConfig = (resolved: ResolvedConfig) => {
    if (!(useLegacyBuilder ?? !resolved.builder)) return

    // Until the ecosystem updates to use `environment.config.build` instead of `config.build`,
    // we need to make override `config.build` for the current environment.
    // We can deprecate `config.build` in ResolvedConfig and push everyone to upgrade, and later
    // remove the default values that shouldn't be used at all once the config is resolved
    const environmentName = resolved.build.ssr ? 'ssr' : 'client'
    ;(resolved.build as ResolvedBuildOptions) = {
      ...resolved.environments[environmentName].build,
    }
  }
  const config = await resolveConfigToBuild(inlineConfig, patchConfig)
  useLegacyBuilder ??= !config.builder
  const configBuilder = config.builder ?? resolveBuilderOptions({})!

  const environments: Record<string, BuildEnvironment> = {}

  const builder: ViteBuilder = {
    environments,
    config,
    async buildApp() {
      const pluginContext = new BasicMinimalPluginContext(
        { ...basePluginContextMeta, watchMode: false },
        config.logger,
      )

      // order 'pre' and 'normal' hooks are run first, then config.builder.buildApp, then 'post' hooks
      let configBuilderBuildAppCalled = false
      for (const p of config.getSortedPlugins('buildApp')) {
        const hook = p.buildApp
        if (
          !configBuilderBuildAppCalled &&
          typeof hook === 'object' &&
          hook.order === 'post'
        ) {
          configBuilderBuildAppCalled = true
          await configBuilder.buildApp(builder)
        }
        const handler = getHookHandler(hook)
        await handler.call(pluginContext, builder)
      }
      if (!configBuilderBuildAppCalled) {
        await configBuilder.buildApp(builder)
      }
      // fallback to building all environments if no environments have been built
      if (
        Object.values(builder.environments).every(
          (environment) => !environment.isBuilt,
        )
      ) {
        for (const environment of Object.values(builder.environments)) {
          await builder.build(environment)
        }
      }
    },
    async build(
      environment: BuildEnvironment,
    ): Promise<RollupOutput | RollupOutput[] | RollupWatcher> {
      const output = await buildEnvironment(environment)
      environment.isBuilt = true
      return output
    },
  }

  async function setupEnvironment(name: string, config: ResolvedConfig) {
    const environment = await config.build.createEnvironment(name, config)
    await environment.init()
    environments[name] = environment
  }

  if (useLegacyBuilder) {
    await setupEnvironment(config.build.ssr ? 'ssr' : 'client', config)
  } else {
    for (const environmentName of Object.keys(config.environments)) {
      // We need to resolve the config again so we can properly merge options
      // and get a new set of plugins for each build environment. The ecosystem
      // expects plugins to be run for the same environment once they are created
      // and to process a single bundle at a time (contrary to dev mode where
      // plugins are built to handle multiple environments concurrently).
      let environmentConfig = config
      if (!configBuilder.sharedConfigBuild) {
        const patchConfig = (resolved: ResolvedConfig) => {
          // Until the ecosystem updates to use `environment.config.build` instead of `config.build`,
          // we need to make override `config.build` for the current environment.
          // We can deprecate `config.build` in ResolvedConfig and push everyone to upgrade, and later
          // remove the default values that shouldn't be used at all once the config is resolved
          ;(resolved.build as ResolvedBuildOptions) = {
            ...resolved.environments[environmentName].build,
          }
        }
        const patchPlugins = (resolvedPlugins: Plugin[]) => {
          // Force opt-in shared plugins
          let j = 0
          for (let i = 0; i < resolvedPlugins.length; i++) {
            const environmentPlugin = resolvedPlugins[i]
            if (
              configBuilder.sharedPlugins ||
              environmentPlugin.sharedDuringBuild
            ) {
              for (let k = j; k < config.plugins.length; k++) {
                if (environmentPlugin.name === config.plugins[k].name) {
                  resolvedPlugins[i] = config.plugins[k]
                  j = k + 1
                  break
                }
              }
            }
          }
        }
        environmentConfig = await resolveConfigToBuild(
          inlineConfig,
          patchConfig,
          patchPlugins,
        )
      }

      await setupEnvironment(environmentName, environmentConfig)
    }
  }

  return builder
}

export type BuildAppHook = (
  this: MinimalPluginContextWithoutEnvironment,
  builder: ViteBuilder,
) => Promise<void>



================================================
FILE: packages/vite/src/node/cli.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import { performance } from 'node:perf_hooks'
import { cac } from 'cac'
import colors from 'picocolors'
import { VERSION } from './constants'
import type { BuildEnvironmentOptions } from './build'
import type { ServerOptions } from './server'
import type { CLIShortcut } from './shortcuts'
import type { LogLevel } from './logger'
import { createLogger } from './logger'
import { resolveConfig } from './config'
import type { InlineConfig } from './config'

const cli = cac('vite')

// global options
interface GlobalCLIOptions {
  '--'?: string[]
  c?: boolean | string
  config?: string
  base?: string
  l?: LogLevel
  logLevel?: LogLevel
  clearScreen?: boolean
  configLoader?: 'bundle' | 'runner' | 'native'
  d?: boolean | string
  debug?: boolean | string
  f?: string
  filter?: string
  m?: string
  mode?: string
  force?: boolean
  w?: boolean
}

interface BuilderCLIOptions {
  app?: boolean
}

let profileSession = global.__vite_profile_session
let profileCount = 0

export const stopProfiler = (
  log: (message: string) => void,
): void | Promise<void> => {
  if (!profileSession) return
  return new Promise((res, rej) => {
    profileSession!.post('Profiler.stop', (err: any, { profile }: any) => {
      // Write profile to disk, upload, etc.
      if (!err) {
        const outPath = path.resolve(
          `./vite-profile-${profileCount++}.cpuprofile`,
        )
        fs.writeFileSync(outPath, JSON.stringify(profile))
        log(
          colors.yellow(
            `CPU profile written to ${colors.white(colors.dim(outPath))}`,
          ),
        )
        profileSession = undefined
        res()
      } else {
        rej(err)
      }
    })
  })
}

const filterDuplicateOptions = <T extends object>(options: T) => {
  for (const [key, value] of Object.entries(options)) {
    if (Array.isArray(value)) {
      options[key as keyof T] = value[value.length - 1]
    }
  }
}
/**
 * removing global flags before passing as command specific sub-configs
 */
function cleanGlobalCLIOptions<Options extends GlobalCLIOptions>(
  options: Options,
): Omit<Options, keyof GlobalCLIOptions> {
  const ret = { ...options }
  delete ret['--']
  delete ret.c
  delete ret.config
  delete ret.base
  delete ret.l
  delete ret.logLevel
  delete ret.clearScreen
  delete ret.configLoader
  delete ret.d
  delete ret.debug
  delete ret.f
  delete ret.filter
  delete ret.m
  delete ret.mode
  delete ret.force
  delete ret.w

  // convert the sourcemap option to a boolean if necessary
  if ('sourcemap' in ret) {
    const sourcemap = ret.sourcemap as `${boolean}` | 'inline' | 'hidden'
    ret.sourcemap =
      sourcemap === 'true'
        ? true
        : sourcemap === 'false'
          ? false
          : ret.sourcemap
  }
  if ('watch' in ret) {
    const watch = ret.watch
    ret.watch = watch ? {} : undefined
  }

  return ret
}

/**
 * removing builder flags before passing as command specific sub-configs
 */
function cleanBuilderCLIOptions<Options extends BuilderCLIOptions>(
  options: Options,
): Omit<Options, keyof BuilderCLIOptions> {
  const ret = { ...options }
  delete ret.app
  return ret
}

/**
 * host may be a number (like 0), should convert to string
 */
const convertHost = (v: any) => {
  if (typeof v === 'number') {
    return String(v)
  }
  return v
}

/**
 * base may be a number (like 0), should convert to empty string
 */
const convertBase = (v: any) => {
  if (v === 0) {
    return ''
  }
  return v
}

cli
  .option('-c, --config <file>', `[string] use specified config file`)
  .option('--base <path>', `[string] public base path (default: /)`, {
    type: [convertBase],
  })
  .option('-l, --logLevel <level>', `[string] info | warn | error | silent`)
  .option('--clearScreen', `[boolean] allow/disable clear screen when logging`)
  .option(
    '--configLoader <loader>',
    `[string] use 'bundle' to bundle the config with esbuild, or 'runner' (experimental) to process it on the fly, or 'native' (experimental) to load using the native runtime (default: bundle)`,
  )
  .option('-d, --debug [feat]', `[string | boolean] show debug logs`)
  .option('-f, --filter <filter>', `[string] filter debug logs`)
  .option('-m, --mode <mode>', `[string] set env mode`)

// dev
cli
  .command('[root]', 'start dev server') // default command
  .alias('serve') // the command is called 'serve' in Vite's API
  .alias('dev') // alias to align with the script name
  .option('--host [host]', `[string] specify hostname`, { type: [convertHost] })
  .option('--port <port>', `[number] specify port`)
  .option('--open [path]', `[boolean | string] open browser on startup`)
  .option('--cors', `[boolean] enable CORS`)
  .option('--strictPort', `[boolean] exit if specified port is already in use`)
  .option(
    '--force',
    `[boolean] force the optimizer to ignore the cache and re-bundle`,
  )
  .action(async (root: string, options: ServerOptions & GlobalCLIOptions) => {
    filterDuplicateOptions(options)
    // output structure is preserved even after bundling so require()
    // is ok here
    const { createServer } = await import('./server')
    try {
      const server = await createServer({
        root,
        base: options.base,
        mode: options.mode,
        configFile: options.config,
        configLoader: options.configLoader,
        logLevel: options.logLevel,
        clearScreen: options.clearScreen,
        server: cleanGlobalCLIOptions(options),
        forceOptimizeDeps: options.force,
      })

      if (!server.httpServer) {
        throw new Error('HTTP server not available')
      }

      await server.listen()

      const info = server.config.logger.info

      const modeString =
        options.mode && options.mode !== 'development'
          ? `  ${colors.bgGreen(` ${colors.bold(options.mode)} `)}`
          : ''
      const viteStartTime = global.__vite_start_time ?? false
      const startupDurationString = viteStartTime
        ? colors.dim(
            `ready in ${colors.reset(
              colors.bold(Math.ceil(performance.now() - viteStartTime)),
            )} ms`,
          )
        : ''
      const hasExistingLogs =
        process.stdout.bytesWritten > 0 || process.stderr.bytesWritten > 0

      info(
        `\n  ${colors.green(
          `${colors.bold('VITE')} v${VERSION}`,
        )}${modeString}  ${startupDurationString}\n`,
        {
          clear: !hasExistingLogs,
        },
      )

      server.printUrls()
      const customShortcuts: CLIShortcut<typeof server>[] = []
      if (profileSession) {
        customShortcuts.push({
          key: 'p',
          description: 'start/stop the profiler',
          async action(server) {
            if (profileSession) {
              await stopProfiler(server.config.logger.info)
            } else {
              const inspector = await import('node:inspector').then(
                (r) => r.default,
              )
              await new Promise<void>((res) => {
                profileSession = new inspector.Session()
                profileSession.connect()
                profileSession.post('Profiler.enable', () => {
                  profileSession!.post('Profiler.start', () => {
                    server.config.logger.info('Profiler started')
                    res()
                  })
                })
              })
            }
          },
        })
      }
      server.bindCLIShortcuts({ print: true, customShortcuts })
    } catch (e) {
      const logger = createLogger(options.logLevel)
      logger.error(colors.red(`error when starting dev server:\n${e.stack}`), {
        error: e,
      })
      stopProfiler(logger.info)
      process.exit(1)
    }
  })

// build
cli
  .command('build [root]', 'build for production')
  .option(
    '--target <target>',
    `[string] transpile target (default: 'baseline-widely-available')`,
  )
  .option('--outDir <dir>', `[string] output directory (default: dist)`)
  .option(
    '--assetsDir <dir>',
    `[string] directory under outDir to place assets in (default: assets)`,
  )
  .option(
    '--assetsInlineLimit <number>',
    `[number] static asset base64 inline threshold in bytes (default: 4096)`,
  )
  .option(
    '--ssr [entry]',
    `[string] build specified entry for server-side rendering`,
  )
  .option(
    '--sourcemap [output]',
    `[boolean | "inline" | "hidden"] output source maps for build (default: false)`,
  )
  .option(
    '--minify [minifier]',
    `[boolean | "terser" | "esbuild"] enable/disable minification, ` +
      `or specify minifier to use (default: esbuild)`,
  )
  .option('--manifest [name]', `[boolean | string] emit build manifest json`)
  .option('--ssrManifest [name]', `[boolean | string] emit ssr manifest json`)
  .option(
    '--emptyOutDir',
    `[boolean] force empty outDir when it's outside of root`,
  )
  .option('-w, --watch', `[boolean] rebuilds when modules have changed on disk`)
  .option('--app', `[boolean] same as \`builder: {}\``)
  .action(
    async (
      root: string,
      options: BuildEnvironmentOptions & BuilderCLIOptions & GlobalCLIOptions,
    ) => {
      filterDuplicateOptions(options)
      const { createBuilder } = await import('./build')

      const buildOptions: BuildEnvironmentOptions = cleanGlobalCLIOptions(
        cleanBuilderCLIOptions(options),
      )

      try {
        const inlineConfig: InlineConfig = {
          root,
          base: options.base,
          mode: options.mode,
          configFile: options.config,
          configLoader: options.configLoader,
          logLevel: options.logLevel,
          clearScreen: options.clearScreen,
          build: buildOptions,
          ...(options.app ? { builder: {} } : {}),
        }
        const builder = await createBuilder(inlineConfig, null)
        await builder.buildApp()
      } catch (e) {
        createLogger(options.logLevel).error(
          colors.red(`error during build:\n${e.stack}`),
          { error: e },
        )
        process.exit(1)
      } finally {
        stopProfiler((message) => createLogger(options.logLevel).info(message))
      }
    },
  )

// optimize
cli
  .command(
    'optimize [root]',
    'pre-bundle dependencies (deprecated, the pre-bundle process runs automatically and does not need to be called)',
  )
  .option(
    '--force',
    `[boolean] force the optimizer to ignore the cache and re-bundle`,
  )
  .action(
    async (root: string, options: { force?: boolean } & GlobalCLIOptions) => {
      filterDuplicateOptions(options)
      const { optimizeDeps } = await import('./optimizer')
      try {
        const config = await resolveConfig(
          {
            root,
            base: options.base,
            configFile: options.config,
            configLoader: options.configLoader,
            logLevel: options.logLevel,
            mode: options.mode,
          },
          'serve',
        )
        await optimizeDeps(config, options.force, true)
      } catch (e) {
        createLogger(options.logLevel).error(
          colors.red(`error when optimizing deps:\n${e.stack}`),
          { error: e },
        )
        process.exit(1)
      }
    },
  )

// preview
cli
  .command('preview [root]', 'locally preview production build')
  .option('--host [host]', `[string] specify hostname`, { type: [convertHost] })
  .option('--port <port>', `[number] specify port`)
  .option('--strictPort', `[boolean] exit if specified port is already in use`)
  .option('--open [path]', `[boolean | string] open browser on startup`)
  .option('--outDir <dir>', `[string] output directory (default: dist)`)
  .action(
    async (
      root: string,
      options: {
        host?: string | boolean
        port?: number
        open?: boolean | string
        strictPort?: boolean
        outDir?: string
      } & GlobalCLIOptions,
    ) => {
      filterDuplicateOptions(options)
      const { preview } = await import('./preview')
      try {
        const server = await preview({
          root,
          base: options.base,
          configFile: options.config,
          configLoader: options.configLoader,
          logLevel: options.logLevel,
          mode: options.mode,
          build: {
            outDir: options.outDir,
          },
          preview: {
            port: options.port,
            strictPort: options.strictPort,
            host: options.host,
            open: options.open,
          },
        })
        server.printUrls()
        server.bindCLIShortcuts({ print: true })
      } catch (e) {
        createLogger(options.logLevel).error(
          colors.red(`error when starting preview server:\n${e.stack}`),
          { error: e },
        )
        process.exit(1)
      } finally {
        stopProfiler((message) => createLogger(options.logLevel).info(message))
      }
    },
  )

cli.help()
cli.version(VERSION)

cli.parse()



================================================
FILE: packages/vite/src/node/constants.ts
================================================
import path, { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { readFileSync } from 'node:fs'
import type { RollupPluginHooks } from './typeUtils'

const { version } = JSON.parse(
  readFileSync(new URL('../../package.json', import.meta.url)).toString(),
)

export const ROLLUP_HOOKS = [
  'options',
  'buildStart',
  'buildEnd',
  'renderStart',
  'renderError',
  'renderChunk',
  'writeBundle',
  'generateBundle',
  'banner',
  'footer',
  'augmentChunkHash',
  'outputOptions',
  'renderDynamicImport',
  'resolveFileUrl',
  'resolveImportMeta',
  'intro',
  'outro',
  'closeBundle',
  'closeWatcher',
  'load',
  'moduleParsed',
  'watchChange',
  'resolveDynamicImport',
  'resolveId',
  'shouldTransformCachedModule',
  'transform',
  'onLog',
] satisfies RollupPluginHooks[]

export const VERSION = version as string

const DEFAULT_MAIN_FIELDS = [
  'browser',
  'module',
  'jsnext:main', // moment still uses this...
  'jsnext',
]
export const DEFAULT_CLIENT_MAIN_FIELDS = Object.freeze(DEFAULT_MAIN_FIELDS)
export const DEFAULT_SERVER_MAIN_FIELDS = Object.freeze(
  DEFAULT_MAIN_FIELDS.filter((f) => f !== 'browser'),
)

/**
 * A special condition that would be replaced with production or development
 * depending on NODE_ENV env variable
 */
export const DEV_PROD_CONDITION = `development|production` as const

const DEFAULT_CONDITIONS = ['module', 'browser', 'node', DEV_PROD_CONDITION]
export const DEFAULT_CLIENT_CONDITIONS = Object.freeze(
  DEFAULT_CONDITIONS.filter((c) => c !== 'node'),
)
export const DEFAULT_SERVER_CONDITIONS = Object.freeze(
  DEFAULT_CONDITIONS.filter((c) => c !== 'browser'),
)

export const DEFAULT_EXTERNAL_CONDITIONS = Object.freeze([
  'node',
  'module-sync',
])

/**
 * The browser versions that are included in the Baseline Widely Available on 2025-05-01.
 *
 * This value would be bumped on each major release of Vite.
 *
 * The value is generated by `pnpm generate-target` script.
 */
export const ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET = [
  'chrome107',
  'edge107',
  'firefox104',
  'safari16',
]

export const DEFAULT_CONFIG_FILES = [
  'vite.config.js',
  'vite.config.mjs',
  'vite.config.ts',
  'vite.config.cjs',
  'vite.config.mts',
  'vite.config.cts',
]

export const JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/

export const CSS_LANGS_RE =
  /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/

export const OPTIMIZABLE_ENTRY_RE = /\.[cm]?[jt]s$/

export const SPECIAL_QUERY_RE = /[?&](?:worker|sharedworker|raw|url)\b/

/**
 * Prefix for resolved fs paths, since windows paths may not be valid as URLs.
 */
export const FS_PREFIX = `/@fs/`

export const CLIENT_PUBLIC_PATH = `/@vite/client`
export const ENV_PUBLIC_PATH = `/@vite/env`
export const VITE_PACKAGE_DIR = resolve(
  fileURLToPath(import.meta.url),
  '../../..',
)

export const CLIENT_ENTRY = resolve(VITE_PACKAGE_DIR, 'dist/client/client.mjs')
export const ENV_ENTRY = resolve(VITE_PACKAGE_DIR, 'dist/client/env.mjs')
export const CLIENT_DIR = path.dirname(CLIENT_ENTRY)

// ** READ THIS ** before editing `KNOWN_ASSET_TYPES`.
//   If you add an asset to `KNOWN_ASSET_TYPES`, make sure to also add it
//   to the TypeScript declaration file `packages/vite/client.d.ts` and
//   add a mime type to the `registerCustomMime` in
//   `packages/vite/src/node/plugin/assets.ts` if mime type cannot be
//   looked up by mrmime.
//   You can check if the mime type can be looked up by mrmime by running
//   `node --print "require('mrmime').lookup('foo.png')"`
export const KNOWN_ASSET_TYPES = [
  // images
  'apng',
  'bmp',
  'png',
  'jpe?g',
  'jfif',
  'pjpeg',
  'pjp',
  'gif',
  'svg',
  'ico',
  'webp',
  'avif',
  'cur',
  'jxl',

  // media
  'mp4',
  'webm',
  'ogg',
  'mp3',
  'wav',
  'flac',
  'aac',
  'opus',
  'mov',
  'm4a',
  'vtt',

  // fonts
  'woff2?',
  'eot',
  'ttf',
  'otf',

  // other
  'webmanifest',
  'pdf',
  'txt',
]

export const DEFAULT_ASSETS_RE = new RegExp(
  `\\.(` + KNOWN_ASSET_TYPES.join('|') + `)(\\?.*)?$`,
  'i',
)

export const DEP_VERSION_RE = /[?&](v=[\w.-]+)\b/

export const loopbackHosts = new Set([
  'localhost',
  '127.0.0.1',
  '::1',
  '0000:0000:0000:0000:0000:0000:0000:0001',
])
export const wildcardHosts = new Set([
  '0.0.0.0',
  '::',
  '0000:0000:0000:0000:0000:0000:0000:0000',
])

export const DEFAULT_DEV_PORT = 5173

export const DEFAULT_PREVIEW_PORT = 4173

export const DEFAULT_ASSETS_INLINE_LIMIT = 4096

// the regex to allow loopback address origins:
// - localhost domains (which will always resolve to the loopback address by RFC 6761 section 6.3)
// - 127.0.0.1
// - ::1
export const defaultAllowedOrigins =
  /^https?:\/\/(?:(?:[^:]+\.)?localhost|127\.0\.0\.1|\[::1\])(?::\d+)?$/

export const METADATA_FILENAME = '_metadata.json'

export const ERR_OPTIMIZE_DEPS_PROCESSING_ERROR =
  'ERR_OPTIMIZE_DEPS_PROCESSING_ERROR'
export const ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR =
  'ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR'



================================================
FILE: packages/vite/src/node/deprecations.ts
================================================
import colors from 'picocolors'
import type { FutureOptions, ResolvedConfig } from './config'

const docsURL = 'https://vite.dev'

const deprecationCode = {
  removePluginHookSsrArgument: 'changes/this-environment-in-hooks',
  removePluginHookHandleHotUpdate: 'changes/hotupdate-hook',

  removeServerModuleGraph: 'changes/per-environment-apis',
  removeServerReloadModule: 'changes/per-environment-apis',
  removeServerPluginContainer: 'changes/per-environment-apis',
  removeServerHot: 'changes/per-environment-apis',
  removeServerTransformRequest: 'changes/per-environment-apis',
  removeServerWarmupRequest: 'changes/per-environment-apis',

  removeSsrLoadModule: 'changes/ssr-using-modulerunner',
} satisfies Record<keyof FutureOptions, string>

const deprecationMessages = {
  removePluginHookSsrArgument:
    "Plugin hook `options.ssr` is replaced with `this.environment.config.consumer === 'server'`.",
  removePluginHookHandleHotUpdate:
    'Plugin hook `handleHotUpdate()` is replaced with `hotUpdate()`.',

  removeServerModuleGraph:
    'The `server.moduleGraph` is replaced with `this.environment.moduleGraph`.',
  removeServerReloadModule:
    'The `server.reloadModule` is replaced with `environment.reloadModule`.',
  removeServerPluginContainer:
    'The `server.pluginContainer` is replaced with `this.environment.pluginContainer`.',
  removeServerHot: 'The `server.hot` is replaced with `this.environment.hot`.',
  removeServerTransformRequest:
    'The `server.transformRequest` is replaced with `this.environment.transformRequest`.',
  removeServerWarmupRequest:
    'The `server.warmupRequest` is replaced with `this.environment.warmupRequest`.',

  removeSsrLoadModule:
    'The `server.ssrLoadModule` is replaced with Environment Runner.',
} satisfies Record<keyof FutureOptions, string>

let _ignoreDeprecationWarnings = false

export function isFutureDeprecationEnabled(
  config: ResolvedConfig,
  type: keyof FutureOptions,
): boolean {
  return !!config.future?.[type]
}

// Later we could have a `warnDeprecation` utils when the deprecation is landed
/**
 * Warn about future deprecations.
 */
export function warnFutureDeprecation(
  config: ResolvedConfig,
  type: keyof FutureOptions,
  extraMessage?: string,
  stacktrace = true,
): void {
  if (
    _ignoreDeprecationWarnings ||
    !config.future ||
    config.future[type] !== 'warn'
  )
    return

  let msg = `[vite future] ${deprecationMessages[type]}`
  if (extraMessage) {
    msg += ` ${extraMessage}`
  }
  msg = colors.yellow(msg)

  const docs = `${docsURL}/changes/${deprecationCode[type].toLowerCase()}`
  msg +=
    colors.gray(`\n  ${stacktrace ? '├' : '└'}─── `) +
    colors.underline(docs) +
    '\n'

  if (stacktrace) {
    const stack = new Error().stack
    if (stack) {
      let stacks = stack
        .split('\n')
        .slice(3)
        .filter((i) => !i.includes('/node_modules/vite/dist/'))
      if (stacks.length === 0) {
        stacks.push('No stack trace found.')
      }
      stacks = stacks.map(
        (i, idx) => `  ${idx === stacks.length - 1 ? '└' : '│'} ${i.trim()}`,
      )
      msg += colors.dim(stacks.join('\n')) + '\n'
    }
  }
  config.logger.warnOnce(msg)
}

export function ignoreDeprecationWarnings<T>(fn: () => T): T {
  const before = _ignoreDeprecationWarnings
  _ignoreDeprecationWarnings = true
  const ret = fn()
  _ignoreDeprecationWarnings = before
  return ret
}



================================================
FILE: packages/vite/src/node/env.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { parse } from 'dotenv'
import { type DotenvPopulateInput, expand } from 'dotenv-expand'
import { arraify, createDebugger, normalizePath, tryStatSync } from './utils'
import type { UserConfig } from './config'

const debug = createDebugger('vite:env')

export function getEnvFilesForMode(
  mode: string,
  envDir: string | false,
): string[] {
  if (envDir !== false) {
    return [
      /** default file */ `.env`,
      /** local file */ `.env.local`,
      /** mode file */ `.env.${mode}`,
      /** mode local file */ `.env.${mode}.local`,
    ].map((file) => normalizePath(path.join(envDir, file)))
  }

  return []
}

export function loadEnv(
  mode: string,
  envDir: string | false,
  prefixes: string | string[] = 'VITE_',
): Record<string, string> {
  const start = performance.now()
  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`

  if (mode === 'local') {
    throw new Error(
      `"local" cannot be used as a mode name because it conflicts with ` +
        `the .local postfix for .env files.`,
    )
  }
  prefixes = arraify(prefixes)
  const env: Record<string, string> = {}
  const envFiles = getEnvFilesForMode(mode, envDir)

  debug?.(`loading env files: %O`, envFiles)

  const parsed = Object.fromEntries(
    envFiles.flatMap((filePath) => {
      if (!tryStatSync(filePath)?.isFile()) return []

      return Object.entries(parse(fs.readFileSync(filePath)))
    }),
  )

  debug?.(`env files loaded in ${getTime()}`)

  // test NODE_ENV override before expand as otherwise process.env.NODE_ENV would override this
  if (parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === undefined) {
    process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV
  }
  // support BROWSER and BROWSER_ARGS env variables
  if (parsed.BROWSER && process.env.BROWSER === undefined) {
    process.env.BROWSER = parsed.BROWSER
  }
  if (parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === undefined) {
    process.env.BROWSER_ARGS = parsed.BROWSER_ARGS
  }

  // let environment variables use each other. make a copy of `process.env` so that `dotenv-expand`
  // doesn't re-assign the expanded values to the global `process.env`.
  const processEnv = { ...process.env } as DotenvPopulateInput
  expand({ parsed, processEnv })

  // only keys that start with prefix are exposed to client
  for (const [key, value] of Object.entries(parsed)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env[key] = value
    }
  }

  // check if there are actual env variables starting with VITE_*
  // these are typically provided inline and should be prioritized
  for (const key in process.env) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env[key] = process.env[key] as string
    }
  }

  debug?.(`using resolved env: %O`, env)

  return env
}

export function resolveEnvPrefix({
  envPrefix = 'VITE_',
}: UserConfig): string[] {
  envPrefix = arraify(envPrefix)
  if (envPrefix.includes('')) {
    throw new Error(
      `envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`,
    )
  }
  return envPrefix
}



================================================
FILE: packages/vite/src/node/environment.ts
================================================
import type { PluginContext } from 'rollup'
import type { DevEnvironment } from './server/environment'
import type { BuildEnvironment } from './build'
import type { ScanEnvironment } from './optimizer/scan'
import type { UnknownEnvironment } from './baseEnvironment'

export type Environment =
  | DevEnvironment
  | BuildEnvironment
  | /** @internal */ ScanEnvironment
  | UnknownEnvironment

/**
 * Creates a function that hides the complexities of a WeakMap with an initial value
 * to implement object metadata. Used by plugins to implement cross hooks per
 * environment metadata
 *
 * @experimental
 */
export function perEnvironmentState<State>(
  initial: (environment: Environment) => State,
): (context: PluginContext) => State {
  const stateMap = new WeakMap<Environment, State>()
  return function (context: PluginContext) {
    const { environment } = context
    let state = stateMap.get(environment)
    if (!state) {
      state = initial(environment)
      stateMap.set(environment, state)
    }
    return state
  }
}



================================================
FILE: packages/vite/src/node/external.ts
================================================
import path from 'node:path'
import type { InternalResolveOptions } from './plugins/resolve'
import { tryNodeResolve } from './plugins/resolve'
import {
  bareImportRE,
  createDebugger,
  createFilter,
  getNpmPackageName,
  isBuiltin,
  isInNodeModules,
} from './utils'
import type { Environment } from './environment'
import type { PartialEnvironment } from './baseEnvironment'

const debug = createDebugger('vite:external')

const isExternalCache = new WeakMap<
  Environment,
  (id: string, importer?: string) => boolean
>()

export function shouldExternalize(
  environment: Environment,
  id: string,
  importer: string | undefined,
): boolean {
  let isExternal = isExternalCache.get(environment)
  if (!isExternal) {
    isExternal = createIsExternal(environment)
    isExternalCache.set(environment, isExternal)
  }
  return isExternal(id, importer)
}

export function createIsConfiguredAsExternal(
  environment: PartialEnvironment,
): (id: string, importer?: string) => boolean {
  const { config } = environment
  const { root, resolve } = config
  const { external, noExternal } = resolve
  const noExternalFilter =
    typeof noExternal !== 'boolean' &&
    !(Array.isArray(noExternal) && noExternal.length === 0) &&
    createFilter(undefined, noExternal, { resolve: false })

  const targetConditions = resolve.externalConditions

  const resolveOptions: InternalResolveOptions = {
    ...resolve,
    root,
    isProduction: false,
    isBuild: true,
    conditions: targetConditions,
  }

  const isExternalizable = (
    id: string,
    importer: string | undefined,
    configuredAsExternal: boolean,
  ): boolean => {
    if (!bareImportRE.test(id) || id.includes('\0')) {
      return false
    }
    try {
      const resolved = tryNodeResolve(
        id,
        // Skip passing importer in build to avoid externalizing non-hoisted dependencies
        // unresolvable from root (which would be unresolvable from output bundles also)
        config.command === 'build' ? undefined : importer,
        resolveOptions,
        undefined,
        false,
      )
      if (!resolved) {
        return false
      }
      // Only allow linked packages to be externalized
      // if they are explicitly configured as external
      if (!configuredAsExternal && !isInNodeModules(resolved.id)) {
        return false
      }
      return canExternalizeFile(resolved.id)
    } catch {
      debug?.(
        `Failed to node resolve "${id}". Skipping externalizing it by default.`,
      )
      // may be an invalid import that's resolved by a plugin
      return false
    }
  }

  // Returns true if it is configured as external, false if it is filtered
  // by noExternal and undefined if it isn't affected by the explicit config
  return (id: string, importer?: string) => {
    if (
      // If this id is defined as external, force it as external
      // Note that individual package entries are allowed in `external`
      external !== true &&
      external.includes(id)
    ) {
      return true
    }
    const pkgName = getNpmPackageName(id)
    if (!pkgName) {
      return isExternalizable(id, importer, false)
    }
    if (
      // A package name in ssr.external externalizes every
      // externalizable package entry
      external !== true &&
      external.includes(pkgName)
    ) {
      return isExternalizable(id, importer, true)
    }
    if (typeof noExternal === 'boolean') {
      return !noExternal
    }
    if (noExternalFilter && !noExternalFilter(pkgName)) {
      return false
    }
    // If external is true, all will be externalized by default, regardless if
    // it's a linked package
    return isExternalizable(id, importer, external === true)
  }
}

function createIsExternal(
  environment: Environment,
): (id: string, importer?: string) => boolean {
  const processedIds = new Map<string, boolean>()

  const isConfiguredAsExternal = createIsConfiguredAsExternal(environment)

  return (id: string, importer?: string) => {
    if (processedIds.has(id)) {
      return processedIds.get(id)!
    }
    let isExternal = false
    if (id[0] !== '.' && !path.isAbsolute(id)) {
      isExternal =
        isBuiltin(environment.config.resolve.builtins, id) ||
        isConfiguredAsExternal(id, importer)
    }
    processedIds.set(id, isExternal)
    return isExternal
  }
}

export function canExternalizeFile(filePath: string): boolean {
  const ext = path.extname(filePath)
  // only external js imports
  return !ext || ext === '.js' || ext === '.mjs' || ext === '.cjs'
}



================================================
FILE: packages/vite/src/node/http.ts
================================================
import fsp from 'node:fs/promises'
import path from 'node:path'
import type { OutgoingHttpHeaders as HttpServerHeaders } from 'node:http'
import type { ServerOptions as HttpsServerOptions } from 'node:https'
import type { Connect } from 'dep-types/connect'
import colors from 'picocolors'
import type { ProxyOptions } from './server/middlewares/proxy'
import type { Logger } from './logger'
import type { HttpServer } from './server'

export interface CommonServerOptions {
  /**
   * Specify server port. Note if the port is already being used, Vite will
   * automatically try the next available port so this may not be the actual
   * port the server ends up listening on.
   */
  port?: number
  /**
   * If enabled, vite will exit if specified port is already in use
   */
  strictPort?: boolean
  /**
   * Specify which IP addresses the server should listen on.
   * Set to 0.0.0.0 to listen on all addresses, including LAN and public addresses.
   */
  host?: string | boolean
  /**
   * The hostnames that Vite is allowed to respond to.
   * `localhost` and subdomains under `.localhost` and all IP addresses are allowed by default.
   * When using HTTPS, this check is skipped.
   *
   * If a string starts with `.`, it will allow that hostname without the `.` and all subdomains under the hostname.
   * For example, `.example.com` will allow `example.com`, `foo.example.com`, and `foo.bar.example.com`.
   *
   * If set to `true`, the server is allowed to respond to requests for any hosts.
   * This is not recommended as it will be vulnerable to DNS rebinding attacks.
   */
  allowedHosts?: string[] | true
  /**
   * Enable TLS + HTTP/2.
   * Note: this downgrades to TLS only when the proxy option is also used.
   */
  https?: HttpsServerOptions
  /**
   * Open browser window on startup
   */
  open?: boolean | string
  /**
   * Configure custom proxy rules for the dev server. Expects an object
   * of `{ key: options }` pairs.
   * Uses [`http-proxy-3`](https://github.com/sagemathinc/http-proxy-3).
   * Full options [here](https://github.com/sagemathinc/http-proxy-3#options).
   *
   * Example `vite.config.js`:
   * ``` js
   * module.exports = {
   *   proxy: {
   *     // string shorthand: /foo -> http://localhost:4567/foo
   *     '/foo': 'http://localhost:4567',
   *     // with options
   *     '/api': {
   *       target: 'http://jsonplaceholder.typicode.com',
   *       changeOrigin: true,
   *       rewrite: path => path.replace(/^\/api/, '')
   *     }
   *   }
   * }
   * ```
   */
  proxy?: Record<string, string | ProxyOptions>
  /**
   * Configure CORS for the dev server.
   * Uses https://github.com/expressjs/cors.
   *
   * When enabling this option, **we recommend setting a specific value
   * rather than `true`** to avoid exposing the source code to untrusted origins.
   *
   * Set to `true` to allow all methods from any origin, or configure separately
   * using an object.
   *
   * @default false
   */
  cors?: CorsOptions | boolean
  /**
   * Specify server response headers.
   */
  headers?: HttpServerHeaders
}

/**
 * https://github.com/expressjs/cors#configuration-options
 */
export interface CorsOptions {
  /**
   * Configures the Access-Control-Allow-Origin CORS header.
   *
   * **We recommend setting a specific value rather than
   * `true`** to avoid exposing the source code to untrusted origins.
   */
  origin?:
    | CorsOrigin
    | ((
        origin: string | undefined,
        cb: (err: Error, origins: CorsOrigin) => void,
      ) => void)
  methods?: string | string[]
  allowedHeaders?: string | string[]
  exposedHeaders?: string | string[]
  credentials?: boolean
  maxAge?: number
  preflightContinue?: boolean
  optionsSuccessStatus?: number
}

export type CorsOrigin = boolean | string | RegExp | (string | RegExp)[]

export async function resolveHttpServer(
  { proxy }: CommonServerOptions,
  app: Connect.Server,
  httpsOptions?: HttpsServerOptions,
): Promise<HttpServer> {
  if (!httpsOptions) {
    const { createServer } = await import('node:http')
    return createServer(app)
  }

  // #484 fallback to http1 when proxy is needed.
  if (proxy) {
    const { createServer } = await import('node:https')
    return createServer(httpsOptions, app)
  } else {
    const { createSecureServer } = await import('node:http2')
    return createSecureServer(
      {
        // Manually increase the session memory to prevent 502 ENHANCE_YOUR_CALM
        // errors on large numbers of requests
        maxSessionMemory: 1000,
        ...httpsOptions,
        allowHTTP1: true,
      },
      // @ts-expect-error TODO: is this correct?
      app,
    )
  }
}

export async function resolveHttpsConfig(
  https: HttpsServerOptions | undefined,
): Promise<HttpsServerOptions | undefined> {
  if (!https) return undefined

  const [ca, cert, key, pfx] = await Promise.all([
    readFileIfExists(https.ca),
    readFileIfExists(https.cert),
    readFileIfExists(https.key),
    readFileIfExists(https.pfx),
  ])
  return { ...https, ca, cert, key, pfx }
}

async function readFileIfExists(value?: string | Buffer | any[]) {
  if (typeof value === 'string') {
    return fsp.readFile(path.resolve(value)).catch(() => value)
  }
  return value
}

export async function httpServerStart(
  httpServer: HttpServer,
  serverOptions: {
    port: number
    strictPort: boolean | undefined
    host: string | undefined
    logger: Logger
  },
): Promise<number> {
  let { port, strictPort, host, logger } = serverOptions

  return new Promise((resolve, reject) => {
    const onError = (e: Error & { code?: string }) => {
      if (e.code === 'EADDRINUSE') {
        if (strictPort) {
          httpServer.removeListener('error', onError)
          reject(new Error(`Port ${port} is already in use`))
        } else {
          logger.info(`Port ${port} is in use, trying another one...`)
          httpServer.listen(++port, host)
        }
      } else {
        httpServer.removeListener('error', onError)
        reject(e)
      }
    }

    httpServer.on('error', onError)

    httpServer.listen(port, host, () => {
      httpServer.removeListener('error', onError)
      resolve(port)
    })
  })
}

export function setClientErrorHandler(
  server: HttpServer,
  logger: Logger,
): void {
  server.on('clientError', (err, socket) => {
    let msg = '400 Bad Request'
    if ((err as any).code === 'HPE_HEADER_OVERFLOW') {
      msg = '431 Request Header Fields Too Large'
      logger.warn(
        colors.yellow(
          'Server responded with status code 431. ' +
            'See https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large.',
        ),
      )
    }
    if ((err as any).code === 'ECONNRESET' || !socket.writable) {
      return
    }
    socket.end(`HTTP/1.1 ${msg}\r\n\r\n`)
  })
}



================================================
FILE: packages/vite/src/node/idResolver.ts
================================================
import type { PartialResolvedId } from 'rollup'
import aliasPlugin from '@rollup/plugin-alias'
import type { ResolvedConfig } from './config'
import type { EnvironmentPluginContainer } from './server/pluginContainer'
import { createEnvironmentPluginContainer } from './server/pluginContainer'
import { resolvePlugin } from './plugins/resolve'
import type { InternalResolveOptions } from './plugins/resolve'
import type { Environment } from './environment'
import type { PartialEnvironment } from './baseEnvironment'

export type ResolveIdFn = (
  environment: PartialEnvironment,
  id: string,
  importer?: string,
  aliasOnly?: boolean,
) => Promise<string | undefined>

/**
 * Some projects like Astro were overriding config.createResolver to add a custom
 * alias plugin. For the client and ssr environments, we root through it to avoid
 * breaking changes for now.
 */
export function createBackCompatIdResolver(
  config: ResolvedConfig,
  options?: Partial<InternalResolveOptions>,
): ResolveIdFn {
  const compatResolve = config.createResolver(options)
  let resolve: ResolveIdFn
  return async (environment, id, importer, aliasOnly) => {
    if (environment.name === 'client' || environment.name === 'ssr') {
      return compatResolve(id, importer, aliasOnly, environment.name === 'ssr')
    }
    resolve ??= createIdResolver(config, options)
    return resolve(environment, id, importer, aliasOnly)
  }
}

/**
 * Create an internal resolver to be used in special scenarios, e.g.
 * optimizer and handling css @imports
 */
export function createIdResolver(
  config: ResolvedConfig,
  options?: Partial<InternalResolveOptions>,
): ResolveIdFn {
  const scan = options?.scan

  const pluginContainerMap = new Map<
    PartialEnvironment,
    EnvironmentPluginContainer
  >()
  async function resolve(
    environment: PartialEnvironment,
    id: string,
    importer?: string,
  ): Promise<PartialResolvedId | null> {
    let pluginContainer = pluginContainerMap.get(environment)
    if (!pluginContainer) {
      pluginContainer = await createEnvironmentPluginContainer(
        environment as Environment,
        [
          aliasPlugin({ entries: environment.config.resolve.alias }),
          resolvePlugin({
            root: config.root,
            isProduction: config.isProduction,
            isBuild: config.command === 'build',
            asSrc: true,
            preferRelative: false,
            tryIndex: true,
            ...options,
            // Ignore sideEffects and other computations as we only need the id
            idOnly: true,
          }),
        ],
        undefined,
        false,
      )
      pluginContainerMap.set(environment, pluginContainer)
    }
    return await pluginContainer.resolveId(id, importer, { scan })
  }

  const aliasOnlyPluginContainerMap = new Map<
    PartialEnvironment,
    EnvironmentPluginContainer
  >()
  async function resolveAlias(
    environment: PartialEnvironment,
    id: string,
    importer?: string,
  ): Promise<PartialResolvedId | null> {
    let pluginContainer = aliasOnlyPluginContainerMap.get(environment)
    if (!pluginContainer) {
      pluginContainer = await createEnvironmentPluginContainer(
        environment as Environment,
        [aliasPlugin({ entries: environment.config.resolve.alias })],
        undefined,
        false,
      )
      aliasOnlyPluginContainerMap.set(environment, pluginContainer)
    }
    return await pluginContainer.resolveId(id, importer, { scan })
  }

  return async (environment, id, importer, aliasOnly) => {
    const resolveFn = aliasOnly ? resolveAlias : resolve
    // aliasPlugin and resolvePlugin are implemented to function with a Environment only,
    // we cast it as PluginEnvironment to be able to use the pluginContainer
    const resolved = await resolveFn(environment, id, importer)
    return resolved?.id
  }
}



================================================
FILE: packages/vite/src/node/index.ts
================================================
import type * as Rollup from 'rollup'

export type { Rollup }
export { parseAst, parseAstAsync } from 'rollup/parseAst'
export {
  defineConfig,
  loadConfigFromFile,
  resolveConfig,
  sortUserPlugins,
} from './config'
export { perEnvironmentPlugin } from './plugin'
export { perEnvironmentState } from './environment'
export { createServer } from './server'
export { preview } from './preview'
export { build, createBuilder } from './build'

export { optimizeDeps } from './optimizer'
export { createIdResolver } from './idResolver'

export { formatPostcssSourceMap, preprocessCSS } from './plugins/css'
export { transformWithEsbuild } from './plugins/esbuild'
export { buildErrorMessage } from './server/middlewares/error'

export {
  createRunnableDevEnvironment,
  isRunnableDevEnvironment,
  type RunnableDevEnvironment,
  type RunnableDevEnvironmentContext,
} from './server/environments/runnableEnvironment'
export {
  createFetchableDevEnvironment,
  isFetchableDevEnvironment,
  type FetchableDevEnvironment,
  type FetchableDevEnvironmentContext,
} from './server/environments/fetchableEnvironments'
export {
  DevEnvironment,
  type DevEnvironmentContext,
} from './server/environment'
export { runnerImport } from './ssr/runnerImport'
export { BuildEnvironment } from './build'

export { fetchModule, type FetchModuleOptions } from './ssr/fetchModule'
export {
  createServerModuleRunner,
  createServerModuleRunnerTransport,
} from './ssr/runtime/serverModuleRunner'
export { createServerHotChannel } from './server/hmr'
export { ssrTransform as moduleRunnerTransform } from './ssr/ssrTransform'
export type { ModuleRunnerTransformOptions } from './ssr/ssrTransform'

export {
  VERSION as version,
  DEFAULT_CLIENT_CONDITIONS as defaultClientConditions,
  DEFAULT_CLIENT_MAIN_FIELDS as defaultClientMainFields,
  DEFAULT_EXTERNAL_CONDITIONS as defaultExternalConditions,
  DEFAULT_SERVER_CONDITIONS as defaultServerConditions,
  DEFAULT_SERVER_MAIN_FIELDS as defaultServerMainFields,
  defaultAllowedOrigins,
} from './constants'
export { version as esbuildVersion } from 'esbuild'
export {
  normalizePath,
  mergeConfig,
  mergeAlias,
  createFilter,
  isCSSRequest,
  rollupVersion,
} from './utils'
export { send } from './server/send'
export { createLogger } from './logger'
export { searchForWorkspaceRoot } from './server/searchRoot'

export {
  isFileServingAllowed,
  isFileLoadingAllowed,
} from './server/middlewares/static'
export { loadEnv, resolveEnvPrefix } from './env'

// additional types
export type {
  AppType,
  ConfigEnv,
  ExperimentalOptions,
  HTMLOptions,
  InlineConfig,
  LegacyOptions,
  PluginHookUtils,
  ResolveFn,
  ResolvedWorkerOptions,
  ResolvedConfig,
  UserConfig,
  UserConfigExport,
  UserConfigFn,
  UserConfigFnObject,
  UserConfigFnPromise,
  EnvironmentOptions,
  DevEnvironmentOptions,
  ResolvedDevEnvironmentOptions,
} from './config'
export type {
  Plugin,
  PluginOption,
  HookHandler,
  ConfigPluginContext,
  MinimalPluginContextWithoutEnvironment,
} from './plugin'
export type { Environment } from './environment'
export type { FilterPattern } from './utils'
export type { CorsOptions, CorsOrigin, CommonServerOptions } from './http'
export type {
  ViteDevServer,
  ServerOptions,
  FileSystemServeOptions,
  ServerHook,
  ResolvedServerOptions,
  ResolvedServerUrls,
  HttpServer,
} from './server'
export type {
  ViteBuilder,
  BuildAppHook,
  BuilderOptions,
  BuildOptions,
  BuildEnvironmentOptions,
  LibraryOptions,
  LibraryFormats,
  RenderBuiltAssetUrl,
  ResolvedBuildOptions,
  ResolvedBuildEnvironmentOptions,
  ModulePreloadOptions,
  ResolvedModulePreloadOptions,
  ResolveModulePreloadDependenciesFn,
} from './build'
export type {
  PreviewOptions,
  PreviewServer,
  PreviewServerHook,
  ResolvedPreviewOptions,
} from './preview'
export type {
  DepOptimizationMetadata,
  DepOptimizationOptions,
  DepOptimizationConfig,
  OptimizedDepInfo,
  ExportsData,
} from './optimizer'
export type {
  ResolvedSSROptions,
  SsrDepOptimizationConfig,
  SSROptions,
  SSRTarget,
} from './ssr'
export type {
  Logger,
  LogOptions,
  LogErrorOptions,
  LogLevel,
  LogType,
  LoggerOptions,
} from './logger'
export type {
  IndexHtmlTransform,
  IndexHtmlTransformHook,
  IndexHtmlTransformContext,
  IndexHtmlTransformResult,
  HtmlTagDescriptor,
} from './plugins/html'
export type {
  CSSOptions,
  CSSModulesOptions,
  PreprocessCSSResult,
  ResolvedCSSOptions,
  SassPreprocessorOptions,
  LessPreprocessorOptions,
  StylusPreprocessorOptions,
} from './plugins/css'
export type { JsonOptions } from './plugins/json'
export type { TransformOptions as EsbuildTransformOptions } from 'esbuild'
export type { ESBuildOptions, ESBuildTransformResult } from './plugins/esbuild'
export type { Manifest, ManifestChunk } from './plugins/manifest'
export type { ResolveOptions, InternalResolveOptions } from './plugins/resolve'
export type { TerserOptions } from './plugins/terser'

export type {
  WebSocketServer,
  WebSocketClient,
  WebSocketCustomListener,
} from './server/ws'
export type { SkipInformation, PluginContainer } from './server/pluginContainer'
export type {
  EnvironmentModuleGraph,
  EnvironmentModuleNode,
  ResolvedUrl,
} from './server/moduleGraph'
export type { SendOptions } from './server/send'
export type { ProxyOptions } from './server/middlewares/proxy'
export type {
  TransformOptions,
  TransformResult,
} from './server/transformRequest'
export type {
  HmrOptions,
  HmrContext,
  HotUpdateOptions,
  HotChannelListener,
  HotChannel,
  ServerHotChannel,
  HotChannelClient,
  NormalizedHotChannel,
  NormalizedHotChannelClient,
  NormalizedServerHotChannel,
} from './server/hmr'

export type { FetchFunction, FetchResult } from 'vite/module-runner'
export type { ServerModuleRunnerOptions } from './ssr/runtime/serverModuleRunner'

export type { BindCLIShortcutsOptions, CLIShortcut } from './shortcuts'

export type {
  HMRPayload,
  HotPayload,
  ConnectedPayload,
  UpdatePayload,
  Update,
  FullReloadPayload,
  CustomPayload,
  PrunePayload,
  ErrorPayload,
} from 'types/hmrPayload'
export type {
  CustomEventMap,
  InferCustomEventPayload,
  InvalidatePayload,
} from 'types/customEvent'
export type {
  ImportGlobFunction,
  ImportGlobOptions,
  GeneralImportGlobOptions,
  KnownAsTypeMap,
} from 'types/importGlob'
export type { ChunkMetadata, CustomPluginOptionsVite } from 'types/metadata'

// dep types
export type {
  AliasOptions,
  MapToFunction,
  ResolverFunction,
  ResolverObject,
  Alias,
} from 'dep-types/alias'
export type { Connect } from 'dep-types/connect'
export type { WebSocket, WebSocketAlias } from 'dep-types/ws'
export type * as HttpProxy from 'http-proxy-3'
export type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
export type { Terser } from 'types/internal/terserOptions'
export type { RollupCommonJSOptions } from 'dep-types/commonjs'
export type { RollupDynamicImportVarsOptions } from 'dep-types/dynamicImportVars'
export type { Matcher, AnymatchPattern, AnymatchFn } from 'dep-types/anymatch'
export type { LightningCSSOptions } from 'types/internal/lightningcssOptions'

// Backward compatibility
export type { ModuleGraph, ModuleNode } from './server/mixedModuleGraph'



================================================
FILE: packages/vite/src/node/logger.ts
================================================
/* eslint no-console: 0 */

import readline from 'node:readline'
import colors from 'picocolors'
import type { RollupError } from 'rollup'
import type { ResolvedServerUrls } from './server'

export type LogType = 'error' | 'warn' | 'info'
export type LogLevel = LogType | 'silent'
export interface Logger {
  info(msg: string, options?: LogOptions): void
  warn(msg: string, options?: LogOptions): void
  warnOnce(msg: string, options?: LogOptions): void
  error(msg: string, options?: LogErrorOptions): void
  clearScreen(type: LogType): void
  hasErrorLogged(error: Error | RollupError): boolean
  hasWarned: boolean
}

export interface LogOptions {
  clear?: boolean
  timestamp?: boolean
  environment?: string
}

export interface LogErrorOptions extends LogOptions {
  error?: Error | RollupError | null
}

export const LogLevels: Record<LogLevel, number> = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
}

let lastType: LogType | undefined
let lastMsg: string | undefined
let sameCount = 0

function clearScreen() {
  const repeatCount = process.stdout.rows - 2
  const blank = repeatCount > 0 ? '\n'.repeat(repeatCount) : ''
  console.log(blank)
  readline.cursorTo(process.stdout, 0, 0)
  readline.clearScreenDown(process.stdout)
}

export interface LoggerOptions {
  prefix?: string
  allowClearScreen?: boolean
  customLogger?: Logger
  console?: Console
}

// Only initialize the timeFormatter when the timestamp option is used, and
// reuse it across all loggers
let timeFormatter: Intl.DateTimeFormat
function getTimeFormatter() {
  timeFormatter ??= new Intl.DateTimeFormat(undefined, {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric',
  })
  return timeFormatter
}

export function createLogger(
  level: LogLevel = 'info',
  options: LoggerOptions = {},
): Logger {
  if (options.customLogger) {
    return options.customLogger
  }

  const loggedErrors = new WeakSet<Error | RollupError>()
  const {
    prefix = '[vite]',
    allowClearScreen = true,
    console = globalThis.console,
  } = options
  const thresh = LogLevels[level]
  const canClearScreen =
    allowClearScreen && process.stdout.isTTY && !process.env.CI
  const clear = canClearScreen ? clearScreen : () => {}

  function format(type: LogType, msg: string, options: LogErrorOptions = {}) {
    if (options.timestamp) {
      let tag = ''
      if (type === 'info') {
        tag = colors.cyan(colors.bold(prefix))
      } else if (type === 'warn') {
        tag = colors.yellow(colors.bold(prefix))
      } else {
        tag = colors.red(colors.bold(prefix))
      }
      const environment = options.environment ? options.environment + ' ' : ''
      return `${colors.dim(getTimeFormatter().format(new Date()))} ${tag} ${environment}${msg}`
    } else {
      return msg
    }
  }

  function output(type: LogType, msg: string, options: LogErrorOptions = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === 'info' ? 'log' : type

      if (options.error) {
        loggedErrors.add(options.error)
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++
          clear()
          console[method](
            format(type, msg, options),
            colors.yellow(`(x${sameCount + 1})`),
          )
        } else {
          sameCount = 0
          lastMsg = msg
          lastType = type
          if (options.clear) {
            clear()
          }
          console[method](format(type, msg, options))
        }
      } else {
        console[method](format(type, msg, options))
      }
    }
  }

  const warnedMessages = new Set<string>()

  const logger: Logger = {
    hasWarned: false,
    info(msg, opts) {
      output('info', msg, opts)
    },
    warn(msg, opts) {
      logger.hasWarned = true
      output('warn', msg, opts)
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg)) return
      logger.hasWarned = true
      output('warn', msg, opts)
      warnedMessages.add(msg)
    },
    error(msg, opts) {
      logger.hasWarned = true
      output('error', msg, opts)
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear()
      }
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error)
    },
  }

  return logger
}

export function printServerUrls(
  urls: ResolvedServerUrls,
  optionsHost: string | boolean | undefined,
  info: Logger['info'],
): void {
  const colorUrl = (url: string) =>
    colors.cyan(url.replace(/:(\d+)\//, (_, port) => `:${colors.bold(port)}/`))
  for (const url of urls.local) {
    info(`  ${colors.green('➜')}  ${colors.bold('Local')}:   ${colorUrl(url)}`)
  }
  for (const url of urls.network) {
    info(`  ${colors.green('➜')}  ${colors.bold('Network')}: ${colorUrl(url)}`)
  }
  if (urls.network.length === 0 && optionsHost === undefined) {
    info(
      colors.dim(`  ${colors.green('➜')}  ${colors.bold('Network')}: use `) +
        colors.bold('--host') +
        colors.dim(' to expose'),
    )
  }
}



================================================
FILE: packages/vite/src/node/packages.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { createRequire } from 'node:module'
import {
  createFilter,
  isInNodeModules,
  normalizePath,
  safeRealpathSync,
  stripBomTag,
  tryStatSync,
} from './utils'
import type { Plugin } from './plugin'
import type { InternalResolveOptions } from './plugins/resolve'

let pnp: typeof import('pnpapi') | undefined
if (process.versions.pnp) {
  try {
    pnp = createRequire(/** #__KEEP__ */ import.meta.url)('pnpapi')
  } catch {}
}

/** Cache for package.json resolution and package.json contents */
export type PackageCache = Map<string, PackageData>

export interface PackageData {
  dir: string
  hasSideEffects: (id: string) => boolean | 'no-treeshake' | null
  setResolvedCache: (
    key: string,
    entry: string,
    options: InternalResolveOptions,
  ) => void
  getResolvedCache: (
    key: string,
    options: InternalResolveOptions,
  ) => string | undefined
  data: {
    [field: string]: any
    name: string
    type: string
    version: string
    main: string
    module: string
    browser: string | Record<string, string | false>
    exports: string | Record<string, any> | string[]
    imports: Record<string, any>
    dependencies: Record<string, string>
  }
}

function invalidatePackageData(
  packageCache: PackageCache,
  pkgPath: string,
): void {
  const pkgDir = normalizePath(path.dirname(pkgPath))
  packageCache.forEach((pkg, cacheKey) => {
    if (pkg.dir === pkgDir) {
      packageCache.delete(cacheKey)
    }
  })
}

export function resolvePackageData(
  pkgName: string,
  basedir: string,
  preserveSymlinks = false,
  packageCache?: PackageCache,
): PackageData | null {
  if (pnp) {
    const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks)
    if (packageCache?.has(cacheKey)) return packageCache.get(cacheKey)!

    try {
      const pkg = pnp.resolveToUnqualified(pkgName, basedir, {
        considerBuiltins: false,
      })
      if (!pkg) return null

      const pkgData = loadPackageData(path.join(pkg, 'package.json'))
      packageCache?.set(cacheKey, pkgData)
      return pkgData
    } catch {
      return null
    }
  }

  const originalBasedir = basedir
  while (basedir) {
    if (packageCache) {
      const cached = getRpdCache(
        packageCache,
        pkgName,
        basedir,
        originalBasedir,
        preserveSymlinks,
      )
      if (cached) return cached
    }

    const pkg = path.join(basedir, 'node_modules', pkgName, 'package.json')
    try {
      if (fs.existsSync(pkg)) {
        const pkgPath = preserveSymlinks ? pkg : safeRealpathSync(pkg)
        const pkgData = loadPackageData(pkgPath)

        if (packageCache) {
          setRpdCache(
            packageCache,
            pkgData,
            pkgName,
            basedir,
            originalBasedir,
            preserveSymlinks,
          )
        }

        return pkgData
      }
    } catch {}

    const nextBasedir = path.dirname(basedir)
    if (nextBasedir === basedir) break
    basedir = nextBasedir
  }

  return null
}

export function findNearestPackageData(
  basedir: string,
  packageCache?: PackageCache,
): PackageData | null {
  const originalBasedir = basedir
  while (basedir) {
    if (packageCache) {
      const cached = getFnpdCache(packageCache, basedir, originalBasedir)
      if (cached) return cached
    }

    const pkgPath = path.join(basedir, 'package.json')
    if (tryStatSync(pkgPath)?.isFile()) {
      try {
        const pkgData = loadPackageData(pkgPath)

        if (packageCache) {
          setFnpdCache(packageCache, pkgData, basedir, originalBasedir)
        }

        return pkgData
      } catch {}
    }

    const nextBasedir = path.dirname(basedir)
    if (nextBasedir === basedir) break
    basedir = nextBasedir
  }

  return null
}

// Finds the nearest package.json with a `name` field
export function findNearestMainPackageData(
  basedir: string,
  packageCache?: PackageCache,
): PackageData | null {
  const nearestPackage = findNearestPackageData(basedir, packageCache)
  return (
    nearestPackage &&
    (nearestPackage.data.name
      ? nearestPackage
      : findNearestMainPackageData(
          path.dirname(nearestPackage.dir),
          packageCache,
        ))
  )
}

export function loadPackageData(pkgPath: string): PackageData {
  const data = JSON.parse(stripBomTag(fs.readFileSync(pkgPath, 'utf-8')))
  const pkgDir = normalizePath(path.dirname(pkgPath))
  const { sideEffects } = data
  let hasSideEffects: (id: string) => boolean | null
  if (typeof sideEffects === 'boolean') {
    hasSideEffects = () => sideEffects
  } else if (Array.isArray(sideEffects)) {
    if (sideEffects.length <= 0) {
      // createFilter always returns true if `includes` is an empty array
      // but here we want it to always return false
      hasSideEffects = () => false
    } else {
      const finalPackageSideEffects = sideEffects.map((sideEffect) => {
        /*
         * The array accepts simple glob patterns to the relevant files... Patterns like *.css, which do not include a /, will be treated like **\/*.css.
         * https://webpack.js.org/guides/tree-shaking/
         * https://github.com/vitejs/vite/pull/11807
         */
        if (sideEffect.includes('/')) {
          return sideEffect
        }
        return `**/${sideEffect}`
      })

      hasSideEffects = createFilter(finalPackageSideEffects, null, {
        resolve: pkgDir,
      })
    }
  } else {
    hasSideEffects = () => null
  }

  const resolvedCache: Record<string, string | undefined> = {}
  const pkg: PackageData = {
    dir: pkgDir,
    data,
    hasSideEffects,
    setResolvedCache(key, entry, options) {
      resolvedCache[getResolveCacheKey(key, options)] = entry
    },
    getResolvedCache(key, options) {
      return resolvedCache[getResolveCacheKey(key, options)]
    },
  }

  return pkg
}

function getResolveCacheKey(key: string, options: InternalResolveOptions) {
  // cache key needs to include options which affect
  // `resolvePackageEntry` or `resolveDeepImport`
  return [
    key,
    options.isRequire ? '1' : '0',
    options.conditions.join('_'),
    options.extensions.join('_'),
    options.mainFields.join('_'),
  ].join('|')
}

export function findNearestNodeModules(basedir: string): string | null {
  while (basedir) {
    const pkgPath = path.join(basedir, 'node_modules')
    if (tryStatSync(pkgPath)?.isDirectory()) {
      return pkgPath
    }

    const nextBasedir = path.dirname(basedir)
    if (nextBasedir === basedir) break
    basedir = nextBasedir
  }

  return null
}

export function watchPackageDataPlugin(packageCache: PackageCache): Plugin {
  // a list of files to watch before the plugin is ready
  const watchQueue = new Set<string>()
  const watchedDirs = new Set<string>()

  const watchFileStub = (id: string) => {
    watchQueue.add(id)
  }
  let watchFile = watchFileStub

  const setPackageData = packageCache.set.bind(packageCache)
  packageCache.set = (id, pkg) => {
    if (!isInNodeModules(pkg.dir) && !watchedDirs.has(pkg.dir)) {
      watchedDirs.add(pkg.dir)
      watchFile(path.join(pkg.dir, 'package.json'))
    }
    return setPackageData(id, pkg)
  }

  return {
    name: 'vite:watch-package-data',
    buildStart() {
      watchFile = this.addWatchFile.bind(this)
      watchQueue.forEach(watchFile)
      watchQueue.clear()
    },
    buildEnd() {
      watchFile = watchFileStub
    },
    watchChange(id) {
      if (id.endsWith('/package.json')) {
        invalidatePackageData(packageCache, path.normalize(id))
      }
    },
  }
}

/**
 * Get cached `resolvePackageData` value based on `basedir`. When one is found,
 * and we've already traversed some directories between `basedir` and `originalBasedir`,
 * we cache the value for those in-between directories as well.
 *
 * This makes it so the fs is only read once for a shared `basedir`.
 */
function getRpdCache(
  packageCache: PackageCache,
  pkgName: string,
  basedir: string,
  originalBasedir: string,
  preserveSymlinks: boolean,
) {
  const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks)
  const pkgData = packageCache.get(cacheKey)
  if (pkgData) {
    traverseBetweenDirs(originalBasedir, basedir, (dir) => {
      packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData)
    })
    return pkgData
  }
}

function setRpdCache(
  packageCache: PackageCache,
  pkgData: PackageData,
  pkgName: string,
  basedir: string,
  originalBasedir: string,
  preserveSymlinks: boolean,
) {
  packageCache.set(getRpdCacheKey(pkgName, basedir, preserveSymlinks), pkgData)
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData)
  })
}

// package cache key for `resolvePackageData`
function getRpdCacheKey(
  pkgName: string,
  basedir: string,
  preserveSymlinks: boolean,
) {
  return `rpd_${pkgName}_${basedir}_${preserveSymlinks}`
}

/**
 * Get cached `findNearestPackageData` value based on `basedir`. When one is found,
 * and we've already traversed some directories between `basedir` and `originalBasedir`,
 * we cache the value for those in-between directories as well.
 *
 * This makes it so the fs is only read once for a shared `basedir`.
 */
function getFnpdCache(
  packageCache: PackageCache,
  basedir: string,
  originalBasedir: string,
) {
  const cacheKey = getFnpdCacheKey(basedir)
  const pkgData = packageCache.get(cacheKey)
  if (pkgData) {
    traverseBetweenDirs(originalBasedir, basedir, (dir) => {
      packageCache.set(getFnpdCacheKey(dir), pkgData)
    })
    return pkgData
  }
}

function setFnpdCache(
  packageCache: PackageCache,
  pkgData: PackageData,
  basedir: string,
  originalBasedir: string,
) {
  packageCache.set(getFnpdCacheKey(basedir), pkgData)
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    packageCache.set(getFnpdCacheKey(dir), pkgData)
  })
}

// package cache key for `findNearestPackageData`
function getFnpdCacheKey(basedir: string) {
  return `fnpd_${basedir}`
}

/**
 * Traverse between `longerDir` (inclusive) and `shorterDir` (exclusive) and call `cb` for each dir.
 * @param longerDir Longer dir path, e.g. `/User/foo/bar/baz`
 * @param shorterDir Shorter dir path, e.g. `/User/foo`
 */
function traverseBetweenDirs(
  longerDir: string,
  shorterDir: string,
  cb: (dir: string) => void,
) {
  while (longerDir !== shorterDir) {
    cb(longerDir)
    longerDir = path.dirname(longerDir)
  }
}



================================================
FILE: packages/vite/src/node/plugin.ts
================================================
import type {
  CustomPluginOptions,
  LoadResult,
  MinimalPluginContext,
  ObjectHook,
  PluginContext,
  PluginContextMeta,
  ResolveIdResult,
  Plugin as RollupPlugin,
  TransformPluginContext,
  TransformResult,
} from 'rollup'
import type {
  ConfigEnv,
  EnvironmentOptions,
  ResolvedConfig,
  UserConfig,
} from './config'
import type { ServerHook } from './server'
import type { BuildAppHook } from './build'
import type { IndexHtmlTransform } from './plugins/html'
import type { EnvironmentModuleNode } from './server/moduleGraph'
import type { ModuleNode } from './server/mixedModuleGraph'
import type { HmrContext, HotUpdateOptions } from './server/hmr'
import type { DevEnvironment } from './server/environment'
import type { Environment } from './environment'
import type { PartialEnvironment } from './baseEnvironment'
import type { PreviewServerHook } from './preview'
import { arraify, asyncFlatten } from './utils'
import type { StringFilter } from './plugins/pluginFilter'

/**
 * Vite plugins extends the Rollup plugin interface with a few extra
 * vite-specific options. A valid vite plugin is also a valid Rollup plugin.
 * On the contrary, a Rollup plugin may or may NOT be a valid vite universal
 * plugin, since some Rollup features do not make sense in an unbundled
 * dev server context. That said, as long as a rollup plugin doesn't have strong
 * coupling between its bundle phase and output phase hooks then it should
 * just work (that means, most of them).
 *
 * By default, the plugins are run during both serve and build. When a plugin
 * is applied during serve, it will only run **non output plugin hooks** (see
 * rollup type definition of {@link rollup#PluginHooks}). You can think of the
 * dev server as only running `const bundle = rollup.rollup()` but never calling
 * `bundle.generate()`.
 *
 * A plugin that expects to have different behavior depending on serve/build can
 * export a factory function that receives the command being run via options.
 *
 * If a plugin should be applied only for server or build, a function format
 * config file can be used to conditional determine the plugins to use.
 *
 * The current environment can be accessed from the context for the all non-global
 * hooks (it is not available in config, configResolved, configureServer, etc).
 * It can be a dev, build, or scan environment.
 * Plugins can use this.environment.mode === 'dev' to guard for dev specific APIs.
 */

export interface PluginContextExtension {
  /**
   * Vite-specific environment instance
   */
  environment: Environment
}

export interface PluginContextMetaExtension {
  viteVersion: string
}

export interface ConfigPluginContext
  extends Omit<MinimalPluginContext, 'meta' | 'environment'> {
  meta: Omit<PluginContextMeta, 'watchMode'>
}

export interface MinimalPluginContextWithoutEnvironment
  extends Omit<MinimalPluginContext, 'environment'> {}

// Augment Rollup types to have the PluginContextExtension
declare module 'rollup' {
  export interface MinimalPluginContext extends PluginContextExtension {}
  export interface PluginContextMeta extends PluginContextMetaExtension {}
}

/**
 * There are two types of plugins in Vite. App plugins and environment plugins.
 * Environment Plugins are defined by a constructor function that will be called
 * once per each environment allowing users to have completely different plugins
 * for each of them. The constructor gets the resolved environment after the server
 * and builder has already been created simplifying config access and cache
 * management for for environment specific plugins.
 * Environment Plugins are closer to regular rollup plugins. They can't define
 * app level hooks (like config, configResolved, configureServer, etc).
 */
export interface Plugin<A = any> extends RollupPlugin<A> {
  /**
   * Perform custom handling of HMR updates.
   * The handler receives an options containing changed filename, timestamp, a
   * list of modules affected by the file change, and the dev server instance.
   *
   * - The hook can return a filtered list of modules to narrow down the update.
   *   e.g. for a Vue SFC, we can narrow down the part to update by comparing
   *   the descriptors.
   *
   * - The hook can also return an empty array and then perform custom updates
   *   by sending a custom hmr payload via environment.hot.send().
   *
   * - If the hook doesn't return a value, the hmr update will be performed as
   *   normal.
   */
  hotUpdate?: ObjectHook<
    (
      this: MinimalPluginContext & { environment: DevEnvironment },
      options: HotUpdateOptions,
    ) =>
      | Array<EnvironmentModuleNode>
      | void
      | Promise<Array<EnvironmentModuleNode> | void>
  >

  /**
   * extend hooks with ssr flag
   */
  resolveId?: ObjectHook<
    (
      this: PluginContext,
      source: string,
      importer: string | undefined,
      options: {
        attributes: Record<string, string>
        custom?: CustomPluginOptions
        ssr?: boolean
        /**
         * @internal
         */
        scan?: boolean
        isEntry: boolean
      },
    ) => Promise<ResolveIdResult> | ResolveIdResult,
    { filter?: { id?: StringFilter<RegExp> } }
  >
  load?: ObjectHook<
    (
      this: PluginContext,
      id: string,
      options?: {
        ssr?: boolean
      },
    ) => Promise<LoadResult> | LoadResult,
    { filter?: { id?: StringFilter } }
  >
  transform?: ObjectHook<
    (
      this: TransformPluginContext,
      code: string,
      id: string,
      options?: {
        ssr?: boolean
      },
    ) => Promise<TransformResult> | TransformResult,
    { filter?: { id?: StringFilter; code?: StringFilter } }
  >
  /**
   * Opt-in this plugin into the shared plugins pipeline.
   * For backward-compatibility, plugins are re-recreated for each environment
   * during `vite build --app`
   * We have an opt-in per plugin, and a general `builder.sharedPlugins`
   * In a future major, we'll flip the default to be shared by default
   * @experimental
   */
  sharedDuringBuild?: boolean
  /**
   * Opt-in this plugin into per-environment buildStart and buildEnd during dev.
   * For backward-compatibility, the buildStart hook is called only once during
   * dev, for the client environment. Plugins can opt-in to be called
   * per-environment, aligning with the build hook behavior.
   * @experimental
   */
  perEnvironmentStartEndDuringDev?: boolean
  /**
   * Enforce plugin invocation tier similar to webpack loaders. Hooks ordering
   * is still subject to the `order` property in the hook object.
   *
   * Plugin invocation order:
   * - alias resolution
   * - `enforce: 'pre'` plugins
   * - vite core plugins
   * - normal plugins
   * - vite build plugins
   * - `enforce: 'post'` plugins
   * - vite build post plugins
   */
  enforce?: 'pre' | 'post'
  /**
   * Apply the plugin only for serve or build, or on certain conditions.
   */
  apply?:
    | 'serve'
    | 'build'
    | ((this: void, config: UserConfig, env: ConfigEnv) => boolean)
  /**
   * Define environments where this plugin should be active
   * By default, the plugin is active in all environments
   * @experimental
   */
  applyToEnvironment?: (
    environment: PartialEnvironment,
  ) => boolean | Promise<boolean> | PluginOption
  /**
   * Modify vite config before it's resolved. The hook can either mutate the
   * passed-in config directly, or return a partial config object that will be
   * deeply merged into existing config.
   *
   * Note: User plugins are resolved before running this hook so injecting other
   * plugins inside  the `config` hook will have no effect.
   */
  config?: ObjectHook<
    (
      this: ConfigPluginContext,
      config: UserConfig,
      env: ConfigEnv,
    ) =>
      | Omit<UserConfig, 'plugins'>
      | null
      | void
      | Promise<Omit<UserConfig, 'plugins'> | null | void>
  >
  /**
   * Modify environment configs before it's resolved. The hook can either mutate the
   * passed-in environment config directly, or return a partial config object that will be
   * deeply merged into existing config.
   * This hook is called for each environment with a partially resolved environment config
   * that already accounts for the default environment config values set at the root level.
   * If plugins need to modify the config of a given environment, they should do it in this
   * hook instead of the config hook. Leaving the config hook only for modifying the root
   * default environment config.
   */
  configEnvironment?: ObjectHook<
    (
      this: ConfigPluginContext,
      name: string,
      config: EnvironmentOptions,
      env: ConfigEnv & {
        /**
         * Whether this environment is SSR environment and `ssr.target` is set to `'webworker'`.
         * Only intended to be used for backward compatibility.
         */
        isSsrTargetWebworker?: boolean
      },
    ) =>
      | EnvironmentOptions
      | null
      | void
      | Promise<EnvironmentOptions | null | void>
  >
  /**
   * Use this hook to read and store the final resolved vite config.
   */
  configResolved?: ObjectHook<
    (
      this: MinimalPluginContextWithoutEnvironment,
      config: ResolvedConfig,
    ) => void | Promise<void>
  >
  /**
   * Configure the vite server. The hook receives the {@link ViteDevServer}
   * instance. This can also be used to store a reference to the server
   * for use in other hooks.
   *
   * The hooks will be called before internal middlewares are applied. A hook
   * can return a post hook that will be called after internal middlewares
   * are applied. Hook can be async functions and will be called in series.
   */
  configureServer?: ObjectHook<ServerHook>
  /**
   * Configure the preview server. The hook receives the {@link PreviewServer}
   * instance. This can also be used to store a reference to the server
   * for use in other hooks.
   *
   * The hooks are called before other middlewares are applied. A hook can
   * return a post hook that will be called after other middlewares are
   * applied. Hooks can be async functions and will be called in series.
   */
  configurePreviewServer?: ObjectHook<PreviewServerHook>
  /**
   * Transform index.html.
   * The hook receives the following arguments:
   *
   * - html: string
   * - ctx: IndexHtmlTransformContext, which contains:
   *    - path: public path when served
   *    - filename: filename on disk
   *    - server?: ViteDevServer (only present during serve)
   *    - bundle?: rollup.OutputBundle (only present during build)
   *    - chunk?: rollup.OutputChunk
   *    - originalUrl?: string
   *
   * It can either return a transformed string, or a list of html tag
   * descriptors that will be injected into the `<head>` or `<body>`.
   *
   * By default the transform is applied **after** vite's internal html
   * transform. If you need to apply the transform before vite, use an object:
   * `{ order: 'pre', handler: hook }`
   */
  transformIndexHtml?: IndexHtmlTransform
  /**
   * Build Environments
   *
   * @experimental
   */
  buildApp?: ObjectHook<BuildAppHook>
  /**
   * Perform custom handling of HMR updates.
   * The handler receives a context containing changed filename, timestamp, a
   * list of modules affected by the file change, and the dev server instance.
   *
   * - The hook can return a filtered list of modules to narrow down the update.
   *   e.g. for a Vue SFC, we can narrow down the part to update by comparing
   *   the descriptors.
   *
   * - The hook can also return an empty array and then perform custom updates
   *   by sending a custom hmr payload via server.ws.send().
   *
   * - If the hook doesn't return a value, the hmr update will be performed as
   *   normal.
   */
  handleHotUpdate?: ObjectHook<
    (
      this: MinimalPluginContextWithoutEnvironment,
      ctx: HmrContext,
    ) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>
  >
}

export type HookHandler<T> = T extends ObjectHook<infer H> ? H : T

export type PluginWithRequiredHook<K extends keyof Plugin> = Plugin & {
  [P in K]: NonNullable<Plugin[P]>
}

type Thenable<T> = T | Promise<T>

export type FalsyPlugin = false | null | undefined

export type PluginOption = Thenable<Plugin | FalsyPlugin | PluginOption[]>

export async function resolveEnvironmentPlugins(
  environment: PartialEnvironment,
): Promise<Plugin[]> {
  const environmentPlugins: Plugin[] = []
  for (const plugin of environment.getTopLevelConfig().plugins) {
    if (plugin.applyToEnvironment) {
      const applied = await plugin.applyToEnvironment(environment)
      if (!applied) {
        continue
      }
      if (applied !== true) {
        environmentPlugins.push(
          ...((await asyncFlatten(arraify(applied))).filter(
            Boolean,
          ) as Plugin[]),
        )
        continue
      }
    }
    environmentPlugins.push(plugin)
  }
  return environmentPlugins
}

/**
 * @experimental
 */
export function perEnvironmentPlugin(
  name: string,
  applyToEnvironment: (
    environment: PartialEnvironment,
  ) => boolean | Promise<boolean> | PluginOption,
): Plugin {
  return {
    name,
    applyToEnvironment,
  }
}



================================================
FILE: packages/vite/src/node/preview.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import sirv from 'sirv'
import compression from '@polka/compression'
import connect from 'connect'
import type { Connect } from 'dep-types/connect'
import corsMiddleware from 'cors'
import type {
  HttpServer,
  ResolvedServerOptions,
  ResolvedServerUrls,
} from './server'
import { createServerCloseFn } from './server'
import type { CommonServerOptions } from './http'
import {
  httpServerStart,
  resolveHttpServer,
  resolveHttpsConfig,
  setClientErrorHandler,
} from './http'
import { openBrowser } from './server/openBrowser'
import { baseMiddleware } from './server/middlewares/base'
import { htmlFallbackMiddleware } from './server/middlewares/htmlFallback'
import { indexHtmlMiddleware } from './server/middlewares/indexHtml'
import { notFoundMiddleware } from './server/middlewares/notFound'
import { proxyMiddleware } from './server/middlewares/proxy'
import {
  getServerUrlByHost,
  resolveHostname,
  resolveServerUrls,
  setupSIGTERMListener,
  shouldServeFile,
  teardownSIGTERMListener,
} from './utils'
import { printServerUrls } from './logger'
import { bindCLIShortcuts } from './shortcuts'
import type { BindCLIShortcutsOptions } from './shortcuts'
import { resolveConfig } from './config'
import type { InlineConfig, ResolvedConfig } from './config'
import { DEFAULT_PREVIEW_PORT } from './constants'
import type { RequiredExceptFor } from './typeUtils'
import { hostValidationMiddleware } from './server/middlewares/hostCheck'
import {
  BasicMinimalPluginContext,
  basePluginContextMeta,
} from './server/pluginContainer'
import type { MinimalPluginContextWithoutEnvironment } from './plugin'

export interface PreviewOptions extends CommonServerOptions {}

export interface ResolvedPreviewOptions
  extends RequiredExceptFor<PreviewOptions, 'host' | 'https' | 'proxy'> {}

export function resolvePreviewOptions(
  preview: PreviewOptions | undefined,
  server: ResolvedServerOptions,
): ResolvedPreviewOptions {
  // The preview server inherits every CommonServerOption from the `server` config
  // except for the port to enable having both the dev and preview servers running
  // at the same time without extra configuration
  return {
    port: preview?.port ?? DEFAULT_PREVIEW_PORT,
    strictPort: preview?.strictPort ?? server.strictPort,
    host: preview?.host ?? server.host,
    allowedHosts: preview?.allowedHosts ?? server.allowedHosts,
    https: preview?.https ?? server.https,
    open: preview?.open ?? server.open,
    proxy: preview?.proxy ?? server.proxy,
    cors: preview?.cors ?? server.cors,
    headers: preview?.headers ?? server.headers,
  }
}

export interface PreviewServer {
  /**
   * The resolved vite config object
   */
  config: ResolvedConfig
  /**
   * Stop the server.
   */
  close(): Promise<void>
  /**
   * A connect app instance.
   * - Can be used to attach custom middlewares to the preview server.
   * - Can also be used as the handler function of a custom http server
   *   or as a middleware in any connect-style Node.js frameworks
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * native Node http server instance
   */
  httpServer: HttpServer
  /**
   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`
   * if the server is not listening on any port.
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * Print server urls
   */
  printUrls(): void
  /**
   * Bind CLI shortcuts
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void
}

export type PreviewServerHook = (
  this: MinimalPluginContextWithoutEnvironment,
  server: PreviewServer,
) => (() => void) | void | Promise<(() => void) | void>

/**
 * Starts the Vite server in preview mode, to simulate a production deployment
 */
export async function preview(
  inlineConfig: InlineConfig = {},
): Promise<PreviewServer> {
  const config = await resolveConfig(
    inlineConfig,
    'serve',
    'production',
    'production',
    true,
  )

  const clientOutDir = config.environments.client.build.outDir
  const distDir = path.resolve(config.root, clientOutDir)
  if (
    !fs.existsSync(distDir) &&
    // error if no plugins implement `configurePreviewServer`
    config.plugins.every((plugin) => !plugin.configurePreviewServer) &&
    // error if called in CLI only. programmatic usage could access `httpServer`
    // and affect file serving
    process.argv[1]?.endsWith(path.normalize('bin/vite.js')) &&
    process.argv[2] === 'preview'
  ) {
    throw new Error(
      `The directory "${clientOutDir}" does not exist. Did you build your project?`,
    )
  }

  const httpsOptions = await resolveHttpsConfig(config.preview.https)
  const app = connect() as Connect.Server
  const httpServer = await resolveHttpServer(config.preview, app, httpsOptions)
  setClientErrorHandler(httpServer, config.logger)

  const options = config.preview
  const logger = config.logger

  const closeHttpServer = createServerCloseFn(httpServer)

  // Promise used by `server.close()` to ensure `closeServer()` is only called once
  let closeServerPromise: Promise<void> | undefined
  const closeServer = async () => {
    teardownSIGTERMListener(closeServerAndExit)
    await closeHttpServer()
    server.resolvedUrls = null
  }

  const server: PreviewServer = {
    config,
    middlewares: app,
    httpServer,
    async close() {
      if (!closeServerPromise) {
        closeServerPromise = closeServer()
      }
      return closeServerPromise
    },
    resolvedUrls: null,
    printUrls() {
      if (server.resolvedUrls) {
        printServerUrls(server.resolvedUrls, options.host, logger.info)
      } else {
        throw new Error('cannot print server URLs before server is listening.')
      }
    },
    bindCLIShortcuts(options) {
      bindCLIShortcuts(server as PreviewServer, options)
    },
  }

  const closeServerAndExit = async (_: unknown, exitCode?: number) => {
    try {
      await server.close()
    } finally {
      process.exitCode ??= exitCode ? 128 + exitCode : undefined
      process.exit()
    }
  }

  setupSIGTERMListener(closeServerAndExit)

  // cors
  const { cors } = config.preview
  if (cors !== false) {
    app.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))
  }

  // host check (to prevent DNS rebinding attacks)
  const { allowedHosts } = config.preview
  // no need to check for HTTPS as HTTPS is not vulnerable to DNS rebinding attacks
  if (allowedHosts !== true && !config.preview.https) {
    app.use(hostValidationMiddleware(allowedHosts, true))
  }

  // apply server hooks from plugins
  const configurePreviewServerContext = new BasicMinimalPluginContext(
    { ...basePluginContextMeta, watchMode: false },
    config.logger,
  )
  const postHooks: ((() => void) | void)[] = []
  for (const hook of config.getSortedPluginHooks('configurePreviewServer')) {
    postHooks.push(await hook.call(configurePreviewServerContext, server))
  }

  // proxy
  const { proxy } = config.preview
  if (proxy) {
    app.use(proxyMiddleware(httpServer, proxy, config))
  }

  app.use(compression())

  // base
  if (config.base !== '/') {
    app.use(baseMiddleware(config.rawBase, false))
  }

  // static assets
  const headers = config.preview.headers
  const viteAssetMiddleware = (...args: readonly [any, any?, any?]) =>
    sirv(distDir, {
      etag: true,
      dev: true,
      extensions: [],
      ignores: false,
      setHeaders(res) {
        if (headers) {
          for (const name in headers) {
            res.setHeader(name, headers[name]!)
          }
        }
      },
      shouldServe(filePath) {
        return shouldServeFile(filePath, distDir)
      },
    })(...args)

  app.use(viteAssetMiddleware)

  // html fallback
  if (config.appType === 'spa' || config.appType === 'mpa') {
    app.use(htmlFallbackMiddleware(distDir, config.appType === 'spa'))
  }

  // apply post server hooks from plugins
  postHooks.forEach((fn) => fn && fn())

  if (config.appType === 'spa' || config.appType === 'mpa') {
    // transform index.html
    app.use(indexHtmlMiddleware(distDir, server))

    // handle 404s
    app.use(notFoundMiddleware())
  }

  const hostname = await resolveHostname(options.host)

  await httpServerStart(httpServer, {
    port: options.port,
    strictPort: options.strictPort,
    host: hostname.host,
    logger,
  })

  server.resolvedUrls = resolveServerUrls(
    httpServer,
    config.preview,
    hostname,
    httpsOptions,
    config,
  )

  if (options.open) {
    const url = getServerUrlByHost(server.resolvedUrls, options.host)
    if (url) {
      const path =
        typeof options.open === 'string' ? new URL(options.open, url).href : url
      openBrowser(path, true, logger)
    }
  }

  return server as PreviewServer
}



================================================
FILE: packages/vite/src/node/publicDir.ts
================================================
import path from 'node:path'
import { cleanUrl, withTrailingSlash } from '../shared/utils'
import type { ResolvedConfig } from './config'
import {
  ERR_SYMLINK_IN_RECURSIVE_READDIR,
  normalizePath,
  recursiveReaddir,
  tryStatSync,
} from './utils'

const publicFilesMap = new WeakMap<ResolvedConfig, Set<string>>()

export async function initPublicFiles(
  config: ResolvedConfig,
): Promise<Set<string> | undefined> {
  let fileNames: string[]
  try {
    fileNames = await recursiveReaddir(config.publicDir)
  } catch (e) {
    if (e.code === ERR_SYMLINK_IN_RECURSIVE_READDIR) {
      return
    }
    throw e
  }
  const publicFiles = new Set(
    fileNames.map((fileName) => fileName.slice(config.publicDir.length)),
  )
  publicFilesMap.set(config, publicFiles)
  return publicFiles
}

function getPublicFiles(config: ResolvedConfig): Set<string> | undefined {
  return publicFilesMap.get(config)
}

export function checkPublicFile(
  url: string,
  config: ResolvedConfig,
): string | undefined {
  // note if the file is in /public, the resolver would have returned it
  // as-is so it's not going to be a fully resolved path.
  const { publicDir } = config
  if (!publicDir || url[0] !== '/') {
    return
  }

  const fileName = cleanUrl(url)

  // short-circuit if we have an in-memory publicFiles cache
  const publicFiles = getPublicFiles(config)
  if (publicFiles) {
    return publicFiles.has(fileName)
      ? normalizePath(path.join(publicDir, fileName))
      : undefined
  }

  const publicFile = normalizePath(path.join(publicDir, fileName))
  if (!publicFile.startsWith(withTrailingSlash(publicDir))) {
    // can happen if URL starts with '../'
    return
  }

  return tryStatSync(publicFile)?.isFile() ? publicFile : undefined
}



================================================
FILE: packages/vite/src/node/shortcuts.ts
================================================
import readline from 'node:readline'
import colors from 'picocolors'
import { restartServerWithUrls } from './server'
import type { ViteDevServer } from './server'
import { isDevServer } from './utils'
import type { PreviewServer } from './preview'
import { openBrowser } from './server/openBrowser'

export type BindCLIShortcutsOptions<Server = ViteDevServer | PreviewServer> = {
  /**
   * Print a one-line shortcuts "help" hint to the terminal
   */
  print?: boolean
  /**
   * Custom shortcuts to run when a key is pressed. These shortcuts take priority
   * over the default shortcuts if they have the same keys (except the `h` key).
   * To disable a default shortcut, define the same key but with `action: undefined`.
   */
  customShortcuts?: CLIShortcut<Server>[]
}

export type CLIShortcut<Server = ViteDevServer | PreviewServer> = {
  key: string
  description: string
  action?(server: Server): void | Promise<void>
}

export function bindCLIShortcuts<Server extends ViteDevServer | PreviewServer>(
  server: Server,
  opts?: BindCLIShortcutsOptions<Server>,
): void {
  if (!server.httpServer || !process.stdin.isTTY || process.env.CI) {
    return
  }

  const isDev = isDevServer(server)

  if (isDev) {
    server._shortcutsOptions = opts as BindCLIShortcutsOptions<ViteDevServer>
  }

  if (opts?.print) {
    server.config.logger.info(
      colors.dim(colors.green('  ➜')) +
        colors.dim('  press ') +
        colors.bold('h + enter') +
        colors.dim(' to show help'),
    )
  }

  const shortcuts = (opts?.customShortcuts ?? []).concat(
    (isDev
      ? BASE_DEV_SHORTCUTS
      : BASE_PREVIEW_SHORTCUTS) as CLIShortcut<Server>[],
  )

  let actionRunning = false

  const onInput = async (input: string) => {
    if (actionRunning) return

    if (input === 'h') {
      const loggedKeys = new Set<string>()
      server.config.logger.info('\n  Shortcuts')

      for (const shortcut of shortcuts) {
        if (loggedKeys.has(shortcut.key)) continue
        loggedKeys.add(shortcut.key)

        if (shortcut.action == null) continue

        server.config.logger.info(
          colors.dim('  press ') +
            colors.bold(`${shortcut.key} + enter`) +
            colors.dim(` to ${shortcut.description}`),
        )
      }

      return
    }

    const shortcut = shortcuts.find((shortcut) => shortcut.key === input)
    if (!shortcut || shortcut.action == null) return

    actionRunning = true
    await shortcut.action(server)
    actionRunning = false
  }

  const rl = readline.createInterface({ input: process.stdin })
  rl.on('line', onInput)
  server.httpServer.on('close', () => rl.close())
}

const BASE_DEV_SHORTCUTS: CLIShortcut<ViteDevServer>[] = [
  {
    key: 'r',
    description: 'restart the server',
    async action(server) {
      await restartServerWithUrls(server)
    },
  },
  {
    key: 'u',
    description: 'show server url',
    action(server) {
      server.config.logger.info('')
      server.printUrls()
    },
  },
  {
    key: 'o',
    description: 'open in browser',
    action(server) {
      server.openBrowser()
    },
  },
  {
    key: 'c',
    description: 'clear console',
    action(server) {
      server.config.logger.clearScreen('error')
    },
  },
  {
    key: 'q',
    description: 'quit',
    async action(server) {
      try {
        await server.close()
      } finally {
        process.exit()
      }
    },
  },
]

const BASE_PREVIEW_SHORTCUTS: CLIShortcut<PreviewServer>[] = [
  {
    key: 'o',
    description: 'open in browser',
    action(server) {
      const url =
        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]
      if (url) {
        openBrowser(url, true, server.config.logger)
      } else {
        server.config.logger.warn('No URL available to open in browser')
      }
    },
  },
  {
    key: 'q',
    description: 'quit',
    async action(server) {
      try {
        await server.close()
      } finally {
        process.exit()
      }
    },
  },
]



================================================
FILE: packages/vite/src/node/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["**/__tests__"]
}



================================================
FILE: packages/vite/src/node/tsconfig.json
================================================
{
  "extends": "../../tsconfig.base.json",
  "include": ["./", "../module-runner", "../types"],
  "exclude": ["**/fixtures"],
  "compilerOptions": {
    // https://github.com/microsoft/TypeScript/wiki/Node-Target-Mapping#node-20
    "lib": ["ES2023", "DOM"], // DOM because we have client code that gets inlined via function.toString()
    "target": "ES2023",
    "skipLibCheck": true, // lib check is done on final types
    "stripInternal": true,
    "paths": {
      "vite/module-runner": ["../module-runner"]
    }
  }
}



================================================
FILE: packages/vite/src/node/typeUtils.ts
================================================
import type {
  ObjectHook,
  MinimalPluginContext as RollupMinimalPluginContext,
  Plugin as RollupPlugin,
} from 'rollup'

export type NonNeverKeys<T> = {
  [K in keyof T]: T[K] extends never ? never : K
}[keyof T]

export type GetHookContextMap<Plugin> = {
  [K in keyof Plugin]-?: Plugin[K] extends ObjectHook<infer T, unknown>
    ? T extends (this: infer This, ...args: any[]) => any
      ? This extends RollupMinimalPluginContext
        ? This
        : never
      : never
    : never
}

type RollupPluginHooksContext = GetHookContextMap<RollupPlugin>
export type RollupPluginHooks = NonNeverKeys<RollupPluginHooksContext>

export type RequiredExceptFor<T, K extends keyof T> = Pick<T, K> &
  Required<Omit<T, K>>



================================================
FILE: packages/vite/src/node/utils.ts
================================================
import fs from 'node:fs'
import os from 'node:os'
import net from 'node:net'
import path from 'node:path'
import { exec } from 'node:child_process'
import crypto from 'node:crypto'
import { fileURLToPath } from 'node:url'
import type { ServerOptions as HttpsServerOptions } from 'node:https'
import { builtinModules, createRequire } from 'node:module'
import { promises as dns } from 'node:dns'
import { performance } from 'node:perf_hooks'
import type { AddressInfo, Server } from 'node:net'
import fsp from 'node:fs/promises'
import type { FSWatcher } from 'dep-types/chokidar'
import remapping from '@jridgewell/remapping'
import type { DecodedSourceMap, RawSourceMap } from '@jridgewell/remapping'
import colors from 'picocolors'
import debug from 'debug'
import type { Alias, AliasOptions } from 'dep-types/alias'
import type MagicString from 'magic-string'
import type { Equal } from '@type-challenges/utils'

import type { TransformResult } from 'rollup'
import { createFilter as _createFilter } from '@rollup/pluginutils'
import {
  cleanUrl,
  isWindows,
  slash,
  splitFileAndPostfix,
  withTrailingSlash,
} from '../shared/utils'
import { VALID_ID_PREFIX } from '../shared/constants'
import {
  CLIENT_ENTRY,
  CLIENT_PUBLIC_PATH,
  CSS_LANGS_RE,
  ENV_PUBLIC_PATH,
  FS_PREFIX,
  OPTIMIZABLE_ENTRY_RE,
  loopbackHosts,
  wildcardHosts,
} from './constants'
import type { DepOptimizationOptions } from './optimizer'
import type { ResolvedConfig } from './config'
import type { ResolvedServerUrls, ViteDevServer } from './server'
import type { PreviewServer } from './preview'
import {
  type PackageCache,
  findNearestPackageData,
  resolvePackageData,
} from './packages'
import type { CommonServerOptions } from '.'

/**
 * Inlined to keep `@rollup/pluginutils` in devDependencies
 */
export type FilterPattern =
  | ReadonlyArray<string | RegExp>
  | string
  | RegExp
  | null
export const createFilter = _createFilter as (
  include?: FilterPattern,
  exclude?: FilterPattern,
  options?: { resolve?: string | false | null },
) => (id: string | unknown) => boolean

const replaceSlashOrColonRE = /[/:]/g
const replaceDotRE = /\./g
const replaceNestedIdRE = /\s*>\s*/g
const replaceHashRE = /#/g
export const flattenId = (id: string): string => {
  const flatId = limitFlattenIdLength(
    id
      .replace(replaceSlashOrColonRE, '_')
      .replace(replaceDotRE, '__')
      .replace(replaceNestedIdRE, '___')
      .replace(replaceHashRE, '____'),
  )
  return flatId
}

const FLATTEN_ID_HASH_LENGTH = 8
const FLATTEN_ID_MAX_FILE_LENGTH = 170

const limitFlattenIdLength = (
  id: string,
  limit: number = FLATTEN_ID_MAX_FILE_LENGTH,
): string => {
  if (id.length <= limit) {
    return id
  }
  return id.slice(0, limit - (FLATTEN_ID_HASH_LENGTH + 1)) + '_' + getHash(id)
}

export const normalizeId = (id: string): string =>
  id.replace(replaceNestedIdRE, ' > ')

// Supported by Node, Deno, Bun
const NODE_BUILTIN_NAMESPACE = 'node:'
// Supported by Bun
const BUN_BUILTIN_NAMESPACE = 'bun:'
// Some runtimes like Bun injects namespaced modules here, which is not a node builtin
const nodeBuiltins = builtinModules.filter((id) => !id.includes(':'))

const isBuiltinCache = new WeakMap<
  (string | RegExp)[],
  (id: string, importer?: string) => boolean
>()

export function isBuiltin(builtins: (string | RegExp)[], id: string): boolean {
  let isBuiltin = isBuiltinCache.get(builtins)
  if (!isBuiltin) {
    isBuiltin = createIsBuiltin(builtins)
    isBuiltinCache.set(builtins, isBuiltin)
  }
  return isBuiltin(id)
}

export function createIsBuiltin(
  builtins: (string | RegExp)[],
): (id: string) => boolean {
  const plainBuiltinsSet = new Set(
    builtins.filter((builtin) => typeof builtin === 'string'),
  )
  const regexBuiltins = builtins.filter(
    (builtin) => typeof builtin !== 'string',
  )

  return (id) =>
    plainBuiltinsSet.has(id) || regexBuiltins.some((regexp) => regexp.test(id))
}

export const nodeLikeBuiltins = [
  ...nodeBuiltins,
  new RegExp(`^${NODE_BUILTIN_NAMESPACE}`),
  new RegExp(`^${BUN_BUILTIN_NAMESPACE}`),
]

export function isNodeLikeBuiltin(id: string): boolean {
  return isBuiltin(nodeLikeBuiltins, id)
}

export function isNodeBuiltin(id: string): boolean {
  if (id.startsWith(NODE_BUILTIN_NAMESPACE)) return true
  return nodeBuiltins.includes(id)
}

export function isInNodeModules(id: string): boolean {
  return id.includes('node_modules')
}

export function moduleListContains(
  moduleList: string[] | undefined,
  id: string,
): boolean | undefined {
  return moduleList?.some(
    (m) => m === id || id.startsWith(withTrailingSlash(m)),
  )
}

export function isOptimizable(
  id: string,
  optimizeDeps: DepOptimizationOptions,
): boolean {
  const { extensions } = optimizeDeps
  return (
    OPTIMIZABLE_ENTRY_RE.test(id) ||
    (extensions?.some((ext) => id.endsWith(ext)) ?? false)
  )
}

export const bareImportRE = /^(?![a-zA-Z]:)[\w@](?!.*:\/\/)/
export const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//

// TODO: use import()
const _require = createRequire(/** #__KEEP__ */ import.meta.url)

const _dirname = path.dirname(fileURLToPath(/** #__KEEP__ */ import.meta.url))

// NOTE: we don't use VERSION variable exported from rollup to avoid importing rollup in dev
export const rollupVersion =
  resolvePackageData('rollup', _dirname, true)?.data.version ?? ''

// set in bin/vite.js
const filter = process.env.VITE_DEBUG_FILTER

const DEBUG = process.env.DEBUG

interface DebuggerOptions {
  onlyWhenFocused?: boolean | string
  depth?: number
}

export type ViteDebugScope = `vite:${string}`

export function createDebugger(
  namespace: ViteDebugScope,
  options: DebuggerOptions = {},
): debug.Debugger['log'] | undefined {
  const log = debug(namespace)
  const { onlyWhenFocused, depth } = options

  // @ts-expect-error - The log function is bound to inspectOpts, but the type is not reflected
  if (depth && log.inspectOpts && log.inspectOpts.depth == null) {
    // @ts-expect-error - The log function is bound to inspectOpts, but the type is not reflected
    log.inspectOpts.depth = options.depth
  }

  let enabled = log.enabled
  if (enabled && onlyWhenFocused) {
    const ns = typeof onlyWhenFocused === 'string' ? onlyWhenFocused : namespace
    enabled = !!DEBUG?.includes(ns)
  }

  if (enabled) {
    return (...args: [string, ...any[]]) => {
      if (!filter || args.some((a) => a?.includes?.(filter))) {
        log(...args)
      }
    }
  }
}

function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith('client.mjs')) {
    throw new Error(
      `cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`,
    )
  }
  if (!fs.existsSync(CLIENT_ENTRY)) {
    throw new Error(
      'cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: ' +
        CLIENT_ENTRY,
    )
  }
  return fs.existsSync(CLIENT_ENTRY.replace('client.mjs', 'cLiEnT.mjs'))
}

export const isCaseInsensitiveFS = testCaseInsensitiveFS()

const VOLUME_RE = /^[A-Z]:/i

export function normalizePath(id: string): string {
  return path.posix.normalize(isWindows ? slash(id) : id)
}

export function fsPathFromId(id: string): string {
  const fsPath = normalizePath(
    id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id,
  )
  return fsPath[0] === '/' || VOLUME_RE.test(fsPath) ? fsPath : `/${fsPath}`
}

export function fsPathFromUrl(url: string): string {
  return fsPathFromId(cleanUrl(url))
}

/**
 * Check if dir is a parent of file
 *
 * Warning: parameters are not validated, only works with normalized absolute paths
 *
 * @param dir - normalized absolute path
 * @param file - normalized absolute path
 * @returns true if dir is a parent of file
 */
export function isParentDirectory(dir: string, file: string): boolean {
  dir = withTrailingSlash(dir)
  return (
    file.startsWith(dir) ||
    (isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase()))
  )
}

/**
 * Check if 2 file name are identical
 *
 * Warning: parameters are not validated, only works with normalized absolute paths
 *
 * @param file1 - normalized absolute path
 * @param file2 - normalized absolute path
 * @returns true if both files url are identical
 */
export function isSameFilePath(file1: string, file2: string): boolean {
  return (
    file1 === file2 ||
    (isCaseInsensitiveFS && file1.toLowerCase() === file2.toLowerCase())
  )
}

export const externalRE = /^([a-z]+:)?\/\//
export const isExternalUrl = (url: string): boolean => externalRE.test(url)

export const dataUrlRE = /^\s*data:/i
export const isDataUrl = (url: string): boolean => dataUrlRE.test(url)

export const virtualModuleRE = /^virtual-module:.*/
export const virtualModulePrefix = 'virtual-module:'

// NOTE: We should start relying on the "Sec-Fetch-Dest" header instead of this
// hardcoded list. We can eventually remove this function when the minimum version
// of browsers we support in dev all support this header.
const knownJsSrcRE =
  /\.(?:[jt]sx?|m[jt]s|vue|marko|svelte|astro|imba|mdx)(?:$|\?)/
export const isJSRequest = (url: string): boolean => {
  url = cleanUrl(url)
  if (knownJsSrcRE.test(url)) {
    return true
  }
  if (!path.extname(url) && url[url.length - 1] !== '/') {
    return true
  }
  return false
}

export const isCSSRequest = (request: string): boolean =>
  CSS_LANGS_RE.test(request)

const importQueryRE = /(\?|&)import=?(?:&|$)/
const directRequestRE = /(\?|&)direct=?(?:&|$)/
const internalPrefixes = [
  FS_PREFIX,
  VALID_ID_PREFIX,
  CLIENT_PUBLIC_PATH,
  ENV_PUBLIC_PATH,
]
const InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join('|')})`)
const trailingSeparatorRE = /[?&]$/
export const isImportRequest = (url: string): boolean => importQueryRE.test(url)
export const isInternalRequest = (url: string): boolean =>
  InternalPrefixRE.test(url)

export function removeImportQuery(url: string): string {
  return url.replace(importQueryRE, '$1').replace(trailingSeparatorRE, '')
}
export function removeDirectQuery(url: string): string {
  return url.replace(directRequestRE, '$1').replace(trailingSeparatorRE, '')
}

export const urlRE = /(\?|&)url(?:&|$)/
export const rawRE = /(\?|&)raw(?:&|$)/
export function removeUrlQuery(url: string): string {
  return url.replace(urlRE, '$1').replace(trailingSeparatorRE, '')
}
export function removeRawQuery(url: string): string {
  return url.replace(rawRE, '$1').replace(trailingSeparatorRE, '')
}

export function injectQuery(url: string, queryToInject: string): string {
  const { file, postfix } = splitFileAndPostfix(url)
  const normalizedFile = isWindows ? slash(file) : file
  return `${normalizedFile}?${queryToInject}${postfix[0] === '?' ? `&${postfix.slice(1)}` : /* hash only */ postfix}`
}

const timestampRE = /\bt=\d{13}&?\b/
export function removeTimestampQuery(url: string): string {
  return url.replace(timestampRE, '').replace(trailingSeparatorRE, '')
}

export async function asyncReplace(
  input: string,
  re: RegExp,
  replacer: (match: RegExpExecArray) => string | Promise<string>,
): Promise<string> {
  let match: RegExpExecArray | null
  let remaining = input
  let rewritten = ''
  while ((match = re.exec(remaining))) {
    rewritten += remaining.slice(0, match.index)
    rewritten += await replacer(match)
    remaining = remaining.slice(match.index + match[0].length)
  }
  rewritten += remaining
  return rewritten
}

export function timeFrom(start: number, subtract = 0): string {
  const time: number | string = performance.now() - start - subtract
  const timeString = (time.toFixed(2) + `ms`).padEnd(5, ' ')
  if (time < 10) {
    return colors.green(timeString)
  } else if (time < 50) {
    return colors.yellow(timeString)
  } else {
    return colors.red(timeString)
  }
}

/**
 * pretty url for logging.
 */
export function prettifyUrl(url: string, root: string): string {
  url = removeTimestampQuery(url)
  const isAbsoluteFile = url.startsWith(root)
  if (isAbsoluteFile || url.startsWith(FS_PREFIX)) {
    const file = path.posix.relative(
      root,
      isAbsoluteFile ? url : fsPathFromId(url),
    )
    return colors.dim(file)
  } else {
    return colors.dim(url)
  }
}

export function isObject(value: unknown): value is Record<string, any> {
  return Object.prototype.toString.call(value) === '[object Object]'
}

export function isDefined<T>(value: T | undefined | null): value is T {
  return value != null
}

export function tryStatSync(file: string): fs.Stats | undefined {
  try {
    // The "throwIfNoEntry" is a performance optimization for cases where the file does not exist
    return fs.statSync(file, { throwIfNoEntry: false })
  } catch {
    // Ignore errors
  }
}

export function lookupFile(
  dir: string,
  fileNames: string[],
): string | undefined {
  while (dir) {
    for (const fileName of fileNames) {
      const fullPath = path.join(dir, fileName)
      if (tryStatSync(fullPath)?.isFile()) return fullPath
    }
    const parentDir = path.dirname(dir)
    if (parentDir === dir) return

    dir = parentDir
  }
}

export function isFilePathESM(
  filePath: string,
  packageCache?: PackageCache,
): boolean {
  if (/\.m[jt]s$/.test(filePath)) {
    return true
  } else if (/\.c[jt]s$/.test(filePath)) {
    return false
  } else {
    // check package.json for type: "module"
    try {
      const pkg = findNearestPackageData(path.dirname(filePath), packageCache)
      return pkg?.data.type === 'module'
    } catch {
      return false
    }
  }
}

export const splitRE = /\r?\n/g

const range: number = 2

export function pad(source: string, n = 2): string {
  const lines = source.split(splitRE)
  return lines.map((l) => ` `.repeat(n) + l).join(`\n`)
}

type Pos = {
  /** 1-based */
  line: number
  /** 0-based */
  column: number
}

export function posToNumber(source: string, pos: number | Pos): number {
  if (typeof pos === 'number') return pos
  const lines = source.split(splitRE)
  const { line, column } = pos
  let start = 0
  for (let i = 0; i < line - 1 && i < lines.length; i++) {
    start += lines[i].length + 1
  }
  return start + column
}

export function numberToPos(source: string, offset: number | Pos): Pos {
  if (typeof offset !== 'number') return offset
  if (offset > source.length) {
    throw new Error(
      `offset is longer than source length! offset ${offset} > length ${source.length}`,
    )
  }

  const lines = source.slice(0, offset).split(splitRE)
  return {
    line: lines.length,
    column: lines[lines.length - 1].length,
  }
}

export function generateCodeFrame(
  source: string,
  start: number | Pos = 0,
  end?: number | Pos,
): string {
  start = Math.max(posToNumber(source, start), 0)
  end = Math.min(
    end !== undefined ? posToNumber(source, end) : start,
    source.length,
  )
  const lastPosLine =
    end !== undefined
      ? numberToPos(source, end).line
      : numberToPos(source, start).line + range
  const lineNumberWidth = Math.max(3, String(lastPosLine).length + 1)
  const lines = source.split(splitRE)
  let count = 0
  const res: string[] = []
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue
        const line = j + 1
        res.push(
          `${line}${' '.repeat(lineNumberWidth - String(line).length)}|  ${
            lines[j]
          }`,
        )
        const lineLength = lines[j].length
        if (j === i) {
          // push underline
          const pad = Math.max(start - (count - lineLength), 0)
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start,
          )
          res.push(
            `${' '.repeat(lineNumberWidth)}|  ` +
              ' '.repeat(pad) +
              '^'.repeat(length),
          )
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1)
            res.push(`${' '.repeat(lineNumberWidth)}|  ` + '^'.repeat(length))
          }
          count += lineLength + 1
        }
      }
      break
    }
    count++
  }
  return res.join('\n')
}

export function isFileReadable(filename: string): boolean {
  if (!tryStatSync(filename)) {
    return false
  }

  try {
    // Check if current process has read permission to the file
    fs.accessSync(filename, fs.constants.R_OK)

    return true
  } catch {
    return false
  }
}

const splitFirstDirRE = /(.+?)[\\/](.+)/

/**
 * Delete every file and subdirectory. **The given directory must exist.**
 * Pass an optional `skip` array to preserve files under the root directory.
 */
export function emptyDir(dir: string, skip?: string[]): void {
  const skipInDir: string[] = []
  let nested: Map<string, string[]> | null = null
  if (skip?.length) {
    for (const file of skip) {
      if (path.dirname(file) !== '.') {
        const matched = splitFirstDirRE.exec(file)
        if (matched) {
          nested ??= new Map()
          const [, nestedDir, skipPath] = matched
          let nestedSkip = nested.get(nestedDir)
          if (!nestedSkip) {
            nestedSkip = []
            nested.set(nestedDir, nestedSkip)
          }
          if (!nestedSkip.includes(skipPath)) {
            nestedSkip.push(skipPath)
          }
        }
      } else {
        skipInDir.push(file)
      }
    }
  }
  for (const file of fs.readdirSync(dir)) {
    if (skipInDir.includes(file)) {
      continue
    }
    if (nested?.has(file)) {
      emptyDir(path.resolve(dir, file), nested.get(file))
    } else {
      fs.rmSync(path.resolve(dir, file), { recursive: true, force: true })
    }
  }
}

export function copyDir(srcDir: string, destDir: string): void {
  fs.mkdirSync(destDir, { recursive: true })
  for (const file of fs.readdirSync(srcDir)) {
    const srcFile = path.resolve(srcDir, file)
    if (srcFile === destDir) {
      continue
    }
    const destFile = path.resolve(destDir, file)
    const stat = fs.statSync(srcFile)
    if (stat.isDirectory()) {
      copyDir(srcFile, destFile)
    } else {
      fs.copyFileSync(srcFile, destFile)
    }
  }
}

export const ERR_SYMLINK_IN_RECURSIVE_READDIR =
  'ERR_SYMLINK_IN_RECURSIVE_READDIR'
export async function recursiveReaddir(dir: string): Promise<string[]> {
  if (!fs.existsSync(dir)) {
    return []
  }
  let dirents: fs.Dirent[]
  try {
    dirents = await fsp.readdir(dir, { withFileTypes: true })
  } catch (e) {
    if (e.code === 'EACCES') {
      // Ignore permission errors
      return []
    }
    throw e
  }
  if (dirents.some((dirent) => dirent.isSymbolicLink())) {
    const err: any = new Error(
      'Symbolic links are not supported in recursiveReaddir',
    )
    err.code = ERR_SYMLINK_IN_RECURSIVE_READDIR
    throw err
  }
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path.resolve(dir, dirent.name)
      return dirent.isDirectory() ? recursiveReaddir(res) : normalizePath(res)
    }),
  )
  return files.flat(1)
}

// `fs.realpathSync.native` resolves differently in Windows network drive,
// causing file read errors. skip for now.
// https://github.com/nodejs/node/issues/37737
export let safeRealpathSync = isWindows
  ? windowsSafeRealPathSync
  : fs.realpathSync.native

// Based on https://github.com/larrybahr/windows-network-drive
// MIT License, Copyright (c) 2017 Larry Bahr
const windowsNetworkMap = new Map()
function windowsMappedRealpathSync(path: string) {
  const realPath = fs.realpathSync.native(path)
  if (realPath.startsWith('\\\\')) {
    for (const [network, volume] of windowsNetworkMap) {
      if (realPath.startsWith(network)) return realPath.replace(network, volume)
    }
  }
  return realPath
}
const parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/
let firstSafeRealPathSyncRun = false

function windowsSafeRealPathSync(path: string): string {
  if (!firstSafeRealPathSyncRun) {
    optimizeSafeRealPathSync()
    firstSafeRealPathSyncRun = true
  }
  return fs.realpathSync(path)
}

function optimizeSafeRealPathSync() {
  // Check the availability `fs.realpathSync.native`
  // in Windows virtual and RAM disks that bypass the Volume Mount Manager, in programs such as imDisk
  // get the error EISDIR: illegal operation on a directory
  try {
    fs.realpathSync.native(path.resolve('./'))
  } catch (error) {
    if (error.message.includes('EISDIR: illegal operation on a directory')) {
      safeRealpathSync = fs.realpathSync
      return
    }
  }
  exec('net use', (error, stdout) => {
    if (error) return
    const lines = stdout.split('\n')
    // OK           Y:        \\NETWORKA\Foo         Microsoft Windows Network
    // OK           Z:        \\NETWORKA\Bar         Microsoft Windows Network
    for (const line of lines) {
      const m = parseNetUseRE.exec(line)
      if (m) windowsNetworkMap.set(m[2], m[1])
    }
    if (windowsNetworkMap.size === 0) {
      safeRealpathSync = fs.realpathSync.native
    } else {
      safeRealpathSync = windowsMappedRealpathSync
    }
  })
}

export function ensureWatchedFile(
  watcher: FSWatcher,
  file: string | null,
  root: string,
): void {
  if (
    file &&
    // only need to watch if out of root
    !file.startsWith(withTrailingSlash(root)) &&
    // some rollup plugins use null bytes for private resolved Ids
    !file.includes('\0') &&
    fs.existsSync(file)
  ) {
    // resolve file to normalized system path
    watcher.add(path.resolve(file))
  }
}

interface ImageCandidate {
  url: string
  descriptor: string
}

function joinSrcset(ret: ImageCandidate[]) {
  return ret
    .map(({ url, descriptor }) => url + (descriptor ? ` ${descriptor}` : ''))
    .join(', ')
}

/**
 This regex represents a loose rule of an “image candidate string” and "image set options".

 @see https://html.spec.whatwg.org/multipage/images.html#srcset-attribute
 @see https://drafts.csswg.org/css-images-4/#image-set-notation

  The Regex has named capturing groups `url` and `descriptor`.
  The `url` group can be:
  * any CSS function
  * CSS string (single or double-quoted)
  * URL string (unquoted)
  The `descriptor` is anything after the space and before the comma.
 */
const imageCandidateRegex =
  /(?:^|\s|(?<=,))(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g
const escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g

export function parseSrcset(string: string): ImageCandidate[] {
  const matches = string
    .trim()
    .replace(escapedSpaceCharacters, ' ')
    .replace(/\r?\n/, '')
    .replace(/,\s+/, ', ')
    .replaceAll(/\s+/g, ' ')
    .matchAll(imageCandidateRegex)
  return Array.from(matches, ({ groups }) => ({
    url: groups?.url?.trim() ?? '',
    descriptor: groups?.descriptor?.trim() ?? '',
  })).filter(({ url }) => !!url)
}

export function processSrcSet(
  srcs: string,
  replacer: (arg: ImageCandidate) => Promise<string>,
): Promise<string> {
  return Promise.all(
    parseSrcset(srcs).map(async ({ url, descriptor }) => ({
      url: await replacer({ url, descriptor }),
      descriptor,
    })),
  ).then(joinSrcset)
}

export function processSrcSetSync(
  srcs: string,
  replacer: (arg: ImageCandidate) => string,
): string {
  return joinSrcset(
    parseSrcset(srcs).map(({ url, descriptor }) => ({
      url: replacer({ url, descriptor }),
      descriptor,
    })),
  )
}

const windowsDriveRE = /^[A-Z]:/
const replaceWindowsDriveRE = /^([A-Z]):\//
const linuxAbsolutePathRE = /^\/[^/]/
function escapeToLinuxLikePath(path: string) {
  if (windowsDriveRE.test(path)) {
    return path.replace(replaceWindowsDriveRE, '/windows/$1/')
  }
  if (linuxAbsolutePathRE.test(path)) {
    return `/linux${path}`
  }
  return path
}

const revertWindowsDriveRE = /^\/windows\/([A-Z])\//
function unescapeToLinuxLikePath(path: string) {
  if (path.startsWith('/linux/')) {
    return path.slice('/linux'.length)
  }
  if (path.startsWith('/windows/')) {
    return path.replace(revertWindowsDriveRE, '$1:/')
  }
  return path
}

// based on https://github.com/sveltejs/svelte/blob/abf11bb02b2afbd3e4cac509a0f70e318c306364/src/compiler/utils/mapped_code.ts#L221
const nullSourceMap: RawSourceMap = {
  names: [],
  sources: [],
  mappings: '',
  version: 3,
}
/**
 * Combines multiple sourcemaps into a single sourcemap.
 * Note that the length of sourcemapList must be 2.
 */
export function combineSourcemaps(
  filename: string,
  sourcemapList: Array<DecodedSourceMap | RawSourceMap>,
): RawSourceMap {
  if (
    sourcemapList.length === 0 ||
    sourcemapList.every((m) => m.sources.length === 0)
  ) {
    return { ...nullSourceMap }
  }

  // hack for parse broken with normalized absolute paths on windows (C:/path/to/something).
  // escape them to linux like paths
  // also avoid mutation here to prevent breaking plugin's using cache to generate sourcemaps like vue (see #7442)
  sourcemapList = sourcemapList.map((sourcemap) => {
    const newSourcemaps = { ...sourcemap }
    newSourcemaps.sources = sourcemap.sources.map((source) =>
      source ? escapeToLinuxLikePath(source) : null,
    )
    if (sourcemap.sourceRoot) {
      newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot)
    }
    return newSourcemaps
  })
  const escapedFilename = escapeToLinuxLikePath(filename)

  // We don't declare type here so we can convert/fake/map as RawSourceMap
  let map //: SourceMap
  let mapIndex = 1
  const useArrayInterface =
    sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === undefined
  if (useArrayInterface) {
    map = remapping(sourcemapList, () => null)
  } else {
    map = remapping(sourcemapList[0], function loader(sourcefile) {
      // this line assumes that the length of the sourcemapList is 2
      if (sourcefile === escapedFilename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++]
      } else {
        return null
      }
    })
  }
  if (!map.file) {
    delete map.file
  }

  // unescape the previous hack
  map.sources = map.sources.map((source) =>
    source ? unescapeToLinuxLikePath(source) : source,
  )
  map.file = filename

  return map as RawSourceMap
}

export function unique<T>(arr: T[]): T[] {
  return Array.from(new Set(arr))
}

/**
 * Returns resolved localhost address when `dns.lookup` result differs from DNS
 *
 * `dns.lookup` result is same when defaultResultOrder is `verbatim`.
 * Even if defaultResultOrder is `ipv4first`, `dns.lookup` result maybe same.
 * For example, when IPv6 is not supported on that machine/network.
 */
export async function getLocalhostAddressIfDiffersFromDNS(): Promise<
  string | undefined
> {
  const [nodeResult, dnsResult] = await Promise.all([
    dns.lookup('localhost'),
    dns.lookup('localhost', { verbatim: true }),
  ])
  const isSame =
    nodeResult.family === dnsResult.family &&
    nodeResult.address === dnsResult.address
  return isSame ? undefined : nodeResult.address
}

export function diffDnsOrderChange(
  oldUrls: ViteDevServer['resolvedUrls'],
  newUrls: ViteDevServer['resolvedUrls'],
): boolean {
  return !(
    oldUrls === newUrls ||
    (oldUrls &&
      newUrls &&
      arrayEqual(oldUrls.local, newUrls.local) &&
      arrayEqual(oldUrls.network, newUrls.network))
  )
}

export interface Hostname {
  /** undefined sets the default behaviour of server.listen */
  host: string | undefined
  /** resolve to localhost when possible */
  name: string
}

export async function resolveHostname(
  optionsHost: string | boolean | undefined,
): Promise<Hostname> {
  let host: string | undefined
  if (optionsHost === undefined || optionsHost === false) {
    // Use a secure default
    host = 'localhost'
  } else if (optionsHost === true) {
    // If passed --host in the CLI without arguments
    host = undefined // undefined typically means 0.0.0.0 or :: (listen on all IPs)
  } else {
    host = optionsHost
  }

  // Set host name to localhost when possible
  let name = host === undefined || wildcardHosts.has(host) ? 'localhost' : host

  if (host === 'localhost') {
    // See #8647 for more details.
    const localhostAddr = await getLocalhostAddressIfDiffersFromDNS()
    if (localhostAddr) {
      name = localhostAddr
    }
  }

  return { host, name }
}

export function resolveServerUrls(
  server: Server,
  options: CommonServerOptions,
  hostname: Hostname,
  httpsOptions: HttpsServerOptions | undefined,
  config: ResolvedConfig,
): ResolvedServerUrls {
  const address = server.address()

  const isAddressInfo = (x: any): x is AddressInfo => x?.address
  if (!isAddressInfo(address)) {
    return { local: [], network: [] }
  }

  const local: string[] = []
  const network: string[] = []
  const protocol = options.https ? 'https' : 'http'
  const port = address.port
  const base =
    config.rawBase === './' || config.rawBase === '' ? '/' : config.rawBase

  if (hostname.host !== undefined && !wildcardHosts.has(hostname.host)) {
    let hostnameName = hostname.name
    // ipv6 host
    if (hostnameName.includes(':')) {
      hostnameName = `[${hostnameName}]`
    }
    const address = `${protocol}://${hostnameName}:${port}${base}`
    if (loopbackHosts.has(hostname.host)) {
      local.push(address)
    } else {
      network.push(address)
    }
  } else {
    Object.values(os.networkInterfaces())
      .flatMap((nInterface) => nInterface ?? [])
      .filter((detail) => detail.address && detail.family === 'IPv4')
      .forEach((detail) => {
        let host = detail.address.replace('127.0.0.1', hostname.name)
        // ipv6 host
        if (host.includes(':')) {
          host = `[${host}]`
        }
        const url = `${protocol}://${host}:${port}${base}`
        if (detail.address.includes('127.0.0.1')) {
          local.push(url)
        } else {
          network.push(url)
        }
      })
  }

  const cert =
    httpsOptions?.cert && !Array.isArray(httpsOptions.cert)
      ? new crypto.X509Certificate(httpsOptions.cert)
      : undefined
  const hostnameFromCert = cert?.subjectAltName
    ? extractHostnamesFromSubjectAltName(cert.subjectAltName)
    : []

  if (hostnameFromCert.length > 0) {
    const existings = new Set([...local, ...network])
    local.push(
      ...hostnameFromCert
        .map((hostname) => `https://${hostname}:${port}${base}`)
        .filter((url) => !existings.has(url)),
    )
  }

  return { local, network }
}

export function extractHostnamesFromSubjectAltName(
  subjectAltName: string,
): string[] {
  const hostnames: string[] = []
  let remaining = subjectAltName
  while (remaining) {
    const nameEndIndex = remaining.indexOf(':')
    const name = remaining.slice(0, nameEndIndex)
    remaining = remaining.slice(nameEndIndex + 1)
    if (!remaining) break

    const isQuoted = remaining[0] === '"'
    let value: string
    if (isQuoted) {
      const endQuoteIndex = remaining.indexOf('"', 1)
      value = JSON.parse(remaining.slice(0, endQuoteIndex + 1))
      remaining = remaining.slice(endQuoteIndex + 1)
    } else {
      const maybeEndIndex = remaining.indexOf(',')
      const endIndex = maybeEndIndex === -1 ? remaining.length : maybeEndIndex
      value = remaining.slice(0, endIndex)
      remaining = remaining.slice(endIndex)
    }
    remaining = remaining.slice(/* for , */ 1).trimStart()

    if (
      name === 'DNS' &&
      // [::1] might be included but skip it as it's already included as a local address
      value !== '[::1]' &&
      // skip *.IPv4 addresses, which is invalid
      !(value.startsWith('*.') && net.isIPv4(value.slice(2)))
    ) {
      hostnames.push(value.replace('*', 'vite'))
    }
  }
  return hostnames
}

export function arraify<T>(target: T | T[]): T[] {
  return Array.isArray(target) ? target : [target]
}

// Taken from https://stackoverflow.com/a/36328890
export const multilineCommentsRE = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g
export const singlelineCommentsRE = /\/\/.*/g
export const requestQuerySplitRE = /\?(?!.*[/|}])/
export const requestQueryMaybeEscapedSplitRE = /\\?\?(?!.*[/|}])/

export const blankReplacer = (match: string): string => ' '.repeat(match.length)

export function getHash(text: Buffer | string, length = 8): string {
  const h = crypto.hash('sha256', text, 'hex').substring(0, length)
  if (length <= 64) return h
  return h.padEnd(length, '_')
}

export const requireResolveFromRootWithFallback = (
  root: string,
  id: string,
): string => {
  // check existence first, so if the package is not found,
  // it won't be cached by nodejs, since there isn't a way to invalidate them:
  // https://github.com/nodejs/node/issues/44663
  const found = resolvePackageData(id, root) || resolvePackageData(id, _dirname)
  if (!found) {
    const error = new Error(`${JSON.stringify(id)} not found.`)
    ;(error as any).code = 'MODULE_NOT_FOUND'
    throw error
  }

  // actually resolve
  // Search in the root directory first, and fallback to the default require paths.
  return _require.resolve(id, { paths: [root, _dirname] })
}

export function emptyCssComments(raw: string): string {
  return raw.replace(multilineCommentsRE, blankReplacer)
}

function backwardCompatibleWorkerPlugins(plugins: any) {
  if (Array.isArray(plugins)) {
    return plugins
  }
  if (typeof plugins === 'function') {
    return plugins()
  }
  return []
}

type DeepWritable<T> =
  T extends ReadonlyArray<unknown>
    ? { -readonly [P in keyof T]: DeepWritable<T[P]> }
    : T extends RegExp
      ? RegExp
      : T[keyof T] extends Function
        ? T
        : { -readonly [P in keyof T]: DeepWritable<T[P]> }

function deepClone<T>(value: T): DeepWritable<T> {
  if (Array.isArray(value)) {
    return value.map((v) => deepClone(v)) as DeepWritable<T>
  }
  if (isObject(value)) {
    const cloned: Record<string, any> = {}
    for (const key in value) {
      cloned[key] = deepClone(value[key])
    }
    return cloned as DeepWritable<T>
  }
  if (typeof value === 'function') {
    return value as DeepWritable<T>
  }
  if (value instanceof RegExp) {
    return new RegExp(value) as DeepWritable<T>
  }
  if (typeof value === 'object' && value != null) {
    throw new Error('Cannot deep clone non-plain object')
  }
  return value as DeepWritable<T>
}

type MaybeFallback<D, V> = undefined extends V ? Exclude<V, undefined> | D : V

type MergeWithDefaultsResult<D, V> =
  Equal<D, undefined> extends true
    ? V
    : D extends Function | Array<any>
      ? MaybeFallback<D, V>
      : V extends Function | Array<any>
        ? MaybeFallback<D, V>
        : D extends Record<string, any>
          ? V extends Record<string, any>
            ? {
                [K in keyof D | keyof V]: K extends keyof D
                  ? K extends keyof V
                    ? MergeWithDefaultsResult<D[K], V[K]>
                    : D[K]
                  : K extends keyof V
                    ? V[K]
                    : never
              }
            : MaybeFallback<D, V>
          : MaybeFallback<D, V>

function mergeWithDefaultsRecursively<
  D extends Record<string, any>,
  V extends Record<string, any>,
>(defaults: D, values: V): MergeWithDefaultsResult<D, V> {
  const merged: Record<string, any> = defaults
  for (const key in values) {
    const value = values[key]
    // let null to set the value (e.g. `server.watch: null`)
    if (value === undefined) continue

    const existing = merged[key]
    if (existing === undefined) {
      merged[key] = value
      continue
    }

    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeWithDefaultsRecursively(existing, value)
      continue
    }

    // use replace even for arrays
    merged[key] = value
  }
  return merged as MergeWithDefaultsResult<D, V>
}

const environmentPathRE = /^environments\.[^.]+$/

export function mergeWithDefaults<
  D extends Record<string, any>,
  V extends Record<string, any>,
>(defaults: D, values: V): MergeWithDefaultsResult<DeepWritable<D>, V> {
  // NOTE: we need to clone the value here to avoid mutating the defaults
  const clonedDefaults = deepClone(defaults)
  return mergeWithDefaultsRecursively(clonedDefaults, values)
}

function mergeConfigRecursively(
  defaults: Record<string, any>,
  overrides: Record<string, any>,
  rootPath: string,
) {
  const merged: Record<string, any> = { ...defaults }
  for (const key in overrides) {
    const value = overrides[key]
    if (value == null) {
      continue
    }

    const existing = merged[key]

    if (existing == null) {
      merged[key] = value
      continue
    }

    // fields that require special handling
    if (key === 'alias' && (rootPath === 'resolve' || rootPath === '')) {
      merged[key] = mergeAlias(existing, value)
      continue
    } else if (key === 'assetsInclude' && rootPath === '') {
      merged[key] = [].concat(existing, value)
      continue
    } else if (
      ((key === 'noExternal' &&
        (rootPath === 'ssr' || rootPath === 'resolve')) ||
        (key === 'allowedHosts' && rootPath === 'server')) &&
      (existing === true || value === true)
    ) {
      merged[key] = true
      continue
    } else if (key === 'plugins' && rootPath === 'worker') {
      merged[key] = () => [
        ...backwardCompatibleWorkerPlugins(existing),
        ...backwardCompatibleWorkerPlugins(value),
      ]
      continue
    } else if (key === 'server' && rootPath === 'server.hmr') {
      merged[key] = value
      continue
    }

    if (Array.isArray(existing) || Array.isArray(value)) {
      merged[key] = [...arraify(existing), ...arraify(value)]
      continue
    }
    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeConfigRecursively(
        existing,
        value,
        // treat environment.* as root
        rootPath && !environmentPathRE.test(rootPath)
          ? `${rootPath}.${key}`
          : key,
      )
      continue
    }

    merged[key] = value
  }
  return merged
}

export function mergeConfig<
  D extends Record<string, any>,
  O extends Record<string, any>,
>(
  defaults: D extends Function ? never : D,
  overrides: O extends Function ? never : O,
  isRoot = true,
): Record<string, any> {
  if (typeof defaults === 'function' || typeof overrides === 'function') {
    throw new Error(`Cannot merge config in form of callback`)
  }

  return mergeConfigRecursively(defaults, overrides, isRoot ? '' : '.')
}

export function mergeAlias(
  a?: AliasOptions,
  b?: AliasOptions,
): AliasOptions | undefined {
  if (!a) return b
  if (!b) return a
  if (isObject(a) && isObject(b)) {
    return { ...a, ...b }
  }
  // the order is flipped because the alias is resolved from top-down,
  // where the later should have higher priority
  return [...normalizeAlias(b), ...normalizeAlias(a)]
}

export function normalizeAlias(o: AliasOptions = []): Alias[] {
  return Array.isArray(o)
    ? o.map(normalizeSingleAlias)
    : Object.keys(o).map((find) =>
        normalizeSingleAlias({
          find,
          replacement: (o as any)[find],
        }),
      )
}

// https://github.com/vitejs/vite/issues/1363
// work around https://github.com/rollup/plugins/issues/759
function normalizeSingleAlias({
  find,
  replacement,
  customResolver,
}: Alias): Alias {
  if (
    typeof find === 'string' &&
    find.endsWith('/') &&
    replacement.endsWith('/')
  ) {
    find = find.slice(0, find.length - 1)
    replacement = replacement.slice(0, replacement.length - 1)
  }

  const alias: Alias = {
    find,
    replacement,
  }
  if (customResolver) {
    alias.customResolver = customResolver
  }
  return alias
}

/**
 * Transforms transpiled code result where line numbers aren't altered,
 * so we can skip sourcemap generation during dev
 */
export function transformStableResult(
  s: MagicString,
  id: string,
  config: ResolvedConfig,
): TransformResult {
  return {
    code: s.toString(),
    map:
      config.command === 'build' && config.build.sourcemap
        ? s.generateMap({ hires: 'boundary', source: id })
        : null,
  }
}

type AsyncFlatten<T extends unknown[]> = T extends (infer U)[]
  ? Exclude<Awaited<U>, U[]>[]
  : never

export async function asyncFlatten<T extends unknown[]>(
  arr: T,
): Promise<AsyncFlatten<T>> {
  do {
    arr = (await Promise.all(arr)).flat(Infinity) as any
  } while (arr.some((v: any) => v?.then))
  return arr as unknown[] as AsyncFlatten<T>
}

// strip UTF-8 BOM
export function stripBomTag(content: string): string {
  if (content.charCodeAt(0) === 0xfeff) {
    return content.slice(1)
  }

  return content
}

const windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/

/**
 * path.isAbsolute also returns true for drive relative paths on windows (e.g. /something)
 * this function returns false for them but true for absolute paths (e.g. C:/something)
 */
export const isNonDriveRelativeAbsolutePath = (p: string): boolean => {
  if (!isWindows) return p[0] === '/'
  return windowsDrivePathPrefixRE.test(p)
}

/**
 * Determine if a file is being requested with the correct case, to ensure
 * consistent behavior between dev and prod and across operating systems.
 */
export function shouldServeFile(filePath: string, root: string): boolean {
  // can skip case check on Linux
  if (!isCaseInsensitiveFS) return true

  return hasCorrectCase(filePath, root)
}

/**
 * Note that we can't use realpath here, because we don't want to follow
 * symlinks.
 */
function hasCorrectCase(file: string, assets: string): boolean {
  if (file === assets) return true

  const parent = path.dirname(file)

  if (fs.readdirSync(parent).includes(path.basename(file))) {
    return hasCorrectCase(parent, assets)
  }

  return false
}

export function joinUrlSegments(a: string, b: string): string {
  if (!a || !b) {
    return a || b || ''
  }
  if (a.endsWith('/')) {
    a = a.substring(0, a.length - 1)
  }
  if (b[0] !== '/') {
    b = '/' + b
  }
  return a + b
}

export function removeLeadingSlash(str: string): string {
  return str[0] === '/' ? str.slice(1) : str
}

export function stripBase(path: string, base: string): string {
  if (path === base) {
    return '/'
  }
  const devBase = withTrailingSlash(base)
  return path.startsWith(devBase) ? path.slice(devBase.length - 1) : path
}

export function arrayEqual(a: any[], b: any[]): boolean {
  if (a === b) return true
  if (a.length !== b.length) return false
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false
  }
  return true
}

export function evalValue<T = any>(rawValue: string): T {
  const fn = new Function(`
    var console, exports, global, module, process, require
    return (\n${rawValue}\n)
  `)
  return fn()
}

export function getNpmPackageName(importPath: string): string | null {
  const parts = importPath.split('/')
  if (parts[0][0] === '@') {
    if (!parts[1]) return null
    return `${parts[0]}/${parts[1]}`
  } else {
    return parts[0]
  }
}

export function getPkgName(name: string): string | undefined {
  return name[0] === '@' ? name.split('/')[1] : name
}

const escapeRegexRE = /[-/\\^$*+?.()|[\]{}]/g
export function escapeRegex(str: string): string {
  return str.replace(escapeRegexRE, '\\$&')
}

type CommandType = 'install' | 'uninstall' | 'update'
export function getPackageManagerCommand(
  type: CommandType = 'install',
): string {
  const packageManager =
    process.env.npm_config_user_agent?.split(' ')[0].split('/')[0] || 'npm'
  switch (type) {
    case 'install':
      return packageManager === 'npm' ? 'npm install' : `${packageManager} add`
    case 'uninstall':
      return packageManager === 'npm'
        ? 'npm uninstall'
        : `${packageManager} remove`
    case 'update':
      return packageManager === 'yarn'
        ? 'yarn upgrade'
        : `${packageManager} update`
    default:
      throw new TypeError(`Unknown command type: ${type}`)
  }
}

export function isDevServer(
  server: ViteDevServer | PreviewServer,
): server is ViteDevServer {
  return 'pluginContainer' in server
}

export function createSerialPromiseQueue<T>(): {
  run(f: () => Promise<T>): Promise<T>
} {
  let previousTask: Promise<[unknown, Awaited<T>]> | undefined

  return {
    async run(f) {
      const thisTask = f()
      // wait for both the previous task and this task
      // so that this function resolves in the order this function is called
      const depTasks = Promise.all([previousTask, thisTask])
      previousTask = depTasks

      const [, result] = await depTasks

      // this task was the last one, clear `previousTask` to free up memory
      if (previousTask === depTasks) {
        previousTask = undefined
      }

      return result
    },
  }
}

export function sortObjectKeys<T extends Record<string, any>>(obj: T): T {
  const sorted: Record<string, any> = {}
  for (const key of Object.keys(obj).sort()) {
    sorted[key] = obj[key]
  }
  return sorted as T
}

export function displayTime(time: number): string {
  // display: {X}ms
  if (time < 1000) {
    return `${time}ms`
  }

  time = time / 1000

  // display: {X}s
  if (time < 60) {
    return `${time.toFixed(2)}s`
  }

  // Calculate total minutes and remaining seconds
  const mins = Math.floor(time / 60)
  const seconds = Math.round(time % 60)

  // Handle case where seconds rounds to 60
  if (seconds === 60) {
    return `${mins + 1}m`
  }

  // display: {X}m {Y}s
  return `${mins}m${seconds < 1 ? '' : ` ${seconds}s`}`
}

/**
 * Encodes the URI path portion (ignores part after ? or #)
 */
export function encodeURIPath(uri: string): string {
  if (uri.startsWith('data:')) return uri
  const filePath = cleanUrl(uri)
  const postfix = filePath !== uri ? uri.slice(filePath.length) : ''
  return encodeURI(filePath) + postfix
}

/**
 * Like `encodeURIPath`, but only replacing `%` as `%25`. This is useful for environments
 * that can handle un-encoded URIs, where `%` is the only ambiguous character.
 */
export function partialEncodeURIPath(uri: string): string {
  if (uri.startsWith('data:')) return uri
  const filePath = cleanUrl(uri)
  const postfix = filePath !== uri ? uri.slice(filePath.length) : ''
  return filePath.replaceAll('%', '%25') + postfix
}

type SigtermCallback = (signal?: 'SIGTERM', exitCode?: number) => Promise<void>

// Use a shared callback when attaching sigterm listeners to avoid `MaxListenersExceededWarning`
const sigtermCallbacks = new Set<SigtermCallback>()
const parentSigtermCallback: SigtermCallback = async (signal, exitCode) => {
  await Promise.all([...sigtermCallbacks].map((cb) => cb(signal, exitCode)))
}

export const setupSIGTERMListener = (
  callback: (signal?: 'SIGTERM', exitCode?: number) => Promise<void>,
): void => {
  if (sigtermCallbacks.size === 0) {
    process.once('SIGTERM', parentSigtermCallback)
    if (process.env.CI !== 'true') {
      process.stdin.on('end', parentSigtermCallback)
    }
  }
  sigtermCallbacks.add(callback)
}

export const teardownSIGTERMListener = (
  callback: Parameters<typeof setupSIGTERMListener>[0],
): void => {
  sigtermCallbacks.delete(callback)
  if (sigtermCallbacks.size === 0) {
    process.off('SIGTERM', parentSigtermCallback)
    if (process.env.CI !== 'true') {
      process.stdin.off('end', parentSigtermCallback)
    }
  }
}

export function getServerUrlByHost(
  resolvedUrls: ResolvedServerUrls | null,
  host: CommonServerOptions['host'],
): string | undefined {
  if (typeof host === 'string') {
    const matchedUrl = [
      ...(resolvedUrls?.local ?? []),
      ...(resolvedUrls?.network ?? []),
    ].find((url) => url.includes(host))
    if (matchedUrl) {
      return matchedUrl
    }
  }
  return resolvedUrls?.local[0] ?? resolvedUrls?.network[0]
}

let lastDateNow = 0
/**
 * Similar to `Date.now()`, but strictly monotonically increasing.
 *
 * This function will never return the same value.
 * Thus, the value may differ from the actual time.
 *
 * related: https://github.com/vitejs/vite/issues/19804
 */
export function monotonicDateNow(): number {
  const now = Date.now()
  if (now > lastDateNow) {
    lastDateNow = now
    return lastDateNow
  }

  lastDateNow++
  return lastDateNow
}



================================================
FILE: packages/vite/src/node/watch.ts
================================================
import { EventEmitter } from 'node:events'
import path from 'node:path'
import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
import type { OutputOptions } from 'rollup'
import colors from 'picocolors'
import { escapePath } from 'tinyglobby'
import { withTrailingSlash } from '../shared/utils'
import { arraify, normalizePath } from './utils'
import type { Logger } from './logger'

export function getResolvedOutDirs(
  root: string,
  outDir: string,
  outputOptions: OutputOptions[] | OutputOptions | undefined,
): Set<string> {
  const resolvedOutDir = path.resolve(root, outDir)
  if (!outputOptions) return new Set([resolvedOutDir])

  return new Set(
    arraify(outputOptions).map(({ dir }) =>
      dir ? path.resolve(root, dir) : resolvedOutDir,
    ),
  )
}

export function resolveEmptyOutDir(
  emptyOutDir: boolean | null,
  root: string,
  outDirs: Set<string>,
  logger?: Logger,
): boolean {
  if (emptyOutDir != null) return emptyOutDir

  for (const outDir of outDirs) {
    if (!normalizePath(outDir).startsWith(withTrailingSlash(root))) {
      // warn if outDir is outside of root
      logger?.warn(
        colors.yellow(
          `\n${colors.bold(`(!)`)} outDir ${colors.white(
            colors.dim(outDir),
          )} is not inside project root and will not be emptied.\n` +
            `Use --emptyOutDir to override.\n`,
        ),
      )
      return false
    }
  }
  return true
}

export function resolveChokidarOptions(
  options: WatchOptions | undefined,
  resolvedOutDirs: Set<string>,
  emptyOutDir: boolean,
  cacheDir: string,
): WatchOptions {
  const { ignored: ignoredList, ...otherOptions } = options ?? {}
  const ignored: WatchOptions['ignored'] = [
    '**/.git/**',
    '**/node_modules/**',
    '**/test-results/**', // Playwright
    escapePath(cacheDir) + '/**',
    ...arraify(ignoredList || []),
  ]
  if (emptyOutDir) {
    ignored.push(
      ...[...resolvedOutDirs].map((outDir) => escapePath(outDir) + '/**'),
    )
  }

  const resolvedWatchOptions: WatchOptions = {
    ignored,
    ignoreInitial: true,
    ignorePermissionErrors: true,
    ...otherOptions,
  }

  return resolvedWatchOptions
}

class NoopWatcher extends EventEmitter implements FSWatcher {
  constructor(public options: WatchOptions) {
    super()
  }

  add() {
    return this
  }

  unwatch() {
    return this
  }

  getWatched() {
    return {}
  }

  ref() {
    return this
  }

  unref() {
    return this
  }

  async close() {
    // noop
  }
}

export function createNoopWatcher(options: WatchOptions): FSWatcher {
  return new NoopWatcher(options)
}



================================================
FILE: packages/vite/src/node/__tests__/assetSource.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { type DefaultTreeAdapterMap, parseFragment } from 'parse5'
import { getNodeAssetAttributes } from '../assetSource'

describe('getNodeAssetAttributes', () => {
  const getNode = (html: string) => {
    const ast = parseFragment(html, { sourceCodeLocationInfo: true })
    return ast.childNodes[0] as DefaultTreeAdapterMap['element']
  }

  test('handles img src', () => {
    const node = getNode('<img src="foo.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(1)
    expect(attrs[0]).toHaveProperty('type', 'src')
    expect(attrs[0]).toHaveProperty('key', 'src')
    expect(attrs[0]).toHaveProperty('value', 'foo.jpg')
    expect(attrs[0].attributes).toEqual({ src: 'foo.jpg' })
    expect(attrs[0].location).toHaveProperty('startOffset', 5)
    expect(attrs[0].location).toHaveProperty('endOffset', 18)
  })

  test('handles source srcset', () => {
    const node = getNode('<source srcset="foo.jpg 1x, bar.jpg 2x">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(1)
    expect(attrs[0]).toHaveProperty('type', 'srcset')
    expect(attrs[0]).toHaveProperty('key', 'srcset')
    expect(attrs[0]).toHaveProperty('value', 'foo.jpg 1x, bar.jpg 2x')
    expect(attrs[0].attributes).toEqual({ srcset: 'foo.jpg 1x, bar.jpg 2x' })
  })

  test('handles video src and poster', () => {
    const node = getNode('<video src="video.mp4" poster="poster.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(2)
    expect(attrs[0]).toHaveProperty('type', 'src')
    expect(attrs[0]).toHaveProperty('key', 'src')
    expect(attrs[0]).toHaveProperty('value', 'video.mp4')
    expect(attrs[0].attributes).toEqual({
      src: 'video.mp4',
      poster: 'poster.jpg',
    })
    expect(attrs[1]).toHaveProperty('type', 'src')
    expect(attrs[1]).toHaveProperty('key', 'poster')
    expect(attrs[1]).toHaveProperty('value', 'poster.jpg')
  })

  test('handles link with allowed rel', () => {
    const node = getNode('<link rel="stylesheet" href="style.css">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(1)
    expect(attrs[0]).toHaveProperty('type', 'src')
    expect(attrs[0]).toHaveProperty('key', 'href')
    expect(attrs[0]).toHaveProperty('value', 'style.css')
    expect(attrs[0].attributes).toEqual({
      rel: 'stylesheet',
      href: 'style.css',
    })
  })

  test('handles meta with allowed name', () => {
    const node = getNode('<meta name="twitter:image" content="image.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(1)
    expect(attrs[0]).toHaveProperty('type', 'src')
    expect(attrs[0]).toHaveProperty('key', 'content')
    expect(attrs[0]).toHaveProperty('value', 'image.jpg')
  })

  test('handles meta with allowed property', () => {
    const node = getNode('<meta property="og:image" content="image.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(1)
    expect(attrs[0]).toHaveProperty('type', 'src')
    expect(attrs[0]).toHaveProperty('key', 'content')
    expect(attrs[0]).toHaveProperty('value', 'image.jpg')
  })

  test('does not handle meta with unknown name', () => {
    const node = getNode('<meta name="unknown" content="image.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(0)
  })

  test('does not handle meta with unknown property', () => {
    const node = getNode('<meta property="unknown" content="image.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(0)
  })

  test('does not handle meta with no known properties', () => {
    const node = getNode('<meta foo="bar" content="image.jpg">')
    const attrs = getNodeAssetAttributes(node)
    expect(attrs).toHaveLength(0)
  })
})



================================================
FILE: packages/vite/src/node/__tests__/build.spec.ts
================================================
import { basename, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { stripVTControlCharacters } from 'node:util'
import fsp from 'node:fs/promises'
import colors from 'picocolors'
import { afterEach, describe, expect, test, vi } from 'vitest'
import type {
  LogLevel,
  OutputChunk,
  OutputOptions,
  RollupLog,
  RollupOptions,
  RollupOutput,
} from 'rollup'
import type { LibraryFormats, LibraryOptions } from '../build'
import {
  build,
  createBuilder,
  onRollupLog,
  resolveBuildOutputs,
  resolveLibFilename,
} from '../build'
import type { Logger } from '../logger'
import { createLogger } from '../logger'
import { BuildEnvironment, resolveConfig } from '..'

const __dirname = resolve(fileURLToPath(import.meta.url), '..')

type FormatsToFileNames = [LibraryFormats, string][]

describe('build', () => {
  test('file hash should change when css changes for dynamic entries', async () => {
    const buildProject = async (cssColor: string) => {
      return (await build({
        root: resolve(__dirname, 'packages/build-project'),
        logLevel: 'silent',
        build: {
          write: false,
        },
        plugins: [
          {
            name: 'test',
            resolveId(id) {
              if (
                id === 'entry.js' ||
                id === 'subentry.js' ||
                id === 'foo.css'
              ) {
                return '\0' + id
              }
            },
            load(id) {
              if (id === '\0entry.js') {
                return `window.addEventListener('click', () => { import('subentry.js') });`
              }
              if (id === '\0subentry.js') {
                return `import 'foo.css'`
              }
              if (id === '\0foo.css') {
                return `.foo { color: ${cssColor} }`
              }
            },
          },
        ],
      })) as RollupOutput
    }
    const result = await Promise.all([
      buildProject('red'),
      buildProject('blue'),
    ])
    expect(getOutputHashChanges(result[0], result[1])).toMatchInlineSnapshot(`
      {
        "changed": [
          "index",
          "_subentry.css",
        ],
        "unchanged": [
          "undefined",
        ],
      }
    `)
    assertOutputHashContentChange(result[0], result[1])
  })

  test('file hash should change when pure css chunk changes', async () => {
    const buildProject = async (cssColor: string) => {
      return (await build({
        root: resolve(__dirname, 'packages/build-project'),
        logLevel: 'silent',
        build: {
          write: false,
        },
        plugins: [
          {
            name: 'test',
            resolveId(id) {
              if (
                id === 'entry.js' ||
                id === 'foo.js' ||
                id === 'bar.js' ||
                id === 'baz.js' ||
                id === 'foo.css' ||
                id === 'bar.css' ||
                id === 'baz.css'
              ) {
                return '\0' + id
              }
            },
            load(id) {
              if (id === '\0entry.js') {
                return `
                  window.addEventListener('click', () => { import('foo.js') });
                  window.addEventListener('click', () => { import('bar.js') });`
              }
              if (id === '\0foo.js') return `import 'foo.css'; import 'baz.js'`
              if (id === '\0bar.js') return `import 'bar.css'; import 'baz.js'`
              if (id === '\0baz.js') return `import 'baz.css'`
              if (id === '\0foo.css') return `.foo { color: red }`
              if (id === '\0bar.css') return `.foo { color: green }`
              if (id === '\0baz.css') return `.foo { color: ${cssColor} }`
            },
          },
        ],
      })) as RollupOutput
    }
    const result = await Promise.all([
      buildProject('yellow'),
      buildProject('blue'),
    ])
    expect(getOutputHashChanges(result[0], result[1])).toMatchInlineSnapshot(`
      {
        "changed": [
          "index",
          "_foo",
          "_bar",
          "_baz.css",
        ],
        "unchanged": [
          "_foo.css",
          "_bar.css",
          "undefined",
        ],
      }
    `)
    assertOutputHashContentChange(result[0], result[1])
  })

  test.for([
    [true, true],
    [true, false],
    [false, true],
    [false, false],
    ['auto', true],
    ['auto', false],
  ] as const)(
    'large json object files should have tree-shaking (json.stringify: %s, json.namedExports: %s)',
    async ([stringify, namedExports]) => {
      const esBundle = (await build({
        mode: 'development',
        root: resolve(__dirname, 'packages/build-project'),
        logLevel: 'silent',
        json: { stringify, namedExports },
        build: {
          minify: false,
          modulePreload: { polyfill: false },
          write: false,
        },
        plugins: [
          {
            name: 'test',
            resolveId(id) {
              if (
                id === 'entry.js' ||
                id === 'object.json' ||
                id === 'array.json'
              ) {
                return '\0' + id
              }
            },
            load(id) {
              if (id === '\0entry.js') {
                return `
                  import object from 'object.json';
                  import array from 'array.json';
                  console.log();
                `
              }
              if (id === '\0object.json') {
                return `
                  {"value": {"${stringify}_${namedExports}":"JSON_OBJ${'_'.repeat(10_000)}"}}
                `
              }
              if (id === '\0array.json') {
                return `
                  ["${stringify}_${namedExports}","JSON_ARR${'_'.repeat(10_000)}"]
                `
              }
            },
          },
        ],
      })) as RollupOutput

      const foo = esBundle.output.find(
        (chunk) => chunk.type === 'chunk' && chunk.isEntry,
      ) as OutputChunk
      expect(foo.code).not.contains('JSON_ARR')
      expect(foo.code).not.contains('JSON_OBJ')
    },
  )

  test('external modules should not be hoisted in library build', async () => {
    const [esBundle] = (await build({
      logLevel: 'silent',
      build: {
        lib: {
          entry: ['foo.js', 'bar.js'],
          formats: ['es'],
        },
        rollupOptions: {
          external: 'external',
        },
        write: false,
      },
      plugins: [
        {
          name: 'test',
          resolveId(id) {
            const name = basename(id)
            if (name === 'foo.js' || name === 'bar.js') {
              return name
            }
          },
          load(id) {
            if (id === 'foo.js') {
              return `
                  import bar from 'bar.js'
                  export default bar()
                `
            }
            if (id === 'bar.js') {
              return `
                  import ext from 'external';
                  export default ext();`
            }
          },
        },
      ],
    })) as RollupOutput[]

    const foo = esBundle.output.find(
      (chunk) => chunk.fileName === 'foo.js',
    ) as OutputChunk
    expect(foo.code).not.contains('import "external"')
  })
})

const baseLibOptions: LibraryOptions = {
  fileName: 'my-lib',
  entry: 'mylib.js',
}

describe('resolveBuildOutputs', () => {
  test('resolves outputs correctly', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = { ...baseLibOptions }
    const outputs: OutputOptions[] = [{ format: 'es' }]
    const resolvedOutputs = resolveBuildOutputs(outputs, libOptions, logger)

    expect(resolvedOutputs).toEqual([
      {
        format: 'es',
      },
    ])
  })

  test('resolves outputs from lib options', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = { ...baseLibOptions, name: 'lib' }
    const resolvedOutputs = resolveBuildOutputs(void 0, libOptions, logger)

    expect(resolvedOutputs).toEqual([
      {
        format: 'es',
      },
      {
        format: 'umd',
      },
    ])
  })

  test('does not change outputs when lib options are missing', () => {
    const logger = createLogger()
    const outputs: OutputOptions[] = [{ format: 'es' }]
    const resolvedOutputs = resolveBuildOutputs(outputs, false, logger)

    expect(resolvedOutputs).toEqual(outputs)
  })

  test('logs a warning when outputs is an array and formats are specified', () => {
    const logger = createLogger()
    const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(() => {})
    const libOptions: LibraryOptions = {
      ...baseLibOptions,
      formats: ['iife'],
    }
    const outputs: OutputOptions[] = [{ format: 'es' }]

    resolveBuildOutputs(outputs, libOptions, logger)

    expect(loggerSpy).toHaveBeenCalledWith(
      expect.stringContaining('"build.lib.formats" will be ignored because'),
    )
  })

  test('throws an error when lib.name is missing on iife format', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = {
      ...baseLibOptions,
      formats: ['iife'],
    }
    const resolveBuild = () => resolveBuildOutputs(void 0, libOptions, logger)

    expect(resolveBuild).toThrowError(/Option "build\.lib\.name" is required/)
  })

  test('throws an error when lib.name is missing on umd format', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = { ...baseLibOptions, formats: ['umd'] }
    const resolveBuild = () => resolveBuildOutputs(void 0, libOptions, logger)

    expect(resolveBuild).toThrowError(/Option "build\.lib\.name" is required/)
  })

  test('throws an error when output.name is missing on iife format', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = { ...baseLibOptions }
    const outputs: OutputOptions[] = [{ format: 'iife' }]
    const resolveBuild = () => resolveBuildOutputs(outputs, libOptions, logger)

    expect(resolveBuild).toThrowError(
      /Entries in "build\.rollupOptions\.output" must specify "name"/,
    )
  })

  test('throws an error when output.name is missing on umd format', () => {
    const logger = createLogger()
    const libOptions: LibraryOptions = { ...baseLibOptions }
    const outputs: OutputOptions[] = [{ format: 'umd' }]
    const resolveBuild = () => resolveBuildOutputs(outputs, libOptions, logger)

    expect(resolveBuild).toThrowError(
      /Entries in "build\.rollupOptions\.output" must specify "name"/,
    )
  })
})

describe('resolveLibFilename', () => {
  test('custom filename function', () => {
    const filename = resolveLibFilename(
      {
        fileName: (format) => `custom-filename-function.${format}.js`,
        entry: 'mylib.js',
      },
      'es',
      'myLib',
      resolve(__dirname, 'packages/name'),
    )

    expect(filename).toBe('custom-filename-function.es.js')
  })

  test('custom filename string', () => {
    const filename = resolveLibFilename(
      {
        fileName: 'custom-filename',
        entry: 'mylib.js',
      },
      'es',
      'myLib',
      resolve(__dirname, 'packages/name'),
    )

    expect(filename).toBe('custom-filename.mjs')
  })

  test('package name as filename', () => {
    const filename = resolveLibFilename(
      {
        entry: 'mylib.js',
      },
      'es',
      'myLib',
      resolve(__dirname, 'packages/name'),
    )

    expect(filename).toBe('mylib.mjs')
  })

  test('custom filename and no package name', () => {
    const filename = resolveLibFilename(
      {
        fileName: 'custom-filename',
        entry: 'mylib.js',
      },
      'es',
      'myLib',
      resolve(__dirname, 'packages/noname'),
    )

    expect(filename).toBe('custom-filename.mjs')
  })

  test('missing filename', () => {
    const filename = resolveLibFilename(
      {
        entry: 'mylib.js',
      },
      'es',
      'myLib',
      resolve(__dirname, 'packages/noname'),
    )
    expect(filename).toBe('named-testing-package.mjs')
  })

  test('commonjs package extensions', () => {
    const formatsToFilenames: FormatsToFileNames = [
      ['es', 'my-lib.mjs'],
      ['umd', 'my-lib.umd.js'],
      ['cjs', 'my-lib.js'],
      ['iife', 'my-lib.iife.js'],
    ]

    for (const [format, expectedFilename] of formatsToFilenames) {
      const filename = resolveLibFilename(
        baseLibOptions,
        format,
        'myLib',
        resolve(__dirname, 'packages/noname'),
      )

      expect(filename).toBe(expectedFilename)
    }
  })

  test('module package extensions', () => {
    const formatsToFilenames: FormatsToFileNames = [
      ['es', 'my-lib.js'],
      ['umd', 'my-lib.umd.cjs'],
      ['cjs', 'my-lib.cjs'],
      ['iife', 'my-lib.iife.js'],
    ]

    for (const [format, expectedFilename] of formatsToFilenames) {
      const filename = resolveLibFilename(
        baseLibOptions,
        format,
        'myLib',
        resolve(__dirname, 'packages/module'),
      )

      expect(expectedFilename).toBe(filename)
    }
  })

  test('multiple entries with aliases', () => {
    const libOptions: LibraryOptions = {
      entry: {
        entryA: 'entryA.js',
        entryB: 'entryB.js',
      },
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('entryA.mjs')
    expect(fileName2).toBe('entryB.mjs')
  })

  test('multiple entries with aliases: custom filename function', () => {
    const libOptions: LibraryOptions = {
      entry: {
        entryA: 'entryA.js',
        entryB: 'entryB.js',
      },
      fileName: (format, entryAlias) =>
        `custom-filename-function.${entryAlias}.${format}.js`,
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('custom-filename-function.entryA.es.js')
    expect(fileName2).toBe('custom-filename-function.entryB.es.js')
  })

  test('multiple entries with aliases: custom filename string', () => {
    const libOptions: LibraryOptions = {
      entry: {
        entryA: 'entryA.js',
        entryB: 'entryB.js',
      },
      fileName: 'custom-filename',
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('custom-filename.mjs')
    expect(fileName2).toBe('custom-filename.mjs')
  })

  test('multiple entries as array', () => {
    const libOptions: LibraryOptions = {
      entry: ['entryA.js', 'entryB.js'],
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('entryA.mjs')
    expect(fileName2).toBe('entryB.mjs')
  })

  test('multiple entries as array: custom filename function', () => {
    const libOptions: LibraryOptions = {
      entry: ['entryA.js', 'entryB.js'],
      fileName: (format, entryAlias) =>
        `custom-filename-function.${entryAlias}.${format}.js`,
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('custom-filename-function.entryA.es.js')
    expect(fileName2).toBe('custom-filename-function.entryB.es.js')
  })

  test('multiple entries as array: custom filename string', () => {
    const libOptions: LibraryOptions = {
      entry: ['entryA.js', 'entryB.js'],
      fileName: 'custom-filename',
    }

    const [fileName1, fileName2] = ['entryA', 'entryB'].map((entryAlias) =>
      resolveLibFilename(
        libOptions,
        'es',
        entryAlias,
        resolve(__dirname, 'packages/name'),
      ),
    )

    expect(fileName1).toBe('custom-filename.mjs')
    expect(fileName2).toBe('custom-filename.mjs')
  })
})

describe('resolveBuildOutputs', () => {
  test('default format: one entry', () => {
    const libOptions: LibraryOptions = {
      entry: 'entryA.js',
      name: 'entryA',
    }

    expect(resolveBuildOutputs(undefined, libOptions, {} as Logger)).toEqual([
      { format: 'es' },
      { format: 'umd' },
    ])
    expect(
      resolveBuildOutputs({ name: 'A' }, libOptions, {} as Logger),
    ).toEqual([
      { format: 'es', name: 'A' },
      { format: 'umd', name: 'A' },
    ])
    expect(
      resolveBuildOutputs([{ name: 'A' }], libOptions, {} as Logger),
    ).toEqual([{ name: 'A' }])
  })

  test('default format: multiple entries', () => {
    const libOptions: LibraryOptions = {
      entry: ['entryA.js', 'entryB.js'],
    }

    expect(resolveBuildOutputs(undefined, libOptions, {} as Logger)).toEqual([
      { format: 'es' },
      { format: 'cjs' },
    ])
    expect(
      resolveBuildOutputs({ name: 'A' }, libOptions, {} as Logger),
    ).toEqual([
      { format: 'es', name: 'A' },
      { format: 'cjs', name: 'A' },
    ])
    expect(
      resolveBuildOutputs([{ name: 'A' }], libOptions, {} as Logger),
    ).toEqual([{ name: 'A' }])
  })

  test('umd or iife: should not support multiple entries', () => {
    ;['umd', 'iife'].forEach((format) => {
      expect(() =>
        resolveBuildOutputs(
          undefined,
          {
            entry: ['entryA.js', 'entryB.js'],
            formats: [format as LibraryFormats],
          },
          {} as Logger,
        ),
      ).toThrow(
        `Multiple entry points are not supported when output formats include "umd" or "iife".`,
      )
    })
  })

  test('umd or iife: should define build.lib.name', () => {
    ;['umd', 'iife'].forEach((format) => {
      expect(() =>
        resolveBuildOutputs(
          undefined,
          {
            entry: 'entryA.js',
            formats: [format as LibraryFormats],
          },
          {} as Logger,
        ),
      ).toThrow(
        `Option "build.lib.name" is required when output formats include "umd" or "iife".`,
      )
    })
  })

  test('array outputs: should ignore build.lib.formats', () => {
    const log = { warn: vi.fn() } as unknown as Logger
    expect(
      resolveBuildOutputs(
        [{ name: 'A' }],
        {
          entry: 'entryA.js',
          formats: ['es'],
        },
        log,
      ),
    ).toEqual([{ name: 'A' }])
    expect(log.warn).toHaveBeenLastCalledWith(
      colors.yellow(
        `"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.`,
      ),
    )
  })

  test('ssrEmitAssets', async () => {
    const result = await build({
      root: resolve(__dirname, 'fixtures/emit-assets'),
      logLevel: 'silent',
      build: {
        ssr: true,
        ssrEmitAssets: true,
        rollupOptions: {
          input: {
            index: '/entry',
          },
        },
      },
    })
    expect(result).toMatchObject({
      output: [
        {
          fileName: 'index.mjs',
        },
        {
          fileName: expect.stringMatching(/assets\/index-[-\w]{8}\.css/),
        },
      ],
    })
  })

  test('emitAssets', async () => {
    const builder = await createBuilder({
      root: resolve(__dirname, 'fixtures/emit-assets'),
      logLevel: 'warn',
      environments: {
        ssr: {
          build: {
            ssr: true,
            emitAssets: true,
            rollupOptions: {
              input: {
                index: '/entry',
              },
            },
          },
        },
      },
    })
    const result = await builder.build(builder.environments.ssr)
    expect(result).toMatchObject({
      output: [
        {
          fileName: 'index.mjs',
        },
        {
          fileName: expect.stringMatching(/assets\/index-[-\w]{8}\.css/),
        },
      ],
    })
  })

  test('ssr builtin', async () => {
    const builder = await createBuilder({
      root: resolve(__dirname, 'fixtures/dynamic-import'),
      logLevel: 'warn',
      environments: {
        ssr: {
          build: {
            ssr: true,
            rollupOptions: {
              input: {
                index: '/entry',
              },
            },
          },
        },
      },
    })
    const result = await builder.build(builder.environments.ssr)
    expect((result as RollupOutput).output[0].code).not.toContain('preload')
  })

  test('ssr custom', async () => {
    const builder = await createBuilder({
      root: resolve(__dirname, 'fixtures/dynamic-import'),
      logLevel: 'warn',
      environments: {
        custom: {
          build: {
            ssr: true,
            rollupOptions: {
              input: {
                index: '/entry',
              },
            },
          },
        },
      },
    })
    const result = await builder.build(builder.environments.custom)
    expect((result as RollupOutput).output[0].code).not.toContain('preload')
  })
})

test('default sharedConfigBuild true on build api', async () => {
  let counter = 0
  await build({
    root: resolve(__dirname, 'fixtures/emit-assets'),
    logLevel: 'warn',
    build: {
      ssr: true,
      rollupOptions: {
        input: {
          index: '/entry',
        },
      },
    },
    plugins: [
      {
        name: 'test-plugin',
        config() {
          counter++
        },
      },
    ],
  })
  expect(counter).toBe(1)
})

test.for([true, false])(
  'minify per environment (builder.sharedPlugins: %s)',
  async (sharedPlugins) => {
    const root = resolve(__dirname, 'fixtures/shared-plugins/minify')
    const builder = await createBuilder({
      root,
      logLevel: 'warn',
      environments: {
        client: {
          build: {
            outDir: './dist/client',
            rollupOptions: {
              input: '/entry.js',
            },
          },
        },
        ssr: {
          build: {
            outDir: './dist/server',
            rollupOptions: {
              input: '/entry.js',
            },
          },
        },
        custom1: {
          build: {
            minify: true,
            outDir: './dist/custom1',
            rollupOptions: {
              input: '/entry.js',
            },
          },
        },
        custom2: {
          build: {
            minify: false,
            outDir: './dist/custom2',
            rollupOptions: {
              input: '/entry.js',
            },
          },
        },
      },
      builder: {
        sharedPlugins,
      },
    })
    const client = await builder.build(builder.environments.client)
    const ssr = await builder.build(builder.environments.ssr)
    const custom1 = await builder.build(builder.environments.custom1)
    const custom2 = await builder.build(builder.environments.custom2)
    expect(
      ([client, ssr, custom1, custom2] as RollupOutput[]).map(
        (o) => o.output[0].code.split('\n').length,
      ),
    ).toEqual([2, 5, 2, 5])
  },
)

test('adjust worker build error for worker.format', async () => {
  try {
    await build({
      root: resolve(__dirname, 'fixtures/worker-dynamic'),
      build: {
        rollupOptions: {
          input: {
            index: '/main.js',
          },
        },
      },
      logLevel: 'silent',
    })
  } catch (e) {
    expect(e.message).toContain('worker.format')
    expect(e.message).not.toContain('output.format')
    return
  }
  expect.unreachable()
})

describe('onRollupLog', () => {
  const pluginName = 'rollup-plugin-test'
  const msgInfo = 'This is the INFO message.'
  const msgWarn = 'This is the WARN message.'
  const buildProject = async (
    level: LogLevel | 'error',
    message: string | RollupLog,
    logger: Logger,
    options?: Pick<RollupOptions, 'onLog' | 'onwarn'>,
  ) => {
    await build({
      root: resolve(__dirname, 'packages/build-project'),
      logLevel: 'info',
      build: {
        write: false,
        rollupOptions: {
          ...options,
          logLevel: 'debug',
        },
      },
      customLogger: logger,
      plugins: [
        {
          name: pluginName,
          resolveId(id) {
            this[level](message)
            if (id === 'entry.js') {
              return '\0' + id
            }
          },
          load(id) {
            if (id === '\0entry.js') {
              return `export default "This is test module";`
            }
          },
        },
      ],
    })
  }

  const callOnRollupLog = async (
    logger: Logger,
    level: LogLevel,
    log: RollupLog,
  ) => {
    const config = await resolveConfig(
      { customLogger: logger },
      'build',
      'production',
      'production',
    )
    const buildEnvironment = new BuildEnvironment('client', config)
    onRollupLog(level, log, buildEnvironment)
  }

  afterEach(() => {
    vi.restoreAllMocks()
  })

  test('Rollup logs of info should be handled by vite', async () => {
    const logger = createLogger()
    const loggerSpy = vi.spyOn(logger, 'info').mockImplementation(() => {})

    await buildProject('info', msgInfo, logger)
    const logs = loggerSpy.mock.calls.map((args) =>
      stripVTControlCharacters(args[0]),
    )
    expect(logs).contain(`[plugin ${pluginName}] ${msgInfo}`)
  })

  test('Rollup logs of warn should be handled by vite', async () => {
    const logger = createLogger('silent')
    const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(() => {})

    await buildProject('warn', msgWarn, logger)
    const logs = loggerSpy.mock.calls.map((args) =>
      stripVTControlCharacters(args[0]),
    )
    expect(logs).contain(`[plugin ${pluginName}] ${msgWarn}`)
  })

  test('onLog passed by user is called', async () => {
    const logger = createLogger('silent')

    const onLogInfo = vi.fn((_log: RollupLog) => {})
    await buildProject('info', msgInfo, logger, {
      onLog(level, log) {
        if (level === 'info') {
          onLogInfo(log)
        }
      },
    })
    expect(onLogInfo).toBeCalledWith(
      expect.objectContaining({ message: `[plugin ${pluginName}] ${msgInfo}` }),
    )
  })

  test('onwarn passed by user is called', async () => {
    const logger = createLogger('silent')

    const onWarn = vi.fn((_log: RollupLog) => {})
    await buildProject('warn', msgWarn, logger, {
      onwarn(warning) {
        onWarn(warning)
      },
    })
    expect(onWarn).toBeCalledWith(
      expect.objectContaining({ message: `[plugin ${pluginName}] ${msgWarn}` }),
    )
  })

  test('should throw error when warning contains UNRESOLVED_IMPORT', async () => {
    const logger = createLogger()
    await expect(() =>
      callOnRollupLog(logger, 'warn', {
        code: 'UNRESOLVED_IMPORT',
        message: 'test',
      }),
    ).rejects.toThrowError(/Rollup failed to resolve import/)
  })

  test.each([[`Unsupported expression`], [`statically analyzed`]])(
    'should ignore dynamic import warnings (%s)',
    async (message: string) => {
      const logger = createLogger()
      const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(() => {})

      await callOnRollupLog(logger, 'warn', {
        code: 'PLUGIN_WARNING',
        message: message,
        plugin: 'rollup-plugin-dynamic-import-variables',
      })
      expect(loggerSpy).toBeCalledTimes(0)
    },
  )

  test.each([[`CIRCULAR_DEPENDENCY`], [`THIS_IS_UNDEFINED`]])(
    'should ignore some warnings (%s)',
    async (code: string) => {
      const logger = createLogger()
      const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(() => {})

      await callOnRollupLog(logger, 'warn', {
        code: code,
        message: 'test message',
        plugin: pluginName,
      })
      expect(loggerSpy).toBeCalledTimes(0)
    },
  )
})

test('watch rebuild manifest', async (ctx) => {
  // this doesn't actually test watch rebuild
  // but it simulates something similar by running two builds for the same environment
  const root = resolve(__dirname, 'fixtures/watch-rebuild-manifest')
  const builder = await createBuilder({
    root,
    logLevel: 'error',
    environments: {
      client: {
        build: {
          rollupOptions: {
            input: '/entry.js',
          },
        },
      },
    },
    build: {
      manifest: true,
    },
  })

  function getManifestKeys(output: RollupOutput) {
    return Object.keys(
      JSON.parse(
        (output.output.find((o) => o.fileName === '.vite/manifest.json') as any)
          .source,
      ),
    )
  }

  const result = await builder.build(builder.environments.client)
  expect(getManifestKeys(result as RollupOutput)).toMatchInlineSnapshot(`
    [
      "dep.js",
      "entry.js",
    ]
  `)

  const entry = resolve(root, 'entry.js')
  const content = await fsp.readFile(entry, 'utf-8')
  await fsp.writeFile(
    entry,
    content.replace(`import('./dep.js')`, `'dep.js removed'`),
  )
  ctx.onTestFinished(async () => {
    await fsp.writeFile(entry, content)
  })

  const result2 = await builder.build(builder.environments.client)
  expect(getManifestKeys(result2 as RollupOutput)).toMatchInlineSnapshot(`
    [
      "entry.js",
    ]
  `)
})

/**
 * for each chunks in output1, if there's a chunk in output2 with the same fileName,
 * ensure that the chunk code is the same. if not, the chunk hash should have changed.
 */
function assertOutputHashContentChange(
  output1: RollupOutput,
  output2: RollupOutput,
) {
  for (const chunk of output1.output) {
    if (chunk.type === 'chunk') {
      const chunk2 = output2.output.find(
        (c) => c.type === 'chunk' && c.fileName === chunk.fileName,
      ) as OutputChunk | undefined
      if (chunk2) {
        expect(
          chunk.code,
          `the ${chunk.fileName} chunk has the same hash but different contents between builds`,
        ).toEqual(chunk2.code)
      }
    }
  }
}

function getOutputHashChanges(output1: RollupOutput, output2: RollupOutput) {
  const map1 = Object.fromEntries(
    output1.output.map((o) => [o.name, o.fileName]),
  )
  const map2 = Object.fromEntries(
    output2.output.map((o) => [o.name, o.fileName]),
  )
  const names = Object.keys(map1).filter(Boolean)
  return {
    changed: names.filter((name) => map1[name] !== map2[name]),
    unchanged: names.filter((name) => map1[name] === map2[name]),
  }
}



================================================
FILE: packages/vite/src/node/__tests__/config.spec.ts
================================================
import http from 'node:http'
import path from 'node:path'
import fs from 'node:fs'
import { afterEach, describe, expect, test } from 'vitest'
import type { InlineConfig, PluginOption } from '..'
import type { UserConfig, UserConfigExport } from '../config'
import { defineConfig, loadConfigFromFile, resolveConfig } from '../config'
import { resolveEnvPrefix } from '../env'
import { mergeConfig } from '../utils'
import { createLogger } from '../logger'

describe('mergeConfig', () => {
  test('handles configs with different alias schemas', () => {
    const baseConfig = defineConfig({
      resolve: {
        alias: [
          {
            find: 'foo',
            replacement: 'foo-value',
          },
        ],
      },
    })

    const newConfig = defineConfig({
      resolve: {
        alias: {
          bar: 'bar-value',
          baz: 'baz-value',
        },
      },
    })

    const mergedConfig: UserConfigExport = {
      resolve: {
        alias: [
          {
            find: 'bar',
            replacement: 'bar-value',
          },
          {
            find: 'baz',
            replacement: 'baz-value',
          },
          {
            find: 'foo',
            replacement: 'foo-value',
          },
        ],
      },
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('keep object alias schema', () => {
    const baseConfig = {
      resolve: {
        alias: {
          bar: 'bar-value',
          baz: 'baz-value',
        },
      },
    }

    const newConfig = {
      resolve: {
        alias: {
          bar: 'bar-value-2',
          foo: 'foo-value',
        },
      },
    }

    const mergedConfig = {
      resolve: {
        alias: {
          bar: 'bar-value-2',
          baz: 'baz-value',
          foo: 'foo-value',
        },
      },
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('handles arrays', () => {
    const baseConfig: UserConfigExport = {
      envPrefix: 'string1',
    }

    const newConfig: UserConfigExport = {
      envPrefix: ['string2', 'string3'],
    }

    const mergedConfig: UserConfigExport = {
      envPrefix: ['string1', 'string2', 'string3'],
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('handles assetsInclude', () => {
    const baseConfig: UserConfigExport = {
      assetsInclude: 'some-string',
    }

    const newConfig: UserConfigExport = {
      assetsInclude: ['some-other-string', /regexp?/],
    }

    const mergedConfig: UserConfigExport = {
      assetsInclude: ['some-string', 'some-other-string', /regexp?/],
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('not handles alias not under `resolve`', () => {
    const baseConfig = {
      custom: {
        alias: {
          bar: 'bar-value',
          baz: 'baz-value',
        },
      },
    }

    const newConfig = {
      custom: {
        alias: {
          bar: 'bar-value-2',
          foo: 'foo-value',
        },
      },
    }

    const mergedConfig = {
      custom: {
        alias: {
          bar: 'bar-value-2',
          baz: 'baz-value',
          foo: 'foo-value',
        },
      },
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('merge array correctly', () => {
    const baseConfig = {
      foo: null,
    }

    const newConfig = {
      foo: ['bar'],
    }

    const mergedConfig = {
      foo: ['bar'],
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('handles ssr.noExternal', () => {
    const baseConfig = {
      ssr: {
        noExternal: true,
      },
    }

    const newConfig = {
      ssr: {
        noExternal: ['foo'],
      },
    }

    const mergedConfig = {
      ssr: {
        noExternal: true,
      },
    }

    // merging either ways, `ssr.noExternal: true` should take highest priority
    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
    expect(mergeConfig(newConfig, baseConfig)).toEqual(mergedConfig)
  })

  test('handles environments.*.resolve.noExternal', () => {
    const baseConfig = {
      environments: {
        ssr: {
          resolve: {
            noExternal: true,
          },
        },
      },
    }

    const newConfig = {
      environments: {
        ssr: {
          resolve: {
            noExternal: ['foo'],
          },
        },
      },
    }

    const mergedConfig = {
      environments: {
        ssr: {
          resolve: {
            noExternal: true,
          },
        },
      },
    }

    // merging either ways, `resolve.noExternal: true` should take highest priority
    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
    expect(mergeConfig(newConfig, baseConfig)).toEqual(mergedConfig)
  })

  test('merge ssr.noExternal and environments.ssr.resolve.noExternal', async () => {
    const oldTrue = await resolveConfig(
      {
        ssr: {
          noExternal: true,
        },
        environments: {
          ssr: {
            resolve: {
              noExternal: ['dep'],
            },
          },
        },
      },
      'serve',
    )
    expect(oldTrue.environments.ssr.resolve.noExternal).toEqual(true)

    const newTrue = await resolveConfig(
      {
        ssr: {
          noExternal: ['dep'],
        },
        environments: {
          ssr: {
            resolve: {
              noExternal: true,
            },
          },
        },
      },
      'serve',
    )
    expect(newTrue.environments.ssr.resolve.noExternal).toEqual(true)
  })

  test('handles server.hmr.server', () => {
    const httpServer = http.createServer()

    const baseConfig = { server: { hmr: { server: httpServer } } }
    const newConfig = { server: { hmr: { server: httpServer } } }

    const mergedConfig = mergeConfig(baseConfig, newConfig)

    // Server instance should not be recreated
    expect(mergedConfig.server.hmr.server).toBe(httpServer)
  })

  test('handles server.allowedHosts', () => {
    const baseConfig = {
      server: { allowedHosts: ['example.com'] },
    }

    const newConfig = {
      server: { allowedHosts: true },
    }

    const mergedConfig = {
      server: { allowedHosts: true },
    }

    expect(mergeConfig(baseConfig, newConfig)).toEqual(mergedConfig)
  })

  test('throws error with functions', () => {
    const baseConfig = defineConfig(() => ({ base: 'base' }))
    const newConfig = defineConfig(() => ({ base: 'new' }))

    expect(() =>
      mergeConfig(
        // @ts-expect-error TypeScript shouldn't give you to pass a function as argument
        baseConfig,
        newConfig,
      ),
    ).toThrowError('Cannot merge config in form of callback')

    expect(() =>
      mergeConfig(
        {},
        // @ts-expect-error TypeScript shouldn't give you to pass a function as argument
        newConfig,
      ),
    ).toThrowError('Cannot merge config in form of callback')
  })
})

describe('resolveEnvPrefix', () => {
  test(`use 'VITE_' as default value`, () => {
    const config: UserConfig = {}
    expect(resolveEnvPrefix(config)).toMatchObject(['VITE_'])
  })

  test(`throw error if envPrefix contains ''`, () => {
    let config: UserConfig = { envPrefix: '' }
    expect(() => resolveEnvPrefix(config)).toThrow()
    config = { envPrefix: ['', 'CUSTOM_'] }
    expect(() => resolveEnvPrefix(config)).toThrow()
  })

  test('should work correctly for valid envPrefix value', () => {
    const config: UserConfig = { envPrefix: [' ', 'CUSTOM_'] }
    expect(resolveEnvPrefix(config)).toMatchObject([' ', 'CUSTOM_'])
  })
})

describe('preview config', () => {
  const serverConfig = () => ({
    port: 3003,
    strictPort: true,
    host: true,
    open: true,
    headers: {
      'Cache-Control': 'no-store',
    },
    proxy: { '/foo': 'http://localhost:4567' },
    cors: true,
  })

  test('preview inherits server config with default port', async () => {
    const config: InlineConfig = {
      server: serverConfig(),
    }
    expect(await resolveConfig(config, 'serve')).toMatchObject({
      preview: {
        ...serverConfig(),
        port: 4173,
      },
    })
  })

  test('preview inherits server config with port override', async () => {
    const config: InlineConfig = {
      server: serverConfig(),
      preview: {
        port: 3006,
      },
    }
    expect(await resolveConfig(config, 'serve')).toMatchObject({
      preview: {
        ...serverConfig(),
        port: 3006,
      },
    })
  })

  const previewConfig = () => ({
    port: 3006,
    strictPort: false,
    open: false,
    host: false,
    proxy: { '/bar': 'http://localhost:3010' },
    cors: false,
  })

  test('preview overrides server config', async () => {
    const config: InlineConfig = {
      server: serverConfig(),
      preview: previewConfig(),
    }
    expect(await resolveConfig(config, 'serve')).toMatchObject({
      preview: previewConfig(),
    })
  })
})

describe('resolveConfig', () => {
  const keepScreenMergePlugin = (): PluginOption => {
    return {
      name: 'vite-plugin-keep-screen-merge',
      config() {
        return { clearScreen: false }
      },
    }
  }

  const keepScreenOverridePlugin = (): PluginOption => {
    return {
      name: 'vite-plugin-keep-screen-override',
      config(config) {
        config.clearScreen = false
      },
    }
  }

  test('plugin merges `clearScreen` option', async () => {
    const config1: InlineConfig = { plugins: [keepScreenMergePlugin()] }
    const config2: InlineConfig = {
      plugins: [keepScreenMergePlugin()],
      clearScreen: true,
    }

    const results1 = await resolveConfig(config1, 'build')
    const results2 = await resolveConfig(config2, 'build')

    expect(results1.clearScreen).toBe(false)
    expect(results2.clearScreen).toBe(false)
  })

  test('plugin overrides `clearScreen` option', async () => {
    const config1: InlineConfig = { plugins: [keepScreenOverridePlugin()] }
    const config2: InlineConfig = {
      plugins: [keepScreenOverridePlugin()],
      clearScreen: true,
    }

    const results1 = await resolveConfig(config1, 'build')
    const results2 = await resolveConfig(config2, 'build')

    expect(results1.clearScreen).toBe(false)
    expect(results2.clearScreen).toBe(false)
  })

  test('resolveConfig with root path including "#" and "?" and "*" should warn ', async () => {
    expect.assertions(1)

    const logger = createLogger('info')
    logger.warn = (str) => {
      expect(str).to.include(
        'Consider renaming the directory / file to remove the characters',
      )
    }

    await resolveConfig({ root: './inc?ud#s*', customLogger: logger }, 'build')
  })
})

test('config compat 1', async () => {
  const config = await resolveConfig(
    {
      resolve: {
        conditions: ['client1'],
      },
      ssr: {
        resolve: {
          conditions: ['ssr1'],
        },
      },
      plugins: [
        {
          name: 'test',
          config() {
            return {
              environments: {
                client: {
                  resolve: {
                    conditions: ['client2'],
                  },
                },
                ssr: {
                  resolve: {
                    conditions: ['ssr2'],
                  },
                },
              },
            }
          },
        },
      ],
    },
    'serve',
  )
  expect(config.resolve.conditions).toMatchInlineSnapshot(`
    [
      "client1",
      "client2",
    ]
  `)
  expect(config.environments.client.resolve.conditions).toMatchInlineSnapshot(`
    [
      "client1",
      "client2",
    ]
  `)
  expect(config.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "ssr1",
      "ssr2",
    ]
  `)
  expect(config.environments.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "ssr1",
      "ssr2",
    ]
  `)
})

test('config compat 2', async () => {
  const config = await resolveConfig(
    {
      environments: {
        client: {
          resolve: {
            conditions: ['client1'],
          },
        },
        ssr: {
          resolve: {
            conditions: ['ssr1'],
          },
        },
      },
      plugins: [
        {
          name: 'test',
          config() {
            return {
              resolve: {
                conditions: ['client2'],
              },
              ssr: {
                resolve: {
                  conditions: ['ssr2'],
                },
              },
            }
          },
        },
      ],
    },
    'serve',
  )
  expect(config.resolve.conditions).toMatchInlineSnapshot(`
    [
      "client2",
      "client1",
    ]
  `)
  expect(config.environments.client.resolve.conditions).toMatchInlineSnapshot(`
    [
      "client2",
      "client1",
    ]
  `)
  expect(config.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "ssr2",
      "ssr1",
    ]
  `)
  expect(config.environments.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "ssr2",
      "ssr1",
    ]
  `)
})

test('config compat 3', async () => {
  const config = await resolveConfig({}, 'serve')
  expect(config.resolve.conditions).toMatchInlineSnapshot(`
    [
      "module",
      "browser",
      "development|production",
    ]
  `)
  expect(config.environments.client.resolve.conditions).toMatchInlineSnapshot(`
    [
      "module",
      "browser",
      "development|production",
    ]
  `)
  expect(config.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "module",
      "node",
      "development|production",
    ]
  `)
  expect(config.environments.ssr.resolve?.conditions).toMatchInlineSnapshot(`
    [
      "module",
      "node",
      "development|production",
    ]
  `)
})

test('preTransformRequests', async () => {
  async function testConfig(inlineConfig: InlineConfig) {
    return Object.fromEntries(
      Object.entries(
        (await resolveConfig(inlineConfig, 'serve')).environments,
      ).map(([name, e]) => [name, e.dev.preTransformRequests]),
    )
  }

  expect(
    await testConfig({
      environments: {
        custom: {},
        customTrue: {
          dev: {
            preTransformRequests: true,
          },
        },
        customFalse: {
          dev: {
            preTransformRequests: false,
          },
        },
      },
    }),
  ).toMatchInlineSnapshot(`
    {
      "client": true,
      "custom": false,
      "customFalse": false,
      "customTrue": true,
      "ssr": false,
    }
  `)

  expect(
    await testConfig({
      server: {
        preTransformRequests: true,
      },
      environments: {
        custom: {},
        customTrue: {
          dev: {
            preTransformRequests: true,
          },
        },
        customFalse: {
          dev: {
            preTransformRequests: false,
          },
        },
      },
    }),
  ).toMatchInlineSnapshot(`
    {
      "client": true,
      "custom": true,
      "customFalse": false,
      "customTrue": true,
      "ssr": true,
    }
  `)

  expect(
    await testConfig({
      server: {
        preTransformRequests: false,
      },
      environments: {
        custom: {},
        customTrue: {
          dev: {
            preTransformRequests: true,
          },
        },
        customFalse: {
          dev: {
            preTransformRequests: false,
          },
        },
      },
    }),
  ).toMatchInlineSnapshot(`
    {
      "client": false,
      "custom": false,
      "customFalse": false,
      "customTrue": true,
      "ssr": false,
    }
  `)
})

describe('loadConfigFromFile', () => {
  const fixtures = path.resolve(__dirname, './fixtures/config')

  describe('load default files', () => {
    const root = path.resolve(fixtures, './loadConfigFromFile')

    let writtenConfig: string | undefined
    afterEach(() => {
      if (writtenConfig) {
        fs.unlinkSync(path.resolve(root, writtenConfig))
      }
      fs.unlinkSync(path.resolve(root, 'package.json'))
    })

    const writeConfig = (fileName: string, content: string) => {
      fs.writeFileSync(path.resolve(root, fileName), content)
      writtenConfig = fileName
    }
    const writePackageJson = (typeField: string | undefined) => {
      fs.writeFileSync(
        path.resolve(root, 'package.json'),
        JSON.stringify({
          name: '@vitejs/test-load-config-from-file',
          type: typeField,
        }),
      )
    }

    const canLoadConfig = async () => {
      const result = await loadConfigFromFile(
        { command: 'build', mode: 'production' },
        undefined,
        root,
      )
      expect(result).toBeTruthy()
      expect(result?.config).toStrictEqual({ define: { foo: 1 } })
      expect(path.normalize(result!.path)).toBe(
        path.resolve(root, writtenConfig!),
      )
    }

    const cases = [
      {
        fileName: 'vite.config.js',
        content: 'export default { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.js',
        content: 'export default { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.cjs',
        content: 'module.exports = { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.cjs',
        content: 'module.exports = { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.mjs',
        content: 'export default { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.mjs',
        content: 'export default { define: { foo: 1 } }',
      },
      {
        fileName: 'vite.config.ts',
        content: 'export default { define: { foo: 1 as number } }',
      },
      {
        fileName: 'vite.config.ts',
        content: 'export default { define: { foo: 1 as number } }',
      },
      {
        fileName: 'vite.config.mts',
        content: 'export default { define: { foo: 1 as number } }',
      },
      {
        fileName: 'vite.config.mts',
        content: 'export default { define: { foo: 1 as number } }',
      },
      {
        fileName: 'vite.config.cts',
        content: 'module.exports = { define: { foo: 1 as number } }',
      },
      {
        fileName: 'vite.config.cts',
        content: 'module.exports = { define: { foo: 1 as number } }',
      },
    ]

    for (const { fileName, content } of cases) {
      for (const typeField of [undefined, 'module']) {
        test(`load ${fileName}${typeField ? ' with package#type module' : ''}`, async () => {
          writePackageJson(typeField)
          writeConfig(fileName, content)
          await canLoadConfig()
        })
      }
    }
  })

  test('can import values', async () => {
    const { config } = (await loadConfigFromFile(
      {} as any,
      path.resolve(fixtures, './entry/vite.config.ts'),
      path.resolve(fixtures, './entry'),
    ))!
    expect(config).toMatchInlineSnapshot(`
      {
        "array": [
          [
            1,
            3,
          ],
          [
            2,
            4,
          ],
        ],
        "importsField": "imports-field",
        "moduleCondition": "import condition",
      }
    `)
  })

  test('loadConfigFromFile with import attributes', async () => {
    const { config } = (await loadConfigFromFile(
      {} as any,
      path.resolve(fixtures, './entry/vite.config.import-attributes.ts'),
      path.resolve(fixtures, './entry'),
    ))!
    expect(config).toMatchInlineSnapshot(`
        {
          "jsonValue": "vite",
        }
      `)
  })

  test('import.meta.main is correctly set', async () => {
    const { config } = (await loadConfigFromFile(
      {} as any,
      path.resolve(fixtures, './import-meta/vite.config.ts'),
      path.resolve(fixtures, './import-meta'),
    ))!

    const c = config as any
    expect(c.isMain).toBe(false)
    expect(c.url).toContain('file://')
    expect(c.dirname).toContain('import-meta')
    expect(c.filename).toContain('vite.config.ts')
  })

  describe('loadConfigFromFile with configLoader: native', () => {
    const fixtureRoot = path.resolve(fixtures, './native-import')

    test('imports a basic js config', async () => {
      const result = (await loadConfigFromFile(
        {} as any,
        path.resolve(fixtureRoot, 'basic.js'),
        fixtureRoot,
        undefined,
        undefined,
        'native',
      ))!
      expect(result.config).toMatchInlineSnapshot(`
        {
          "value": "works",
        }
      `)
      expect(result.dependencies.length).toBe(0)
    })
  })
})



================================================
FILE: packages/vite/src/node/__tests__/constants.spec.ts
================================================
import { expect, test } from 'vitest'
import { defaultAllowedOrigins } from '../constants'

test('defaultAllowedOrigins', () => {
  const allowed = [
    'http://localhost',
    'http://foo.localhost',
    'http://localhost:3000',
    'https://localhost:3000',
    'http://127.0.0.1',
    'http://[::1]',
    'http://[::1]:3000',
  ]
  const denied = [
    'file:///foo',
    'http://localhost.example.com',
    'http://foo.example.com:localhost',
    'http://',
    'http://192.0.2',
    'http://[2001:db8::1]',
    'http://vite',
    'http://vite:3000',
  ]

  for (const origin of allowed) {
    expect(defaultAllowedOrigins.test(origin), origin).toBe(true)
  }

  for (const origin of denied) {
    expect(defaultAllowedOrigins.test(origin), origin).toBe(false)
  }
})



================================================
FILE: packages/vite/src/node/__tests__/dev.spec.ts
================================================
import { afterEach, describe, expect, test } from 'vitest'
import type { ResolvedServerUrls } from 'vite'
import { createServer, resolveConfig } from '..'
import type { ViteDevServer } from '..'
import { promiseWithResolvers } from '../../shared/utils'

describe('resolveBuildEnvironmentOptions in dev', () => {
  test('build.rollupOptions should not have input in lib', async () => {
    const config = await resolveConfig(
      {
        build: {
          lib: {
            entry: './index.js',
          },
        },
      },
      'serve',
    )

    expect(config.build.rollupOptions).not.toHaveProperty('input')
  })
})

describe('the dev server', () => {
  let server: ViteDevServer

  afterEach(() => {
    server?.close()
  })

  test('resolves the server URLs before the httpServer listening events are called', async () => {
    expect.assertions(1)

    const options = {
      port: 5013, // make sure the port is unique
    }

    const { promise, resolve } =
      promiseWithResolvers<ResolvedServerUrls | null>()
    server = await createServer({
      root: __dirname,
      logLevel: 'error',
      server: {
        strictPort: true,
        ws: false,
        ...options,
      },
      plugins: [
        {
          name: 'test',
          configureServer(server) {
            server.httpServer?.on('listening', () => {
              resolve(server.resolvedUrls)
            })
          },
        },
      ],
    })

    await server.listen()
    const urls = await promise

    expect(urls).toStrictEqual({
      local: ['http://localhost:5013/'],
      network: [],
    })
  })
})



================================================
FILE: packages/vite/src/node/__tests__/env.spec.ts
================================================
import { join } from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { loadEnv } from '../env'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

describe('loadEnv', () => {
  test('basic', () => {
    expect(loadEnv('development', join(__dirname, './env')))
      .toMatchInlineSnapshot(`
        {
          "VITE_APP_BASE_ROUTE": "/",
          "VITE_APP_BASE_URL": "/",
          "VITE_ENV1": "ENV1",
          "VITE_ENV2": "ENV2",
          "VITE_ENV3": "ENV3",
        }
      `)
  })

  test('specific prefix', () => {
    expect(loadEnv('development', join(__dirname, './env'), 'VVITE'))
      .toMatchInlineSnapshot(`
        {
          "VVITE_A": "A",
          "VVITE_B": "B",
        }
      `)
  })

  test('override', () => {
    expect(loadEnv('production', join(__dirname, './env')))
      .toMatchInlineSnapshot(`
        {
          "VITE_APP_BASE_ROUTE": "/app/",
          "VITE_APP_BASE_URL": "/app/",
        }
      `)
  })

  test('override 2', () => {
    expect(loadEnv('development2', join(__dirname, './env')))
      .toMatchInlineSnapshot(`
        {
          "VITE_APP_BASE_ROUTE": "source",
          "VITE_APP_BASE_URL": "source",
          "VITE_SOURCE": "source",
        }
      `)
  })

  test('VITE_USER_NODE_ENV', () => {
    loadEnv('development', join(__dirname, './env'))
    expect(process.env.VITE_USER_NODE_ENV).toEqual(undefined)
  })

  test('VITE_USER_NODE_ENV for dev behaviour in build', () => {
    const _nodeEnv = process.env.NODE_ENV
    process.env.NODE_ENV = 'production'
    loadEnv('testing', join(__dirname, './env'))
    expect(process.env.VITE_USER_NODE_ENV).toEqual('development')
    process.env.NODE_ENV = _nodeEnv
  })

  test('Already exists VITE_USER_NODE_ENV', () => {
    process.env.VITE_USER_NODE_ENV = 'test'
    loadEnv('development', join(__dirname, './env'))
    expect(process.env.VITE_USER_NODE_ENV).toEqual('test')
  })

  test('prioritize existing process.env', () => {
    process.env.VITE_ENV_TEST_ENV = 'EXIST'
    expect(loadEnv('existing', join(__dirname, './env')))
      .toMatchInlineSnapshot(`
        {
          "VITE_APP_BASE_ROUTE": "/",
          "VITE_APP_BASE_URL": "/",
          "VITE_ENV_TEST_ENV": "EXIST",
          "VITE_USER_NODE_ENV": "test",
        }
      `)
  })
})



================================================
FILE: packages/vite/src/node/__tests__/environment.spec.ts
================================================
import path from 'node:path'
import { describe, expect, onTestFinished, test } from 'vitest'
import type { RollupOutput } from 'rollup'
import { createServer } from '../server'
import type { InlineConfig } from '../config'
import { createBuilder } from '../build'
import { createServerModuleRunner } from '../ssr/runtime/serverModuleRunner'

describe('custom environment conditions', () => {
  function getConfig({
    noExternal,
  }: {
    noExternal: true | undefined
  }): InlineConfig {
    return {
      configFile: false,
      root: import.meta.dirname,
      logLevel: 'error',
      server: {
        middlewareMode: true,
        ws: false,
      },
      // disable scanner for client env to suppress scanner warnings
      optimizeDeps: { entries: [] },
      environments: {
        // default
        ssr: {
          resolve: {
            noExternal,
          },
          build: {
            outDir: path.join(
              import.meta.dirname,
              'fixtures/test-dep-conditions/dist/ssr',
            ),
            rollupOptions: {
              input: { index: '@vitejs/test-dep-conditions' },
            },
          },
        },
        // worker
        worker: {
          resolve: {
            noExternal,
            conditions: ['worker'],
            externalConditions: ['worker'],
          },
          build: {
            outDir: path.join(
              import.meta.dirname,
              'fixtures/test-dep-conditions/dist/worker',
            ),
            rollupOptions: {
              input: { index: '@vitejs/test-dep-conditions' },
            },
          },
        },
        // custom1
        custom1: {
          resolve: {
            noExternal,
            conditions: ['custom1'],
            externalConditions: ['custom1'],
          },
          build: {
            outDir: path.join(
              import.meta.dirname,
              'fixtures/test-dep-conditions/dist/custom1',
            ),
            rollupOptions: {
              input: { index: '@vitejs/test-dep-conditions' },
            },
          },
        },
        // same as custom1
        custom1_2: {
          resolve: {
            noExternal,
            conditions: ['custom1'],
            externalConditions: ['custom1'],
          },
          build: {
            outDir: path.join(
              import.meta.dirname,
              'fixtures/test-dep-conditions/dist/custom1_2',
            ),
            rollupOptions: {
              input: { index: '@vitejs/test-dep-conditions' },
            },
          },
        },
      },
    }
  }

  test('dev noExternal', async () => {
    const server = await createServer(getConfig({ noExternal: true }))
    onTestFinished(() => server.close())

    const results: Record<string, unknown> = {}
    for (const key of ['ssr', 'worker', 'custom1', 'custom1_2']) {
      const runner = createServerModuleRunner(server.environments[key], {
        hmr: {
          logger: false,
        },
        sourcemapInterceptor: false,
      })
      const mod = await runner.import('@vitejs/test-dep-conditions')
      results[key] = mod.default
    }
    expect(results).toMatchInlineSnapshot(`
      {
        "custom1": "index.custom1.js",
        "custom1_2": "index.custom1.js",
        "ssr": "index.default.js",
        "worker": "index.worker.js",
      }
    `)
  })

  test('dev external', async () => {
    const server = await createServer(getConfig({ noExternal: undefined }))
    onTestFinished(() => server.close())

    const results: Record<string, unknown> = {}
    for (const key of ['ssr', 'worker', 'custom1', 'custom1_2']) {
      const runner = createServerModuleRunner(server.environments[key], {
        hmr: {
          logger: false,
        },
        sourcemapInterceptor: false,
      })
      const mod = await runner.import(
        '/fixtures/test-dep-conditions-app/entry.js',
      )
      results[key] = mod.default
    }
    expect(results).toMatchInlineSnapshot(`
      {
        "custom1": "index.custom1.js",
        "custom1_2": "index.custom1.js",
        "ssr": "index.default.js",
        "worker": "index.worker.js",
      }
    `)
  })

  test('css', async () => {
    const server = await createServer(getConfig({ noExternal: true }))
    onTestFinished(() => server.close())

    const modJs = await server.ssrLoadModule(
      '/fixtures/test-dep-conditions-app/entry.js',
    )
    const modCss = await server.ssrLoadModule(
      '/fixtures/test-dep-conditions-app/entry.css?inline',
    )
    expect([modCss.default.replace(/\s+/g, ' '), modJs.default])
      .toMatchInlineSnapshot(`
      [
        ".test-css { color: orange; } ",
        "index.default.js",
      ]
    `)
  })

  test('build', async () => {
    const builder = await createBuilder(getConfig({ noExternal: true }))
    const results: Record<string, unknown> = {}
    for (const key of ['ssr', 'worker', 'custom1', 'custom1_2']) {
      const output = await builder.build(builder.environments[key])
      const chunk = (output as RollupOutput).output[0]
      const mod = await import(
        path.join(
          import.meta.dirname,
          'fixtures/test-dep-conditions/dist',
          key,
          chunk.fileName,
        )
      )
      results[key] = mod.default
    }
    expect(results).toMatchInlineSnapshot(`
      {
        "custom1": "index.custom1.js",
        "custom1_2": "index.custom1.js",
        "ssr": "index.default.js",
        "worker": "index.worker.js",
      }
    `)
  })
})



================================================
FILE: packages/vite/src/node/__tests__/external.spec.ts
================================================
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { resolveConfig } from '../config'
import { createIsConfiguredAsExternal } from '../external'
import { PartialEnvironment } from '../baseEnvironment'

describe('createIsConfiguredAsExternal', () => {
  test('default', async () => {
    const isExternal = await createIsExternal()
    expect(isExternal('@vitejs/cjs-ssr-dep')).toBe(false)
  })

  test('force external', async () => {
    const isExternal = await createIsExternal(true)
    expect(isExternal('@vitejs/cjs-ssr-dep')).toBe(true)
  })
})

async function createIsExternal(external?: true) {
  const resolvedConfig = await resolveConfig(
    {
      configFile: false,
      root: fileURLToPath(new URL('./', import.meta.url)),
      resolve: { external },
    },
    'serve',
  )
  const environment = new PartialEnvironment('ssr', resolvedConfig)
  return createIsConfiguredAsExternal(environment)
}



================================================
FILE: packages/vite/src/node/__tests__/package.json
================================================
{
  "name": "@vitejs/unit-ssr",
  "private": true,
  "version": "0.0.0",
  "dependencies": {
    "@vitejs/parent": "link:./packages/parent",
    "@vitejs/cjs-ssr-dep": "link:./fixtures/cjs-ssr-dep",
    "@vitejs/test-dep-conditions": "file:./fixtures/test-dep-conditions",
    "vue": "^3.5.18"
  }
}



================================================
FILE: packages/vite/src/node/__tests__/resolve.spec.ts
================================================
import { join } from 'node:path'
import { describe, expect, onTestFinished, test, vi } from 'vitest'
import { createServer } from '../server'
import { createServerModuleRunner } from '../ssr/runtime/serverModuleRunner'
import type { EnvironmentOptions, InlineConfig } from '../config'
import { build } from '../build'

describe('import and resolveId', () => {
  async function createTestServer() {
    const server = await createServer({
      configFile: false,
      root: import.meta.dirname,
      logLevel: 'error',
      server: {
        middlewareMode: true,
        ws: false,
      },
    })
    onTestFinished(() => server.close())
    const runner = createServerModuleRunner(server.environments.ssr, {
      hmr: {
        logger: false,
      },
      sourcemapInterceptor: false,
    })
    return { server, runner }
  }

  test('import first', async () => {
    const { server, runner } = await createTestServer()
    const mod = await runner.import(
      '/fixtures/test-dep-conditions-app/entry-with-module',
    )
    const resolved = await server.environments.ssr.pluginContainer.resolveId(
      '@vitejs/test-dep-conditions/with-module',
    )
    expect([mod.default, resolved?.id]).toEqual([
      'dir/index.default.js',
      expect.stringContaining('dir/index.module.js'),
    ])
  })

  test('resolveId first', async () => {
    const { server, runner } = await createTestServer()
    const resolved = await server.environments.ssr.pluginContainer.resolveId(
      '@vitejs/test-dep-conditions/with-module',
    )
    const mod = await runner.import(
      '/fixtures/test-dep-conditions-app/entry-with-module',
    )
    expect([mod.default, resolved?.id]).toEqual([
      'dir/index.default.js',
      expect.stringContaining('dir/index.module.js'),
    ])
  })
})

describe('file url', () => {
  const fileUrl = new URL('./fixtures/file-url/entry.js', import.meta.url)

  function getConfig(): InlineConfig {
    return {
      configFile: false,
      root: join(import.meta.dirname, 'fixtures/file-url'),
      logLevel: 'error',
      server: {
        middlewareMode: true,
      },
      plugins: [
        {
          name: 'virtual-file-url',
          resolveId(source) {
            if (source.startsWith('virtual:test-dep/')) {
              return '\0' + source
            }
          },
          load(id) {
            if (id === '\0virtual:test-dep/static') {
              return `
                import * as dep from ${JSON.stringify(fileUrl.href)};
                export default dep;
              `
            }
            if (id === '\0virtual:test-dep/static-postfix') {
              return `
                import * as dep from ${JSON.stringify(fileUrl.href + '?query=test')};
                export default dep;
              `
            }
            if (id === '\0virtual:test-dep/non-static') {
              return `
                const dep = await import(/* @vite-ignore */ String(${JSON.stringify(fileUrl.href)}));
                export default dep;
              `
            }
            if (id === '\0virtual:test-dep/non-static-postfix') {
              return `
                const dep = await import(/* @vite-ignore */ String(${JSON.stringify(fileUrl.href + '?query=test')}));
                export default dep;
              `
            }
          },
        },
      ],
    }
  }

  test('dev', async () => {
    const server = await createServer(getConfig())
    onTestFinished(() => server.close())

    const runner = createServerModuleRunner(server.environments.ssr, {
      hmr: {
        logger: false,
      },
      sourcemapInterceptor: false,
    })

    const mod = await runner.import('/entry.js')
    expect(mod.default).toEqual('ok')

    const mod2 = await runner.import(fileUrl.href)
    expect(mod2).toBe(mod)

    const mod3 = await runner.import('virtual:test-dep/static')
    expect(mod3.default).toBe(mod)

    const mod4 = await runner.import('virtual:test-dep/non-static')
    expect(mod4.default).toBe(mod)

    const mod5 = await runner.import(fileUrl.href + '?query=test')
    expect(mod5).toEqual(mod)
    expect(mod5).not.toBe(mod)

    const mod6 = await runner.import('virtual:test-dep/static-postfix')
    expect(mod6.default).toEqual(mod)
    expect(mod6.default).not.toBe(mod)
    expect(mod6.default).toBe(mod5)

    const mod7 = await runner.import('virtual:test-dep/non-static-postfix')
    expect(mod7.default).toEqual(mod)
    expect(mod7.default).not.toBe(mod)
    expect(mod7.default).toBe(mod5)
  })

  describe('environment builtins', () => {
    function getConfig(
      targetEnv: 'client' | 'ssr' | string,
      builtins: NonNullable<EnvironmentOptions['resolve']>['builtins'],
    ): InlineConfig {
      return {
        configFile: false,
        root: join(import.meta.dirname, 'fixtures/file-url'),
        logLevel: 'error',
        server: {
          middlewareMode: true,
        },
        environments: {
          [targetEnv]: {
            resolve: {
              builtins,
            },
          },
        },
      }
    }

    async function run({
      builtins,
      targetEnv = 'custom',
      testEnv = 'custom',
      idToResolve,
    }: {
      builtins?: NonNullable<EnvironmentOptions['resolve']>['builtins']
      targetEnv?: 'client' | 'ssr' | string
      testEnv?: 'client' | 'ssr' | string
      idToResolve: string
    }) {
      const server = await createServer(getConfig(targetEnv, builtins))
      vi.spyOn(server.config.logger, 'warn').mockImplementationOnce(
        (message) => {
          throw new Error(message)
        },
      )
      onTestFinished(() => server.close())

      return server.environments[testEnv]?.pluginContainer.resolveId(
        idToResolve,
      )
    }

    test('declared builtin string', async () => {
      const resolved = await run({
        builtins: ['my-env:custom-builtin'],
        idToResolve: 'my-env:custom-builtin',
      })
      expect(resolved?.external).toBe(true)
    })

    test('declared builtin regexp', async () => {
      const resolved = await run({
        builtins: [/^my-env:\w/],
        idToResolve: 'my-env:custom-builtin',
      })
      expect(resolved?.external).toBe(true)
    })

    test('non declared builtin', async () => {
      const resolved = await run({
        builtins: [
          /* empty */
        ],
        idToResolve: 'my-env:custom-builtin',
      })
      expect(resolved).toBeNull()
    })

    test('non declared node builtin', async () => {
      await expect(
        run({
          builtins: [
            /* empty */
          ],
          idToResolve: 'node:fs',
        }),
      ).rejects.toThrowError(
        /warning: Automatically externalized node built-in module "node:fs"/,
      )
    })

    test('default to node-like builtins', async () => {
      const resolved = await run({
        idToResolve: 'node:fs',
      })
      expect(resolved?.external).toBe(true)
    })

    test('default to node-like builtins for ssr environment', async () => {
      const resolved = await run({
        idToResolve: 'node:fs',
        testEnv: 'ssr',
      })
      expect(resolved?.external).toBe(true)
    })

    test('no default to node-like builtins for client environment', async () => {
      const resolved = await run({
        idToResolve: 'node:fs',
        testEnv: 'client',
      })
      expect(resolved?.id).toEqual('__vite-browser-external:node:fs')
    })

    test('no builtins overriding for client environment', async () => {
      const resolved = await run({
        idToResolve: 'node:fs',
        testEnv: 'client',
        targetEnv: 'client',
      })
      expect(resolved?.id).toEqual('__vite-browser-external:node:fs')
    })

    test('declared node builtin', async () => {
      const resolved = await run({
        builtins: [/^node:/],
        idToResolve: 'node:fs',
      })
      expect(resolved?.external).toBe(true)
    })

    test('declared builtin string in different environment', async () => {
      const resolved = await run({
        builtins: ['my-env:custom-builtin'],
        idToResolve: 'my-env:custom-builtin',
        targetEnv: 'custom',
        testEnv: 'ssr',
      })
      expect(resolved).toBe(null)
    })
  })

  test('build', async () => {
    await build({
      ...getConfig(),
      build: {
        ssr: true,
        outDir: 'dist/basic',
        rollupOptions: {
          input: { index: fileUrl.href },
        },
      },
    })
    const mod1 = await import(
      join(import.meta.dirname, 'fixtures/file-url/dist/basic/index.js')
    )
    expect(mod1.default).toBe('ok')

    await build({
      ...getConfig(),
      build: {
        ssr: true,
        outDir: 'dist/virtual',
        rollupOptions: {
          input: { index: 'virtual:test-dep/static' },
        },
      },
    })
    const mod2 = await import(
      join(import.meta.dirname, 'fixtures/file-url/dist/virtual/index.js')
    )
    expect(mod2.default.default).toBe('ok')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/runnerImport.spec.ts
================================================
import { resolve } from 'node:path'
import { describe, expect, test } from 'vitest'
import { loadConfigFromFile } from 'vite'
import { runnerImport } from '../ssr/runnerImport'
import { slash } from '../../shared/utils'

// eslint-disable-next-line n/no-unsupported-features/node-builtins
const isTypeStrippingSupported = !!process.features.typescript

describe('importing files using inlined environment', () => {
  const fixture = (name: string) =>
    resolve(import.meta.dirname, './fixtures/runner-import', name)

  test('importing a basic file works', async () => {
    const { module } = await runnerImport<
      typeof import('./fixtures/runner-import/basic')
    >(fixture('basic'))
    expect(module.test).toEqual({
      field: true,
    })
  })

  test("cannot import cjs, 'runnerImport' doesn't support CJS syntax at all", async () => {
    await expect(() =>
      runnerImport<typeof import('./fixtures/runner-import/basic')>(
        fixture('cjs.js'),
      ),
    ).rejects.toThrow('module is not defined')
  })

  test('can import vite config', async () => {
    const { module, dependencies } = await runnerImport<
      typeof import('./fixtures/runner-import/vite.config')
    >(fixture('vite.config'))
    expect(module.default).toEqual({
      root: './test',
      plugins: [
        {
          name: 'test',
        },
      ],
    })
    expect(dependencies).toEqual([slash(fixture('plugin.ts'))])
  })

  test('can import vite config that imports a TS external module', async () => {
    const { module, dependencies } = await runnerImport<
      typeof import('./fixtures/runner-import/vite.config.outside-pkg-import.mjs')
    >(fixture('vite.config.outside-pkg-import.mts'))

    expect(module.default.__injected).toBe(true)
    expect(dependencies).toEqual([
      slash(resolve(import.meta.dirname, './packages/parent/index.ts')),
    ])

    // confirm that it fails with a bundle approach
    if (!isTypeStrippingSupported) {
      await expect(async () => {
        const root = resolve(import.meta.dirname, './fixtures/runner-import')
        await loadConfigFromFile(
          { mode: 'production', command: 'serve' },
          resolve(root, './vite.config.outside-pkg-import.mts'),
          root,
          'silent',
        )
      }).rejects.toThrow('Unknown file extension ".ts"')
    }
  })

  test('dynamic import', async () => {
    const { module } = await runnerImport<any>(fixture('dynamic-import.ts'))
    await expect(() => module.default()).rejects.toMatchInlineSnapshot(
      `[Error: Vite module runner has been closed.]`,
    )
    // const dep = await module.default();
    // expect(dep.default).toMatchInlineSnapshot(`"ok"`)
  })
})



================================================
FILE: packages/vite/src/node/__tests__/scan.spec.ts
================================================
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { commentRE, importsRE, scriptRE } from '../optimizer/scan'
import { multilineCommentsRE, singlelineCommentsRE } from '../utils'
import { createServer, createServerModuleRunner } from '..'

describe('optimizer-scan:script-test', () => {
  const scriptContent = `import { defineComponent } from 'vue'
      import ScriptDevelopPane from './ScriptDevelopPane.vue';
      export default defineComponent({
        components: {
          ScriptDevelopPane
        }
      })`

  test('component return value test', () => {
    scriptRE.lastIndex = 0
    const [, tsOpenTag, tsContent] = scriptRE.exec(
      `<script lang="ts">${scriptContent}</script>`,
    )!
    expect(tsOpenTag).toEqual('<script lang="ts">')
    expect(tsContent).toEqual(scriptContent)

    scriptRE.lastIndex = 0
    const [, openTag, content] = scriptRE.exec(
      `<script>${scriptContent}</script>`,
    )!
    expect(openTag).toEqual('<script>')
    expect(content).toEqual(scriptContent)
  })

  test('include comments test', () => {
    scriptRE.lastIndex = 0
    const ret = scriptRE.exec(
      `<template>
        <!--  <script >var test1 = null</script> -->
        <!--  <script >var test2 = null</script> -->
      </template>`.replace(commentRE, ''),
    )
    expect(ret).toEqual(null)
  })

  test('components with script keyword test', () => {
    scriptRE.lastIndex = 0
    let ret = scriptRE.exec(`<template><script-develop-pane/></template>`)
    expect(ret).toBe(null)

    scriptRE.lastIndex = 0
    ret = scriptRE.exec(
      `<template><script-develop-pane></script-develop-pane></template>`,
    )
    expect(ret).toBe(null)

    scriptRE.lastIndex = 0
    ret = scriptRE.exec(
      `<template><script-develop-pane  > content </script-develop-pane></template>`,
    )
    expect(ret).toBe(null)
  })

  test('ordinary script tag test', () => {
    scriptRE.lastIndex = 0
    const [, tag, content] = scriptRE.exec(
      `<script  >var test = null</script>`,
    )!
    expect(tag).toEqual('<script  >')
    expect(content).toEqual('var test = null')

    scriptRE.lastIndex = 0
    const [, tag1, content1] = scriptRE.exec(
      `<script>var test = null</script>`,
    )!
    expect(tag1).toEqual('<script>')
    expect(content1).toEqual('var test = null')
  })

  test('imports regex should work', () => {
    const shouldMatchArray = [
      `import 'vue'`,
      `import { foo } from 'vue'`,
      `import foo from 'vue'`,
      `;import foo from 'vue'`,
      `   import foo from 'vue'`,
      `import { foo
      } from 'vue'`,
      `import bar, { foo } from 'vue'`,
      `import foo from 'vue';`,
      `*/ import foo from 'vue';`,
      `import foo from 'vue';//comment`,
      `import foo from 'vue';/*comment
      */`,
      // Skipped, false negatives with current regex
      // `import typescript from 'typescript'`,
      // import type, {foo} from 'vue'
    ]

    shouldMatchArray.forEach((str) => {
      importsRE.lastIndex = 0
      expect(importsRE.exec(str)![1]).toEqual("'vue'")
    })

    const shouldFailArray = [
      `testMultiline("import", {
        body: "ok" });`,
      `//;import foo from 'vue'`,
      `import type { Bar } from 'foo'`,
      `import type{ Bar } from 'foo'`,
      `import type Bar from 'foo'`,
    ]
    shouldFailArray.forEach((str) => {
      importsRE.lastIndex = 0
      expect(importsRE.test(str)).toBe(false)
    })
  })

  test('script comments test', () => {
    multilineCommentsRE.lastIndex = 0
    let ret = `/*
      export default { }
      */`.replace(multilineCommentsRE, '')
    expect(ret).not.toContain('export default')

    singlelineCommentsRE.lastIndex = 0
    ret = `//export default { }`.replace(singlelineCommentsRE, '')
    expect(ret).not.toContain('export default')
  })
})

test('scan jsx-runtime', async (ctx) => {
  const server = await createServer({
    configFile: false,
    logLevel: 'error',
    root: path.join(import.meta.dirname, 'fixtures', 'scan-jsx-runtime'),
    environments: {
      client: {
        // silence client optimizer
        optimizeDeps: {
          noDiscovery: true,
        },
      },
      ssr: {
        resolve: {
          noExternal: true,
        },
        optimizeDeps: {
          force: true,
          noDiscovery: false,
          entries: ['./entry-jsx.tsx', './entry-no-jsx.js'],
        },
      },
    },
  })

  // start server to ensure optimizer run
  await server.listen()
  ctx.onTestFinished(() => server.close())

  const runner = createServerModuleRunner(server.environments.ssr, {
    hmr: { logger: false },
  })

  // flush initial optimizer by importing any file
  await runner.import('./entry-no-jsx.js')

  // verify jsx won't trigger optimizer re-run
  const mod1 = await runner.import('./entry-jsx.js')
  const mod2 = await runner.import('./entry-jsx.js')
  expect((globalThis as any).__test_scan_jsx_runtime).toBe(1)
  expect(mod1).toBe(mod2)
})



================================================
FILE: packages/vite/src/node/__tests__/utils.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import crypto from 'node:crypto'
import { describe, expect, test } from 'vitest'
import { fileURLToPath } from 'mlly'
import {
  asyncFlatten,
  bareImportRE,
  combineSourcemaps,
  extractHostnamesFromSubjectAltName,
  flattenId,
  generateCodeFrame,
  getHash,
  getLocalhostAddressIfDiffersFromDNS,
  getServerUrlByHost,
  injectQuery,
  isFileReadable,
  mergeWithDefaults,
  normalizePath,
  numberToPos,
  posToNumber,
  processSrcSetSync,
  resolveHostname,
} from '../utils'
import { isWindows } from '../../shared/utils'
import type { CommonServerOptions, ResolvedServerUrls } from '..'

describe('bareImportRE', () => {
  test('should work with normal package name', () => {
    expect(bareImportRE.test('vite')).toBe(true)
  })
  test('should work with scoped package name', () => {
    expect(bareImportRE.test('@vitejs/plugin-vue')).toBe(true)
  })

  test('should work with absolute paths', () => {
    expect(bareImportRE.test('/foo')).toBe(false)
    expect(bareImportRE.test('C:/foo')).toBe(false)
    expect(bareImportRE.test('C:\\foo')).toBe(false)
  })
  test('should work with relative path', () => {
    expect(bareImportRE.test('./foo')).toBe(false)
    expect(bareImportRE.test('.\\foo')).toBe(false)
  })
})

describe('injectQuery', () => {
  if (isWindows) {
    // this test will work incorrectly on unix systems
    test('normalize windows path', () => {
      expect(injectQuery('C:\\User\\Vite\\Project', 'direct')).toEqual(
        'C:/User/Vite/Project?direct',
      )
    })

    test('absolute file path', () => {
      expect(injectQuery('C:\\test-file.vue', 'direct')).toEqual(
        'C:/test-file.vue?direct',
      )
    })

    test('absolute file path with parameters', () => {
      expect(
        injectQuery('C:\\test-file.vue?vue&type=template&lang.js', 'direct'),
      ).toEqual('C:/test-file.vue?direct&vue&type=template&lang.js')
    })
  }

  test('relative path', () => {
    expect(injectQuery('usr/vite/%20a%20', 'direct')).toEqual(
      'usr/vite/%20a%20?direct',
    )
    expect(injectQuery('./usr/vite/%20a%20', 'direct')).toEqual(
      './usr/vite/%20a%20?direct',
    )
    expect(injectQuery('../usr/vite/%20a%20', 'direct')).toEqual(
      '../usr/vite/%20a%20?direct',
    )
  })

  test('path with hash', () => {
    expect(injectQuery('/usr/vite/path with space/#1?2/', 'direct')).toEqual(
      '/usr/vite/path with space/?direct#1?2/',
    )
  })

  test('path with protocol', () => {
    expect(injectQuery('file:///usr/vite/%20a%20', 'direct')).toMatch(
      'file:///usr/vite/%20a%20?direct',
    )
    expect(injectQuery('http://usr.vite/%20a%20', 'direct')).toMatch(
      'http://usr.vite/%20a%20?direct',
    )
  })

  test('path with multiple spaces', () => {
    expect(injectQuery('/usr/vite/path with space', 'direct')).toEqual(
      '/usr/vite/path with space?direct',
    )
  })

  test('path with multiple % characters', () => {
    expect(injectQuery('/usr/vite/not%20a%20space', 'direct')).toEqual(
      '/usr/vite/not%20a%20space?direct',
    )
  })

  test('path with %25', () => {
    expect(injectQuery('/usr/vite/%25hello%25', 'direct')).toEqual(
      '/usr/vite/%25hello%25?direct',
    )
  })

  test('path with Unicode', () => {
    expect(injectQuery('/usr/vite/東京', 'direct')).toEqual(
      '/usr/vite/東京?direct',
    )
  })

  test('path with Unicode, space, and %', () => {
    expect(injectQuery('/usr/vite/東京 %20 hello', 'direct')).toEqual(
      '/usr/vite/東京 %20 hello?direct',
    )
  })

  test('path with url-encoded path as query parameter', () => {
    const src = '/src/module.ts?url=https%3A%2F%2Fusr.vite%2F'
    const expected = '/src/module.ts?t=1234&url=https%3A%2F%2Fusr.vite%2F'
    expect(injectQuery(src, 't=1234')).toEqual(expected)
  })
})

describe('resolveHostname', () => {
  test('defaults to localhost', async () => {
    const resolved = await getLocalhostAddressIfDiffersFromDNS()

    expect(await resolveHostname(undefined)).toEqual({
      host: 'localhost',
      name: resolved ?? 'localhost',
    })
  })

  test('accepts localhost', async () => {
    const resolved = await getLocalhostAddressIfDiffersFromDNS()

    expect(await resolveHostname('localhost')).toEqual({
      host: 'localhost',
      name: resolved ?? 'localhost',
    })
  })

  test('accepts 0.0.0.0', async () => {
    expect(await resolveHostname('0.0.0.0')).toEqual({
      host: '0.0.0.0',
      name: 'localhost',
    })
  })

  test('accepts ::', async () => {
    expect(await resolveHostname('::')).toEqual({
      host: '::',
      name: 'localhost',
    })
  })

  test('accepts 0000:0000:0000:0000:0000:0000:0000:0000', async () => {
    expect(
      await resolveHostname('0000:0000:0000:0000:0000:0000:0000:0000'),
    ).toEqual({
      host: '0000:0000:0000:0000:0000:0000:0000:0000',
      name: 'localhost',
    })
  })
})

describe('extractHostnamesFromSubjectAltName', () => {
  const testCases = [
    ['DNS:localhost', ['localhost']],
    ['DNS:localhost, DNS:foo.localhost', ['localhost', 'foo.localhost']],
    ['DNS:*.localhost', ['vite.localhost']],
    ['DNS:[::1]', []], // [::1] is skipped
    ['DNS:*.192.168.0.152, DNS:192.168.0.152', ['192.168.0.152']], // *.192.168.0.152 is skipped
    ['othername:"foo,bar", DNS:localhost', ['localhost']], // handle quoted correctly
  ] as const

  for (const [input, expected] of testCases) {
    test(`should extract names from subjectAltName: ${input}`, () => {
      expect(extractHostnamesFromSubjectAltName(input)).toStrictEqual(expected)
    })
  }

  test('should extract names from actual certificate', () => {
    const certText = `
-----BEGIN CERTIFICATE-----
MIID7zCCAtegAwIBAgIJS9D2rIN7tA8mMA0GCSqGSIb3DQEBCwUAMGkxFDASBgNV
BAMTC2V4YW1wbGUub3JnMQswCQYDVQQGEwJVUzERMA8GA1UECBMIVmlyZ2luaWEx
EzARBgNVBAcTCkJsYWNrc2J1cmcxDTALBgNVBAoTBFRlc3QxDTALBgNVBAsTBFRl
c3QwHhcNMjUwMTMwMDQxNTI1WhcNMjUwMzAxMDQxNTI1WjBpMRQwEgYDVQQDEwtl
eGFtcGxlLm9yZzELMAkGA1UEBhMCVVMxETAPBgNVBAgTCFZpcmdpbmlhMRMwEQYD
VQQHEwpCbGFja3NidXJnMQ0wCwYDVQQKEwRUZXN0MQ0wCwYDVQQLEwRUZXN0MIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxNPlCqTmUZ7/F7GyFWDopqZ6
w19Y7/98B10JEeFGTAQIj/RP2UgZNcTABQDUvtkF7y+bOeoVJW7Zz8ozQYhRaDp8
CN2gXMcYeTUku/pKLXyCzHHVrOPAXTeU7sMRgLvPCrrJtx5OjvndW+O/PhohPRi3
iEpPvpM8gi7MVRGhnWVSx0/Ynx5c0+/vqyBTzrM2OX7Ufg8Nv7LaTXpCAnmIQp+f
Sqq7HZ7t6Y7laS4RApityvlnFHZ4f2cEibAKv/vXLED7bgAlGb8R1viPRdMtAPuI
MYvHBgGFjyX1fmq6Mz3aqlAscJILtbQlwty1oYyaENE0lq8+nZXQ+t6I+CIVLQID
AQABo4GZMIGWMAsGA1UdDwQEAwIC9DAxBgNVHSUEKjAoBggrBgEFBQcDAQYIKwYB
BQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDBUBgNVHREETTBLgglsb2NhbGhvc3SC
DWZvby5sb2NhbGhvc3SCECoudml0ZS5sb2NhbGhvc3SCBVs6OjFdhwR/AAABhxD+
gAAAAAAAAAAAAAAAAAABMA0GCSqGSIb3DQEBCwUAA4IBAQBi302qLCgxWsUalgc2
olFxVKob1xCciS8yUVX6HX0vza0WJ7oGW6qZsBbQtfgDwB/dHv7rwsfpjRWvFhmq
gEUrewa1h0TIC+PPTYYz4M0LOwcLIWZLZr4am1eI7YP9NDgRdhfAfM4hw20vjf2a
kYLKyRTC5+3/ly5opMq+CGLQ8/gnFxhP3ho8JYrRnqLeh3KCTGen3kmbAhD4IOJ9
lxMwFPTTWLFFjxbXjXmt5cEiL2mpcq13VCF2HmheCen37CyYIkrwK9IfLhBd5QQh
WEIBLwjKCAscrtyayXWp6zUTmgvb8PQf//3Mh2DiEngAi3WI/nL+8Y0RkqbvxBar
X2JN
-----END CERTIFICATE-----
    `.trim()
    const cert = new crypto.X509Certificate(certText)
    expect(
      extractHostnamesFromSubjectAltName(cert.subjectAltName ?? ''),
    ).toStrictEqual([
      'localhost',
      'foo.localhost',
      'vite.vite.localhost', // *.vite.localhost
    ])
  })
})

describe('posToNumber', () => {
  test('simple', () => {
    const actual = posToNumber('a\nb', { line: 2, column: 0 })
    expect(actual).toBe(2)
  })
  test('pass though pos', () => {
    const actual = posToNumber('a\nb', 2)
    expect(actual).toBe(2)
  })
  test('empty line', () => {
    const actual = posToNumber('a\n\nb', { line: 3, column: 0 })
    expect(actual).toBe(3)
  })
  test('out of range', () => {
    const actual = posToNumber('a\nb', { line: 4, column: 0 })
    expect(actual).toBe(4)
  })
})

describe('numberToPos', () => {
  test('simple', () => {
    const actual = numberToPos('a\nb', 2)
    expect(actual).toEqual({ line: 2, column: 0 })
  })
  test('pass though pos', () => {
    const actual = numberToPos('a\nb', { line: 2, column: 0 })
    expect(actual).toEqual({ line: 2, column: 0 })
  })
  test('empty line', () => {
    const actual = numberToPos('a\n\nb', 3)
    expect(actual).toEqual({ line: 3, column: 0 })
  })
  test('middle of line', () => {
    const actual = numberToPos('abc\ndef', 5)
    expect(actual).toEqual({ line: 2, column: 1 })
  })
  test('end of line', () => {
    const actual = numberToPos('abc\ndef', 3)
    expect(actual).toEqual({ line: 1, column: 3 })
  })
  test('out of range', () => {
    expect(() => numberToPos('a\nb', 5)).toThrowError(
      'offset is longer than source length',
    )
  })
})

describe('generateCodeFrames', () => {
  const source = `
import foo from './foo'
foo()
`.trim()
  const sourceCrLf = source.replaceAll('\n', '\r\n')
  const longSource = `
import foo from './foo'

foo()
// 1
// 2
// 3
`.trim()
  const veryLongSource = Array.from({ length: 2000 }, (_, i) => `// ${i}`).join(
    '\n',
  )

  const expectSnapshot = (value: string) => {
    try {
      // add new line to make snapshot easier to read
      expect('\n' + value + '\n').toMatchSnapshot()
    } catch (e) {
      // don't include this function in stacktrace
      Error.captureStackTrace(e, expectSnapshot)
      throw e
    }
  }

  test('start with number', () => {
    expectSnapshot(generateCodeFrame(source, -1))
    expectSnapshot(generateCodeFrame(source, 0))
    expectSnapshot(generateCodeFrame(source, 1))
    expectSnapshot(generateCodeFrame(source, 24))
  })

  test('start with position', () => {
    expectSnapshot(generateCodeFrame(source, { line: 1, column: 0 }))
    expectSnapshot(generateCodeFrame(source, { line: 1, column: 1 }))
    expectSnapshot(generateCodeFrame(source, { line: 2, column: 0 }))
  })

  test('works with CRLF', () => {
    expectSnapshot(generateCodeFrame(sourceCrLf, { line: 2, column: 0 }))
  })

  test('end', () => {
    expectSnapshot(generateCodeFrame(source, 0, 0))
    expectSnapshot(generateCodeFrame(source, 0, 23))
    expectSnapshot(generateCodeFrame(source, 0, 29))
    expectSnapshot(generateCodeFrame(source, 0, source.length))
    expectSnapshot(generateCodeFrame(source, 0, source.length + 1))
    expectSnapshot(generateCodeFrame(source, 0, source.length + 100))
  })

  test('range', () => {
    expectSnapshot(generateCodeFrame(longSource, { line: 3, column: 0 }))
    expectSnapshot(
      generateCodeFrame(
        longSource,
        { line: 3, column: 0 },
        { line: 4, column: 0 },
      ),
    )
  })

  test('invalid start > end', () => {
    expectSnapshot(generateCodeFrame(source, 2, 0))
  })

  test('supports more than 1000 lines', () => {
    expectSnapshot(generateCodeFrame(veryLongSource, { line: 1200, column: 0 }))
  })
})

describe('getHash', () => {
  test('8-digit hex', () => {
    const hash = getHash(Buffer.alloc(0))
    expect(hash).toMatch(/^[\da-f]{8}$/)
  })
})

describe('asyncFlatten', () => {
  test('plain array', async () => {
    const arr = await asyncFlatten([1, 2, 3])
    expect(arr).toEqual([1, 2, 3])
  })

  test('nested array', async () => {
    const arr = await asyncFlatten([1, 2, 3, [4, 5, 6]])
    expect(arr).toEqual([1, 2, 3, 4, 5, 6])
  })

  test('nested falsy array', async () => {
    const arr = await asyncFlatten([1, 2, false, [4, null, undefined]])
    expect(arr).toEqual([1, 2, false, 4, null, undefined])
  })

  test('plain promise array', async () => {
    const arr = await asyncFlatten([1, 2, Promise.resolve(3)])
    expect(arr).toEqual([1, 2, 3])
  })

  test('nested promise array', async () => {
    const arr = await asyncFlatten([
      1,
      2,
      Promise.resolve(3),
      Promise.resolve([4, 5, 6]),
    ])
    expect(arr).toEqual([1, 2, 3, 4, 5, 6])
  })

  test('2x nested promise array', async () => {
    const arr = await asyncFlatten([
      1,
      2,
      Promise.resolve(3),
      Promise.resolve([4, 5, Promise.resolve(6), Promise.resolve([7, 8, 9])]),
    ])
    expect(arr).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9])
  })
})

describe('isFileReadable', () => {
  test("file doesn't exist", async () => {
    expect(isFileReadable('/does_not_exist')).toBe(false)
  })

  const testFile = require.resolve(
    './utils/isFileReadable/permission-test-file',
  )
  test('file with normal permission', async () => {
    expect(isFileReadable(testFile)).toBe(true)
  })

  if (process.platform !== 'win32') {
    test('file with read-only permission', async () => {
      fs.chmodSync(testFile, '400')
      expect(isFileReadable(testFile)).toBe(true)
    })
    test.runIf(process.getuid && process.getuid() !== 0)(
      'file without read permission',
      async () => {
        fs.chmodSync(testFile, '044')
        expect(isFileReadable(testFile)).toBe(false)
        fs.chmodSync(testFile, '644')
      },
    )
  }
})

describe('processSrcSetSync', () => {
  test('prepend base URL to srcset', async () => {
    const devBase = '/base/'
    expect(
      processSrcSetSync(
        './nested/asset.png 1x, ./nested/asset.png 2x',
        ({ url }) => path.posix.join(devBase, url),
      ),
    ).toBe('/base/nested/asset.png 1x, /base/nested/asset.png 2x')
  })

  test('prepend base URL to srcset 2', async () => {
    const devBase = '/base/'
    expect(
      processSrcSetSync(
        './nested/asset.png 1x,./nested/asset.png 2x',
        ({ url }) => path.posix.join(devBase, url),
      ),
    ).toBe('/base/nested/asset.png 1x, /base/nested/asset.png 2x')
  })

  test('prepend base URL to srcset 3', async () => {
    const devBase = '/base/'
    expect(
      processSrcSetSync(
        '"./nested/asset.png" 1x,"./nested/asset.png" 2x',
        ({ url }) => `"${path.posix.join(devBase, url.slice(1, -1))}"`,
      ),
    ).toBe('"/base/nested/asset.png" 1x, "/base/nested/asset.png" 2x')
  })

  test('should not split the comma inside base64 value', async () => {
    const base64 =
      'data:image/avif;base64,aA+/0= 400w, data:image/avif;base64,bB+/9= 800w'
    expect(processSrcSetSync(base64, ({ url }) => url)).toBe(base64)
  })

  test('should not split the comma inside image URI', async () => {
    const imageURIWithComma =
      'asset.png?param1=true,param2=false 400w, asset.png?param1=true,param2=false 800w'
    expect(processSrcSetSync(imageURIWithComma, ({ url }) => url)).toBe(
      imageURIWithComma,
    )
  })

  test('should handle srcset when descriptor is not present', async () => {
    const srcsetNoDescriptor = 'asset.png, test.png 400w'
    const result = 'asset.png, test.png 400w'
    expect(processSrcSetSync(srcsetNoDescriptor, ({ url }) => url)).toBe(result)
  })

  test('should not break a regular URL in srcSet', async () => {
    const source = 'https://anydomain/image.jpg'
    expect(
      processSrcSetSync('https://anydomain/image.jpg', ({ url }) => url),
    ).toBe(source)
  })

  test('should not break URLs with commas in srcSet', async () => {
    const source = `
      \thttps://example.com/dpr_1,f_auto,fl_progressive,q_auto,w_100/v1/img   1x,
      \thttps://example.com/dpr_2,f_auto,fl_progressive,q_auto,w_100/v1/img\t\t2x
    `
    const result =
      'https://example.com/dpr_1,f_auto,fl_progressive,q_auto,w_100/v1/img 1x, https://example.com/dpr_2,f_auto,fl_progressive,q_auto,w_100/v1/img 2x'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should not break URLs with commas in image-set-options', async () => {
    const source = `url(https://example.com/dpr_1,f_auto,fl_progressive,q_auto,w_100/v1/img)   1x,
      url("https://example.com/dpr_2,f_auto,fl_progressive,q_auto,w_100/v1/img")\t\t2x
    `
    const result =
      'url(https://example.com/dpr_1,f_auto,fl_progressive,q_auto,w_100/v1/img) 1x, url("https://example.com/dpr_2,f_auto,fl_progressive,q_auto,w_100/v1/img") 2x'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should parse image-set-options with resolution', async () => {
    const source = ` "foo.png" 1x,
                     "foo-2x.png" 2x,
                     "foo-print.png" 600dpi`
    const result = '"foo.png" 1x, "foo-2x.png" 2x, "foo-print.png" 600dpi'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should parse image-set-options with type', async () => {
    const source = ` "foo.avif" type("image/avif"),
                     "foo.jpg" type("image/jpeg") `
    const result = '"foo.avif" type("image/avif"), "foo.jpg" type("image/jpeg")'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should parse image-set-options with linear-gradient', async () => {
    const source = `linear-gradient(cornflowerblue, white) 1x,
                    url("detailed-gradient.png") 3x`
    const result =
      'linear-gradient(cornflowerblue, white) 1x, url("detailed-gradient.png") 3x'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should parse image-set-options with resolution and type specified', async () => {
    const source = `url("picture.png")\t1x\t type("image/jpeg"), url("picture.png")\t type("image/jpeg")\t2x`
    const result =
      'url("picture.png") 1x type("image/jpeg"), url("picture.png") type("image/jpeg") 2x'
    expect(processSrcSetSync(source, ({ url }) => url)).toBe(result)
  })

  test('should capture whole image set options', async () => {
    const source = `linear-gradient(cornflowerblue, white) 1x,
                    url("detailed-gradient.png") 3x`
    const expected = [
      'linear-gradient(cornflowerblue, white)',
      'url("detailed-gradient.png")',
    ]
    const result: string[] = []
    processSrcSetSync(source, ({ url }) => {
      result.push(url)
      return url
    })
    expect(result).toEqual(expected)
  })
})

describe('flattenId', () => {
  test('should limit id to 170 characters', () => {
    const tenChars = '1234567890'
    let id = ''

    for (let i = 0; i < 17; i++) {
      id += tenChars
    }
    expect(id).toHaveLength(170)

    const result = flattenId(id)
    expect(result).toHaveLength(170)

    id += tenChars
    const result2 = flattenId(id)
    expect(result2).toHaveLength(170)
  })
})

describe('mergeWithDefaults', () => {
  test('merges with defaults', () => {
    const actual = mergeWithDefaults(
      {
        useDefault: 1,
        useValueIfNull: 2,
        replaceArray: [0, 1],
        nested: {
          foo: 'bar',
        },
      },
      {
        useDefault: undefined,
        useValueIfNull: null,
        useValueIfNoDefault: 'foo',
        replaceArray: [2, 3],
        nested: {
          foo2: 'bar2',
        },
      },
    )
    expect(actual).toStrictEqual({
      useDefault: 1,
      useValueIfNull: null,
      useValueIfNoDefault: 'foo',
      replaceArray: [2, 3],
      nested: {
        foo: 'bar',
        foo2: 'bar2',
      },
    })

    const defaults = {
      object: {},
      array: [],
      regex: /foo/,
      function: () => {},
    }
    const actual2 = mergeWithDefaults(defaults, {})
    expect(actual2.object).toStrictEqual({})
    expect(actual2.array).toStrictEqual([])
    expect(actual2.regex).toStrictEqual(/foo/)
    expect(actual2.function).toStrictEqual(expect.any(Function))
    // cloned
    expect(actual2.object).not.toBe(defaults.object)
    expect(actual2.array).not.toBe(defaults.array)
  })
})

describe('combineSourcemaps', () => {
  const _dirname = path.dirname(fileURLToPath(import.meta.url))
  const resolveFile = (file: string) => {
    return normalizePath(path.resolve(_dirname, file))
  }

  test('should combine sourcemaps with single sources', () => {
    const sourcemaps = [
      // processed with magic-string
      // https://evanw.github.io/source-map-visualization/#MzQALyogY29tbWVudCAqLwpjb25zb2xlLmxvZygiZm9vIik7CjE1NgB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiL3NyYy9mb28uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc29sZS5sb2coXCJmb29cIik7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzsifQo=
      {
        version: 3 as const,
        mappings: ';AAAA,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;',
        names: [],
        sources: [resolveFile('./src/foo.js')],
      },
      // processed with esbuild
      // https://evanw.github.io/source-map-visualization/#MjAAY29uc29sZS5sb2coImZvbyIpOwoxNDgAewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL3NyYy9mb28uanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNvbnNvbGUubG9nKFwiZm9vXCIpIl0sCiAgIm1hcHBpbmdzIjogIkFBQUEsUUFBUSxJQUFJLEtBQUs7IiwKICAibmFtZXMiOiBbXQp9Cg==
      {
        version: 3 as const,
        mappings: 'AAAA,QAAQ,IAAI,KAAK;',
        names: [],
        sources: [resolveFile('./src/foo.js')],
      },
    ]
    const combined = combineSourcemaps(resolveFile('./src/foo.js'), sourcemaps)
    expect(combined).toStrictEqual(
      expect.objectContaining({
        version: 3,
        file: resolveFile('./src/foo.js'),
        mappings: ';AAAA,QAAQ,IAAI,KAAK',
        sources: [resolveFile('./src/foo.js')],
      }),
    )
  })

  test('should combine sourcemaps with multiple sources', () => {
    const sourcemaps = [
      // processed with magic-string
      // https://evanw.github.io/source-map-visualization/#NzcALyogY29tbWVudCAqLwovLyBiLmpzCmNvbnNvbGUubG9nKCIuL2IuanMiKTsKCi8vIGEuanMKY29uc29sZS5sb2coIi4vYS5qcyIpOwozMzkAeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9hLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGIuanNcbmNvbnNvbGUubG9nKFwiLi9iLmpzXCIpO1xuXG4vLyBhLmpzXG5jb25zb2xlLmxvZyhcIi4vYS5qc1wiKTtcblxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7O0FBRXJCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7In0K
      {
        version: 3 as const,
        mappings:
          ';AAAA,CAAC,CAAC,CAAC,CAAC,CAAC;OACE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;;AAErB,CAAC,CAAC,CAAC,CAAC,CAAC;OACE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;;',
        names: [],
        sources: [resolveFile('./src/a.js')],
      },
      // processed with esbuild
      // https://evanw.github.io/source-map-visualization/#NjMALy8gYi5qcwpjb25zb2xlLmxvZygiLi9iLmpzIik7CgovLyBhLmpzCmNvbnNvbGUubG9nKCIuL2EuanMiKTsKMjIwAHsKICAidmVyc2lvbiI6IDMsCiAgInNvdXJjZXMiOiBbImIuanMiLCAiYS5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiY29uc29sZS5sb2coJy4vYi5qcycpXG4iLCAiaW1wb3J0ICcuL2IuanMnXG5jb25zb2xlLmxvZygnLi9hLmpzJylcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxRQUFRLElBQUksUUFBUTs7O0FDQ3BCLFFBQVEsSUFBSSxRQUFROyIsCiAgIm5hbWVzIjogW10KfQo=
      {
        version: 3 as const,
        mappings: ';AAAA,QAAQ,IAAI,QAAQ;;;ACCpB,QAAQ,IAAI,QAAQ;',
        names: [],
        sources: [resolveFile('./src/b.js'), resolveFile('./src/a.js')],
      },
    ]
    const combined = combineSourcemaps(resolveFile('./src/a.js'), sourcemaps)
    expect(combined).toStrictEqual(
      expect.objectContaining({
        version: 3,
        file: resolveFile('./src/a.js'),
        mappings: ';;OAAA,CAAQ,IAAI,QAAQ;;;OCCpB,CAAQ,IAAI,QAAQ',
        sources: [resolveFile('./src/b.js'), resolveFile('./src/a.js')],
      }),
    )
  })

  test('should combine sourcemaps with multiple sources 2', () => {
    const sourcemaps = [
      // processed with sass
      // https://evanw.github.io/source-map-visualization/#NTYALmltcG9ydGVkMiB7CiAgY29sb3I6IHJlZAp9CgouaW1wb3J0ZWQgewogIGNvbG9yOiByZWQKfQoyNzAAewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsKICAgICIvaW1wb3J0ZWQyLnNhc3MiLAogICAgIi9Gb28udnVlIgogIF0sCiAgIm5hbWVzIjogW10sCiAgIm1hcHBpbmdzIjogIkFBQUE7RUFDRTs7O0FDRUY7RUFDRSIsCiAgImZpbGUiOiAiL0Zvby52dWUiLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICIuaW1wb3J0ZWQyXG4gIGNvbG9yOiByZWRcbiIsCiAgICAiXG5AdXNlICcuL2ltcG9ydGVkMidcblxuLmltcG9ydGVkXG4gIGNvbG9yOiByZWRcbiIKICBdCn0K
      {
        version: 3 as const,
        file: resolveFile('./src/Foo.vue'),
        mappings: 'AAAA;EACE;;;ACEF;EACE',
        names: [],
        sources: [
          resolveFile('./src/imported2.sass'),
          resolveFile('./src/Foo.vue'),
        ],
      },
      // processed with vue
      // https://evanw.github.io/source-map-visualization/#NDQACkB1c2UgJy4vaW1wb3J0ZWQyJwoKLmltcG9ydGVkCiAgY29sb3I6IHJlZAo0OTQAewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsKICAgICIvRm9vLnZ1ZSIKICBdLAogICJuYW1lcyI6IFtdLAogICJtYXBwaW5ncyI6ICI7QUFNQSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVqQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMiLAogICJmaWxlIjogIi9Gb28udnVlIiwKICAic291cmNlc0NvbnRlbnQiOiBbCiAgICAiPHRlbXBsYXRlPlxuICA8cCBjbGFzcz1cImltcG9ydGVkXCI+Zm9vPC9wPlxuICA8cCBjbGFzcz1cImltcG9ydGVkMlwiPmJhcjwvcD5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBsYW5nPVwic2Fzc1wiPlxuQHVzZSAnLi9pbXBvcnRlZDInXG5cbi5pbXBvcnRlZFxuICBjb2xvcjogcmVkXG48L3N0eWxlPlxuIgogIF0KfQo=
      {
        version: 3 as const,
        file: resolveFile('./src/Foo.vue'),
        sources: [resolveFile('./src/Foo.vue')],
        names: [],
        mappings:
          ';AAMA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;AAEjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACN,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC',
      },
    ]
    const combined = combineSourcemaps(resolveFile('./src/Foo.vue'), sourcemaps)
    expect(combined).toStrictEqual(
      expect.objectContaining({
        version: 3,
        file: resolveFile('./src/Foo.vue'),
        mappings: 'AAAA;EACE;;;ACOF;EACE',
        sources: [
          resolveFile('./src/imported2.sass'),
          resolveFile('./src/Foo.vue'),
        ],
      }),
    )
  })

  test('should combine sourcemaps with multiple sources without matched source', () => {
    const sourcemaps = [
      // processed with postcss
      // https://evanw.github.io/source-map-visualization/#NjYALmZvbyB7CiAgb3ZlcmZsb3c6IHNjcm9sbDsKICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7Cn0KMjU1AHsKICAiZmlsZSI6ICIvc3JjL3Nhc3Mvc3R5bGUuc2FzcyIsCiAgIm1hcHBpbmdzIjogIkFBQUE7RUFDRSxnQkFBZ0I7RUNEbEIsa0NBQUE7QURFQSIsCiAgIm5hbWVzIjogW10sCiAgInNvdXJjZXMiOiBbCiAgICAiL3NyYy9zYXNzL3N0eWxlLnNhc3MiLAogICAgIlx1MDAwMDxubyBzb3VyY2U+IgogIF0sCiAgInNvdXJjZXNDb250ZW50IjogWyAiLmZvbyB7XG4gIG92ZXJmbG93OiBzY3JvbGw7XG59IiwgbnVsbCBdLAogICJ2ZXJzaW9uIjogMwp9Cg==
      {
        version: 3 as const,
        file: resolveFile('./src/sass/style.sass'),
        mappings: 'AAAA;EACE,gBAAgB;ECDlB,kCAAA;ADEA',
        names: [],
        sources: [
          resolveFile('./src/sass/style.sass'),
          '\x00<no source>', // postcss virtual file
        ],
      },
      // processed with sass
      // https://evanw.github.io/source-map-visualization/#MjkALmZvbyB7CiAgb3ZlcmZsb3c6IHNjcm9sbDsKfQoyMDcAewogICJmaWxlIjogIi9zcmMvc2Fzcy9zdHlsZS5zYXNzIiwKICAibWFwcGluZ3MiOiAiQUFBQTtFQUNFIiwKICAibmFtZXMiOiBbXSwKICAic291cmNlcyI6IFsKICAgICIvc3JjL3Nhc3MvdmVuZG9yL2luZGV4LnNjc3MiCiAgXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi5mb28ge1xuICBvdmVyZmxvdzogc2Nyb2xsO1xufVxuIl0sCiAgInZlcnNpb24iOiAzCn0K
      {
        version: 3 as const,
        sources: [resolveFile('./src/sass/vendor/index.scss')],
        names: [],
        mappings: 'AAAA;EACE',
      },
    ]
    const combined = combineSourcemaps(
      resolveFile('./src/sass/style.sass'),
      sourcemaps,
    )
    expect(combined).toStrictEqual(
      expect.objectContaining({
        version: 3,
        file: resolveFile('./src/sass/style.sass'),
        mappings: 'AAAA;EACE;ECDF',
        sources: [
          resolveFile('./src/sass/vendor/index.scss'),
          '\x00<no source>',
        ],
      }),
    )
  })
})

describe('getServerUrlByHost', () => {
  const urls: ResolvedServerUrls = {
    local: ['http://localhost:5173'],
    network: ['http://foo.example.com:5173'],
  }
  const cases = [
    {
      name: 'when host is undefined',
      urls,
      host: undefined,
      expected: 'http://localhost:5173',
    },
    {
      name: 'when host is true',
      urls,
      host: true,
      expected: 'http://localhost:5173',
    },
    {
      name: 'when host is explicit string',
      urls,
      host: 'foo.example.com',
      expected: 'http://foo.example.com:5173',
    },
    {
      name: 'when host is 0.0.0.0',
      urls,
      host: '0.0.0.0',
      expected: 'http://localhost:5173',
    },
    {
      name: 'when host is ::1',
      urls,
      host: '::1',
      expected: 'http://localhost:5173',
    },
  ] satisfies ReadonlyArray<{
    name: string
    urls: ResolvedServerUrls
    host: CommonServerOptions['host']
    expected: string | undefined
  }>

  for (const { name, urls, host, expected } of cases) {
    test(name, () => {
      const actual = getServerUrlByHost(urls, host)
      expect(actual).toBe(expected)
    })
  }
})



================================================
FILE: packages/vite/src/node/__tests__/__snapshots__/utils.spec.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateCodeFrames > end 1`] = `
"
1  |  import foo from './foo'
   |  ^
2  |  foo()
"
`;

exports[`generateCodeFrames > end 2`] = `
"
1  |  import foo from './foo'
   |  ^^^^^^^^^^^^^^^^^^^^^^^
2  |  foo()
"
`;

exports[`generateCodeFrames > end 3`] = `
"
1  |  import foo from './foo'
   |  ^^^^^^^^^^^^^^^^^^^^^^^
2  |  foo()
   |  ^^^^^
"
`;

exports[`generateCodeFrames > end 4`] = `
"
1  |  import foo from './foo'
   |  ^^^^^^^^^^^^^^^^^^^^^^^
2  |  foo()
   |  ^^^^^
"
`;

exports[`generateCodeFrames > end 5`] = `
"
1  |  import foo from './foo'
   |  ^^^^^^^^^^^^^^^^^^^^^^^
2  |  foo()
   |  ^^^^^
"
`;

exports[`generateCodeFrames > end 6`] = `
"
1  |  import foo from './foo'
   |  ^^^^^^^^^^^^^^^^^^^^^^^
2  |  foo()
   |  ^^^^^
"
`;

exports[`generateCodeFrames > invalid start > end 1`] = `
"
1  |  import foo from './foo'
   |    ^
2  |  foo()
"
`;

exports[`generateCodeFrames > range 1`] = `
"
1  |  import foo from './foo'
2  |  
3  |  foo()
   |  ^
4  |  // 1
5  |  // 2
"
`;

exports[`generateCodeFrames > range 2`] = `
"
1  |  import foo from './foo'
2  |  
3  |  foo()
   |  ^^^^^
4  |  // 1
   |  ^
5  |  // 2
"
`;

exports[`generateCodeFrames > start with number 1`] = `
"
1  |  import foo from './foo'
   |  ^
2  |  foo()
"
`;

exports[`generateCodeFrames > start with number 2`] = `
"
1  |  import foo from './foo'
   |  ^
2  |  foo()
"
`;

exports[`generateCodeFrames > start with number 3`] = `
"
1  |  import foo from './foo'
   |   ^
2  |  foo()
"
`;

exports[`generateCodeFrames > start with number 4`] = `
"
1  |  import foo from './foo'
2  |  foo()
   |  ^
"
`;

exports[`generateCodeFrames > start with position 1`] = `
"
1  |  import foo from './foo'
   |  ^
2  |  foo()
"
`;

exports[`generateCodeFrames > start with position 2`] = `
"
1  |  import foo from './foo'
   |   ^
2  |  foo()
"
`;

exports[`generateCodeFrames > start with position 3`] = `
"
1  |  import foo from './foo'
2  |  foo()
   |  ^
"
`;

exports[`generateCodeFrames > supports more than 1000 lines 1`] = `
"
1198 |  // 1197
1199 |  // 1198
1200 |  // 1199
     |  ^
1201 |  // 1200
1202 |  // 1201
"
`;

exports[`generateCodeFrames > works with CRLF 1`] = `
"
1  |  import foo from './foo'
2  |  foo()
   |  ^
"
`;



================================================
FILE: packages/vite/src/node/__tests__/fixtures/cjs-ssr-dep/index.js
================================================
// eslint-disable-next-line no-undef
module.exports = {
  hello: () => 'world',
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/cjs-ssr-dep/package.json
================================================
{
  "name": "@vitejs/cjs-ssr-dep",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/entry/imports-field.ts
================================================
export default 'imports-field'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/entry/package.json
================================================
{
  "name": "@vite/test-config-entry",
  "type": "module",
  "dependencies": {
    "@vite/test-config-plugin-module-condition": "link:../plugin-module-condition"
  },
  "imports": {
    "#imports-field": "./imports-field.ts"
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/entry/vite.config.import-attributes.ts
================================================
// We have to import external json to prevent Vite / esbuild from bundling it.
import pkg from 'vite/package.json' with { type: 'json' }

export default {
  jsonValue: pkg.name,
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/entry/vite.config.ts
================================================
import moduleCondition from '@vite/test-config-plugin-module-condition'
import { array } from '../siblings/foo'
import importsField from '#imports-field'

export default {
  array,
  moduleCondition,
  importsField,
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/import-meta/vite.config.ts
================================================
export default {
  isMain: import.meta.main,
  url: import.meta.url,
  dirname: import.meta.dirname,
  filename: import.meta.filename,
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/loadConfigFromFile/.gitkeep
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/native-import/basic.js
================================================
export default {
  value: 'works',
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/plugin-module-condition/index.cjs
================================================
module.exports = 'require condition'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/plugin-module-condition/index.d.ts
================================================
const str: string
export default str



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/plugin-module-condition/index.mjs
================================================
export default 'import condition'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/plugin-module-condition/module.mjs
================================================
export default 'module condition'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/plugin-module-condition/package.json
================================================
{
  "name": "@vite/test-config-plugin-module-condition",
  "type": "module",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "module": "./module.mjs",
      "import": "./index.mjs",
      "require": "./index.cjs"
    }
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/siblings/foo.ts
================================================
import lodash from 'lodash'

export const array = lodash.partition([1, 2, 3, 4], (n) => n % 2)



================================================
FILE: packages/vite/src/node/__tests__/fixtures/config/siblings/package.json
================================================
{
  "name": "@vite/test-config-sibling",
  "type": "module",
  "devDependencies": {
    "@types/lodash": "^4.17.16",
    "lodash": "^4.17.21"
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/dynamic-import/dep.mjs
================================================
export const hello = 'hello'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/dynamic-import/entry.mjs
================================================
export async function main() {
  const mod = await import('./dep.mjs')
  console.log(mod)
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/emit-assets/css-module.module.css
================================================
.css-module {
  background: rgb(200, 250, 250);
  padding: 20px;
  width: 200px;
  border: 1px solid gray;
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/emit-assets/css-normal.css
================================================
#css-normal {
  background: rgb(250, 250, 200);
  padding: 20px;
  width: 200px;
  border: 1px solid gray;
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/emit-assets/entry.mjs
================================================
import './css-normal.css'
import cssModule from './css-module.module.css'

export default function Page() {
  console.log(cssModule)
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/environment-alias/test.client.js
================================================
export const msg = `[success] (client) alias to mod path`



================================================
FILE: packages/vite/src/node/__tests__/fixtures/environment-alias/test.rsc.js
================================================
export const msg = `[success] (rsc) alias to mod path`



================================================
FILE: packages/vite/src/node/__tests__/fixtures/environment-alias/test.ssr.js
================================================
export const msg = `[success] (ssr) alias to mod path`



================================================
FILE: packages/vite/src/node/__tests__/fixtures/file-url/entry.js
================================================
export default 'ok'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/file-url/package.json
================================================
{
  "type": "module"
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/basic.ts
================================================
interface Test {
  field: true
}

export const test: Test = {
  field: true,
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/cjs.js
================================================
module.exports = {}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/dynamic-import-dep.ts
================================================
export default 'ok'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/dynamic-import.ts
================================================
export default () => import('./dynamic-import-dep')



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/plugin.ts
================================================
import { Plugin } from 'vite'

export default function testPlugin(): Plugin {
  return {
    name: 'test',
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/vite.config.outside-pkg-import.mts
================================================
import parent from '@vitejs/parent'

export default {
  __injected: parent.child,
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/runner-import/vite.config.ts
================================================
import { defineConfig } from 'vite'
import plugin from './plugin'

export default defineConfig({
  root: './test',
  plugins: [plugin()],
})



================================================
FILE: packages/vite/src/node/__tests__/fixtures/scan-jsx-runtime/entry-jsx.tsx
================================================
;(globalThis as any).__test_scan_jsx_runtime ??= 0
;(globalThis as any).__test_scan_jsx_runtime++

export default <div />



================================================
FILE: packages/vite/src/node/__tests__/fixtures/scan-jsx-runtime/entry-no-jsx.js
================================================
import * as vue from 'vue'

export default vue



================================================
FILE: packages/vite/src/node/__tests__/fixtures/scan-jsx-runtime/tsconfig.json
================================================
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "vue",
    "strict": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"]
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/shared-plugins/minify/entry.js
================================================
function main() {
  console.log('test')
}
main()



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/index.browser.js
================================================
export default 'index.browser.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/index.css
================================================
.test-css {
  color: orange;
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/index.custom1.js
================================================
export default 'index.custom1.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/index.default.js
================================================
export default 'index.default.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/index.worker.js
================================================
export default 'index.worker.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/package.json
================================================
{
  "name": "@vitejs/test-dep-conditions",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "style": "./index.css",
      "custom1": "./index.custom1.js",
      "worker": "./index.worker.js",
      "browser": "./index.browser.js",
      "default": "./index.default.js"
    },
    "./with-module": {
      "module": "./dir/index.module.js",
      "default": "./dir/index.default.js"
    }
  }
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/dir/index.default.js
================================================
export default 'dir/index.default.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions/dir/index.module.js
================================================
export default 'dir/index.module.js'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions-app/entry-with-module.js
================================================
import dep from '@vitejs/test-dep-conditions/with-module'
export default dep



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions-app/entry.css
================================================
@import '@vitejs/test-dep-conditions';



================================================
FILE: packages/vite/src/node/__tests__/fixtures/test-dep-conditions-app/entry.js
================================================
import dep from '@vitejs/test-dep-conditions'
export default dep



================================================
FILE: packages/vite/src/node/__tests__/fixtures/watch-rebuild-manifest/dep.js
================================================
console.log('dep.js')



================================================
FILE: packages/vite/src/node/__tests__/fixtures/watch-rebuild-manifest/entry.js
================================================
console.log('entry.js')
console.log(import('./dep.js'))



================================================
FILE: packages/vite/src/node/__tests__/fixtures/watch-rebuild-manifest/package.json
================================================
{
  "type": "module"
}



================================================
FILE: packages/vite/src/node/__tests__/fixtures/worker-dynamic/dynamic.js
================================================
export default 'dynamic ok'



================================================
FILE: packages/vite/src/node/__tests__/fixtures/worker-dynamic/main.js
================================================
document.querySelector('#app').innerHTML = `
  <div>
    <h1>Test worker</h1>
    <div id="worker">???</div>
  </div>
`

const worker = new Worker(new URL('./worker.js', import.meta.url))
worker.onmessage = (e) => {
  document.querySelector('#worker').textContent = e.data
}
worker.postMessage('hi')



================================================
FILE: packages/vite/src/node/__tests__/fixtures/worker-dynamic/worker.js
================================================
self.onmessage = async () => {
  const mod = await import('./dynamic')
  self.postMessage('hello from worker: ' + mod.default)
}



================================================
FILE: packages/vite/src/node/__tests__/packages/package.json
================================================
{
  "name": "named-testing-package"
}



================================================
FILE: packages/vite/src/node/__tests__/packages/build-project/index.html
================================================
<h1>Hello world</h1>

<script type="module" src="entry.js"></script>



================================================
FILE: packages/vite/src/node/__tests__/packages/child/index.js
================================================
export default true



================================================
FILE: packages/vite/src/node/__tests__/packages/child/package.json
================================================
{
  "name": "@vitejs/child",
  "type": "module",
  "main": "./index.js"
}



================================================
FILE: packages/vite/src/node/__tests__/packages/module/package.json
================================================
{
  "name": "mylib",
  "type": "module"
}



================================================
FILE: packages/vite/src/node/__tests__/packages/name/package.json
================================================
{
  "name": "mylib"
}



================================================
FILE: packages/vite/src/node/__tests__/packages/noname/package.json
================================================
{}



================================================
FILE: packages/vite/src/node/__tests__/packages/parent/index.ts
================================================
// @ts-expect-error not typed
import child from '@vitejs/child'

export default {
  child,
}



================================================
FILE: packages/vite/src/node/__tests__/packages/parent/package.json
================================================
{
  "name": "@vitejs/parent",
  "type": "module",
  "main": "./index.ts",
  "dependencies": {
    "@vitejs/child": "link:../child"
  }
}



================================================
FILE: packages/vite/src/node/__tests__/plugins/assetImportMetaUrl.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { parseAst } from 'rollup/parseAst'
import { assetImportMetaUrlPlugin } from '../../plugins/assetImportMetaUrl'
import { resolveConfig } from '../../config'
import { PartialEnvironment } from '../../baseEnvironment'

async function createAssetImportMetaurlPluginTransform() {
  const config = await resolveConfig({ configFile: false }, 'serve')
  const instance = assetImportMetaUrlPlugin(config)
  const environment = new PartialEnvironment('client', config)

  return async (code: string) => {
    // @ts-expect-error transform.handler should exist
    const result = await instance.transform.handler.call(
      { environment, parse: parseAst },
      code,
      'foo.ts',
    )
    return result?.code || result
  }
}

describe('assetImportMetaUrlPlugin', async () => {
  const transform = await createAssetImportMetaurlPluginTransform()

  test('variable between /', async () => {
    expect(
      await transform('new URL(`./foo/${dir}/index.js`, import.meta.url)'),
    ).toMatchInlineSnapshot(
      `"new URL((import.meta.glob("./foo/*/index.js", {"eager":true,"import":"default","query":"?url"}))[\`./foo/\${dir}/index.js\`], import.meta.url)"`,
    )
  })

  test('variable before non-/', async () => {
    expect(
      await transform('new URL(`./foo/${dir}.js`, import.meta.url)'),
    ).toMatchInlineSnapshot(
      `"new URL((import.meta.glob("./foo/*.js", {"eager":true,"import":"default","query":"?url"}))[\`./foo/\${dir}.js\`], import.meta.url)"`,
    )
  })

  test('two variables', async () => {
    expect(
      await transform('new URL(`./foo/${dir}${file}.js`, import.meta.url)'),
    ).toMatchInlineSnapshot(
      `"new URL((import.meta.glob("./foo/*.js", {"eager":true,"import":"default","query":"?url"}))[\`./foo/\${dir}\${file}.js\`], import.meta.url)"`,
    )
  })

  test('two variables between /', async () => {
    expect(
      await transform(
        'new URL(`./foo/${dir}${dir2}/index.js`, import.meta.url)',
      ),
    ).toMatchInlineSnapshot(
      `"new URL((import.meta.glob("./foo/*/index.js", {"eager":true,"import":"default","query":"?url"}))[\`./foo/\${dir}\${dir2}/index.js\`], import.meta.url)"`,
    )
  })

  test('ignore starting with a variable', async () => {
    expect(
      await transform('new URL(`${file}.js`, import.meta.url)'),
    ).toMatchInlineSnapshot(`"new URL(\`\${file}.js\`, import.meta.url)"`)
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/css.spec.ts
================================================
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { resolveConfig } from '../../config'
import type { InlineConfig } from '../../config'
import {
  convertTargets,
  cssPlugin,
  cssUrlRE,
  getEmptyChunkReplacer,
  hoistAtRules,
  preprocessCSS,
  resolveLibCssFilename,
} from '../../plugins/css'
import { PartialEnvironment } from '../../baseEnvironment'

const __dirname = path.resolve(fileURLToPath(import.meta.url), '..')

describe('search css url function', () => {
  test('some spaces before it', () => {
    expect(
      cssUrlRE.test("list-style-image: url('../images/bullet.jpg');"),
    ).toBe(true)
  })

  test('no space after colon', () => {
    expect(cssUrlRE.test("list-style-image:url('../images/bullet.jpg');")).toBe(
      true,
    )
  })

  test('at the beginning of line', () => {
    expect(cssUrlRE.test("url('../images/bullet.jpg');")).toBe(true)
  })

  test('as suffix of a function name', () => {
    expect(
      cssUrlRE.test(`@function svg-url($string) {
      @return "";
    }`),
    ).toBe(false)
  })

  test('after parenthesis', () => {
    expect(
      cssUrlRE.test(
        'mask-image: image(url(mask.png), skyblue, linear-gradient(rgba(0, 0, 0, 1.0), transparent));',
      ),
    ).toBe(true)
  })

  test('after comma', () => {
    expect(
      cssUrlRE.test(
        'mask-image: image(skyblue,url(mask.png), linear-gradient(rgba(0, 0, 0, 1.0), transparent));',
      ),
    ).toBe(true)
  })
})

describe('css modules', () => {
  test('css module compose/from path resolutions', async () => {
    const { transform } = await createCssPluginTransform({
      configFile: false,
      resolve: {
        alias: [
          {
            find: '@',
            replacement: path.join(
              import.meta.dirname,
              './fixtures/css-module-compose',
            ),
          },
        ],
      },
    })

    const result = await transform(
      `\
.foo {
position: fixed;
composes: bar from '@/css/bar.module.css';
}`,
      '/css/foo.module.css',
    )

    expect(result.code).toMatchInlineSnapshot(
      `
      "._bar_1b4ow_1 {
        display: block;
        background: #f0f;
      }
      ._foo_86148_1 {
      position: fixed;
      }"
    `,
    )
  })

  test('custom generateScopedName', async () => {
    const { transform } = await createCssPluginTransform({
      configFile: false,
      css: {
        modules: {
          generateScopedName: 'custom__[hash:base64:5]',
        },
      },
    })
    const css = `\
.foo {
  color: red;
}`
    const result1 = await transform(css, '/foo.module.css') // server
    const result2 = await transform(css, '/foo.module.css?direct') // client
    expect(result1.code).toBe(result2.code)
  })

  test('custom generateScopedName with lightningcss', async () => {
    const { transform } = await createCssPluginTransform({
      configFile: false,
      css: {
        modules: {
          generateScopedName: 'custom__[hash:base64:5]',
        },
        transformer: 'lightningcss',
      },
    })
    const css = `\
.foo {
  color: red;
}`
    const result1 = await transform(css, '/foo.module.css') // server
    const result2 = await transform(css, '/foo.module.css?direct') // client
    expect(result1.code).toBe(result2.code)
  })
})

describe('hoist @ rules', () => {
  test('hoist @import', async () => {
    const css = `.foo{color:red;}@import "bla";`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@import "bla";.foo{color:red;}`)
  })

  test('hoist @import url with semicolon', async () => {
    const css = `.foo{color:red;}@import url("bla;bla");`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@import url("bla;bla");.foo{color:red;}`)
  })

  test('hoist @import url data with semicolon', async () => {
    const css = `.foo{color:red;}@import url(data:image/png;base64,iRxVB0);`
    const result = await hoistAtRules(css)
    expect(result).toBe(
      `@import url(data:image/png;base64,iRxVB0);.foo{color:red;}`,
    )
  })

  test('hoist @import with semicolon in quotes', async () => {
    const css = `.foo{color:red;}@import "bla;bar";`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@import "bla;bar";.foo{color:red;}`)
  })

  test('hoist @charset', async () => {
    const css = `.foo{color:red;}@charset "utf-8";`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@charset "utf-8";.foo{color:red;}`)
  })

  test('hoist one @charset only', async () => {
    const css = `.foo{color:red;}@charset "utf-8";@charset "utf-8";`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@charset "utf-8";.foo{color:red;}`)
  })

  test('hoist @import and @charset', async () => {
    const css = `.foo{color:red;}@import "bla";@charset "utf-8";.bar{color:green;}@import "baz";`
    const result = await hoistAtRules(css)
    expect(result).toBe(
      `@charset "utf-8";@import "bla";@import "baz";.foo{color:red;}.bar{color:green;}`,
    )
  })

  test('dont hoist @import in comments', async () => {
    const css = `.foo{color:red;}/* @import "bla"; */@import "bar";`
    const result = await hoistAtRules(css)
    expect(result).toBe(`@import "bar";.foo{color:red;}/* @import "bla"; */`)
  })

  test('dont hoist @charset in comments', async () => {
    const css = `.foo{color:red;}/* @charset "utf-8"; */@charset "utf-8";`
    const result = await hoistAtRules(css)
    expect(result).toBe(
      `@charset "utf-8";.foo{color:red;}/* @charset "utf-8"; */`,
    )
  })

  test('dont hoist @import and @charset in comments', async () => {
    const css = `
.foo{color:red;}
/*
  @import "bla";
*/
@charset "utf-8";
/*
  @charset "utf-8";
  @import "bar";
*/
@import "baz";`
    const result = await hoistAtRules(css)
    expect(result).toMatchInlineSnapshot(`
      "@charset "utf-8";@import "baz";
      .foo{color:red;}
      /*
        @import "bla";
      */

      /*
        @charset "utf-8";
        @import "bar";
      */
      "
    `)
  })
})

async function createCssPluginTransform(inlineConfig: InlineConfig = {}) {
  const config = await resolveConfig(inlineConfig, 'serve')
  const environment = new PartialEnvironment('client', config)

  const { transform, buildStart } = cssPlugin(config)

  // @ts-expect-error buildStart is function
  await buildStart.call({})

  return {
    async transform(code: string, id: string) {
      // @ts-expect-error transform.handler is function
      return await transform.handler.call(
        {
          addWatchFile() {
            return
          },
          environment,
        },
        code,
        id,
      )
    },
  }
}

describe('convertTargets', () => {
  test('basic cases', () => {
    expect(convertTargets('es2018')).toStrictEqual({
      chrome: 4128768,
      edge: 5177344,
      firefox: 3801088,
      safari: 786432,
      opera: 3276800,
    })
    expect(convertTargets(['safari13.1', 'ios13', 'node14'])).toStrictEqual({
      ios_saf: 851968,
      safari: 852224,
    })
  })
})

describe('getEmptyChunkReplacer', () => {
  test('replaces import call', () => {
    const code = `\
import "some-module";
import "pure_css_chunk.js";
import "other-module";`

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'es')
    const replaced = replacer(code)
    expect(replaced.length).toBe(code.length)
    expect(replaced).toMatchInlineSnapshot(`
      "import "some-module";
      /* empty css             */
      import "other-module";"
    `)
  })

  test('replaces import call without new lines', () => {
    const code = `import "some-module";import "pure_css_chunk.js";import "other-module";`

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'es')
    const replaced = replacer(code)
    expect(replaced.length).toBe(code.length)
    expect(replaced).toMatchInlineSnapshot(
      `"import "some-module";/* empty css             */import "other-module";"`,
    )
  })

  test('replaces require call', () => {
    const code = `\
require("some-module");
require("pure_css_chunk.js");
require("other-module");`

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'cjs')
    const replaced = replacer(code)
    expect(replaced.length).toBe(code.length)
    expect(replaced).toMatchInlineSnapshot(`
      "require("some-module");
      ;/* empty css              */
      require("other-module");"
    `)
  })

  test('replaces require call in minified code without new lines', () => {
    const code = `require("some-module");require("pure_css_chunk.js");require("other-module");`

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'cjs')
    const replaced = replacer(code)
    expect(replaced.length).toBe(code.length)
    expect(replaced).toMatchInlineSnapshot(
      `"require("some-module");;/* empty css              */require("other-module");"`,
    )
  })

  test('replaces require call in minified code that uses comma operator', () => {
    const code =
      'require("some-module"),require("pure_css_chunk.js"),require("other-module");'

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'cjs')
    const newCode = replacer(code)
    expect(newCode.length).toBe(code.length)
    expect(newCode).toMatchInlineSnapshot(
      `"require("some-module"),/* empty css               */require("other-module");"`,
    )
    // So there should be no pure css chunk anymore
    expect(newCode).not.toContain('pure_css_chunk.js')
  })

  test('replaces require call in minified code that uses comma operator 2', () => {
    const code = 'require("pure_css_chunk.js"),console.log();'
    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'cjs')
    const newCode = replacer(code)
    expect(newCode.length).toBe(code.length)
    expect(newCode).toMatchInlineSnapshot(
      `"/* empty css               */console.log();"`,
    )
    expect(newCode).not.toContain('pure_css_chunk.js')
  })

  test('replaces require call in minified code that uses comma operator followed by assignment', () => {
    const code =
      'require("some-module"),require("pure_css_chunk.js");const v=require("other-module");'

    const replacer = getEmptyChunkReplacer(['pure_css_chunk.js'], 'cjs')
    const newCode = replacer(code)
    expect(newCode.length).toBe(code.length)
    expect(newCode).toMatchInlineSnapshot(
      `"require("some-module");/* empty css               */const v=require("other-module");"`,
    )
    expect(newCode).not.toContain('pure_css_chunk.js')
  })
})

describe('preprocessCSS', () => {
  test('works', async () => {
    const resolvedConfig = await resolveConfig({ configFile: false }, 'serve')
    const result = await preprocessCSS(
      `\
.foo {
  color:red;
  background: url(./foo.png);
}`,
      'foo.css',
      resolvedConfig,
    )
    expect(result.code).toMatchInlineSnapshot(`
      ".foo {
        color:red;
        background: url(./foo.png);
      }"
    `)
  })

  test('works with lightningcss', async () => {
    const resolvedConfig = await resolveConfig(
      {
        configFile: false,
        css: { transformer: 'lightningcss' },
      },
      'serve',
    )
    const result = await preprocessCSS(
      `\
.foo {
  color: red;
  background: url(./foo.png);
}`,
      'foo.css',
      resolvedConfig,
    )
    expect(result.code).toMatchInlineSnapshot(`
      ".foo {
        color: red;
        background: url("./foo.png");
      }
      "
    `)
  })
})

describe('resolveLibCssFilename', () => {
  test('use name from package.json', () => {
    const filename = resolveLibCssFilename(
      {
        entry: 'mylib.js',
      },
      path.resolve(__dirname, '../packages/name'),
    )
    expect(filename).toBe('mylib.css')
  })

  test('set cssFileName', () => {
    const filename = resolveLibCssFilename(
      {
        entry: 'mylib.js',
        cssFileName: 'style',
      },
      path.resolve(__dirname, '../packages/noname'),
    )
    expect(filename).toBe('style.css')
  })

  test('use fileName if set', () => {
    const filename = resolveLibCssFilename(
      {
        entry: 'mylib.js',
        fileName: 'custom-name',
      },
      path.resolve(__dirname, '../packages/name'),
    )
    expect(filename).toBe('custom-name.css')
  })

  test('use fileName if set and has array entry', () => {
    const filename = resolveLibCssFilename(
      {
        entry: ['mylib.js', 'mylib2.js'],
        fileName: 'custom-name',
      },
      path.resolve(__dirname, '../packages/name'),
    )
    expect(filename).toBe('custom-name.css')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/define.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { definePlugin } from '../../plugins/define'
import { resolveConfig } from '../../config'
import { PartialEnvironment } from '../../baseEnvironment'

async function createDefinePluginTransform(
  define: Record<string, any> = {},
  build = true,
  ssr = false,
) {
  const config = await resolveConfig(
    { configFile: false, define },
    build ? 'build' : 'serve',
  )
  const instance = definePlugin(config)
  const environment = new PartialEnvironment(ssr ? 'ssr' : 'client', config)

  return async (code: string) => {
    // @ts-expect-error transform.handler should exist
    const result = await instance.transform.handler.call(
      { environment },
      code,
      'foo.ts',
    )
    return result?.code || result
  }
}

describe('definePlugin', () => {
  test('replaces custom define', async () => {
    const transform = await createDefinePluginTransform({
      __APP_VERSION__: JSON.stringify('1.0'),
    })
    expect(await transform('const version = __APP_VERSION__ ;')).toBe(
      'const version = "1.0";\n',
    )
    expect(await transform('const version = __APP_VERSION__;')).toBe(
      'const version = "1.0";\n',
    )
  })

  test('should not replace if not defined', async () => {
    const transform = await createDefinePluginTransform({
      __APP_VERSION__: JSON.stringify('1.0'),
    })
    expect(await transform('const version = "1.0";')).toBe(undefined)
    expect(await transform('const version = import.meta.SOMETHING')).toBe(
      undefined,
    )
  })

  test('replaces import.meta.env.SSR with false', async () => {
    const transform = await createDefinePluginTransform()
    expect(await transform('const isSSR = import.meta.env.SSR;')).toBe(
      'const isSSR = false;\n',
    )
  })

  test('preserve import.meta.hot with override', async () => {
    // assert that the default behavior is to replace import.meta.hot with undefined
    const transform = await createDefinePluginTransform()
    expect(await transform('const hot = import.meta.hot;')).toBe(
      'const hot = void 0;\n',
    )
    // assert that we can specify a user define to preserve import.meta.hot
    const overrideTransform = await createDefinePluginTransform({
      'import.meta.hot': 'import.meta.hot',
    })
    expect(await overrideTransform('const hot = import.meta.hot;')).toBe(
      'const hot = import.meta.hot;\n',
    )
  })

  test('replace import.meta.env.UNKNOWN with undefined', async () => {
    const transform = await createDefinePluginTransform()
    expect(await transform('const foo = import.meta.env.UNKNOWN;')).toBe(
      'const foo = undefined                       ;\n',
    )
  })

  test('leave import.meta.env["UNKNOWN"] to runtime', async () => {
    const transform = await createDefinePluginTransform()
    expect(await transform('const foo = import.meta.env["UNKNOWN"];')).toMatch(
      /const __vite_import_meta_env__ = .*;\nconst foo = __vite_import_meta_env__\["UNKNOWN"\];/,
    )
  })

  test('preserve import.meta.env.UNKNOWN with override', async () => {
    const transform = await createDefinePluginTransform({
      'import.meta.env.UNKNOWN': 'import.meta.env.UNKNOWN',
    })
    expect(await transform('const foo = import.meta.env.UNKNOWN;')).toBe(
      'const foo = import.meta.env.UNKNOWN;\n',
    )
  })

  test('replace import.meta.env when it is a invalid json', async () => {
    const transform = await createDefinePluginTransform({
      'import.meta.env.LEGACY': '__VITE_IS_LEGACY__',
    })

    expect(
      await transform(
        'const isLegacy = import.meta.env.LEGACY;\nimport.meta.env.UNDEFINED && console.log(import.meta.env.UNDEFINED);',
      ),
    ).toMatchInlineSnapshot(`
      "const isLegacy = __VITE_IS_LEGACY__;
      undefined                          && console.log(undefined                         );
      "
    `)
  })

  test('replace bare import.meta.env', async () => {
    const transform = await createDefinePluginTransform()
    expect(await transform('const env = import.meta.env;')).toMatch(
      /const __vite_import_meta_env__ = .*;\nconst env = __vite_import_meta_env__;/,
    )
  })

  test('already has marker', async () => {
    const transform = await createDefinePluginTransform()
    expect(
      await transform(
        'console.log(__vite_import_meta_env__);\nconst env = import.meta.env;',
      ),
    ).toMatch(
      /const __vite_import_meta_env__1 = .*;\nconsole.log\(__vite_import_meta_env__\);\nconst env = __vite_import_meta_env__1;/,
    )

    expect(
      await transform(
        'console.log(__vite_import_meta_env__, __vite_import_meta_env__1);\n const env = import.meta.env;',
      ),
    ).toMatch(
      /const __vite_import_meta_env__2 = .*;\nconsole.log\(__vite_import_meta_env__, __vite_import_meta_env__1\);\nconst env = __vite_import_meta_env__2;/,
    )

    expect(
      await transform(
        'console.log(__vite_import_meta_env__);\nconst env = import.meta.env;\nconsole.log(import.meta.env.UNDEFINED);',
      ),
    ).toMatch(
      /const __vite_import_meta_env__1 = .*;\nconsole.log\(__vite_import_meta_env__\);\nconst env = __vite_import_meta_env__1;\nconsole.log\(undefined {26}\);/,
    )
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/esbuild.spec.ts
================================================
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import type { ResolvedConfig, UserConfig } from '../../config'
import {
  resolveEsbuildTranspileOptions,
  transformWithEsbuild,
} from '../../plugins/esbuild'
import { normalizePath } from '../../utils'

describe('resolveEsbuildTranspileOptions', () => {
  test('resolve default', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          target: 'es2020',
          minify: 'esbuild',
        },
        esbuild: {
          keepNames: true,
        },
      }),
      'es',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: 'es2020',
      format: 'esm',
      keepNames: true,
      minify: true,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve esnext no minify', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          target: 'esnext',
          minify: false,
        },
        esbuild: {
          keepNames: true,
        },
      }),
      'es',
    )
    expect(options).toEqual(null)
  })

  test('resolve specific minify options', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          minify: 'esbuild',
        },
        esbuild: {
          keepNames: true,
          minifyIdentifiers: false,
        },
      }),
      'es',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: undefined,
      format: 'esm',
      keepNames: true,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: true,
      minifyWhitespace: true,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve no minify', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          target: 'es2020',
          minify: false,
        },
        esbuild: {
          keepNames: true,
        },
      }),
      'es',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: 'es2020',
      format: 'esm',
      keepNames: true,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: false,
      minifyWhitespace: false,
      treeShaking: false,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve es lib', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          minify: 'esbuild',
          lib: {
            entry: './somewhere.js',
          },
        },
        esbuild: {
          keepNames: true,
        },
      }),
      'es',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: undefined,
      format: 'esm',
      keepNames: true,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve cjs lib', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          minify: 'esbuild',
          lib: {
            entry: './somewhere.js',
          },
        },
        esbuild: {
          keepNames: true,
        },
      }),
      'cjs',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: undefined,
      format: 'cjs',
      keepNames: true,
      minify: true,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve es lib with specific minify options', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          minify: 'esbuild',
          lib: {
            entry: './somewhere.js',
          },
        },
        esbuild: {
          keepNames: true,
          minifyIdentifiers: true,
          minifyWhitespace: true,
        },
      }),
      'es',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: undefined,
      format: 'esm',
      keepNames: true,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })

  test('resolve cjs lib with specific minify options', () => {
    const options = resolveEsbuildTranspileOptions(
      defineResolvedConfig({
        build: {
          minify: 'esbuild',
          lib: {
            entry: './somewhere.js',
          },
        },
        esbuild: {
          keepNames: true,
          minifyIdentifiers: true,
          minifySyntax: false,
          treeShaking: true,
        },
      }),
      'cjs',
    )
    expect(options).toEqual({
      charset: 'utf8',
      loader: 'js',
      target: undefined,
      format: 'cjs',
      keepNames: true,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: false,
      minifyWhitespace: true,
      treeShaking: true,
      supported: {
        'dynamic-import': true,
        'import-meta': true,
      },
    })
  })
})

describe('transformWithEsbuild', () => {
  test('not throw on inline sourcemap', async () => {
    const result = await transformWithEsbuild(`const foo = 'bar'`, '', {
      sourcemap: 'inline',
    })
    expect(result?.code).toBeTruthy()
    expect(result?.map).toBeTruthy()
  })

  test('correctly overrides TS configuration and applies automatic transform', async () => {
    const jsxImportSource = 'bar'
    const result = await transformWithEsbuild(
      'const foo = () => <></>',
      'baz.jsx',
      {
        tsconfigRaw: {
          compilerOptions: {
            jsx: 'preserve',
          },
        },
        jsx: 'automatic',
        jsxImportSource,
      },
    )
    expect(result?.code).toContain(`${jsxImportSource}/jsx-runtime`)
    expect(result?.code).toContain('/* @__PURE__ */')
  })

  test('correctly overrides TS configuration and preserves code', async () => {
    const foo = 'const foo = () => <></>'
    const result = await transformWithEsbuild(foo, 'baz.jsx', {
      tsconfigRaw: {
        compilerOptions: {
          jsx: 'react-jsx',
        },
      },
      jsx: 'preserve',
    })
    expect(result?.code).toContain(foo)
  })

  test('correctly overrides TS configuration and transforms code', async () => {
    const jsxFactory = 'h',
      jsxFragment = 'bar'
    const result = await transformWithEsbuild(
      'const foo = () => <></>',
      'baz.jsx',
      {
        tsconfigRaw: {
          compilerOptions: {
            jsxFactory: 'g',
            jsxFragmentFactory: 'foo',
            jsxImportSource: 'baz',
          },
        },
        jsx: 'transform',
        jsxFactory,
        jsxFragment,
      },
    )
    expect(result?.code).toContain(
      `/* @__PURE__ */ ${jsxFactory}(${jsxFragment}, null)`,
    )
  })

  describe('useDefineForClassFields', async () => {
    const transformClassCode = async (
      target: string,
      tsconfigCompilerOptions: {
        target?: string
        useDefineForClassFields?: boolean
      },
    ) => {
      const result = await transformWithEsbuild(
        `
          class foo {
            bar = 'bar'
          }
        `,
        normalizePath(path.resolve(import.meta.dirname, 'bar.ts')),
        {
          target,
          tsconfigRaw: { compilerOptions: tsconfigCompilerOptions },
        },
      )
      return result?.code
    }

    const [
      defineForClassFieldsTrueTransformedCode,
      defineForClassFieldsTrueLowerTransformedCode,
      defineForClassFieldsFalseTransformedCode,
    ] = await Promise.all([
      transformClassCode('esnext', {
        useDefineForClassFields: true,
      }),
      transformClassCode('es2021', {
        useDefineForClassFields: true,
      }),
      transformClassCode('esnext', {
        useDefineForClassFields: false,
      }),
    ])

    test('target: esnext and tsconfig.target: esnext => true', async () => {
      const actual = await transformClassCode('esnext', {
        target: 'esnext',
      })
      expect(actual).toBe(defineForClassFieldsTrueTransformedCode)
    })

    test('target: es2021 and tsconfig.target: esnext => true', async () => {
      const actual = await transformClassCode('es2021', {
        target: 'esnext',
      })
      expect(actual).toBe(defineForClassFieldsTrueLowerTransformedCode)
    })

    test('target: es2021 and tsconfig.target: es2021 => false', async () => {
      const actual = await transformClassCode('es2021', {
        target: 'es2021',
      })
      expect(actual).toBe(defineForClassFieldsFalseTransformedCode)
    })

    test('target: esnext and tsconfig.target: es2021 => false', async () => {
      const actual = await transformClassCode('esnext', {
        target: 'es2021',
      })
      expect(actual).toBe(defineForClassFieldsFalseTransformedCode)
    })

    test('target: es2022 and tsconfig.target: es2022 => true', async () => {
      const actual = await transformClassCode('es2022', {
        target: 'es2022',
      })
      expect(actual).toBe(defineForClassFieldsTrueTransformedCode)
    })

    test('target: es2022 and tsconfig.target: undefined => false', async () => {
      const actual = await transformClassCode('es2022', {
        target: undefined,
      })
      expect(actual).toBe(defineForClassFieldsFalseTransformedCode)
    })
  })
})

/**
 * Helper for `resolveEsbuildTranspileOptions` to created resolved config with types.
 * Note: The function only uses `build.target`, `build.minify` and `esbuild` options.
 */
function defineResolvedConfig(config: UserConfig): ResolvedConfig {
  return config as any
}



================================================
FILE: packages/vite/src/node/__tests__/plugins/hooks.spec.ts
================================================
import path from 'node:path'
import { describe, expect, onTestFinished, test } from 'vitest'
import { build } from '../../build'
import type { Plugin } from '../../plugin'
import { resolveConfig } from '../../config'
import { createServer } from '../../server'
import { preview } from '../../preview'
import { promiseWithResolvers } from '../../../shared/utils'

const resolveConfigWithPlugin = (
  plugin: Plugin,
  command: 'serve' | 'build' = 'serve',
) => {
  return resolveConfig(
    { configFile: false, plugins: [plugin], logLevel: 'error' },
    command,
  )
}

const ENTRY_ID = 'entry.js'
const RESOLVED_ENTRY_ID = `\0${ENTRY_ID}`
const resolveEntryPlugin: Plugin = {
  name: 'resolve-entry.js',
  resolveId(id) {
    if (id === ENTRY_ID) {
      return RESOLVED_ENTRY_ID
    }
  },
  load(id) {
    if (id === RESOLVED_ENTRY_ID) {
      return 'export default {}'
    }
  },
}

const createServerWithPlugin = async (plugin: Plugin) => {
  const server = await createServer({
    configFile: false,
    root: import.meta.dirname,
    plugins: [plugin, resolveEntryPlugin],
    logLevel: 'error',
    server: {
      middlewareMode: true,
      ws: false,
    },
  })
  onTestFinished(() => server.close())
  return server
}

const createPreviewServerWithPlugin = async (plugin: Plugin) => {
  const server = await preview({
    configFile: false,
    root: import.meta.dirname,
    plugins: [
      {
        name: 'mock-preview',
        configurePreviewServer({ httpServer }) {
          // NOTE: make httpServer.listen no-op to avoid starting a server
          httpServer.listen = (...args: unknown[]) => {
            const listener = args.at(-1) as () => void
            listener()
            return httpServer as any
          }
        },
      },
      plugin,
    ],
    logLevel: 'error',
  })
  onTestFinished(() => server.close())
  return server
}

const buildWithPlugin = async (plugin: Plugin) => {
  await build({
    root: path.resolve(import.meta.dirname, '../packages/build-project'),
    logLevel: 'error',
    build: {
      write: false,
    },
    plugins: [plugin, resolveEntryPlugin],
  })
}

describe('supports plugin context', () => {
  test('config hook', async () => {
    expect.assertions(4)

    await resolveConfigWithPlugin({
      name: 'test',
      config() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        // @ts-expect-error watchMode should not exist in types
        expect(this.meta.watchMode).toBeUndefined()
      },
    })
  })

  test('configEnvironment hook', async () => {
    expect.assertions(4)

    await resolveConfigWithPlugin({
      name: 'test',
      configEnvironment(name) {
        if (name !== 'client') return

        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        // @ts-expect-error watchMode should not exist in types
        expect(this.meta.watchMode).toBeUndefined()
      },
    })
  })

  test('configResolved hook', async () => {
    expect.assertions(4)

    await resolveConfigWithPlugin({
      name: 'test',
      configResolved() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
      },
    })
  })

  test('configureServer hook', async () => {
    expect.assertions(4)

    await createServerWithPlugin({
      name: 'test',
      configureServer() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
      },
    })
  })

  test('configurePreviewServer hook', async () => {
    expect.assertions(4)

    await createPreviewServerWithPlugin({
      name: 'test',
      configurePreviewServer() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(false)
      },
    })
  })

  test('transformIndexHtml hook in dev', async () => {
    expect.assertions(4)

    const server = await createServerWithPlugin({
      name: 'test',
      transformIndexHtml() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
      },
    })
    await server.transformIndexHtml('/index.html', '<html></html>')
  })

  test('transformIndexHtml hook in build', async () => {
    expect.assertions(4)

    await buildWithPlugin({
      name: 'test',
      transformIndexHtml() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(false)
      },
    })
  })

  test('handleHotUpdate hook', async () => {
    expect.assertions(4)

    const { promise, resolve } = promiseWithResolvers<void>()
    const server = await createServerWithPlugin({
      name: 'test',
      handleHotUpdate() {
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
        resolve()
      },
    })
    server.watcher.emit(
      'change',
      path.resolve(import.meta.dirname, 'index.html'),
    )

    await promise
  })

  test('hotUpdate hook', async () => {
    expect.assertions(4)

    const { promise, resolve } = promiseWithResolvers<void>()
    const server = await createServerWithPlugin({
      name: 'test',
      hotUpdate() {
        if (this.environment.name !== 'client') return

        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
          environment: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
        resolve()
      },
    })
    server.watcher.emit(
      'change',
      path.resolve(import.meta.dirname, 'index.html'),
    )

    await promise
  })

  test('transform hook in dev', async () => {
    expect.assertions(4)

    const server = await createServerWithPlugin({
      name: 'test',
      transform(_code, id) {
        if (id !== RESOLVED_ENTRY_ID) return
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(true)
      },
    })
    await server.transformRequest(ENTRY_ID)
    await server.close()
  })

  test('transform hook in build', async () => {
    expect.assertions(4)

    await buildWithPlugin({
      name: 'test',
      transform(_code, id) {
        if (id !== RESOLVED_ENTRY_ID) return
        expect(this).toMatchObject({
          debug: expect.any(Function),
          info: expect.any(Function),
          warn: expect.any(Function),
          error: expect.any(Function),
          meta: expect.any(Object),
        })
        expect(this.meta.rollupVersion).toBeTypeOf('string')
        expect(this.meta.viteVersion).toBeTypeOf('string')
        expect(this.meta.watchMode).toBe(false)
      },
    })
  })

  test('this.fs is supported in dev', async () => {
    expect.hasAssertions()

    const server = await createServerWithPlugin({
      name: 'test',
      resolveId(id) {
        if (id !== ENTRY_ID) return
        expect(this.fs.readFile).toBeTypeOf('function')
      },
    })
    await server.transformRequest(ENTRY_ID)
    await server.close()
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/import.spec.ts
================================================
import { beforeEach, describe, expect, test, vi } from 'vitest'
import { transformCjsImport } from '../../plugins/importAnalysis'

describe('runTransform', () => {
  const config: any = {
    command: 'serve',
    logger: {
      warn: vi.fn(),
    },
  }

  function runTransformCjsImport(importExp: string) {
    const result = transformCjsImport(
      importExp,
      './node_modules/.vite/deps/react.js',
      'react',
      0,
      'modA',
      config,
    )
    if (result !== undefined) {
      expect(result.split('\n').length, 'result line count').toBe(
        importExp.split('\n').length,
      )
    }
    return result
  }

  beforeEach(() => {
    config.logger.warn.mockClear()
  })

  test('import specifier', () => {
    expect(
      runTransformCjsImport(
        'import { useState, Component, "👋" as fake } from "react"',
      ),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const useState = __vite__cjsImport0_react["useState"]; ' +
        'const Component = __vite__cjsImport0_react["Component"]; ' +
        'const fake = __vite__cjsImport0_react["👋"]',
    )
  })

  test('import default specifier', () => {
    expect(runTransformCjsImport('import React from "react"')).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const React = __vite__cjsImport0_react.__esModule ? __vite__cjsImport0_react.default : __vite__cjsImport0_react',
    )

    expect(
      runTransformCjsImport('import { default as React } from "react"'),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const React = __vite__cjsImport0_react.__esModule ? __vite__cjsImport0_react.default : __vite__cjsImport0_react',
    )
  })

  test('import all specifier', () => {
    expect(runTransformCjsImport('import * as react from "react"')).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        `const react = ((m) => m?.__esModule ? m : {  ...typeof m === "object" && !Array.isArray(m) || typeof m === "function" ? m : {},  default: m})(__vite__cjsImport0_react)`,
    )
  })

  test('export all specifier', () => {
    expect(runTransformCjsImport('export * from "react"')).toBe(undefined)

    expect(config.logger.warn).toBeCalledWith(
      expect.stringContaining(`export * from "react"\` in modA`),
    )

    expect(runTransformCjsImport('export * as react from "react"')).toBe(
      undefined,
    )

    expect(config.logger.warn).toBeCalledTimes(1)
  })

  test('export name specifier', () => {
    expect(
      runTransformCjsImport(
        'export { useState, Component, "👋" } from "react"',
      ),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const __vite__cjsExportI_useState = __vite__cjsImport0_react["useState"]; ' +
        'const __vite__cjsExportI_Component = __vite__cjsImport0_react["Component"]; ' +
        'const __vite__cjsExportL_1d0452e3 = __vite__cjsImport0_react["👋"]; ' +
        'export { __vite__cjsExportI_useState as useState, __vite__cjsExportI_Component as Component, __vite__cjsExportL_1d0452e3 as "👋" }',
    )

    expect(
      runTransformCjsImport(
        'export { useState as useStateAlias, Component as ComponentAlias, "👋" as "👍" } from "react"',
      ),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const __vite__cjsExportI_useStateAlias = __vite__cjsImport0_react["useState"]; ' +
        'const __vite__cjsExportI_ComponentAlias = __vite__cjsImport0_react["Component"]; ' +
        'const __vite__cjsExportL_5d57d39e = __vite__cjsImport0_react["👋"]; ' +
        'export { __vite__cjsExportI_useStateAlias as useStateAlias, __vite__cjsExportI_ComponentAlias as ComponentAlias, __vite__cjsExportL_5d57d39e as "👍" }',
    )
  })

  test('export default specifier', () => {
    expect(runTransformCjsImport('export { default } from "react"')).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const __vite__cjsExportDefault_0 = __vite__cjsImport0_react.__esModule ? __vite__cjsImport0_react.default : __vite__cjsImport0_react; ' +
        'export default __vite__cjsExportDefault_0',
    )

    expect(
      runTransformCjsImport('export { default as React} from "react"'),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const __vite__cjsExportI_React = __vite__cjsImport0_react.__esModule ? __vite__cjsImport0_react.default : __vite__cjsImport0_react; ' +
        'export { __vite__cjsExportI_React as React }',
    )

    expect(
      runTransformCjsImport('export { Component as default } from "react"'),
    ).toBe(
      'import __vite__cjsImport0_react from "./node_modules/.vite/deps/react.js"; ' +
        'const __vite__cjsExportDefault_0 = __vite__cjsImport0_react["Component"]; ' +
        'export default __vite__cjsExportDefault_0',
    )
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/index.spec.ts
================================================
import { afterAll, describe, expect, test, vi } from 'vitest'
import { type InlineConfig, type Plugin, build, createServer } from '../..'

const getConfigWithPlugin = (
  plugins: Plugin[],
  input?: string[],
): InlineConfig => {
  return {
    configFile: false,
    server: { middlewareMode: true, ws: false },
    optimizeDeps: { noDiscovery: true, include: [] },
    build: { rollupOptions: { input }, write: false },
    plugins,
    logLevel: 'silent',
  }
}

describe('hook filter with plugin container', async () => {
  const resolveId = vi.fn()
  const load = vi.fn()
  const transformWithId = vi.fn()
  const transformWithCode = vi.fn()
  const any = expect.toSatisfy(() => true) // anything including undefined and null
  const config = getConfigWithPlugin([
    {
      name: 'test',
      resolveId: {
        filter: { id: /\.js$/ },
        handler: resolveId,
      },
      load: {
        filter: { id: '**/*.js' },
        handler: load,
      },
      transform: {
        filter: { id: '**/*.js' },
        handler: transformWithId,
      },
    },
    {
      name: 'test2',
      transform: {
        filter: { code: 'import.meta' },
        handler: transformWithCode,
      },
    },
  ])
  const server = await createServer(config)
  afterAll(async () => {
    await server.close()
  })
  const pluginContainer = server.environments.ssr.pluginContainer

  test('resolveId', async () => {
    await pluginContainer.resolveId('foo.js')
    await pluginContainer.resolveId('foo.ts')
    expect(resolveId).toHaveBeenCalledTimes(1)
    expect(resolveId).toHaveBeenCalledWith('foo.js', any, any)
  })

  test('load', async () => {
    await pluginContainer.load('foo.js')
    await pluginContainer.load('foo.ts')
    expect(load).toHaveBeenCalledTimes(1)
    expect(load).toHaveBeenCalledWith('foo.js', any)
  })

  test('transform', async () => {
    await server.environments.ssr.moduleGraph.ensureEntryFromUrl('foo.js')
    await server.environments.ssr.moduleGraph.ensureEntryFromUrl('foo.ts')

    await pluginContainer.transform('import_meta', 'foo.js')
    await pluginContainer.transform('import.meta', 'foo.ts')
    expect(transformWithId).toHaveBeenCalledTimes(1)
    expect(transformWithId).toHaveBeenCalledWith(
      expect.stringContaining('import_meta'),
      'foo.js',
      any,
    )
    expect(transformWithCode).toHaveBeenCalledTimes(1)
    expect(transformWithCode).toHaveBeenCalledWith(
      expect.stringContaining('import.meta'),
      'foo.ts',
      any,
    )
  })
})

describe('hook filter with build', async () => {
  const resolveId = vi.fn()
  const load = vi.fn()
  const transformWithId = vi.fn()
  const transformWithCode = vi.fn()
  const any = expect.anything()
  const config = getConfigWithPlugin(
    [
      {
        name: 'test',
        resolveId: {
          filter: { id: /\.js$/ },
          handler: resolveId,
        },
        load: {
          filter: { id: '**/*.js' },
          handler: load,
        },
        transform: {
          filter: { id: '**/*.js' },
          handler: transformWithId,
        },
      },
      {
        name: 'test2',
        transform: {
          filter: { code: 'import.meta' },
          handler: transformWithCode,
        },
      },
      {
        name: 'resolver',
        resolveId(id) {
          return id
        },
        load(id) {
          if (id === 'foo.js') {
            return 'import "foo.ts"\n' + 'import_meta'
          }
          if (id === 'foo.ts') {
            return 'import.meta'
          }
        },
      },
    ],
    ['foo.js', 'foo.ts'],
  )
  await build(config)

  test('resolveId', async () => {
    expect(resolveId).toHaveBeenCalledTimes(1)
    expect(resolveId).toHaveBeenCalledWith('foo.js', undefined, any)
  })

  test('load', async () => {
    expect(load).toHaveBeenCalledTimes(1)
    expect(load).toHaveBeenCalledWith('foo.js', any)
  })

  test('transform', async () => {
    expect(transformWithId).toHaveBeenCalledTimes(1)
    expect(transformWithId).toHaveBeenCalledWith(
      expect.stringContaining('import_meta'),
      'foo.js',
      any,
    )
    expect(transformWithCode).toHaveBeenCalledTimes(1)
    expect(transformWithCode).toHaveBeenCalledWith(
      expect.stringContaining('import.meta'),
      'foo.ts',
      any,
    )
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/json.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import {
  type JsonOptions,
  extractJsonErrorPosition,
  jsonPlugin,
} from '../../plugins/json'

const getErrorMessage = (input: string) => {
  try {
    JSON.parse(input)
    throw new Error('No error happened')
  } catch (e) {
    return e.message
  }
}

test('can extract json error position', () => {
  const cases = [
    { input: '{', expectedPosition: 0 },
    { input: '{},', expectedPosition: 1 },
    { input: '"f', expectedPosition: 1 },
    { input: '[', expectedPosition: 0 },
  ]

  for (const { input, expectedPosition } of cases) {
    expect(extractJsonErrorPosition(getErrorMessage(input), input.length)).toBe(
      expectedPosition,
    )
  }
})

describe('transform', () => {
  const transform = (
    input: string,
    opts: Required<JsonOptions>,
    isBuild: boolean,
  ) => {
    const plugin = jsonPlugin(opts, isBuild)
    // @ts-expect-error transform.handler should exist
    return plugin.transform.handler(input, 'test.json').code
  }

  test("namedExports: true, stringify: 'auto' should not transformed an array input", () => {
    const actualSmall = transform(
      '[{"a":1,"b":2}]',
      { namedExports: true, stringify: 'auto' },
      false,
    )
    expect(actualSmall).toMatchInlineSnapshot(`
"export default [
	{
		a: 1,
		b: 2
	}
];"
    `)
  })

  test('namedExports: true, stringify: true should not transformed an array input', () => {
    const actualSmall = transform(
      '[{"a":1,"b":2}]',
      { namedExports: true, stringify: true },
      false,
    )
    expect(actualSmall).toMatchInlineSnapshot(
      `"export default /* #__PURE__ */ JSON.parse("[{\\"a\\":1,\\"b\\":2}]")"`,
    )
  })

  test('namedExports: true, stringify: false', () => {
    const actual = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: true, stringify: false },
      false,
    )
    expect(actual).toMatchInlineSnapshot(`
      "export const a = 1;
      export default {
      	a: a,
      	"🫠": "",
      	"const": false
      };
      "
    `)
  })

  test('namedExports: false, stringify: false', () => {
    const actual = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: false, stringify: false },
      false,
    )
    expect(actual).toMatchInlineSnapshot(`
      "export default {
      	a: 1,
      	"🫠": "",
      	"const": false
      };"
    `)
  })

  test('namedExports: true, stringify: true', () => {
    const actual = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: true, stringify: true },
      false,
    )
    expect(actual).toMatchInlineSnapshot(`
      "export const a = 1;
      export default {
        a,
        "🫠": "",
        "const": false,
      };
      "
    `)
  })

  test('namedExports: false, stringify: true', () => {
    const actualDev = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: false, stringify: true },
      false,
    )
    expect(actualDev).toMatchInlineSnapshot(
      `"export default /* #__PURE__ */ JSON.parse("{\\"a\\":1,\\n\\"🫠\\": \\"\\",\\n\\"const\\": false}")"`,
    )

    const actualBuild = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: false, stringify: true },
      true,
    )
    expect(actualBuild).toMatchInlineSnapshot(
      `"export default /* #__PURE__ */ JSON.parse("{\\"a\\":1,\\"🫠\\":\\"\\",\\"const\\":false}")"`,
    )
  })

  test("namedExports: true, stringify: 'auto'", () => {
    const actualSmall = transform(
      '{"a":1,\n"🫠": "",\n"const": false}',
      { namedExports: true, stringify: 'auto' },
      false,
    )
    expect(actualSmall).toMatchInlineSnapshot(`
      "export const a = 1;
      export default {
        a,
        "🫠": "",
        "const": false,
      };
      "
    `)
    const actualLargeNonObject = transform(
      `{"a":1,\n"🫠": "${'vite'.repeat(3000)}",\n"const": false}`,
      { namedExports: true, stringify: 'auto' },
      false,
    )
    expect(actualLargeNonObject).not.toContain('JSON.parse(')

    const actualLarge = transform(
      `{"a":1,\n"🫠": {\n"foo": "${'vite'.repeat(3000)}"\n},\n"const": false}`,
      { namedExports: true, stringify: 'auto' },
      false,
    )
    expect(actualLarge).toContain('JSON.parse(')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/pluginFilter.spec.ts
================================================
import util from 'node:util'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import {
  createCodeFilter,
  createFilterForTransform,
  createIdFilter,
} from '../../plugins/pluginFilter'

describe('createIdFilter', () => {
  const filters = [
    { inputFilter: undefined, cases: undefined },
    {
      inputFilter: 'foo.js',
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
        { id: '\0foo.js', expected: false },
        { id: '\0' + path.resolve('foo.js'), expected: false },
      ],
    },
    {
      inputFilter: ['foo.js'],
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: { include: 'foo.js' },
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: { include: '*.js' },
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: { include: /\.js$/ },
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: { include: /\/foo\.js$/ },
      cases: [
        { id: 'a/foo.js', expected: true },
        ...(process.platform === 'win32'
          ? [{ id: 'a\\foo.js', expected: true }]
          : []),
        { id: 'a_foo.js', expected: false },
      ],
    },
    {
      inputFilter: { include: [/\.js$/] },
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: { exclude: 'foo.js' },
      cases: [
        { id: 'foo.js', expected: false },
        { id: 'foo.ts', expected: true },
      ],
    },
    {
      inputFilter: { exclude: '*.js' },
      cases: [
        { id: 'foo.js', expected: false },
        { id: 'foo.ts', expected: true },
      ],
    },
    {
      inputFilter: { exclude: /\.js$/ },
      cases: [
        { id: 'foo.js', expected: false },
        { id: 'foo.ts', expected: true },
      ],
    },
    {
      inputFilter: { exclude: [/\.js$/] },
      cases: [
        { id: 'foo.js', expected: false },
        { id: 'foo.ts', expected: true },
      ],
    },
    {
      inputFilter: { include: 'foo.js', exclude: 'bar.js' },
      cases: [
        { id: 'foo.js', expected: true },
        { id: 'bar.js', expected: false },
        { id: 'baz.js', expected: false },
      ],
    },
    {
      inputFilter: { include: '*.js', exclude: 'foo.*' },
      cases: [
        { id: 'foo.js', expected: false }, // exclude has higher priority
        { id: 'bar.js', expected: true },
        { id: 'foo.ts', expected: false },
      ],
    },
    {
      inputFilter: '/virtual/foo',
      cases: [{ id: '/virtual/foo', expected: true }],
    },
  ]

  for (const filter of filters) {
    test(`${util.inspect(filter.inputFilter)}`, () => {
      const idFilter = createIdFilter(filter.inputFilter, '')
      if (!filter.cases) {
        expect(idFilter).toBeUndefined()
        return
      }
      expect(idFilter).not.toBeUndefined()

      for (const testCase of filter.cases) {
        const { id, expected } = testCase
        expect(idFilter!(id), id).toBe(expected)
      }
    })
  }
})

describe('createCodeFilter', () => {
  const filters = [
    { inputFilter: undefined, cases: undefined },
    {
      inputFilter: 'import.meta',
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: ['import.meta'],
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: { include: 'import.meta' },
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: { include: /import\.\w+/ },
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: { include: [/import\.\w+/] },
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: { exclude: 'import.meta' },
      cases: [
        { code: 'import.meta', expected: false },
        { code: 'import_meta', expected: true },
      ],
    },
    {
      inputFilter: { exclude: /import\.\w+/ },
      cases: [
        { code: 'import.meta', expected: false },
        { code: 'import_meta', expected: true },
      ],
    },
    {
      inputFilter: { exclude: [/import\.\w+/] },
      cases: [
        { code: 'import.meta', expected: false },
        { code: 'import_meta', expected: true },
      ],
    },
    {
      inputFilter: { include: 'import.meta', exclude: 'import_meta' },
      cases: [
        { code: 'import.meta', expected: true },
        { code: 'import_meta', expected: false },
        { code: 'importmeta', expected: false },
      ],
    },
    {
      inputFilter: { include: /import\.\w+/, exclude: /\w+\.meta/ },
      cases: [
        { code: 'import.meta', expected: false }, // exclude has higher priority
        { code: 'import.foo', expected: true },
        { code: 'foo.meta', expected: false },
      ],
    },
  ]

  for (const filter of filters) {
    test(`${util.inspect(filter.inputFilter)}`, () => {
      const codeFilter = createCodeFilter(filter.inputFilter)
      if (!filter.cases) {
        expect(codeFilter).toBeUndefined()
        return
      }
      expect(codeFilter).not.toBeUndefined()

      for (const testCase of filter.cases) {
        const { code, expected } = testCase
        expect(codeFilter!(code), code).toBe(expected)
      }
    })
  }
})

describe('createFilterForTransform', () => {
  const filters = [
    { inputFilter: [undefined, undefined], cases: undefined },
    {
      inputFilter: ['*.js', undefined],
      cases: [
        { id: 'foo.js', code: 'foo', expected: true },
        { id: 'foo.ts', code: 'foo', expected: false },
      ],
    },
    {
      inputFilter: [undefined, 'import.meta'],
      cases: [
        { id: 'foo.js', code: 'import.meta', expected: true },
        { id: 'foo.js', code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: [{ exclude: '*.js' }, 'import.meta'],
      cases: [
        { id: 'foo.js', code: 'import.meta', expected: false },
        { id: 'foo.js', code: 'import_meta', expected: false },
        { id: 'foo.ts', code: 'import.meta', expected: true },
        { id: 'foo.ts', code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: [{ include: 'foo.ts', exclude: '*.js' }, 'import.meta'],
      cases: [
        { id: 'foo.js', code: 'import.meta', expected: false },
        { id: 'foo.js', code: 'import_meta', expected: false },
        { id: 'foo.ts', code: 'import.meta', expected: true },
        { id: 'foo.ts', code: 'import_meta', expected: false },
      ],
    },
    {
      inputFilter: [
        { include: 'a*', exclude: '*b' },
        { include: 'a', exclude: 'b' },
      ],
      cases: [
        { id: 'ab', code: '', expected: false },
        { id: 'a', code: 'b', expected: false },
        { id: 'a', code: '', expected: false },
        { id: 'c', code: 'a', expected: false },
        { id: 'a', code: 'a', expected: true },
      ],
    },
    {
      inputFilter: [{ include: 'a*', exclude: '*b' }, { exclude: 'b' }],
      cases: [
        { id: 'ab', code: '', expected: false },
        { id: 'a', code: 'b', expected: false },
        { id: 'a', code: '', expected: true },
        { id: 'c', code: 'a', expected: false },
        { id: 'a', code: 'a', expected: true },
      ],
    },
  ]

  for (const filter of filters) {
    test(`${util.inspect(filter.inputFilter)}`, () => {
      const [idFilter, codeFilter] = filter.inputFilter
      const filterForTransform = createFilterForTransform(
        idFilter,
        codeFilter,
        '',
      )
      if (!filter.cases) {
        expect(filterForTransform).toBeUndefined()
        return
      }
      expect(filterForTransform).not.toBeUndefined()

      for (const testCase of filter.cases) {
        const { id, code, expected } = testCase
        expect(filterForTransform!(id, code), util.inspect({ id, code })).toBe(
          expected,
        )
      }
    })
  }
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/terser.spec.ts
================================================
import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { build } from 'vite'
import type { RollupOutput } from 'rollup'
import type { TerserOptions } from '../../plugins/terser'

const __dirname = resolve(fileURLToPath(import.meta.url), '..')

describe('terser', () => {
  const run = async (terserOptions: TerserOptions) => {
    const result = (await build({
      root: resolve(__dirname, '../packages/build-project'),
      logLevel: 'silent',
      build: {
        write: false,
        minify: 'terser',
        terserOptions,
      },
      plugins: [
        {
          name: 'test',
          resolveId(id) {
            if (id === 'entry.js') {
              return '\0' + id
            }
          },
          load(id) {
            if (id === '\0entry.js') {
              return `const foo = 1;console.log(foo)`
            }
          },
        },
      ],
    })) as RollupOutput
    return result.output[0].code
  }

  test('basic', async () => {
    await run({})
  })

  test('nth', async () => {
    const resultCode = await run({
      mangle: {
        nth_identifier: {
          get: (n) => {
            return 'prefix_' + n.toString()
          },
        },
      },
    })
    expect(resultCode).toContain('prefix_')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/workerImportMetaUrl.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { parseAst } from 'rollup/parseAst'
import { workerImportMetaUrlPlugin } from '../../plugins/workerImportMetaUrl'
import { resolveConfig } from '../../config'
import { PartialEnvironment } from '../../baseEnvironment'

async function createWorkerImportMetaUrlPluginTransform() {
  const config = await resolveConfig({ configFile: false }, 'serve')
  const instance = workerImportMetaUrlPlugin(config)
  const environment = new PartialEnvironment('client', config)

  return async (code: string) => {
    // @ts-expect-error transform.handler should exist
    const result = await instance.transform.handler.call(
      { environment, parse: parseAst },
      code,
      'foo.ts',
    )
    return result?.code || result
  }
}

describe('workerImportMetaUrlPlugin', async () => {
  const transform = await createWorkerImportMetaUrlPluginTransform()

  test('without worker options', async () => {
    expect(
      await transform('new Worker(new URL("./worker.js", import.meta.url))'),
    ).toMatchInlineSnapshot(
      `"new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=classic", import.meta.url))"`,
    )
  })

  test('with shared worker', async () => {
    expect(
      await transform(
        'new SharedWorker(new URL("./worker.js", import.meta.url))',
      ),
    ).toMatchInlineSnapshot(
      `"new SharedWorker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=classic", import.meta.url))"`,
    )
  })

  test('with static worker options and identifier properties', async () => {
    expect(
      await transform(
        'new Worker(new URL("./worker.js", import.meta.url), { type: "module", name: "worker1" })',
      ),
    ).toMatchInlineSnapshot(
      `"new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), { type: "module", name: "worker1" })"`,
    )
  })

  test('with static worker options and literal properties', async () => {
    expect(
      await transform(
        'new Worker(new URL("./worker.js", import.meta.url), { "type": "module", "name": "worker1" })',
      ),
    ).toMatchInlineSnapshot(
      `"new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), { "type": "module", "name": "worker1" })"`,
    )
  })

  test('with dynamic name field in worker options', async () => {
    expect(
      await transform(
        'const id = 1; new Worker(new URL("./worker.js", import.meta.url), { name: "worker" + id })',
      ),
    ).toMatchInlineSnapshot(
      `"const id = 1; new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=classic", import.meta.url), { name: "worker" + id })"`,
    )
  })

  test('with interpolated dynamic name field in worker options', async () => {
    expect(
      await transform(
        'const id = 1; new Worker(new URL("./worker.js", import.meta.url), { name: `worker-${id}` })',
      ),
    ).toMatchInlineSnapshot(
      `"const id = 1; new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=classic", import.meta.url), { name: \`worker-\${id}\` })"`,
    )
  })

  test('with dynamic name field and static type in worker options', async () => {
    expect(
      await transform(
        'const id = 1; new Worker(new URL("./worker.js", import.meta.url), { name: "worker" + id, type: "module" })',
      ),
    ).toMatchInlineSnapshot(
      `"const id = 1; new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), { name: "worker" + id, type: "module" })"`,
    )
  })

  test('with interpolated dynamic name field and static type in worker options', async () => {
    expect(
      await transform(
        'const id = 1; new Worker(new URL("./worker.js", import.meta.url), { name: `worker-${id}`, type: "module" })',
      ),
    ).toMatchInlineSnapshot(
      `"const id = 1; new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), { name: \`worker-\${id}\`, type: "module" })"`,
    )
  })

  test('with parenthesis inside of worker options', async () => {
    expect(
      await transform(
        'const worker = new Worker(new URL("./worker.js", import.meta.url), { name: genName(), type: "module"})',
      ),
    ).toMatchInlineSnapshot(
      `"const worker = new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), { name: genName(), type: "module"})"`,
    )
  })

  test('with multi-line code and worker options', async () => {
    expect(
      await transform(`
const worker = new Worker(new URL("./worker.js", import.meta.url), {
    name: genName(),
    type: "module",
  },
)

worker.addEventListener('message', (ev) => text('.simple-worker-url', JSON.stringify(ev.data)))
`),
    ).toMatchInlineSnapshot(`"
const worker = new Worker(new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url), {
    name: genName(),
    type: "module",
  },
)

worker.addEventListener('message', (ev) => text('.simple-worker-url', JSON.stringify(ev.data)))
"`)
  })

  test('trailing comma', async () => {
    expect(
      await transform(`
new Worker(
  new URL('./worker.js', import.meta.url),
  {
    type: 'module'
  }, // },
)
`),
    ).toMatchInlineSnapshot(`"
new Worker(
  new URL(/* @vite-ignore */ "/worker.js?worker_file&type=module", import.meta.url),
  {
    type: 'module'
  }, // },
)
"`)
  })

  test('throws an error when non-static worker options are provided', async () => {
    await expect(
      transform(
        'new Worker(new URL("./worker.js", import.meta.url), myWorkerOptions)',
      ),
    ).rejects.toThrow(
      'Vite is unable to parse the worker options as the value is not static. To ignore this error, please use /* @vite-ignore */ in the worker options.',
    )
  })

  test('throws an error when worker options are not an object', async () => {
    await expect(
      transform(
        'new Worker(new URL("./worker.js", import.meta.url), "notAnObject")',
      ),
    ).rejects.toThrow('Expected worker options to be an object, got string')
  })

  test('throws an error when non-literal type field in worker options', async () => {
    await expect(
      transform(
        'const type = "module"; new Worker(new URL("./worker.js", import.meta.url), { type })',
      ),
    ).rejects.toThrow(
      'Expected worker options type property to be a literal value.',
    )
  })

  test('throws an error when spread operator used without the type field', async () => {
    await expect(
      transform(
        'const options = { name: "worker1" }; new Worker(new URL("./worker.js", import.meta.url), { ...options })',
      ),
    ).rejects.toThrow(
      'Expected object spread to be used before the definition of the type property. Vite needs a static value for the type property to correctly infer it.',
    )
  })

  test('throws an error when spread operator used after definition of type field', async () => {
    await expect(
      transform(
        'const options = { name: "worker1" }; new Worker(new URL("./worker.js", import.meta.url), { type: "module", ...options })',
      ),
    ).rejects.toThrow(
      'Expected object spread to be used before the definition of the type property. Vite needs a static value for the type property to correctly infer it.',
    )
  })

  test('find closing parenthesis correctly', async () => {
    expect(
      await transform(
        `(() => { new Worker(new URL('./worker', import.meta.url)); repro({ test: "foo", }); })();`,
      ),
    ).toMatchInlineSnapshot(
      `"(() => { new Worker(new URL(/* @vite-ignore */ "/worker?worker_file&type=classic", import.meta.url)); repro({ test: "foo", }); })();"`,
    )
    expect(
      await transform(
        `repro(new Worker(new URL('./worker', import.meta.url)), { type: "module" })`,
      ),
    ).toMatchInlineSnapshot(
      `"repro(new Worker(new URL(/* @vite-ignore */ "/worker?worker_file&type=classic", import.meta.url)), { type: "module" })"`,
    )
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/dynamicImportVar/parse.spec.ts
================================================
import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import { transformDynamicImport } from '../../../plugins/dynamicImportVars'
import { normalizePath } from '../../../utils'
import { isWindows } from '../../../../shared/utils'

const __dirname = resolve(fileURLToPath(import.meta.url), '..')

async function run(input: string) {
  const { glob, rawPattern } =
    (await transformDynamicImport(
      input,
      normalizePath(resolve(__dirname, 'index.js')),
      (id) =>
        id
          .replace('@', resolve(__dirname, './mods/'))
          .replace('#', resolve(__dirname, '../../')),
      __dirname,
    )) || {}
  return `__variableDynamicImportRuntimeHelper(${glob}, \`${rawPattern}\`)`
}

describe('parse positives', () => {
  it('basic', async () => {
    expect(await run('`./mods/${base}.js`')).toMatchSnapshot()
  })

  it('alias path', async () => {
    expect(await run('`@/${base}.js`')).toMatchSnapshot()
  })

  it('alias path with multi ../', async () => {
    expect(await run('`#/${base}.js`')).toMatchSnapshot()
  })

  it('with query', async () => {
    expect(await run('`./mods/${base}.js?foo=bar`')).toMatchSnapshot()
  })

  it('with query raw', async () => {
    expect(await run('`./mods/${base}.js?raw`')).toMatchSnapshot()
  })

  it('with query url', async () => {
    expect(await run('`./mods/${base}.js?url`')).toMatchSnapshot()
  })

  it('? in variables', async () => {
    expect(await run('`./mods/${base ?? foo}.js?raw`')).toMatchSnapshot()
  })

  // ? is not escaped on windows (? cannot be used as a filename on windows)
  it.skipIf(isWindows)('? in url', async () => {
    expect(await run('`./mo?ds/${base ?? foo}.js?url`')).toMatchSnapshot()
  })

  // ? is not escaped on windows (? cannot be used as a filename on windows)
  it.skipIf(isWindows)('? in worker', async () => {
    expect(await run('`./mo?ds/${base ?? foo}.js?worker`')).toMatchSnapshot()
  })

  it('with ../ and itself', async () => {
    expect(await run('`../dynamicImportVar/${name}.js`')).toMatchSnapshot()
  })

  it('with multi ../ and itself', async () => {
    expect(
      await run('`../../plugins/dynamicImportVar/${name}.js`'),
    ).toMatchSnapshot()
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/dynamicImportVar/__snapshots__/parse.spec.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`parse positives > ? in url 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mo\\\\?ds/*.js", {"query":"?url","import":"*"})), \`./mo?ds/\${base ?? foo}.js\`)"`;

exports[`parse positives > ? in variables 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js", {"query":"?raw","import":"*"})), \`./mods/\${base ?? foo}.js\`)"`;

exports[`parse positives > ? in worker 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mo\\\\?ds/*.js", {"query":"?worker","import":"*"})), \`./mo?ds/\${base ?? foo}.js\`)"`;

exports[`parse positives > alias path 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js")), \`./mods/\${base}.js\`)"`;

exports[`parse positives > alias path with multi ../ 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("../../*.js")), \`../../\${base}.js\`)"`;

exports[`parse positives > basic 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js")), \`./mods/\${base}.js\`)"`;

exports[`parse positives > with ../ and itself 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("../dynamicImportVar/*.js")), \`./\${name}.js\`)"`;

exports[`parse positives > with multi ../ and itself 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("../../plugins/dynamicImportVar/*.js")), \`./\${name}.js\`)"`;

exports[`parse positives > with query 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js", {"query":"?foo=bar"})), \`./mods/\${base}.js\`)"`;

exports[`parse positives > with query raw 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js", {"query":"?raw","import":"*"})), \`./mods/\${base}.js\`)"`;

exports[`parse positives > with query url 1`] = `"__variableDynamicImportRuntimeHelper((import.meta.glob("./mods/*.js", {"query":"?url","import":"*"})), \`./mods/\${base}.js\`)"`;



================================================
FILE: packages/vite/src/node/__tests__/plugins/dynamicImportVar/mods/hello.js
================================================
export function hello() {
  return 'hello'
}



================================================
FILE: packages/vite/src/node/__tests__/plugins/dynamicImportVar/mods/hi.js
================================================
export function hi() {
  return 'hi'
}



================================================
FILE: packages/vite/src/node/__tests__/plugins/fixtures/css-module-compose/css/bar.module.css
================================================
.bar {
  display: block;
  background: #f0f;
}



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture.spec.ts
================================================
import { dirname, resolve } from 'node:path'
import { promises as fs } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import { transformGlobImport } from '../../../plugins/importMetaGlob'
import { transformWithEsbuild } from '../../../plugins/esbuild'

const __dirname = resolve(dirname(fileURLToPath(import.meta.url)))

describe('fixture', async () => {
  const resolveId = (id: string) => id
  const root = __dirname

  it('transform', async () => {
    const id = resolve(__dirname, './fixture-a/index.ts')
    const code = (
      await transformWithEsbuild(await fs.readFile(id, 'utf-8'), id)
    ).code

    expect(
      (await transformGlobImport(code, id, root, resolveId))?.s.toString(),
    ).toMatchSnapshot()
  })

  it('preserve line count', async () => {
    const getTransformedLineCount = async (code: string) =>
      (await transformGlobImport(code, 'virtual:module', root, resolveId))?.s
        .toString()
        .split('\n').length

    expect(await getTransformedLineCount("import.meta.glob('./*.js')")).toBe(1)
    expect(
      await getTransformedLineCount(
        `
          import.meta.glob(
            './*.js'
          )
        `.trim(),
      ),
    ).toBe(3)
  })

  it('virtual modules', async () => {
    const root = resolve(__dirname, './fixture-a')
    const code = [
      "import.meta.glob('/modules/*.ts')",
      "import.meta.glob(['/../fixture-b/*.ts'])",
      "import.meta.glob(['./*.ts'], { base: '/modules' })",
    ].join('\n')
    expect(
      (
        await transformGlobImport(code, 'virtual:module', root, resolveId)
      )?.s.toString(),
    ).toMatchSnapshot()

    try {
      await transformGlobImport(
        "import.meta.glob('./modules/*.ts')",
        'virtual:module',
        root,
        resolveId,
      )
      expect('no error').toBe('should throw an error')
    } catch (err) {
      expect(err).toMatchInlineSnapshot(
        "[Error: In virtual modules, all globs must start with '/']",
      )
    }
  })

  it('transform with restoreQueryExtension', async () => {
    const id = resolve(__dirname, './fixture-a/index.ts')
    const code = (
      await transformWithEsbuild(await fs.readFile(id, 'utf-8'), id)
    ).code

    expect(
      (
        await transformGlobImport(code, id, root, resolveId, true)
      )?.s.toString(),
    ).toMatchSnapshot()
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/parse.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { parseImportGlob } from '../../../plugins/importMetaGlob'

async function run(input: string) {
  const items = await parseImportGlob(
    input,
    process.cwd(),
    process.cwd(),
    (id) => id,
  )
  return items.map((i) => ({
    globs: i.globs,
    options: i.options,
    start: i.start,
  }))
}

async function runError(input: string) {
  try {
    await run(input)
  } catch (e) {
    return e
  }
}

describe('parse positives', async () => {
  it('basic', async () => {
    expect(
      await run(`
    import.meta.glob('./modules/*.ts')
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "./modules/*.ts",
          ],
          "options": {},
          "start": 5,
        },
      ]
    `)
  })

  it('array', async () => {
    expect(
      await run(`
    import.meta.glob(['./modules/*.ts', './dir/*.{js,ts}'])
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "./modules/*.ts",
            "./dir/*.{js,ts}",
          ],
          "options": {},
          "start": 5,
        },
      ]
    `)
  })

  it('options with multilines', async () => {
    expect(
      await run(`
    import.meta.glob([
      './modules/*.ts',
      "!./dir/*.{js,ts}"
    ], {
      eager: true,
      import: 'named'
    })
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "./modules/*.ts",
            "!./dir/*.{js,ts}",
          ],
          "options": {
            "eager": true,
            "import": "named",
          },
          "start": 5,
        },
      ]
    `)
  })

  it('options with multilines', async () => {
    expect(
      await run(`
    const modules = import.meta.glob(
      '/dir/**'
      // for test: annotation contain ")"
      /*
       * for test: annotation contain ")"
       * */
    )
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "/dir/**",
          ],
          "options": {},
          "start": 21,
        },
      ]
    `)
  })

  it('options query', async () => {
    expect(
      await run(`
    const modules = import.meta.glob(
      '/dir/**',
      {
        query: {
          foo: 'bar',
          raw: true,
        }
      }
    )
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "/dir/**",
          ],
          "options": {
            "query": "?foo=bar&raw=true",
          },
          "start": 21,
        },
      ]
    `)
  })

  it('options with base', async () => {
    expect(
      await run(`
    import.meta.glob('./**/dir/*.md', {
      base: './path/to/base'
    })
    `),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "./**/dir/*.md",
          ],
          "options": {
            "base": "./path/to/base",
          },
          "start": 5,
        },
      ]
    `)
  })

  it('object properties - 1', async () => {
    expect(
      await run(`
    export const pageFiles = {
      '.page': import.meta.glob('/**/*.page.*([a-zA-Z0-9])')
};`),
    ).toMatchInlineSnapshot(`
  [
    {
      "globs": [
        "/**/*.page.*([a-zA-Z0-9])",
      ],
      "options": {},
      "start": 47,
    },
  ]
`)
  })

  it('object properties - 2', async () => {
    expect(
      await run(`
    export const pageFiles = {
      '.page': import.meta.glob('/**/*.page.*([a-zA-Z0-9])'),
};`),
    ).toMatchInlineSnapshot(`
  [
    {
      "globs": [
        "/**/*.page.*([a-zA-Z0-9])",
      ],
      "options": {},
      "start": 47,
    },
  ]
`)
  })

  it('object properties - 3', async () => {
    expect(
      await run(`
    export const pageFiles = {
      '.page.client': import.meta.glob('/**/*.page.client.*([a-zA-Z0-9])'),
      '.page.server': import.meta.glob('/**/*.page.server.*([a-zA-Z0-9])'),
};`),
    ).toMatchInlineSnapshot(`
  [
    {
      "globs": [
        "/**/*.page.client.*([a-zA-Z0-9])",
      ],
      "options": {},
      "start": 54,
    },
    {
      "globs": [
        "/**/*.page.server.*([a-zA-Z0-9])",
      ],
      "options": {},
      "start": 130,
    },
  ]
`)
  })

  it('array item', async () => {
    expect(
      await run(`
    export const pageFiles = [
      import.meta.glob('/**/*.page.client.*([a-zA-Z0-9])'),
      import.meta.glob('/**/*.page.server.*([a-zA-Z0-9])'),
    ]`),
    ).toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "/**/*.page.client.*([a-zA-Z0-9])",
          ],
          "options": {},
          "start": 38,
        },
        {
          "globs": [
            "/**/*.page.server.*([a-zA-Z0-9])",
          ],
          "options": {},
          "start": 98,
        },
      ]
    `)
  })
})

describe('parse negatives', async () => {
  it('syntax error', async () => {
    expect(await runError('import.meta.glob(')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Close parenthesis not found]',
    )
  })

  it('empty', async () => {
    expect(await runError('import.meta.glob()')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected 1-2 arguments, but got 0]',
    )
  })

  it('3 args', async () => {
    expect(
      await runError('import.meta.glob("", {}, {})'),
    ).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected 1-2 arguments, but got 3]',
    )
  })

  it('in string', async () => {
    expect(await runError('"import.meta.glob()"')).toBeUndefined()
  })

  it('variable', async () => {
    expect(await runError('import.meta.glob(hey)')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Could only use literals]',
    )
  })

  it('template', async () => {
    expect(
      await runError('import.meta.glob(`hi ${hey}`)'),
    ).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected glob to be a string, but got dynamic template literal]',
    )
  })

  it('template with unicode', async () => {
    expect(await run('import.meta.glob(`/\u0068\u0065\u006c\u006c\u006f`)'))
      .toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "/hello",
          ],
          "options": {},
          "start": 0,
        },
      ]
    `)
  })

  it('template without expressions', async () => {
    expect(await run('import.meta.glob(`/**/*.page.client.*([a-zA-Z0-9])`)'))
      .toMatchInlineSnapshot(`
      [
        {
          "globs": [
            "/**/*.page.client.*([a-zA-Z0-9])",
          ],
          "options": {},
          "start": 0,
        },
      ]
    `)
  })

  it('be string', async () => {
    expect(await runError('import.meta.glob(1)')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected glob to be a string, but got "number"]',
    )
  })

  it('be array variable', async () => {
    expect(await runError('import.meta.glob([hey])')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Could only use literals]',
    )
    expect(
      await runError('import.meta.glob(["1", hey])'),
    ).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Could only use literals]',
    )
  })

  it('options', async () => {
    expect(
      await runError('import.meta.glob("hey", hey)'),
    ).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected the second argument to be an object literal, but got "Identifier"]',
    )
    expect(await runError('import.meta.glob("hey", [])')).toMatchInlineSnapshot(
      '[Error: Invalid glob import syntax: Expected the second argument to be an object literal, but got "ArrayExpression"]',
    )
  })

  it('options props', async () => {
    expect(
      await runError('import.meta.glob("hey", { hey: 1 })'),
    ).toMatchInlineSnapshot('[Error: Unknown glob option "hey"]')
    expect(
      await runError('import.meta.glob("hey", { import: hey })'),
    ).toMatchInlineSnapshot(
      '[Error: Vite is unable to parse the glob options as the value is not static]',
    )
    expect(
      await runError('import.meta.glob("hey", { eager: 123 })'),
    ).toMatchInlineSnapshot(
      '[Error: Expected glob option "eager" to be of type boolean, but got number]',
    )
  })

  it('options query', async () => {
    expect(
      await runError('import.meta.glob("./*.js", { as: "raw", query: "hi" })'),
    ).toMatchInlineSnapshot(
      '[Error: Options "as" and "query" cannot be used together]',
    )
    expect(
      await runError('import.meta.glob("./*.js", { query: 123 })'),
    ).toMatchInlineSnapshot(
      '[Error: Expected glob option "query" to be of type object or string, but got number]',
    )
    expect(
      await runError('import.meta.glob("./*.js", { query: { foo: {} } })'),
    ).toMatchInlineSnapshot(
      '[Error: Expected glob option "query.foo" to be of type string, number, or boolean, but got object]',
    )
    expect(
      await runError('import.meta.glob("./*.js", { query: { foo: hey } })'),
    ).toMatchInlineSnapshot(
      '[Error: Vite is unable to parse the glob options as the value is not static]',
    )
    expect(
      await runError(
        'import.meta.glob("./*.js", { query: { foo: 123, ...a } })',
      ),
    ).toMatchInlineSnapshot(
      '[Error: Vite is unable to parse the glob options as the value is not static]',
    )
  })

  it('options base', async () => {
    expect(
      await runError('import.meta.glob("./*.js", { base: 1 })'),
    ).toMatchInlineSnapshot(
      '[Error: Expected glob option "base" to be of type string, but got number]',
    )
    expect(
      await runError('import.meta.glob("./*.js", { base: "foo" })'),
    ).toMatchInlineSnapshot(
      "[Error: Option \"base\" must start with '/', './' or '../', but got \"foo\"]",
    )
    expect(
      await runError('import.meta.glob("./*.js", { base: "!/foo" })'),
    ).toMatchInlineSnapshot('[Error: Option "base" cannot start with "!"]')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/utils.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { getCommonBase } from '../../../plugins/importMetaGlob'

describe('getCommonBase()', async () => {
  it('basic', () => {
    expect(getCommonBase(['/a/b/*.js', '/a/c/*.js'])).toBe('/a')
  })
  it('common base', () => {
    expect(getCommonBase(['/a/b/**/*.vue', '/a/b/**/*.jsx'])).toBe('/a/b')
  })
  it('static file', () => {
    expect(
      getCommonBase(['/a/b/**/*.vue', '/a/b/**/*.jsx', '/a/b/foo.js']),
    ).toBe('/a/b')
    expect(getCommonBase(['/a/b/**/*.vue', '/a/b/**/*.jsx', '/a/foo.js'])).toBe(
      '/a',
    )
  })
  it('correct `scan()`', () => {
    expect(getCommonBase(['/a/*.vue'])).toBe('/a')
    expect(getCommonBase(['/a/some.vue'])).toBe('/a')
    expect(getCommonBase(['/a/b/**/c/foo.vue', '/a/b/c/**/*.jsx'])).toBe('/a/b')
  })
  it('single', () => {
    expect(getCommonBase(['/a/b/c/*.vue'])).toBe('/a/b/c')
    expect(getCommonBase(['/a/b/c/foo.vue'])).toBe('/a/b/c')
  })
  it('no common base', () => {
    expect(getCommonBase(['/a/b/*.js', '/c/a/b/*.js'])).toBe('/')
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/__snapshots__/fixture.spec.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`fixture > transform 1`] = `
"import * as __vite_glob_3_0 from "./modules/a.ts";import * as __vite_glob_3_1 from "./modules/b.ts";import * as __vite_glob_3_2 from "./modules/index.ts";import * as __vite_glob_5_0 from "./modules/a.ts";import * as __vite_glob_5_1 from "./modules/b.ts";import * as __vite_glob_5_2 from "./modules/index.ts";import { name as __vite_glob_9_0 } from "./modules/a.ts";import { name as __vite_glob_9_1 } from "./modules/b.ts";import { name as __vite_glob_9_2 } from "./modules/index.ts";import { name as __vite_glob_11_0 } from "./modules/a.ts";import { name as __vite_glob_11_1 } from "./modules/b.ts";import { name as __vite_glob_11_2 } from "./modules/index.ts";import { default as __vite_glob_15_0 } from "./modules/a.ts?raw";import { default as __vite_glob_15_1 } from "./modules/b.ts?raw";import "types/importMeta";
export const basic = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"./modules/index.ts": () => import("./modules/index.ts")});
export const basicWithObjectKeys = Object.keys({"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0});
export const basicWithObjectValues = Object.values([() => import("./modules/a.ts"),() => import("./modules/b.ts"),() => import("./modules/index.ts")]);
export const basicEager = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_3_0,"./modules/b.ts": __vite_glob_3_1,"./modules/index.ts": __vite_glob_3_2

});
export const basicEagerWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0

}
);
export const basicEagerWithObjectValues = Object.values(
  [__vite_glob_5_0,__vite_glob_5_1,__vite_glob_5_2

]
);
export const ignore = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts")});
export const ignoreWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0}
);
export const ignoreWithObjectValues = Object.values(
  [() => import("./modules/a.ts"),() => import("./modules/b.ts")]
);
export const namedEager = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_9_0,"./modules/b.ts": __vite_glob_9_1,"./modules/index.ts": __vite_glob_9_2


});
export const namedEagerWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0


}
);
export const namedEagerWithObjectValues = Object.values(
  [__vite_glob_11_0,__vite_glob_11_1,__vite_glob_11_2


]
);
export const namedDefault = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts").then(m => m["default"]),"./modules/b.ts": () => import("./modules/b.ts").then(m => m["default"]),"./modules/index.ts": () => import("./modules/index.ts").then(m => m["default"])

});
export const namedDefaultWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0

}
);
export const namedDefaultWithObjectValues = Object.values(
  [() => import("./modules/a.ts").then(m => m["default"]),() => import("./modules/b.ts").then(m => m["default"]),() => import("./modules/index.ts").then(m => m["default"])

]
);
export const eagerAs = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_15_0,"./modules/b.ts": __vite_glob_15_1


});
export const rawImportModule = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts?raw"),"./modules/b.ts": () => import("./modules/b.ts?raw")


});
export const excludeSelf = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts")





});
export const excludeSelfRaw = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?raw")});
export const customQueryString = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?custom")});
export const customQueryObject = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?foo=bar&raw=true")




});
export const parent = /* #__PURE__ */ Object.assign({


});
export const rootMixedRelative = /* #__PURE__ */ Object.assign({"/fixture-b/a.ts": () => import("../fixture-b/a.ts?url").then(m => m["default"]),"/fixture-b/b.ts": () => import("../fixture-b/b.ts?url").then(m => m["default"]),"/fixture-b/index.ts": () => import("../fixture-b/index.ts?url").then(m => m["default"]),"/fixture.spec.ts": () => import("../fixture.spec.ts?url").then(m => m["default"]),"/parse.spec.ts": () => import("../parse.spec.ts?url").then(m => m["default"]),"/utils.spec.ts": () => import("../utils.spec.ts?url").then(m => m["default"])


});
export const cleverCwd1 = /* #__PURE__ */ Object.assign({"./node_modules/framework/pages/hello.page.js": () => import("./node_modules/framework/pages/hello.page.js")

});
export const cleverCwd2 = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"../fixture-b/a.ts": () => import("../fixture-b/a.ts"),"../fixture-b/b.ts": () => import("../fixture-b/b.ts")



});
export const customBase = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"./modules/index.ts": () => import("./modules/index.ts"),"./sibling.ts": () => import("./sibling.ts")});
export const customRootBase = /* #__PURE__ */ Object.assign({"./a.ts": () => import("/fixture-b/a.ts"),"./b.ts": () => import("/fixture-b/b.ts"),"./index.ts": () => import("/fixture-b/index.ts")

});
export const customBaseParent = /* #__PURE__ */ Object.assign({"../fixture-b/a.ts": () => import("/fixture-b/a.ts"),"../fixture-b/b.ts": () => import("/fixture-b/b.ts"),"../fixture-b/index.ts": () => import("/fixture-b/index.ts")

});
"
`;

exports[`fixture > transform with restoreQueryExtension 1`] = `
"import * as __vite_glob_3_0 from "./modules/a.ts";import * as __vite_glob_3_1 from "./modules/b.ts";import * as __vite_glob_3_2 from "./modules/index.ts";import * as __vite_glob_5_0 from "./modules/a.ts";import * as __vite_glob_5_1 from "./modules/b.ts";import * as __vite_glob_5_2 from "./modules/index.ts";import { name as __vite_glob_9_0 } from "./modules/a.ts";import { name as __vite_glob_9_1 } from "./modules/b.ts";import { name as __vite_glob_9_2 } from "./modules/index.ts";import { name as __vite_glob_11_0 } from "./modules/a.ts";import { name as __vite_glob_11_1 } from "./modules/b.ts";import { name as __vite_glob_11_2 } from "./modules/index.ts";import { default as __vite_glob_15_0 } from "./modules/a.ts?raw";import { default as __vite_glob_15_1 } from "./modules/b.ts?raw";import "types/importMeta";
export const basic = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"./modules/index.ts": () => import("./modules/index.ts")});
export const basicWithObjectKeys = Object.keys({"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0});
export const basicWithObjectValues = Object.values([() => import("./modules/a.ts"),() => import("./modules/b.ts"),() => import("./modules/index.ts")]);
export const basicEager = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_3_0,"./modules/b.ts": __vite_glob_3_1,"./modules/index.ts": __vite_glob_3_2

});
export const basicEagerWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0

}
);
export const basicEagerWithObjectValues = Object.values(
  [__vite_glob_5_0,__vite_glob_5_1,__vite_glob_5_2

]
);
export const ignore = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts")});
export const ignoreWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0}
);
export const ignoreWithObjectValues = Object.values(
  [() => import("./modules/a.ts"),() => import("./modules/b.ts")]
);
export const namedEager = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_9_0,"./modules/b.ts": __vite_glob_9_1,"./modules/index.ts": __vite_glob_9_2


});
export const namedEagerWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0


}
);
export const namedEagerWithObjectValues = Object.values(
  [__vite_glob_11_0,__vite_glob_11_1,__vite_glob_11_2


]
);
export const namedDefault = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts").then(m => m["default"]),"./modules/b.ts": () => import("./modules/b.ts").then(m => m["default"]),"./modules/index.ts": () => import("./modules/index.ts").then(m => m["default"])

});
export const namedDefaultWithObjectKeys = Object.keys(
  {"./modules/a.ts": 0,"./modules/b.ts": 0,"./modules/index.ts": 0

}
);
export const namedDefaultWithObjectValues = Object.values(
  [() => import("./modules/a.ts").then(m => m["default"]),() => import("./modules/b.ts").then(m => m["default"]),() => import("./modules/index.ts").then(m => m["default"])

]
);
export const eagerAs = /* #__PURE__ */ Object.assign({"./modules/a.ts": __vite_glob_15_0,"./modules/b.ts": __vite_glob_15_1


});
export const rawImportModule = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts?raw"),"./modules/b.ts": () => import("./modules/b.ts?raw")


});
export const excludeSelf = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts")





});
export const excludeSelfRaw = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?raw")});
export const customQueryString = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?custom&lang.ts")});
export const customQueryObject = /* #__PURE__ */ Object.assign({"./sibling.ts": () => import("./sibling.ts?foo=bar&raw=true&lang.ts")




});
export const parent = /* #__PURE__ */ Object.assign({


});
export const rootMixedRelative = /* #__PURE__ */ Object.assign({"/fixture-b/a.ts": () => import("../fixture-b/a.ts?url&lang.ts").then(m => m["default"]),"/fixture-b/b.ts": () => import("../fixture-b/b.ts?url&lang.ts").then(m => m["default"]),"/fixture-b/index.ts": () => import("../fixture-b/index.ts?url&lang.ts").then(m => m["default"]),"/fixture.spec.ts": () => import("../fixture.spec.ts?url&lang.ts").then(m => m["default"]),"/parse.spec.ts": () => import("../parse.spec.ts?url&lang.ts").then(m => m["default"]),"/utils.spec.ts": () => import("../utils.spec.ts?url&lang.ts").then(m => m["default"])


});
export const cleverCwd1 = /* #__PURE__ */ Object.assign({"./node_modules/framework/pages/hello.page.js": () => import("./node_modules/framework/pages/hello.page.js")

});
export const cleverCwd2 = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"../fixture-b/a.ts": () => import("../fixture-b/a.ts"),"../fixture-b/b.ts": () => import("../fixture-b/b.ts")



});
export const customBase = /* #__PURE__ */ Object.assign({"./modules/a.ts": () => import("./modules/a.ts"),"./modules/b.ts": () => import("./modules/b.ts"),"./modules/index.ts": () => import("./modules/index.ts"),"./sibling.ts": () => import("./sibling.ts")});
export const customRootBase = /* #__PURE__ */ Object.assign({"./a.ts": () => import("/fixture-b/a.ts"),"./b.ts": () => import("/fixture-b/b.ts"),"./index.ts": () => import("/fixture-b/index.ts")

});
export const customBaseParent = /* #__PURE__ */ Object.assign({"../fixture-b/a.ts": () => import("/fixture-b/a.ts"),"../fixture-b/b.ts": () => import("/fixture-b/b.ts"),"../fixture-b/index.ts": () => import("/fixture-b/index.ts")

});
"
`;

exports[`fixture > virtual modules 1`] = `
"/* #__PURE__ */ Object.assign({"/modules/a.ts": () => import("/modules/a.ts"),"/modules/b.ts": () => import("/modules/b.ts"),"/modules/index.ts": () => import("/modules/index.ts")})
/* #__PURE__ */ Object.assign({"/../fixture-b/a.ts": () => import("/../fixture-b/a.ts"),"/../fixture-b/b.ts": () => import("/../fixture-b/b.ts"),"/../fixture-b/index.ts": () => import("/../fixture-b/index.ts")})
/* #__PURE__ */ Object.assign({"./a.ts": () => import("/modules/a.ts"),"./b.ts": () => import("/modules/b.ts"),"./index.ts": () => import("/modules/index.ts")})"
`;



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-a/index.ts
================================================
import 'types/importMeta'

export interface ModuleType {
  name: string
}

export const basic = import.meta.glob<ModuleType>('./modules/*.ts')
// prettier-ignore
export const basicWithObjectKeys = Object.keys(import.meta.glob<ModuleType>('./modules/*.ts'))
// prettier-ignore
export const basicWithObjectValues = Object.values(import.meta.glob<ModuleType>('./modules/*.ts'))

export const basicEager = import.meta.glob<ModuleType>('./modules/*.ts', {
  eager: true,
})
export const basicEagerWithObjectKeys = Object.keys(
  import.meta.glob<ModuleType>('./modules/*.ts', {
    eager: true,
  }),
)
export const basicEagerWithObjectValues = Object.values(
  import.meta.glob<ModuleType>('./modules/*.ts', {
    eager: true,
  }),
)

export const ignore = import.meta.glob(['./modules/*.ts', '!**/index.ts'])
export const ignoreWithObjectKeys = Object.keys(
  import.meta.glob(['./modules/*.ts', '!**/index.ts']),
)
export const ignoreWithObjectValues = Object.values(
  import.meta.glob(['./modules/*.ts', '!**/index.ts']),
)

export const namedEager = import.meta.glob<string>('./modules/*.ts', {
  eager: true,
  import: 'name',
})
export const namedEagerWithObjectKeys = Object.keys(
  import.meta.glob<string>('./modules/*.ts', {
    eager: true,
    import: 'name',
  }),
)
export const namedEagerWithObjectValues = Object.values(
  import.meta.glob<string>('./modules/*.ts', {
    eager: true,
    import: 'name',
  }),
)

export const namedDefault = import.meta.glob<string>('./modules/*.ts', {
  import: 'default',
})
export const namedDefaultWithObjectKeys = Object.keys(
  import.meta.glob<string>('./modules/*.ts', {
    import: 'default',
  }),
)
export const namedDefaultWithObjectValues = Object.values(
  import.meta.glob<string>('./modules/*.ts', {
    import: 'default',
  }),
)

export const eagerAs = import.meta.glob<ModuleType>(
  ['./modules/*.ts', '!**/index.ts'],
  { eager: true, query: '?raw', import: 'default' },
)

export const rawImportModule = import.meta.glob(
  ['./modules/*.ts', '!**/index.ts'],
  { query: '?raw', import: '*' },
)

export const excludeSelf = import.meta.glob(
  './*.ts',
  // for test: annotation contain ")"
  /*
   * for test: annotation contain ")"
   * */
)
export const excludeSelfRaw = import.meta.glob('./*.ts', { query: '?raw' })

export const customQueryString = import.meta.glob('./*.ts', { query: 'custom' })

export const customQueryObject = import.meta.glob('./*.ts', {
  query: {
    foo: 'bar',
    raw: true,
  },
})

export const parent = import.meta.glob('../../playground/src/*.ts', {
  query: '?url',
  import: 'default',
})

export const rootMixedRelative = import.meta.glob(
  ['/*.ts', '../fixture-b/*.ts'],
  { query: '?url', import: 'default' },
)

export const cleverCwd1 = import.meta.glob(
  './node_modules/framework/**/*.page.js',
)

export const cleverCwd2 = import.meta.glob([
  './modules/*.ts',
  '../fixture-b/*.ts',
  '!**/index.ts',
])

export const customBase = import.meta.glob('./**/*.ts', { base: './' })

export const customRootBase = import.meta.glob('./**/*.ts', {
  base: '/fixture-b',
})

export const customBaseParent = import.meta.glob('/fixture-b/**/*.ts', {
  base: '/fixture-a',
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-a/sibling.ts
================================================
export const name = 'I am your sibling!'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-a/modules/a.ts
================================================
export const name = 'a'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-a/modules/b.ts
================================================
export const name = 'b'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-a/modules/index.ts
================================================
export { name as a } from './a'
export { name as b } from './b'

export const name = 'index'

export default 'indexDefault'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-b/a.ts
================================================
export const name = 'a'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-b/b.ts
================================================
export const name = 'b'



================================================
FILE: packages/vite/src/node/__tests__/plugins/importGlob/fixture-b/index.ts
================================================
export { name as a } from './a'
export { name as b } from './b'



================================================
FILE: packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/modulePreloadPolyfill.spec.ts
================================================
import { describe, it } from 'vitest'
import type { ModuleFormat, RollupOutput } from 'rollup'
import { build } from '../../../build'
import { modulePreloadPolyfillId } from '../../../plugins/modulePreloadPolyfill'

const buildProject = ({ format = 'es' as ModuleFormat } = {}) =>
  build({
    logLevel: 'silent',
    build: {
      write: false,
      rollupOptions: {
        input: 'main.js',
        output: {
          format,
        },
        treeshake: {
          moduleSideEffects: false,
        },
      },
      minify: false,
    },
    plugins: [
      {
        name: 'test',
        resolveId(id) {
          if (id === 'main.js') {
            return `\0${id}`
          }
        },
        load(id) {
          if (id === '\0main.js') {
            return `import '${modulePreloadPolyfillId}'`
          }
        },
      },
    ],
  }) as Promise<RollupOutput>

describe('load', () => {
  it('loads modulepreload polyfill', async ({ expect }) => {
    const { output } = await buildProject()
    expect(output).toHaveLength(1)
    expect(output[0].code).toMatchSnapshot()
  })

  it("doesn't load modulepreload polyfill when format is cjs", async ({
    expect,
  }) => {
    const { output } = await buildProject({ format: 'cjs' })
    expect(output).toHaveLength(1)
    expect(output[0].code).toMatchSnapshot()
  })
})



================================================
FILE: packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/__snapshots__/modulePreloadPolyfill.spec.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`load > doesn't load modulepreload polyfill when format is cjs 1`] = `
""use strict";
"
`;

exports[`load > loads modulepreload polyfill 1`] = `
"(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
"
`;



================================================
FILE: packages/vite/src/node/__tests__/utils/isFileReadable/permission-test-file
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/__tests_dts__/config.ts
================================================
/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-unused-vars */
import type { Equal, ExpectTrue } from '@type-challenges/utils'
import {
  type UserConfig,
  type UserConfigExport,
  type UserConfigFn,
  type UserConfigFnObject,
  type UserConfigFnPromise,
  defineConfig,
} from '../config'
import { mergeConfig } from '../utils'

const configObjectDefined = defineConfig({})
const configObjectPromiseDefined = defineConfig(Promise.resolve({}))
const configFnObjectDefined = defineConfig(() => ({}))
const configFnPromiseDefined = defineConfig(async () => ({}))
const configFnDefined = defineConfig(() =>
  // TypeScript requires both non-promise config and
  // promise config to have at least one property
  Math.random() > 0.5 ? { base: '' } : Promise.resolve({ base: '/' }),
)
const configExportDefined = defineConfig({} as UserConfigExport)

export type cases1 = [
  ExpectTrue<Equal<typeof configObjectDefined, UserConfig>>,
  ExpectTrue<Equal<typeof configObjectPromiseDefined, Promise<UserConfig>>>,
  ExpectTrue<Equal<typeof configFnObjectDefined, UserConfigFnObject>>,
  ExpectTrue<Equal<typeof configFnPromiseDefined, UserConfigFnPromise>>,
  ExpectTrue<Equal<typeof configFnDefined, UserConfigFn>>,
  ExpectTrue<Equal<typeof configExportDefined, UserConfigExport>>,
]

defineConfig({
  base: '',
  // @ts-expect-error
  unknownProperty: 1,
})

mergeConfig(defineConfig({}), defineConfig({}))
mergeConfig(
  // @ts-expect-error
  defineConfig(() => ({})),
  defineConfig({}),
)

export {}



================================================
FILE: packages/vite/src/node/__tests_dts__/plugin.ts
================================================
/**
 * This is a development only file for testing types.
 */
import type { Plugin as RollupPlugin } from 'rollup'
import type { Equal, ExpectExtends, ExpectTrue } from '@type-challenges/utils'
import type { Plugin, PluginContextExtension } from '../plugin'
import type { ROLLUP_HOOKS } from '../constants'
import type {
  GetHookContextMap,
  NonNeverKeys,
  RollupPluginHooks,
} from '../typeUtils'

type EnvironmentPluginHooksContext = GetHookContextMap<Plugin>
type EnvironmentPluginHooksContextMatched = {
  [K in keyof EnvironmentPluginHooksContext]: EnvironmentPluginHooksContext[K] extends PluginContextExtension
    ? never
    : false
}

type HooksMissingExtension = NonNeverKeys<EnvironmentPluginHooksContextMatched>
type HooksMissingInConstants = Exclude<
  RollupPluginHooks,
  (typeof ROLLUP_HOOKS)[number]
>

export type cases = [
  // Ensure environment plugin hooks are superset of rollup plugin hooks
  ExpectTrue<ExpectExtends<RollupPlugin, Plugin>>,

  // Ensure all Rollup hooks have Vite's plugin context extension
  ExpectTrue<Equal<HooksMissingExtension, never>>,

  // Ensure the `ROLLUP_HOOKS` constant is up-to-date
  ExpectTrue<Equal<HooksMissingInConstants, never>>,
]

export {}



================================================
FILE: packages/vite/src/node/__tests_dts__/typeOptions.ts
================================================
// This file tests `ViteTypeOptions` in `packages/vite/types/importMeta.d.ts`
import type { ExpectFalse, ExpectTrue } from '@type-challenges/utils'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
interface TypeOptions1 {}
interface TypeOptions2 {
  strictImportMetaEnv: unknown
}
interface TypeOptions3 {
  unknownKey: unknown
}

type IsEnabled<Opts, Key extends string> = Key extends keyof Opts ? true : false

export type cases = [
  ExpectFalse<IsEnabled<TypeOptions1, 'strictImportMetaEnv'>>,
  ExpectTrue<IsEnabled<TypeOptions2, 'strictImportMetaEnv'>>,
  ExpectFalse<IsEnabled<TypeOptions3, 'strictImportMetaEnv'>>,
]

export {}



================================================
FILE: packages/vite/src/node/__tests_dts__/utils.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import type { Equal, ExpectTrue } from '@type-challenges/utils'
import { mergeWithDefaults } from '../utils'

const useDefaultTypeForUndefined1 = mergeWithDefaults(
  {
    foo: 1,
  },
  {},
)

const useDefaultTypeForUndefined2 = mergeWithDefaults(
  {
    foo: 1,
  },
  {
    foo: 2 as number | undefined,
  },
)

const includeKeyNotIncludedInDefault1 = mergeWithDefaults(
  {},
  {
    foo: 2,
  },
)

const extendTypeWithValueType = mergeWithDefaults(
  {
    foo: 1,
  },
  {
    foo: 'string' as string | number,
  },
)

const plainObject = mergeWithDefaults({ foo: { bar: 1 } }, { foo: { baz: 2 } })

const nonPlainObject = mergeWithDefaults(
  { foo: ['foo'] },
  { foo: [0] as number[] | undefined },
)

const optionalNested = mergeWithDefaults({ foo: { bar: true } }, {
  foo: { bar: false },
} as { foo?: { bar?: boolean } })

export type cases1 = [
  ExpectTrue<Equal<typeof useDefaultTypeForUndefined1, { foo: number }>>,
  ExpectTrue<Equal<typeof useDefaultTypeForUndefined2, { foo: number }>>,
  ExpectTrue<Equal<typeof includeKeyNotIncludedInDefault1, { foo: number }>>,
  ExpectTrue<Equal<typeof extendTypeWithValueType, { foo: string | number }>>,
  ExpectTrue<Equal<typeof plainObject, { foo: { bar: number; baz: number } }>>,
  ExpectTrue<Equal<typeof nonPlainObject, { foo: string[] | number[] }>>,
  ExpectTrue<
    Equal<typeof optionalNested, { foo: { bar: boolean } | { bar: boolean } }>
  >,
]



================================================
FILE: packages/vite/src/node/optimizer/esbuildDepPlugin.ts
================================================
import path from 'node:path'
import type { ImportKind, Plugin } from 'esbuild'
import { JS_TYPES_RE, KNOWN_ASSET_TYPES } from '../constants'
import type { PackageCache } from '../packages'
import {
  escapeRegex,
  flattenId,
  isBuiltin,
  isCSSRequest,
  isExternalUrl,
  isNodeBuiltin,
  moduleListContains,
  normalizePath,
} from '../utils'
import { browserExternalId, optionalPeerDepId } from '../plugins/resolve'
import { isModuleCSSRequest } from '../plugins/css'
import type { Environment } from '../environment'
import { createBackCompatIdResolver } from '../idResolver'

const externalWithConversionNamespace =
  'vite:dep-pre-bundle:external-conversion'
const convertedExternalPrefix = 'vite-dep-pre-bundle-external:'

const cjsExternalFacadeNamespace = 'vite:cjs-external-facade'
const nonFacadePrefix = 'vite-cjs-external-facade:'

const externalTypes = [
  'css',
  // supported pre-processor types
  'less',
  'sass',
  'scss',
  'styl',
  'stylus',
  'pcss',
  'postcss',
  // wasm
  'wasm',
  // known SFC types
  'vue',
  'svelte',
  'marko',
  'astro',
  'imba',
  // JSX/TSX may be configured to be compiled differently from how esbuild
  // handles it by default, so exclude them as well
  'jsx',
  'tsx',
  ...KNOWN_ASSET_TYPES,
]

export function esbuildDepPlugin(
  environment: Environment,
  qualified: Record<string, string>,
  external: string[],
): Plugin {
  const { isProduction } = environment.config
  const { extensions } = environment.config.optimizeDeps

  // remove optimizable extensions from `externalTypes` list
  const allExternalTypes = extensions
    ? externalTypes.filter((type) => !extensions.includes('.' + type))
    : externalTypes

  // use separate package cache for optimizer as it caches paths around node_modules
  // and it's unlikely for the core Vite process to traverse into node_modules again
  const esmPackageCache: PackageCache = new Map()
  const cjsPackageCache: PackageCache = new Map()

  // default resolver which prefers ESM
  const _resolve = createBackCompatIdResolver(environment.getTopLevelConfig(), {
    asSrc: false,
    scan: true,
    packageCache: esmPackageCache,
  })

  // cjs resolver that prefers Node
  const _resolveRequire = createBackCompatIdResolver(
    environment.getTopLevelConfig(),
    {
      asSrc: false,
      isRequire: true,
      scan: true,
      packageCache: cjsPackageCache,
    },
  )

  const resolve = (
    id: string,
    importer: string,
    kind: ImportKind,
    resolveDir?: string,
  ): Promise<string | undefined> => {
    let _importer: string
    // explicit resolveDir - this is passed only during yarn pnp resolve for
    // entries
    if (resolveDir) {
      _importer = normalizePath(path.join(resolveDir, '*'))
    } else {
      // map importer ids to file paths for correct resolution
      _importer = importer in qualified ? qualified[importer] : importer
    }
    const resolver = kind.startsWith('require') ? _resolveRequire : _resolve
    return resolver(environment, id, _importer)
  }

  const resolveResult = (id: string, resolved: string) => {
    if (resolved.startsWith(browserExternalId)) {
      return {
        path: id,
        namespace: 'browser-external',
      }
    }
    if (resolved.startsWith(optionalPeerDepId)) {
      return {
        path: resolved,
        namespace: 'optional-peer-dep',
      }
    }
    if (isBuiltin(environment.config.resolve.builtins, resolved)) {
      return
    }
    if (isExternalUrl(resolved)) {
      return {
        path: resolved,
        external: true,
      }
    }
    return {
      path: path.resolve(resolved),
    }
  }

  return {
    name: 'vite:dep-pre-bundle',
    setup(build) {
      // clear package cache when esbuild is finished
      build.onEnd(() => {
        esmPackageCache.clear()
        cjsPackageCache.clear()
      })

      // externalize assets and commonly known non-js file types
      // See #8459 for more details about this require-import conversion
      build.onResolve(
        {
          filter: new RegExp(
            `\\.(` + allExternalTypes.join('|') + `)(\\?.*)?$`,
          ),
        },
        async ({ path: id, importer, kind }) => {
          // if the prefix exist, it is already converted to `import`, so set `external: true`
          if (id.startsWith(convertedExternalPrefix)) {
            return {
              path: id.slice(convertedExternalPrefix.length),
              external: true,
            }
          }

          const resolved = await resolve(id, importer, kind)
          if (resolved) {
            // `resolved` can be javascript even when `id` matches `allExternalTypes`
            // due to cjs resolution (e.g. require("./test.pdf") for "./test.pdf.js")
            // or package name (e.g. import "some-package.pdf")
            if (JS_TYPES_RE.test(resolved)) {
              return {
                path: resolved,
                external: false,
              }
            }

            if (kind === 'require-call') {
              // here it is not set to `external: true` to convert `require` to `import`
              return {
                path: resolved,
                namespace: externalWithConversionNamespace,
              }
            }
            return {
              path: resolved,
              external: true,
            }
          }
        },
      )
      build.onLoad(
        { filter: /./, namespace: externalWithConversionNamespace },
        (args) => {
          // import itself with prefix (this is the actual part of require-import conversion)
          const modulePath = `"${convertedExternalPrefix}${args.path}"`
          return {
            contents:
              isCSSRequest(args.path) && !isModuleCSSRequest(args.path)
                ? `import ${modulePath};`
                : `export { default } from ${modulePath};` +
                  `export * from ${modulePath};`,
            loader: 'js',
          }
        },
      )

      function resolveEntry(id: string) {
        const flatId = flattenId(id)
        if (flatId in qualified) {
          return {
            path: qualified[flatId],
          }
        }
      }

      build.onResolve(
        { filter: /^[\w@][^:]/ },
        async ({ path: id, importer, kind }) => {
          if (moduleListContains(external, id)) {
            return {
              path: id,
              external: true,
            }
          }

          // ensure esbuild uses our resolved entries
          let entry: { path: string } | undefined
          // if this is an entry, return entry namespace resolve result
          if (!importer) {
            if ((entry = resolveEntry(id))) return entry
            // check if this is aliased to an entry - also return entry namespace
            const aliased = await _resolve(environment, id, undefined, true)
            if (aliased && (entry = resolveEntry(aliased))) {
              return entry
            }
          }

          // use vite's own resolver
          const resolved = await resolve(id, importer, kind)
          if (resolved) {
            return resolveResult(id, resolved)
          }
        },
      )

      build.onLoad(
        { filter: /.*/, namespace: 'browser-external' },
        ({ path }) => {
          if (isProduction) {
            return {
              contents: 'module.exports = {}',
            }
          } else {
            return {
              // Return in CJS to intercept named imports. Use `Object.create` to
              // create the Proxy in the prototype to workaround esbuild issue. Why?
              //
              // In short, esbuild cjs->esm flow:
              // 1. Create empty object using `Object.create(Object.getPrototypeOf(module.exports))`.
              // 2. Assign props of `module.exports` to the object.
              // 3. Return object for ESM use.
              //
              // If we do `module.exports = new Proxy({}, {})`, step 1 returns empty object,
              // step 2 does nothing as there's no props for `module.exports`. The final object
              // is just an empty object.
              //
              // Creating the Proxy in the prototype satisfies step 1 immediately, which means
              // the returned object is a Proxy that we can intercept.
              //
              // Note: Skip keys that are accessed by esbuild and browser devtools.
              contents: `\
module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path}" has been externalized for browser compatibility. Cannot access "${path}.\${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  }
}))`,
            }
          }
        },
      )

      build.onLoad(
        { filter: /.*/, namespace: 'optional-peer-dep' },
        ({ path }) => {
          const [, peerDep, parentDep] = path.split(':')
          return {
            contents:
              'module.exports = {};' +
              `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}".${isProduction ? '' : ' Is it installed?'}\`)`,
          }
        },
      )
    },
  }
}

const matchesEntireLine = (text: string) => `^${escapeRegex(text)}$`

// esbuild doesn't transpile `require('foo')` into `import` statements if 'foo' is externalized
// https://github.com/evanw/esbuild/issues/566#issuecomment-735551834
export function esbuildCjsExternalPlugin(
  externals: string[],
  platform: 'node' | 'browser' | 'neutral',
): Plugin {
  return {
    name: 'cjs-external',
    setup(build) {
      const filter = new RegExp(externals.map(matchesEntireLine).join('|'))

      build.onResolve({ filter: new RegExp(`^${nonFacadePrefix}`) }, (args) => {
        return {
          path: args.path.slice(nonFacadePrefix.length),
          external: true,
        }
      })

      build.onResolve({ filter }, (args) => {
        // preserve `require` for node because it's more accurate than converting it to import
        if (args.kind === 'require-call' && platform !== 'node') {
          return {
            path: args.path,
            namespace: cjsExternalFacadeNamespace,
          }
        }

        return {
          path: args.path,
          external: true,
        }
      })

      build.onLoad(
        { filter: /.*/, namespace: cjsExternalFacadeNamespace },
        (args) => ({
          contents: `\
import * as m from ${JSON.stringify(nonFacadePrefix + args.path)};
module.exports = ${isNodeBuiltin(args.path) ? 'm.default' : '{ ...m }'};
`,
        }),
      )
    },
  }
}



================================================
FILE: packages/vite/src/node/optimizer/index.ts
================================================
import fs from 'node:fs'
import fsp from 'node:fs/promises'
import path from 'node:path'
import { promisify } from 'node:util'
import { performance } from 'node:perf_hooks'
import colors from 'picocolors'
import type { BuildContext, BuildOptions as EsbuildBuildOptions } from 'esbuild'
import esbuild, { build, formatMessages } from 'esbuild'
import { init, parse } from 'es-module-lexer'
import { isDynamicPattern } from 'tinyglobby'
import type { ResolvedConfig } from '../config'
import {
  createDebugger,
  flattenId,
  getHash,
  isOptimizable,
  lookupFile,
  normalizeId,
  normalizePath,
  removeLeadingSlash,
  tryStatSync,
  unique,
} from '../utils'
import {
  defaultEsbuildSupported,
  transformWithEsbuild,
} from '../plugins/esbuild'
import {
  ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET,
  METADATA_FILENAME,
} from '../constants'
import { isWindows } from '../../shared/utils'
import type { Environment } from '../environment'
import { esbuildCjsExternalPlugin, esbuildDepPlugin } from './esbuildDepPlugin'
import { ScanEnvironment, scanImports } from './scan'
import { createOptimizeDepsIncludeResolver, expandGlobIds } from './resolve'

const debug = createDebugger('vite:deps')

const jsExtensionRE = /\.js$/i
const jsMapExtensionRE = /\.js\.map$/i

export type ExportsData = {
  hasModuleSyntax: boolean
  // exported names (for `export { a as b }`, `b` is exported name)
  exports: readonly string[]
  // hint if the dep requires loading as jsx
  jsxLoader?: boolean
}

export interface DepsOptimizer {
  init: () => Promise<void>

  metadata: DepOptimizationMetadata
  scanProcessing?: Promise<void>
  registerMissingImport: (id: string, resolved: string) => OptimizedDepInfo
  run: () => void

  isOptimizedDepFile: (id: string) => boolean
  isOptimizedDepUrl: (url: string) => boolean
  getOptimizedDepId: (depInfo: OptimizedDepInfo) => string

  close: () => Promise<void>

  options: DepOptimizationOptions
}

export interface DepOptimizationConfig {
  /**
   * Force optimize listed dependencies (must be resolvable import paths,
   * cannot be globs).
   */
  include?: string[]
  /**
   * Do not optimize these dependencies (must be resolvable import paths,
   * cannot be globs).
   */
  exclude?: string[]
  /**
   * Forces ESM interop when importing these dependencies. Some legacy
   * packages advertise themselves as ESM but use `require` internally
   * @experimental
   */
  needsInterop?: string[]
  /**
   * Options to pass to esbuild during the dep scanning and optimization
   *
   * Certain options are omitted since changing them would not be compatible
   * with Vite's dep optimization.
   *
   * - `external` is also omitted, use Vite's `optimizeDeps.exclude` option
   * - `plugins` are merged with Vite's dep plugin
   *
   * https://esbuild.github.io/api
   */
  esbuildOptions?: Omit<
    EsbuildBuildOptions,
    | 'bundle'
    | 'entryPoints'
    | 'external'
    | 'write'
    | 'watch'
    | 'outdir'
    | 'outfile'
    | 'outbase'
    | 'outExtension'
    | 'metafile'
  >
  /**
   * List of file extensions that can be optimized. A corresponding esbuild
   * plugin must exist to handle the specific extension.
   *
   * By default, Vite can optimize `.mjs`, `.js`, `.ts`, and `.mts` files. This option
   * allows specifying additional extensions.
   *
   * @experimental
   */
  extensions?: string[]
  /**
   * Deps optimization during build was removed in Vite 5.1. This option is
   * now redundant and will be removed in a future version. Switch to using
   * `optimizeDeps.noDiscovery` and an empty or undefined `optimizeDeps.include`.
   * true or 'dev' disables the optimizer, false or 'build' leaves it enabled.
   * @default 'build'
   * @deprecated
   * @experimental
   */
  disabled?: boolean | 'build' | 'dev'
  /**
   * Automatic dependency discovery. When `noDiscovery` is true, only dependencies
   * listed in `include` will be optimized. The scanner isn't run for cold start
   * in this case. CJS-only dependencies must be present in `include` during dev.
   * @default false
   */
  noDiscovery?: boolean
  /**
   * When enabled, it will hold the first optimized deps results until all static
   * imports are crawled on cold start. This avoids the need for full-page reloads
   * when new dependencies are discovered and they trigger the generation of new
   * common chunks. If all dependencies are found by the scanner plus the explicitly
   * defined ones in `include`, it is better to disable this option to let the
   * browser process more requests in parallel.
   * @default true
   * @experimental
   */
  holdUntilCrawlEnd?: boolean
}

export type DepOptimizationOptions = DepOptimizationConfig & {
  /**
   * By default, Vite will crawl your `index.html` to detect dependencies that
   * need to be pre-bundled. If `build.rollupOptions.input` is specified, Vite
   * will crawl those entry points instead.
   *
   * If neither of these fit your needs, you can specify custom entries using
   * this option - the value should be a tinyglobby pattern or array of patterns
   * (https://github.com/SuperchupuDev/tinyglobby) that are relative from
   * vite project root. This will overwrite default entries inference.
   */
  entries?: string | string[]
  /**
   * Force dep pre-optimization regardless of whether deps have changed.
   * @experimental
   */
  force?: boolean
}

export function isDepOptimizationDisabled(
  optimizeDeps: DepOptimizationOptions,
): boolean {
  return (
    optimizeDeps.disabled === true ||
    optimizeDeps.disabled === 'dev' ||
    (!!optimizeDeps.noDiscovery && !optimizeDeps.include?.length)
  )
}

export interface DepOptimizationResult {
  metadata: DepOptimizationMetadata
  /**
   * When doing a re-run, if there are newly discovered dependencies
   * the page reload will be delayed until the next rerun so we need
   * to be able to discard the result
   */
  commit: () => Promise<void>
  cancel: () => void
}

export interface OptimizedDepInfo {
  id: string
  file: string
  src?: string
  needsInterop?: boolean
  browserHash?: string
  fileHash?: string
  /**
   * During optimization, ids can still be resolved to their final location
   * but the bundles may not yet be saved to disk
   */
  processing?: Promise<void>
  /**
   * ExportData cache, discovered deps will parse the src entry to get exports
   * data used both to define if interop is needed and when pre-bundling
   */
  exportsData?: Promise<ExportsData>
}

export interface DepOptimizationMetadata {
  /**
   * The main hash is determined by user config and dependency lockfiles.
   * This is checked on server startup to avoid unnecessary re-bundles.
   */
  hash: string
  /**
   * This hash is determined by dependency lockfiles.
   * This is checked on server startup to avoid unnecessary re-bundles.
   */
  lockfileHash: string
  /**
   * This hash is determined by user config.
   * This is checked on server startup to avoid unnecessary re-bundles.
   */
  configHash: string
  /**
   * The browser hash is determined by the main hash plus additional dependencies
   * discovered at runtime. This is used to invalidate browser requests to
   * optimized deps.
   */
  browserHash: string
  /**
   * Metadata for each already optimized dependency
   */
  optimized: Record<string, OptimizedDepInfo>
  /**
   * Metadata for non-entry optimized chunks and dynamic imports
   */
  chunks: Record<string, OptimizedDepInfo>
  /**
   * Metadata for each newly discovered dependency after processing
   */
  discovered: Record<string, OptimizedDepInfo>
  /**
   * OptimizedDepInfo list
   */
  depInfoList: OptimizedDepInfo[]
}

/**
 * Scan and optimize dependencies within a project.
 * Used by Vite CLI when running `vite optimize`.
 *
 * @deprecated the optimization process runs automatically and does not need to be called
 */

export async function optimizeDeps(
  config: ResolvedConfig,
  force = config.optimizeDeps.force,
  asCommand = false,
): Promise<DepOptimizationMetadata> {
  const log = asCommand ? config.logger.info : debug

  config.logger.warn(
    colors.yellow(
      'manually calling optimizeDeps is deprecated. This is done automatically and does not need to be called manually.',
    ),
  )

  const environment = new ScanEnvironment('client', config)
  await environment.init()

  const cachedMetadata = await loadCachedDepOptimizationMetadata(
    environment,
    force,
    asCommand,
  )
  if (cachedMetadata) {
    return cachedMetadata
  }

  const deps = await discoverProjectDependencies(environment).result

  await addManuallyIncludedOptimizeDeps(environment, deps)

  const depsString = depsLogString(Object.keys(deps))
  log?.(colors.green(`Optimizing dependencies:\n  ${depsString}`))

  const depsInfo = toDiscoveredDependencies(environment, deps)

  const result = await runOptimizeDeps(environment, depsInfo).result

  await result.commit()

  return result.metadata
}

export async function optimizeExplicitEnvironmentDeps(
  environment: Environment,
): Promise<DepOptimizationMetadata> {
  const cachedMetadata = await loadCachedDepOptimizationMetadata(
    environment,
    environment.config.optimizeDeps.force ?? false,
    false,
  )
  if (cachedMetadata) {
    return cachedMetadata
  }

  const deps: Record<string, string> = {}

  await addManuallyIncludedOptimizeDeps(environment, deps)

  const depsInfo = toDiscoveredDependencies(environment, deps)

  const result = await runOptimizeDeps(environment, depsInfo).result

  await result.commit()

  return result.metadata
}

export function initDepsOptimizerMetadata(
  environment: Environment,
  timestamp?: string,
): DepOptimizationMetadata {
  const { lockfileHash, configHash, hash } = getDepHash(environment)
  return {
    hash,
    lockfileHash,
    configHash,
    browserHash: getOptimizedBrowserHash(hash, {}, timestamp),
    optimized: {},
    chunks: {},
    discovered: {},
    depInfoList: [],
  }
}

export function addOptimizedDepInfo(
  metadata: DepOptimizationMetadata,
  type: 'optimized' | 'discovered' | 'chunks',
  depInfo: OptimizedDepInfo,
): OptimizedDepInfo {
  metadata[type][depInfo.id] = depInfo
  metadata.depInfoList.push(depInfo)
  return depInfo
}

let firstLoadCachedDepOptimizationMetadata = true

/**
 * Creates the initial dep optimization metadata, loading it from the deps cache
 * if it exists and pre-bundling isn't forced
 */
export async function loadCachedDepOptimizationMetadata(
  environment: Environment,
  force = environment.config.optimizeDeps.force ?? false,
  asCommand = false,
): Promise<DepOptimizationMetadata | undefined> {
  const log = asCommand ? environment.logger.info : debug

  if (firstLoadCachedDepOptimizationMetadata) {
    firstLoadCachedDepOptimizationMetadata = false
    // Fire up a clean up of stale processing deps dirs if older process exited early
    setTimeout(
      () => cleanupDepsCacheStaleDirs(environment.getTopLevelConfig()),
      0,
    )
  }

  const depsCacheDir = getDepsCacheDir(environment)

  if (!force) {
    let cachedMetadata: DepOptimizationMetadata | undefined
    try {
      const cachedMetadataPath = path.join(depsCacheDir, METADATA_FILENAME)
      cachedMetadata = parseDepsOptimizerMetadata(
        await fsp.readFile(cachedMetadataPath, 'utf-8'),
        depsCacheDir,
      )
    } catch {}
    // hash is consistent, no need to re-bundle
    if (cachedMetadata) {
      if (cachedMetadata.lockfileHash !== getLockfileHash(environment)) {
        environment.logger.info(
          'Re-optimizing dependencies because lockfile has changed',
          {
            timestamp: true,
          },
        )
      } else if (cachedMetadata.configHash !== getConfigHash(environment)) {
        environment.logger.info(
          'Re-optimizing dependencies because vite config has changed',
          {
            timestamp: true,
          },
        )
      } else {
        log?.(
          `(${environment.name}) Hash is consistent. Skipping. Use --force to override.`,
        )
        // Nothing to commit or cancel as we are using the cache, we only
        // need to resolve the processing promise so requests can move on
        return cachedMetadata
      }
    }
  } else {
    environment.logger.info('Forced re-optimization of dependencies', {
      timestamp: true,
    })
  }

  // Start with a fresh cache
  debug?.(
    `(${environment.name}) ${colors.green(`removing old cache dir ${depsCacheDir}`)}`,
  )
  await fsp.rm(depsCacheDir, { recursive: true, force: true })
}

/**
 * Initial optimizeDeps at server start. Perform a fast scan using esbuild to
 * find deps to pre-bundle and include user hard-coded dependencies
 */
export function discoverProjectDependencies(environment: ScanEnvironment): {
  cancel: () => Promise<void>
  result: Promise<Record<string, string>>
} {
  const { cancel, result } = scanImports(environment)

  return {
    cancel,
    result: result.then(({ deps, missing }) => {
      const missingIds = Object.keys(missing)
      if (missingIds.length) {
        throw new Error(
          `The following dependencies are imported but could not be resolved:\n\n  ${missingIds
            .map(
              (id) =>
                `${colors.cyan(id)} ${colors.white(
                  colors.dim(`(imported by ${missing[id]})`),
                )}`,
            )
            .join(`\n  `)}\n\nAre they installed?`,
        )
      }

      return deps
    }),
  }
}

export function toDiscoveredDependencies(
  environment: Environment,
  deps: Record<string, string>,
  timestamp?: string,
): Record<string, OptimizedDepInfo> {
  const browserHash = getOptimizedBrowserHash(
    getDepHash(environment).hash,
    deps,
    timestamp,
  )
  const discovered: Record<string, OptimizedDepInfo> = {}
  for (const id in deps) {
    const src = deps[id]
    discovered[id] = {
      id,
      file: getOptimizedDepPath(environment, id),
      src,
      browserHash: browserHash,
      exportsData: extractExportsData(environment, src),
    }
  }
  return discovered
}

export function depsLogString(qualifiedIds: string[]): string {
  return colors.yellow(qualifiedIds.join(`, `))
}

/**
 * Internally, Vite uses this function to prepare a optimizeDeps run. When Vite starts, we can get
 * the metadata and start the server without waiting for the optimizeDeps processing to be completed
 */
export function runOptimizeDeps(
  environment: Environment,
  depsInfo: Record<string, OptimizedDepInfo>,
): {
  cancel: () => Promise<void>
  result: Promise<DepOptimizationResult>
} {
  const optimizerContext = { cancelled: false }

  const depsCacheDir = getDepsCacheDir(environment)
  const processingCacheDir = getProcessingDepsCacheDir(environment)

  // Create a temporary directory so we don't need to delete optimized deps
  // until they have been processed. This also avoids leaving the deps cache
  // directory in a corrupted state if there is an error
  fs.mkdirSync(processingCacheDir, { recursive: true })

  // a hint for Node.js
  // all files in the cache directory should be recognized as ES modules
  debug?.(colors.green(`creating package.json in ${processingCacheDir}`))
  fs.writeFileSync(
    path.resolve(processingCacheDir, 'package.json'),
    `{\n  "type": "module"\n}\n`,
  )

  const metadata = initDepsOptimizerMetadata(environment)

  metadata.browserHash = getOptimizedBrowserHash(
    metadata.hash,
    depsFromOptimizedDepInfo(depsInfo),
  )

  // We prebundle dependencies with esbuild and cache them, but there is no need
  // to wait here. Code that needs to access the cached deps needs to await
  // the optimizedDepInfo.processing promise for each dep

  const qualifiedIds = Object.keys(depsInfo)
  let cleaned = false
  let committed = false
  const cleanUp = () => {
    // If commit was already called, ignore the clean up even if a cancel was requested
    // This minimizes the chances of leaving the deps cache in a corrupted state
    if (!cleaned && !committed) {
      cleaned = true
      // No need to wait, we can clean up in the background because temp folders
      // are unique per run
      debug?.(colors.green(`removing cache dir ${processingCacheDir}`))
      try {
        // When exiting the process, `fsp.rm` may not take effect, so we use `fs.rmSync`
        fs.rmSync(processingCacheDir, { recursive: true, force: true })
      } catch {
        // Ignore errors
      }
    }
  }

  const successfulResult: DepOptimizationResult = {
    metadata,
    cancel: cleanUp,
    commit: async () => {
      if (cleaned) {
        throw new Error(
          'Can not commit a Deps Optimization run as it was cancelled',
        )
      }
      // Ignore clean up requests after this point so the temp folder isn't deleted before
      // we finish committing the new deps cache files to the deps folder
      committed = true

      // Write metadata file, then commit the processing folder to the global deps cache
      // Rewire the file paths from the temporary processing dir to the final deps cache dir
      const dataPath = path.join(processingCacheDir, METADATA_FILENAME)
      debug?.(
        colors.green(`creating ${METADATA_FILENAME} in ${processingCacheDir}`),
      )
      fs.writeFileSync(
        dataPath,
        stringifyDepsOptimizerMetadata(metadata, depsCacheDir),
      )

      // In order to minimize the time where the deps folder isn't in a consistent state,
      // we first rename the old depsCacheDir to a temporary path, then we rename the
      // new processing cache dir to the depsCacheDir. In systems where doing so in sync
      // is safe, we do an atomic operation (at least for this thread). For Windows, we
      // found there are cases where the rename operation may finish before it's done
      // so we do a graceful rename checking that the folder has been properly renamed.
      // We found that the rename-rename (then delete the old folder in the background)
      // is safer than a delete-rename operation.
      const temporaryPath = depsCacheDir + getTempSuffix()
      const depsCacheDirPresent = fs.existsSync(depsCacheDir)
      if (isWindows) {
        if (depsCacheDirPresent) {
          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
          await safeRename(depsCacheDir, temporaryPath)
        }
        debug?.(
          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
        )
        await safeRename(processingCacheDir, depsCacheDir)
      } else {
        if (depsCacheDirPresent) {
          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
          fs.renameSync(depsCacheDir, temporaryPath)
        }
        debug?.(
          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
        )
        fs.renameSync(processingCacheDir, depsCacheDir)
      }

      // Delete temporary path in the background
      if (depsCacheDirPresent) {
        debug?.(colors.green(`removing cache temp dir ${temporaryPath}`))
        fsp.rm(temporaryPath, { recursive: true, force: true })
      }
    },
  }

  if (!qualifiedIds.length) {
    // No deps to optimize, we still commit the processing cache dir to remove
    // the previous optimized deps if they exist, and let the next server start
    // skip the scanner step if the lockfile hasn't changed
    return {
      cancel: async () => cleanUp(),
      result: Promise.resolve(successfulResult),
    }
  }

  const cancelledResult: DepOptimizationResult = {
    metadata,
    commit: async () => cleanUp(),
    cancel: cleanUp,
  }

  const start = performance.now()

  const preparedRun = prepareEsbuildOptimizerRun(
    environment,
    depsInfo,
    processingCacheDir,
    optimizerContext,
  )

  const runResult = preparedRun.then(({ context, idToExports }) => {
    function disposeContext() {
      return context?.dispose().catch((e) => {
        environment.logger.error('Failed to dispose esbuild context', {
          error: e,
        })
      })
    }
    if (!context || optimizerContext.cancelled) {
      disposeContext()
      return cancelledResult
    }

    return context
      .rebuild()
      .then((result) => {
        const meta = result.metafile!

        // the paths in `meta.outputs` are relative to `process.cwd()`
        const processingCacheDirOutputPath = path.relative(
          process.cwd(),
          processingCacheDir,
        )

        for (const id in depsInfo) {
          const output = esbuildOutputFromId(
            meta.outputs,
            id,
            processingCacheDir,
          )

          const { exportsData, ...info } = depsInfo[id]
          addOptimizedDepInfo(metadata, 'optimized', {
            ...info,
            // We only need to hash the output.imports in to check for stability, but adding the hash
            // and file path gives us a unique hash that may be useful for other things in the future
            fileHash: getHash(
              metadata.hash +
                depsInfo[id].file +
                JSON.stringify(output.imports),
            ),
            browserHash: metadata.browserHash,
            // After bundling we have more information and can warn the user about legacy packages
            // that require manual configuration
            needsInterop: needsInterop(
              environment,
              id,
              idToExports[id],
              output,
            ),
          })
        }

        for (const o of Object.keys(meta.outputs)) {
          if (!jsMapExtensionRE.test(o)) {
            const id = path
              .relative(processingCacheDirOutputPath, o)
              .replace(jsExtensionRE, '')
            const file = getOptimizedDepPath(environment, id)
            if (
              !findOptimizedDepInfoInRecord(
                metadata.optimized,
                (depInfo) => depInfo.file === file,
              )
            ) {
              addOptimizedDepInfo(metadata, 'chunks', {
                id,
                file,
                needsInterop: false,
                browserHash: metadata.browserHash,
              })
            }
          } else {
            // workaround Firefox warning by removing blank source map reference
            // https://github.com/evanw/esbuild/issues/3945
            const output = meta.outputs[o]
            // filter by exact bytes of an empty source map
            if (output.bytes === 93) {
              const jsMapPath = path.resolve(o)
              const jsPath = jsMapPath.slice(0, -4)
              if (fs.existsSync(jsPath) && fs.existsSync(jsMapPath)) {
                const map = JSON.parse(fs.readFileSync(jsMapPath, 'utf-8'))
                if (map.sources.length === 0) {
                  const js = fs.readFileSync(jsPath, 'utf-8')
                  fs.writeFileSync(
                    jsPath,
                    js.slice(0, js.lastIndexOf('//# sourceMappingURL=')),
                  )
                }
              }
            }
          }
        }

        debug?.(
          `Dependencies bundled in ${(performance.now() - start).toFixed(2)}ms`,
        )

        return successfulResult
      })

      .catch(async (e) => {
        if (e.errors && e.message.includes('The build was canceled')) {
          // esbuild logs an error when cancelling, but this is expected so
          // return an empty result instead
          return cancelledResult
        }
        const prependMessage = colors.red(
          'Error during dependency optimization:\n\n',
        )
        if (e.errors) {
          const msgs = await formatMessages(e.errors, {
            kind: 'error',
            color: true,
          })
          e.message = prependMessage + msgs.join('\n')
        } else {
          e.message = prependMessage + e.message
        }
        throw e
      })
      .finally(() => {
        return disposeContext()
      })
  })

  runResult.catch(() => {
    cleanUp()
  })

  return {
    async cancel() {
      optimizerContext.cancelled = true
      const { context } = await preparedRun
      await context?.cancel()
      cleanUp()
    },
    result: runResult,
  }
}

async function prepareEsbuildOptimizerRun(
  environment: Environment,
  depsInfo: Record<string, OptimizedDepInfo>,
  processingCacheDir: string,
  optimizerContext: { cancelled: boolean },
): Promise<{
  context?: BuildContext
  idToExports: Record<string, ExportsData>
}> {
  // esbuild generates nested directory output with lowest common ancestor base
  // this is unpredictable and makes it difficult to analyze entry / output
  // mapping. So what we do here is:
  // 1. flatten all ids to eliminate slash
  // 2. in the plugin, read the entry ourselves as virtual files to retain the
  //    path.
  const flatIdDeps: Record<string, string> = {}
  const idToExports: Record<string, ExportsData> = {}

  const { optimizeDeps } = environment.config

  const { plugins: pluginsFromConfig = [], ...esbuildOptions } =
    optimizeDeps.esbuildOptions ?? {}

  await Promise.all(
    Object.keys(depsInfo).map(async (id) => {
      const src = depsInfo[id].src!
      const exportsData = await (depsInfo[id].exportsData ??
        extractExportsData(environment, src))
      if (exportsData.jsxLoader && !esbuildOptions.loader?.['.js']) {
        // Ensure that optimization won't fail by defaulting '.js' to the JSX parser.
        // This is useful for packages such as Gatsby.
        esbuildOptions.loader = {
          '.js': 'jsx',
          ...esbuildOptions.loader,
        }
      }
      const flatId = flattenId(id)
      flatIdDeps[flatId] = src
      idToExports[id] = exportsData
    }),
  )

  if (optimizerContext.cancelled) return { context: undefined, idToExports }

  const define = {
    'process.env.NODE_ENV': environment.config.keepProcessEnv
      ? // define process.env.NODE_ENV even for keepProcessEnv === true
        // as esbuild will replace it automatically when `platform` is `'browser'`
        'process.env.NODE_ENV'
      : JSON.stringify(process.env.NODE_ENV || environment.config.mode),
  }

  const platform =
    optimizeDeps.esbuildOptions?.platform ??
    // We generally don't want to use platform 'neutral', as esbuild has custom handling
    // when the platform is 'node' or 'browser' that can't be emulated by using mainFields
    // and conditions
    (environment.config.consumer === 'client' ||
    environment.config.ssr.target === 'webworker'
      ? 'browser'
      : 'node')

  const external = [...(optimizeDeps.exclude ?? [])]

  const plugins = [...pluginsFromConfig]
  if (external.length) {
    plugins.push(esbuildCjsExternalPlugin(external, platform))
  }
  plugins.push(esbuildDepPlugin(environment, flatIdDeps, external))

  const context = await esbuild.context({
    absWorkingDir: process.cwd(),
    entryPoints: Object.keys(flatIdDeps),
    bundle: true,
    platform,
    define,
    format: 'esm',
    // See https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694
    banner:
      platform === 'node'
        ? {
            js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`,
          }
        : undefined,
    target: ESBUILD_BASELINE_WIDELY_AVAILABLE_TARGET,
    external,
    logLevel: 'error',
    splitting: true,
    sourcemap: true,
    outdir: processingCacheDir,
    ignoreAnnotations: true,
    metafile: true,
    plugins,
    charset: 'utf8',
    ...esbuildOptions,
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildOptions.supported,
    },
  })
  return { context, idToExports }
}

export async function addManuallyIncludedOptimizeDeps(
  environment: Environment,
  deps: Record<string, string>,
): Promise<void> {
  const { logger } = environment
  const { optimizeDeps } = environment.config
  const optimizeDepsInclude = optimizeDeps.include ?? []
  if (optimizeDepsInclude.length) {
    const unableToOptimize = (id: string, msg: string) => {
      if (optimizeDepsInclude.includes(id)) {
        logger.warn(
          `${msg}: ${colors.cyan(id)}, present in ${environment.name} 'optimizeDeps.include'`,
        )
      }
    }

    const includes = [...optimizeDepsInclude]
    for (let i = 0; i < includes.length; i++) {
      const id = includes[i]
      if (isDynamicPattern(id)) {
        const globIds = expandGlobIds(id, environment.getTopLevelConfig())
        includes.splice(i, 1, ...globIds)
        i += globIds.length - 1
      }
    }

    const resolve = createOptimizeDepsIncludeResolver(environment)
    for (const id of includes) {
      // normalize 'foo   >bar` as 'foo > bar' to prevent same id being added
      // and for pretty printing
      const normalizedId = normalizeId(id)
      if (!deps[normalizedId]) {
        const entry = await resolve(id)
        if (entry) {
          if (isOptimizable(entry, optimizeDeps)) {
            deps[normalizedId] = entry
          } else {
            unableToOptimize(id, 'Cannot optimize dependency')
          }
        } else {
          unableToOptimize(id, 'Failed to resolve dependency')
        }
      }
    }
  }
}

// Convert to { id: src }
export function depsFromOptimizedDepInfo(
  depsInfo: Record<string, OptimizedDepInfo>,
): Record<string, string> {
  const obj: Record<string, string> = {}
  for (const key in depsInfo) {
    obj[key] = depsInfo[key].src!
  }
  return obj
}

export function getOptimizedDepPath(
  environment: Environment,
  id: string,
): string {
  return normalizePath(
    path.resolve(getDepsCacheDir(environment), flattenId(id) + '.js'),
  )
}

function getDepsCacheSuffix(environment: Environment): string {
  return environment.name === 'client' ? '' : `_${environment.name}`
}

export function getDepsCacheDir(environment: Environment): string {
  return getDepsCacheDirPrefix(environment) + getDepsCacheSuffix(environment)
}

function getProcessingDepsCacheDir(environment: Environment) {
  return (
    getDepsCacheDirPrefix(environment) +
    getDepsCacheSuffix(environment) +
    getTempSuffix()
  )
}

function getTempSuffix() {
  return (
    '_temp_' +
    getHash(
      `${process.pid}:${Date.now().toString()}:${Math.random()
        .toString(16)
        .slice(2)}`,
    )
  )
}

function getDepsCacheDirPrefix(environment: Environment): string {
  return normalizePath(path.resolve(environment.config.cacheDir, 'deps'))
}

export function createIsOptimizedDepFile(
  environment: Environment,
): (id: string) => boolean {
  const depsCacheDirPrefix = getDepsCacheDirPrefix(environment)
  return (id) => id.startsWith(depsCacheDirPrefix)
}

export function createIsOptimizedDepUrl(
  environment: Environment,
): (url: string) => boolean {
  const { root } = environment.config
  const depsCacheDir = getDepsCacheDirPrefix(environment)

  // determine the url prefix of files inside cache directory
  const depsCacheDirRelative = normalizePath(path.relative(root, depsCacheDir))
  const depsCacheDirPrefix = depsCacheDirRelative.startsWith('../')
    ? // if the cache directory is outside root, the url prefix would be something
      // like '/@fs/absolute/path/to/node_modules/.vite'
      `/@fs/${removeLeadingSlash(normalizePath(depsCacheDir))}`
    : // if the cache directory is inside root, the url prefix would be something
      // like '/node_modules/.vite'
      `/${depsCacheDirRelative}`

  return function isOptimizedDepUrl(url: string): boolean {
    return url.startsWith(depsCacheDirPrefix)
  }
}

function parseDepsOptimizerMetadata(
  jsonMetadata: string,
  depsCacheDir: string,
): DepOptimizationMetadata | undefined {
  const { hash, lockfileHash, configHash, browserHash, optimized, chunks } =
    JSON.parse(jsonMetadata, (key: string, value: string) => {
      // Paths can be absolute or relative to the deps cache dir where
      // the _metadata.json is located
      if (key === 'file' || key === 'src') {
        return normalizePath(path.resolve(depsCacheDir, value))
      }
      return value
    })
  if (
    !chunks ||
    Object.values(optimized).some((depInfo: any) => !depInfo.fileHash)
  ) {
    // outdated _metadata.json version, ignore
    return
  }
  const metadata = {
    hash,
    lockfileHash,
    configHash,
    browserHash,
    optimized: {},
    discovered: {},
    chunks: {},
    depInfoList: [],
  }
  for (const id of Object.keys(optimized)) {
    addOptimizedDepInfo(metadata, 'optimized', {
      ...optimized[id],
      id,
      browserHash,
    })
  }
  for (const id of Object.keys(chunks)) {
    addOptimizedDepInfo(metadata, 'chunks', {
      ...chunks[id],
      id,
      browserHash,
      needsInterop: false,
    })
  }
  return metadata
}

/**
 * Stringify metadata for deps cache. Remove processing promises
 * and individual dep info browserHash. Once the cache is reload
 * the next time the server start we need to use the global
 * browserHash to allow long term caching
 */
function stringifyDepsOptimizerMetadata(
  metadata: DepOptimizationMetadata,
  depsCacheDir: string,
) {
  const { hash, configHash, lockfileHash, browserHash, optimized, chunks } =
    metadata
  return JSON.stringify(
    {
      hash,
      configHash,
      lockfileHash,
      browserHash,
      optimized: Object.fromEntries(
        Object.values(optimized).map(
          ({ id, src, file, fileHash, needsInterop }) => [
            id,
            {
              src,
              file,
              fileHash,
              needsInterop,
            },
          ],
        ),
      ),
      chunks: Object.fromEntries(
        Object.values(chunks).map(({ id, file }) => [id, { file }]),
      ),
    },
    (key: string, value: string) => {
      // Paths can be absolute or relative to the deps cache dir where
      // the _metadata.json is located
      if (key === 'file' || key === 'src') {
        return normalizePath(path.relative(depsCacheDir, value))
      }
      return value
    },
    2,
  )
}

function esbuildOutputFromId(
  outputs: Record<string, any>,
  id: string,
  cacheDirOutputPath: string,
): any {
  const cwd = process.cwd()
  const flatId = flattenId(id) + '.js'
  const normalizedOutputPath = normalizePath(
    path.relative(cwd, path.join(cacheDirOutputPath, flatId)),
  )
  const output = outputs[normalizedOutputPath]
  if (output) {
    return output
  }
  // If the root dir was symlinked, esbuild could return output keys as `../cwd/`
  // Normalize keys to support this case too
  for (const [key, value] of Object.entries(outputs)) {
    if (normalizePath(path.relative(cwd, key)) === normalizedOutputPath) {
      return value
    }
  }
}

export async function extractExportsData(
  environment: Environment,
  filePath: string,
): Promise<ExportsData> {
  await init

  const { optimizeDeps } = environment.config

  const esbuildOptions = optimizeDeps.esbuildOptions ?? {}
  if (optimizeDeps.extensions?.some((ext) => filePath.endsWith(ext))) {
    // For custom supported extensions, build the entry file to transform it into JS,
    // and then parse with es-module-lexer. Note that the `bundle` option is not `true`,
    // so only the entry file is being transformed.
    const result = await build({
      ...esbuildOptions,
      entryPoints: [filePath],
      write: false,
      format: 'esm',
    })
    const [, exports, , hasModuleSyntax] = parse(result.outputFiles[0].text)
    return {
      hasModuleSyntax,
      exports: exports.map((e) => e.n),
    }
  }

  let parseResult: ReturnType<typeof parse>
  let usedJsxLoader = false

  const entryContent = await fsp.readFile(filePath, 'utf-8')
  try {
    parseResult = parse(entryContent)
  } catch {
    const loader = esbuildOptions.loader?.[path.extname(filePath)] || 'jsx'
    debug?.(
      `Unable to parse: ${filePath}.\n Trying again with a ${loader} transform.`,
    )
    const transformed = await transformWithEsbuild(
      entryContent,
      filePath,
      { loader },
      undefined,
      environment.config,
    )
    parseResult = parse(transformed.code)
    usedJsxLoader = true
  }

  const [, exports, , hasModuleSyntax] = parseResult
  const exportsData: ExportsData = {
    hasModuleSyntax,
    exports: exports.map((e) => e.n),
    jsxLoader: usedJsxLoader,
  }
  return exportsData
}

function needsInterop(
  environment: Environment,
  id: string,
  exportsData: ExportsData,
  output?: { exports: string[] },
): boolean {
  if (environment.config.optimizeDeps.needsInterop?.includes(id)) {
    return true
  }
  const { hasModuleSyntax, exports } = exportsData
  // entry has no ESM syntax - likely CJS or UMD
  if (!hasModuleSyntax) {
    return true
  }

  if (output) {
    // if a peer dependency used require() on an ESM dependency, esbuild turns the
    // ESM dependency's entry chunk into a single default export... detect
    // such cases by checking exports mismatch, and force interop.
    const generatedExports: string[] = output.exports

    if (
      isSingleDefaultExport(generatedExports) &&
      !isSingleDefaultExport(exports)
    ) {
      return true
    }
  }
  return false
}

function isSingleDefaultExport(exports: readonly string[]) {
  return exports.length === 1 && exports[0] === 'default'
}

const lockfileFormats = [
  {
    path: 'node_modules/.package-lock.json',
    checkPatchesDir: 'patches',
    manager: 'npm',
  },
  {
    // Yarn non-PnP
    path: 'node_modules/.yarn-state.yml',
    checkPatchesDir: false,
    manager: 'yarn',
  },
  {
    // Yarn v3+ PnP
    path: '.pnp.cjs',
    checkPatchesDir: '.yarn/patches',
    manager: 'yarn',
  },
  {
    // Yarn v2 PnP
    path: '.pnp.js',
    checkPatchesDir: '.yarn/patches',
    manager: 'yarn',
  },
  {
    // yarn 1
    path: 'node_modules/.yarn-integrity',
    checkPatchesDir: 'patches',
    manager: 'yarn',
  },
  {
    path: 'node_modules/.pnpm/lock.yaml',
    // Included in lockfile
    checkPatchesDir: false,
    manager: 'pnpm',
  },
  {
    path: 'bun.lock',
    checkPatchesDir: 'patches',
    manager: 'bun',
  },
  {
    path: 'bun.lockb',
    checkPatchesDir: 'patches',
    manager: 'bun',
  },
].sort((_, { manager }) => {
  return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1
})
const lockfilePaths = lockfileFormats.map((l) => l.path)

function getConfigHash(environment: Environment): string {
  // Take config into account
  // only a subset of config options that can affect dep optimization
  const { config } = environment
  const { optimizeDeps } = config
  const content = JSON.stringify(
    {
      define: !config.keepProcessEnv
        ? process.env.NODE_ENV || config.mode
        : null,
      root: config.root,
      resolve: config.resolve,
      assetsInclude: config.assetsInclude,
      plugins: config.plugins.map((p) => p.name),
      optimizeDeps: {
        include: optimizeDeps.include
          ? unique(optimizeDeps.include).sort()
          : undefined,
        exclude: optimizeDeps.exclude
          ? unique(optimizeDeps.exclude).sort()
          : undefined,
        esbuildOptions: {
          ...optimizeDeps.esbuildOptions,
          plugins: optimizeDeps.esbuildOptions?.plugins?.map((p) => p.name),
        },
      },
    },
    (_, value) => {
      if (typeof value === 'function' || value instanceof RegExp) {
        return value.toString()
      }
      return value
    },
  )
  return getHash(content)
}

function getLockfileHash(environment: Environment): string {
  const lockfilePath = lookupFile(environment.config.root, lockfilePaths)
  let content = lockfilePath ? fs.readFileSync(lockfilePath, 'utf-8') : ''
  if (lockfilePath) {
    const normalizedLockfilePath = lockfilePath.replaceAll('\\', '/')
    const lockfileFormat = lockfileFormats.find((f) =>
      normalizedLockfilePath.endsWith(f.path),
    )!
    if (lockfileFormat.checkPatchesDir) {
      // Default of https://github.com/ds300/patch-package
      const baseDir = lockfilePath.slice(0, -lockfileFormat.path.length)
      const fullPath = path.join(
        baseDir,
        lockfileFormat.checkPatchesDir as string,
      )
      const stat = tryStatSync(fullPath)
      if (stat?.isDirectory()) {
        content += stat.mtimeMs.toString()
      }
    }
  }
  return getHash(content)
}

function getDepHash(environment: Environment): {
  lockfileHash: string
  configHash: string
  hash: string
} {
  const lockfileHash = getLockfileHash(environment)
  const configHash = getConfigHash(environment)
  const hash = getHash(lockfileHash + configHash)
  return {
    hash,
    lockfileHash,
    configHash,
  }
}

function getOptimizedBrowserHash(
  hash: string,
  deps: Record<string, string>,
  timestamp = '',
) {
  return getHash(hash + JSON.stringify(deps) + timestamp)
}

export function optimizedDepInfoFromId(
  metadata: DepOptimizationMetadata,
  id: string,
): OptimizedDepInfo | undefined {
  return (
    metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id]
  )
}

export function optimizedDepInfoFromFile(
  metadata: DepOptimizationMetadata,
  file: string,
): OptimizedDepInfo | undefined {
  return metadata.depInfoList.find((depInfo) => depInfo.file === file)
}

function findOptimizedDepInfoInRecord(
  dependenciesInfo: Record<string, OptimizedDepInfo>,
  callbackFn: (depInfo: OptimizedDepInfo, id: string) => any,
): OptimizedDepInfo | undefined {
  for (const o of Object.keys(dependenciesInfo)) {
    const info = dependenciesInfo[o]
    if (callbackFn(info, o)) {
      return info
    }
  }
}

export async function optimizedDepNeedsInterop(
  environment: Environment,
  metadata: DepOptimizationMetadata,
  file: string,
): Promise<boolean | undefined> {
  const depInfo = optimizedDepInfoFromFile(metadata, file)
  if (depInfo?.src && depInfo.needsInterop === undefined) {
    depInfo.exportsData ??= extractExportsData(environment, depInfo.src)
    depInfo.needsInterop = needsInterop(
      environment,
      depInfo.id,
      await depInfo.exportsData,
    )
  }
  return depInfo?.needsInterop
}

const MAX_TEMP_DIR_AGE_MS = 24 * 60 * 60 * 1000
export async function cleanupDepsCacheStaleDirs(
  config: ResolvedConfig,
): Promise<void> {
  try {
    const cacheDir = path.resolve(config.cacheDir)
    if (fs.existsSync(cacheDir)) {
      const dirents = await fsp.readdir(cacheDir, { withFileTypes: true })
      for (const dirent of dirents) {
        if (dirent.isDirectory() && dirent.name.includes('_temp_')) {
          const tempDirPath = path.resolve(config.cacheDir, dirent.name)
          const stats = await fsp.stat(tempDirPath).catch(() => null)
          if (
            stats?.mtime &&
            Date.now() - stats.mtime.getTime() > MAX_TEMP_DIR_AGE_MS
          ) {
            debug?.(`removing stale cache temp dir ${tempDirPath}`)
            await fsp.rm(tempDirPath, { recursive: true, force: true })
          }
        }
      }
    }
  } catch (err) {
    config.logger.error(err)
  }
}

// We found issues with renaming folders in some systems. This is a custom
// implementation for the optimizer. It isn't intended to be a general utility

// Based on node-graceful-fs

// The ISC License
// Copyright (c) 2011-2022 Isaac Z. Schlueter, Ben Noordhuis, and Contributors
// https://github.com/isaacs/node-graceful-fs/blob/main/LICENSE

// On Windows, A/V software can lock the directory, causing this
// to fail with an EACCES or EPERM if the directory contains newly
// created files. The original tried for up to 60 seconds, we only
// wait for 5 seconds, as a longer time would be seen as an error

const GRACEFUL_RENAME_TIMEOUT = 5000
const safeRename = promisify(function gracefulRename(
  from: string,
  to: string,
  cb: (error: NodeJS.ErrnoException | null) => void,
) {
  const start = Date.now()
  let backoff = 0
  fs.rename(from, to, function CB(er) {
    if (
      er &&
      (er.code === 'EACCES' || er.code === 'EPERM') &&
      Date.now() - start < GRACEFUL_RENAME_TIMEOUT
    ) {
      setTimeout(function () {
        fs.stat(to, function (stater, _st) {
          if (stater && stater.code === 'ENOENT') fs.rename(from, to, CB)
          else CB(er)
        })
      }, backoff)
      if (backoff < 100) backoff += 10
      return
    }
    cb(er)
  })
})



================================================
FILE: packages/vite/src/node/optimizer/optimizer.ts
================================================
import colors from 'picocolors'
import { createDebugger, getHash } from '../utils'
import {
  type PromiseWithResolvers,
  promiseWithResolvers,
} from '../../shared/utils'
import type { DevEnvironment } from '../server/environment'
import { devToScanEnvironment } from './scan'
import {
  addManuallyIncludedOptimizeDeps,
  addOptimizedDepInfo,
  createIsOptimizedDepFile,
  createIsOptimizedDepUrl,
  depsFromOptimizedDepInfo,
  depsLogString,
  discoverProjectDependencies,
  extractExportsData,
  getOptimizedDepPath,
  initDepsOptimizerMetadata,
  loadCachedDepOptimizationMetadata,
  optimizeExplicitEnvironmentDeps,
  runOptimizeDeps,
  toDiscoveredDependencies,
} from './index'
import type {
  DepOptimizationMetadata,
  DepOptimizationResult,
  DepsOptimizer,
  OptimizedDepInfo,
} from './index'

const debug = createDebugger('vite:deps')

/**
 * The amount to wait for requests to register newly found dependencies before triggering
 * a re-bundle + page reload
 */
const debounceMs = 100

export function createDepsOptimizer(
  environment: DevEnvironment,
): DepsOptimizer {
  const { logger } = environment
  const sessionTimestamp = Date.now().toString()

  let debounceProcessingHandle: NodeJS.Timeout | undefined

  let closed = false

  const options = environment.config.optimizeDeps

  const { noDiscovery, holdUntilCrawlEnd } = options

  let metadata: DepOptimizationMetadata = initDepsOptimizerMetadata(
    environment,
    sessionTimestamp,
  )

  const depsOptimizer: DepsOptimizer = {
    init,
    metadata,
    registerMissingImport,
    run: () => debouncedProcessing(0),
    isOptimizedDepFile: createIsOptimizedDepFile(environment),
    isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
    getOptimizedDepId: (depInfo: OptimizedDepInfo) =>
      `${depInfo.file}?v=${depInfo.browserHash}`,
    close,
    options,
  }

  let newDepsDiscovered = false

  let newDepsToLog: string[] = []
  let newDepsToLogHandle: NodeJS.Timeout | undefined
  const logNewlyDiscoveredDeps = () => {
    if (newDepsToLog.length) {
      logger.info(
        colors.green(
          `✨ new dependencies optimized: ${depsLogString(newDepsToLog)}`,
        ),
        {
          timestamp: true,
        },
      )
      newDepsToLog = []
    }
  }

  let discoveredDepsWhileScanning: string[] = []
  const logDiscoveredDepsWhileScanning = () => {
    if (discoveredDepsWhileScanning.length) {
      logger.info(
        colors.green(
          `✨ discovered while scanning: ${depsLogString(
            discoveredDepsWhileScanning,
          )}`,
        ),
        {
          timestamp: true,
        },
      )
      discoveredDepsWhileScanning = []
    }
  }

  let depOptimizationProcessing = promiseWithResolvers<void>()
  let depOptimizationProcessingQueue: PromiseWithResolvers<void>[] = []
  const resolveEnqueuedProcessingPromises = () => {
    // Resolve all the processings (including the ones which were delayed)
    for (const processing of depOptimizationProcessingQueue) {
      processing.resolve()
    }
    depOptimizationProcessingQueue = []
  }

  let enqueuedRerun: (() => void) | undefined
  let currentlyProcessing = false

  let firstRunCalled = false
  let warnAboutMissedDependencies = false

  // If this is a cold run, we wait for static imports discovered
  // from the first request before resolving to minimize full page reloads.
  // On warm start or after the first optimization is run, we use a simpler
  // debounce strategy each time a new dep is discovered.
  let waitingForCrawlEnd = false

  let optimizationResult:
    | {
        cancel: () => Promise<void>
        result: Promise<DepOptimizationResult>
      }
    | undefined

  let discover:
    | {
        cancel: () => Promise<void>
        result: Promise<Record<string, string>>
      }
    | undefined

  async function close() {
    closed = true
    await Promise.allSettled([
      discover?.cancel(),
      depsOptimizer.scanProcessing,
      optimizationResult?.cancel(),
    ])
  }

  let inited = false
  async function init() {
    if (inited) return
    inited = true

    const cachedMetadata = await loadCachedDepOptimizationMetadata(environment)

    firstRunCalled = !!cachedMetadata

    metadata = depsOptimizer.metadata =
      cachedMetadata || initDepsOptimizerMetadata(environment, sessionTimestamp)

    if (!cachedMetadata) {
      waitingForCrawlEnd = true

      // Enter processing state until crawl of static imports ends
      currentlyProcessing = true

      // Initialize discovered deps with manually added optimizeDeps.include info

      const manuallyIncludedDeps: Record<string, string> = {}
      await addManuallyIncludedOptimizeDeps(environment, manuallyIncludedDeps)

      const manuallyIncludedDepsInfo = toDiscoveredDependencies(
        environment,
        manuallyIncludedDeps,
        sessionTimestamp,
      )

      for (const depInfo of Object.values(manuallyIncludedDepsInfo)) {
        addOptimizedDepInfo(metadata, 'discovered', {
          ...depInfo,
          processing: depOptimizationProcessing.promise,
        })
        newDepsDiscovered = true
      }

      environment.waitForRequestsIdle().then(onCrawlEnd)

      if (noDiscovery) {
        // We don't need to scan for dependencies or wait for the static crawl to end
        // Run the first optimization run immediately
        runOptimizer()
      } else {
        // Important, the scanner is dev only
        depsOptimizer.scanProcessing = new Promise((resolve) => {
          // Runs in the background in case blocking high priority tasks
          ;(async () => {
            try {
              debug?.(colors.green(`scanning for dependencies...`))

              let deps: Record<string, string>
              try {
                discover = discoverProjectDependencies(
                  devToScanEnvironment(environment),
                )
                deps = await discover.result
                discover = undefined
              } catch (e) {
                environment.logger.error(
                  colors.red(
                    '(!) Failed to run dependency scan. ' +
                      'Skipping dependency pre-bundling. ' +
                      e.stack,
                  ),
                )
                return
              }

              const manuallyIncluded = Object.keys(manuallyIncludedDepsInfo)
              discoveredDepsWhileScanning.push(
                ...Object.keys(metadata.discovered).filter(
                  (dep) => !deps[dep] && !manuallyIncluded.includes(dep),
                ),
              )

              // Add these dependencies to the discovered list, as these are currently
              // used by the preAliasPlugin to support aliased and optimized deps.
              // This is also used by the CJS externalization heuristics in legacy mode
              for (const id of Object.keys(deps)) {
                if (!metadata.discovered[id]) {
                  addMissingDep(id, deps[id])
                }
              }

              const knownDeps = prepareKnownDeps()
              startNextDiscoveredBatch()

              // For dev, we run the scanner and the first optimization
              // run on the background
              optimizationResult = runOptimizeDeps(environment, knownDeps)

              // If the holdUntilCrawlEnd strategy is used, we wait until crawling has
              // ended to decide if we send this result to the browser or we need to
              // do another optimize step
              if (!holdUntilCrawlEnd) {
                // If not, we release the result to the browser as soon as the scanner
                // is done. If the scanner missed any dependency, and a new dependency
                // is discovered while crawling static imports, then there will be a
                // full-page reload if new common chunks are generated between the old
                // and new optimized deps.
                optimizationResult.result.then((result) => {
                  // Check if the crawling of static imports has already finished. In that
                  // case, the result is handled by the onCrawlEnd callback
                  if (!waitingForCrawlEnd) return

                  optimizationResult = undefined // signal that we'll be using the result

                  runOptimizer(result)
                })
              }
            } catch (e) {
              logger.error(e.stack || e.message)
            } finally {
              resolve()
              depsOptimizer.scanProcessing = undefined
            }
          })()
        })
      }
    }
  }

  function startNextDiscoveredBatch() {
    newDepsDiscovered = false

    // Add the current depOptimizationProcessing to the queue, these
    // promises are going to be resolved once a rerun is committed
    depOptimizationProcessingQueue.push(depOptimizationProcessing)

    // Create a new promise for the next rerun, discovered missing
    // dependencies will be assigned this promise from this point
    depOptimizationProcessing = promiseWithResolvers()
  }

  function prepareKnownDeps() {
    const knownDeps: Record<string, OptimizedDepInfo> = {}
    // Clone optimized info objects, fileHash, browserHash may be changed for them
    const metadata = depsOptimizer.metadata!
    for (const dep of Object.keys(metadata.optimized)) {
      knownDeps[dep] = { ...metadata.optimized[dep] }
    }
    for (const dep of Object.keys(metadata.discovered)) {
      // Clone the discovered info discarding its processing promise
      const { processing, ...info } = metadata.discovered[dep]
      knownDeps[dep] = info
    }
    return knownDeps
  }

  async function runOptimizer(preRunResult?: DepOptimizationResult) {
    // a successful completion of the optimizeDeps rerun will end up
    // creating new bundled version of all current and discovered deps
    // in the cache dir and a new metadata info object assigned
    // to _metadata. A fullReload is only issued if the previous bundled
    // dependencies have changed.

    // if the rerun fails, _metadata remains untouched, current discovered
    // deps are cleaned, and a fullReload is issued

    // All deps, previous known and newly discovered are rebundled,
    // respect insertion order to keep the metadata file stable

    const isRerun = firstRunCalled
    firstRunCalled = true

    // Ensure that rerun is called sequentially
    enqueuedRerun = undefined

    // Ensure that a rerun will not be issued for current discovered deps
    if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle)

    if (closed) {
      currentlyProcessing = false
      depOptimizationProcessing.resolve()
      resolveEnqueuedProcessingPromises()
      return
    }

    currentlyProcessing = true

    try {
      let processingResult: DepOptimizationResult
      if (preRunResult) {
        processingResult = preRunResult
      } else {
        const knownDeps = prepareKnownDeps()
        startNextDiscoveredBatch()

        optimizationResult = runOptimizeDeps(environment, knownDeps)
        processingResult = await optimizationResult.result
        optimizationResult = undefined
      }

      if (closed) {
        currentlyProcessing = false
        processingResult.cancel()
        resolveEnqueuedProcessingPromises()
        return
      }

      const newData = processingResult.metadata

      const needsInteropMismatch = findInteropMismatches(
        metadata.discovered,
        newData.optimized,
      )

      // After a re-optimization, if the internal bundled chunks change a full page reload
      // is required. If the files are stable, we can avoid the reload that is expensive
      // for large applications. Comparing their fileHash we can find out if it is safe to
      // keep the current browser state.
      const needsReload =
        needsInteropMismatch.length > 0 ||
        metadata.hash !== newData.hash ||
        Object.keys(metadata.optimized).some((dep) => {
          return (
            metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash
          )
        })

      const commitProcessing = async () => {
        await processingResult.commit()

        // While optimizeDeps is running, new missing deps may be discovered,
        // in which case they will keep being added to metadata.discovered
        for (const id in metadata.discovered) {
          if (!newData.optimized[id]) {
            addOptimizedDepInfo(newData, 'discovered', metadata.discovered[id])
          }
        }

        // If we don't reload the page, we need to keep browserHash stable
        if (!needsReload) {
          newData.browserHash = metadata.browserHash
          for (const dep in newData.chunks) {
            newData.chunks[dep].browserHash = metadata.browserHash
          }
          for (const dep in newData.optimized) {
            newData.optimized[dep].browserHash = (
              metadata.optimized[dep] || metadata.discovered[dep]
            ).browserHash
          }
        }

        // Commit hash and needsInterop changes to the discovered deps info
        // object. Allow for code to await for the discovered processing promise
        // and use the information in the same object
        for (const o in newData.optimized) {
          const discovered = metadata.discovered[o]
          if (discovered) {
            const optimized = newData.optimized[o]
            discovered.browserHash = optimized.browserHash
            discovered.fileHash = optimized.fileHash
            discovered.needsInterop = optimized.needsInterop
            discovered.processing = undefined
          }
        }

        if (isRerun) {
          newDepsToLog.push(
            ...Object.keys(newData.optimized).filter(
              (dep) => !metadata.optimized[dep],
            ),
          )
        }

        metadata = depsOptimizer.metadata = newData
        resolveEnqueuedProcessingPromises()
      }

      if (!needsReload) {
        await commitProcessing()

        if (!debug) {
          if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle)
          newDepsToLogHandle = setTimeout(() => {
            newDepsToLogHandle = undefined
            logNewlyDiscoveredDeps()
            if (warnAboutMissedDependencies) {
              logDiscoveredDepsWhileScanning()
              logger.info(
                colors.magenta(
                  `❗ add these dependencies to optimizeDeps.include to speed up cold start`,
                ),
                { timestamp: true },
              )
              warnAboutMissedDependencies = false
            }
          }, 2 * debounceMs)
        } else {
          debug(
            colors.green(
              `✨ ${
                !isRerun
                  ? `dependencies optimized`
                  : `optimized dependencies unchanged`
              }`,
            ),
          )
        }
      } else {
        if (newDepsDiscovered) {
          // There are newly discovered deps, and another rerun is about to be
          // executed. Avoid the current full reload discarding this rerun result
          // We don't resolve the processing promise, as they will be resolved
          // once a rerun is committed
          processingResult.cancel()

          debug?.(
            colors.green(
              `✨ delaying reload as new dependencies have been found...`,
            ),
          )
        } else {
          await commitProcessing()

          if (!debug) {
            if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle)
            newDepsToLogHandle = undefined
            logNewlyDiscoveredDeps()
            if (warnAboutMissedDependencies) {
              logDiscoveredDepsWhileScanning()
              logger.info(
                colors.magenta(
                  `❗ add these dependencies to optimizeDeps.include to avoid a full page reload during cold start`,
                ),
                { timestamp: true },
              )
              warnAboutMissedDependencies = false
            }
          }

          logger.info(
            colors.green(`✨ optimized dependencies changed. reloading`),
            {
              timestamp: true,
            },
          )
          if (needsInteropMismatch.length > 0) {
            logger.warn(
              `Mixed ESM and CJS detected in ${colors.yellow(
                needsInteropMismatch.join(', '),
              )}, add ${
                needsInteropMismatch.length === 1 ? 'it' : 'them'
              } to optimizeDeps.needsInterop to speed up cold start`,
              {
                timestamp: true,
              },
            )
          }

          fullReload()
        }
      }
    } catch (e) {
      logger.error(
        colors.red(`error while updating dependencies:\n${e.stack}`),
        { timestamp: true, error: e },
      )
      resolveEnqueuedProcessingPromises()

      // Reset missing deps, let the server rediscover the dependencies
      metadata.discovered = {}
    }

    currentlyProcessing = false
    // @ts-expect-error `enqueuedRerun` could exist because `debouncedProcessing` may run while awaited
    enqueuedRerun?.()
  }

  function fullReload() {
    // Cached transform results have stale imports (resolved to
    // old locations) so they need to be invalidated before the page is
    // reloaded.
    environment.moduleGraph.invalidateAll()

    environment.hot.send({
      type: 'full-reload',
      path: '*',
    })
  }

  async function rerun() {
    // debounce time to wait for new missing deps finished, issue a new
    // optimization of deps (both old and newly found) once the previous
    // optimizeDeps processing is finished
    const deps = Object.keys(metadata.discovered)
    const depsString = depsLogString(deps)
    debug?.(colors.green(`new dependencies found: ${depsString}`))
    runOptimizer()
  }

  function getDiscoveredBrowserHash(
    hash: string,
    deps: Record<string, string>,
    missing: Record<string, string>,
  ) {
    return getHash(
      hash + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp,
    )
  }

  function registerMissingImport(
    id: string,
    resolved: string,
  ): OptimizedDepInfo {
    const optimized = metadata.optimized[id]
    if (optimized) {
      return optimized
    }
    const chunk = metadata.chunks[id]
    if (chunk) {
      return chunk
    }
    let missing = metadata.discovered[id]
    if (missing) {
      // We are already discover this dependency
      // It will be processed in the next rerun call
      return missing
    }

    missing = addMissingDep(id, resolved)

    // Until the first optimize run is called, avoid triggering processing
    // We'll wait until the user codebase is eagerly processed by Vite so
    // we can get a list of every missing dependency before giving to the
    // browser a dependency that may be outdated, thus avoiding full page reloads

    if (!waitingForCrawlEnd) {
      // Debounced rerun, let other missing dependencies be discovered before
      // the running next optimizeDeps
      debouncedProcessing()
    }

    // Return the path for the optimized bundle, this path is known before
    // esbuild is run to generate the pre-bundle
    return missing
  }

  function addMissingDep(id: string, resolved: string) {
    newDepsDiscovered = true

    return addOptimizedDepInfo(metadata, 'discovered', {
      id,
      file: getOptimizedDepPath(environment, id),
      src: resolved,
      // Adding a browserHash to this missing dependency that is unique to
      // the current state of known + missing deps. If its optimizeDeps run
      // doesn't alter the bundled files of previous known dependencies,
      // we don't need a full reload and this browserHash will be kept
      browserHash: getDiscoveredBrowserHash(
        metadata.hash,
        depsFromOptimizedDepInfo(metadata.optimized),
        depsFromOptimizedDepInfo(metadata.discovered),
      ),
      // loading of this pre-bundled dep needs to await for its processing
      // promise to be resolved
      processing: depOptimizationProcessing.promise,
      exportsData: extractExportsData(environment, resolved),
    })
  }

  function debouncedProcessing(timeout = debounceMs) {
    // Debounced rerun, let other missing dependencies be discovered before
    // the next optimizeDeps run
    enqueuedRerun = undefined
    if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle)
    if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle)
    newDepsToLogHandle = undefined
    debounceProcessingHandle = setTimeout(() => {
      debounceProcessingHandle = undefined
      enqueuedRerun = rerun
      if (!currentlyProcessing) {
        enqueuedRerun()
      }
    }, timeout)
  }

  // onCrawlEnd is called once when the server starts and all static
  // imports after the first request have been crawled (dynamic imports may also
  // be crawled if the browser requests them right away).
  async function onCrawlEnd() {
    // switch after this point to a simple debounce strategy
    waitingForCrawlEnd = false

    debug?.(colors.green(`✨ static imports crawl ended`))
    if (closed) {
      return
    }

    // Await for the scan+optimize step running in the background
    // It normally should be over by the time crawling of user code ended
    await depsOptimizer.scanProcessing

    if (optimizationResult && !options.noDiscovery) {
      // In the holdUntilCrawlEnd strategy, we don't release the result of the
      // post-scanner optimize step to the browser until we reach this point
      // If there are new dependencies, we do another optimize run, if not, we
      // use the post-scanner optimize result
      // If holdUntilCrawlEnd is false and we reach here, it means that the
      // scan+optimize step finished after crawl end. We follow the same
      // process as in the holdUntilCrawlEnd in this case.
      const afterScanResult = optimizationResult.result
      optimizationResult = undefined // signal that we'll be using the result

      const result = await afterScanResult
      currentlyProcessing = false

      const crawlDeps = Object.keys(metadata.discovered)
      const scanDeps = Object.keys(result.metadata.optimized)

      if (scanDeps.length === 0 && crawlDeps.length === 0) {
        debug?.(
          colors.green(
            `✨ no dependencies found by the scanner or crawling static imports`,
          ),
        )
        // We still commit the result so the scanner isn't run on the next cold start
        // for projects without dependencies
        startNextDiscoveredBatch()
        runOptimizer(result)
        return
      }

      const needsInteropMismatch = findInteropMismatches(
        metadata.discovered,
        result.metadata.optimized,
      )
      const scannerMissedDeps = crawlDeps.some((dep) => !scanDeps.includes(dep))
      const outdatedResult =
        needsInteropMismatch.length > 0 || scannerMissedDeps

      if (outdatedResult) {
        // Drop this scan result, and perform a new optimization to avoid a full reload
        result.cancel()

        // Add deps found by the scanner to the discovered deps while crawling
        for (const dep of scanDeps) {
          if (!crawlDeps.includes(dep)) {
            addMissingDep(dep, result.metadata.optimized[dep].src!)
          }
        }
        if (scannerMissedDeps) {
          debug?.(
            colors.yellow(
              `✨ new dependencies were found while crawling that weren't detected by the scanner`,
            ),
          )
        }
        debug?.(colors.green(`✨ re-running optimizer`))
        debouncedProcessing(0)
      } else {
        debug?.(
          colors.green(
            `✨ using post-scan optimizer result, the scanner found every used dependency`,
          ),
        )
        startNextDiscoveredBatch()
        runOptimizer(result)
      }
    } else if (!holdUntilCrawlEnd) {
      // The post-scanner optimize result has been released to the browser
      // If new deps have been discovered, issue a regular rerun of the
      // optimizer. A full page reload may still be avoided if the new
      // optimize result is compatible in this case
      if (newDepsDiscovered) {
        debug?.(
          colors.green(
            `✨ new dependencies were found while crawling static imports, re-running optimizer`,
          ),
        )
        warnAboutMissedDependencies = true
        debouncedProcessing(0)
      }
    } else {
      const crawlDeps = Object.keys(metadata.discovered)
      currentlyProcessing = false

      if (crawlDeps.length === 0) {
        debug?.(
          colors.green(
            `✨ no dependencies found while crawling the static imports`,
          ),
        )
        firstRunCalled = true
      }

      // queue the first optimizer run, even without deps so the result is cached
      debouncedProcessing(0)
    }
  }

  return depsOptimizer
}

export function createExplicitDepsOptimizer(
  environment: DevEnvironment,
): DepsOptimizer {
  const depsOptimizer = {
    metadata: initDepsOptimizerMetadata(environment),
    isOptimizedDepFile: createIsOptimizedDepFile(environment),
    isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
    getOptimizedDepId: (depInfo: OptimizedDepInfo) =>
      `${depInfo.file}?v=${depInfo.browserHash}`,

    registerMissingImport: () => {
      throw new Error(
        `Vite Internal Error: registerMissingImport is not supported in dev ${environment.name}`,
      )
    },
    init,
    // noop, there is no scanning during dev SSR
    // the optimizer blocks the server start
    run: () => {},

    close: async () => {},
    options: environment.config.optimizeDeps,
  }

  let inited = false
  async function init() {
    if (inited) return
    inited = true

    depsOptimizer.metadata = await optimizeExplicitEnvironmentDeps(environment)
  }

  return depsOptimizer
}

function findInteropMismatches(
  discovered: Record<string, OptimizedDepInfo>,
  optimized: Record<string, OptimizedDepInfo>,
) {
  const needsInteropMismatch = []
  for (const dep in discovered) {
    const discoveredDepInfo = discovered[dep]
    if (discoveredDepInfo.needsInterop === undefined) continue

    const depInfo = optimized[dep]
    if (!depInfo) continue

    if (depInfo.needsInterop !== discoveredDepInfo.needsInterop) {
      // This only happens when a discovered dependency has mixed ESM and CJS syntax
      // and it hasn't been manually added to optimizeDeps.needsInterop
      needsInteropMismatch.push(dep)
      debug?.(colors.cyan(`✨ needsInterop mismatch detected for ${dep}`))
    }
  }
  return needsInteropMismatch
}



================================================
FILE: packages/vite/src/node/optimizer/resolve.ts
================================================
import path from 'node:path'
import picomatch from 'picomatch'
import { globSync } from 'tinyglobby'
import type { ResolvedConfig } from '../config'
import { escapeRegex, getNpmPackageName } from '../utils'
import { resolvePackageData } from '../packages'
import { slash } from '../../shared/utils'
import type { Environment } from '../environment'
import { createBackCompatIdResolver } from '../idResolver'

export function createOptimizeDepsIncludeResolver(
  environment: Environment,
): (id: string) => Promise<string | undefined> {
  const topLevelConfig = environment.getTopLevelConfig()
  const resolve = createBackCompatIdResolver(topLevelConfig, {
    asSrc: false,
    scan: true,
    packageCache: new Map(),
  })

  return async (id: string) => {
    const lastArrowIndex = id.lastIndexOf('>')
    if (lastArrowIndex === -1) {
      return await resolve(environment, id, undefined)
    }
    // split nested selected id by last '>', for example:
    // 'foo > bar > baz' => 'foo > bar' & 'baz'
    const nestedRoot = id.substring(0, lastArrowIndex).trim()
    const nestedPath = id.substring(lastArrowIndex + 1).trim()
    const basedir = nestedResolveBasedir(
      nestedRoot,
      topLevelConfig.root,
      topLevelConfig.resolve.preserveSymlinks,
    )
    return await resolve(
      environment,
      nestedPath,
      path.resolve(basedir, 'package.json'),
    )
  }
}

/**
 * Expand the glob syntax in `optimizeDeps.include` to proper import paths
 */
export function expandGlobIds(id: string, config: ResolvedConfig): string[] {
  const pkgName = getNpmPackageName(id)
  if (!pkgName) return []

  const pkgData = resolvePackageData(
    pkgName,
    config.root,
    config.resolve.preserveSymlinks,
    config.packageCache,
  )
  if (!pkgData) return []

  const pattern = '.' + id.slice(pkgName.length)
  const exports = pkgData.data.exports

  // if package has exports field, get all possible export paths and apply
  // glob on them with picomatch
  if (exports) {
    if (typeof exports === 'string' || Array.isArray(exports)) {
      return [pkgName]
    }

    const possibleExportPaths: string[] = []
    for (const key in exports) {
      if (key[0] === '.') {
        if (key.includes('*')) {
          // "./glob/*": {
          //   "browser": "./dist/glob/*-browser/*.js", <-- get this one
          //   "default": "./dist/glob/*/*.js"
          // }
          // NOTE: theoretically the "default" condition could map to a different
          // set of files, but that complicates the resolve logic, so we assume
          // all conditions map to the same set of files, and get the first one.
          const exportsValue = getFirstExportStringValue(exports[key])
          if (!exportsValue) continue

          // "./dist/glob/*-browser/*.js" => "./dist/glob/**/*-browser/**/*.js"
          // NOTE: in some cases, this could expand to consecutive /**/*/**/* etc
          // but it's fine since `tinyglobby` handles it the same.
          const exportValuePattern = exportsValue.replace(/\*/g, '**/*')
          // "./dist/glob/*-browser/*.js" => /dist\/glob\/(.*)-browser\/(.*)\.js/
          const exportsValueGlobRe = new RegExp(
            exportsValue.split('*').map(escapeRegex).join('(.*)'),
          )

          possibleExportPaths.push(
            ...globSync(exportValuePattern, {
              cwd: pkgData.dir,
              expandDirectories: false,
              ignore: ['node_modules'],
            })
              .map((filePath) => {
                // `tinyglobby` returns paths as they are formatted by the underlying `fdir`.
                // Both `globSync("./some-dir/**/*")` and `globSync("./**/*")` result in
                // `"some-dir/somefile"` being returned, so we ensure the correct prefix manually.
                if (exportsValue.startsWith('./')) {
                  filePath = './' + filePath
                }

                // "./glob/*": "./dist/glob/*-browser/*.js"
                // `filePath`: "./dist/glob/foo-browser/foo.js"
                // we need to revert the file path back to the export key by
                // matching value regex and replacing the capture groups to the key
                const matched = exportsValueGlobRe.exec(slash(filePath))
                // `matched`: [..., 'foo', 'foo']
                if (matched) {
                  let allGlobSame = matched.length === 2
                  // exports key can only have one *, so for >=2 matched groups,
                  // make sure they have the same value
                  if (!allGlobSame) {
                    // assume true, if one group is different, set false and break
                    allGlobSame = true
                    for (let i = 2; i < matched.length; i++) {
                      if (matched[i] !== matched[i - 1]) {
                        allGlobSame = false
                        break
                      }
                    }
                  }
                  if (allGlobSame) {
                    return key.replace('*', matched[1]).slice(2)
                  }
                }
                return ''
              })
              .filter(Boolean),
          )
        } else {
          possibleExportPaths.push(key.slice(2))
        }
      }
    }

    const isMatch = picomatch(pattern)
    const matched = possibleExportPaths
      .filter((p) => isMatch(p))
      .map((match) => path.posix.join(pkgName, match))
    matched.unshift(pkgName)
    return matched
  } else {
    // for packages without exports, we can do a simple glob
    const matched = globSync(pattern, {
      cwd: pkgData.dir,
      expandDirectories: false,
      ignore: ['node_modules'],
    }).map((match) => path.posix.join(pkgName, slash(match)))
    matched.unshift(pkgName)
    return matched
  }
}

function getFirstExportStringValue(
  obj: string | string[] | Record<string, any>,
): string | undefined {
  if (typeof obj === 'string') {
    return obj
  } else if (Array.isArray(obj)) {
    return obj[0]
  } else {
    for (const key in obj) {
      return getFirstExportStringValue(obj[key])
    }
  }
}

/**
 * Continuously resolve the basedir of packages separated by '>'
 */
function nestedResolveBasedir(
  id: string,
  basedir: string,
  preserveSymlinks = false,
) {
  const pkgs = id.split('>').map((pkg) => pkg.trim())
  for (const pkg of pkgs) {
    basedir = resolvePackageData(pkg, basedir, preserveSymlinks)?.dir || basedir
  }
  return basedir
}



================================================
FILE: packages/vite/src/node/optimizer/scan.ts
================================================
import fs from 'node:fs'
import fsp from 'node:fs/promises'
import path from 'node:path'
import { performance } from 'node:perf_hooks'
import type {
  BuildContext,
  Loader,
  OnLoadArgs,
  OnLoadResult,
  Plugin,
} from 'esbuild'
import esbuild, { formatMessages, transform } from 'esbuild'
import type { PartialResolvedId } from 'rollup'
import colors from 'picocolors'
import { glob } from 'tinyglobby'
import {
  CSS_LANGS_RE,
  JS_TYPES_RE,
  KNOWN_ASSET_TYPES,
  SPECIAL_QUERY_RE,
} from '../constants'
import {
  arraify,
  createDebugger,
  dataUrlRE,
  externalRE,
  isInNodeModules,
  isObject,
  isOptimizable,
  moduleListContains,
  multilineCommentsRE,
  normalizePath,
  singlelineCommentsRE,
  virtualModulePrefix,
  virtualModuleRE,
} from '../utils'
import type { EnvironmentPluginContainer } from '../server/pluginContainer'
import { createEnvironmentPluginContainer } from '../server/pluginContainer'
import { BaseEnvironment } from '../baseEnvironment'
import type { DevEnvironment } from '../server/environment'
import { transformGlobImport } from '../plugins/importMetaGlob'
import { cleanUrl } from '../../shared/utils'
import { loadTsconfigJsonForFile } from '../plugins/esbuild'

export class ScanEnvironment extends BaseEnvironment {
  mode = 'scan' as const

  get pluginContainer(): EnvironmentPluginContainer {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`,
      )
    return this._pluginContainer
  }
  /**
   * @internal
   */
  _pluginContainer: EnvironmentPluginContainer | undefined

  async init(): Promise<void> {
    if (this._initiated) {
      return
    }
    this._initiated = true
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this.plugins,
      undefined,
      false,
    )
  }
}

// Restrict access to the module graph and the server while scanning
export function devToScanEnvironment(
  environment: DevEnvironment,
): ScanEnvironment {
  return {
    mode: 'scan',
    get name() {
      return environment.name
    },
    getTopLevelConfig() {
      return environment.getTopLevelConfig()
    },
    get config() {
      return environment.config
    },
    get logger() {
      return environment.logger
    },
    get pluginContainer() {
      return environment.pluginContainer
    },
    get plugins() {
      return environment.plugins
    },
  } as unknown as ScanEnvironment
}

const debug = createDebugger('vite:deps')

const htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/

// A simple regex to detect import sources. This is only used on
// <script lang="ts"> blocks in vue (setup only) or svelte files, since
// seemingly unused imports are dropped by esbuild when transpiling TS which
// prevents it from crawling further.
// We can't use es-module-lexer because it can't handle TS, and don't want to
// use Acorn because it's slow. Luckily this doesn't have to be bullet proof
// since even missed imports can be caught at runtime, and false positives will
// simply be ignored.
export const importsRE =
  /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm

export function scanImports(environment: ScanEnvironment): {
  cancel: () => Promise<void>
  result: Promise<{
    deps: Record<string, string>
    missing: Record<string, string>
  }>
} {
  const start = performance.now()
  const { config } = environment

  const scanContext = { cancelled: false }
  let esbuildContext: Promise<BuildContext | undefined> | undefined
  async function cancel() {
    scanContext.cancelled = true
    return esbuildContext?.then((context) => context?.cancel())
  }

  async function scan() {
    const entries = await computeEntries(environment)
    if (!entries.length) {
      if (!config.optimizeDeps.entries && !config.optimizeDeps.include) {
        environment.logger.warn(
          colors.yellow(
            '(!) Could not auto-determine entry point from rollupOptions or html files ' +
              'and there are no explicit optimizeDeps.include patterns. ' +
              'Skipping dependency pre-bundling.',
          ),
        )
      }
      return
    }
    if (scanContext.cancelled) return

    debug?.(
      `Crawling dependencies using entries: ${entries
        .map((entry) => `\n  ${colors.dim(entry)}`)
        .join('')}`,
    )
    const deps: Record<string, string> = {}
    const missing: Record<string, string> = {}

    let context: BuildContext | undefined
    try {
      esbuildContext = prepareEsbuildScanner(
        environment,
        entries,
        deps,
        missing,
      )
      context = await esbuildContext
      if (scanContext.cancelled) return

      try {
        await context!.rebuild()
        return {
          // Ensure a fixed order so hashes are stable and improve logs
          deps: orderedDependencies(deps),
          missing,
        }
      } catch (e) {
        if (e.errors && e.message.includes('The build was canceled')) {
          // esbuild logs an error when cancelling, but this is expected so
          // return an empty result instead
          return
        }

        const prependMessage = colors.red(`\
  Failed to scan for dependencies from entries:
  ${entries.join('\n')}

  `)
        if (e.errors) {
          const msgs = await formatMessages(e.errors, {
            kind: 'error',
            color: true,
          })
          e.message = prependMessage + msgs.join('\n')
        } else {
          e.message = prependMessage + e.message
        }
        throw e
      } finally {
        if (debug) {
          const duration = (performance.now() - start).toFixed(2)
          const depsStr =
            Object.keys(orderedDependencies(deps))
              .sort()
              .map((id) => `\n  ${colors.cyan(id)} -> ${colors.dim(deps[id])}`)
              .join('') || colors.dim('no dependencies found')
          debug(`Scan completed in ${duration}ms: ${depsStr}`)
        }
      }
    } finally {
      context?.dispose().catch((e) => {
        environment.logger.error('Failed to dispose esbuild context', {
          error: e,
        })
      })
    }
  }
  const result = scan()

  return {
    cancel,
    result: result.then((res) => res ?? { deps: {}, missing: {} }),
  }
}

async function computeEntries(environment: ScanEnvironment) {
  let entries: string[] = []

  const explicitEntryPatterns = environment.config.optimizeDeps.entries
  const buildInput = environment.config.build.rollupOptions.input

  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, environment)
  } else if (buildInput) {
    const resolvePath = async (p: string) => {
      // rollup resolves the input from process.cwd()
      const id = (
        await environment.pluginContainer.resolveId(
          p,
          path.join(process.cwd(), '*'),
          {
            isEntry: true,
            scan: true,
          },
        )
      )?.id
      if (id === undefined) {
        throw new Error(
          `failed to resolve rollupOptions.input value: ${JSON.stringify(p)}.`,
        )
      }
      return id
    }
    if (typeof buildInput === 'string') {
      entries = [await resolvePath(buildInput)]
    } else if (Array.isArray(buildInput)) {
      entries = await Promise.all(buildInput.map(resolvePath))
    } else if (isObject(buildInput)) {
      entries = await Promise.all(Object.values(buildInput).map(resolvePath))
    } else {
      throw new Error('invalid rollupOptions.input value.')
    }
  } else {
    entries = await globEntries('**/*.html', environment)
  }

  // Non-supported entry file types and virtual files should not be scanned for
  // dependencies.
  entries = entries.filter(
    (entry) =>
      isScannable(entry, environment.config.optimizeDeps.extensions) &&
      fs.existsSync(entry),
  )

  return entries
}

async function prepareEsbuildScanner(
  environment: ScanEnvironment,
  entries: string[],
  deps: Record<string, string>,
  missing: Record<string, string>,
): Promise<BuildContext> {
  const plugin = esbuildScanPlugin(environment, deps, missing, entries)

  const { plugins = [], ...esbuildOptions } =
    environment.config.optimizeDeps.esbuildOptions ?? {}

  // The plugin pipeline automatically loads the closest tsconfig.json.
  // But esbuild doesn't support reading tsconfig.json if the plugin has resolved the path (https://github.com/evanw/esbuild/issues/2265).
  // Due to syntax incompatibilities between the experimental decorators in TypeScript and TC39 decorators,
  // we cannot simply set `"experimentalDecorators": true` or `false`. (https://github.com/vitejs/vite/pull/15206#discussion_r1417414715)
  // Therefore, we use the closest tsconfig.json from the root to make it work in most cases.
  let tsconfigRaw = esbuildOptions.tsconfigRaw
  if (!tsconfigRaw && !esbuildOptions.tsconfig) {
    const { tsconfig } = await loadTsconfigJsonForFile(
      path.join(environment.config.root, '_dummy.js'),
    )
    if (
      tsconfig.compilerOptions?.experimentalDecorators ||
      tsconfig.compilerOptions?.jsx ||
      tsconfig.compilerOptions?.jsxFactory ||
      tsconfig.compilerOptions?.jsxFragmentFactory ||
      tsconfig.compilerOptions?.jsxImportSource
    ) {
      tsconfigRaw = {
        compilerOptions: {
          experimentalDecorators:
            tsconfig.compilerOptions?.experimentalDecorators,
          // esbuild uses tsconfig fields when both the normal options and tsconfig was set
          // but we want to prioritize the normal options
          jsx: esbuildOptions.jsx ? undefined : tsconfig.compilerOptions?.jsx,
          jsxFactory: esbuildOptions.jsxFactory
            ? undefined
            : tsconfig.compilerOptions?.jsxFactory,
          jsxFragmentFactory: esbuildOptions.jsxFragment
            ? undefined
            : tsconfig.compilerOptions?.jsxFragmentFactory,
          jsxImportSource: esbuildOptions.jsxImportSource
            ? undefined
            : tsconfig.compilerOptions?.jsxImportSource,
        },
      }
    }
  }

  return await esbuild.context({
    absWorkingDir: process.cwd(),
    write: false,
    stdin: {
      contents: entries.map((e) => `import ${JSON.stringify(e)}`).join('\n'),
      loader: 'js',
    },
    bundle: true,
    format: 'esm',
    logLevel: 'silent',
    plugins: [...plugins, plugin],
    jsxDev: !environment.config.isProduction,
    ...esbuildOptions,
    tsconfigRaw,
  })
}

function orderedDependencies(deps: Record<string, string>) {
  const depsList = Object.entries(deps)
  // Ensure the same browserHash for the same set of dependencies
  depsList.sort((a, b) => a[0].localeCompare(b[0]))
  return Object.fromEntries(depsList)
}

async function globEntries(
  patterns: string | string[],
  environment: ScanEnvironment,
) {
  const nodeModulesPatterns: string[] = []
  const regularPatterns: string[] = []

  for (const pattern of arraify(patterns)) {
    if (pattern.includes('node_modules')) {
      nodeModulesPatterns.push(pattern)
    } else {
      regularPatterns.push(pattern)
    }
  }

  const sharedOptions = {
    absolute: true,
    cwd: environment.config.root,
    ignore: [
      `**/${environment.config.build.outDir}/**`,
      // if there aren't explicit entries, also ignore other common folders
      ...(environment.config.optimizeDeps.entries
        ? []
        : [`**/__tests__/**`, `**/coverage/**`]),
    ],
  }

  const results = await Promise.all([
    glob(nodeModulesPatterns, sharedOptions),
    glob(regularPatterns, {
      ...sharedOptions,
      ignore: [...sharedOptions.ignore, '**/node_modules/**'],
    }),
  ])

  return results.flat()
}

export const scriptRE =
  /(<script(?:\s+[a-z_:][-\w:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'<>=\s]+))?)*\s*>)(.*?)<\/script>/gis
export const commentRE = /<!--.*?-->/gs
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i
const svelteScriptModuleRE =
  /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i
const svelteModuleRE = /\smodule\b/i

function esbuildScanPlugin(
  environment: ScanEnvironment,
  depImports: Record<string, string>,
  missing: Record<string, string>,
  entries: string[],
): Plugin {
  const seen = new Map<string, string | undefined>()
  async function resolveId(
    id: string,
    importer?: string,
  ): Promise<PartialResolvedId | null> {
    return environment.pluginContainer.resolveId(
      id,
      importer && normalizePath(importer),
      { scan: true },
    )
  }
  const resolve = async (id: string, importer?: string) => {
    const key = id + (importer && path.dirname(importer))
    if (seen.has(key)) {
      return seen.get(key)
    }
    const resolved = await resolveId(id, importer)
    const res = resolved?.id
    seen.set(key, res)
    return res
  }

  const optimizeDepsOptions = environment.config.optimizeDeps
  const include = optimizeDepsOptions.include
  const exclude = [
    ...(optimizeDepsOptions.exclude ?? []),
    '@vite/client',
    '@vite/env',
  ]

  const isUnlessEntry = (path: string) => !entries.includes(path)

  const externalUnlessEntry = ({ path }: { path: string }) => ({
    path,
    external: isUnlessEntry(path),
  })

  const doTransformGlobImport = async (
    contents: string,
    id: string,
    loader: Loader,
  ) => {
    let transpiledContents
    // transpile because `transformGlobImport` only expects js
    if (loader !== 'js') {
      transpiledContents = (await transform(contents, { loader })).code
    } else {
      transpiledContents = contents
    }

    const result = await transformGlobImport(
      transpiledContents,
      id,
      environment.config.root,
      resolve,
    )

    return result?.s.toString() || transpiledContents
  }

  return {
    name: 'vite:dep-scan',
    setup(build) {
      const scripts: Record<string, OnLoadResult> = {}

      // external urls
      build.onResolve({ filter: externalRE }, ({ path }) => ({
        path,
        external: true,
      }))

      // data urls
      build.onResolve({ filter: dataUrlRE }, ({ path }) => ({
        path,
        external: true,
      }))

      // local scripts (`<script>` in Svelte and `<script setup>` in Vue)
      build.onResolve({ filter: virtualModuleRE }, ({ path }) => {
        return {
          // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
          path: path.replace(virtualModulePrefix, ''),
          namespace: 'script',
        }
      })

      build.onLoad({ filter: /.*/, namespace: 'script' }, ({ path }) => {
        return scripts[path]
      })

      // html types: extract script contents -----------------------------------
      build.onResolve({ filter: htmlTypesRE }, async ({ path, importer }) => {
        const resolved = await resolve(path, importer)
        if (!resolved) return
        // It is possible for the scanner to scan html types in node_modules.
        // If we can optimize this html type, skip it so it's handled by the
        // bare import resolve, and recorded as optimization dep.
        if (
          isInNodeModules(resolved) &&
          isOptimizable(resolved, optimizeDepsOptions)
        )
          return
        return {
          path: resolved,
          namespace: 'html',
        }
      })

      const htmlTypeOnLoadCallback: (
        args: OnLoadArgs,
      ) => Promise<OnLoadResult | null | undefined> = async ({ path: p }) => {
        let raw = await fsp.readFile(p, 'utf-8')
        // Avoid matching the content of the comment
        raw = raw.replace(commentRE, '<!---->')
        const isHtml = p.endsWith('.html')
        let js = ''
        let scriptId = 0
        const matches = raw.matchAll(scriptRE)
        for (const [, openTag, content] of matches) {
          const typeMatch = typeRE.exec(openTag)
          const type =
            typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3])
          const langMatch = langRE.exec(openTag)
          const lang =
            langMatch && (langMatch[1] || langMatch[2] || langMatch[3])
          // skip non type module script
          if (isHtml && type !== 'module') {
            continue
          }
          // skip type="application/ld+json" and other non-JS types
          if (
            type &&
            !(
              type.includes('javascript') ||
              type.includes('ecmascript') ||
              type === 'module'
            )
          ) {
            continue
          }
          let loader: Loader = 'js'
          if (lang === 'ts' || lang === 'tsx' || lang === 'jsx') {
            loader = lang
          } else if (p.endsWith('.astro')) {
            loader = 'ts'
          }
          const srcMatch = srcRE.exec(openTag)
          if (srcMatch) {
            const src = srcMatch[1] || srcMatch[2] || srcMatch[3]
            js += `import ${JSON.stringify(src)}\n`
          } else if (content.trim()) {
            // The reason why virtual modules are needed:
            // 1. There can be module scripts (`<script context="module">` in Svelte and `<script>` in Vue)
            // or local scripts (`<script>` in Svelte and `<script setup>` in Vue)
            // 2. There can be multiple module scripts in html
            // We need to handle these separately in case variable names are reused between them

            // append imports in TS to prevent esbuild from removing them
            // since they may be used in the template
            const contents =
              content +
              (loader.startsWith('ts') ? extractImportPaths(content) : '')

            const key = `${p}?id=${scriptId++}`
            if (contents.includes('import.meta.glob')) {
              scripts[key] = {
                loader: 'js', // since it is transpiled
                contents: await doTransformGlobImport(contents, p, loader),
                resolveDir: normalizePath(path.dirname(p)),
                pluginData: {
                  htmlType: { loader },
                },
              }
            } else {
              scripts[key] = {
                loader,
                contents,
                resolveDir: normalizePath(path.dirname(p)),
                pluginData: {
                  htmlType: { loader },
                },
              }
            }

            const virtualModulePath = JSON.stringify(virtualModulePrefix + key)

            let addedImport = false

            // For Svelte files, exports in <script context="module"> or <script module> means module exports,
            // exports in <script> means component props. To avoid having two same export name from the
            // star exports, we need to ignore exports in <script>
            if (p.endsWith('.svelte')) {
              let isModule = svelteModuleRE.test(openTag) // test for svelte5 <script module> syntax
              if (!isModule) {
                // fallback, test for svelte4 <script context="module"> syntax
                const contextMatch = svelteScriptModuleRE.exec(openTag)
                const context =
                  contextMatch &&
                  (contextMatch[1] || contextMatch[2] || contextMatch[3])
                isModule = context === 'module'
              }
              if (!isModule) {
                addedImport = true
                js += `import ${virtualModulePath}\n`
              }
            }

            if (!addedImport) {
              js += `export * from ${virtualModulePath}\n`
            }
          }
        }

        // This will trigger incorrectly if `export default` is contained
        // anywhere in a string. Svelte and Astro files can't have
        // `export default` as code so we know if it's encountered it's a
        // false positive (e.g. contained in a string)
        if (!p.endsWith('.vue') || !js.includes('export default')) {
          js += '\nexport default {}'
        }

        return {
          loader: 'js',
          contents: js,
        }
      }

      // extract scripts inside HTML-like files and treat it as a js module
      build.onLoad(
        { filter: htmlTypesRE, namespace: 'html' },
        htmlTypeOnLoadCallback,
      )
      // the onResolve above will use namespace=html but esbuild doesn't
      // call onResolve for glob imports and those will use namespace=file
      // https://github.com/evanw/esbuild/issues/3317
      build.onLoad(
        { filter: htmlTypesRE, namespace: 'file' },
        htmlTypeOnLoadCallback,
      )

      // bare imports: record and externalize ----------------------------------
      build.onResolve(
        {
          // avoid matching windows volume
          filter: /^[\w@][^:]/,
        },
        async ({ path: id, importer }) => {
          if (moduleListContains(exclude, id)) {
            return externalUnlessEntry({ path: id })
          }
          if (depImports[id]) {
            return externalUnlessEntry({ path: id })
          }
          const resolved = await resolve(id, importer)
          if (resolved) {
            if (shouldExternalizeDep(resolved, id)) {
              return externalUnlessEntry({ path: id })
            }
            if (isInNodeModules(resolved) || include?.includes(id)) {
              // dependency or forced included, externalize and stop crawling
              if (isOptimizable(resolved, optimizeDepsOptions)) {
                depImports[id] = resolved
              }
              return externalUnlessEntry({ path: id })
            } else if (isScannable(resolved, optimizeDepsOptions.extensions)) {
              const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined
              // linked package, keep crawling
              return {
                path: path.resolve(resolved),
                namespace,
              }
            } else {
              return externalUnlessEntry({ path: id })
            }
          } else {
            missing[id] = normalizePath(importer)
          }
        },
      )

      // Externalized file types -----------------------------------------------
      // these are done on raw ids using esbuild's native regex filter so it
      // should be faster than doing it in the catch-all via js
      // they are done after the bare import resolve because a package name
      // may end with these extensions
      const setupExternalize = (
        filter: RegExp,
        doExternalize: (path: string) => boolean,
      ) => {
        build.onResolve({ filter }, ({ path }) => {
          return {
            path,
            external: doExternalize(path),
          }
        })
      }

      // css
      setupExternalize(CSS_LANGS_RE, isUnlessEntry)
      // json & wasm
      setupExternalize(/\.(json|json5|wasm)$/, isUnlessEntry)
      // known asset types
      setupExternalize(
        new RegExp(`\\.(${KNOWN_ASSET_TYPES.join('|')})$`),
        isUnlessEntry,
      )
      // known vite query types: ?worker, ?raw
      setupExternalize(SPECIAL_QUERY_RE, () => true)

      // catch all -------------------------------------------------------------

      build.onResolve(
        {
          filter: /.*/,
        },
        async ({ path: id, importer }) => {
          // use vite resolver to support urls and omitted extensions
          const resolved = await resolve(id, importer)
          if (resolved) {
            if (
              shouldExternalizeDep(resolved, id) ||
              !isScannable(resolved, optimizeDepsOptions.extensions)
            ) {
              return externalUnlessEntry({ path: id })
            }

            const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined

            return {
              path: path.resolve(cleanUrl(resolved)),
              namespace,
            }
          } else {
            // resolve failed... probably unsupported type
            return externalUnlessEntry({ path: id })
          }
        },
      )

      // for jsx/tsx, we need to access the content and check for
      // presence of import.meta.glob, since it results in import relationships
      // but isn't crawled by esbuild.
      build.onLoad({ filter: JS_TYPES_RE }, async ({ path: id }) => {
        let ext = path.extname(id).slice(1)
        if (ext === 'mjs') ext = 'js'

        const esbuildConfig = environment.config.esbuild
        let contents = await fsp.readFile(id, 'utf-8')
        if (ext.endsWith('x') && esbuildConfig && esbuildConfig.jsxInject) {
          contents = esbuildConfig.jsxInject + `\n` + contents
        }

        const loader =
          optimizeDepsOptions.esbuildOptions?.loader?.[`.${ext}`] ??
          (ext as Loader)

        if (contents.includes('import.meta.glob')) {
          return {
            loader: 'js', // since it is transpiled,
            contents: await doTransformGlobImport(contents, id, loader),
          }
        }

        return {
          loader,
          contents,
        }
      })

      // onResolve is not called for glob imports.
      // we need to add that here as well until esbuild calls onResolve for glob imports.
      // https://github.com/evanw/esbuild/issues/3317
      build.onLoad({ filter: /.*/, namespace: 'file' }, () => {
        return {
          loader: 'js',
          contents: 'export default {}',
        }
      })
    },
  }
}

/**
 * when using TS + (Vue + `<script setup>`) or Svelte, imports may seem
 * unused to esbuild and dropped in the build output, which prevents
 * esbuild from crawling further.
 * the solution is to add `import 'x'` for every source to force
 * esbuild to keep crawling due to potential side effects.
 */
function extractImportPaths(code: string) {
  // empty singleline & multiline comments to avoid matching comments
  code = code
    .replace(multilineCommentsRE, '/* */')
    .replace(singlelineCommentsRE, '')

  let js = ''
  let m
  importsRE.lastIndex = 0
  while ((m = importsRE.exec(code)) != null) {
    js += `\nimport ${m[1]}`
  }
  return js
}

function shouldExternalizeDep(resolvedId: string, rawId: string): boolean {
  // not a valid file path
  if (!path.isAbsolute(resolvedId)) {
    return true
  }
  // virtual id
  if (resolvedId === rawId || resolvedId.includes('\0')) {
    return true
  }
  return false
}

function isScannable(id: string, extensions: string[] | undefined): boolean {
  return (
    JS_TYPES_RE.test(id) ||
    htmlTypesRE.test(id) ||
    extensions?.includes(path.extname(id)) ||
    false
  )
}



================================================
FILE: packages/vite/src/node/plugins/asset.ts
================================================
import path from 'node:path'
import fsp from 'node:fs/promises'
import { Buffer } from 'node:buffer'
import * as mrmime from 'mrmime'
import type {
  NormalizedOutputOptions,
  PluginContext,
  RenderedChunk,
} from 'rollup'
import MagicString from 'magic-string'
import colors from 'picocolors'
import {
  createToImportMetaURLBasedRelativeRuntime,
  toOutputFilePathInJS,
} from '../build'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import { checkPublicFile } from '../publicDir'
import {
  encodeURIPath,
  getHash,
  injectQuery,
  joinUrlSegments,
  normalizePath,
  rawRE,
  removeLeadingSlash,
  removeUrlQuery,
  urlRE,
} from '../utils'
import { DEFAULT_ASSETS_INLINE_LIMIT, FS_PREFIX } from '../constants'
import {
  cleanUrl,
  splitFileAndPostfix,
  withTrailingSlash,
} from '../../shared/utils'
import type { Environment } from '../environment'

// referenceId is base64url but replaces - with $
export const assetUrlRE = /__VITE_ASSET__([\w$]+)__(?:\$_(.*?)__)?/g

const jsSourceMapRE = /\.[cm]?js\.map$/

export const noInlineRE = /[?&]no-inline\b/
export const inlineRE = /[?&]inline\b/

const assetCache = new WeakMap<Environment, Map<string, string>>()

/** a set of referenceId for entry CSS assets for each environment */
export const cssEntriesMap = new WeakMap<Environment, Set<string>>()

// add own dictionary entry by directly assigning mrmime
export function registerCustomMime(): void {
  // https://github.com/lukeed/mrmime/issues/3
  // instead of `image/vnd.microsoft.icon` which is registered on IANA Media Types DB
  // image/x-icon should be used instead for better compatibility (https://github.com/h5bp/html5-boilerplate/issues/219)
  mrmime.mimes['ico'] = 'image/x-icon'
  // https://mimesniff.spec.whatwg.org/#matching-an-image-type-pattern
  mrmime.mimes['cur'] = 'image/x-icon'
  // https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers#flac
  mrmime.mimes['flac'] = 'audio/flac'
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  mrmime.mimes['eot'] = 'application/vnd.ms-fontobject'
}

export function renderAssetUrlInJS(
  pluginContext: PluginContext,
  chunk: RenderedChunk,
  opts: NormalizedOutputOptions,
  code: string,
): MagicString | undefined {
  const { environment } = pluginContext
  const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
    opts.format,
    environment.config.isWorker,
  )

  let match: RegExpExecArray | null
  let s: MagicString | undefined

  // Urls added with JS using e.g.
  // imgElement.src = "__VITE_ASSET__5aA0Ddc0__" are using quotes

  // Urls added in CSS that is imported in JS end up like
  // var inlined = ".inlined{color:green;background:url(__VITE_ASSET__5aA0Ddc0__)}\n";

  // In both cases, the wrapping should already be fine

  assetUrlRE.lastIndex = 0
  while ((match = assetUrlRE.exec(code))) {
    s ||= new MagicString(code)
    const [full, referenceId, postfix = ''] = match
    const file = pluginContext.getFileName(referenceId)
    chunk.viteMetadata!.importedAssets.add(cleanUrl(file))
    const filename = file + postfix
    const replacement = toOutputFilePathInJS(
      environment,
      filename,
      'asset',
      chunk.fileName,
      'js',
      toRelativeRuntime,
    )
    const replacementString =
      typeof replacement === 'string'
        ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)
        : `"+${replacement.runtime}+"`
    s.update(match.index, match.index + full.length, replacementString)
  }

  // Replace __VITE_PUBLIC_ASSET__5aA0Ddc0__ with absolute paths

  const publicAssetUrlMap = publicAssetUrlCache.get(
    environment.getTopLevelConfig(),
  )!
  publicAssetUrlRE.lastIndex = 0
  while ((match = publicAssetUrlRE.exec(code))) {
    s ||= new MagicString(code)
    const [full, hash] = match
    const publicUrl = publicAssetUrlMap.get(hash)!.slice(1)
    const replacement = toOutputFilePathInJS(
      environment,
      publicUrl,
      'public',
      chunk.fileName,
      'js',
      toRelativeRuntime,
    )
    const replacementString =
      typeof replacement === 'string'
        ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)
        : `"+${replacement.runtime}+"`
    s.update(match.index, match.index + full.length, replacementString)
  }

  return s
}

/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
export function assetPlugin(config: ResolvedConfig): Plugin {
  registerCustomMime()

  return {
    name: 'vite:asset',

    perEnvironmentStartEndDuringDev: true,

    buildStart() {
      assetCache.set(this.environment, new Map())
      cssEntriesMap.set(this.environment, new Set())
    },

    resolveId: {
      handler(id) {
        if (!config.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
          return
        }
        // imports to absolute urls pointing to files in /public
        // will fail to resolve in the main resolver. handle them here.
        const publicFile = checkPublicFile(id, config)
        if (publicFile) {
          return id
        }
      },
    },

    load: {
      filter: {
        id: {
          // Rollup convention, this id should be handled by the
          // plugin that marked it with \0
          exclude: /^\0/,
        },
      },
      async handler(id) {
        // raw requests, read from disk
        if (rawRE.test(id)) {
          const file = checkPublicFile(id, config) || cleanUrl(id)
          this.addWatchFile(file)
          // raw query, read file and return as string
          return `export default ${JSON.stringify(
            await fsp.readFile(file, 'utf-8'),
          )}`
        }

        if (!urlRE.test(id) && !config.assetsInclude(cleanUrl(id))) {
          return
        }

        id = removeUrlQuery(id)
        let url = await fileToUrl(this, id)

        // Inherit HMR timestamp if this asset was invalidated
        if (!url.startsWith('data:') && this.environment.mode === 'dev') {
          const mod = this.environment.moduleGraph.getModuleById(id)
          if (mod && mod.lastHMRTimestamp > 0) {
            url = injectQuery(url, `t=${mod.lastHMRTimestamp}`)
          }
        }

        return {
          code: `export default ${JSON.stringify(encodeURIPath(url))}`,
          // Force rollup to keep this module from being shared between other entry points if it's an entrypoint.
          // If the resulting chunk is empty, it will be removed in generateBundle.
          moduleSideEffects:
            config.command === 'build' && this.getModuleInfo(id)?.isEntry
              ? 'no-treeshake'
              : false,
          meta: config.command === 'build' ? { 'vite:asset': true } : undefined,
        }
      },
    },

    renderChunk(code, chunk, opts) {
      const s = renderAssetUrlInJS(this, chunk, opts, code)

      if (s) {
        return {
          code: s.toString(),
          map: this.environment.config.build.sourcemap
            ? s.generateMap({ hires: 'boundary' })
            : null,
        }
      } else {
        return null
      }
    },

    generateBundle(_, bundle) {
      // Remove empty entry point file
      let importedFiles: Set<string> | undefined
      for (const file in bundle) {
        const chunk = bundle[file]
        if (
          chunk.type === 'chunk' &&
          chunk.isEntry &&
          chunk.moduleIds.length === 1 &&
          config.assetsInclude(chunk.moduleIds[0]) &&
          this.getModuleInfo(chunk.moduleIds[0])?.meta['vite:asset']
        ) {
          if (!importedFiles) {
            importedFiles = new Set()
            for (const file in bundle) {
              const chunk = bundle[file]
              if (chunk.type === 'chunk') {
                for (const importedFile of chunk.imports) {
                  importedFiles.add(importedFile)
                }
                for (const importedFile of chunk.dynamicImports) {
                  importedFiles.add(importedFile)
                }
              }
            }
          }
          if (!importedFiles.has(file)) {
            delete bundle[file]
          }
        }
      }

      // do not emit assets for SSR build
      if (
        config.command === 'build' &&
        !this.environment.config.build.emitAssets
      ) {
        for (const file in bundle) {
          if (
            bundle[file].type === 'asset' &&
            !file.endsWith('ssr-manifest.json') &&
            !jsSourceMapRE.test(file)
          ) {
            delete bundle[file]
          }
        }
      }
    },
  }
}

export async function fileToUrl(
  pluginContext: PluginContext,
  id: string,
): Promise<string> {
  const { environment } = pluginContext
  if (environment.config.command === 'serve') {
    return fileToDevUrl(environment, id)
  } else {
    return fileToBuiltUrl(pluginContext, id)
  }
}

export async function fileToDevUrl(
  environment: Environment,
  id: string,
  skipBase = false,
): Promise<string> {
  const config = environment.getTopLevelConfig()
  const publicFile = checkPublicFile(id, config)

  // If has inline query, unconditionally inline the asset
  if (inlineRE.test(id)) {
    const file = publicFile || cleanUrl(id)
    const content = await fsp.readFile(file)
    return assetToDataURL(environment, file, content)
  }

  // If is svg and it's inlined in build, also inline it in dev to match
  // the behaviour in build due to quote handling differences.
  const cleanedId = cleanUrl(id)
  if (cleanedId.endsWith('.svg')) {
    const file = publicFile || cleanedId
    const content = await fsp.readFile(file)
    if (shouldInline(environment, file, id, content, undefined, undefined)) {
      return assetToDataURL(environment, file, content)
    }
  }

  let rtn: string
  if (publicFile) {
    // in public dir during dev, keep the url as-is
    rtn = id
  } else if (id.startsWith(withTrailingSlash(config.root))) {
    // in project root, infer short public path
    rtn = '/' + path.posix.relative(config.root, id)
  } else {
    // outside of project root, use absolute fs path
    // (this is special handled by the serve static middleware
    rtn = path.posix.join(FS_PREFIX, id)
  }
  if (skipBase) {
    return rtn
  }
  const base = joinUrlSegments(config.server.origin ?? '', config.decodedBase)
  return joinUrlSegments(base, removeLeadingSlash(rtn))
}

export function getPublicAssetFilename(
  hash: string,
  config: ResolvedConfig,
): string | undefined {
  return publicAssetUrlCache.get(config)?.get(hash)
}

export const publicAssetUrlCache = new WeakMap<
  ResolvedConfig,
  // hash -> url
  Map<string, string>
>()

export const publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\d]{8})__/g

export function publicFileToBuiltUrl(
  url: string,
  config: ResolvedConfig,
): string {
  if (config.command !== 'build') {
    // We don't need relative base or renderBuiltUrl support during dev
    return joinUrlSegments(config.decodedBase, url)
  }
  const hash = getHash(url)
  let cache = publicAssetUrlCache.get(config)
  if (!cache) {
    cache = new Map<string, string>()
    publicAssetUrlCache.set(config, cache)
  }
  if (!cache.get(hash)) {
    cache.set(hash, url)
  }
  return `__VITE_PUBLIC_ASSET__${hash}__`
}

const GIT_LFS_PREFIX = Buffer.from('version https://git-lfs.github.com')
function isGitLfsPlaceholder(content: Buffer): boolean {
  if (content.length < GIT_LFS_PREFIX.length) return false
  // Check whether the content begins with the characteristic string of Git LFS placeholders
  return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0
}

/**
 * Register an asset to be emitted as part of the bundle (if necessary)
 * and returns the resolved public URL
 */
async function fileToBuiltUrl(
  pluginContext: PluginContext,
  id: string,
  skipPublicCheck = false,
  forceInline?: boolean,
): Promise<string> {
  const environment = pluginContext.environment
  const topLevelConfig = environment.getTopLevelConfig()
  if (!skipPublicCheck) {
    const publicFile = checkPublicFile(id, topLevelConfig)
    if (publicFile) {
      if (inlineRE.test(id)) {
        // If inline via query, re-assign the id so it can be read by the fs and inlined
        id = publicFile
      } else {
        return publicFileToBuiltUrl(id, topLevelConfig)
      }
    }
  }

  const cache = assetCache.get(environment)!
  const cached = cache.get(id)
  if (cached) {
    return cached
  }

  let { file, postfix } = splitFileAndPostfix(id)
  const content = await fsp.readFile(file)

  let url: string
  if (
    shouldInline(environment, file, id, content, pluginContext, forceInline)
  ) {
    url = assetToDataURL(environment, file, content)
  } else {
    // emit as asset
    const originalFileName = normalizePath(
      path.relative(environment.config.root, file),
    )
    const referenceId = pluginContext.emitFile({
      type: 'asset',
      // Ignore directory structure for asset file names
      name: path.basename(file),
      originalFileName,
      source: content,
    })

    if (environment.config.command === 'build' && noInlineRE.test(postfix)) {
      postfix = postfix.replace(noInlineRE, '').replace(/^&/, '?')
    }

    url = `__VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}`
  }

  cache.set(id, url)
  return url
}

export async function urlToBuiltUrl(
  pluginContext: PluginContext,
  url: string,
  importer: string,
  forceInline?: boolean,
): Promise<string> {
  const topLevelConfig = pluginContext.environment.getTopLevelConfig()
  if (checkPublicFile(url, topLevelConfig)) {
    return publicFileToBuiltUrl(url, topLevelConfig)
  }
  const file =
    url[0] === '/'
      ? path.join(topLevelConfig.root, url)
      : path.join(path.dirname(importer), url)
  return fileToBuiltUrl(
    pluginContext,
    file,
    // skip public check since we just did it above
    true,
    forceInline,
  )
}

function shouldInline(
  environment: Environment,
  file: string,
  id: string,
  content: Buffer,
  /** Should be passed only in build */
  buildPluginContext: PluginContext | undefined,
  forceInline: boolean | undefined,
): boolean {
  if (noInlineRE.test(id)) return false
  if (inlineRE.test(id)) return true
  // Do build only checks if passed the plugin context during build
  if (buildPluginContext) {
    if (environment.config.build.lib) return true
    if (buildPluginContext.getModuleInfo(id)?.isEntry) return false
  }
  if (forceInline !== undefined) return forceInline
  if (file.endsWith('.html')) return false
  // Don't inline SVG with fragments, as they are meant to be reused
  if (file.endsWith('.svg') && id.includes('#')) return false
  let limit: number
  const { assetsInlineLimit } = environment.config.build
  if (typeof assetsInlineLimit === 'function') {
    const userShouldInline = assetsInlineLimit(file, content)
    if (userShouldInline != null) return userShouldInline
    limit = DEFAULT_ASSETS_INLINE_LIMIT
  } else {
    limit = Number(assetsInlineLimit)
  }
  return content.length < limit && !isGitLfsPlaceholder(content)
}

function assetToDataURL(
  environment: Environment,
  file: string,
  content: Buffer,
) {
  if (environment.config.build.lib && isGitLfsPlaceholder(content)) {
    environment.logger.warn(
      colors.yellow(`Inlined file ${file} was not downloaded via Git LFS`),
    )
  }

  if (file.endsWith('.svg')) {
    return svgToDataURL(content)
  } else {
    const mimeType = mrmime.lookup(file) ?? 'application/octet-stream'
    // base64 inlined as a string
    return `data:${mimeType};base64,${content.toString('base64')}`
  }
}

const nestedQuotesRE = /"[^"']*'[^"]*"|'[^'"]*"[^']*'/

// Inspired by https://github.com/iconify/iconify/blob/main/packages/utils/src/svg/url.ts
function svgToDataURL(content: Buffer): string {
  const stringContent = content.toString()
  // If the SVG contains some text or HTML, any transformation is unsafe, and given that double quotes would then
  // need to be escaped, the gain to use a data URI would be ridiculous if not negative
  if (
    stringContent.includes('<text') ||
    stringContent.includes('<foreignObject') ||
    nestedQuotesRE.test(stringContent)
  ) {
    return `data:image/svg+xml;base64,${content.toString('base64')}`
  } else {
    return (
      'data:image/svg+xml,' +
      stringContent
        .trim()
        .replaceAll(/>\s+</g, '><')
        .replaceAll('"', "'")
        .replaceAll('%', '%25')
        .replaceAll('#', '%23')
        .replaceAll('<', '%3c')
        .replaceAll('>', '%3e')
        // Spaces are not valid in srcset it has some use cases
        // it can make the uncompressed URI slightly higher than base64, but will compress way better
        // https://github.com/vitejs/vite/pull/14643#issuecomment-1766288673
        .replaceAll(/\s+/g, '%20')
    )
  }
}



================================================
FILE: packages/vite/src/node/plugins/assetImportMetaUrl.ts
================================================
import path from 'node:path'
import MagicString from 'magic-string'
import { stripLiteral } from 'strip-literal'
import { exactRegex } from '@rolldown/pluginutils'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import {
  injectQuery,
  isDataUrl,
  isParentDirectory,
  transformStableResult,
  tryStatSync,
} from '../utils'
import { CLIENT_ENTRY } from '../constants'
import { slash } from '../../shared/utils'
import { createBackCompatIdResolver } from '../idResolver'
import type { ResolveIdFn } from '../idResolver'
import { fileToUrl } from './asset'
import { preloadHelperId } from './importAnalysisBuild'
import type { InternalResolveOptions } from './resolve'
import { tryFsResolve } from './resolve'
import { hasViteIgnoreRE } from './importAnalysis'

/**
 * Convert `new URL('./foo.png', import.meta.url)` to its resolved built URL
 *
 * Supports template string with dynamic segments:
 * ```
 * new URL(`./dir/${name}.png`, import.meta.url)
 * // transformed to
 * import.meta.glob('./dir/**.png', { eager: true, import: 'default' })[`./dir/${name}.png`]
 * ```
 */
export function assetImportMetaUrlPlugin(config: ResolvedConfig): Plugin {
  const { publicDir } = config
  let assetResolver: ResolveIdFn

  const fsResolveOptions: InternalResolveOptions = {
    ...config.resolve,
    root: config.root,
    isProduction: config.isProduction,
    isBuild: config.command === 'build',
    packageCache: config.packageCache,
    asSrc: true,
  }

  return {
    name: 'vite:asset-import-meta-url',

    applyToEnvironment(environment) {
      return environment.config.consumer === 'client'
    },

    transform: {
      filter: {
        id: {
          exclude: [exactRegex(preloadHelperId), exactRegex(CLIENT_ENTRY)],
        },
        code: /new\s+URL.+import\.meta\.url/,
      },
      async handler(code, id) {
        let s: MagicString | undefined
        const assetImportMetaUrlRE =
          /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*(?:,\s*)?\)/dg
        const cleanString = stripLiteral(code)

        let match: RegExpExecArray | null
        while ((match = assetImportMetaUrlRE.exec(cleanString))) {
          const [[startIndex, endIndex], [urlStart, urlEnd]] = match.indices!
          if (hasViteIgnoreRE.test(code.slice(startIndex, urlStart))) continue

          const rawUrl = code.slice(urlStart, urlEnd)

          if (!s) s = new MagicString(code)

          // potential dynamic template string
          if (rawUrl[0] === '`' && rawUrl.includes('${')) {
            const queryDelimiterIndex = getQueryDelimiterIndex(rawUrl)
            const hasQueryDelimiter = queryDelimiterIndex !== -1
            const pureUrl = hasQueryDelimiter
              ? rawUrl.slice(0, queryDelimiterIndex) + '`'
              : rawUrl
            const queryString = hasQueryDelimiter
              ? rawUrl.slice(queryDelimiterIndex, -1)
              : ''
            const ast = this.parse(pureUrl)
            const templateLiteral = (ast as any).body[0].expression
            if (templateLiteral.expressions.length) {
              const pattern = buildGlobPattern(templateLiteral)
              if (pattern.startsWith('*')) {
                // don't transform for patterns like this
                // because users won't intend to do that in most cases
                continue
              }

              const globOptions = {
                eager: true,
                import: 'default',
                // A hack to allow 'as' & 'query' exist at the same time
                query: injectQuery(queryString, 'url'),
              }
              s.update(
                startIndex,
                endIndex,
                `new URL((import.meta.glob(${JSON.stringify(
                  pattern,
                )}, ${JSON.stringify(
                  globOptions,
                )}))[${pureUrl}], import.meta.url)`,
              )
              continue
            }
          }

          const url = rawUrl.slice(1, -1)
          if (isDataUrl(url)) {
            continue
          }
          let file: string | undefined
          if (url[0] === '.') {
            file = slash(path.resolve(path.dirname(id), url))
            file = tryFsResolve(file, fsResolveOptions) ?? file
          } else {
            assetResolver ??= createBackCompatIdResolver(config, {
              extensions: [],
              mainFields: [],
              tryIndex: false,
              preferRelative: true,
            })
            file = await assetResolver(this.environment, url, id)
            file ??=
              url[0] === '/'
                ? slash(path.join(publicDir, url))
                : slash(path.resolve(path.dirname(id), url))
          }

          // Get final asset URL. If the file does not exist,
          // we fall back to the initial URL and let it resolve in runtime
          let builtUrl: string | undefined
          if (file) {
            try {
              if (publicDir && isParentDirectory(publicDir, file)) {
                const publicPath = '/' + path.posix.relative(publicDir, file)
                builtUrl = await fileToUrl(this, publicPath)
              } else {
                builtUrl = await fileToUrl(this, file)
                // during dev, builtUrl may point to a directory or a non-existing file
                if (tryStatSync(file)?.isFile()) {
                  this.addWatchFile(file)
                }
              }
            } catch {
              // do nothing, we'll log a warning after this
            }
          }
          if (!builtUrl) {
            const rawExp = code.slice(startIndex, endIndex)
            config.logger.warnOnce(
              `\n${rawExp} doesn't exist at build time, it will remain unchanged to be resolved at runtime. ` +
                `If this is intended, you can use the /* @vite-ignore */ comment to suppress this warning.`,
            )
            builtUrl = url
          }
          s.update(
            startIndex,
            endIndex,
            `new URL(${JSON.stringify(builtUrl)}, import.meta.url)`,
          )
        }
        if (s) {
          return transformStableResult(s, id, config)
        }
      },
    },
  }
}

function buildGlobPattern(ast: any) {
  let pattern = ''
  let lastIsGlob = false
  for (let i = 0; i < ast.quasis.length; i++) {
    const str = ast.quasis[i].value.raw
    if (str) {
      pattern += str
      lastIsGlob = false
    }

    if (ast.expressions[i] && !lastIsGlob) {
      pattern += '*'
      lastIsGlob = true
    }
  }
  return pattern
}

function getQueryDelimiterIndex(rawUrl: string): number {
  let bracketsStack = 0
  for (let i = 0; i < rawUrl.length; i++) {
    if (rawUrl[i] === '{') {
      bracketsStack++
    } else if (rawUrl[i] === '}') {
      bracketsStack--
    } else if (rawUrl[i] === '?' && bracketsStack === 0) {
      return i
    }
  }
  return -1
}



================================================
FILE: packages/vite/src/node/plugins/clientInjections.ts
================================================
import path from 'node:path'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import { CLIENT_ENTRY, ENV_ENTRY } from '../constants'
import { isObject, normalizePath, resolveHostname } from '../utils'
import { perEnvironmentState } from '../environment'
import { replaceDefine, serializeDefine } from './define'

// ids in transform are normalized to unix style
const normalizedClientEntry = normalizePath(CLIENT_ENTRY)
const normalizedEnvEntry = normalizePath(ENV_ENTRY)

/**
 * some values used by the client needs to be dynamically injected by the server
 * @server-only
 */
export function clientInjectionsPlugin(config: ResolvedConfig): Plugin {
  let injectConfigValues: (code: string) => string

  const getDefineReplacer = perEnvironmentState((environment) => {
    const userDefine: Record<string, any> = {}
    for (const key in environment.config.define) {
      // import.meta.env.* is handled in `importAnalysis` plugin
      if (!key.startsWith('import.meta.env.')) {
        userDefine[key] = environment.config.define[key]
      }
    }
    const serializedDefines = serializeDefine(userDefine)
    const definesReplacement = () => serializedDefines
    return (code: string) => code.replace(`__DEFINES__`, definesReplacement)
  })

  return {
    name: 'vite:client-inject',
    async buildStart() {
      const resolvedServerHostname = (await resolveHostname(config.server.host))
        .name
      const resolvedServerPort = config.server.port!
      const devBase = config.base

      const serverHost = `${resolvedServerHostname}:${resolvedServerPort}${devBase}`

      let hmrConfig = config.server.hmr
      hmrConfig = isObject(hmrConfig) ? hmrConfig : undefined
      const host = hmrConfig?.host || null
      const protocol = hmrConfig?.protocol || null
      const timeout = hmrConfig?.timeout || 30000
      const overlay = hmrConfig?.overlay !== false
      const isHmrServerSpecified = !!hmrConfig?.server
      const hmrConfigName = path.basename(config.configFile || 'vite.config.js')

      // hmr.clientPort -> hmr.port
      // -> (24678 if middleware mode and HMR server is not specified) -> new URL(import.meta.url).port
      let port = hmrConfig?.clientPort || hmrConfig?.port || null
      if (config.server.middlewareMode && !isHmrServerSpecified) {
        port ||= 24678
      }

      let directTarget = hmrConfig?.host || resolvedServerHostname
      directTarget += `:${hmrConfig?.port || resolvedServerPort}`
      directTarget += devBase

      let hmrBase = devBase
      if (hmrConfig?.path) {
        hmrBase = path.posix.join(hmrBase, hmrConfig.path)
      }

      const modeReplacement = escapeReplacement(config.mode)
      const baseReplacement = escapeReplacement(devBase)
      const serverHostReplacement = escapeReplacement(serverHost)
      const hmrProtocolReplacement = escapeReplacement(protocol)
      const hmrHostnameReplacement = escapeReplacement(host)
      const hmrPortReplacement = escapeReplacement(port)
      const hmrDirectTargetReplacement = escapeReplacement(directTarget)
      const hmrBaseReplacement = escapeReplacement(hmrBase)
      const hmrTimeoutReplacement = escapeReplacement(timeout)
      const hmrEnableOverlayReplacement = escapeReplacement(overlay)
      const hmrConfigNameReplacement = escapeReplacement(hmrConfigName)
      const wsTokenReplacement = escapeReplacement(config.webSocketToken)

      injectConfigValues = (code: string) => {
        return code
          .replace(`__MODE__`, modeReplacement)
          .replace(/__BASE__/g, baseReplacement)
          .replace(`__SERVER_HOST__`, serverHostReplacement)
          .replace(`__HMR_PROTOCOL__`, hmrProtocolReplacement)
          .replace(`__HMR_HOSTNAME__`, hmrHostnameReplacement)
          .replace(`__HMR_PORT__`, hmrPortReplacement)
          .replace(`__HMR_DIRECT_TARGET__`, hmrDirectTargetReplacement)
          .replace(`__HMR_BASE__`, hmrBaseReplacement)
          .replace(`__HMR_TIMEOUT__`, hmrTimeoutReplacement)
          .replace(`__HMR_ENABLE_OVERLAY__`, hmrEnableOverlayReplacement)
          .replace(`__HMR_CONFIG_NAME__`, hmrConfigNameReplacement)
          .replace(`__WS_TOKEN__`, wsTokenReplacement)
      }
    },
    async transform(code, id) {
      const ssr = this.environment.config.consumer === 'server'
      if (id === normalizedClientEntry || id === normalizedEnvEntry) {
        const defineReplacer = getDefineReplacer(this)
        return defineReplacer(injectConfigValues(code))
      } else if (!ssr && code.includes('process.env.NODE_ENV')) {
        // replace process.env.NODE_ENV instead of defining a global
        // for it to avoid shimming a `process` object during dev,
        // avoiding inconsistencies between dev and build
        const nodeEnv =
          this.environment.config.define?.['process.env.NODE_ENV'] ||
          JSON.stringify(process.env.NODE_ENV || config.mode)
        return await replaceDefine(this.environment, code, id, {
          'process.env.NODE_ENV': nodeEnv,
          'global.process.env.NODE_ENV': nodeEnv,
          'globalThis.process.env.NODE_ENV': nodeEnv,
        })
      }
    },
  }
}

function escapeReplacement(value: string | number | boolean | null) {
  const jsonValue = JSON.stringify(value)
  return () => jsonValue
}



================================================
FILE: packages/vite/src/node/plugins/completeSystemWrap.ts
================================================
import type { Plugin } from '../plugin'

/**
 * make sure systemjs register wrap to had complete parameters in system format
 */
export function completeSystemWrapPlugin(): Plugin {
  const SystemJSWrapRE = /System.register\(.*?(\(exports\)|\(\))/g

  return {
    name: 'vite:force-systemjs-wrap-complete',

    renderChunk(code, _chunk, opts) {
      if (opts.format === 'system') {
        return {
          code: code.replace(SystemJSWrapRE, (s, s1) =>
            s.replace(s1, '(exports, module)'),
          ),
          map: null,
        }
      }
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/dataUri.ts
================================================
// This is based on @rollup/plugin-data-uri
// MIT Licensed https://github.com/rollup/plugins/blob/master/LICENSE
// ref https://github.com/vitejs/vite/issues/1428#issuecomment-757033808
import { URL } from 'node:url'
import type { Plugin } from '../plugin'

const dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/
const base64RE = /base64/i
const dataUriPrefix = `\0/@data-uri/`

/**
 * Build only, since importing from a data URI works natively.
 */
export function dataURIPlugin(): Plugin {
  let resolved: Map<string, string>

  return {
    name: 'vite:data-uri',

    buildStart() {
      resolved = new Map()
    },

    resolveId(id) {
      if (!id.trimStart().startsWith('data:')) {
        return
      }

      const uri = new URL(id)
      if (uri.protocol !== 'data:') {
        return
      }

      const match = dataUriRE.exec(uri.pathname)
      if (!match) {
        return
      }

      const [, mime, format, data] = match
      if (mime !== 'text/javascript') {
        throw new Error(
          `data URI with non-JavaScript mime type is not supported. If you're using legacy JavaScript MIME types (such as 'application/javascript'), please use 'text/javascript' instead.`,
        )
      }

      // decode data
      const base64 = format && base64RE.test(format.substring(1))
      const content = base64
        ? Buffer.from(data, 'base64').toString('utf-8')
        : data
      resolved.set(id, content)
      return dataUriPrefix + id
    },

    load(id) {
      if (id.startsWith(dataUriPrefix)) {
        return resolved.get(id.slice(dataUriPrefix.length))
      }
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/define.ts
================================================
import { transform } from 'esbuild'
import { TraceMap, decodedMap, encodedMap } from '@jridgewell/trace-mapping'
import type { ResolvedConfig } from '../config'
import type { Plugin } from '../plugin'
import { escapeRegex, isCSSRequest } from '../utils'
import type { Environment } from '../environment'
import { isHTMLRequest } from './html'

const nonJsRe = /\.json(?:$|\?)/
const isNonJsRequest = (request: string): boolean => nonJsRe.test(request)
const importMetaEnvMarker = '__vite_import_meta_env__'
const importMetaEnvKeyReCache = new Map<string, RegExp>()
const escapedDotRE = /(?<!\\)\\./g

export function definePlugin(config: ResolvedConfig): Plugin {
  const isBuild = config.command === 'build'
  const isBuildLib = isBuild && config.build.lib

  // ignore replace process.env in lib build
  const processEnv: Record<string, string> = {}
  if (!isBuildLib) {
    const nodeEnv = process.env.NODE_ENV || config.mode
    Object.assign(processEnv, {
      'process.env': `{}`,
      'global.process.env': `{}`,
      'globalThis.process.env': `{}`,
      'process.env.NODE_ENV': JSON.stringify(nodeEnv),
      'global.process.env.NODE_ENV': JSON.stringify(nodeEnv),
      'globalThis.process.env.NODE_ENV': JSON.stringify(nodeEnv),
    })
  }

  // during dev, import.meta properties are handled by importAnalysis plugin.
  const importMetaKeys: Record<string, string> = {}
  const importMetaEnvKeys: Record<string, string> = {}
  const importMetaFallbackKeys: Record<string, string> = {}
  if (isBuild) {
    importMetaKeys['import.meta.hot'] = `undefined`
    for (const key in config.env) {
      const val = JSON.stringify(config.env[key])
      importMetaKeys[`import.meta.env.${key}`] = val
      importMetaEnvKeys[key] = val
    }
    // these will be set to a proper value in `generatePattern`
    importMetaKeys['import.meta.env.SSR'] = `undefined`
    importMetaFallbackKeys['import.meta.env'] = `undefined`
  }

  function generatePattern(environment: Environment) {
    const keepProcessEnv = environment.config.keepProcessEnv

    const userDefine: Record<string, string> = {}
    const userDefineEnv: Record<string, any> = {}
    for (const key in environment.config.define) {
      userDefine[key] = handleDefineValue(environment.config.define[key])

      // make sure `import.meta.env` object has user define properties
      if (isBuild && key.startsWith('import.meta.env.')) {
        userDefineEnv[key.slice(16)] = environment.config.define[key]
      }
    }

    const define: Record<string, string> = {
      ...(keepProcessEnv ? {} : processEnv),
      ...importMetaKeys,
      ...userDefine,
      ...importMetaFallbackKeys,
    }

    // Additional define fixes based on `ssr` value
    const ssr = environment.config.consumer === 'server'

    if ('import.meta.env.SSR' in define) {
      define['import.meta.env.SSR'] = ssr + ''
    }
    if ('import.meta.env' in define) {
      define['import.meta.env'] = importMetaEnvMarker
    }

    const importMetaEnvVal = serializeDefine({
      ...importMetaEnvKeys,
      SSR: ssr + '',
      ...userDefineEnv,
    })

    // Create regex pattern as a fast check before running esbuild
    const patternKeys = Object.keys(userDefine)
    if (!keepProcessEnv && Object.keys(processEnv).length) {
      patternKeys.push('process.env')
    }
    if (Object.keys(importMetaKeys).length) {
      patternKeys.push('import.meta.env', 'import.meta.hot')
    }
    const pattern = patternKeys.length
      ? new RegExp(
          patternKeys
            // replace `\.` (ignore `\\.`) with `\??\.` to match with `?.` as well
            .map((key) => escapeRegex(key).replaceAll(escapedDotRE, '\\??\\.'))
            .join('|'),
        )
      : null

    return [define, pattern, importMetaEnvVal] as const
  }

  const patternsCache = new WeakMap<
    Environment,
    readonly [Record<string, string>, RegExp | null, string]
  >()
  function getPattern(environment: Environment) {
    let pattern = patternsCache.get(environment)
    if (!pattern) {
      pattern = generatePattern(environment)
      patternsCache.set(environment, pattern)
    }
    return pattern
  }

  return {
    name: 'vite:define',

    transform: {
      async handler(code, id) {
        if (this.environment.config.consumer === 'client' && !isBuild) {
          // for dev we inject actual global defines in the vite client to
          // avoid the transform cost. see the `clientInjection` and
          // `importAnalysis` plugin.
          return
        }

        if (
          // exclude html, css and static assets for performance
          isHTMLRequest(id) ||
          isCSSRequest(id) ||
          isNonJsRequest(id) ||
          config.assetsInclude(id)
        ) {
          return
        }

        let [define, pattern, importMetaEnvVal] = getPattern(this.environment)
        if (!pattern) return

        // Check if our code needs any replacements before running esbuild
        pattern.lastIndex = 0
        if (!pattern.test(code)) return

        const hasDefineImportMetaEnv = 'import.meta.env' in define
        let marker = importMetaEnvMarker

        if (hasDefineImportMetaEnv && code.includes(marker)) {
          // append a number to the marker until it's unique, to avoid if there is a
          // marker already in the code
          let i = 1
          do {
            marker = importMetaEnvMarker + i++
          } while (code.includes(marker))

          if (marker !== importMetaEnvMarker) {
            define = { ...define, 'import.meta.env': marker }
          }
        }

        const result = await replaceDefine(this.environment, code, id, define)

        if (hasDefineImportMetaEnv) {
          // Replace `import.meta.env.*` with undefined
          result.code = result.code.replaceAll(
            getImportMetaEnvKeyRe(marker),
            (m) => 'undefined'.padEnd(m.length),
          )

          // If there's bare `import.meta.env` references, prepend the banner
          if (result.code.includes(marker)) {
            result.code =
              `const ${marker} = ${importMetaEnvVal};\n` + result.code

            if (result.map) {
              const map = JSON.parse(result.map)
              map.mappings = ';' + map.mappings
              result.map = map
            }
          }
        }

        return result
      },
    },
  }
}

export async function replaceDefine(
  environment: Environment,
  code: string,
  id: string,
  define: Record<string, string>,
): Promise<{ code: string; map: string | null }> {
  const esbuildOptions = environment.config.esbuild || {}

  const result = await transform(code, {
    loader: 'js',
    charset: esbuildOptions.charset ?? 'utf8',
    platform: 'neutral',
    define,
    sourcefile: id,
    sourcemap:
      environment.config.command === 'build'
        ? !!environment.config.build.sourcemap
        : true,
  })

  // remove esbuild's <define:...> source entries
  // since they would confuse source map remapping/collapsing which expects a single source
  if (result.map.includes('<define:')) {
    const originalMap = new TraceMap(result.map)
    if (originalMap.sources.length >= 2) {
      const sourceIndex = originalMap.sources.indexOf(id)
      const decoded = decodedMap(originalMap)
      decoded.sources = [id]
      decoded.mappings = decoded.mappings.map((segments) =>
        segments.filter((segment) => {
          // modify and filter
          const index = segment[1]
          segment[1] = 0
          return index === sourceIndex
        }),
      )
      result.map = JSON.stringify(encodedMap(new TraceMap(decoded as any)))
    }
  }

  return {
    code: result.code,
    map: result.map || null,
  }
}

/**
 * Like `JSON.stringify` but keeps raw string values as a literal
 * in the generated code. For example: `"window"` would refer to
 * the global `window` object directly.
 */
export function serializeDefine(define: Record<string, any>): string {
  let res = `{`
  const keys = Object.keys(define).sort()
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const val = define[key]
    res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`
    if (i !== keys.length - 1) {
      res += `, `
    }
  }
  return res + `}`
}

function handleDefineValue(value: any): string {
  if (typeof value === 'undefined') return 'undefined'
  if (typeof value === 'string') return value
  return JSON.stringify(value)
}

function getImportMetaEnvKeyRe(marker: string): RegExp {
  let re = importMetaEnvKeyReCache.get(marker)
  if (!re) {
    re = new RegExp(`${marker}\\..+?\\b`, 'g')
    importMetaEnvKeyReCache.set(marker, re)
  }
  return re
}



================================================
FILE: packages/vite/src/node/plugins/dynamicImportVars.ts
================================================
import { posix } from 'node:path'
import MagicString from 'magic-string'
import { init, parse as parseImports } from 'es-module-lexer'
import type { ImportSpecifier } from 'es-module-lexer'
import { parseAst } from 'rollup/parseAst'
import { dynamicImportToGlob } from '@rollup/plugin-dynamic-import-vars'
import { exactRegex } from '@rolldown/pluginutils'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import { CLIENT_ENTRY } from '../constants'
import { createBackCompatIdResolver } from '../idResolver'
import {
  createFilter,
  normalizePath,
  rawRE,
  requestQueryMaybeEscapedSplitRE,
  requestQuerySplitRE,
  transformStableResult,
  urlRE,
} from '../utils'
import type { Environment } from '../environment'
import { perEnvironmentState } from '../environment'
import { hasViteIgnoreRE } from './importAnalysis'
import { workerOrSharedWorkerRE } from './worker'

export const dynamicImportHelperId = '\0vite/dynamic-import-helper.js'

const relativePathRE = /^\.{1,2}\//
// fast path to check if source contains a dynamic import. we check for a
// trailing slash too as a dynamic import statement can have comments between
// the `import` and the `(`.
const hasDynamicImportRE = /\bimport\s*[(/]/

interface DynamicImportRequest {
  query?: string | Record<string, string>
  import?: string
}

interface DynamicImportPattern {
  globParams: DynamicImportRequest | null
  userPattern: string
  rawPattern: string
}

const dynamicImportHelper = (
  glob: Record<string, any>,
  path: string,
  segs: number,
) => {
  const v = glob[path]
  if (v) {
    return typeof v === 'function' ? v() : Promise.resolve(v)
  }
  return new Promise((_, reject) => {
    ;(typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
      reject.bind(
        null,
        new Error(
          'Unknown variable dynamic import: ' +
            path +
            (path.split('/').length !== segs
              ? '. Note that variables only represent file names one level deep.'
              : ''),
        ),
      ),
    )
  })
}

function parseDynamicImportPattern(
  strings: string,
): DynamicImportPattern | null {
  const filename = strings.slice(1, -1)
  const ast = (parseAst(strings).body[0] as any).expression

  const userPatternQuery = dynamicImportToGlob(ast, filename)
  if (!userPatternQuery) {
    return null
  }

  const [userPattern] = userPatternQuery.split(
    // ? is escaped on posix OS
    requestQueryMaybeEscapedSplitRE,
    2,
  )
  let [rawPattern, search] = filename.split(requestQuerySplitRE, 2)
  let globParams: DynamicImportRequest | null = null
  if (search) {
    search = '?' + search
    if (
      workerOrSharedWorkerRE.test(search) ||
      urlRE.test(search) ||
      rawRE.test(search)
    ) {
      globParams = {
        query: search,
        import: '*',
      }
    } else {
      globParams = {
        query: search,
      }
    }
  }

  return {
    globParams,
    userPattern,
    rawPattern,
  }
}

export async function transformDynamicImport(
  importSource: string,
  importer: string,
  resolve: (
    url: string,
    importer?: string,
  ) => Promise<string | undefined> | string | undefined,
  root: string,
): Promise<{
  glob: string
  pattern: string
  rawPattern: string
} | null> {
  if (importSource[1] !== '.' && importSource[1] !== '/') {
    const resolvedFileName = await resolve(importSource.slice(1, -1), importer)
    if (!resolvedFileName) {
      return null
    }
    const relativeFileName = normalizePath(
      posix.relative(
        posix.dirname(normalizePath(importer)),
        normalizePath(resolvedFileName),
      ),
    )
    importSource =
      '`' + (relativeFileName[0] === '.' ? '' : './') + relativeFileName + '`'
  }

  const dynamicImportPattern = parseDynamicImportPattern(importSource)
  if (!dynamicImportPattern) {
    return null
  }
  const { globParams, rawPattern, userPattern } = dynamicImportPattern
  const params = globParams ? `, ${JSON.stringify(globParams)}` : ''
  const dir = importer ? posix.dirname(importer) : root
  const normalized =
    rawPattern[0] === '/'
      ? posix.join(root, rawPattern.slice(1))
      : posix.join(dir, rawPattern)

  let newRawPattern = posix.relative(posix.dirname(importer), normalized)

  if (!relativePathRE.test(newRawPattern)) {
    newRawPattern = `./${newRawPattern}`
  }

  const exp = `(import.meta.glob(${JSON.stringify(userPattern)}${params}))`

  return {
    rawPattern: newRawPattern,
    pattern: userPattern,
    glob: exp,
  }
}

export function dynamicImportVarsPlugin(config: ResolvedConfig): Plugin {
  const resolve = createBackCompatIdResolver(config, {
    preferRelative: true,
    tryIndex: false,
    extensions: [],
  })

  const getFilter = perEnvironmentState((environment: Environment) => {
    const { include, exclude } =
      environment.config.build.dynamicImportVarsOptions
    return createFilter(include, exclude)
  })

  return {
    name: 'vite:dynamic-import-vars',

    resolveId: {
      filter: { id: exactRegex(dynamicImportHelperId) },
      handler(id) {
        return id
      },
    },

    load: {
      filter: { id: exactRegex(dynamicImportHelperId) },
      handler(_id) {
        return `export default ${dynamicImportHelper.toString()}`
      },
    },

    transform: {
      filter: {
        id: { exclude: exactRegex(CLIENT_ENTRY) },
        code: hasDynamicImportRE,
      },
      async handler(source, importer) {
        const { environment } = this
        if (!getFilter(this)(importer)) {
          return
        }

        await init

        let imports: readonly ImportSpecifier[] = []
        try {
          imports = parseImports(source)[0]
        } catch {
          // ignore as it might not be a JS file, the subsequent plugins will catch the error
          return null
        }

        if (!imports.length) {
          return null
        }

        let s: MagicString | undefined
        let needDynamicImportHelper = false

        for (let index = 0; index < imports.length; index++) {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex,
          } = imports[index]

          if (dynamicIndex === -1 || source[start] !== '`') {
            continue
          }

          if (hasViteIgnoreRE.test(source.slice(expStart, expEnd))) {
            continue
          }

          s ||= new MagicString(source)
          let result
          try {
            result = await transformDynamicImport(
              source.slice(start, end),
              importer,
              (id, importer) => resolve(environment, id, importer),
              config.root,
            )
          } catch (error) {
            if (environment.config.build.dynamicImportVarsOptions.warnOnError) {
              this.warn(error)
            } else {
              this.error(error)
            }
          }

          if (!result) {
            continue
          }

          const { rawPattern, glob } = result

          needDynamicImportHelper = true
          s.overwrite(
            expStart,
            expEnd,
            `__variableDynamicImportRuntimeHelper(${glob}, \`${rawPattern}\`, ${rawPattern.split('/').length})`,
          )
        }

        if (s) {
          if (needDynamicImportHelper) {
            s.prepend(
              `import __variableDynamicImportRuntimeHelper from "${dynamicImportHelperId}";`,
            )
          }
          return transformStableResult(s, importer, config)
        }
      },
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/esbuild.ts
================================================
import path from 'node:path'
import colors from 'picocolors'
import type {
  Loader,
  Message,
  TransformOptions,
  TransformResult,
} from 'esbuild'
import { transform } from 'esbuild'
import type { RawSourceMap } from '@jridgewell/remapping'
import type { InternalModuleFormat, SourceMap } from 'rollup'
import type { TSConfckParseResult } from 'tsconfck'
import { TSConfckCache, TSConfckParseError, parse } from 'tsconfck'
import type { FSWatcher } from 'dep-types/chokidar'
import {
  combineSourcemaps,
  createDebugger,
  createFilter,
  ensureWatchedFile,
  generateCodeFrame,
} from '../utils'
import type { ViteDevServer } from '../server'
import type { ResolvedConfig } from '../config'
import type { Plugin } from '../plugin'
import { cleanUrl } from '../../shared/utils'

const debug = createDebugger('vite:esbuild')

// IIFE content looks like `var MyLib = function() {`.
// Spaces are removed and parameters are mangled when minified
const IIFE_BEGIN_RE =
  /(?:const|var)\s+\S+\s*=\s*function\([^()]*\)\s*\{\s*"use strict";/

const validExtensionRE = /\.\w+$/
const jsxExtensionsRE = /\.(?:j|t)sx\b/

// the final build should always support dynamic import and import.meta.
// if they need to be polyfilled, plugin-legacy should be used.
// plugin-legacy detects these two features when checking for modern code.
// Browser support: https://caniuse.com/es6-module-dynamic-import,mdn-javascript_operators_import_meta#:~:text=Feature%20summary
export const defaultEsbuildSupported = {
  'dynamic-import': true,
  'import-meta': true,
}

export interface ESBuildOptions extends TransformOptions {
  include?: string | RegExp | ReadonlyArray<string | RegExp>
  exclude?: string | RegExp | ReadonlyArray<string | RegExp>
  jsxInject?: string
  /**
   * This option is not respected. Use `build.minify` instead.
   */
  minify?: never
}

export type ESBuildTransformResult = Omit<TransformResult, 'map'> & {
  map: SourceMap
}

type TSConfigJSON = {
  extends?: string
  compilerOptions?: {
    alwaysStrict?: boolean
    experimentalDecorators?: boolean
    importsNotUsedAsValues?: 'remove' | 'preserve' | 'error'
    jsx?: 'preserve' | 'react' | 'react-jsx' | 'react-jsxdev'
    jsxFactory?: string
    jsxFragmentFactory?: string
    jsxImportSource?: string
    preserveValueImports?: boolean
    target?: string
    useDefineForClassFields?: boolean
    verbatimModuleSyntax?: boolean
  }
  [key: string]: any
}
type TSCompilerOptions = NonNullable<TSConfigJSON['compilerOptions']>

export async function transformWithEsbuild(
  code: string,
  filename: string,
  options?: TransformOptions,
  inMap?: object,
  config?: ResolvedConfig,
  watcher?: FSWatcher,
): Promise<ESBuildTransformResult> {
  let loader = options?.loader

  if (!loader) {
    // if the id ends with a valid ext, use it (e.g. vue blocks)
    // otherwise, cleanup the query before checking the ext
    const ext = path
      .extname(validExtensionRE.test(filename) ? filename : cleanUrl(filename))
      .slice(1)

    if (ext === 'cjs' || ext === 'mjs') {
      loader = 'js'
    } else if (ext === 'cts' || ext === 'mts') {
      loader = 'ts'
    } else {
      loader = ext as Loader
    }
  }

  let tsconfigRaw = options?.tsconfigRaw

  // if options provide tsconfigRaw in string, it takes highest precedence
  if (typeof tsconfigRaw !== 'string') {
    // these fields would affect the compilation result
    // https://esbuild.github.io/content-types/#tsconfig-json
    const meaningfulFields: Array<keyof TSCompilerOptions> = [
      'alwaysStrict',
      'experimentalDecorators',
      'importsNotUsedAsValues',
      'jsx',
      'jsxFactory',
      'jsxFragmentFactory',
      'jsxImportSource',
      'preserveValueImports',
      'target',
      'useDefineForClassFields',
      'verbatimModuleSyntax',
    ]
    const compilerOptionsForFile: TSCompilerOptions = {}
    if (loader === 'ts' || loader === 'tsx') {
      try {
        const { tsconfig: loadedTsconfig, tsconfigFile } =
          await loadTsconfigJsonForFile(filename, config)
        // tsconfig could be out of root, make sure it is watched on dev
        if (watcher && tsconfigFile && config) {
          ensureWatchedFile(watcher, tsconfigFile, config.root)
        }
        const loadedCompilerOptions = loadedTsconfig.compilerOptions ?? {}

        for (const field of meaningfulFields) {
          if (field in loadedCompilerOptions) {
            // @ts-expect-error TypeScript can't tell they are of the same type
            compilerOptionsForFile[field] = loadedCompilerOptions[field]
          }
        }
      } catch (e) {
        if (e instanceof TSConfckParseError) {
          // tsconfig could be out of root, make sure it is watched on dev
          if (watcher && e.tsconfigFile && config) {
            ensureWatchedFile(watcher, e.tsconfigFile, config.root)
          }
        }
        throw e
      }
    }

    const compilerOptions = {
      ...compilerOptionsForFile,
      ...tsconfigRaw?.compilerOptions,
    }

    // esbuild uses `useDefineForClassFields: true` when `tsconfig.compilerOptions.target` isn't declared
    // but we want `useDefineForClassFields: false` when `tsconfig.compilerOptions.target` isn't declared
    // to align with the TypeScript's behavior
    if (
      compilerOptions.useDefineForClassFields === undefined &&
      compilerOptions.target === undefined
    ) {
      compilerOptions.useDefineForClassFields = false
    }

    // esbuild uses tsconfig fields when both the normal options and tsconfig was set
    // but we want to prioritize the normal options
    if (options) {
      if (options.jsx) compilerOptions.jsx = undefined
      if (options.jsxFactory) compilerOptions.jsxFactory = undefined
      if (options.jsxFragment) compilerOptions.jsxFragmentFactory = undefined
      if (options.jsxImportSource) compilerOptions.jsxImportSource = undefined
    }

    tsconfigRaw = {
      ...tsconfigRaw,
      compilerOptions,
    }
  }

  const resolvedOptions: TransformOptions = {
    sourcemap: true,
    // ensure source file name contains full query
    sourcefile: filename,
    ...options,
    loader,
    tsconfigRaw,
  }

  // Some projects in the ecosystem are calling this function with an ESBuildOptions
  // object and esbuild throws an error for extra fields
  // @ts-expect-error include exists in ESBuildOptions
  delete resolvedOptions.include
  // @ts-expect-error exclude exists in ESBuildOptions
  delete resolvedOptions.exclude
  // @ts-expect-error jsxInject exists in ESBuildOptions
  delete resolvedOptions.jsxInject

  try {
    const result = await transform(code, resolvedOptions)
    let map: SourceMap
    if (inMap && resolvedOptions.sourcemap) {
      const nextMap = JSON.parse(result.map)
      nextMap.sourcesContent = []
      map = combineSourcemaps(filename, [
        nextMap as RawSourceMap,
        inMap as RawSourceMap,
      ]) as SourceMap
    } else {
      map =
        resolvedOptions.sourcemap && resolvedOptions.sourcemap !== 'inline'
          ? JSON.parse(result.map)
          : { mappings: '' }
    }
    return {
      ...result,
      map,
    }
  } catch (e: any) {
    debug?.(`esbuild error with options used: `, resolvedOptions)
    // patch error information
    if (e.errors) {
      e.frame = ''
      e.errors.forEach((m: Message) => {
        if (
          m.text === 'Experimental decorators are not currently enabled' ||
          m.text ===
            'Parameter decorators only work when experimental decorators are enabled'
        ) {
          m.text +=
            '. Vite 5 now uses esbuild 0.18 and you need to enable them by adding "experimentalDecorators": true in your "tsconfig.json" file.'
        }
        e.frame += `\n` + prettifyMessage(m, code)
      })
      e.loc = e.errors[0].location
    }
    throw e
  }
}

export function esbuildPlugin(config: ResolvedConfig): Plugin {
  const options = config.esbuild as ESBuildOptions
  const { jsxInject, include, exclude, ...esbuildTransformOptions } = options

  const filter = createFilter(include || /\.(m?ts|[jt]sx)$/, exclude || /\.js$/)

  // Remove optimization options for dev as we only need to transpile them,
  // and for build as the final optimization is in `buildEsbuildPlugin`
  const transformOptions: TransformOptions = {
    target: 'esnext',
    charset: 'utf8',
    ...esbuildTransformOptions,
    minify: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    treeShaking: false,
    // keepNames is not needed when minify is disabled.
    // Also transforming multiple times with keepNames enabled breaks
    // tree-shaking. (#9164)
    keepNames: false,
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildTransformOptions.supported,
    },
  }

  let server: ViteDevServer | undefined

  return {
    name: 'vite:esbuild',
    configureServer(_server) {
      server = _server
    },
    async transform(code, id) {
      if (filter(id) || filter(cleanUrl(id))) {
        const result = await transformWithEsbuild(
          code,
          id,
          transformOptions,
          undefined,
          config,
          server?.watcher,
        )
        if (result.warnings.length) {
          result.warnings.forEach((m) => {
            this.warn(prettifyMessage(m, code))
          })
        }
        if (jsxInject && jsxExtensionsRE.test(id)) {
          result.code = jsxInject + ';' + result.code
        }
        return {
          code: result.code,
          map: result.map,
        }
      }
    },
  }
}

const rollupToEsbuildFormatMap: Record<
  string,
  TransformOptions['format'] | undefined
> = {
  es: 'esm',
  cjs: 'cjs',

  // passing `var Lib = (() => {})()` to esbuild with format = "iife"
  // will turn it to `(() => { var Lib = (() => {})() })()`,
  // so we remove the format config to tell esbuild not doing this
  //
  // although esbuild doesn't change format, there is still possibility
  // that `{ treeShaking: true }` removes a top-level no-side-effect variable
  // like: `var Lib = 1`, which becomes `` after esbuild transforming,
  // but thankfully rollup does not do this optimization now
  iife: undefined,
}

export const buildEsbuildPlugin = (): Plugin => {
  return {
    name: 'vite:esbuild-transpile',
    applyToEnvironment(environment) {
      return environment.config.esbuild !== false
    },
    async renderChunk(code, chunk, opts) {
      // @ts-expect-error injected by @vitejs/plugin-legacy
      if (opts.__vite_skip_esbuild__) {
        return null
      }

      const config = this.environment.config
      const options = resolveEsbuildTranspileOptions(config, opts.format)

      if (!options) {
        return null
      }

      const res = await transformWithEsbuild(
        code,
        chunk.fileName,
        options,
        undefined,
        config,
      )

      if (config.build.lib) {
        // #7188, esbuild adds helpers out of the UMD and IIFE wrappers, and the
        // names are minified potentially causing collision with other globals.
        // We inject the helpers inside the wrappers.
        // e.g. turn:
        //    <esbuild helpers> (function(){ /*actual content/* })()
        // into:
        //    (function(){ <esbuild helpers> /*actual content/* })()
        // Not using regex because it's too hard to rule out performance issues like #8738 #8099 #10900 #14065
        // Instead, using plain string index manipulation (indexOf, slice) which is simple and performant
        // We don't need to create a MagicString here because both the helpers and
        // the headers don't modify the sourcemap
        const esbuildCode = res.code
        const contentIndex =
          opts.format === 'iife'
            ? Math.max(esbuildCode.search(IIFE_BEGIN_RE), 0)
            : opts.format === 'umd'
              ? esbuildCode.indexOf(`(function(`) // same for minified or not
              : 0
        if (contentIndex > 0) {
          const esbuildHelpers = esbuildCode.slice(0, contentIndex)
          res.code = esbuildCode
            .slice(contentIndex)
            .replace(`"use strict";`, `"use strict";` + esbuildHelpers)
        }
      }

      return res
    },
  }
}

export function resolveEsbuildTranspileOptions(
  config: ResolvedConfig,
  format: InternalModuleFormat,
): TransformOptions | null {
  const target = config.build.target
  const minify = config.build.minify === 'esbuild'

  if ((!target || target === 'esnext') && !minify) {
    return null
  }

  // Do not minify whitespace for ES lib output since that would remove
  // pure annotations and break tree-shaking
  // https://github.com/vuejs/core/issues/2860#issuecomment-926882793
  const isEsLibBuild = config.build.lib && format === 'es'
  const esbuildOptions = config.esbuild || {}

  const options: TransformOptions = {
    charset: 'utf8',
    ...esbuildOptions,
    loader: 'js',
    target: target || undefined,
    format: rollupToEsbuildFormatMap[format],
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildOptions.supported,
    },
  }

  // If no minify, disable all minify options
  if (!minify) {
    return {
      ...options,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: false,
      minifyWhitespace: false,
      treeShaking: false,
    }
  }

  // If user enable fine-grain minify options, minify with their options instead
  if (
    options.minifyIdentifiers != null ||
    options.minifySyntax != null ||
    options.minifyWhitespace != null
  ) {
    if (isEsLibBuild) {
      // Disable minify whitespace as it breaks tree-shaking
      return {
        ...options,
        minify: false,
        minifyIdentifiers: options.minifyIdentifiers ?? true,
        minifySyntax: options.minifySyntax ?? true,
        minifyWhitespace: false,
        treeShaking: true,
      }
    } else {
      return {
        ...options,
        minify: false,
        minifyIdentifiers: options.minifyIdentifiers ?? true,
        minifySyntax: options.minifySyntax ?? true,
        minifyWhitespace: options.minifyWhitespace ?? true,
        treeShaking: true,
      }
    }
  }

  // Else apply default minify options
  if (isEsLibBuild) {
    // Minify all except whitespace as it breaks tree-shaking
    return {
      ...options,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true,
    }
  } else {
    return {
      ...options,
      minify: true,
      treeShaking: true,
    }
  }
}

function prettifyMessage(m: Message, code: string): string {
  let res = colors.yellow(m.text)
  if (m.location) {
    res += `\n` + generateCodeFrame(code, m.location)
  }
  return res + `\n`
}

let globalTSConfckCache: TSConfckCache<TSConfckParseResult> | undefined
const tsconfckCacheMap = new WeakMap<
  ResolvedConfig,
  TSConfckCache<TSConfckParseResult>
>()

function getTSConfckCache(config?: ResolvedConfig) {
  if (!config) {
    return (globalTSConfckCache ??= new TSConfckCache<TSConfckParseResult>())
  }
  let cache = tsconfckCacheMap.get(config)
  if (!cache) {
    cache = new TSConfckCache<TSConfckParseResult>()
    tsconfckCacheMap.set(config, cache)
  }
  return cache
}

export async function loadTsconfigJsonForFile(
  filename: string,
  config?: ResolvedConfig,
): Promise<{ tsconfigFile: string; tsconfig: TSConfigJSON }> {
  const { tsconfig, tsconfigFile } = await parse(filename, {
    cache: getTSConfckCache(config),
    ignoreNodeModules: true,
  })
  return { tsconfigFile, tsconfig }
}

export async function reloadOnTsconfigChange(
  server: ViteDevServer,
  changedFile: string,
): Promise<void> {
  // any tsconfig.json that's added in the workspace could be closer to a code file than a previously cached one
  // any json file in the tsconfig cache could have been used to compile ts
  if (changedFile.endsWith('.json')) {
    const cache = getTSConfckCache(server.config)
    if (
      changedFile.endsWith('/tsconfig.json') ||
      cache.hasParseResult(changedFile)
    ) {
      server.config.logger.info(
        `changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure TypeScript is compiled with updated config values.`,
        { clear: server.config.clearScreen, timestamp: true },
      )

      // TODO: more finegrained invalidation than the nuclear option below

      // clear module graph to remove code compiled with outdated config
      for (const environment of Object.values(server.environments)) {
        environment.moduleGraph.invalidateAll()
      }

      // reset tsconfck cache so that recompile works with up2date configs
      cache.clear()

      // reload environments
      for (const environment of Object.values(server.environments)) {
        environment.hot.send({
          type: 'full-reload',
          path: '*',
        })
      }
    }
  }
}



================================================
FILE: packages/vite/src/node/plugins/importAnalysis.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import { performance } from 'node:perf_hooks'
import colors from 'picocolors'
import MagicString from 'magic-string'
import type {
  ParseError as EsModuleLexerParseError,
  ExportSpecifier,
  ImportSpecifier,
} from 'es-module-lexer'
import { init, parse as parseImports } from 'es-module-lexer'
import { parseAst } from 'rollup/parseAst'
import type { StaticImport } from 'mlly'
import { ESM_STATIC_IMPORT_RE, parseStaticImport } from 'mlly'
import { makeLegalIdentifier } from '@rollup/pluginutils'
import type { PartialResolvedId, RollupError } from 'rollup'
import type { Identifier, Literal } from 'estree'
import {
  CLIENT_DIR,
  CLIENT_PUBLIC_PATH,
  DEP_VERSION_RE,
  FS_PREFIX,
  SPECIAL_QUERY_RE,
} from '../constants'
import {
  debugHmr,
  handlePrunedModules,
  lexAcceptedHmrDeps,
  lexAcceptedHmrExports,
  normalizeHmrUrl,
} from '../server/hmr'
import {
  createDebugger,
  fsPathFromUrl,
  generateCodeFrame,
  getHash,
  injectQuery,
  isBuiltin,
  isCSSRequest,
  isDataUrl,
  isDefined,
  isExternalUrl,
  isInNodeModules,
  isJSRequest,
  joinUrlSegments,
  moduleListContains,
  normalizePath,
  prettifyUrl,
  removeImportQuery,
  removeTimestampQuery,
  stripBase,
  stripBomTag,
  timeFrom,
  transformStableResult,
  urlRE,
} from '../utils'
import { checkPublicFile } from '../publicDir'
import type { ResolvedConfig } from '../config'
import type { Plugin } from '../plugin'
import type { DevEnvironment } from '../server/environment'
import { shouldExternalize } from '../external'
import { optimizedDepNeedsInterop } from '../optimizer'
import {
  cleanUrl,
  unwrapId,
  withTrailingSlash,
  wrapId,
} from '../../shared/utils'
import type { TransformPluginContext } from '../server/pluginContainer'
import { throwOutdatedRequest } from './optimizedDeps'
import { isDirectCSSRequest } from './css'
import { browserExternalId } from './resolve'
import { serializeDefine } from './define'
import { WORKER_FILE_ID } from './worker'
import { getAliasPatternMatcher } from './preAlias'

const debug = createDebugger('vite:import-analysis')

const clientDir = normalizePath(CLIENT_DIR)

const skipRE = /\.(?:map|json)(?:$|\?)/
export const canSkipImportAnalysis = (id: string): boolean =>
  skipRE.test(id) || isDirectCSSRequest(id)

const optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/
const optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/

export const hasViteIgnoreRE = /\/\*\s*@vite-ignore\s*\*\//

const urlIsStringRE = /^(?:'.*'|".*"|`.*`)$/

const templateLiteralRE = /^\s*`(.*)`\s*$/

interface UrlPosition {
  url: string
  start: number
  end: number
}

export function isExplicitImportRequired(url: string): boolean {
  return !isJSRequest(url) && !isCSSRequest(url)
}

function normalizeResolvedIdToUrl(
  environment: DevEnvironment,
  url: string,
  resolved: PartialResolvedId,
): string {
  const root = environment.config.root
  const depsOptimizer = environment.depsOptimizer

  // normalize all imports into resolved URLs
  // e.g. `import 'foo'` -> `import '/@fs/.../node_modules/foo/index.js'`
  if (resolved.id.startsWith(withTrailingSlash(root))) {
    // in root: infer short absolute path from root
    url = resolved.id.slice(root.length)
  } else if (
    depsOptimizer?.isOptimizedDepFile(resolved.id) ||
    // vite-plugin-react isn't following the leading \0 virtual module convention.
    // This is a temporary hack to avoid expensive fs checks for React apps.
    // We'll remove this as soon we're able to fix the react plugins.
    (resolved.id !== '/@react-refresh' &&
      path.isAbsolute(resolved.id) &&
      fs.existsSync(cleanUrl(resolved.id)))
  ) {
    // an optimized deps may not yet exists in the filesystem, or
    // a regular file exists but is out of root: rewrite to absolute /@fs/ paths
    url = path.posix.join(FS_PREFIX, resolved.id)
  } else {
    url = resolved.id
  }

  // if the resolved id is not a valid browser import specifier,
  // prefix it to make it valid. We will strip this before feeding it
  // back into the transform pipeline
  if (url[0] !== '.' && url[0] !== '/') {
    url = wrapId(resolved.id)
  }

  return url
}

function extractImportedBindings(
  id: string,
  source: string,
  importSpec: ImportSpecifier,
  importedBindings: Map<string, Set<string>>,
) {
  let bindings = importedBindings.get(id)
  if (!bindings) {
    bindings = new Set<string>()
    importedBindings.set(id, bindings)
  }

  const isDynamic = importSpec.d > -1
  const isMeta = importSpec.d === -2
  if (isDynamic || isMeta) {
    // this basically means the module will be impacted by any change in its dep
    bindings.add('*')
    return
  }

  const exp = source.slice(importSpec.ss, importSpec.se)
  ESM_STATIC_IMPORT_RE.lastIndex = 0
  const match = ESM_STATIC_IMPORT_RE.exec(exp)
  if (!match) {
    return
  }

  const staticImport: StaticImport = {
    type: 'static',
    code: match[0],
    start: match.index,
    end: match.index + match[0].length,
    imports: match.groups!.imports,
    specifier: match.groups!.specifier,
  }
  const parsed = parseStaticImport(staticImport)
  if (parsed.namespacedImport) {
    bindings.add('*')
  }
  if (parsed.defaultImport) {
    bindings.add('default')
  }
  if (parsed.namedImports) {
    for (const name of Object.keys(parsed.namedImports)) {
      bindings.add(name)
    }
  }
}

/**
 * Dev-only plugin that lexes, resolves, rewrites and analyzes url imports.
 *
 * - Imports are resolved to ensure they exist on disk
 *
 * - Lexes HMR accept calls and updates import relationships in the module graph
 *
 * - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
 * absolute file paths, e.g.
 *
 *     ```js
 *     import 'foo'
 *     ```
 *     is rewritten to
 *     ```js
 *     import '/@fs//project/node_modules/foo/dist/foo.js'
 *     ```
 *
 * - CSS imports are appended with `.js` since both the js module and the actual
 * css (referenced via `<link>`) may go through the transform pipeline:
 *
 *     ```js
 *     import './style.css'
 *     ```
 *     is rewritten to
 *     ```js
 *     import './style.css.js'
 *     ```
 */
export function importAnalysisPlugin(config: ResolvedConfig): Plugin {
  const { root, base } = config
  const clientPublicPath = path.posix.join(base, CLIENT_PUBLIC_PATH)
  const enablePartialAccept = config.experimental.hmrPartialAccept
  const matchAlias = getAliasPatternMatcher(config.resolve.alias)

  let _env: string | undefined
  let _ssrEnv: string | undefined
  function getEnv(ssr: boolean) {
    if (!_ssrEnv || !_env) {
      const importMetaEnvKeys: Record<string, any> = {}
      const userDefineEnv: Record<string, any> = {}
      for (const key in config.env) {
        importMetaEnvKeys[key] = JSON.stringify(config.env[key])
      }
      for (const key in config.define) {
        // non-import.meta.env.* is handled in `clientInjection` plugin
        if (key.startsWith('import.meta.env.')) {
          userDefineEnv[key.slice(16)] = config.define[key]
        }
      }
      const env = `import.meta.env = ${serializeDefine({
        ...importMetaEnvKeys,
        SSR: '__vite_ssr__',
        ...userDefineEnv,
      })};`
      _ssrEnv = env.replace('__vite_ssr__', 'true')
      _env = env.replace('__vite_ssr__', 'false')
    }
    return ssr ? _ssrEnv : _env
  }

  return {
    name: 'vite:import-analysis',

    async transform(source, importer) {
      const environment = this.environment as DevEnvironment
      const ssr = environment.config.consumer === 'server'
      const moduleGraph = environment.moduleGraph

      if (canSkipImportAnalysis(importer)) {
        debug?.(colors.dim(`[skipped] ${prettifyUrl(importer, root)}`))
        return null
      }

      const msAtStart = debug ? performance.now() : 0
      await init
      let imports!: readonly ImportSpecifier[]
      let exports!: readonly ExportSpecifier[]
      source = stripBomTag(source)
      try {
        ;[imports, exports] = parseImports(source)
      } catch (_e: unknown) {
        const e = _e as EsModuleLexerParseError
        const { message, showCodeFrame } = createParseErrorInfo(
          importer,
          source,
        )
        this.error(message, showCodeFrame ? e.idx : undefined)
      }

      const depsOptimizer = environment.depsOptimizer

      // since we are already in the transform phase of the importer, it must
      // have been loaded so its entry is guaranteed in the module graph.
      const importerModule = moduleGraph.getModuleById(importer)
      if (!importerModule) {
        // This request is no longer valid. It could happen for optimized deps
        // requests. A full reload is going to request this id again.
        // Throwing an outdated error so we properly finish the request with a
        // 504 sent to the browser.
        throwOutdatedRequest(importer)
      }

      if (
        !imports.length &&
        !(this as unknown as TransformPluginContext)._addedImports
      ) {
        importerModule.isSelfAccepting = false
        debug?.(
          `${timeFrom(msAtStart)} ${colors.dim(
            `[no imports] ${prettifyUrl(importer, root)}`,
          )}`,
        )
        return source
      }

      let hasHMR = false
      let isSelfAccepting = false
      let hasEnv = false
      let needQueryInjectHelper = false
      let s: MagicString | undefined
      const str = () => s || (s = new MagicString(source))
      let isPartiallySelfAccepting = false
      const importedBindings = enablePartialAccept
        ? new Map<string, Set<string>>()
        : null
      const toAbsoluteUrl = (url: string) =>
        path.posix.resolve(path.posix.dirname(importerModule.url), url)

      const normalizeUrl = async (
        url: string,
        pos: number,
        forceSkipImportAnalysis: boolean = false,
      ): Promise<[string, string | null]> => {
        url = stripBase(url, base)

        let importerFile = importer

        if (
          depsOptimizer &&
          moduleListContains(depsOptimizer.options.exclude, url)
        ) {
          await depsOptimizer.scanProcessing

          // if the dependency encountered in the optimized file was excluded from the optimization
          // the dependency needs to be resolved starting from the original source location of the optimized file
          // because starting from node_modules/.vite will not find the dependency if it was not hoisted
          // (that is, if it is under node_modules directory in the package source of the optimized file)
          for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
            if (!optimizedModule.src) continue // Ignore chunks
            if (optimizedModule.file === importerModule.file) {
              importerFile = optimizedModule.src
            }
          }
        }

        const resolved = await this.resolve(url, importerFile).catch((e) => {
          if (e instanceof Error) {
            ;(e as RollupError).pos ??= pos
          }
          throw e
        })

        // NOTE: resolved.meta is undefined in dev
        if (!resolved || resolved.meta?.['vite:alias']?.noResolved) {
          // in ssr, we should let node handle the missing modules
          if (ssr) {
            return [url, null]
          }
          // fix#9534, prevent the importerModuleNode being stopped from propagating updates
          importerModule.isSelfAccepting = false
          moduleGraph._hasResolveFailedErrorModules.add(importerModule)
          return this.error(
            `Failed to resolve import "${url}" from "${normalizePath(
              path.relative(process.cwd(), importerFile),
            )}". Does the file exist?`,
            pos,
          )
        }

        if (isExternalUrl(resolved.id)) {
          return [resolved.id, resolved.id]
        }

        const isRelative = url[0] === '.'
        const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer)

        url = normalizeResolvedIdToUrl(environment, url, resolved)

        // make the URL browser-valid
        if (environment.config.consumer === 'client') {
          // mark non-js/css imports with `?import`
          if (isExplicitImportRequired(url)) {
            url = injectQuery(url, 'import')
          } else if (
            (isRelative || isSelfImport) &&
            !DEP_VERSION_RE.test(url)
          ) {
            // If the url isn't a request for a pre-bundled common chunk,
            // for relative js/css imports, or self-module virtual imports
            // (e.g. vue blocks), inherit importer's version query
            // do not do this for unknown type imports, otherwise the appended
            // query can break 3rd party plugin's extension checks.
            const versionMatch = DEP_VERSION_RE.exec(importer)
            if (versionMatch) {
              url = injectQuery(url, versionMatch[1])
            }
          }
        }

        try {
          // delay setting `isSelfAccepting` until the file is actually used (#7870)
          // We use an internal function to avoid resolving the url again
          const depModule = await moduleGraph._ensureEntryFromUrl(
            unwrapId(url),
            canSkipImportAnalysis(url) || forceSkipImportAnalysis,
            resolved,
          )
          // check if the dep has been hmr updated. If yes, we need to attach
          // its last updated timestamp to force the browser to fetch the most
          // up-to-date version of this module.
          if (
            environment.config.consumer === 'client' &&
            depModule.lastHMRTimestamp > 0
          ) {
            url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`)
          }
        } catch (e: any) {
          // it's possible that the dep fails to resolve (non-existent import)
          // attach location to the missing import
          e.pos = pos
          throw e
        }

        // prepend base
        if (!ssr) url = joinUrlSegments(base, url)

        return [url, resolved.id]
      }

      const orderedImportedUrls = new Array<string | undefined>(imports.length)
      const orderedAcceptedUrls = new Array<Set<UrlPosition> | undefined>(
        imports.length,
      )
      const orderedAcceptedExports = new Array<Set<string> | undefined>(
        imports.length,
      )

      await Promise.all(
        imports.map(async (importSpecifier, index) => {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex,
            a: attributeIndex,
          } = importSpecifier

          // #2083 User may use escape path,
          // so use imports[index].n to get the unescaped string
          let specifier = importSpecifier.n

          const rawUrl = source.slice(start, end)

          // check import.meta usage
          if (rawUrl === 'import.meta') {
            const prop = source.slice(end, end + 4)
            if (prop === '.hot') {
              hasHMR = true
              const endHot = end + 4 + (source[end + 4] === '?' ? 1 : 0)
              if (source.slice(endHot, endHot + 7) === '.accept') {
                // further analyze accepted modules
                if (source.slice(endHot, endHot + 14) === '.acceptExports') {
                  const importAcceptedExports = (orderedAcceptedExports[index] =
                    new Set<string>())
                  lexAcceptedHmrExports(
                    source,
                    source.indexOf('(', endHot + 14) + 1,
                    importAcceptedExports,
                  )
                  isPartiallySelfAccepting = true
                } else {
                  const importAcceptedUrls = (orderedAcceptedUrls[index] =
                    new Set<UrlPosition>())
                  if (
                    lexAcceptedHmrDeps(
                      source,
                      source.indexOf('(', endHot + 7) + 1,
                      importAcceptedUrls,
                    )
                  ) {
                    isSelfAccepting = true
                  }
                }
              }
            } else if (prop === '.env') {
              hasEnv = true
            }
            return
          } else if (templateLiteralRE.test(rawUrl)) {
            // If the import has backticks but isn't transformed as a glob import
            // (as there's nothing to glob), check if it's simply a plain string.
            // If so, we can replace the specifier as a plain string to prevent
            // an incorrect "cannot be analyzed" warning.
            if (!(rawUrl.includes('${') && rawUrl.includes('}'))) {
              specifier = rawUrl.replace(templateLiteralRE, '$1')
            }
          }

          const isDynamicImport = dynamicIndex > -1

          // strip import attributes as we can process them ourselves
          if (!isDynamicImport && attributeIndex > -1) {
            str().remove(end + 1, expEnd)
          }

          // static import or valid string in dynamic import
          // If resolvable, let's resolve it
          if (specifier !== undefined) {
            // skip external / data uri
            if (
              (isExternalUrl(specifier) && !specifier.startsWith('file://')) ||
              isDataUrl(specifier)
            ) {
              return
            }
            // skip ssr externals and builtins
            if (ssr && !matchAlias(specifier)) {
              if (shouldExternalize(environment, specifier, importer)) {
                return
              }
              if (isBuiltin(environment.config.resolve.builtins, specifier)) {
                return
              }
            }
            // skip client
            if (specifier === clientPublicPath) {
              return
            }

            // warn imports to non-asset /public files
            if (
              specifier[0] === '/' &&
              !(
                config.assetsInclude(cleanUrl(specifier)) ||
                urlRE.test(specifier)
              ) &&
              checkPublicFile(specifier, config)
            ) {
              throw new Error(
                `Cannot import non-asset file ${specifier} which is inside /public. ` +
                  `JS/CSS files inside /public are copied as-is on build and ` +
                  `can only be referenced via <script src> or <link href> in html. ` +
                  `If you want to get the URL of that file, use ${injectQuery(
                    specifier,
                    'url',
                  )} instead.`,
              )
            }

            // normalize
            let [url, resolvedId] = await normalizeUrl(specifier, start)
            resolvedId = resolvedId || url

            // record as safe modules
            // safeModulesPath should not include the base prefix.
            // See https://github.com/vitejs/vite/issues/9438#issuecomment-1465270409
            config.safeModulePaths.add(fsPathFromUrl(stripBase(url, base)))

            if (url !== specifier) {
              let rewriteDone = false
              if (
                depsOptimizer?.isOptimizedDepFile(resolvedId) &&
                !optimizedDepChunkRE.test(resolvedId)
              ) {
                // for optimized cjs deps, support named imports by rewriting named imports to const assignments.
                // internal optimized chunks don't need es interop and are excluded

                // The browserHash in resolvedId could be stale in which case there will be a full
                // page reload. We could return a 404 in that case but it is safe to return the request
                const file = cleanUrl(resolvedId) // Remove ?v={hash}

                const needsInterop = await optimizedDepNeedsInterop(
                  environment,
                  depsOptimizer.metadata,
                  file,
                )

                if (needsInterop === undefined) {
                  // Non-entry dynamic imports from dependencies will reach here as there isn't
                  // optimize info for them, but they don't need es interop. If the request isn't
                  // a dynamic import, then it is an internal Vite error
                  if (!optimizedDepDynamicRE.test(file)) {
                    config.logger.error(
                      colors.red(
                        `Vite Error, ${url} optimized info should be defined`,
                      ),
                    )
                  }
                } else if (needsInterop) {
                  debug?.(`${url} needs interop`)
                  interopNamedImports(
                    str(),
                    importSpecifier,
                    url,
                    index,
                    importer,
                    config,
                  )
                  rewriteDone = true
                }
              }
              // If source code imports builtin modules via named imports, the stub proxy export
              // would fail as it's `export default` only. Apply interop for builtin modules to
              // correctly throw the error message.
              else if (
                url.includes(browserExternalId) &&
                source.slice(expStart, start).includes('{')
              ) {
                interopNamedImports(
                  str(),
                  importSpecifier,
                  url,
                  index,
                  importer,
                  config,
                )
                rewriteDone = true
              }
              if (!rewriteDone) {
                const rewrittenUrl = JSON.stringify(url)
                const s = isDynamicImport ? start : start - 1
                const e = isDynamicImport ? end : end + 1
                str().overwrite(s, e, rewrittenUrl, {
                  contentOnly: true,
                })
              }
            }

            // record for HMR import chain analysis
            // make sure to unwrap and normalize away base
            const hmrUrl = unwrapId(stripBase(url, base))
            const isLocalImport = !isExternalUrl(hmrUrl) && !isDataUrl(hmrUrl)
            if (isLocalImport) {
              orderedImportedUrls[index] = hmrUrl
            }

            if (enablePartialAccept && importedBindings) {
              extractImportedBindings(
                resolvedId,
                source,
                importSpecifier,
                importedBindings,
              )
            }

            if (
              !isDynamicImport &&
              isLocalImport &&
              environment.config.dev.preTransformRequests
            ) {
              // pre-transform known direct imports
              // These requests will also be registered in transformRequest to be awaited
              // by the deps optimizer
              const url = removeImportQuery(hmrUrl)
              environment.warmupRequest(url)
            }
          } else if (!importer.startsWith(withTrailingSlash(clientDir))) {
            if (!isInNodeModules(importer)) {
              // check @vite-ignore which suppresses dynamic import warning
              const hasViteIgnore = hasViteIgnoreRE.test(
                // complete expression inside parens
                source.slice(dynamicIndex + 1, end),
              )
              if (!hasViteIgnore) {
                this.warn(
                  `\n` +
                    colors.cyan(importerModule.file) +
                    `\n` +
                    colors.reset(generateCodeFrame(source, start, end)) +
                    colors.yellow(
                      `\nThe above dynamic import cannot be analyzed by Vite.\n` +
                        `See ${colors.blue(
                          `https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`,
                        )} ` +
                        `for supported dynamic import formats. ` +
                        `If this is intended to be left as-is, you can use the ` +
                        `/* @vite-ignore */ comment inside the import() call to suppress this warning.\n`,
                    ),
                )
              }
            }

            if (!ssr) {
              if (
                !urlIsStringRE.test(rawUrl) ||
                isExplicitImportRequired(rawUrl.slice(1, -1))
              ) {
                needQueryInjectHelper = true
                str().overwrite(
                  start,
                  end,
                  `__vite__injectQuery(${rawUrl}, 'import')`,
                  { contentOnly: true },
                )
              }
            }
          }
        }),
      )

      const _orderedImportedUrls = orderedImportedUrls.filter(isDefined)
      const importedUrls = new Set(_orderedImportedUrls)
      // `importedUrls` will be mixed with watched files for the module graph,
      // `staticImportedUrls` will only contain the static top-level imports and
      // dynamic imports
      const staticImportedUrls = new Set(
        _orderedImportedUrls.map((url) => removeTimestampQuery(url)),
      )
      const acceptedUrls = mergeAcceptedUrls(orderedAcceptedUrls)
      const acceptedExports = mergeAcceptedUrls(orderedAcceptedExports)

      // While we always expect to work with ESM, a classic worker is the only
      // case where it's not ESM and we need to avoid injecting ESM-specific code
      const isClassicWorker =
        importer.includes(WORKER_FILE_ID) && importer.includes('type=classic')

      if (hasEnv && !isClassicWorker) {
        // inject import.meta.env
        str().prepend(getEnv(ssr))
      }

      if (hasHMR && !ssr && !isClassicWorker) {
        debugHmr?.(
          `${
            isSelfAccepting
              ? `[self-accepts]`
              : isPartiallySelfAccepting
                ? `[accepts-exports]`
                : acceptedUrls.size
                  ? `[accepts-deps]`
                  : `[detected api usage]`
          } ${prettifyUrl(importer, root)}`,
        )
        // inject hot context
        str().prepend(
          `import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";` +
            `import.meta.hot = __vite__createHotContext(${JSON.stringify(
              normalizeHmrUrl(importerModule.url),
            )});`,
        )
      }

      if (needQueryInjectHelper) {
        if (isClassicWorker) {
          str().append('\n' + __vite__injectQuery.toString())
        } else {
          str().prepend(
            `import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`,
          )
        }
      }

      // normalize and rewrite accepted urls
      const normalizedAcceptedUrls = new Set<string>()
      for (const { url, start, end } of acceptedUrls) {
        let [normalized, resolvedId] = await normalizeUrl(url, start).catch(
          () => [],
        )
        if (resolvedId) {
          const mod = moduleGraph.getModuleById(resolvedId)
          if (!mod) {
            this.error(
              `module was not found for ${JSON.stringify(resolvedId)}`,
              start,
            )
            return
          }
          normalized = mod.url
        } else {
          try {
            // this fallback is for backward compat and will be removed in Vite 7
            const [resolved] = await moduleGraph.resolveUrl(toAbsoluteUrl(url))
            normalized = resolved
            if (resolved) {
              this.warn({
                message:
                  `Failed to resolve ${JSON.stringify(url)} from ${importer}.` +
                  ' An id should be written. Did you pass a URL?',
                pos: start,
              })
            }
          } catch {
            this.error(`Failed to resolve ${JSON.stringify(url)}`, start)
            return
          }
        }
        normalizedAcceptedUrls.add(normalized)
        const hmrAccept = normalizeHmrUrl(normalized)
        str().overwrite(start, end, JSON.stringify(hmrAccept), {
          contentOnly: true,
        })
      }

      // update the module graph for HMR analysis.
      // node CSS imports does its own graph update in the css-analysis plugin so we
      // only handle js graph updates here.
      // note that we want to handle .css?raw and .css?url here
      if (!isCSSRequest(importer) || SPECIAL_QUERY_RE.test(importer)) {
        // attached by pluginContainer.addWatchFile
        const pluginImports = (this as unknown as TransformPluginContext)
          ._addedImports
        if (pluginImports) {
          ;(
            await Promise.all(
              [...pluginImports].map((id) => normalizeUrl(id, 0, true)),
            )
          ).forEach(([url]) => importedUrls.add(stripBase(url, base)))
        }
        // HMR transforms are no-ops in SSR, so an `accept` call will
        // never be injected. Avoid updating the `isSelfAccepting`
        // property for our module node in that case.
        if (ssr && importerModule.isSelfAccepting) {
          isSelfAccepting = true
        }
        // a partially accepted module that accepts all its exports
        // behaves like a self-accepted module in practice
        if (
          !isSelfAccepting &&
          isPartiallySelfAccepting &&
          acceptedExports.size >= exports.length &&
          exports.every((e) => acceptedExports.has(e.n))
        ) {
          isSelfAccepting = true
        }
        const prunedImports = await moduleGraph.updateModuleInfo(
          importerModule,
          importedUrls,
          importedBindings,
          normalizedAcceptedUrls,
          isPartiallySelfAccepting ? acceptedExports : null,
          isSelfAccepting,
          staticImportedUrls,
        )
        if (hasHMR && prunedImports) {
          handlePrunedModules(prunedImports, environment)
        }
      }

      debug?.(
        `${timeFrom(msAtStart)} ${colors.dim(
          `[${importedUrls.size} imports rewritten] ${prettifyUrl(
            importer,
            root,
          )}`,
        )}`,
      )

      if (s) {
        return transformStableResult(s, importer, config)
      } else {
        return source
      }
    },
  }
}

function mergeAcceptedUrls<T>(orderedUrls: Array<Set<T> | undefined>) {
  const acceptedUrls = new Set<T>()
  for (const urls of orderedUrls) {
    if (!urls) continue
    for (const url of urls) acceptedUrls.add(url)
  }
  return acceptedUrls
}

export function createParseErrorInfo(
  importer: string,
  source: string,
): { message: string; showCodeFrame: boolean } {
  const isVue = importer.endsWith('.vue')
  const isJsx = importer.endsWith('.jsx') || importer.endsWith('.tsx')
  const maybeJSX = !isVue && isJSRequest(importer)
  const probablyBinary = source.includes(
    '\ufffd' /* unicode replacement character */,
  )

  const msg = isVue
    ? `Install @vitejs/plugin-vue to handle .vue files.`
    : maybeJSX
      ? isJsx
        ? `If you use tsconfig.json, make sure to not set jsx to preserve.`
        : `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.`
      : `You may need to install appropriate plugins to handle the ${path.extname(
          importer,
        )} file format, or if it's an asset, add "**/*${path.extname(
          importer,
        )}" to \`assetsInclude\` in your configuration.`

  return {
    message:
      `Failed to parse source for import analysis because the content ` +
      `contains invalid JS syntax. ` +
      msg,
    showCodeFrame: !probablyBinary,
  }
}

const interopHelper = (m: any) =>
  m?.__esModule
    ? m
    : {
        ...((typeof m === 'object' && !Array.isArray(m)) ||
        typeof m === 'function'
          ? m
          : {}),
        default: m,
      }
const interopHelperStr = interopHelper.toString().replaceAll('\n', '')

export function interopNamedImports(
  str: MagicString,
  importSpecifier: ImportSpecifier,
  rewrittenUrl: string,
  importIndex: number,
  importer: string,
  config: ResolvedConfig,
): void {
  const source = str.original
  const {
    s: start,
    e: end,
    ss: expStart,
    se: expEnd,
    d: dynamicIndex,
  } = importSpecifier
  const exp = source.slice(expStart, expEnd)
  if (dynamicIndex > -1) {
    // rewrite `import('package')` to expose the default directly
    str.overwrite(
      expStart,
      expEnd,
      `import('${rewrittenUrl}').then(m => (${interopHelperStr})(m.default))` +
        getLineBreaks(exp),
      { contentOnly: true },
    )
  } else {
    const rawUrl = source.slice(start, end)
    const rewritten = transformCjsImport(
      exp,
      rewrittenUrl,
      rawUrl,
      importIndex,
      importer,
      config,
    )
    if (rewritten) {
      str.overwrite(expStart, expEnd, rewritten + getLineBreaks(exp), {
        contentOnly: true,
      })
    } else {
      // #1439 export * from '...'
      str.overwrite(
        start,
        end,
        rewrittenUrl + getLineBreaks(source.slice(start, end)),
        {
          contentOnly: true,
        },
      )
    }
  }
}

// get line breaks to preserve line count for not breaking source maps
function getLineBreaks(str: string) {
  return str.includes('\n') ? '\n'.repeat(str.split('\n').length - 1) : ''
}

type ImportNameSpecifier = { importedName: string; localName: string }

/**
 * Detect import statements to a known optimized CJS dependency and provide
 * ES named imports interop. We do this by rewriting named imports to a variable
 * assignment to the corresponding property on the `module.exports` of the cjs
 * module. Note this doesn't support dynamic re-assignments from within the cjs
 * module.
 *
 * Note that es-module-lexer treats `export * from '...'` as an import as well,
 * so, we may encounter ExportAllDeclaration here, in which case `undefined`
 * will be returned.
 *
 * Credits \@csr632 via #837
 */
export function transformCjsImport(
  importExp: string,
  url: string,
  rawUrl: string,
  importIndex: number,
  importer: string,
  config: ResolvedConfig,
): string | undefined {
  const node = parseAst(importExp).body[0]

  // `export * from '...'` may cause unexpected problem, so give it a warning
  if (
    config.command === 'serve' &&
    node.type === 'ExportAllDeclaration' &&
    !node.exported
  ) {
    config.logger.warn(
      colors.yellow(
        `\nUnable to interop \`${importExp}\` in ${importer}, this may lose module exports. Please export "${rawUrl}" as ESM or use named exports instead, e.g. \`export { A, B } from "${rawUrl}"\``,
      ),
    )
  } else if (
    node.type === 'ImportDeclaration' ||
    node.type === 'ExportNamedDeclaration'
  ) {
    if (!node.specifiers.length) {
      return `import "${url}"`
    }

    const importNames: ImportNameSpecifier[] = []
    const exportNames: string[] = []
    let defaultExports: string = ''
    for (const spec of node.specifiers) {
      if (spec.type === 'ImportSpecifier') {
        const importedName = getIdentifierNameOrLiteralValue(
          spec.imported,
        ) as string
        const localName = spec.local.name
        importNames.push({ importedName, localName })
      } else if (spec.type === 'ImportDefaultSpecifier') {
        importNames.push({
          importedName: 'default',
          localName: spec.local.name,
        })
      } else if (spec.type === 'ImportNamespaceSpecifier') {
        importNames.push({ importedName: '*', localName: spec.local.name })
      } else if (spec.type === 'ExportSpecifier') {
        // for ExportSpecifier, local name is same as imported name
        // prefix the variable name to avoid clashing with other local variables
        const importedName = getIdentifierNameOrLiteralValue(
          spec.local,
        ) as string
        // we want to specify exported name as variable and re-export it
        const exportedName = getIdentifierNameOrLiteralValue(
          spec.exported,
        ) as string
        if (exportedName === 'default') {
          defaultExports = makeLegalIdentifier(
            `__vite__cjsExportDefault_${importIndex}`,
          )
          importNames.push({ importedName, localName: defaultExports })
        } else {
          const localName = `__vite__cjsExport${
            spec.exported.type === 'Literal'
              ? `L_${getHash(spec.exported.value as string)}`
              : 'I_' + spec.exported.name
          }`
          importNames.push({ importedName, localName })
          exportNames.push(
            `${localName} as ${spec.exported.type === 'Literal' ? JSON.stringify(exportedName) : exportedName}`,
          )
        }
      }
    }

    // If there is multiple import for same id in one file,
    // importIndex will prevent the cjsModuleName to be duplicate
    const cjsModuleName = makeLegalIdentifier(
      `__vite__cjsImport${importIndex}_${rawUrl}`,
    )
    const lines: string[] = [`import ${cjsModuleName} from "${url}"`]
    importNames.forEach(({ importedName, localName }) => {
      if (importedName === '*') {
        lines.push(
          `const ${localName} = (${interopHelperStr})(${cjsModuleName})`,
        )
      } else if (importedName === 'default') {
        lines.push(
          `const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`,
        )
      } else {
        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`)
      }
    })
    if (defaultExports) {
      lines.push(`export default ${defaultExports}`)
    }
    if (exportNames.length) {
      lines.push(`export { ${exportNames.join(', ')} }`)
    }

    return lines.join('; ')
  }
}

function getIdentifierNameOrLiteralValue(node: Identifier | Literal) {
  return node.type === 'Identifier' ? node.name : node.value
}

// Copied from `client/client.ts`. Only needed so we can inline inject this function for classic workers.
function __vite__injectQuery(url: string, queryToInject: string): string {
  // skip urls that won't be handled by vite
  if (url[0] !== '.' && url[0] !== '/') {
    return url
  }

  // can't use pathname from URL since it may be relative like ../
  const pathname = url.replace(/[?#].*$/, '')
  const { search, hash } = new URL(url, 'http://vite.dev')

  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${
    hash || ''
  }`
}



================================================
FILE: packages/vite/src/node/plugins/importAnalysisBuild.ts
================================================
import path from 'node:path'
import MagicString from 'magic-string'
import type {
  ParseError as EsModuleLexerParseError,
  ImportSpecifier,
} from 'es-module-lexer'
import { init, parse as parseImports } from 'es-module-lexer'
import type { SourceMap } from 'rollup'
import type { RawSourceMap } from '@jridgewell/remapping'
import convertSourceMap from 'convert-source-map'
import { exactRegex } from '@rolldown/pluginutils'
import { combineSourcemaps, generateCodeFrame, numberToPos } from '../utils'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import { toOutputFilePathInJS } from '../build'
import { genSourceMapUrl } from '../server/sourcemap'
import type { PartialEnvironment } from '../baseEnvironment'
import { removedPureCssFilesCache } from './css'
import { createParseErrorInfo } from './importAnalysis'

type FileDep = {
  url: string
  runtime: boolean
}

type VitePreloadErrorEvent = Event & { payload: Error }

/**
 * A flag for injected helpers. This flag will be set to `false` if the output
 * target is not native es - so that injected helper logic can be conditionally
 * dropped.
 */
export const isModernFlag = `__VITE_IS_MODERN__`
export const preloadMethod = `__vitePreload`
export const preloadMarker = `__VITE_PRELOAD__`
export const preloadBaseMarker = `__VITE_PRELOAD_BASE__`

export const preloadHelperId = '\0vite/preload-helper.js'
const preloadMarkerRE = new RegExp(preloadMarker, 'g')

const dynamicImportPrefixRE = /import\s*\(/

const dynamicImportTreeshakenRE =
  /((?:\bconst\s+|\blet\s+|\bvar\s+|,\s*)(\{[^{}.=]+\})\s*=\s*await\s+import\([^)]+\))(?=\s*(?:$|[^[.]))|(\(\s*await\s+import\([^)]+\)\s*\)(\??\.[\w$]+))|\bimport\([^)]+\)(\s*\.then\(\s*(?:function\s*)?\(\s*\{([^{}.=]+)\}\))/g

function toRelativePath(filename: string, importer: string) {
  const relPath = path.posix.relative(path.posix.dirname(importer), filename)
  return relPath[0] === '.' ? relPath : `./${relPath}`
}

function indexOfMatchInSlice(
  str: string,
  reg: RegExp,
  pos: number = 0,
): number {
  reg.lastIndex = pos
  const result = reg.exec(str)
  return result?.index ?? -1
}

/**
 * Helper for preloading CSS and direct imports of async chunks in parallel to
 * the async chunk itself.
 */

function detectScriptRel() {
  const relList =
    typeof document !== 'undefined' && document.createElement('link').relList
  return relList && relList.supports && relList.supports('modulepreload')
    ? 'modulepreload'
    : 'preload'
}

declare const scriptRel: string
declare const seen: Record<string, boolean>
function preload(
  baseModule: () => Promise<unknown>,
  deps?: string[],
  importerUrl?: string,
) {
  let promise: Promise<PromiseSettledResult<unknown>[] | void> =
    Promise.resolve()
  // @ts-expect-error __VITE_IS_MODERN__ will be replaced with boolean later
  if (__VITE_IS_MODERN__ && deps && deps.length > 0) {
    const links = document.getElementsByTagName('link')
    const cspNonceMeta = document.querySelector<HTMLMetaElement>(
      'meta[property=csp-nonce]',
    )
    // `.nonce` should be used to get along with nonce hiding (https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce#accessing_nonces_and_nonce_hiding)
    // Firefox 67-74 uses modern chunks and supports CSP nonce, but does not support `.nonce`
    // in that case fallback to getAttribute
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute('nonce')

    // Promise.allSettled is not supported by Chrome 64-75, Firefox 67-70, Safari 11.1-12.1
    function allSettled<T>(
      promises: Array<T | PromiseLike<T>>,
    ): Promise<PromiseSettledResult<T>[]> {
      return Promise.all(
        promises.map((p) =>
          Promise.resolve(p).then(
            (value: T) => ({ status: 'fulfilled' as const, value }),
            (reason: unknown) => ({ status: 'rejected' as const, reason }),
          ),
        ),
      )
    }

    promise = allSettled(
      deps.map((dep) => {
        // @ts-expect-error assetsURL is declared before preload.toString()
        dep = assetsURL(dep, importerUrl)
        if (dep in seen) return
        seen[dep] = true
        const isCss = dep.endsWith('.css')
        const cssSelector = isCss ? '[rel="stylesheet"]' : ''
        const isBaseRelative = !!importerUrl

        // check if the file is already preloaded by SSR markup
        if (isBaseRelative) {
          // When isBaseRelative is true then we have `importerUrl` and `dep` is
          // already converted to an absolute URL by the `assetsURL` function
          for (let i = links.length - 1; i >= 0; i--) {
            const link = links[i]
            // The `links[i].href` is an absolute URL thanks to browser doing the work
            // for us. See https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes:idl-domstring-5
            if (link.href === dep && (!isCss || link.rel === 'stylesheet')) {
              return
            }
          }
        } else if (
          document.querySelector(`link[href="${dep}"]${cssSelector}`)
        ) {
          return
        }

        const link = document.createElement('link')
        link.rel = isCss ? 'stylesheet' : scriptRel
        if (!isCss) {
          link.as = 'script'
        }
        link.crossOrigin = ''
        link.href = dep
        if (cspNonce) {
          link.setAttribute('nonce', cspNonce)
        }
        document.head.appendChild(link)
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener('load', res)
            link.addEventListener('error', () =>
              rej(new Error(`Unable to preload CSS for ${dep}`)),
            )
          })
        }
      }),
    )
  }

  function handlePreloadError(err: Error) {
    const e = new Event('vite:preloadError', {
      cancelable: true,
    }) as VitePreloadErrorEvent
    e.payload = err
    window.dispatchEvent(e)
    if (!e.defaultPrevented) {
      throw err
    }
  }

  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== 'rejected') continue
      handlePreloadError(item.reason)
    }
    return baseModule().catch(handlePreloadError)
  })
}

function getPreloadCode(
  environment: PartialEnvironment,
  renderBuiltUrlBoolean: boolean,
  isRelativeBase: boolean,
) {
  const { modulePreload } = environment.config.build

  const scriptRel =
    modulePreload && modulePreload.polyfill
      ? `'modulepreload'`
      : `/* @__PURE__ */ (${detectScriptRel.toString()})()`

  // There are two different cases for the preload list format in __vitePreload
  //
  // __vitePreload(() => import(asyncChunk), [ ...deps... ])
  //
  // This is maintained to keep backwards compatibility as some users developed plugins
  // using regex over this list to workaround the fact that module preload wasn't
  // configurable.
  const assetsURL =
    renderBuiltUrlBoolean || isRelativeBase
      ? // If `experimental.renderBuiltUrl` is used, the dependencies might be relative to the current chunk.
        // If relative base is used, the dependencies are relative to the current chunk.
        // The importerUrl is passed as third parameter to __vitePreload in this case
        `function(dep, importerUrl) { return new URL(dep, importerUrl).href }`
      : // If the base isn't relative, then the deps are relative to the projects `outDir` and the base
        // is appended inside __vitePreload too.
        `function(dep) { return ${JSON.stringify(environment.config.base)}+dep }`
  const preloadCode = `const scriptRel = ${scriptRel};const assetsURL = ${assetsURL};const seen = {};export const ${preloadMethod} = ${preload.toString()}`
  return preloadCode
}

/**
 * Build only. During serve this is performed as part of ./importAnalysis.
 */
export function buildImportAnalysisPlugin(config: ResolvedConfig): Plugin {
  const getInsertPreload = (environment: PartialEnvironment) =>
    environment.config.consumer === 'client' &&
    !config.isWorker &&
    !config.build.lib

  const renderBuiltUrl = config.experimental.renderBuiltUrl
  const isRelativeBase = config.base === './' || config.base === ''

  return {
    name: 'vite:build-import-analysis',
    resolveId: {
      filter: { id: exactRegex(preloadHelperId) },
      handler(id) {
        return id
      },
    },

    load: {
      filter: { id: exactRegex(preloadHelperId) },
      handler(_id) {
        const preloadCode = getPreloadCode(
          this.environment,
          !!renderBuiltUrl,
          isRelativeBase,
        )
        return { code: preloadCode, moduleSideEffects: false }
      },
    },

    transform: {
      filter: { code: dynamicImportPrefixRE },
      async handler(source, importer) {
        await init

        let imports: readonly ImportSpecifier[] = []
        try {
          imports = parseImports(source)[0]
        } catch (_e: unknown) {
          const e = _e as EsModuleLexerParseError
          const { message, showCodeFrame } = createParseErrorInfo(
            importer,
            source,
          )
          this.error(message, showCodeFrame ? e.idx : undefined)
        }

        if (!imports.length) {
          return null
        }

        const insertPreload = getInsertPreload(this.environment)
        // when wrapping dynamic imports with a preload helper, Rollup is unable to analyze the
        // accessed variables for treeshaking. This below tries to match common accessed syntax
        // to "copy" it over to the dynamic import wrapped by the preload helper.
        const dynamicImports: Record<
          number,
          { declaration?: string; names?: string }
        > = {}

        if (insertPreload) {
          let match
          while ((match = dynamicImportTreeshakenRE.exec(source))) {
            /* handle `const {foo} = await import('foo')`
             *
             * match[1]: `const {foo} = await import('foo')`
             * match[2]: `{foo}`
             * import end: `const {foo} = await import('foo')_`
             *                                               ^
             */
            if (match[1]) {
              dynamicImports[dynamicImportTreeshakenRE.lastIndex] = {
                declaration: `const ${match[2]}`,
                names: match[2]?.trim(),
              }
              continue
            }

            /* handle `(await import('foo')).foo`
             *
             * match[3]: `(await import('foo')).foo`
             * match[4]: `.foo`
             * import end: `(await import('foo'))`
             *                                  ^
             */
            if (match[3]) {
              let names = /\.([^.?]+)/.exec(match[4])?.[1] || ''
              // avoid `default` keyword error
              if (names === 'default') {
                names = 'default: __vite_default__'
              }
              dynamicImports[
                dynamicImportTreeshakenRE.lastIndex - match[4]?.length - 1
              ] = { declaration: `const {${names}}`, names: `{ ${names} }` }
              continue
            }

            /* handle `import('foo').then(({foo})=>{})`
             *
             * match[5]: `.then(({foo})`
             * match[6]: `foo`
             * import end: `import('foo').`
             *                           ^
             */
            const names = match[6]?.trim()
            dynamicImports[
              dynamicImportTreeshakenRE.lastIndex - match[5]?.length
            ] = { declaration: `const {${names}}`, names: `{ ${names} }` }
          }
        }

        let s: MagicString | undefined
        const str = () => s || (s = new MagicString(source))
        let needPreloadHelper = false

        for (let index = 0; index < imports.length; index++) {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex,
            a: attributeIndex,
          } = imports[index]

          const isDynamicImport = dynamicIndex > -1

          // strip import attributes as we can process them ourselves
          if (!isDynamicImport && attributeIndex > -1) {
            str().remove(end + 1, expEnd)
          }

          if (
            isDynamicImport &&
            insertPreload &&
            // Only preload static urls
            (source[start] === '"' ||
              source[start] === "'" ||
              source[start] === '`')
          ) {
            needPreloadHelper = true
            const { declaration, names } = dynamicImports[expEnd] || {}
            if (names) {
              /* transform `const {foo} = await import('foo')`
               * to `const {foo} = await __vitePreload(async () => { const {foo} = await import('foo');return {foo}}, ...)`
               *
               * transform `import('foo').then(({foo})=>{})`
               * to `__vitePreload(async () => { const {foo} = await import('foo');return { foo }},...).then(({foo})=>{})`
               *
               * transform `(await import('foo')).foo`
               * to `__vitePreload(async () => { const {foo} = (await import('foo')).foo; return { foo }},...)).foo`
               */
              str().prependLeft(
                expStart,
                `${preloadMethod}(async () => { ${declaration} = await `,
              )
              str().appendRight(expEnd, `;return ${names}}`)
            } else {
              str().prependLeft(expStart, `${preloadMethod}(() => `)
            }

            str().appendRight(
              expEnd,
              `,${isModernFlag}?${preloadMarker}:void 0${
                renderBuiltUrl || isRelativeBase ? ',import.meta.url' : ''
              })`,
            )
          }
        }

        if (
          needPreloadHelper &&
          insertPreload &&
          !source.includes(`const ${preloadMethod} =`)
        ) {
          str().prepend(
            `import { ${preloadMethod} } from "${preloadHelperId}";`,
          )
        }

        if (s) {
          return {
            code: s.toString(),
            map: this.environment.config.build.sourcemap
              ? s.generateMap({ hires: 'boundary' })
              : null,
          }
        }
      },
    },

    renderChunk(code, _, { format }) {
      // make sure we only perform the preload logic in modern builds.
      if (code.indexOf(isModernFlag) > -1) {
        const re = new RegExp(isModernFlag, 'g')
        const isModern = String(format === 'es')
        const isModernWithPadding =
          isModern + ' '.repeat(isModernFlag.length - isModern.length)
        return {
          code: code.replace(re, isModernWithPadding),
          map: null,
        }
      }
      return null
    },

    generateBundle({ format }, bundle) {
      if (format !== 'es') {
        return
      }

      // If preload is not enabled, we parse through each imports and remove any imports to pure CSS chunks
      // as they are removed from the bundle
      if (!getInsertPreload(this.environment)) {
        const removedPureCssFiles = removedPureCssFilesCache.get(config)
        if (removedPureCssFiles && removedPureCssFiles.size > 0) {
          for (const file in bundle) {
            const chunk = bundle[file]
            if (chunk.type === 'chunk' && chunk.code.includes('import')) {
              const code = chunk.code
              let imports!: ImportSpecifier[]
              try {
                imports = parseImports(code)[0].filter((i) => i.d > -1)
              } catch (e: any) {
                const loc = numberToPos(code, e.idx)
                this.error({
                  name: e.name,
                  message: e.message,
                  stack: e.stack,
                  cause: e.cause,
                  pos: e.idx,
                  loc: { ...loc, file: chunk.fileName },
                  frame: generateCodeFrame(code, loc),
                })
              }

              for (const imp of imports) {
                const {
                  n: name,
                  s: start,
                  e: end,
                  ss: expStart,
                  se: expEnd,
                } = imp
                let url = name
                if (!url) {
                  const rawUrl = code.slice(start, end)
                  if (rawUrl[0] === `"` && rawUrl.endsWith(`"`))
                    url = rawUrl.slice(1, -1)
                }
                if (!url) continue

                const normalizedFile = path.posix.join(
                  path.posix.dirname(chunk.fileName),
                  url,
                )
                if (removedPureCssFiles.has(normalizedFile)) {
                  // remove with Promise.resolve({}) while preserving source map location
                  chunk.code =
                    chunk.code.slice(0, expStart) +
                    `Promise.resolve({${''.padEnd(expEnd - expStart - 19, ' ')}})` +
                    chunk.code.slice(expEnd)
                }
              }
            }
          }
        }
        return
      }
      const buildSourcemap = this.environment.config.build.sourcemap
      const { modulePreload } = this.environment.config.build

      for (const file in bundle) {
        const chunk = bundle[file]
        // can't use chunk.dynamicImports.length here since some modules e.g.
        // dynamic import to constant json may get inlined.
        if (chunk.type === 'chunk' && chunk.code.indexOf(preloadMarker) > -1) {
          const code = chunk.code
          let imports!: ImportSpecifier[]
          try {
            imports = parseImports(code)[0].filter((i) => i.d > -1)
          } catch (e: any) {
            const loc = numberToPos(code, e.idx)
            this.error({
              name: e.name,
              message: e.message,
              stack: e.stack,
              cause: e.cause,
              pos: e.idx,
              loc: { ...loc, file: chunk.fileName },
              frame: generateCodeFrame(code, loc),
            })
          }

          const s = new MagicString(code)
          const rewroteMarkerStartPos = new Set() // position of the leading double quote

          const fileDeps: FileDep[] = []
          const addFileDep = (
            url: string,
            runtime: boolean = false,
          ): number => {
            const index = fileDeps.findIndex((dep) => dep.url === url)
            if (index === -1) {
              return fileDeps.push({ url, runtime }) - 1
            } else {
              return index
            }
          }

          if (imports.length) {
            for (let index = 0; index < imports.length; index++) {
              // To handle escape sequences in specifier strings, the .n field will be provided where possible.
              const {
                n: name,
                s: start,
                e: end,
                ss: expStart,
                se: expEnd,
              } = imports[index]
              // check the chunk being imported
              let url = name
              if (!url) {
                const rawUrl = code.slice(start, end)
                if (rawUrl[0] === `"` && rawUrl.endsWith(`"`))
                  url = rawUrl.slice(1, -1)
              }
              const deps = new Set<string>()
              let hasRemovedPureCssChunk = false

              let normalizedFile: string | undefined = undefined

              if (url) {
                normalizedFile = path.posix.join(
                  path.posix.dirname(chunk.fileName),
                  url,
                )

                const ownerFilename = chunk.fileName
                // literal import - trace direct imports and add to deps
                const analyzed: Set<string> = new Set<string>()
                const addDeps = (filename: string) => {
                  if (filename === ownerFilename) return
                  if (analyzed.has(filename)) return
                  analyzed.add(filename)
                  const chunk = bundle[filename]
                  if (chunk) {
                    deps.add(chunk.fileName)
                    if (chunk.type === 'chunk') {
                      chunk.imports.forEach(addDeps)
                      // Ensure that the css imported by current chunk is loaded after the dependencies.
                      // So the style of current chunk won't be overwritten unexpectedly.
                      chunk.viteMetadata!.importedCss.forEach((file) => {
                        deps.add(file)
                      })
                    }
                  } else {
                    const removedPureCssFiles =
                      removedPureCssFilesCache.get(config)!
                    const chunk = removedPureCssFiles.get(filename)
                    if (chunk) {
                      if (chunk.viteMetadata!.importedCss.size) {
                        chunk.viteMetadata!.importedCss.forEach((file) => {
                          deps.add(file)
                        })
                        hasRemovedPureCssChunk = true
                      }

                      s.update(expStart, expEnd, 'Promise.resolve({})')
                    }
                  }
                }
                addDeps(normalizedFile)
              }

              let markerStartPos = indexOfMatchInSlice(
                code,
                preloadMarkerRE,
                end,
              )
              // fix issue #3051
              if (markerStartPos === -1 && imports.length === 1) {
                markerStartPos = indexOfMatchInSlice(code, preloadMarkerRE)
              }

              if (markerStartPos > 0) {
                // the dep list includes the main chunk, so only need to reload when there are actual other deps.
                let depsArray =
                  deps.size > 1 ||
                  // main chunk is removed
                  (hasRemovedPureCssChunk && deps.size > 0)
                    ? modulePreload === false
                      ? // CSS deps use the same mechanism as module preloads, so even if disabled,
                        // we still need to pass these deps to the preload helper in dynamic imports.
                        [...deps].filter((d) => d.endsWith('.css'))
                      : [...deps]
                    : []

                const resolveDependencies = modulePreload
                  ? modulePreload.resolveDependencies
                  : undefined
                if (resolveDependencies && normalizedFile) {
                  // We can't let the user remove css deps as these aren't really preloads, they are just using
                  // the same mechanism as module preloads for this chunk
                  const cssDeps: string[] = []
                  const otherDeps: string[] = []
                  for (const dep of depsArray) {
                    ;(dep.endsWith('.css') ? cssDeps : otherDeps).push(dep)
                  }
                  depsArray = [
                    ...resolveDependencies(normalizedFile, otherDeps, {
                      hostId: file,
                      hostType: 'js',
                    }),
                    ...cssDeps,
                  ]
                }

                let renderedDeps: number[]
                if (renderBuiltUrl) {
                  renderedDeps = depsArray.map((dep) => {
                    const replacement = toOutputFilePathInJS(
                      this.environment,
                      dep,
                      'asset',
                      chunk.fileName,
                      'js',
                      toRelativePath,
                    )

                    if (typeof replacement === 'string') {
                      return addFileDep(replacement)
                    }

                    return addFileDep(replacement.runtime, true)
                  })
                } else {
                  renderedDeps = depsArray.map((d) =>
                    // Don't include the assets dir if the default asset file names
                    // are used, the path will be reconstructed by the import preload helper
                    isRelativeBase
                      ? addFileDep(toRelativePath(d, file))
                      : addFileDep(d),
                  )
                }

                s.update(
                  markerStartPos,
                  markerStartPos + preloadMarker.length,
                  renderedDeps.length > 0
                    ? `__vite__mapDeps([${renderedDeps.join(',')}])`
                    : `[]`,
                )
                rewroteMarkerStartPos.add(markerStartPos)
              }
            }
          }

          if (fileDeps.length > 0) {
            const fileDepsCode = `[${fileDeps
              .map((fileDep) =>
                fileDep.runtime ? fileDep.url : JSON.stringify(fileDep.url),
              )
              .join(',')}]`

            const mapDepsCode = `const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=${fileDepsCode})))=>i.map(i=>d[i]);\n`

            // inject extra code at the top or next line of hashbang
            if (code.startsWith('#!')) {
              s.prependLeft(code.indexOf('\n') + 1, mapDepsCode)
            } else {
              s.prepend(mapDepsCode)
            }
          }

          // there may still be markers due to inlined dynamic imports, remove
          // all the markers regardless
          let markerStartPos = indexOfMatchInSlice(code, preloadMarkerRE)
          while (markerStartPos >= 0) {
            if (!rewroteMarkerStartPos.has(markerStartPos)) {
              s.update(
                markerStartPos,
                markerStartPos + preloadMarker.length,
                'void 0',
              )
            }
            markerStartPos = indexOfMatchInSlice(
              code,
              preloadMarkerRE,
              markerStartPos + preloadMarker.length,
            )
          }

          if (s.hasChanged()) {
            chunk.code = s.toString()
            if (buildSourcemap && chunk.map) {
              const nextMap = s.generateMap({
                source: chunk.fileName,
                hires: 'boundary',
              })
              const map = combineSourcemaps(chunk.fileName, [
                nextMap as RawSourceMap,
                chunk.map as RawSourceMap,
              ]) as SourceMap
              map.toUrl = () => genSourceMapUrl(map)

              const originalDebugId = chunk.map.debugId
              chunk.map = map

              if (buildSourcemap === 'inline') {
                chunk.code = chunk.code.replace(
                  convertSourceMap.mapFileCommentRegex,
                  '',
                )
                chunk.code += `\n//# sourceMappingURL=${genSourceMapUrl(map)}`
              } else {
                if (originalDebugId) {
                  map.debugId = originalDebugId
                }
                const mapAsset = bundle[chunk.fileName + '.map']
                if (mapAsset && mapAsset.type === 'asset') {
                  mapAsset.source = map.toString()
                }
              }
            }
          }
        }
      }
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/importMetaGlob.ts
================================================
import { isAbsolute, posix } from 'node:path'
import picomatch from 'picomatch'
import { stripLiteral } from 'strip-literal'
import colors from 'picocolors'
import type {
  ArrayExpression,
  Expression,
  Literal,
  Node,
  SpreadElement,
  TemplateLiteral,
} from 'estree'
import type { CustomPluginOptions, RollupAstNode, RollupError } from 'rollup'
import MagicString from 'magic-string'
import { stringifyQuery } from 'ufo'
import type { GeneralImportGlobOptions } from 'types/importGlob'
import { parseAstAsync } from 'rollup/parseAst'
import { escapePath, glob } from 'tinyglobby'
import type { Plugin } from '../plugin'
import type { EnvironmentModuleNode } from '../server/moduleGraph'
import type { ResolvedConfig } from '../config'
import { evalValue, normalizePath, transformStableResult } from '../utils'
import type { Logger } from '../logger'
import { slash } from '../../shared/utils'
import type { Environment } from '../environment'

export interface ParsedImportGlob {
  index: number
  globs: string[]
  globsResolved: string[]
  isRelative: boolean
  options: ParsedGeneralImportGlobOptions
  start: number
  end: number
  onlyKeys: boolean
  onlyValues: boolean
}

interface ParsedGeneralImportGlobOptions extends GeneralImportGlobOptions {
  query?: string
}

export function importGlobPlugin(config: ResolvedConfig): Plugin {
  const importGlobMaps = new Map<
    Environment,
    Map<string, Array<(file: string) => boolean>>
  >()

  return {
    name: 'vite:import-glob',
    buildStart() {
      importGlobMaps.clear()
    },
    transform: {
      filter: { code: 'import.meta.glob' },
      async handler(code, id) {
        const result = await transformGlobImport(
          code,
          id,
          config.root,
          (im, _, options) =>
            this.resolve(im, id, options).then((i) => i?.id || im),
          config.experimental.importGlobRestoreExtension,
          config.logger,
        )
        if (result) {
          const allGlobs = result.matches.map((i) => i.globsResolved)
          if (!importGlobMaps.has(this.environment)) {
            importGlobMaps.set(this.environment, new Map())
          }

          const globMatchers = allGlobs.map((globs) => {
            const affirmed: string[] = []
            const negated: string[] = []
            for (const glob of globs) {
              ;(glob[0] === '!' ? negated : affirmed).push(glob)
            }
            const affirmedMatcher = picomatch(affirmed)
            const negatedMatcher = picomatch(negated)

            return (file: string) => {
              // (glob1 || glob2) && !(glob3 || glob4)...
              return (
                (affirmed.length === 0 || affirmedMatcher(file)) &&
                !(negated.length > 0 && negatedMatcher(file))
              )
            }
          })
          importGlobMaps.get(this.environment)!.set(id, globMatchers)

          return transformStableResult(result.s, id, config)
        }
      },
    },
    hotUpdate({ type, file, modules: oldModules }) {
      if (type === 'update') return

      const importGlobMap = importGlobMaps.get(this.environment)
      if (!importGlobMap) return

      const modules: EnvironmentModuleNode[] = []
      for (const [id, globMatchers] of importGlobMap) {
        if (globMatchers.some((matcher) => matcher(file))) {
          const mod = this.environment.moduleGraph.getModuleById(id)
          if (mod) modules.push(mod)
        }
      }
      return modules.length > 0 ? [...oldModules, ...modules] : undefined
    },
  }
}

const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g
const objectKeysRE = /\bObject\.keys\(\s*$/
const objectValuesRE = /\bObject\.values\(\s*$/

const knownOptions = {
  as: ['string'],
  eager: ['boolean'],
  import: ['string'],
  exhaustive: ['boolean'],
  query: ['object', 'string'],
  base: ['string'],
}

const forceDefaultAs = ['raw', 'url']

function err(e: string, pos: number) {
  const error = new Error(e) as RollupError
  error.pos = pos
  return error
}

function parseGlobOptions(
  rawOpts: string,
  optsStartIndex: number,
  logger?: Logger,
): ParsedGeneralImportGlobOptions {
  let opts: GeneralImportGlobOptions = {}
  try {
    opts = evalValue(rawOpts)
  } catch {
    throw err(
      'Vite is unable to parse the glob options as the value is not static',
      optsStartIndex,
    )
  }

  if (opts == null) {
    return {}
  }

  for (const key in opts) {
    if (!(key in knownOptions)) {
      throw err(`Unknown glob option "${key}"`, optsStartIndex)
    }
    const allowedTypes = knownOptions[key as keyof typeof knownOptions]
    const valueType = typeof opts[key as keyof GeneralImportGlobOptions]
    if (!allowedTypes.includes(valueType)) {
      throw err(
        `Expected glob option "${key}" to be of type ${allowedTypes.join(
          ' or ',
        )}, but got ${valueType}`,
        optsStartIndex,
      )
    }
  }

  if (opts.base) {
    if (opts.base[0] === '!') {
      throw err('Option "base" cannot start with "!"', optsStartIndex)
    } else if (
      opts.base[0] !== '/' &&
      !opts.base.startsWith('./') &&
      !opts.base.startsWith('../')
    ) {
      throw err(
        `Option "base" must start with '/', './' or '../', but got "${opts.base}"`,
        optsStartIndex,
      )
    }
  }

  if (typeof opts.query === 'object') {
    for (const key in opts.query) {
      const value = opts.query[key]
      if (!['string', 'number', 'boolean'].includes(typeof value)) {
        throw err(
          `Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value}`,
          optsStartIndex,
        )
      }
    }
    // normalize query as string so it's easier to handle later
    opts.query = stringifyQuery(opts.query)
  }

  if (opts.as && logger) {
    const importSuggestion = forceDefaultAs.includes(opts.as)
      ? `, import: 'default'`
      : ''
    logger.warn(
      colors.yellow(
        `The glob option "as" has been deprecated in favour of "query". Please update \`as: '${opts.as}'\` to \`query: '?${opts.as}'${importSuggestion}\`.`,
      ),
    )
  }

  // validate `import` option based on `as` option
  if (opts.as && forceDefaultAs.includes(opts.as)) {
    if (opts.import && opts.import !== 'default' && opts.import !== '*')
      throw err(
        `Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`,
        optsStartIndex,
      )
    opts.import = opts.import || 'default'
  }

  if (opts.as && opts.query)
    throw err(
      'Options "as" and "query" cannot be used together',
      optsStartIndex,
    )

  if (opts.as) opts.query = opts.as

  if (opts.query && opts.query[0] !== '?') opts.query = `?${opts.query}`

  return opts as ParsedGeneralImportGlobOptions
}

export async function parseImportGlob(
  code: string,
  importer: string | undefined,
  root: string,
  resolveId: IdResolver,
  logger?: Logger,
): Promise<ParsedImportGlob[]> {
  let cleanCode: string
  try {
    cleanCode = stripLiteral(code)
  } catch {
    // skip invalid js code
    return []
  }
  const matches = Array.from(cleanCode.matchAll(importGlobRE))

  const tasks = matches.map(async (match, index) => {
    const start = match.index!

    const err = (msg: string) => {
      const e = new Error(`Invalid glob import syntax: ${msg}`)
      ;(e as any).pos = start
      return e
    }

    const end =
      findCorrespondingCloseParenthesisPosition(
        cleanCode,
        start + match[0].length,
      ) + 1
    if (end <= 0) {
      throw err('Close parenthesis not found')
    }

    const statementCode = code.slice(start, end)

    const rootAst = (await parseAstAsync(statementCode)).body[0]
    if (rootAst.type !== 'ExpressionStatement') {
      throw err(`Expect CallExpression, got ${rootAst.type}`)
    }
    const ast = rootAst.expression
    if (ast.type !== 'CallExpression') {
      throw err(`Expect CallExpression, got ${ast.type}`)
    }
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err(`Expected 1-2 arguments, but got ${ast.arguments.length}`)

    const arg1 = ast.arguments[0] as ArrayExpression | Literal | TemplateLiteral
    const arg2 = ast.arguments[1] as RollupAstNode<Node> | undefined

    const globs: string[] = []

    const validateLiteral = (element: Expression | SpreadElement | null) => {
      if (!element) return
      if (element.type === 'Literal') {
        if (typeof element.value !== 'string')
          throw err(
            `Expected glob to be a string, but got "${typeof element.value}"`,
          )
        globs.push(element.value)
      } else if (element.type === 'TemplateLiteral') {
        if (element.expressions.length !== 0) {
          throw err(
            `Expected glob to be a string, but got dynamic template literal`,
          )
        }
        globs.push(element.quasis[0].value.raw)
      } else {
        throw err('Could only use literals')
      }
    }

    if (arg1.type === 'ArrayExpression') {
      for (const element of arg1.elements) {
        validateLiteral(element)
      }
    } else {
      validateLiteral(arg1)
    }

    // arg2
    let options: ParsedGeneralImportGlobOptions = {}
    if (arg2) {
      if (arg2.type !== 'ObjectExpression')
        throw err(
          `Expected the second argument to be an object literal, but got "${arg2.type}"`,
        )

      options = parseGlobOptions(
        code.slice(start + arg2.start, start + arg2.end),
        start + arg2.start,
        logger,
      )
    }

    const globsResolved = await Promise.all(
      globs.map((glob) =>
        toAbsoluteGlob(glob, root, importer, resolveId, options.base),
      ),
    )
    const isRelative = globs.every((i) => '.!'.includes(i[0]))
    const sliceCode = cleanCode.slice(0, start)
    const onlyKeys = objectKeysRE.test(sliceCode)
    let onlyValues = false
    if (!onlyKeys) {
      onlyValues = objectValuesRE.test(sliceCode)
    }

    return {
      index,
      globs,
      globsResolved,
      isRelative,
      options,
      start,
      end,
      onlyKeys,
      onlyValues,
    }
  })

  return (await Promise.all(tasks)).filter(Boolean)
}

function findCorrespondingCloseParenthesisPosition(
  cleanCode: string,
  openPos: number,
) {
  const closePos = cleanCode.indexOf(')', openPos)
  if (closePos < 0) return -1

  if (!cleanCode.slice(openPos, closePos).includes('(')) return closePos

  let remainingParenthesisCount = 0
  const cleanCodeLen = cleanCode.length
  for (let pos = openPos; pos < cleanCodeLen; pos++) {
    switch (cleanCode[pos]) {
      case '(': {
        remainingParenthesisCount++
        break
      }
      case ')': {
        remainingParenthesisCount--
        if (remainingParenthesisCount <= 0) {
          return pos
        }
      }
    }
  }
  return -1
}

const importPrefix = '__vite_glob_'

const { basename, dirname, relative } = posix

export interface TransformGlobImportResult {
  s: MagicString
  matches: ParsedImportGlob[]
  files: Set<string>
}

/**
 * @param optimizeExport for dynamicImportVar plugin don't need to optimize export.
 */
export async function transformGlobImport(
  code: string,
  id: string,
  root: string,
  resolveId: IdResolver,
  restoreQueryExtension = false,
  logger?: Logger,
): Promise<TransformGlobImportResult | null> {
  id = slash(id)
  root = slash(root)
  const isVirtual = isVirtualModule(id)
  const dir = isVirtual ? undefined : dirname(id)
  const matches = await parseImportGlob(
    code,
    isVirtual ? undefined : id,
    root,
    resolveId,
    logger,
  )
  const matchedFiles = new Set<string>()

  if (!matches.length) return null

  const s = new MagicString(code)

  const staticImports = (
    await Promise.all(
      matches.map(
        async ({
          globsResolved,
          isRelative,
          options,
          index,
          start,
          end,
          onlyKeys,
          onlyValues,
        }) => {
          const cwd = getCommonBase(globsResolved) ?? root
          const files = (
            await glob(globsResolved, {
              absolute: true,
              cwd,
              dot: !!options.exhaustive,
              expandDirectories: false,
              ignore: options.exhaustive ? [] : ['**/node_modules/**'],
            })
          )
            .filter((file) => file !== id)
            .sort()

          const objectProps: string[] = []
          const staticImports: string[] = []

          const resolvePaths = (file: string) => {
            if (!dir) {
              if (!options.base && isRelative)
                throw new Error(
                  "In virtual modules, all globs must start with '/'",
                )
              const importPath = `/${relative(root, file)}`
              let filePath = options.base
                ? `${relative(posix.join(root, options.base), file)}`
                : importPath
              if (options.base && filePath[0] !== '.') {
                filePath = `./${filePath}`
              }
              return { filePath, importPath }
            }

            let importPath = relative(dir, file)
            if (importPath[0] !== '.') importPath = `./${importPath}`

            let filePath: string
            if (options.base) {
              const resolvedBasePath = options.base[0] === '/' ? root : dir
              filePath = relative(
                posix.join(resolvedBasePath, options.base),
                file,
              )
              if (filePath[0] !== '.') filePath = `./${filePath}`
              if (options.base[0] === '/') {
                importPath = `/${relative(root, file)}`
              }
            } else if (isRelative) {
              filePath = importPath
            } else {
              filePath = relative(root, file)
              if (filePath[0] !== '.') filePath = `/${filePath}`
            }

            return { filePath, importPath }
          }

          files.forEach((file, i) => {
            const paths = resolvePaths(file)
            const filePath = paths.filePath
            let importPath = paths.importPath
            let importQuery = options.query ?? ''

            if (onlyKeys) {
              objectProps.push(`${JSON.stringify(filePath)}: 0`)
              return
            }

            if (importQuery && importQuery !== '?raw') {
              const fileExtension = basename(file).split('.').slice(-1)[0]
              if (fileExtension && restoreQueryExtension)
                importQuery = `${importQuery}&lang.${fileExtension}`
            }

            importPath = `${importPath}${importQuery}`

            const importKey =
              options.import && options.import !== '*'
                ? options.import
                : undefined

            if (options.eager) {
              const variableName = `${importPrefix}${index}_${i}`
              const expression = importKey
                ? `{ ${importKey} as ${variableName} }`
                : `* as ${variableName}`
              staticImports.push(
                `import ${expression} from ${JSON.stringify(importPath)}`,
              )
              objectProps.push(
                onlyValues
                  ? `${variableName}`
                  : `${JSON.stringify(filePath)}: ${variableName}`,
              )
            } else {
              let importStatement = `import(${JSON.stringify(importPath)})`
              if (importKey)
                importStatement += `.then(m => m[${JSON.stringify(importKey)}])`
              objectProps.push(
                onlyValues
                  ? `() => ${importStatement}`
                  : `${JSON.stringify(filePath)}: () => ${importStatement}`,
              )
            }
          })

          files.forEach((i) => matchedFiles.add(i))

          const originalLineBreakCount =
            code.slice(start, end).match(/\n/g)?.length ?? 0
          const lineBreaks =
            originalLineBreakCount > 0
              ? '\n'.repeat(originalLineBreakCount)
              : ''
          let replacement = ''
          if (onlyKeys) {
            replacement = `{${objectProps.join(',')}${lineBreaks}}`
          } else if (onlyValues) {
            replacement = `[${objectProps.join(',')}${lineBreaks}]`
          } else {
            replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(
              ',',
            )}${lineBreaks}})`
          }

          s.overwrite(start, end, replacement)

          return staticImports
        },
      ),
    )
  ).flat()

  if (staticImports.length) s.prepend(`${staticImports.join(';')};`)

  return {
    s,
    matches,
    files: matchedFiles,
  }
}

type IdResolver = (
  id: string,
  importer?: string,
  options?: {
    attributes?: Record<string, string>
    custom?: CustomPluginOptions
    isEntry?: boolean
    skipSelf?: boolean
  },
) => Promise<string | undefined> | string | undefined

function globSafePath(path: string) {
  // slash path to ensure \ is converted to / as \ could lead to a double escape scenario
  return escapePath(normalizePath(path))
}

function lastNthChar(str: string, n: number) {
  return str.charAt(str.length - 1 - n)
}

function globSafeResolvedPath(resolved: string, glob: string) {
  // we have to escape special glob characters in the resolved path, but keep the user specified globby suffix
  // walk back both strings until a character difference is found
  // then slice up the resolved path at that pos and escape the first part
  let numEqual = 0
  const maxEqual = Math.min(resolved.length, glob.length)
  while (
    numEqual < maxEqual &&
    lastNthChar(resolved, numEqual) === lastNthChar(glob, numEqual)
  ) {
    numEqual += 1
  }
  const staticPartEnd = resolved.length - numEqual
  const staticPart = resolved.slice(0, staticPartEnd)
  const dynamicPart = resolved.slice(staticPartEnd)
  return globSafePath(staticPart) + dynamicPart
}

export async function toAbsoluteGlob(
  glob: string,
  root: string,
  importer: string | undefined,
  resolveId: IdResolver,
  base?: string,
): Promise<string> {
  let pre = ''
  if (glob[0] === '!') {
    pre = '!'
    glob = glob.slice(1)
  }
  root = globSafePath(root)
  let dir
  if (base) {
    if (base.startsWith('/')) {
      dir = posix.join(root, base)
    } else {
      dir = posix.resolve(
        importer ? globSafePath(dirname(importer)) : root,
        base,
      )
    }
  } else {
    dir = importer ? globSafePath(dirname(importer)) : root
  }

  if (glob[0] === '/') return pre + posix.join(root, glob.slice(1))
  if (glob.startsWith('./')) return pre + posix.join(dir, glob.slice(2))
  if (glob.startsWith('../')) return pre + posix.join(dir, glob)
  if (glob.startsWith('**')) return pre + glob

  const isSubImportsPattern = glob[0] === '#' && glob.includes('*')

  const resolved = normalizePath(
    (await resolveId(glob, importer, {
      custom: { 'vite:import-glob': { isSubImportsPattern } },
    })) || glob,
  )
  if (isAbsolute(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob)
  }

  throw new Error(
    `Invalid glob: "${glob}" (resolved: "${resolved}"). It must start with '/' or './'`,
  )
}

export function getCommonBase(globsResolved: string[]): null | string {
  const bases = globsResolved
    .filter((g) => g[0] !== '!')
    .map((glob) => {
      let { base } = picomatch.scan(glob)
      // `scan('a/foo.js')` returns `base: 'a/foo.js'`
      if (posix.basename(base).includes('.')) base = posix.dirname(base)

      return base
    })

  if (!bases.length) return null

  let commonAncestor = ''
  const dirS = bases[0].split('/')
  for (let i = 0; i < dirS.length; i++) {
    const candidate = dirS.slice(0, i + 1).join('/')
    if (bases.every((base) => base.startsWith(candidate)))
      commonAncestor = candidate
    else break
  }
  if (!commonAncestor) commonAncestor = '/'

  return commonAncestor
}

export function isVirtualModule(id: string): boolean {
  // https://vite.dev/guide/api-plugin.html#virtual-modules-convention
  return id.startsWith('virtual:') || id[0] === '\0' || !id.includes('/')
}



================================================
FILE: packages/vite/src/node/plugins/index.ts
================================================
import aliasPlugin, { type ResolverFunction } from '@rollup/plugin-alias'
import type { ObjectHook } from 'rollup'
import type { PluginHookUtils, ResolvedConfig } from '../config'
import type { HookHandler, Plugin, PluginWithRequiredHook } from '../plugin'
import { watchPackageDataPlugin } from '../packages'
import { jsonPlugin } from './json'
import { resolvePlugin } from './resolve'
import { optimizedDepsPlugin } from './optimizedDeps'
import { esbuildPlugin } from './esbuild'
import { importAnalysisPlugin } from './importAnalysis'
import { cssAnalysisPlugin, cssPlugin, cssPostPlugin } from './css'
import { assetPlugin } from './asset'
import { clientInjectionsPlugin } from './clientInjections'
import { buildHtmlPlugin, htmlInlineProxyPlugin } from './html'
import { wasmFallbackPlugin, wasmHelperPlugin } from './wasm'
import { modulePreloadPolyfillPlugin } from './modulePreloadPolyfill'
import { webWorkerPlugin } from './worker'
import { preAliasPlugin } from './preAlias'
import { definePlugin } from './define'
import { workerImportMetaUrlPlugin } from './workerImportMetaUrl'
import { assetImportMetaUrlPlugin } from './assetImportMetaUrl'
import { metadataPlugin } from './metadata'
import { dynamicImportVarsPlugin } from './dynamicImportVars'
import { importGlobPlugin } from './importMetaGlob'
import {
  type PluginFilter,
  type TransformHookFilter,
  createFilterForTransform,
  createIdFilter,
} from './pluginFilter'

export async function resolvePlugins(
  config: ResolvedConfig,
  prePlugins: Plugin[],
  normalPlugins: Plugin[],
  postPlugins: Plugin[],
): Promise<Plugin[]> {
  const isBuild = config.command === 'build'
  const isWorker = config.isWorker
  const buildPlugins = isBuild
    ? await (await import('../build')).resolveBuildPlugins(config)
    : { pre: [], post: [] }
  const { modulePreload } = config.build

  return [
    !isBuild ? optimizedDepsPlugin() : null,
    isBuild ? metadataPlugin() : null,
    !isWorker ? watchPackageDataPlugin(config.packageCache) : null,
    !isBuild ? preAliasPlugin(config) : null,
    aliasPlugin({
      entries: config.resolve.alias,
      customResolver: viteAliasCustomResolver,
    }),

    ...prePlugins,

    modulePreload !== false && modulePreload.polyfill
      ? modulePreloadPolyfillPlugin(config)
      : null,
    resolvePlugin({
      root: config.root,
      isProduction: config.isProduction,
      isBuild,
      packageCache: config.packageCache,
      asSrc: true,
      optimizeDeps: true,
      externalize: true,
    }),
    htmlInlineProxyPlugin(config),
    cssPlugin(config),
    config.esbuild !== false ? esbuildPlugin(config) : null,
    jsonPlugin(config.json, isBuild),
    wasmHelperPlugin(),
    webWorkerPlugin(config),
    assetPlugin(config),

    ...normalPlugins,

    wasmFallbackPlugin(),
    definePlugin(config),
    cssPostPlugin(config),
    isBuild && buildHtmlPlugin(config),
    workerImportMetaUrlPlugin(config),
    assetImportMetaUrlPlugin(config),
    ...buildPlugins.pre,
    dynamicImportVarsPlugin(config),
    importGlobPlugin(config),

    ...postPlugins,

    ...buildPlugins.post,

    // internal server-only plugins are always applied after everything else
    ...(isBuild
      ? []
      : [
          clientInjectionsPlugin(config),
          cssAnalysisPlugin(config),
          importAnalysisPlugin(config),
        ]),
  ].filter(Boolean) as Plugin[]
}

export function createPluginHookUtils(
  plugins: readonly Plugin[],
): PluginHookUtils {
  // sort plugins per hook
  const sortedPluginsCache = new Map<keyof Plugin, Plugin[]>()
  function getSortedPlugins<K extends keyof Plugin>(
    hookName: K,
  ): PluginWithRequiredHook<K>[] {
    if (sortedPluginsCache.has(hookName))
      return sortedPluginsCache.get(hookName) as PluginWithRequiredHook<K>[]
    const sorted = getSortedPluginsByHook(hookName, plugins)
    sortedPluginsCache.set(hookName, sorted)
    return sorted
  }
  function getSortedPluginHooks<K extends keyof Plugin>(
    hookName: K,
  ): NonNullable<HookHandler<Plugin[K]>>[] {
    const plugins = getSortedPlugins(hookName)
    return plugins.map((p) => getHookHandler(p[hookName])).filter(Boolean)
  }

  return {
    getSortedPlugins,
    getSortedPluginHooks,
  }
}

export function getSortedPluginsByHook<K extends keyof Plugin>(
  hookName: K,
  plugins: readonly Plugin[],
): PluginWithRequiredHook<K>[] {
  const sortedPlugins: Plugin[] = []
  // Use indexes to track and insert the ordered plugins directly in the
  // resulting array to avoid creating 3 extra temporary arrays per hook
  let pre = 0,
    normal = 0,
    post = 0
  for (const plugin of plugins) {
    const hook = plugin[hookName]
    if (hook) {
      if (typeof hook === 'object') {
        if (hook.order === 'pre') {
          sortedPlugins.splice(pre++, 0, plugin)
          continue
        }
        if (hook.order === 'post') {
          sortedPlugins.splice(pre + normal + post++, 0, plugin)
          continue
        }
      }
      sortedPlugins.splice(pre + normal++, 0, plugin)
    }
  }

  return sortedPlugins as PluginWithRequiredHook<K>[]
}

export function getHookHandler<T extends ObjectHook<Function>>(
  hook: T,
): HookHandler<T> {
  return (typeof hook === 'object' ? hook.handler : hook) as HookHandler<T>
}

type FilterForPluginValue = {
  resolveId?: PluginFilter | undefined
  load?: PluginFilter | undefined
  transform?: TransformHookFilter | undefined
}
const filterForPlugin = new WeakMap<Plugin, FilterForPluginValue>()

export function getCachedFilterForPlugin<
  H extends 'resolveId' | 'load' | 'transform',
>(plugin: Plugin, hookName: H): FilterForPluginValue[H] | undefined {
  let filters = filterForPlugin.get(plugin)
  if (filters && hookName in filters) {
    return filters[hookName]
  }

  if (!filters) {
    filters = {}
    filterForPlugin.set(plugin, filters)
  }

  let filter: PluginFilter | TransformHookFilter | undefined
  switch (hookName) {
    case 'resolveId': {
      const rawFilter = extractFilter(plugin.resolveId)?.id
      filters.resolveId = createIdFilter(rawFilter)
      filter = filters.resolveId
      break
    }
    case 'load': {
      const rawFilter = extractFilter(plugin.load)?.id
      filters.load = createIdFilter(rawFilter)
      filter = filters.load
      break
    }
    case 'transform': {
      const rawFilters = extractFilter(plugin.transform)
      filters.transform = createFilterForTransform(
        rawFilters?.id,
        rawFilters?.code,
      )
      filter = filters.transform
      break
    }
  }
  return filter as FilterForPluginValue[H] | undefined
}

function extractFilter<T extends Function, F>(
  hook: ObjectHook<T, { filter?: F }> | undefined,
) {
  return hook && 'filter' in hook && hook.filter ? hook.filter : undefined
}

// Same as `@rollup/plugin-alias` default resolver, but we attach additional meta
// if we can't resolve to something, which will error in `importAnalysis`
export const viteAliasCustomResolver: ResolverFunction = async function (
  id,
  importer,
  options,
) {
  const resolved = await this.resolve(id, importer, options)
  return resolved || { id, meta: { 'vite:alias': { noResolved: true } } }
}



================================================
FILE: packages/vite/src/node/plugins/json.ts
================================================
/**
 * https://github.com/rollup/plugins/blob/master/packages/json/src/index.js
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/rollup/plugins/blob/master/LICENSE
 */

import { dataToEsm, makeLegalIdentifier } from '@rollup/pluginutils'
import { SPECIAL_QUERY_RE } from '../constants'
import type { Plugin } from '../plugin'
import { stripBomTag } from '../utils'
import { inlineRE, noInlineRE } from './asset'

export interface JsonOptions {
  /**
   * Generate a named export for every property of the JSON object
   * @default true
   */
  namedExports?: boolean
  /**
   * Generate performant output as JSON.parse("stringified").
   *
   * When set to 'auto', the data will be stringified only if the data is bigger than 10kB.
   * @default 'auto'
   */
  stringify?: boolean | 'auto'
}

// Custom json filter for vite
const jsonExtRE = /\.json(?:$|\?)(?!commonjs-(?:proxy|external))/

const jsonObjRE = /^\s*\{/

const jsonLangs = `\\.(?:json|json5)(?:$|\\?)`
const jsonLangRE = new RegExp(jsonLangs)
export const isJSONRequest = (request: string): boolean =>
  jsonLangRE.test(request)

export function jsonPlugin(
  options: Required<JsonOptions>,
  isBuild: boolean,
): Plugin {
  return {
    name: 'vite:json',

    transform: {
      filter: {
        id: { include: jsonExtRE, exclude: SPECIAL_QUERY_RE },
      },
      handler(json, id) {
        if (inlineRE.test(id) || noInlineRE.test(id)) {
          this.warn(
            `\n` +
              `Using ?inline or ?no-inline for JSON imports will have no effect.\n` +
              `Please use ?url&inline or ?url&no-inline to control JSON file inlining behavior.\n`,
          )
        }

        json = stripBomTag(json)

        try {
          if (options.stringify !== false) {
            if (options.namedExports && jsonObjRE.test(json)) {
              const parsed = JSON.parse(json)
              const keys = Object.keys(parsed)

              let code = ''
              let defaultObjectCode = '{\n'
              for (const key of keys) {
                if (key === makeLegalIdentifier(key)) {
                  code += `export const ${key} = ${serializeValue(parsed[key])};\n`
                  defaultObjectCode += `  ${key},\n`
                } else {
                  defaultObjectCode += `  ${JSON.stringify(key)}: ${serializeValue(parsed[key])},\n`
                }
              }
              defaultObjectCode += '}'

              code += `export default ${defaultObjectCode};\n`
              return {
                code,
                map: { mappings: '' },
              }
            }

            if (
              options.stringify === true ||
              // use 10kB as a threshold for 'auto'
              // https://v8.dev/blog/cost-of-javascript-2019#:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger
              json.length > 10 * 1000
            ) {
              // during build, parse then double-stringify to remove all
              // unnecessary whitespaces to reduce bundle size.
              if (isBuild) {
                json = JSON.stringify(JSON.parse(json))
              }

              return {
                code: `export default /* #__PURE__ */ JSON.parse(${JSON.stringify(json)})`,
                map: { mappings: '' },
              }
            }
          }

          return {
            code: dataToEsm(JSON.parse(json), {
              preferConst: true,
              namedExports: options.namedExports,
            }),
            map: { mappings: '' },
          }
        } catch (e) {
          const position = extractJsonErrorPosition(e.message, json.length)
          const msg = position
            ? `, invalid JSON syntax found at position ${position}`
            : `.`
          this.error(`Failed to parse JSON file` + msg, position)
        }
      },
    },
  }
}

function serializeValue(value: unknown): string {
  const valueAsString = JSON.stringify(value)
  // use 10kB as a threshold
  // https://v8.dev/blog/cost-of-javascript-2019#:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger
  if (
    typeof value === 'object' &&
    value != null &&
    valueAsString.length > 10 * 1000
  ) {
    return `/* #__PURE__ */ JSON.parse(${JSON.stringify(valueAsString)})`
  }
  return valueAsString
}

export function extractJsonErrorPosition(
  errorMessage: string,
  inputLength: number,
): number | undefined {
  if (errorMessage.startsWith('Unexpected end of JSON input')) {
    return inputLength - 1
  }

  const errorMessageList = /at position (\d+)/.exec(errorMessage)
  return errorMessageList
    ? Math.max(parseInt(errorMessageList[1], 10) - 1, 0)
    : undefined
}



================================================
FILE: packages/vite/src/node/plugins/loadFallback.ts
================================================
import fsp from 'node:fs/promises'
import { cleanUrl } from '../../shared/utils'
import type { Plugin } from '../plugin'

/**
 * A plugin to provide build load fallback for arbitrary request with queries.
 */
export function buildLoadFallbackPlugin(): Plugin {
  return {
    name: 'vite:load-fallback',
    load: {
      async handler(id) {
        try {
          const cleanedId = cleanUrl(id)
          const content = await fsp.readFile(cleanedId, 'utf-8')
          this.addWatchFile(cleanedId)
          return content
        } catch {
          const content = await fsp.readFile(id, 'utf-8')
          this.addWatchFile(id)
          return content
        }
      },
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/manifest.ts
================================================
import path from 'node:path'
import type {
  InternalModuleFormat,
  OutputAsset,
  OutputChunk,
  RenderedChunk,
} from 'rollup'
import type { Plugin } from '../plugin'
import { normalizePath, sortObjectKeys } from '../utils'
import { perEnvironmentState } from '../environment'
import { cssEntriesMap } from './asset'

const endsWithJSRE = /\.[cm]?js$/

export type Manifest = Record<string, ManifestChunk>

export interface ManifestChunk {
  src?: string
  file: string
  css?: string[]
  assets?: string[]
  isEntry?: boolean
  name?: string
  names?: string[]
  isDynamicEntry?: boolean
  imports?: string[]
  dynamicImports?: string[]
}

export function manifestPlugin(): Plugin {
  const getState = perEnvironmentState(() => {
    return {
      manifest: {} as Manifest,
      outputCount: 0,
      reset() {
        this.manifest = {}
        this.outputCount = 0
      },
    }
  })

  return {
    name: 'vite:manifest',

    perEnvironmentStartEndDuringDev: true,

    applyToEnvironment(environment) {
      return !!environment.config.build.manifest
    },

    buildStart() {
      getState(this).reset()
    },

    generateBundle({ format }, bundle) {
      const state = getState(this)
      const { manifest } = state
      const { root } = this.environment.config
      const buildOptions = this.environment.config.build

      function getChunkName(chunk: OutputChunk) {
        return (
          getChunkOriginalFileName(chunk, root, format) ??
          `_${path.basename(chunk.fileName)}`
        )
      }

      function getInternalImports(imports: string[]): string[] {
        const filteredImports: string[] = []

        for (const file of imports) {
          if (bundle[file] === undefined) {
            continue
          }

          filteredImports.push(getChunkName(bundle[file] as OutputChunk))
        }

        return filteredImports
      }

      function createChunk(chunk: OutputChunk): ManifestChunk {
        const manifestChunk: ManifestChunk = {
          file: chunk.fileName,
          name: chunk.name,
        }

        if (chunk.facadeModuleId) {
          manifestChunk.src = getChunkName(chunk)
        }
        if (chunk.isEntry) {
          manifestChunk.isEntry = true
        }
        if (chunk.isDynamicEntry) {
          manifestChunk.isDynamicEntry = true
        }

        if (chunk.imports.length) {
          const internalImports = getInternalImports(chunk.imports)
          if (internalImports.length > 0) {
            manifestChunk.imports = internalImports
          }
        }

        if (chunk.dynamicImports.length) {
          const internalImports = getInternalImports(chunk.dynamicImports)
          if (internalImports.length > 0) {
            manifestChunk.dynamicImports = internalImports
          }
        }

        if (chunk.viteMetadata?.importedCss.size) {
          manifestChunk.css = [...chunk.viteMetadata.importedCss]
        }
        if (chunk.viteMetadata?.importedAssets.size) {
          manifestChunk.assets = [...chunk.viteMetadata.importedAssets]
        }

        return manifestChunk
      }

      function createAsset(
        asset: OutputAsset,
        src: string,
        isEntry?: boolean,
      ): ManifestChunk {
        const manifestChunk: ManifestChunk = {
          file: asset.fileName,
          src,
        }
        if (isEntry) {
          manifestChunk.isEntry = true
          manifestChunk.names = asset.names
        }
        return manifestChunk
      }

      const entryCssReferenceIds = cssEntriesMap.get(this.environment)!
      const entryCssAssetFileNames = new Set()
      for (const id of entryCssReferenceIds) {
        try {
          const fileName = this.getFileName(id)
          entryCssAssetFileNames.add(fileName)
        } catch {
          // The asset was generated as part of a different output option.
          // It was already handled during the previous run of this plugin.
        }
      }

      for (const file in bundle) {
        const chunk = bundle[file]
        if (chunk.type === 'chunk') {
          manifest[getChunkName(chunk)] = createChunk(chunk)
        } else if (chunk.type === 'asset' && chunk.names.length > 0) {
          // Add every unique asset to the manifest, keyed by its original name
          const src =
            chunk.originalFileNames.length > 0
              ? chunk.originalFileNames[0]
              : `_${path.basename(chunk.fileName)}`
          const isEntry = entryCssAssetFileNames.has(chunk.fileName)
          const asset = createAsset(chunk, src, isEntry)

          // If JS chunk and asset chunk are both generated from the same source file,
          // prioritize JS chunk as it contains more information
          const file = manifest[src]?.file
          if (!(file && endsWithJSRE.test(file))) {
            manifest[src] = asset
          }

          for (const originalFileName of chunk.originalFileNames.slice(1)) {
            const file = manifest[originalFileName]?.file
            if (!(file && endsWithJSRE.test(file))) {
              manifest[originalFileName] = asset
            }
          }
        }
      }

      state.outputCount++
      const output = buildOptions.rollupOptions.output
      const outputLength = Array.isArray(output) ? output.length : 1
      if (state.outputCount >= outputLength) {
        this.emitFile({
          fileName:
            typeof buildOptions.manifest === 'string'
              ? buildOptions.manifest
              : '.vite/manifest.json',
          type: 'asset',
          source: JSON.stringify(sortObjectKeys(manifest), undefined, 2),
        })
      }
    },
  }
}

export function getChunkOriginalFileName(
  chunk: OutputChunk | RenderedChunk,
  root: string,
  format: InternalModuleFormat,
): string | undefined {
  if (chunk.facadeModuleId) {
    let name = normalizePath(path.relative(root, chunk.facadeModuleId))
    if (format === 'system' && !chunk.name.includes('-legacy')) {
      const ext = path.extname(name)
      const endPos = ext.length !== 0 ? -ext.length : undefined
      name = `${name.slice(0, endPos)}-legacy${ext}`
    }
    return name.replace(/\0/g, '')
  }
}



================================================
FILE: packages/vite/src/node/plugins/metadata.ts
================================================
import type { Plugin } from '../plugin'

/**
 * Prepares the rendered chunks to contain additional metadata during build.
 */
export function metadataPlugin(): Plugin {
  return {
    name: 'vite:build-metadata',

    async renderChunk(_code, chunk) {
      chunk.viteMetadata = {
        importedAssets: new Set(),
        importedCss: new Set(),
      }
      return null
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/modulePreloadPolyfill.ts
================================================
import { exactRegex } from '@rolldown/pluginutils'
import type { ResolvedConfig } from '..'
import type { Plugin } from '../plugin'
import { isModernFlag } from './importAnalysisBuild'

export const modulePreloadPolyfillId = 'vite/modulepreload-polyfill'
const resolvedModulePreloadPolyfillId = '\0' + modulePreloadPolyfillId + '.js'

export function modulePreloadPolyfillPlugin(config: ResolvedConfig): Plugin {
  let polyfillString: string | undefined

  return {
    name: 'vite:modulepreload-polyfill',
    resolveId: {
      filter: { id: exactRegex(modulePreloadPolyfillId) },
      handler(_id) {
        return resolvedModulePreloadPolyfillId
      },
    },
    load: {
      filter: { id: exactRegex(resolvedModulePreloadPolyfillId) },
      handler(_id) {
        // `isModernFlag` is only available during build since it is resolved by `vite:build-import-analysis`
        if (
          config.command !== 'build' ||
          this.environment.config.consumer !== 'client'
        ) {
          return ''
        }
        if (!polyfillString) {
          polyfillString = `${isModernFlag}&&(${polyfill.toString()}());`
        }
        return { code: polyfillString, moduleSideEffects: true }
      },
    },
  }
}

/**
The following polyfill function is meant to run in the browser and adapted from
https://github.com/guybedford/es-module-shims
MIT License
Copyright (C) 2018-2021 Guy Bedford
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

declare const document: any
declare const MutationObserver: any
declare const fetch: any

function polyfill() {
  const relList = document.createElement('link').relList
  if (relList && relList.supports && relList.supports('modulepreload')) {
    return
  }

  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link)
  }

  new MutationObserver((mutations: any) => {
    for (const mutation of mutations) {
      if (mutation.type !== 'childList') {
        continue
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === 'LINK' && node.rel === 'modulepreload')
          processPreload(node)
      }
    }
  }).observe(document, { childList: true, subtree: true })

  function getFetchOpts(link: any) {
    const fetchOpts = {} as any
    if (link.integrity) fetchOpts.integrity = link.integrity
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy
    if (link.crossOrigin === 'use-credentials')
      fetchOpts.credentials = 'include'
    else if (link.crossOrigin === 'anonymous') fetchOpts.credentials = 'omit'
    else fetchOpts.credentials = 'same-origin'
    return fetchOpts
  }

  function processPreload(link: any) {
    if (link.ep)
      // ep marker = processed
      return
    link.ep = true
    // prepopulate the load record
    const fetchOpts = getFetchOpts(link)
    fetch(link.href, fetchOpts)
  }
}



================================================
FILE: packages/vite/src/node/plugins/optimizedDeps.ts
================================================
import fsp from 'node:fs/promises'
import colors from 'picocolors'
import type { DevEnvironment } from '..'
import type { Plugin } from '../plugin'
import {
  DEP_VERSION_RE,
  ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR,
  ERR_OPTIMIZE_DEPS_PROCESSING_ERROR,
} from '../constants'
import { createDebugger } from '../utils'
import {
  isDepOptimizationDisabled,
  optimizedDepInfoFromFile,
} from '../optimizer'
import { cleanUrl } from '../../shared/utils'
import { ERR_OUTDATED_OPTIMIZED_DEP } from '../../shared/constants'

const debug = createDebugger('vite:optimize-deps')

export function optimizedDepsPlugin(): Plugin {
  return {
    name: 'vite:optimized-deps',

    applyToEnvironment(environment) {
      return !isDepOptimizationDisabled(environment.config.optimizeDeps)
    },

    resolveId(id) {
      const environment = this.environment as DevEnvironment
      if (environment.depsOptimizer?.isOptimizedDepFile(id)) {
        return id
      }
    },

    // this.load({ id }) isn't implemented in PluginContainer
    // The logic to register an id to wait until it is processed
    // is in importAnalysis, see call to delayDepsOptimizerUntil

    async load(id) {
      const environment = this.environment as DevEnvironment
      const depsOptimizer = environment.depsOptimizer
      if (depsOptimizer?.isOptimizedDepFile(id)) {
        const metadata = depsOptimizer.metadata
        const file = cleanUrl(id)
        const versionMatch = DEP_VERSION_RE.exec(file)
        const browserHash = versionMatch
          ? versionMatch[1].split('=')[1]
          : undefined

        // Search in both the currently optimized and newly discovered deps
        const info = optimizedDepInfoFromFile(metadata, file)
        if (info) {
          if (browserHash && info.browserHash !== browserHash) {
            throwOutdatedRequest(id)
          }
          try {
            // This is an entry point, it may still not be bundled
            await info.processing
          } catch {
            // If the refresh has not happened after timeout, Vite considers
            // something unexpected has happened. In this case, Vite
            // returns an empty response that will error.
            throwProcessingError(id)
          }
          const newMetadata = depsOptimizer.metadata
          if (metadata !== newMetadata) {
            const currentInfo = optimizedDepInfoFromFile(newMetadata!, file)
            if (info.browserHash !== currentInfo?.browserHash) {
              throwOutdatedRequest(id)
            }
          }
        }
        debug?.(`load ${colors.cyan(file)}`)
        // Load the file from the cache instead of waiting for other plugin
        // load hooks to avoid race conditions, once processing is resolved,
        // we are sure that the file has been properly save to disk
        try {
          return await fsp.readFile(file, 'utf-8')
        } catch {
          const newMetadata = depsOptimizer.metadata
          if (optimizedDepInfoFromFile(newMetadata, file)) {
            // Outdated non-entry points (CHUNK), loaded after a rerun
            throwOutdatedRequest(id)
          }
          throwFileNotFoundInOptimizedDep(id)
        }
      }
    },
  }
}

function throwProcessingError(id: string): never {
  const err: any = new Error(
    `Something unexpected happened while optimizing "${id}". ` +
      `The current page should have reloaded by now`,
  )
  err.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR
  // This error will be caught by the transform middleware that will
  // send a 504 status code request timeout
  throw err
}

export function throwOutdatedRequest(id: string): never {
  const err: any = new Error(
    `There is a new version of the pre-bundle for "${id}", ` +
      `a page reload is going to ask for it.`,
  )
  err.code = ERR_OUTDATED_OPTIMIZED_DEP
  // This error will be caught by the transform middleware that will
  // send a 504 status code request timeout
  throw err
}

export function throwFileNotFoundInOptimizedDep(id: string): never {
  const err: any = new Error(
    `The file does not exist at "${id}" which is in the optimize deps directory. ` +
      `The dependency might be incompatible with the dep optimizer. ` +
      `Try adding it to \`optimizeDeps.exclude\`.`,
  )
  err.code = ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR
  // This error will be caught by the transform middleware that will
  // send a 404 status code not found
  throw err
}



================================================
FILE: packages/vite/src/node/plugins/pluginFilter.ts
================================================
import path from 'node:path'
import picomatch from 'picomatch'
import { arraify } from '../utils'
import { slash } from '../../shared/utils'

export type PluginFilter = (input: string) => boolean
export type TransformHookFilter = (id: string, code: string) => boolean

export type StringFilter<Value = string | RegExp> =
  | Value
  | Array<Value>
  | {
      include?: Value | Array<Value>
      exclude?: Value | Array<Value>
    }

type NormalizedStringFilter = {
  include?: Array<string | RegExp>
  exclude?: Array<string | RegExp>
}

function getMatcherString(glob: string, cwd: string) {
  if (glob.startsWith('**') || path.isAbsolute(glob)) {
    return slash(glob)
  }

  const resolved = path.join(cwd, glob)
  return slash(resolved)
}

function patternToIdFilter(
  pattern: string | RegExp,
  cwd: string,
): PluginFilter {
  if (pattern instanceof RegExp) {
    return (id: string) => {
      const normalizedId = slash(id)
      const result = pattern.test(normalizedId)
      pattern.lastIndex = 0
      return result
    }
  }

  const glob = getMatcherString(pattern, cwd)
  const matcher = picomatch(glob, { dot: true })
  return (id: string) => {
    const normalizedId = slash(id)
    return matcher(normalizedId)
  }
}

function patternToCodeFilter(pattern: string | RegExp): PluginFilter {
  if (pattern instanceof RegExp) {
    return (code: string) => {
      const result = pattern.test(code)
      pattern.lastIndex = 0
      return result
    }
  }
  return (code: string) => code.includes(pattern)
}

function createFilter(
  exclude: Array<PluginFilter> | undefined,
  include: Array<PluginFilter> | undefined,
): PluginFilter | undefined {
  if (!exclude && !include) {
    return
  }

  return (input) => {
    if (exclude?.some((filter) => filter(input))) {
      return false
    }
    if (include?.some((filter) => filter(input))) {
      return true
    }
    return !(include && include.length > 0)
  }
}

function normalizeFilter(filter: StringFilter): NormalizedStringFilter {
  if (typeof filter === 'string' || filter instanceof RegExp) {
    return {
      include: [filter],
    }
  }
  if (Array.isArray(filter)) {
    return {
      include: filter,
    }
  }
  return {
    include: filter.include ? arraify(filter.include) : undefined,
    exclude: filter.exclude ? arraify(filter.exclude) : undefined,
  }
}

export function createIdFilter(
  filter: StringFilter | undefined,
  cwd = process.cwd(),
): PluginFilter | undefined {
  if (!filter) return
  const { exclude, include } = normalizeFilter(filter)
  const excludeFilter = exclude?.map((p) => patternToIdFilter(p, cwd))
  const includeFilter = include?.map((p) => patternToIdFilter(p, cwd))
  return createFilter(excludeFilter, includeFilter)
}

export function createCodeFilter(
  filter: StringFilter | undefined,
): PluginFilter | undefined {
  if (!filter) return
  const { exclude, include } = normalizeFilter(filter)
  const excludeFilter = exclude?.map(patternToCodeFilter)
  const includeFilter = include?.map(patternToCodeFilter)
  return createFilter(excludeFilter, includeFilter)
}

export function createFilterForTransform(
  idFilter: StringFilter | undefined,
  codeFilter: StringFilter | undefined,
  cwd?: string,
): TransformHookFilter | undefined {
  if (!idFilter && !codeFilter) return
  const idFilterFn = createIdFilter(idFilter, cwd)
  const codeFilterFn = createCodeFilter(codeFilter)
  return (id, code) => {
    let fallback = true
    if (idFilterFn) {
      fallback &&= idFilterFn(id)
    }
    if (!fallback) {
      return false
    }

    if (codeFilterFn) {
      fallback &&= codeFilterFn(code)
    }
    return fallback
  }
}



================================================
FILE: packages/vite/src/node/plugins/preAlias.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import type {
  Alias,
  AliasOptions,
  DepOptimizationOptions,
  DevEnvironment,
  ResolvedConfig,
} from '..'
import type { Plugin } from '../plugin'
import {
  bareImportRE,
  isInNodeModules,
  isOptimizable,
  moduleListContains,
} from '../utils'
import { cleanUrl, withTrailingSlash } from '../../shared/utils'
import { isDepOptimizationDisabled } from '../optimizer'
import { tryOptimizedResolve } from './resolve'

/**
 * A plugin to avoid an aliased AND optimized dep from being aliased in src
 */
export function preAliasPlugin(config: ResolvedConfig): Plugin {
  const findPatterns = getAliasPatterns(config.resolve.alias)
  return {
    name: 'vite:pre-alias',
    applyToEnvironment(environment) {
      return !isDepOptimizationDisabled(environment.config.optimizeDeps)
    },
    async resolveId(id, importer, options) {
      const environment = this.environment as DevEnvironment
      const ssr = environment.config.consumer === 'server'
      const depsOptimizer = environment.depsOptimizer
      if (
        importer &&
        depsOptimizer &&
        bareImportRE.test(id) &&
        !options.scan &&
        id !== '@vite/client' &&
        id !== '@vite/env'
      ) {
        if (findPatterns.find((pattern) => matches(pattern, id))) {
          const optimizedId = await tryOptimizedResolve(
            depsOptimizer,
            id,
            importer,
            config.resolve.preserveSymlinks,
            config.packageCache,
          )
          if (optimizedId) {
            return optimizedId // aliased dep already optimized
          }
          if (depsOptimizer.options.noDiscovery) {
            return
          }
          const resolved = await this.resolve(id, importer, options)
          if (resolved && !depsOptimizer.isOptimizedDepFile(resolved.id)) {
            const optimizeDeps = depsOptimizer.options
            const resolvedId = cleanUrl(resolved.id)
            const isVirtual = resolvedId === id || resolvedId.includes('\0')
            if (
              !isVirtual &&
              fs.existsSync(resolvedId) &&
              !moduleListContains(optimizeDeps.exclude, id) &&
              path.isAbsolute(resolvedId) &&
              (isInNodeModules(resolvedId) ||
                optimizeDeps.include?.includes(id)) &&
              isOptimizable(resolvedId, optimizeDeps) &&
              (!ssr || optimizeAliasReplacementForSSR(resolvedId, optimizeDeps))
            ) {
              // aliased dep has not yet been optimized
              const optimizedInfo = depsOptimizer!.registerMissingImport(
                id,
                resolvedId,
              )
              return { id: depsOptimizer!.getOptimizedDepId(optimizedInfo) }
            }
          }
          return resolved
        }
      }
    },
  }
}

function optimizeAliasReplacementForSSR(
  id: string,
  optimizeDeps: DepOptimizationOptions,
) {
  if (optimizeDeps.include?.includes(id)) {
    return true
  }
  // In the regular resolution, the default for non-external modules is to
  // be optimized if they are CJS. Here, we don't have the package id but
  // only the replacement file path. We could find the package.json from
  // the id and respect the same default in the future.
  // Default to not optimize an aliased replacement for now, forcing the
  // user to explicitly add it to the ssr.optimizeDeps.include list.
  return false
}

// In sync with rollup plugin alias logic
function matches(pattern: string | RegExp, importee: string) {
  if (pattern instanceof RegExp) {
    return pattern.test(importee)
  }
  if (importee.length < pattern.length) {
    return false
  }
  if (importee === pattern) {
    return true
  }
  return importee.startsWith(withTrailingSlash(pattern))
}

function getAliasPatterns(
  entries: (AliasOptions | undefined) & Alias[],
): (string | RegExp)[] {
  if (Array.isArray(entries)) {
    return entries.map((entry) => entry.find)
  }
  return Object.entries(entries).map(([find]) => find)
}

export function getAliasPatternMatcher(
  entries: (AliasOptions | undefined) & Alias[],
): (importee: string) => boolean {
  const patterns = getAliasPatterns(entries)
  return (importee: string) =>
    patterns.some((pattern) => matches(pattern, importee))
}



================================================
FILE: packages/vite/src/node/plugins/prepareOutDir.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import colors from 'picocolors'
import type { Plugin } from '../plugin'
import { getResolvedOutDirs, resolveEmptyOutDir } from '../watch'
import type { Environment } from '../environment'
import { copyDir, emptyDir, normalizePath } from '../utils'
import { withTrailingSlash } from '../../shared/utils'

export function prepareOutDirPlugin(): Plugin {
  const rendered = new Set<Environment>()
  return {
    name: 'vite:prepare-out-dir',
    options() {
      rendered.delete(this.environment)
    },
    renderStart: {
      order: 'pre',
      handler() {
        if (rendered.has(this.environment)) {
          return
        }
        rendered.add(this.environment)

        const { config } = this.environment
        if (config.build.write) {
          const { root, build: options } = config
          const resolvedOutDirs = getResolvedOutDirs(
            root,
            options.outDir,
            options.rollupOptions.output,
          )
          const emptyOutDir = resolveEmptyOutDir(
            options.emptyOutDir,
            root,
            resolvedOutDirs,
            this.environment.logger,
          )
          prepareOutDir(resolvedOutDirs, emptyOutDir, this.environment)
        }
      },
    },
  }
}

function prepareOutDir(
  outDirs: Set<string>,
  emptyOutDir: boolean | null,
  environment: Environment,
) {
  const { publicDir } = environment.config
  const outDirsArray = [...outDirs]
  for (const outDir of outDirs) {
    if (emptyOutDir !== false && fs.existsSync(outDir)) {
      // skip those other outDirs which are nested in current outDir
      const skipDirs = outDirsArray
        .map((dir) => {
          const relative = path.relative(outDir, dir)
          if (
            relative &&
            !relative.startsWith('..') &&
            !path.isAbsolute(relative)
          ) {
            return relative
          }
          return ''
        })
        .filter(Boolean)
      emptyDir(outDir, [...skipDirs, '.git'])
    }
    if (
      environment.config.build.copyPublicDir &&
      publicDir &&
      fs.existsSync(publicDir)
    ) {
      if (!areSeparateFolders(outDir, publicDir)) {
        environment.logger.warn(
          colors.yellow(
            `\n${colors.bold(
              `(!)`,
            )} The public directory feature may not work correctly. outDir ${colors.white(
              colors.dim(outDir),
            )} and publicDir ${colors.white(
              colors.dim(publicDir),
            )} are not separate folders.\n`,
          ),
        )
      }
      copyDir(publicDir, outDir)
    }
  }
}

function areSeparateFolders(a: string, b: string) {
  const na = normalizePath(a)
  const nb = normalizePath(b)
  return (
    na !== nb &&
    !na.startsWith(withTrailingSlash(nb)) &&
    !nb.startsWith(withTrailingSlash(na))
  )
}



================================================
FILE: packages/vite/src/node/plugins/reporter.ts
================================================
import path from 'node:path'
import { gzip } from 'node:zlib'
import { promisify } from 'node:util'
import colors from 'picocolors'
import type { OutputBundle } from 'rollup'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '../config'
import type { Environment } from '../environment'
import { perEnvironmentState } from '../environment'
import { isDefined, isInNodeModules, normalizePath } from '../utils'
import { LogLevels } from '../logger'
import { withTrailingSlash } from '../../shared/utils'

const groups = [
  { name: 'Assets', color: colors.green },
  { name: 'CSS', color: colors.magenta },
  { name: 'JS', color: colors.cyan },
]
type LogEntry = {
  name: string
  group: (typeof groups)[number]['name']
  size: number
  compressedSize: number | null
  mapSize: number | null
}

const COMPRESSIBLE_ASSETS_RE = /\.(?:html|json|svg|txt|xml|xhtml|wasm)$/

export function buildReporterPlugin(config: ResolvedConfig): Plugin {
  const compress = promisify(gzip)

  const numberFormatter = new Intl.NumberFormat('en', {
    maximumFractionDigits: 2,
    minimumFractionDigits: 2,
  })
  const displaySize = (bytes: number) => {
    return `${numberFormatter.format(bytes / 1000)} kB`
  }

  const tty = process.stdout.isTTY && !process.env.CI
  const shouldLogInfo = LogLevels[config.logLevel || 'info'] >= LogLevels.info

  const modulesReporter = shouldLogInfo
    ? perEnvironmentState((environment: Environment) => {
        let hasTransformed = false
        let transformedCount = 0

        const logTransform = throttle((id: string) => {
          writeLine(
            `transforming (${transformedCount}) ${colors.dim(
              path.relative(config.root, id),
            )}`,
          )
        })

        return {
          reset() {
            transformedCount = 0
          },
          register(id: string) {
            transformedCount++
            if (!tty) {
              if (!hasTransformed) {
                config.logger.info(`transforming...`)
              }
            } else {
              if (id.includes(`?`)) return
              logTransform(id)
            }
            hasTransformed = true
          },
          log() {
            if (tty) {
              clearLine()
            }
            environment.logger.info(
              `${colors.green(`✓`)} ${transformedCount} modules transformed.`,
            )
          },
        }
      })
    : undefined

  const chunksReporter = perEnvironmentState((environment: Environment) => {
    let hasRenderedChunk = false
    let hasCompressChunk = false
    let chunkCount = 0
    let compressedCount = 0

    async function getCompressedSize(
      code: string | Uint8Array,
    ): Promise<number | null> {
      if (
        environment.config.consumer !== 'client' ||
        !environment.config.build.reportCompressedSize
      ) {
        return null
      }
      if (shouldLogInfo && !hasCompressChunk) {
        if (!tty) {
          config.logger.info('computing gzip size...')
        } else {
          writeLine('computing gzip size (0)...')
        }
        hasCompressChunk = true
      }
      const compressed = await compress(
        typeof code === 'string' ? code : Buffer.from(code),
      )
      compressedCount++
      if (shouldLogInfo && tty) {
        writeLine(`computing gzip size (${compressedCount})...`)
      }
      return compressed.length
    }

    return {
      reset() {
        chunkCount = 0
        compressedCount = 0
      },
      register() {
        chunkCount++
        if (shouldLogInfo) {
          if (!tty) {
            if (!hasRenderedChunk) {
              environment.logger.info('rendering chunks...')
            }
          } else {
            writeLine(`rendering chunks (${chunkCount})...`)
          }
          hasRenderedChunk = true
        }
      },
      async log(output: OutputBundle, outDir?: string) {
        const chunkLimit = environment.config.build.chunkSizeWarningLimit

        let hasLargeChunks = false

        if (shouldLogInfo) {
          const entries = (
            await Promise.all(
              Object.values(output).map(
                async (chunk): Promise<LogEntry | null> => {
                  if (chunk.type === 'chunk') {
                    return {
                      name: chunk.fileName,
                      group: 'JS',
                      size: Buffer.byteLength(chunk.code),
                      compressedSize: await getCompressedSize(chunk.code),
                      mapSize: chunk.map
                        ? Buffer.byteLength(chunk.map.toString())
                        : null,
                    }
                  } else {
                    if (chunk.fileName.endsWith('.map')) return null
                    const isCSS = chunk.fileName.endsWith('.css')
                    const isCompressible =
                      isCSS || COMPRESSIBLE_ASSETS_RE.test(chunk.fileName)
                    return {
                      name: chunk.fileName,
                      group: isCSS ? 'CSS' : 'Assets',
                      size: Buffer.byteLength(chunk.source),
                      mapSize: null, // Rollup doesn't support CSS maps?
                      compressedSize: isCompressible
                        ? await getCompressedSize(chunk.source)
                        : null,
                    }
                  }
                },
              ),
            )
          ).filter(isDefined)
          if (tty) clearLine()

          let longest = 0
          let biggestSize = 0
          let biggestMap = 0
          let biggestCompressSize = 0
          for (const entry of entries) {
            if (entry.name.length > longest) longest = entry.name.length
            if (entry.size > biggestSize) biggestSize = entry.size
            if (entry.mapSize && entry.mapSize > biggestMap) {
              biggestMap = entry.mapSize
            }
            if (
              entry.compressedSize &&
              entry.compressedSize > biggestCompressSize
            ) {
              biggestCompressSize = entry.compressedSize
            }
          }

          const sizePad = displaySize(biggestSize).length
          const mapPad = displaySize(biggestMap).length
          const compressPad = displaySize(biggestCompressSize).length

          const relativeOutDir = normalizePath(
            path.relative(
              config.root,
              path.resolve(
                config.root,
                outDir ?? environment.config.build.outDir,
              ),
            ),
          )
          const assetsDir = path.join(environment.config.build.assetsDir, '/')

          for (const group of groups) {
            const filtered = entries.filter((e) => e.group === group.name)
            if (!filtered.length) continue
            for (const entry of filtered.sort((a, z) => a.size - z.size)) {
              const isLarge =
                group.name === 'JS' && entry.size / 1000 > chunkLimit
              if (isLarge) hasLargeChunks = true
              const sizeColor = isLarge ? colors.yellow : colors.dim
              let log = colors.dim(withTrailingSlash(relativeOutDir))
              log +=
                !config.build.lib &&
                entry.name.startsWith(withTrailingSlash(assetsDir))
                  ? colors.dim(assetsDir) +
                    group.color(
                      entry.name
                        .slice(assetsDir.length)
                        .padEnd(longest + 2 - assetsDir.length),
                    )
                  : group.color(entry.name.padEnd(longest + 2))
              log += colors.bold(
                sizeColor(displaySize(entry.size).padStart(sizePad)),
              )
              if (entry.compressedSize) {
                log += colors.dim(
                  ` │ gzip: ${displaySize(entry.compressedSize).padStart(
                    compressPad,
                  )}`,
                )
              }
              if (entry.mapSize) {
                log += colors.dim(
                  ` │ map: ${displaySize(entry.mapSize).padStart(mapPad)}`,
                )
              }
              config.logger.info(log)
            }
          }
        } else {
          hasLargeChunks = Object.values(output).some((chunk) => {
            return (
              chunk.type === 'chunk' && chunk.code.length / 1000 > chunkLimit
            )
          })
        }

        if (
          hasLargeChunks &&
          environment.config.build.minify &&
          !config.build.lib &&
          environment.config.consumer === 'client'
        ) {
          environment.logger.warn(
            colors.yellow(
              `\n(!) Some chunks are larger than ${chunkLimit} kB after minification. Consider:\n` +
                `- Using dynamic import() to code-split the application\n` +
                `- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks\n` +
                `- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`,
            ),
          )
        }
      },
    }
  })

  return {
    name: 'vite:reporter',
    sharedDuringBuild: true,
    perEnvironmentStartEndDuringDev: true,

    ...(modulesReporter
      ? {
          transform(_, id) {
            modulesReporter(this).register(id)
          },

          buildStart() {
            modulesReporter(this).reset()
          },

          buildEnd() {
            modulesReporter(this).log()
          },
        }
      : {}),

    renderStart() {
      chunksReporter(this).reset()
    },

    renderChunk(_, chunk, options) {
      if (!options.inlineDynamicImports) {
        for (const id of chunk.moduleIds) {
          const module = this.getModuleInfo(id)
          if (!module) continue
          // When a dynamic importer shares a chunk with the imported module,
          // warn that the dynamic imported module will not be moved to another chunk (#12850).
          if (module.importers.length && module.dynamicImporters.length) {
            // Filter out the intersection of dynamic importers and sibling modules in
            // the same chunk. The intersecting dynamic importers' dynamic import is not
            // expected to work. Note we're only detecting the direct ineffective
            // dynamic import here.
            const detectedIneffectiveDynamicImport =
              module.dynamicImporters.some(
                (id) => !isInNodeModules(id) && chunk.moduleIds.includes(id),
              )
            if (detectedIneffectiveDynamicImport) {
              this.warn(
                `\n(!) ${
                  module.id
                } is dynamically imported by ${module.dynamicImporters.join(
                  ', ',
                )} but also statically imported by ${module.importers.join(
                  ', ',
                )}, dynamic import will not move module into another chunk.\n`,
              )
            }
          }
        }
      }

      chunksReporter(this).register()
    },

    generateBundle() {
      if (shouldLogInfo && tty) clearLine()
    },

    async writeBundle({ dir }, output) {
      await chunksReporter(this).log(output, dir)
    },
  }
}

function writeLine(output: string) {
  clearLine()
  if (output.length < process.stdout.columns) {
    process.stdout.write(output)
  } else {
    process.stdout.write(output.substring(0, process.stdout.columns - 1))
  }
}

function clearLine() {
  process.stdout.clearLine(0)
  process.stdout.cursorTo(0)
}

function throttle(fn: Function) {
  let timerHandle: NodeJS.Timeout | null = null
  return (...args: any[]) => {
    if (timerHandle) return
    fn(...args)
    timerHandle = setTimeout(() => {
      timerHandle = null
    }, 100)
  }
}



================================================
FILE: packages/vite/src/node/plugins/resolve.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import colors from 'picocolors'
import type { PartialResolvedId } from 'rollup'
import { exports, imports } from 'resolve.exports'
import { hasESMSyntax } from 'mlly'
import { prefixRegex } from '@rolldown/pluginutils'
import type { Plugin } from '../plugin'
import {
  CLIENT_ENTRY,
  DEP_VERSION_RE,
  DEV_PROD_CONDITION,
  ENV_ENTRY,
  FS_PREFIX,
  SPECIAL_QUERY_RE,
} from '../constants'
import {
  bareImportRE,
  createDebugger,
  deepImportRE,
  fsPathFromId,
  getNpmPackageName,
  injectQuery,
  isBuiltin,
  isDataUrl,
  isExternalUrl,
  isInNodeModules,
  isNodeLikeBuiltin,
  isNonDriveRelativeAbsolutePath,
  isObject,
  isOptimizable,
  normalizePath,
  safeRealpathSync,
  tryStatSync,
} from '../utils'
import { optimizedDepInfoFromFile, optimizedDepInfoFromId } from '../optimizer'
import type { DepsOptimizer } from '../optimizer'
import type { PackageCache, PackageData } from '../packages'
import { canExternalizeFile, shouldExternalize } from '../external'
import {
  findNearestMainPackageData,
  findNearestPackageData,
  loadPackageData,
  resolvePackageData,
} from '../packages'
import {
  cleanUrl,
  isWindows,
  slash,
  splitFileAndPostfix,
  withTrailingSlash,
} from '../../shared/utils'

const normalizedClientEntry = normalizePath(CLIENT_ENTRY)
const normalizedEnvEntry = normalizePath(ENV_ENTRY)

const ERR_RESOLVE_PACKAGE_ENTRY_FAIL = 'ERR_RESOLVE_PACKAGE_ENTRY_FAIL'

// special id for paths marked with browser: false
// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
export const browserExternalId = '__vite-browser-external'
// special id for packages that are optional peer deps
export const optionalPeerDepId = '__vite-optional-peer-dep'

const subpathImportsPrefix = '#'

const relativePrefixRE = /^\.\.?(?:[/\\]|$)/
const startsWithWordCharRE = /^\w/

const debug = createDebugger('vite:resolve-details', {
  onlyWhenFocused: true,
})

export interface EnvironmentResolveOptions {
  /**
   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
   */
  mainFields?: string[]
  conditions?: string[]
  externalConditions?: string[]
  /**
   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
   */
  extensions?: string[]
  dedupe?: string[]
  // TODO: better abstraction that works for the client environment too?
  /**
   * Prevent listed dependencies from being externalized and will get bundled in build.
   * Only works in server environments for now. Previously this was `ssr.noExternal`.
   * @experimental
   */
  noExternal?: string | RegExp | (string | RegExp)[] | true
  /**
   * Externalize the given dependencies and their transitive dependencies.
   * Only works in server environments for now. Previously this was `ssr.external`.
   * @experimental
   */
  external?: string[] | true
  /**
   * Array of strings or regular expressions that indicate what modules are builtin for the environment.
   */
  builtins?: (string | RegExp)[]
}

export interface ResolveOptions extends EnvironmentResolveOptions {
  /**
   * @default false
   */
  preserveSymlinks?: boolean
}

interface ResolvePluginOptions {
  root: string
  isBuild: boolean
  isProduction: boolean
  packageCache?: PackageCache
  /**
   * src code mode also attempts the following:
   * - resolving /xxx as URLs
   * - resolving bare imports from optimized deps
   */
  asSrc?: boolean
  tryIndex?: boolean
  tryPrefix?: string
  preferRelative?: boolean
  isRequire?: boolean
  // True when resolving during the scan phase to discover dependencies
  scan?: boolean

  /**
   * Optimize deps during dev, defaults to false // TODO: Review default
   * @internal
   */
  optimizeDeps?: boolean

  /**
   * Externalize using `resolve.external` and `resolve.noExternal` when running a build in
   * a server environment. Defaults to false (only for createResolver)
   * @internal
   */
  externalize?: boolean

  /**
   * Set by createResolver, we only care about the resolved id. moduleSideEffects
   * and other fields are discarded so we can avoid computing them.
   * @internal
   */
  idOnly?: boolean
}

export interface InternalResolveOptions
  extends Required<ResolveOptions>,
    ResolvePluginOptions {}

// Defined ResolveOptions are used to overwrite the values for all environments
// It is used when creating custom resolvers (for CSS, scanning, etc)
export interface ResolvePluginOptionsWithOverrides
  extends ResolveOptions,
    ResolvePluginOptions {}

export function resolvePlugin(
  resolveOptions: ResolvePluginOptionsWithOverrides,
): Plugin {
  const { root, isProduction, asSrc, preferRelative = false } = resolveOptions

  // In unix systems, absolute paths inside root first needs to be checked as an
  // absolute URL (/root/root/path-to-file) resulting in failed checks before falling
  // back to checking the path as absolute. If /root/root isn't a valid path, we can
  // avoid these checks. Absolute paths inside root are common in user code as many
  // paths are resolved by the user. For example for an alias.
  const rootInRoot = tryStatSync(path.join(root, root))?.isDirectory() ?? false

  return {
    name: 'vite:resolve',

    resolveId: {
      filter: {
        id: {
          exclude: /^(?:\0|\/?virtual:)/, // `/virtual:` is used when it's injected directly in html/client code
        },
      },
      async handler(id, importer, resolveOpts) {
        // The resolve plugin is used for createIdResolver and the depsOptimizer should be
        // disabled in that case, so deps optimization is opt-in when creating the plugin.
        const depsOptimizer =
          resolveOptions.optimizeDeps && this.environment.mode === 'dev'
            ? this.environment.depsOptimizer
            : undefined

        if (id.startsWith(browserExternalId)) {
          return id
        }

        // this is passed by @rollup/plugin-commonjs
        const isRequire: boolean =
          resolveOpts.custom?.['node-resolve']?.isRequire ?? false

        const currentEnvironmentOptions = this.environment.config

        const options: InternalResolveOptions = {
          isRequire,
          ...currentEnvironmentOptions.resolve,
          ...resolveOptions, // plugin options + resolve options overrides
          scan: resolveOpts.scan ?? resolveOptions.scan,
        }

        const resolvedImports = resolveSubpathImports(id, importer, options)
        if (resolvedImports) {
          id = resolvedImports

          if (resolveOpts.custom?.['vite:import-glob']?.isSubImportsPattern) {
            return normalizePath(path.join(root, id))
          }
        }

        let res: string | PartialResolvedId | undefined

        // resolve pre-bundled deps requests, these could be resolved by
        // tryFileResolve or /fs/ resolution but these files may not yet
        // exists if we are in the middle of a deps re-processing
        if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) {
          const optimizedPath = id.startsWith(FS_PREFIX)
            ? fsPathFromId(id)
            : normalizePath(path.resolve(root, id.slice(1)))
          return optimizedPath
        }

        // explicit fs paths that starts with /@fs/*
        if (asSrc && id.startsWith(FS_PREFIX)) {
          res = fsPathFromId(id)
          // We don't need to resolve these paths since they are already resolved
          // always return here even if res doesn't exist since /@fs/ is explicit
          // if the file doesn't exist it should be a 404.
          debug?.(`[@fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
          return ensureVersionQuery(res, id, options, depsOptimizer)
        }

        // URL
        // /foo -> /fs-root/foo
        if (
          asSrc &&
          id[0] === '/' &&
          (rootInRoot || !id.startsWith(withTrailingSlash(root)))
        ) {
          const fsPath = path.resolve(root, id.slice(1))
          if ((res = tryFsResolve(fsPath, options))) {
            debug?.(`[url] ${colors.cyan(id)} -> ${colors.dim(res)}`)
            return ensureVersionQuery(res, id, options, depsOptimizer)
          }
        }

        // relative
        if (
          relativePrefixRE.test(id) ||
          ((preferRelative ||
            resolveOpts.isEntry ||
            importer?.endsWith('.html')) &&
            startsWithWordCharRE.test(id))
        ) {
          const basedir = importer ? path.dirname(importer) : process.cwd()
          const fsPath = path.resolve(basedir, id)
          // handle browser field mapping for relative imports

          const normalizedFsPath = normalizePath(fsPath)

          if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
            // Optimized files could not yet exist in disk, resolve to the full path
            // Inject the current browserHash version if the path doesn't have one
            if (!options.isBuild && !DEP_VERSION_RE.test(normalizedFsPath)) {
              const browserHash = optimizedDepInfoFromFile(
                depsOptimizer.metadata,
                normalizedFsPath,
              )?.browserHash
              if (browserHash) {
                return injectQuery(normalizedFsPath, `v=${browserHash}`)
              }
            }
            return normalizedFsPath
          }

          if (
            options.mainFields.includes('browser') &&
            (res = tryResolveBrowserMapping(fsPath, importer, options, true))
          ) {
            return res
          }

          if ((res = tryFsResolve(fsPath, options))) {
            res = ensureVersionQuery(res, id, options, depsOptimizer)
            debug?.(`[relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)

            if (!options.idOnly && !options.scan && options.isBuild) {
              const resPkg = findNearestPackageData(
                path.dirname(res),
                options.packageCache,
              )
              if (resPkg) {
                return {
                  id: res,
                  moduleSideEffects: resPkg.hasSideEffects(res),
                }
              }
            }
            return res
          }
        }

        // file url to path with preserving hash/search
        if (id.startsWith('file://')) {
          const { file, postfix } = splitFileAndPostfix(id)
          id = fileURLToPath(file) + postfix
        }

        // drive relative fs paths (only windows)
        if (isWindows && id[0] === '/') {
          const basedir = importer ? path.dirname(importer) : process.cwd()
          const fsPath = path.resolve(basedir, id)
          if ((res = tryFsResolve(fsPath, options))) {
            debug?.(`[drive-relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)
            return ensureVersionQuery(res, id, options, depsOptimizer)
          }
        }

        // absolute fs paths
        if (
          isNonDriveRelativeAbsolutePath(id) &&
          (res = tryFsResolve(id, options))
        ) {
          debug?.(`[fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
          return ensureVersionQuery(res, id, options, depsOptimizer)
        }

        // external
        if (isExternalUrl(id)) {
          return options.idOnly ? id : { id, external: true }
        }

        // data uri: pass through (this only happens during build and will be
        // handled by dedicated plugin)
        if (isDataUrl(id)) {
          return null
        }

        // bare package imports, perform node resolve
        if (bareImportRE.test(id)) {
          const external =
            options.externalize &&
            options.isBuild &&
            currentEnvironmentOptions.consumer === 'server' &&
            shouldExternalize(this.environment, id, importer)
          if (
            !external &&
            asSrc &&
            depsOptimizer &&
            !options.scan &&
            (res = await tryOptimizedResolve(
              depsOptimizer,
              id,
              importer,
              options.preserveSymlinks,
              options.packageCache,
            ))
          ) {
            return res
          }

          if (
            options.mainFields.includes('browser') &&
            (res = tryResolveBrowserMapping(
              id,
              importer,
              options,
              false,
              external,
            ))
          ) {
            return res
          }

          if (
            (res = tryNodeResolve(
              id,
              importer,
              options,
              depsOptimizer,
              external,
            ))
          ) {
            return res
          }

          // built-ins
          // externalize if building for a server environment, otherwise redirect to an empty module
          if (
            currentEnvironmentOptions.consumer === 'server' &&
            isBuiltin(options.builtins, id)
          ) {
            return options.idOnly
              ? id
              : { id, external: true, moduleSideEffects: false }
          } else if (
            currentEnvironmentOptions.consumer === 'server' &&
            isNodeLikeBuiltin(id)
          ) {
            if (!(options.external === true || options.external.includes(id))) {
              let message = `Automatically externalized node built-in module "${id}"`
              if (importer) {
                message += ` imported from "${path.relative(
                  process.cwd(),
                  importer,
                )}"`
              }
              message += `. Consider adding it to environments.${this.environment.name}.external if it is intended.`
              this.warn(message)
            }

            return options.idOnly
              ? id
              : { id, external: true, moduleSideEffects: false }
          } else if (
            currentEnvironmentOptions.consumer === 'client' &&
            isNodeLikeBuiltin(id)
          ) {
            if (
              options.noExternal === true &&
              // if both noExternal and external are true, noExternal will take the higher priority and bundle it.
              // only if the id is explicitly listed in external, we will externalize it and skip this error.
              (options.external === true || !options.external.includes(id))
            ) {
              let message = `Cannot bundle built-in module "${id}"`
              if (importer) {
                message += ` imported from "${path.relative(
                  process.cwd(),
                  importer,
                )}"`
              }
              message += `. Consider disabling environments.${this.environment.name}.noExternal or remove the built-in dependency.`
              this.error(message)
            }

            if (!asSrc) {
              debug?.(
                `externalized node built-in "${id}" to empty module. ` +
                  `(imported by: ${colors.white(colors.dim(importer))})`,
              )
            } else if (isProduction) {
              this.warn(
                `Module "${id}" has been externalized for browser compatibility, imported by "${importer}". ` +
                  `See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`,
              )
            }
            return isProduction
              ? browserExternalId
              : `${browserExternalId}:${id}`
          }
        }

        debug?.(`[fallthrough] ${colors.dim(id)}`)
      },
    },

    load: {
      filter: {
        id: [prefixRegex(browserExternalId), prefixRegex(optionalPeerDepId)],
      },
      handler(id) {
        if (id.startsWith(browserExternalId)) {
          if (isProduction) {
            return `export default {}`
          } else {
            id = id.slice(browserExternalId.length + 1)
            return `\
  export default new Proxy({}, {
    get(_, key) {
      throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  })`
          }
        }
        if (id.startsWith(optionalPeerDepId)) {
          const [, peerDep, parentDep, isRequire] = id.split(':')
          // rollup + @rollup/plugin-commonjs hoists dynamic `require`s by default
          // If we add a `throw` statement, it will be injected to the top-level and break the whole bundle
          // Instead, we mock the module for now
          // This can be fixed when we migrate to rolldown
          if (isRequire === 'true' && isProduction) {
            return 'export default {}'
          }
          return (
            'export default {};' +
            `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}".${isProduction ? '' : ' Is it installed?'}\`)`
          )
        }
      },
    },
  }
}

function resolveSubpathImports(
  id: string,
  importer: string | undefined,
  options: InternalResolveOptions,
) {
  if (!importer || !id.startsWith(subpathImportsPrefix)) return
  const basedir = path.dirname(importer)
  const pkgData = findNearestPackageData(basedir, options.packageCache)
  if (!pkgData) return

  let { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id.slice(1))
  idWithoutPostfix = '#' + idWithoutPostfix

  let importsPath = resolveExportsOrImports(
    pkgData.data,
    idWithoutPostfix,
    options,
    'imports',
  )

  if (importsPath?.[0] === '.') {
    importsPath = path.relative(basedir, path.join(pkgData.dir, importsPath))

    if (importsPath[0] !== '.') {
      importsPath = `./${importsPath}`
    }
  }

  return importsPath + postfix
}

function ensureVersionQuery(
  resolved: string,
  id: string,
  options: InternalResolveOptions,
  depsOptimizer?: DepsOptimizer,
): string {
  if (
    !options.isBuild &&
    !options.scan &&
    depsOptimizer &&
    !(resolved === normalizedClientEntry || resolved === normalizedEnvEntry)
  ) {
    // Ensure that direct imports of node_modules have the same version query
    // as if they would have been imported through a bare import
    // Use the original id to do the check as the resolved id may be the real
    // file path after symlinks resolution
    const isNodeModule = isInNodeModules(id) || isInNodeModules(resolved)

    if (isNodeModule && !DEP_VERSION_RE.test(resolved)) {
      const versionHash = depsOptimizer.metadata.browserHash
      if (versionHash && isOptimizable(resolved, depsOptimizer.options)) {
        resolved = injectQuery(resolved, `v=${versionHash}`)
      }
    }
  }
  return resolved
}

export function tryFsResolve(
  fsPath: string,
  options: InternalResolveOptions,
  tryIndex = true,
  skipPackageJson = false,
): string | undefined {
  // Dependencies like es5-ext use `#` in their paths. We don't support `#` in user
  // source code so we only need to perform the check for dependencies.
  // We don't support `?` in node_modules paths, so we only need to check in this branch.
  const hashIndex = fsPath.indexOf('#')
  if (hashIndex >= 0 && isInNodeModules(fsPath)) {
    const queryIndex = fsPath.indexOf('?')
    // We only need to check foo#bar?baz and foo#bar, ignore foo?bar#baz
    if (queryIndex < 0 || queryIndex > hashIndex) {
      const file = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath
      const res = tryCleanFsResolve(file, options, tryIndex, skipPackageJson)
      if (res) return res + fsPath.slice(file.length)
    }
  }

  const { file, postfix } = splitFileAndPostfix(fsPath)
  const res = tryCleanFsResolve(file, options, tryIndex, skipPackageJson)
  if (res) return res + postfix
}

const knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/
const isPossibleTsOutput = (url: string): boolean => knownTsOutputRE.test(url)

function tryCleanFsResolve(
  file: string,
  options: InternalResolveOptions,
  tryIndex = true,
  skipPackageJson = false,
): string | undefined {
  const { tryPrefix, extensions, preserveSymlinks } = options

  // Optimization to get the real type or file type (directory, file, other)
  const fileResult = tryResolveRealFileOrType(file, options.preserveSymlinks)

  if (fileResult?.path) return fileResult.path

  let res: string | undefined

  // If path.dirname is a valid directory, try extensions and ts resolution logic
  const possibleJsToTs = isPossibleTsOutput(file)
  if (possibleJsToTs || options.extensions.length || tryPrefix) {
    const dirPath = path.dirname(file)
    if (isDirectory(dirPath)) {
      if (possibleJsToTs) {
        // try resolve .js, .mjs, .cjs or .jsx import to typescript file
        const fileExt = path.extname(file)
        const fileName = file.slice(0, -fileExt.length)
        if (
          (res = tryResolveRealFile(
            fileName + fileExt.replace('js', 'ts'),
            preserveSymlinks,
          ))
        )
          return res
        // for .js, also try .tsx
        if (
          fileExt === '.js' &&
          (res = tryResolveRealFile(fileName + '.tsx', preserveSymlinks))
        )
          return res
      }

      if (
        (res = tryResolveRealFileWithExtensions(
          file,
          extensions,
          preserveSymlinks,
        ))
      )
        return res

      if (tryPrefix) {
        const prefixed = `${dirPath}/${options.tryPrefix}${path.basename(file)}`

        if ((res = tryResolveRealFile(prefixed, preserveSymlinks))) return res

        if (
          (res = tryResolveRealFileWithExtensions(
            prefixed,
            extensions,
            preserveSymlinks,
          ))
        )
          return res
      }
    }
  }

  if (tryIndex && fileResult?.type === 'directory') {
    // Path points to a directory, check for package.json and entry and /index file
    const dirPath = file

    if (!skipPackageJson) {
      let pkgPath = `${dirPath}/package.json`
      try {
        if (fs.existsSync(pkgPath)) {
          if (!options.preserveSymlinks) {
            pkgPath = safeRealpathSync(pkgPath)
          }
          // path points to a node package
          const pkg = loadPackageData(pkgPath)
          return resolvePackageEntry(dirPath, pkg, options)
        }
      } catch (e) {
        // This check is best effort, so if an entry is not found, skip error for now
        if (e.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e.code !== 'ENOENT')
          throw e
      }
    }

    if (
      (res = tryResolveRealFileWithExtensions(
        `${dirPath}/index`,
        extensions,
        preserveSymlinks,
      ))
    )
      return res

    if (tryPrefix) {
      if (
        (res = tryResolveRealFileWithExtensions(
          `${dirPath}/${options.tryPrefix}index`,
          extensions,
          preserveSymlinks,
        ))
      )
        return res
    }
  }
}

export function tryNodeResolve(
  id: string,
  importer: string | null | undefined,
  options: InternalResolveOptions,
  depsOptimizer?: DepsOptimizer,
  externalize?: boolean,
): PartialResolvedId | undefined {
  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options

  // check for deep import, e.g. "my-lib/foo"
  const deepMatch = deepImportRE.exec(id)
  // package name doesn't include postfixes
  // trim them to support importing package with queries (e.g. `import css from 'normalize.css?inline'`)
  const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id)

  let basedir: string
  if (dedupe.includes(pkgId)) {
    basedir = root
  } else if (
    importer &&
    path.isAbsolute(importer) &&
    // css processing appends `*` for importer
    (importer.endsWith('*') || fs.existsSync(cleanUrl(importer)))
  ) {
    basedir = path.dirname(importer)
  } else {
    basedir = root
  }

  const isModuleBuiltin = (id: string) => isBuiltin(options.builtins, id)

  let selfPkg = null
  if (!isModuleBuiltin(id) && !id.includes('\0') && bareImportRE.test(id)) {
    // check if it's a self reference dep.
    const selfPackageData = findNearestPackageData(basedir, packageCache)
    selfPkg =
      selfPackageData?.data.exports && selfPackageData.data.name === pkgId
        ? selfPackageData
        : null
  }

  const pkg =
    selfPkg ||
    resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache)
  if (!pkg) {
    // if import can't be found, check if it's an optional peer dep.
    // if so, we can resolve to a special id that errors only when imported.
    if (
      basedir !== root && // root has no peer dep
      !isModuleBuiltin(id) &&
      !id.includes('\0') &&
      bareImportRE.test(id)
    ) {
      const mainPkg = findNearestMainPackageData(basedir, packageCache)?.data
      if (mainPkg) {
        const pkgName = getNpmPackageName(id)
        if (
          pkgName != null &&
          mainPkg.peerDependencies?.[pkgName] &&
          mainPkg.peerDependenciesMeta?.[pkgName]?.optional
        ) {
          return {
            id: `${optionalPeerDepId}:${id}:${mainPkg.name}:${!!options.isRequire}`,
          }
        }
      }
    }
    return
  }

  const resolveId = deepMatch ? resolveDeepImport : resolvePackageEntry
  const unresolvedId = deepMatch ? '.' + id.slice(pkgId.length) : id

  let resolved = resolveId(unresolvedId, pkg, options, externalize)
  if (!resolved) {
    return
  }

  const processResult = (resolved: PartialResolvedId) => {
    if (!externalize) {
      return resolved
    }
    if (!canExternalizeFile(resolved.id)) {
      return resolved
    }

    let resolvedId = id
    if (
      deepMatch &&
      !pkg.data.exports &&
      path.extname(id) !== path.extname(resolved.id)
    ) {
      // id date-fns/locale
      // resolve.id ...date-fns/esm/locale/index.js
      const index = resolved.id.indexOf(id)
      if (index > -1) {
        resolvedId = resolved.id.slice(index)
        debug?.(
          `[processResult] ${colors.cyan(id)} -> ${colors.dim(resolvedId)}`,
        )
      }
    }
    return { ...resolved, id: resolvedId, external: true }
  }

  if (!options.idOnly && ((!options.scan && isBuild) || externalize)) {
    // Resolve package side effects for build so that rollup can better
    // perform tree-shaking
    return processResult({
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved),
    })
  }

  if (
    !isInNodeModules(resolved) || // linked
    !depsOptimizer || // resolving before listening to the server
    options.scan // initial esbuild scan phase
  ) {
    return { id: resolved }
  }

  // if we reach here, it's a valid dep import that hasn't been optimized.
  const isJsType = isOptimizable(resolved, depsOptimizer.options)
  const exclude = depsOptimizer.options.exclude

  const skipOptimization =
    depsOptimizer.options.noDiscovery ||
    !isJsType ||
    (importer && isInNodeModules(importer)) ||
    exclude?.includes(pkgId) ||
    exclude?.includes(id) ||
    SPECIAL_QUERY_RE.test(resolved)

  if (skipOptimization) {
    // excluded from optimization
    // Inject a version query to npm deps so that the browser
    // can cache it without re-validation, but only do so for known js types.
    // otherwise we may introduce duplicated modules for externalized files
    // from pre-bundled deps.
    const versionHash = depsOptimizer.metadata.browserHash
    if (versionHash && isJsType) {
      resolved = injectQuery(resolved, `v=${versionHash}`)
    }
  } else {
    // this is a missing import, queue optimize-deps re-run and
    // get a resolved its optimized info
    const optimizedInfo = depsOptimizer.registerMissingImport(id, resolved)
    resolved = depsOptimizer.getOptimizedDepId(optimizedInfo)
  }

  return { id: resolved }
}

export async function tryOptimizedResolve(
  depsOptimizer: DepsOptimizer,
  id: string,
  importer?: string,
  preserveSymlinks?: boolean,
  packageCache?: PackageCache,
): Promise<string | undefined> {
  // TODO: we need to wait until scanning is done here as this function
  // is used in the preAliasPlugin to decide if an aliased dep is optimized,
  // and avoid replacing the bare import with the resolved path.
  // We should be able to remove this in the future
  await depsOptimizer.scanProcessing

  const metadata = depsOptimizer.metadata

  const depInfo = optimizedDepInfoFromId(metadata, id)
  if (depInfo) {
    return depsOptimizer.getOptimizedDepId(depInfo)
  }

  if (!importer) return

  // further check if id is imported by nested dependency
  let idPkgDir: string | undefined
  const nestedIdMatch = `> ${id}`

  for (const optimizedData of metadata.depInfoList) {
    if (!optimizedData.src) continue // Ignore chunks

    // check where "foo" is nested in "my-lib > foo"
    if (!optimizedData.id.endsWith(nestedIdMatch)) continue

    // lazily initialize idPkgDir
    if (idPkgDir == null) {
      const pkgName = getNpmPackageName(id)
      if (!pkgName) break
      idPkgDir = resolvePackageData(
        pkgName,
        importer,
        preserveSymlinks,
        packageCache,
      )?.dir
      // if still null, it likely means that this id isn't a dep for importer.
      // break to bail early
      if (idPkgDir == null) break
      idPkgDir = normalizePath(idPkgDir)
    }

    // match by src to correctly identify if id belongs to nested dependency
    if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) {
      return depsOptimizer.getOptimizedDepId(optimizedData)
    }
  }
}

export function resolvePackageEntry(
  id: string,
  { dir, data, setResolvedCache, getResolvedCache }: PackageData,
  options: InternalResolveOptions,
  externalize?: boolean,
): string | undefined {
  const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id)

  const cached = getResolvedCache('.', options)
  if (cached) {
    return cached + postfix
  }

  try {
    let entryPoint: string | undefined

    // resolve exports field with highest priority
    // using https://github.com/lukeed/resolve.exports
    if (data.exports) {
      entryPoint = resolveExportsOrImports(
        data,
        '.',
        options,
        'exports',
        externalize,
      )
    }

    // fallback to mainFields if still not resolved
    if (!entryPoint) {
      for (const field of options.mainFields) {
        if (field === 'browser') {
          entryPoint = tryResolveBrowserEntry(dir, data, options)
          if (entryPoint) {
            break
          }
        } else if (typeof data[field] === 'string') {
          entryPoint = data[field]
          break
        }
      }
    }
    entryPoint ||= data.main

    // try default entry when entry is not define
    // https://nodejs.org/api/modules.html#all-together
    const entryPoints = entryPoint
      ? [entryPoint]
      : ['index.js', 'index.json', 'index.node']

    for (let entry of entryPoints) {
      // make sure we don't get scripts when looking for sass
      let skipPackageJson = false
      if (
        options.mainFields[0] === 'sass' &&
        !options.extensions.includes(path.extname(entry))
      ) {
        entry = ''
        skipPackageJson = true
      } else {
        // resolve object browser field in package.json
        const { browser: browserField } = data
        if (options.mainFields.includes('browser') && isObject(browserField)) {
          entry = mapWithBrowserField(entry, browserField) || entry
        }
      }

      const entryPointPath = path.join(dir, entry)
      const resolvedEntryPoint = tryFsResolve(
        entryPointPath,
        options,
        true,
        skipPackageJson,
      )
      if (resolvedEntryPoint) {
        debug?.(
          `[package entry] ${colors.cyan(idWithoutPostfix)} -> ${colors.dim(
            resolvedEntryPoint,
          )}${postfix !== '' ? ` (postfix: ${postfix})` : ''}`,
        )
        setResolvedCache('.', resolvedEntryPoint, options)
        return resolvedEntryPoint + postfix
      }
    }
  } catch (e) {
    packageEntryFailure(id, e.message)
  }
  packageEntryFailure(id)
}

function packageEntryFailure(id: string, details?: string) {
  const err: any = new Error(
    `Failed to resolve entry for package "${id}". ` +
      `The package may have incorrect main/module/exports specified in its package.json` +
      (details ? ': ' + details : '.'),
  )
  err.code = ERR_RESOLVE_PACKAGE_ENTRY_FAIL
  throw err
}

function resolveExportsOrImports(
  pkg: PackageData['data'],
  key: string,
  options: InternalResolveOptions,
  type: 'imports' | 'exports',
  externalize?: boolean,
) {
  const rawConditions = externalize
    ? options.externalConditions
    : options.conditions
  const conditions = rawConditions.map((condition) => {
    if (condition === DEV_PROD_CONDITION) {
      return options.isProduction ? 'production' : 'development'
    }
    return condition
  })

  if (options.isRequire) {
    conditions.push('require')
  } else {
    conditions.push('import')
  }

  const fn = type === 'imports' ? imports : exports
  const result = fn(pkg, key, { conditions, unsafe: true })
  return result ? result[0] : undefined
}

function resolveDeepImport(
  id: string,
  { setResolvedCache, getResolvedCache, dir, data }: PackageData,
  options: InternalResolveOptions,
  externalize?: boolean,
): string | undefined {
  const cache = getResolvedCache(id, options)
  if (cache) {
    return cache
  }

  let relativeId: string | undefined | void = id
  const { exports: exportsField, browser: browserField } = data

  // map relative based on exports data
  if (exportsField) {
    if (isObject(exportsField) && !Array.isArray(exportsField)) {
      // resolve without postfix (see #7098)
      const { file, postfix } = splitFileAndPostfix(relativeId)
      const exportsId = resolveExportsOrImports(
        data,
        file,
        options,
        'exports',
        externalize,
      )
      if (exportsId !== undefined) {
        relativeId = exportsId + postfix
      } else {
        relativeId = undefined
      }
    } else {
      // not exposed
      relativeId = undefined
    }
    if (!relativeId) {
      throw new Error(
        `Package subpath '${relativeId}' is not defined by "exports" in ` +
          `${path.join(dir, 'package.json')}.`,
      )
    }
  } else if (options.mainFields.includes('browser') && isObject(browserField)) {
    // resolve without postfix (see #7098)
    const { file, postfix } = splitFileAndPostfix(relativeId)
    const mapped = mapWithBrowserField(file, browserField)
    if (mapped) {
      relativeId = mapped + postfix
    } else if (mapped === false) {
      setResolvedCache(id, browserExternalId, options)
      return browserExternalId
    }
  }

  if (relativeId) {
    const resolved = tryFsResolve(
      path.join(dir, relativeId),
      options,
      !exportsField, // try index only if no exports field
    )
    if (resolved) {
      debug?.(
        `[node/deep-import] ${colors.cyan(id)} -> ${colors.dim(resolved)}`,
      )
      setResolvedCache(id, resolved, options)
      return resolved
    }
  }
}

function tryResolveBrowserMapping(
  id: string,
  importer: string | undefined,
  options: InternalResolveOptions,
  isFilePath: boolean,
  externalize?: boolean,
) {
  let res: string | undefined
  const pkg =
    importer &&
    findNearestPackageData(path.dirname(importer), options.packageCache)
  if (pkg && isObject(pkg.data.browser)) {
    const mapId = isFilePath ? './' + slash(path.relative(pkg.dir, id)) : id
    const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser)
    if (browserMappedPath) {
      if (
        (res = bareImportRE.test(browserMappedPath)
          ? tryNodeResolve(
              browserMappedPath,
              importer,
              options,
              undefined,
              undefined,
            )?.id
          : tryFsResolve(path.join(pkg.dir, browserMappedPath), options))
      ) {
        debug?.(`[browser mapped] ${colors.cyan(id)} -> ${colors.dim(res)}`)
        let result: PartialResolvedId = { id: res }
        if (options.idOnly) {
          return result
        }
        if (!options.scan && options.isBuild) {
          const resPkg = findNearestPackageData(
            path.dirname(res),
            options.packageCache,
          )
          if (resPkg) {
            result = {
              id: res,
              moduleSideEffects: resPkg.hasSideEffects(res),
            }
          }
        }
        return externalize ? { ...result, external: true } : result
      }
    } else if (browserMappedPath === false) {
      return browserExternalId
    }
  }
}

function tryResolveBrowserEntry(
  dir: string,
  data: PackageData['data'],
  options: InternalResolveOptions,
) {
  // handle edge case with browser and module field semantics

  // check browser field
  // https://github.com/defunctzombie/package-browser-field-spec
  const browserEntry =
    typeof data.browser === 'string'
      ? data.browser
      : isObject(data.browser) && data.browser['.']
  if (browserEntry) {
    // check if the package also has a "module" field.
    if (
      !options.isRequire &&
      options.mainFields.includes('module') &&
      typeof data.module === 'string' &&
      data.module !== browserEntry
    ) {
      // if both are present, we may have a problem: some package points both
      // to ESM, with "module" targeting Node.js, while some packages points
      // "module" to browser ESM and "browser" to UMD/IIFE.
      // the heuristics here is to actually read the browser entry when
      // possible and check for hints of ESM. If it is not ESM, prefer "module"
      // instead; Otherwise, assume it's ESM and use it.
      const resolvedBrowserEntry = tryFsResolve(
        path.join(dir, browserEntry),
        options,
      )
      if (resolvedBrowserEntry) {
        const content = fs.readFileSync(resolvedBrowserEntry, 'utf-8')
        if (hasESMSyntax(content)) {
          // likely ESM, prefer browser
          return browserEntry
        } else {
          // non-ESM, UMD or IIFE or CJS(!!! e.g. firebase 7.x), prefer module
          return data.module
        }
      }
    } else {
      return browserEntry
    }
  }
}

/**
 * given a relative path in pkg dir,
 * return a relative path in pkg dir,
 * mapped with the "map" object
 *
 * - Returning `undefined` means there is no browser mapping for this id
 * - Returning `false` means this id is explicitly externalized for browser
 */
function mapWithBrowserField(
  relativePathInPkgDir: string,
  map: Record<string, string | false>,
): string | false | undefined {
  const normalizedPath = path.posix.normalize(relativePathInPkgDir)

  for (const key in map) {
    const normalizedKey = path.posix.normalize(key)
    if (
      normalizedPath === normalizedKey ||
      equalWithoutSuffix(normalizedPath, normalizedKey, '.js') ||
      equalWithoutSuffix(normalizedPath, normalizedKey, '/index.js')
    ) {
      return map[key]
    }
  }
}

function equalWithoutSuffix(path: string, key: string, suffix: string) {
  return key.endsWith(suffix) && key.slice(0, -suffix.length) === path
}

function tryResolveRealFile(
  file: string,
  preserveSymlinks?: boolean,
): string | undefined {
  const stat = tryStatSync(file)
  if (stat?.isFile()) return getRealPath(file, preserveSymlinks)
}

function tryResolveRealFileWithExtensions(
  filePath: string,
  extensions: string[],
  preserveSymlinks?: boolean,
): string | undefined {
  for (const ext of extensions) {
    const res = tryResolveRealFile(filePath + ext, preserveSymlinks)
    if (res) return res
  }
}

function tryResolveRealFileOrType(
  file: string,
  preserveSymlinks?: boolean,
): { path?: string; type: 'directory' | 'file' } | undefined {
  const fileStat = tryStatSync(file)
  if (fileStat?.isFile()) {
    return { path: getRealPath(file, preserveSymlinks), type: 'file' }
  }
  if (fileStat?.isDirectory()) {
    return { type: 'directory' }
  }
  return
}

function getRealPath(resolved: string, preserveSymlinks?: boolean): string {
  if (!preserveSymlinks) {
    resolved = safeRealpathSync(resolved)
  }
  return normalizePath(resolved)
}

function isDirectory(path: string): boolean {
  const stat = tryStatSync(path)
  return stat?.isDirectory() ?? false
}



================================================
FILE: packages/vite/src/node/plugins/terser.ts
================================================
import type {
  TerserMinifyOptions,
  TerserMinifyOutput,
} from 'types/internal/terserOptions'
import { WorkerWithFallback } from 'artichokie'
import type { Plugin } from '../plugin'
import type { ResolvedConfig } from '..'
import { requireResolveFromRootWithFallback } from '../utils'

export interface TerserOptions extends TerserMinifyOptions {
  /**
   * Vite-specific option to specify the max number of workers to spawn
   * when minifying files with terser.
   *
   * @default number of CPUs minus 1
   */
  maxWorkers?: number
}

let terserPath: string | undefined
const loadTerserPath = (root: string) => {
  if (terserPath) return terserPath
  try {
    terserPath = requireResolveFromRootWithFallback(root, 'terser')
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error(
        'terser not found. Since Vite v3, terser has become an optional dependency. You need to install it.',
      )
    } else {
      const message = new Error(`terser failed to load:\n${e.message}`)
      message.stack = e.stack + '\n' + message.stack
      throw message
    }
  }
  return terserPath
}

export function terserPlugin(config: ResolvedConfig): Plugin {
  const { maxWorkers, ...terserOptions } = config.build.terserOptions

  const makeWorker = () =>
    new WorkerWithFallback(
      () =>
        async (
          terserPath: string,
          code: string,
          options: TerserMinifyOptions,
        ) => {
          // test fails when using `import`. maybe related: https://github.com/nodejs/node/issues/43205
          // eslint-disable-next-line no-restricted-globals -- this function runs inside cjs
          const terser = require(terserPath)
          return terser.minify(code, options) as TerserMinifyOutput
        },
      {
        shouldUseFake(_terserPath, _code, options) {
          return !!(
            (typeof options.mangle === 'object' &&
              (options.mangle.nth_identifier?.get ||
                (typeof options.mangle.properties === 'object' &&
                  options.mangle.properties.nth_identifier?.get))) ||
            typeof options.format?.comments === 'function' ||
            typeof options.output?.comments === 'function'
          )
        },
        max: maxWorkers,
      },
    )

  let worker: ReturnType<typeof makeWorker>

  return {
    name: 'vite:terser',

    applyToEnvironment(environment) {
      // We also need the plugin even if minify isn't 'terser' as we force
      // terser in plugin-legacy
      return !!environment.config.build.minify
    },

    async renderChunk(code, _chunk, outputOptions) {
      // This plugin is included for any non-false value of config.build.minify,
      // so that normal chunks can use the preferred minifier, and legacy chunks
      // can use terser.
      if (
        config.build.minify !== 'terser' &&
        // @ts-expect-error injected by @vitejs/plugin-legacy
        !outputOptions.__vite_force_terser__
      ) {
        return null
      }

      // Do not minify ES lib output since that would remove pure annotations
      // and break tree-shaking.
      if (config.build.lib && outputOptions.format === 'es') {
        return null
      }

      // Lazy load worker.
      worker ||= makeWorker()

      const terserPath = loadTerserPath(config.root)
      const res = await worker.run(terserPath, code, {
        safari10: true,
        ...terserOptions,
        sourceMap: !!outputOptions.sourcemap,
        module: outputOptions.format.startsWith('es'),
        toplevel: outputOptions.format === 'cjs',
      })
      return {
        code: res.code!,
        map: res.map as any,
      }
    },

    closeBundle() {
      worker?.stop()
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/wasm.ts
================================================
import { exactRegex } from '@rolldown/pluginutils'
import type { Plugin } from '../plugin'
import { fileToUrl } from './asset'

const wasmHelperId = '\0vite/wasm-helper.js'

const wasmInitRE = /(?<![?#].*)\.wasm\?init/

const wasmHelper = async (opts = {}, url: string) => {
  let result
  if (url.startsWith('data:')) {
    const urlContent = url.replace(/^data:.*?base64,/, '')
    let bytes
    if (typeof Buffer === 'function' && typeof Buffer.from === 'function') {
      bytes = Buffer.from(urlContent, 'base64')
    } else if (typeof atob === 'function') {
      const binaryString = atob(urlContent)
      bytes = new Uint8Array(binaryString.length)
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i)
      }
    } else {
      throw new Error(
        'Failed to decode base64-encoded data URL, Buffer and atob are not supported',
      )
    }
    result = await WebAssembly.instantiate(bytes, opts)
  } else {
    // https://github.com/mdn/webassembly-examples/issues/5
    // WebAssembly.instantiateStreaming requires the server to provide the
    // correct MIME type for .wasm files, which unfortunately doesn't work for
    // a lot of static file servers, so we just work around it by getting the
    // raw buffer.
    const response = await fetch(url)
    const contentType = response.headers.get('Content-Type') || ''
    if (
      'instantiateStreaming' in WebAssembly &&
      contentType.startsWith('application/wasm')
    ) {
      result = await WebAssembly.instantiateStreaming(response, opts)
    } else {
      const buffer = await response.arrayBuffer()
      result = await WebAssembly.instantiate(buffer, opts)
    }
  }
  return result.instance
}

const wasmHelperCode = wasmHelper.toString()

export const wasmHelperPlugin = (): Plugin => {
  return {
    name: 'vite:wasm-helper',

    resolveId: {
      filter: { id: exactRegex(wasmHelperId) },
      handler(id) {
        return id
      },
    },

    load: {
      filter: { id: [exactRegex(wasmHelperId), wasmInitRE] },
      async handler(id) {
        if (id === wasmHelperId) {
          return `export default ${wasmHelperCode}`
        }

        const url = await fileToUrl(this, id)

        return `
  import initWasm from "${wasmHelperId}"
  export default opts => initWasm(opts, ${JSON.stringify(url)})
  `
      },
    },
  }
}

export const wasmFallbackPlugin = (): Plugin => {
  return {
    name: 'vite:wasm-fallback',

    load: {
      filter: { id: /\.wasm$/ },
      handler(_id) {
        throw new Error(
          '"ESM integration proposal for Wasm" is not supported currently. ' +
            'Use vite-plugin-wasm or other community plugins to handle this. ' +
            'Alternatively, you can use `.wasm?init` or `.wasm?url`. ' +
            'See https://vite.dev/guide/features.html#webassembly for more details.',
        )
      },
    },
  }
}



================================================
FILE: packages/vite/src/node/plugins/worker.ts
================================================
import path from 'node:path'
import MagicString from 'magic-string'
import type { OutputChunk, RollupError } from 'rollup'
import colors from 'picocolors'
import type { ResolvedConfig } from '../config'
import type { Plugin } from '../plugin'
import { ENV_ENTRY, ENV_PUBLIC_PATH } from '../constants'
import {
  encodeURIPath,
  getHash,
  injectQuery,
  prettifyUrl,
  urlRE,
} from '../utils'
import {
  BuildEnvironment,
  createToImportMetaURLBasedRelativeRuntime,
  injectEnvironmentToHooks,
  onRollupLog,
  toOutputFilePathInJS,
} from '../build'
import { cleanUrl } from '../../shared/utils'
import { fileToUrl } from './asset'

type WorkerBundleAsset = {
  fileName: string
  /** @deprecated */
  originalFileName: string | null
  originalFileNames: string[]
  source: string | Uint8Array
}

interface WorkerCache {
  // save worker all emit chunk avoid rollup make the same asset unique.
  assets: Map<string, WorkerBundleAsset>

  // worker bundle don't deps on any more worker runtime info an id only had a result.
  // save worker bundled file id to avoid repeated execution of bundles
  // <input_filename, fileName>
  bundle: Map<string, string>

  // <hash, fileName>
  fileNameHash: Map<string, string>
}

export type WorkerType = 'classic' | 'module' | 'ignore'

export const workerOrSharedWorkerRE = /(?:\?|&)(worker|sharedworker)(?:&|$)/
const workerFileRE = /(?:\?|&)worker_file&type=(\w+)(?:&|$)/
const inlineRE = /[?&]inline\b/

export const WORKER_FILE_ID = 'worker_file'
const workerCache = new WeakMap<ResolvedConfig, WorkerCache>()

function saveEmitWorkerAsset(
  config: ResolvedConfig,
  asset: WorkerBundleAsset,
): void {
  const workerMap = workerCache.get(config.mainConfig || config)!
  const duplicateAsset = workerMap.assets.get(asset.fileName)
  if (duplicateAsset) {
    if (!isSameContent(duplicateAsset.source, asset.source)) {
      config.logger.warn(
        `\n` +
          colors.yellow(
            `The emitted file ${JSON.stringify(asset.fileName)} overwrites a previously emitted file of the same name.`,
          ),
      )
    }
  }
  workerMap.assets.set(asset.fileName, asset)
}

async function bundleWorkerEntry(
  config: ResolvedConfig,
  id: string,
): Promise<OutputChunk> {
  const input = cleanUrl(id)
  const newBundleChain = [...config.bundleChain, input]
  if (config.bundleChain.includes(input)) {
    throw new Error(
      'Circular worker imports detected. Vite does not support it. ' +
        `Import chain: ${newBundleChain.map((id) => prettifyUrl(id, config.root)).join(' -> ')}`,
    )
  }

  // bundle the file as entry to support imports
  const { rollup } = await import('rollup')
  const { plugins, rollupOptions, format } = config.worker
  const workerConfig = await plugins(newBundleChain)
  const workerEnvironment = new BuildEnvironment('client', workerConfig) // TODO: should this be 'worker'?
  await workerEnvironment.init()

  const bundle = await rollup({
    ...rollupOptions,
    input,
    plugins: workerEnvironment.plugins.map((p) =>
      injectEnvironmentToHooks(workerEnvironment, p),
    ),
    onLog(level, log) {
      onRollupLog(level, log, workerEnvironment)
    },
    preserveEntrySignatures: false,
  })
  let chunk: OutputChunk
  try {
    const workerOutputConfig = config.worker.rollupOptions.output
    const workerConfig = workerOutputConfig
      ? Array.isArray(workerOutputConfig)
        ? workerOutputConfig[0] || {}
        : workerOutputConfig
      : {}
    const {
      output: [outputChunk, ...outputChunks],
    } = await bundle.generate({
      entryFileNames: path.posix.join(
        config.build.assetsDir,
        '[name]-[hash].js',
      ),
      chunkFileNames: path.posix.join(
        config.build.assetsDir,
        '[name]-[hash].js',
      ),
      assetFileNames: path.posix.join(
        config.build.assetsDir,
        '[name]-[hash].[ext]',
      ),
      ...workerConfig,
      format,
      sourcemap: config.build.sourcemap,
    })
    chunk = outputChunk
    outputChunks.forEach((outputChunk) => {
      if (outputChunk.type === 'asset') {
        saveEmitWorkerAsset(config, outputChunk)
      } else if (outputChunk.type === 'chunk') {
        saveEmitWorkerAsset(config, {
          fileName: outputChunk.fileName,
          originalFileName: null,
          originalFileNames: [],
          source: outputChunk.code,
        })
      }
    })
  } catch (e) {
    // adjust rollup format error
    if (
      e instanceof Error &&
      e.name === 'RollupError' &&
      (e as RollupError).code === 'INVALID_OPTION' &&
      e.message.includes('"output.format"')
    ) {
      e.message = e.message.replace('output.format', 'worker.format')
    }
    throw e
  } finally {
    await bundle.close()
  }
  return emitSourcemapForWorkerEntry(config, chunk)
}

function emitSourcemapForWorkerEntry(
  config: ResolvedConfig,
  chunk: OutputChunk,
): OutputChunk {
  const { map: sourcemap } = chunk

  if (sourcemap) {
    if (
      config.build.sourcemap === 'hidden' ||
      config.build.sourcemap === true
    ) {
      const data = sourcemap.toString()
      const mapFileName = chunk.fileName + '.map'
      saveEmitWorkerAsset(config, {
        fileName: mapFileName,
        originalFileName: null,
        originalFileNames: [],
        source: data,
      })
    }
  }

  return chunk
}

export const workerAssetUrlRE = /__VITE_WORKER_ASSET__([a-z\d]{8})__/g

function encodeWorkerAssetFileName(
  fileName: string,
  workerCache: WorkerCache,
): string {
  const { fileNameHash } = workerCache
  const hash = getHash(fileName)
  if (!fileNameHash.get(hash)) {
    fileNameHash.set(hash, fileName)
  }
  return `__VITE_WORKER_ASSET__${hash}__`
}

export async function workerFileToUrl(
  config: ResolvedConfig,
  id: string,
): Promise<string> {
  const workerMap = workerCache.get(config.mainConfig || config)!
  let fileName = workerMap.bundle.get(id)
  if (!fileName) {
    const outputChunk = await bundleWorkerEntry(config, id)
    fileName = outputChunk.fileName
    saveEmitWorkerAsset(config, {
      fileName,
      originalFileName: null,
      originalFileNames: [],
      source: outputChunk.code,
    })
    workerMap.bundle.set(id, fileName)
  }
  return encodeWorkerAssetFileName(fileName, workerMap)
}

export function webWorkerPostPlugin(): Plugin {
  return {
    name: 'vite:worker-post',
    resolveImportMeta(property, { format }) {
      // document is undefined in the worker, so we need to avoid it in iife
      if (format === 'iife') {
        // compiling import.meta
        if (!property) {
          // rollup only supports `url` property. we only support `url` property as well.
          // https://github.com/rollup/rollup/blob/62b648e1cc6a1f00260bb85aa2050097bb4afd2b/src/ast/nodes/MetaProperty.ts#L164-L173
          return `{
            url: self.location.href
          }`
        }
        // compiling import.meta.url
        if (property === 'url') {
          return 'self.location.href'
        }
      }

      return null
    },
  }
}

export function webWorkerPlugin(config: ResolvedConfig): Plugin {
  const isBuild = config.command === 'build'
  const isWorker = config.isWorker

  return {
    name: 'vite:worker',

    buildStart() {
      if (isWorker) {
        return
      }
      workerCache.set(config, {
        assets: new Map(),
        bundle: new Map(),
        fileNameHash: new Map(),
      })
    },

    load: {
      filter: { id: workerOrSharedWorkerRE },
      async handler(id) {
        const workerMatch = workerOrSharedWorkerRE.exec(id)
        if (!workerMatch) return

        const { format } = config.worker
        const workerConstructor =
          workerMatch[1] === 'sharedworker' ? 'SharedWorker' : 'Worker'
        const workerType = isBuild
          ? format === 'es'
            ? 'module'
            : 'classic'
          : 'module'
        const workerTypeOption = `{
          ${workerType === 'module' ? `type: "module",` : ''}
          name: options?.name
        }`

        let urlCode: string
        if (isBuild) {
          if (isWorker && config.bundleChain.at(-1) === cleanUrl(id)) {
            urlCode = 'self.location.href'
          } else if (inlineRE.test(id)) {
            const chunk = await bundleWorkerEntry(config, id)
            const jsContent = `const jsContent = ${JSON.stringify(chunk.code)};`

            const code =
              // Using blob URL for SharedWorker results in multiple instances of a same worker
              workerConstructor === 'Worker'
                ? `${jsContent}
            const blob = typeof self !== "undefined" && self.Blob && new Blob([${
              // NOTE: Revoke the objURL after creating the worker, otherwise it breaks WebKit-based browsers
              workerType === 'classic'
                ? `'(self.URL || self.webkitURL).revokeObjectURL(self.location.href);',`
                : // `URL` is always available, in `Worker[type="module"]`
                  `'URL.revokeObjectURL(import.meta.url);',`
            }jsContent], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper(options) {
              let objURL;
              try {
                objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
                if (!objURL) throw ''
                const worker = new ${workerConstructor}(objURL, ${workerTypeOption});
                worker.addEventListener("error", () => {
                  (self.URL || self.webkitURL).revokeObjectURL(objURL);
                });
                return worker;
              } catch(e) {
                return new ${workerConstructor}(
                  'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                  ${workerTypeOption}
                );
              }
            }`
                : `${jsContent}
            export default function WorkerWrapper(options) {
              return new ${workerConstructor}(
                'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                ${workerTypeOption}
              );
            }
            `

            return {
              code,
              // Empty sourcemap to suppress Rollup warning
              map: { mappings: '' },
            }
          } else {
            urlCode = JSON.stringify(await workerFileToUrl(config, id))
          }
        } else {
          let url = await fileToUrl(this, cleanUrl(id))
          url = injectQuery(url, `${WORKER_FILE_ID}&type=${workerType}`)
          urlCode = JSON.stringify(url)
        }

        if (urlRE.test(id)) {
          return {
            code: `export default ${urlCode}`,
            map: { mappings: '' }, // Empty sourcemap to suppress Rollup warning
          }
        }

        return {
          code: `export default function WorkerWrapper(options) {
            return new ${workerConstructor}(
              ${urlCode},
              ${workerTypeOption}
            );
          }`,
          map: { mappings: '' }, // Empty sourcemap to suppress Rollup warning
        }
      },
    },

    shouldTransformCachedModule({ id }) {
      if (isBuild && config.build.watch && workerOrSharedWorkerRE.test(id)) {
        return true
      }
    },

    transform: {
      filter: { id: workerFileRE },
      async handler(raw, id) {
        const workerFileMatch = workerFileRE.exec(id)
        if (workerFileMatch) {
          // if import worker by worker constructor will have query.type
          // other type will be import worker by esm
          const workerType = workerFileMatch[1] as WorkerType
          let injectEnv = ''

          const scriptPath = JSON.stringify(
            path.posix.join(config.base, ENV_PUBLIC_PATH),
          )

          if (workerType === 'classic') {
            injectEnv = `importScripts(${scriptPath})\n`
          } else if (workerType === 'module') {
            injectEnv = `import ${scriptPath}\n`
          } else if (workerType === 'ignore') {
            if (isBuild) {
              injectEnv = ''
            } else {
              // dynamic worker type we can't know how import the env
              // so we copy /@vite/env code of server transform result into file header
              const environment = this.environment
              const moduleGraph =
                environment.mode === 'dev' ? environment.moduleGraph : undefined
              const module = moduleGraph?.getModuleById(ENV_ENTRY)
              injectEnv = module?.transformResult?.code || ''
            }
          }
          if (injectEnv) {
            const s = new MagicString(raw)
            s.prepend(injectEnv + ';\n')
            return {
              code: s.toString(),
              map: s.generateMap({ hires: 'boundary' }),
            }
          }
        }
      },
    },

    renderChunk(code, chunk, outputOptions) {
      let s: MagicString
      const result = () => {
        return (
          s && {
            code: s.toString(),
            map: this.environment.config.build.sourcemap
              ? s.generateMap({ hires: 'boundary' })
              : null,
          }
        )
      }
      workerAssetUrlRE.lastIndex = 0
      if (workerAssetUrlRE.test(code)) {
        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
          outputOptions.format,
          this.environment.config.isWorker,
        )

        let match: RegExpExecArray | null
        s = new MagicString(code)
        workerAssetUrlRE.lastIndex = 0

        // Replace "__VITE_WORKER_ASSET__5aa0ddc0__" using relative paths
        const workerMap = workerCache.get(config.mainConfig || config)!
        const { fileNameHash } = workerMap

        while ((match = workerAssetUrlRE.exec(code))) {
          const [full, hash] = match
          const filename = fileNameHash.get(hash)!
          const replacement = toOutputFilePathInJS(
            this.environment,
            filename,
            'asset',
            chunk.fileName,
            'js',
            toRelativeRuntime,
          )
          const replacementString =
            typeof replacement === 'string'
              ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)
              : `"+${replacement.runtime}+"`
          s.update(match.index, match.index + full.length, replacementString)
        }
      }
      return result()
    },

    generateBundle(opts, bundle) {
      // @ts-expect-error asset emits are skipped in legacy bundle
      if (opts.__vite_skip_asset_emit__ || isWorker) {
        return
      }
      const workerMap = workerCache.get(config)!
      workerMap.assets.forEach((asset) => {
        const duplicateAsset = bundle[asset.fileName]
        if (duplicateAsset) {
          const content =
            duplicateAsset.type === 'asset'
              ? duplicateAsset.source
              : duplicateAsset.code
          // don't emit if the file name and the content is same
          if (isSameContent(content, asset.source)) {
            return
          }
        }

        this.emitFile({
          type: 'asset',
          fileName: asset.fileName,
          source: asset.source,
          // NOTE: fileName is already generated when bundling the worker
          //       so no need to pass originalFileNames/names
        })
      })
      workerMap.assets.clear()
    },
  }
}

function isSameContent(a: string | Uint8Array, b: string | Uint8Array) {
  if (typeof a === 'string') {
    if (typeof b === 'string') {
      return a === b
    }
    return Buffer.from(a).equals(b)
  }
  return Buffer.from(b).equals(a)
}



================================================
FILE: packages/vite/src/node/plugins/workerImportMetaUrl.ts
================================================
import path from 'node:path'
import MagicString from 'magic-string'
import type { RollupAstNode, RollupError } from 'rollup'
import { parseAstAsync } from 'rollup/parseAst'
import { stripLiteral } from 'strip-literal'
import type { Expression, ExpressionStatement } from 'estree'
import type { ResolvedConfig } from '../config'
import type { Plugin } from '../plugin'
import { evalValue, injectQuery, transformStableResult } from '../utils'
import { createBackCompatIdResolver } from '../idResolver'
import type { ResolveIdFn } from '../idResolver'
import { cleanUrl, slash } from '../../shared/utils'
import type { WorkerType } from './worker'
import { WORKER_FILE_ID, workerFileToUrl } from './worker'
import { fileToUrl } from './asset'
import type { InternalResolveOptions } from './resolve'
import { tryFsResolve } from './resolve'
import { hasViteIgnoreRE } from './importAnalysis'

interface WorkerOptions {
  type?: WorkerType
}

function err(e: string, pos: number) {
  const error = new Error(e) as RollupError
  error.pos = pos
  return error
}

function findClosingParen(input: string, fromIndex: number) {
  let count = 1

  for (let i = fromIndex; i < input.length; i++) {
    if (input[i] === '(') count++
    if (input[i] === ')') count--
    if (count === 0) return i
  }

  return -1
}

function extractWorkerTypeFromAst(
  expression: Expression,
  optsStartIndex: number,
): 'classic' | 'module' | undefined {
  if (expression.type !== 'ObjectExpression') {
    return
  }

  let lastSpreadElementIndex = -1
  let typeProperty = null
  let typePropertyIndex = -1

  for (let i = 0; i < expression.properties.length; i++) {
    const property = expression.properties[i]

    if (property.type === 'SpreadElement') {
      lastSpreadElementIndex = i
      continue
    }

    if (
      property.type === 'Property' &&
      ((property.key.type === 'Identifier' && property.key.name === 'type') ||
        (property.key.type === 'Literal' && property.key.value === 'type'))
    ) {
      typeProperty = property
      typePropertyIndex = i
    }
  }

  if (typePropertyIndex === -1 && lastSpreadElementIndex === -1) {
    // No type property or spread element in use. Assume safe usage and default to classic
    return 'classic'
  }

  if (typePropertyIndex < lastSpreadElementIndex) {
    throw err(
      'Expected object spread to be used before the definition of the type property. ' +
        'Vite needs a static value for the type property to correctly infer it.',
      optsStartIndex,
    )
  }

  if (typeProperty?.value.type !== 'Literal') {
    throw err(
      'Expected worker options type property to be a literal value.',
      optsStartIndex,
    )
  }

  // Silently default to classic type like the getWorkerType method
  return typeProperty?.value.value === 'module' ? 'module' : 'classic'
}

async function parseWorkerOptions(
  rawOpts: string,
  optsStartIndex: number,
): Promise<WorkerOptions> {
  let opts: WorkerOptions = {}
  try {
    opts = evalValue<WorkerOptions>(rawOpts)
  } catch {
    const optsNode = (
      (await parseAstAsync(`(${rawOpts})`))
        .body[0] as RollupAstNode<ExpressionStatement>
    ).expression

    const type = extractWorkerTypeFromAst(optsNode, optsStartIndex)
    if (type) {
      return { type }
    }

    throw err(
      'Vite is unable to parse the worker options as the value is not static. ' +
        'To ignore this error, please use /* @vite-ignore */ in the worker options.',
      optsStartIndex,
    )
  }

  if (opts == null) {
    return {}
  }

  if (typeof opts !== 'object') {
    throw err(
      `Expected worker options to be an object, got ${typeof opts}`,
      optsStartIndex,
    )
  }

  return opts
}

async function getWorkerType(
  raw: string,
  clean: string,
  i: number,
): Promise<WorkerType> {
  const commaIndex = clean.indexOf(',', i)
  if (commaIndex === -1) {
    return 'classic'
  }
  const endIndex = findClosingParen(clean, i)

  // case: ') ... ,' mean no worker options params
  if (commaIndex > endIndex) {
    return 'classic'
  }

  // need to find in comment code
  let workerOptString = raw.substring(commaIndex + 1, endIndex)
  const hasViteIgnore = hasViteIgnoreRE.test(workerOptString)
  if (hasViteIgnore) {
    return 'ignore'
  }

  // need to find in no comment code
  const cleanWorkerOptString = clean.substring(commaIndex + 1, endIndex)
  const trimmedCleanWorkerOptString = cleanWorkerOptString.trim()
  if (!trimmedCleanWorkerOptString.length) {
    return 'classic'
  }

  // strip trailing comma for evalValue
  if (trimmedCleanWorkerOptString.endsWith(',')) {
    workerOptString = workerOptString.slice(
      0,
      cleanWorkerOptString.lastIndexOf(','),
    )
  }

  const workerOpts = await parseWorkerOptions(workerOptString, commaIndex + 1)
  if (
    workerOpts.type &&
    (workerOpts.type === 'module' || workerOpts.type === 'classic')
  ) {
    return workerOpts.type
  }

  return 'classic'
}

const workerImportMetaUrlRE =
  /new\s+(?:Worker|SharedWorker)\s*\(\s*new\s+URL.+?import\.meta\.url/s

export function workerImportMetaUrlPlugin(config: ResolvedConfig): Plugin {
  const isBuild = config.command === 'build'
  let workerResolver: ResolveIdFn

  const fsResolveOptions: InternalResolveOptions = {
    ...config.resolve,
    root: config.root,
    isProduction: config.isProduction,
    isBuild: config.command === 'build',
    packageCache: config.packageCache,
    asSrc: true,
  }

  return {
    name: 'vite:worker-import-meta-url',

    applyToEnvironment(environment) {
      return environment.config.consumer === 'client'
    },

    shouldTransformCachedModule({ code }) {
      if (isBuild && config.build.watch && workerImportMetaUrlRE.test(code)) {
        return true
      }
    },

    transform: {
      filter: { code: workerImportMetaUrlRE },
      async handler(code, id) {
        let s: MagicString | undefined
        const cleanString = stripLiteral(code)
        const workerImportMetaUrlRE =
          /\bnew\s+(?:Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/dg

        let match: RegExpExecArray | null
        while ((match = workerImportMetaUrlRE.exec(cleanString))) {
          const [[, endIndex], [expStart, expEnd], [urlStart, urlEnd]] =
            match.indices!

          const rawUrl = code.slice(urlStart, urlEnd)

          // potential dynamic template string
          if (rawUrl[0] === '`' && rawUrl.includes('${')) {
            this.error(
              `\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`,
              expStart,
            )
          }

          s ||= new MagicString(code)
          const workerType = await getWorkerType(code, cleanString, endIndex)
          const url = rawUrl.slice(1, -1)
          let file: string | undefined
          if (url[0] === '.') {
            file = path.resolve(path.dirname(id), url)
            file = slash(tryFsResolve(file, fsResolveOptions) ?? file)
          } else {
            workerResolver ??= createBackCompatIdResolver(config, {
              extensions: [],
              tryIndex: false,
              preferRelative: true,
            })
            file = await workerResolver(this.environment, url, id)
            file ??=
              url[0] === '/'
                ? slash(path.join(config.publicDir, url))
                : slash(path.resolve(path.dirname(id), url))
          }

          if (
            isBuild &&
            config.isWorker &&
            config.bundleChain.at(-1) === cleanUrl(file)
          ) {
            s.update(expStart, expEnd, 'self.location.href')
          } else {
            let builtUrl: string
            if (isBuild) {
              builtUrl = await workerFileToUrl(config, file)
            } else {
              builtUrl = await fileToUrl(this, cleanUrl(file))
              builtUrl = injectQuery(
                builtUrl,
                `${WORKER_FILE_ID}&type=${workerType}`,
              )
            }
            s.update(
              expStart,
              expEnd,
              `new URL(/* @vite-ignore */ ${JSON.stringify(builtUrl)}, import.meta.url)`,
            )
          }
        }

        if (s) {
          return transformStableResult(s, id, config)
        }

        return null
      },
    },
  }
}



================================================
FILE: packages/vite/src/node/server/environment.ts
================================================
import type { FSWatcher } from 'dep-types/chokidar'
import colors from 'picocolors'
import type { FetchFunctionOptions, FetchResult } from 'vite/module-runner'
import { BaseEnvironment } from '../baseEnvironment'
import type {
  EnvironmentOptions,
  ResolvedConfig,
  ResolvedEnvironmentOptions,
} from '../config'
import { mergeConfig, monotonicDateNow } from '../utils'
import { fetchModule } from '../ssr/fetchModule'
import type { DepsOptimizer } from '../optimizer'
import { isDepOptimizationDisabled } from '../optimizer'
import {
  createDepsOptimizer,
  createExplicitDepsOptimizer,
} from '../optimizer/optimizer'
import { ERR_OUTDATED_OPTIMIZED_DEP } from '../../shared/constants'
import { promiseWithResolvers } from '../../shared/utils'
import type { ViteDevServer } from '../server'
import { EnvironmentModuleGraph } from './moduleGraph'
import type { EnvironmentModuleNode } from './moduleGraph'
import type { HotChannel, NormalizedHotChannel } from './hmr'
import { getShortName, normalizeHotChannel, updateModules } from './hmr'
import type {
  TransformOptionsInternal,
  TransformResult,
} from './transformRequest'
import { transformRequest } from './transformRequest'
import type { EnvironmentPluginContainer } from './pluginContainer'
import {
  ERR_CLOSED_SERVER,
  createEnvironmentPluginContainer,
} from './pluginContainer'
import { type WebSocketServer, isWebSocketServer } from './ws'
import { warmupFiles } from './warmup'
import { buildErrorMessage } from './middlewares/error'

export interface DevEnvironmentContext {
  hot: boolean
  transport?: HotChannel | WebSocketServer
  options?: EnvironmentOptions
  remoteRunner?: {
    inlineSourceMap?: boolean
  }
  depsOptimizer?: DepsOptimizer
}

export class DevEnvironment extends BaseEnvironment {
  mode = 'dev' as const
  moduleGraph: EnvironmentModuleGraph

  depsOptimizer?: DepsOptimizer
  /**
   * @internal
   */
  _remoteRunnerOptions: DevEnvironmentContext['remoteRunner']

  get pluginContainer(): EnvironmentPluginContainer<DevEnvironment> {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`,
      )
    return this._pluginContainer
  }
  /**
   * @internal
   */
  _pluginContainer: EnvironmentPluginContainer<DevEnvironment> | undefined

  /**
   * @internal
   */
  _closing: boolean = false
  /**
   * @internal
   */
  _pendingRequests: Map<
    string,
    {
      request: Promise<TransformResult | null>
      timestamp: number
      abort: () => void
    }
  >
  /**
   * @internal
   */
  _crawlEndFinder: CrawlEndFinder

  /**
   * Hot channel for this environment. If not provided or disabled,
   * it will be a noop channel that does nothing.
   *
   * @example
   * environment.hot.send({ type: 'full-reload' })
   */
  hot: NormalizedHotChannel
  constructor(
    name: string,
    config: ResolvedConfig,
    context: DevEnvironmentContext,
  ) {
    let options = config.environments[name]
    if (!options) {
      throw new Error(`Environment "${name}" is not defined in the config.`)
    }
    if (context.options) {
      options = mergeConfig(
        options,
        context.options,
      ) as ResolvedEnvironmentOptions
    }
    super(name, config, options)

    this._pendingRequests = new Map()

    this.moduleGraph = new EnvironmentModuleGraph(name, (url: string) =>
      this.pluginContainer!.resolveId(url, undefined),
    )

    this._crawlEndFinder = setupOnCrawlEnd()

    this._remoteRunnerOptions = context.remoteRunner ?? {}

    this.hot = context.transport
      ? isWebSocketServer in context.transport
        ? context.transport
        : normalizeHotChannel(context.transport, context.hot)
      : normalizeHotChannel({}, context.hot)

    this.hot.setInvokeHandler({
      fetchModule: (id, importer, options) => {
        return this.fetchModule(id, importer, options)
      },
    })

    this.hot.on(
      'vite:invalidate',
      async ({ path, message, firstInvalidatedBy }) => {
        invalidateModule(this, {
          path,
          message,
          firstInvalidatedBy,
        })
      },
    )

    const { optimizeDeps } = this.config
    if (context.depsOptimizer) {
      this.depsOptimizer = context.depsOptimizer
    } else if (isDepOptimizationDisabled(optimizeDeps)) {
      this.depsOptimizer = undefined
    } else {
      this.depsOptimizer = (
        optimizeDeps.noDiscovery
          ? createExplicitDepsOptimizer
          : createDepsOptimizer
      )(this)
    }
  }

  async init(options?: {
    watcher?: FSWatcher
    /**
     * the previous instance used for the environment with the same name
     *
     * when using, the consumer should check if it's an instance generated from the same class or factory function
     */
    previousInstance?: DevEnvironment
  }): Promise<void> {
    if (this._initiated) {
      return
    }
    this._initiated = true
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this.config.plugins,
      options?.watcher,
    )
  }

  /**
   * When the dev server is restarted, the methods are called in the following order:
   * - new instance `init`
   * - previous instance `close`
   * - new instance `listen`
   */
  async listen(server: ViteDevServer): Promise<void> {
    this.hot.listen()
    await this.depsOptimizer?.init()
    warmupFiles(server, this)
  }

  fetchModule(
    id: string,
    importer?: string,
    options?: FetchFunctionOptions,
  ): Promise<FetchResult> {
    return fetchModule(this, id, importer, {
      ...this._remoteRunnerOptions,
      ...options,
    })
  }

  async reloadModule(module: EnvironmentModuleNode): Promise<void> {
    if (this.config.server.hmr !== false && module.file) {
      updateModules(this, module.file, [module], monotonicDateNow())
    }
  }

  transformRequest(
    url: string,
    /** @internal */
    options?: TransformOptionsInternal,
  ): Promise<TransformResult | null> {
    return transformRequest(this, url, options)
  }

  async warmupRequest(url: string): Promise<void> {
    try {
      await this.transformRequest(url)
    } catch (e) {
      if (
        e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||
        e?.code === ERR_CLOSED_SERVER
      ) {
        // these are expected errors
        return
      }
      // Unexpected error, log the issue but avoid an unhandled exception
      this.logger.error(
        buildErrorMessage(e, [`Pre-transform error: ${e.message}`], false),
        {
          error: e,
          timestamp: true,
        },
      )
    }
  }

  async close(): Promise<void> {
    this._closing = true

    this._crawlEndFinder.cancel()
    await Promise.allSettled([
      this.pluginContainer.close(),
      this.depsOptimizer?.close(),
      // WebSocketServer is independent of HotChannel and should not be closed on environment close
      isWebSocketServer in this.hot ? Promise.resolve() : this.hot.close(),
      (async () => {
        while (this._pendingRequests.size > 0) {
          await Promise.allSettled(
            [...this._pendingRequests.values()].map(
              (pending) => pending.request,
            ),
          )
        }
      })(),
    ])
  }

  /**
   * Calling `await environment.waitForRequestsIdle(id)` will wait until all static imports
   * are processed after the first transformRequest call. If called from a load or transform
   * plugin hook, the id needs to be passed as a parameter to avoid deadlocks.
   * Calling this function after the first static imports section of the module graph has been
   * processed will resolve immediately.
   * @experimental
   */
  waitForRequestsIdle(ignoredId?: string): Promise<void> {
    return this._crawlEndFinder.waitForRequestsIdle(ignoredId)
  }

  /**
   * @internal
   */
  _registerRequestProcessing(id: string, done: () => Promise<unknown>): void {
    this._crawlEndFinder.registerRequestProcessing(id, done)
  }
}

function invalidateModule(
  environment: DevEnvironment,
  m: {
    path: string
    message?: string
    firstInvalidatedBy: string
  },
) {
  const mod = environment.moduleGraph.urlToModuleMap.get(m.path)
  if (
    mod &&
    mod.isSelfAccepting &&
    mod.lastHMRTimestamp > 0 &&
    !mod.lastHMRInvalidationReceived
  ) {
    mod.lastHMRInvalidationReceived = true
    environment.logger.info(
      colors.yellow(`hmr invalidate `) +
        colors.dim(m.path) +
        (m.message ? ` ${m.message}` : ''),
      { timestamp: true },
    )
    const file = getShortName(mod.file!, environment.config.root)
    updateModules(
      environment,
      file,
      [...mod.importers],
      mod.lastHMRTimestamp,
      m.firstInvalidatedBy,
    )
  }
}

const callCrawlEndIfIdleAfterMs = 50

interface CrawlEndFinder {
  registerRequestProcessing: (id: string, done: () => Promise<any>) => void
  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
  cancel: () => void
}

function setupOnCrawlEnd(): CrawlEndFinder {
  const registeredIds = new Set<string>()
  const seenIds = new Set<string>()
  const onCrawlEndPromiseWithResolvers = promiseWithResolvers<void>()

  let timeoutHandle: NodeJS.Timeout | undefined

  let cancelled = false
  function cancel() {
    cancelled = true
  }

  function registerRequestProcessing(
    id: string,
    done: () => Promise<any>,
  ): void {
    if (!seenIds.has(id)) {
      seenIds.add(id)
      registeredIds.add(id)
      done()
        .catch(() => {})
        .finally(() => markIdAsDone(id))
    }
  }

  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
    if (ignoredId) {
      seenIds.add(ignoredId)
      markIdAsDone(ignoredId)
    } else {
      checkIfCrawlEndAfterTimeout()
    }
    return onCrawlEndPromiseWithResolvers.promise
  }

  function markIdAsDone(id: string): void {
    registeredIds.delete(id)
    checkIfCrawlEndAfterTimeout()
  }

  function checkIfCrawlEndAfterTimeout() {
    if (cancelled || registeredIds.size > 0) return

    if (timeoutHandle) clearTimeout(timeoutHandle)
    timeoutHandle = setTimeout(
      callOnCrawlEndWhenIdle,
      callCrawlEndIfIdleAfterMs,
    )
  }
  async function callOnCrawlEndWhenIdle() {
    if (cancelled || registeredIds.size > 0) return
    onCrawlEndPromiseWithResolvers.resolve()
  }

  return {
    registerRequestProcessing,
    waitForRequestsIdle,
    cancel,
  }
}



================================================
FILE: packages/vite/src/node/server/hmr.ts
================================================
import fsp from 'node:fs/promises'
import path from 'node:path'
import { EventEmitter } from 'node:events'
import colors from 'picocolors'
import type { CustomPayload, HotPayload, Update } from 'types/hmrPayload'
import type { RollupError } from 'rollup'
import type {
  InvokeMethods,
  InvokeResponseData,
  InvokeSendData,
} from '../../shared/invokeMethods'
import { CLIENT_DIR } from '../constants'
import { createDebugger, monotonicDateNow, normalizePath } from '../utils'
import type { InferCustomEventPayload, ViteDevServer } from '..'
import { getHookHandler } from '../plugins'
import { isExplicitImportRequired } from '../plugins/importAnalysis'
import { getEnvFilesForMode } from '../env'
import type { Environment } from '../environment'
import { withTrailingSlash, wrapId } from '../../shared/utils'
import type { Plugin } from '../plugin'
import {
  ignoreDeprecationWarnings,
  warnFutureDeprecation,
} from '../deprecations'
import type { EnvironmentModuleNode } from './moduleGraph'
import type { ModuleNode } from './mixedModuleGraph'
import type { DevEnvironment } from './environment'
import { prepareError } from './middlewares/error'
import {
  BasicMinimalPluginContext,
  basePluginContextMeta,
} from './pluginContainer'
import type { HttpServer } from '.'
import { restartServerWithUrls } from '.'

export const debugHmr = createDebugger('vite:hmr')

const whitespaceRE = /\s/

const normalizedClientDir = normalizePath(CLIENT_DIR)

export interface HmrOptions {
  protocol?: string
  host?: string
  port?: number
  clientPort?: number
  path?: string
  timeout?: number
  overlay?: boolean
  server?: HttpServer
}

export interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}

export interface HmrContext {
  file: string
  timestamp: number
  modules: Array<ModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}

interface PropagationBoundary {
  boundary: EnvironmentModuleNode & { type: 'js' | 'css' }
  acceptedVia: EnvironmentModuleNode
  isWithinCircularImport: boolean
}

export interface HotChannelClient {
  send(payload: HotPayload): void
}

export type HotChannelListener<T extends string = string> = (
  data: InferCustomEventPayload<T>,
  client: HotChannelClient,
) => void

export interface HotChannel<Api = any> {
  /**
   * Broadcast events to all clients
   */
  send?(payload: HotPayload): void
  /**
   * Handle custom event emitted by `import.meta.hot.send`
   */
  on?<T extends string>(event: T, listener: HotChannelListener<T>): void
  on?(event: 'connection', listener: () => void): void
  /**
   * Unregister event listener
   */
  off?(event: string, listener: Function): void
  /**
   * Start listening for messages
   */
  listen?(): void
  /**
   * Disconnect all clients, called when server is closed or restarted.
   */
  close?(): Promise<unknown> | void

  api?: Api
}

export function getShortName(file: string, root: string): string {
  return file.startsWith(withTrailingSlash(root))
    ? path.posix.relative(root, file)
    : file
}

export interface NormalizedHotChannelClient {
  /**
   * Send event to the client
   */
  send(payload: HotPayload): void
  /**
   * Send custom event
   */
  send(event: string, payload?: CustomPayload['data']): void
}

export interface NormalizedHotChannel<Api = any> {
  /**
   * Broadcast events to all clients
   */
  send(payload: HotPayload): void
  /**
   * Send custom event
   */
  send<T extends string>(event: T, payload?: InferCustomEventPayload<T>): void
  /**
   * Handle custom event emitted by `import.meta.hot.send`
   */
  on<T extends string>(
    event: T,
    listener: (
      data: InferCustomEventPayload<T>,
      client: NormalizedHotChannelClient,
    ) => void,
  ): void
  on(event: 'connection', listener: () => void): void
  /**
   * Unregister event listener
   */
  off(event: string, listener: Function): void
  /** @internal */
  setInvokeHandler(invokeHandlers: InvokeMethods | undefined): void
  handleInvoke(payload: HotPayload): Promise<{ result: any } | { error: any }>
  /**
   * Start listening for messages
   */
  listen(): void
  /**
   * Disconnect all clients, called when server is closed or restarted.
   */
  close(): Promise<unknown> | void

  api?: Api
}

export const normalizeHotChannel = (
  channel: HotChannel,
  enableHmr: boolean,
  normalizeClient = true,
): NormalizedHotChannel => {
  const normalizedListenerMap = new WeakMap<
    (data: any, client: NormalizedHotChannelClient) => void | Promise<void>,
    (data: any, client: HotChannelClient) => void | Promise<void>
  >()
  const listenersForEvents = new Map<
    string,
    Set<(data: any, client: HotChannelClient) => void | Promise<void>>
  >()

  let invokeHandlers: InvokeMethods | undefined
  let listenerForInvokeHandler:
    | ((data: InvokeSendData, client: HotChannelClient) => void)
    | undefined
  const handleInvoke = async <T extends keyof InvokeMethods>(
    payload: HotPayload,
  ) => {
    if (!invokeHandlers) {
      return {
        error: {
          name: 'TransportError',
          message: 'invokeHandlers is not set',
          stack: new Error().stack,
        },
      }
    }

    const data: InvokeSendData<T> = (payload as CustomPayload).data
    const { name, data: args } = data
    try {
      const invokeHandler = invokeHandlers[name]
      // @ts-expect-error `invokeHandler` is `InvokeMethods[T]`, so passing the args is fine
      const result = await invokeHandler(...args)
      return { result }
    } catch (error) {
      return {
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
          ...error, // preserve enumerable properties such as RollupError.loc, frame, plugin
        },
      }
    }
  }

  return {
    ...channel,
    on: (
      event: string,
      fn: (data: any, client: NormalizedHotChannelClient) => void,
    ) => {
      if (event === 'connection' || !normalizeClient) {
        channel.on?.(event, fn as () => void)
        return
      }

      const listenerWithNormalizedClient = (
        data: any,
        client: HotChannelClient,
      ) => {
        const normalizedClient: NormalizedHotChannelClient = {
          send: (...args) => {
            let payload: HotPayload
            if (typeof args[0] === 'string') {
              payload = {
                type: 'custom',
                event: args[0],
                data: args[1],
              }
            } else {
              payload = args[0]
            }
            client.send(payload)
          },
        }
        fn(data, normalizedClient)
      }
      normalizedListenerMap.set(fn, listenerWithNormalizedClient)

      channel.on?.(event, listenerWithNormalizedClient)
      if (!listenersForEvents.has(event)) {
        listenersForEvents.set(event, new Set())
      }
      listenersForEvents.get(event)!.add(listenerWithNormalizedClient)
    },
    off: (event: string, fn: () => void) => {
      if (event === 'connection' || !normalizeClient) {
        channel.off?.(event, fn as () => void)
        return
      }

      const normalizedListener = normalizedListenerMap.get(fn)
      if (normalizedListener) {
        channel.off?.(event, normalizedListener)
        listenersForEvents.get(event)?.delete(normalizedListener)
      }
    },
    setInvokeHandler(_invokeHandlers) {
      invokeHandlers = _invokeHandlers
      if (!_invokeHandlers) {
        if (listenerForInvokeHandler) {
          channel.off?.('vite:invoke', listenerForInvokeHandler)
        }
        return
      }

      listenerForInvokeHandler = async (payload, client) => {
        const responseInvoke = payload.id.replace('send', 'response') as
          | 'response'
          | `response:${string}`
        client.send({
          type: 'custom',
          event: 'vite:invoke',
          data: {
            name: payload.name,
            id: responseInvoke,
            data: (await handleInvoke({
              type: 'custom',
              event: 'vite:invoke',
              data: payload,
            }))!,
          } satisfies InvokeResponseData,
        })
      }
      channel.on?.('vite:invoke', listenerForInvokeHandler)
    },
    handleInvoke,
    send: (...args: any[]) => {
      let payload: HotPayload
      if (typeof args[0] === 'string') {
        payload = {
          type: 'custom',
          event: args[0],
          data: args[1],
        }
      } else {
        payload = args[0]
      }

      if (
        enableHmr ||
        payload.type === 'connected' ||
        payload.type === 'ping' ||
        payload.type === 'custom' ||
        payload.type === 'error'
      ) {
        channel.send?.(payload)
      }
    },
    listen() {
      return channel.listen?.()
    },
    close() {
      return channel.close?.()
    },
  }
}

export function getSortedPluginsByHotUpdateHook(
  plugins: readonly Plugin[],
): Plugin[] {
  const sortedPlugins: Plugin[] = []
  // Use indexes to track and insert the ordered plugins directly in the
  // resulting array to avoid creating 3 extra temporary arrays per hook
  let pre = 0,
    normal = 0,
    post = 0
  for (const plugin of plugins) {
    const hook = plugin['hotUpdate'] ?? plugin['handleHotUpdate']
    if (hook) {
      if (typeof hook === 'object') {
        if (hook.order === 'pre') {
          sortedPlugins.splice(pre++, 0, plugin)
          continue
        }
        if (hook.order === 'post') {
          sortedPlugins.splice(pre + normal + post++, 0, plugin)
          continue
        }
      }
      sortedPlugins.splice(pre + normal++, 0, plugin)
    }
  }

  return sortedPlugins
}

const sortedHotUpdatePluginsCache = new WeakMap<Environment, Plugin[]>()
function getSortedHotUpdatePlugins(environment: Environment): Plugin[] {
  let sortedPlugins = sortedHotUpdatePluginsCache.get(environment)
  if (!sortedPlugins) {
    sortedPlugins = getSortedPluginsByHotUpdateHook(environment.plugins)
    sortedHotUpdatePluginsCache.set(environment, sortedPlugins)
  }
  return sortedPlugins
}

export async function handleHMRUpdate(
  type: 'create' | 'delete' | 'update',
  file: string,
  server: ViteDevServer,
): Promise<void> {
  const { config } = server
  const mixedModuleGraph = ignoreDeprecationWarnings(() => server.moduleGraph)

  const environments = Object.values(server.environments)
  const shortFile = getShortName(file, config.root)

  const isConfig = file === config.configFile
  const isConfigDependency = config.configFileDependencies.some(
    (name) => file === name,
  )

  const isEnv =
    config.envDir !== false &&
    getEnvFilesForMode(config.mode, config.envDir).includes(file)
  if (isConfig || isConfigDependency || isEnv) {
    // auto restart server
    debugHmr?.(`[config change] ${colors.dim(shortFile)}`)
    config.logger.info(
      colors.green(
        `${normalizePath(
          path.relative(process.cwd(), file),
        )} changed, restarting server...`,
      ),
      { clear: true, timestamp: true },
    )
    try {
      await restartServerWithUrls(server)
    } catch (e) {
      config.logger.error(colors.red(e))
    }
    return
  }

  debugHmr?.(`[file change] ${colors.dim(shortFile)}`)

  // (dev only) the client itself cannot be hot updated.
  if (file.startsWith(withTrailingSlash(normalizedClientDir))) {
    environments.forEach(({ hot }) =>
      hot.send({
        type: 'full-reload',
        path: '*',
        triggeredBy: path.resolve(config.root, file),
      }),
    )
    return
  }

  const timestamp = monotonicDateNow()
  const contextMeta = {
    type,
    file,
    timestamp,
    read: () => readModifiedFile(file),
    server,
  }
  const hotMap = new Map<
    Environment,
    { options: HotUpdateOptions; error?: Error }
  >()

  for (const environment of Object.values(server.environments)) {
    const mods = new Set(environment.moduleGraph.getModulesByFile(file))
    if (type === 'create') {
      for (const mod of environment.moduleGraph._hasResolveFailedErrorModules) {
        mods.add(mod)
      }
    }
    const options = {
      ...contextMeta,
      modules: [...mods],
    }
    hotMap.set(environment, { options })
  }

  const mixedMods = new Set(mixedModuleGraph.getModulesByFile(file))

  const mixedHmrContext: HmrContext = {
    ...contextMeta,
    modules: [...mixedMods],
  }

  const contextForHandleHotUpdate = new BasicMinimalPluginContext(
    { ...basePluginContextMeta, watchMode: true },
    config.logger,
  )
  const clientEnvironment = server.environments.client
  const ssrEnvironment = server.environments.ssr
  const clientContext = clientEnvironment.pluginContainer.minimalContext
  const clientHotUpdateOptions = hotMap.get(clientEnvironment)!.options
  const ssrHotUpdateOptions = hotMap.get(ssrEnvironment)?.options
  try {
    for (const plugin of getSortedHotUpdatePlugins(
      server.environments.client,
    )) {
      if (plugin.hotUpdate) {
        const filteredModules = await getHookHandler(plugin.hotUpdate).call(
          clientContext,
          clientHotUpdateOptions,
        )
        if (filteredModules) {
          clientHotUpdateOptions.modules = filteredModules
          // Invalidate the hmrContext to force compat modules to be updated
          mixedHmrContext.modules = mixedHmrContext.modules.filter(
            (mixedMod) =>
              filteredModules.some((mod) => mixedMod.id === mod.id) ||
              ssrHotUpdateOptions?.modules.some(
                (ssrMod) => ssrMod.id === mixedMod.id,
              ),
          )
          mixedHmrContext.modules.push(
            ...filteredModules
              .filter(
                (mod) =>
                  !mixedHmrContext.modules.some(
                    (mixedMod) => mixedMod.id === mod.id,
                  ),
              )
              .map((mod) =>
                mixedModuleGraph.getBackwardCompatibleModuleNode(mod),
              ),
          )
        }
      } else if (type === 'update') {
        warnFutureDeprecation(
          config,
          'removePluginHookHandleHotUpdate',
          `Used in plugin "${plugin.name}".`,
          false,
        )
        // later on, we'll need: if (runtime === 'client')
        // Backward compatibility with mixed client and ssr moduleGraph
        const filteredModules = await getHookHandler(
          plugin.handleHotUpdate!,
        ).call(contextForHandleHotUpdate, mixedHmrContext)
        if (filteredModules) {
          mixedHmrContext.modules = filteredModules
          clientHotUpdateOptions.modules =
            clientHotUpdateOptions.modules.filter((mod) =>
              filteredModules.some((mixedMod) => mod.id === mixedMod.id),
            )
          clientHotUpdateOptions.modules.push(
            ...(filteredModules
              .filter(
                (mixedMod) =>
                  !clientHotUpdateOptions.modules.some(
                    (mod) => mod.id === mixedMod.id,
                  ),
              )
              .map((mixedMod) => mixedMod._clientModule)
              .filter(Boolean) as EnvironmentModuleNode[]),
          )
          if (ssrHotUpdateOptions) {
            ssrHotUpdateOptions.modules = ssrHotUpdateOptions.modules.filter(
              (mod) =>
                filteredModules.some((mixedMod) => mod.id === mixedMod.id),
            )
            ssrHotUpdateOptions.modules.push(
              ...(filteredModules
                .filter(
                  (mixedMod) =>
                    !ssrHotUpdateOptions.modules.some(
                      (mod) => mod.id === mixedMod.id,
                    ),
                )
                .map((mixedMod) => mixedMod._ssrModule)
                .filter(Boolean) as EnvironmentModuleNode[]),
            )
          }
        }
      }
    }
  } catch (error) {
    hotMap.get(server.environments.client)!.error = error
  }

  for (const environment of Object.values(server.environments)) {
    if (environment.name === 'client') continue
    const hot = hotMap.get(environment)!
    const context = environment.pluginContainer.minimalContext
    try {
      for (const plugin of getSortedHotUpdatePlugins(environment)) {
        if (plugin.hotUpdate) {
          const filteredModules = await getHookHandler(plugin.hotUpdate).call(
            context,
            hot.options,
          )
          if (filteredModules) {
            hot.options.modules = filteredModules
          }
        }
      }
    } catch (error) {
      hot.error = error
    }
  }

  async function hmr(environment: DevEnvironment) {
    try {
      const { options, error } = hotMap.get(environment)!
      if (error) {
        throw error
      }
      if (!options.modules.length) {
        // html file cannot be hot updated
        if (file.endsWith('.html') && environment.name === 'client') {
          environment.logger.info(
            colors.green(`page reload `) + colors.dim(shortFile),
            {
              clear: true,
              timestamp: true,
            },
          )
          environment.hot.send({
            type: 'full-reload',
            path: config.server.middlewareMode
              ? '*'
              : '/' + normalizePath(path.relative(config.root, file)),
          })
        } else {
          // loaded but not in the module graph, probably not js
          debugHmr?.(
            `(${environment.name}) [no modules matched] ${colors.dim(shortFile)}`,
          )
        }
        return
      }

      updateModules(environment, shortFile, options.modules, timestamp)
    } catch (err) {
      environment.hot.send({
        type: 'error',
        err: prepareError(err),
      })
    }
  }

  const hotUpdateEnvironments =
    server.config.server.hotUpdateEnvironments ??
    ((server, hmr) => {
      // Run HMR in parallel for all environments by default
      return Promise.all(
        Object.values(server.environments).map((environment) =>
          hmr(environment),
        ),
      )
    })

  await hotUpdateEnvironments(server, hmr)
}

type HasDeadEnd = string | boolean

export function updateModules(
  environment: DevEnvironment,
  file: string,
  modules: EnvironmentModuleNode[],
  timestamp: number,
  firstInvalidatedBy?: string,
): void {
  const { hot } = environment
  const updates: Update[] = []
  const invalidatedModules = new Set<EnvironmentModuleNode>()
  const traversedModules = new Set<EnvironmentModuleNode>()
  // Modules could be empty if a root module is invalidated via import.meta.hot.invalidate()
  let needFullReload: HasDeadEnd = modules.length === 0

  for (const mod of modules) {
    const boundaries: PropagationBoundary[] = []
    const hasDeadEnd = propagateUpdate(mod, traversedModules, boundaries)

    environment.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true,
    )

    if (needFullReload) {
      continue
    }

    if (hasDeadEnd) {
      needFullReload = hasDeadEnd
      continue
    }

    // If import.meta.hot.invalidate was called already on that module for the same update,
    // it means any importer of that module can't hot update. We should fallback to full reload.
    if (
      firstInvalidatedBy &&
      boundaries.some(
        ({ acceptedVia }) =>
          normalizeHmrUrl(acceptedVia.url) === firstInvalidatedBy,
      )
    ) {
      needFullReload = 'circular import invalidate'
      continue
    }

    updates.push(
      ...boundaries.map(
        ({ boundary, acceptedVia, isWithinCircularImport }) => ({
          type: `${boundary.type}-update` as const,
          timestamp,
          path: normalizeHmrUrl(boundary.url),
          acceptedPath: normalizeHmrUrl(acceptedVia.url),
          explicitImportRequired:
            boundary.type === 'js'
              ? isExplicitImportRequired(acceptedVia.url)
              : false,
          isWithinCircularImport,
          firstInvalidatedBy,
        }),
      ),
    )
  }

  // html file cannot be hot updated because it may be used as the template for a top-level request response.
  const isClientHtmlChange =
    file.endsWith('.html') &&
    environment.name === 'client' &&
    // if the html file is imported as a module, we assume that this file is
    // not used as the template for top-level request response
    // (i.e. not used by the middleware).
    modules.every((mod) => mod.type !== 'js')

  if (needFullReload || isClientHtmlChange) {
    const reason =
      typeof needFullReload === 'string'
        ? colors.dim(` (${needFullReload})`)
        : ''
    environment.logger.info(
      colors.green(`page reload `) + colors.dim(file) + reason,
      { clear: !firstInvalidatedBy, timestamp: true },
    )
    hot.send({
      type: 'full-reload',
      triggeredBy: path.resolve(environment.config.root, file),
      path:
        !isClientHtmlChange ||
        environment.config.server.middlewareMode ||
        updates.length > 0 // if there's an update, other URLs may be affected
          ? '*'
          : '/' + file,
    })
    return
  }

  if (updates.length === 0) {
    debugHmr?.(colors.yellow(`no update happened `) + colors.dim(file))
    return
  }

  environment.logger.info(
    colors.green(`hmr update `) +
      colors.dim([...new Set(updates.map((u) => u.path))].join(', ')),
    { clear: !firstInvalidatedBy, timestamp: true },
  )
  hot.send({
    type: 'update',
    updates,
  })
}

function areAllImportsAccepted(
  importedBindings: Set<string>,
  acceptedExports: Set<string>,
) {
  for (const binding of importedBindings) {
    if (!acceptedExports.has(binding)) {
      return false
    }
  }
  return true
}

function propagateUpdate(
  node: EnvironmentModuleNode,
  traversedModules: Set<EnvironmentModuleNode>,
  boundaries: PropagationBoundary[],
  currentChain: EnvironmentModuleNode[] = [node],
): HasDeadEnd {
  if (traversedModules.has(node)) {
    return false
  }
  traversedModules.add(node)

  // #7561
  // if the imports of `node` have not been analyzed, then `node` has not
  // been loaded in the browser and we should stop propagation.
  if (node.id && node.isSelfAccepting === undefined) {
    debugHmr?.(
      `[propagate update] stop propagation because not analyzed: ${colors.dim(
        node.id,
      )}`,
    )
    return false
  }

  if (node.isSelfAccepting) {
    // isSelfAccepting is only true for js and css
    const boundary = node as EnvironmentModuleNode & { type: 'js' | 'css' }
    boundaries.push({
      boundary,
      acceptedVia: boundary,
      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
    })
    return false
  }

  // A partially accepted module with no importers is considered self accepting,
  // because the deal is "there are parts of myself I can't self accept if they
  // are used outside of me".
  // Also, the imported module (this one) must be updated before the importers,
  // so that they do get the fresh imported module when/if they are reloaded.
  if (node.acceptedHmrExports) {
    // acceptedHmrExports is only true for js and css
    const boundary = node as EnvironmentModuleNode & { type: 'js' | 'css' }
    boundaries.push({
      boundary,
      acceptedVia: boundary,
      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
    })
  } else {
    if (!node.importers.size) {
      return true
    }
  }

  for (const importer of node.importers) {
    const subChain = currentChain.concat(importer)

    if (importer.acceptedHmrDeps.has(node)) {
      // acceptedHmrDeps has value only for js and css
      const boundary = importer as EnvironmentModuleNode & {
        type: 'js' | 'css'
      }
      boundaries.push({
        boundary,
        acceptedVia: node,
        isWithinCircularImport: isNodeWithinCircularImports(importer, subChain),
      })
      continue
    }

    if (node.id && node.acceptedHmrExports && importer.importedBindings) {
      const importedBindingsFromNode = importer.importedBindings.get(node.id)
      if (
        importedBindingsFromNode &&
        areAllImportsAccepted(importedBindingsFromNode, node.acceptedHmrExports)
      ) {
        continue
      }
    }

    if (
      !currentChain.includes(importer) &&
      propagateUpdate(importer, traversedModules, boundaries, subChain)
    ) {
      return true
    }
  }
  return false
}

/**
 * Check importers recursively if it's an import loop. An accepted module within
 * an import loop cannot recover its execution order and should be reloaded.
 *
 * @param node The node that accepts HMR and is a boundary
 * @param nodeChain The chain of nodes/imports that lead to the node.
 *   (The last node in the chain imports the `node` parameter)
 * @param currentChain The current chain tracked from the `node` parameter
 * @param traversedModules The set of modules that have traversed
 */
function isNodeWithinCircularImports(
  node: EnvironmentModuleNode,
  nodeChain: EnvironmentModuleNode[],
  currentChain: EnvironmentModuleNode[] = [node],
  traversedModules = new Set<EnvironmentModuleNode>(),
): boolean {
  // To help visualize how each parameter works, imagine this import graph:
  //
  // A -> B -> C -> ACCEPTED -> D -> E -> NODE
  //      ^--------------------------|
  //
  // ACCEPTED: the node that accepts HMR. the `node` parameter.
  // NODE    : the initial node that triggered this HMR.
  //
  // This function will return true in the above graph, which:
  // `node`         : ACCEPTED
  // `nodeChain`    : [NODE, E, D, ACCEPTED]
  // `currentChain` : [ACCEPTED, C, B]
  //
  // It works by checking if any `node` importers are within `nodeChain`, which
  // means there's an import loop with a HMR-accepted module in it.

  if (traversedModules.has(node)) {
    return false
  }
  traversedModules.add(node)

  for (const importer of node.importers) {
    // Node may import itself which is safe
    if (importer === node) continue

    // Check circular imports
    const importerIndex = nodeChain.indexOf(importer)
    if (importerIndex > -1) {
      // Log extra debug information so users can fix and remove the circular imports
      if (debugHmr) {
        // Following explanation above:
        // `importer`                    : E
        // `currentChain` reversed       : [B, C, ACCEPTED]
        // `nodeChain` sliced & reversed : [D, E]
        // Combined                      : [E, B, C, ACCEPTED, D, E]
        const importChain = [
          importer,
          ...[...currentChain].reverse(),
          ...nodeChain.slice(importerIndex, -1).reverse(),
        ]
        debugHmr(
          colors.yellow(`circular imports detected: `) +
            importChain.map((m) => colors.dim(m.url)).join(' -> '),
        )
      }
      return true
    }

    // Continue recursively
    if (!currentChain.includes(importer)) {
      const result = isNodeWithinCircularImports(
        importer,
        nodeChain,
        currentChain.concat(importer),
        traversedModules,
      )
      if (result) return result
    }
  }
  return false
}

export function handlePrunedModules(
  mods: Set<EnvironmentModuleNode>,
  { hot }: DevEnvironment,
): void {
  // update the disposed modules' hmr timestamp
  // since if it's re-imported, it should re-apply side effects
  // and without the timestamp the browser will not re-import it!
  const t = monotonicDateNow()
  mods.forEach((mod) => {
    mod.lastHMRTimestamp = t
    mod.lastHMRInvalidationReceived = false
    debugHmr?.(`[dispose] ${colors.dim(mod.file)}`)
  })
  hot.send({
    type: 'prune',
    paths: [...mods].map((m) => m.url),
  })
}

const enum LexerState {
  inCall,
  inSingleQuoteString,
  inDoubleQuoteString,
  inTemplateString,
  inArray,
}

/**
 * Lex import.meta.hot.accept() for accepted deps.
 * Since hot.accept() can only accept string literals or array of string
 * literals, we don't really need a heavy @babel/parse call on the entire source.
 *
 * @returns selfAccepts
 */
export function lexAcceptedHmrDeps(
  code: string,
  start: number,
  urls: Set<{ url: string; start: number; end: number }>,
): boolean {
  let state: LexerState = LexerState.inCall
  // the state can only be 2 levels deep so no need for a stack
  let prevState: LexerState = LexerState.inCall
  let currentDep: string = ''

  function addDep(index: number) {
    urls.add({
      url: currentDep,
      start: index - currentDep.length - 1,
      end: index + 1,
    })
    currentDep = ''
  }

  for (let i = start; i < code.length; i++) {
    const char = code.charAt(i)
    switch (state) {
      case LexerState.inCall:
      case LexerState.inArray:
        if (char === `'`) {
          prevState = state
          state = LexerState.inSingleQuoteString
        } else if (char === `"`) {
          prevState = state
          state = LexerState.inDoubleQuoteString
        } else if (char === '`') {
          prevState = state
          state = LexerState.inTemplateString
        } else if (whitespaceRE.test(char)) {
          continue
        } else {
          if (state === LexerState.inCall) {
            if (char === `[`) {
              state = LexerState.inArray
            } else {
              // reaching here means the first arg is neither a string literal
              // nor an Array literal (direct callback) or there is no arg
              // in both case this indicates a self-accepting module
              return true // done
            }
          } else {
            if (char === `]`) {
              return false // done
            } else if (char === ',') {
              continue
            } else {
              error(i)
            }
          }
        }
        break
      case LexerState.inSingleQuoteString:
        if (char === `'`) {
          addDep(i)
          if (prevState === LexerState.inCall) {
            // accept('foo', ...)
            return false
          } else {
            state = prevState
          }
        } else {
          currentDep += char
        }
        break
      case LexerState.inDoubleQuoteString:
        if (char === `"`) {
          addDep(i)
          if (prevState === LexerState.inCall) {
            // accept('foo', ...)
            return false
          } else {
            state = prevState
          }
        } else {
          currentDep += char
        }
        break
      case LexerState.inTemplateString:
        if (char === '`') {
          addDep(i)
          if (prevState === LexerState.inCall) {
            // accept('foo', ...)
            return false
          } else {
            state = prevState
          }
        } else if (char === '$' && code.charAt(i + 1) === '{') {
          error(i)
        } else {
          currentDep += char
        }
        break
      default:
        throw new Error('unknown import.meta.hot lexer state')
    }
  }
  return false
}

export function lexAcceptedHmrExports(
  code: string,
  start: number,
  exportNames: Set<string>,
): boolean {
  const urls = new Set<{ url: string; start: number; end: number }>()
  lexAcceptedHmrDeps(code, start, urls)
  for (const { url } of urls) {
    exportNames.add(url)
  }
  return urls.size > 0
}

export function normalizeHmrUrl(url: string): string {
  if (url[0] !== '.' && url[0] !== '/') {
    url = wrapId(url)
  }
  return url
}

function error(pos: number) {
  const err = new Error(
    `import.meta.hot.accept() can only accept string literals or an ` +
      `Array of string literals.`,
  ) as RollupError
  err.pos = pos
  throw err
}

// vitejs/vite#610 when hot-reloading Vue files, we read immediately on file
// change event and sometimes this can be too early and get an empty buffer.
// Poll until the file's modified time has changed before reading again.
async function readModifiedFile(file: string): Promise<string> {
  const content = await fsp.readFile(file, 'utf-8')
  if (!content) {
    const mtime = (await fsp.stat(file)).mtimeMs

    for (let n = 0; n < 10; n++) {
      await new Promise((r) => setTimeout(r, 10))
      const newMtime = (await fsp.stat(file)).mtimeMs
      if (newMtime !== mtime) {
        break
      }
    }

    return await fsp.readFile(file, 'utf-8')
  } else {
    return content
  }
}

export type ServerHotChannelApi = {
  innerEmitter: EventEmitter
  outsideEmitter: EventEmitter
}

export type ServerHotChannel = HotChannel<ServerHotChannelApi>
export type NormalizedServerHotChannel =
  NormalizedHotChannel<ServerHotChannelApi>

export function createServerHotChannel(): ServerHotChannel {
  const innerEmitter = new EventEmitter()
  const outsideEmitter = new EventEmitter()

  return {
    send(payload: HotPayload) {
      outsideEmitter.emit('send', payload)
    },
    off(event, listener: () => void) {
      innerEmitter.off(event, listener)
    },
    on: ((event: string, listener: () => unknown) => {
      innerEmitter.on(event, listener)
    }) as ServerHotChannel['on'],
    close() {
      innerEmitter.removeAllListeners()
      outsideEmitter.removeAllListeners()
    },
    listen() {
      innerEmitter.emit('connection')
    },
    api: {
      innerEmitter,
      outsideEmitter,
    },
  }
}



================================================
FILE: packages/vite/src/node/server/index.ts
================================================
import path from 'node:path'
import { execSync } from 'node:child_process'
import type * as net from 'node:net'
import { get as httpGet } from 'node:http'
import { get as httpsGet } from 'node:https'
import type * as http from 'node:http'
import { performance } from 'node:perf_hooks'
import type { Http2SecureServer } from 'node:http2'
import connect from 'connect'
import corsMiddleware from 'cors'
import colors from 'picocolors'
import chokidar from 'chokidar'
import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
import type { Connect } from 'dep-types/connect'
import launchEditorMiddleware from 'launch-editor-middleware'
import type { SourceMap } from 'rollup'
import type { ModuleRunner } from 'vite/module-runner'
import type { CommonServerOptions } from '../http'
import {
  httpServerStart,
  resolveHttpServer,
  resolveHttpsConfig,
  setClientErrorHandler,
} from '../http'
import type { InlineConfig, ResolvedConfig } from '../config'
import { isResolvedConfig, resolveConfig } from '../config'
import {
  type Hostname,
  diffDnsOrderChange,
  getServerUrlByHost,
  isInNodeModules,
  isObject,
  isParentDirectory,
  mergeConfig,
  mergeWithDefaults,
  monotonicDateNow,
  normalizePath,
  resolveHostname,
  resolveServerUrls,
  setupSIGTERMListener,
  teardownSIGTERMListener,
} from '../utils'
import { ssrLoadModule } from '../ssr/ssrModuleLoader'
import { ssrFixStacktrace, ssrRewriteStacktrace } from '../ssr/ssrStacktrace'
import { ssrTransform } from '../ssr/ssrTransform'
import { reloadOnTsconfigChange } from '../plugins/esbuild'
import { bindCLIShortcuts } from '../shortcuts'
import type { BindCLIShortcutsOptions } from '../shortcuts'
import {
  CLIENT_DIR,
  DEFAULT_DEV_PORT,
  defaultAllowedOrigins,
} from '../constants'
import type { Logger } from '../logger'
import { printServerUrls } from '../logger'
import { warnFutureDeprecation } from '../deprecations'
import {
  createNoopWatcher,
  getResolvedOutDirs,
  resolveChokidarOptions,
  resolveEmptyOutDir,
} from '../watch'
import { initPublicFiles } from '../publicDir'
import { getEnvFilesForMode } from '../env'
import type { RequiredExceptFor } from '../typeUtils'
import type { MinimalPluginContextWithoutEnvironment } from '../plugin'
import type { PluginContainer } from './pluginContainer'
import {
  BasicMinimalPluginContext,
  basePluginContextMeta,
  createPluginContainer,
} from './pluginContainer'
import type { WebSocketServer } from './ws'
import { createWebSocketServer } from './ws'
import { baseMiddleware } from './middlewares/base'
import { proxyMiddleware } from './middlewares/proxy'
import { htmlFallbackMiddleware } from './middlewares/htmlFallback'
import {
  cachedTransformMiddleware,
  transformMiddleware,
} from './middlewares/transform'
import {
  createDevHtmlTransformFn,
  indexHtmlMiddleware,
} from './middlewares/indexHtml'
import {
  servePublicMiddleware,
  serveRawFsMiddleware,
  serveStaticMiddleware,
} from './middlewares/static'
import { timeMiddleware } from './middlewares/time'
import { ModuleGraph } from './mixedModuleGraph'
import type { ModuleNode } from './mixedModuleGraph'
import { notFoundMiddleware } from './middlewares/notFound'
import { errorMiddleware } from './middlewares/error'
import type { HmrOptions, NormalizedHotChannel } from './hmr'
import { handleHMRUpdate, updateModules } from './hmr'
import { openBrowser as _openBrowser } from './openBrowser'
import type { TransformOptions, TransformResult } from './transformRequest'
import { searchForPackageRoot, searchForWorkspaceRoot } from './searchRoot'
import type { DevEnvironment } from './environment'
import { hostValidationMiddleware } from './middlewares/hostCheck'
import { rejectInvalidRequestMiddleware } from './middlewares/rejectInvalidRequest'

const usedConfigs = new WeakSet<ResolvedConfig>()

export interface ServerOptions extends CommonServerOptions {
  /**
   * Configure HMR-specific options (port, host, path & protocol)
   */
  hmr?: HmrOptions | boolean
  /**
   * Do not start the websocket connection.
   * @experimental
   */
  ws?: false
  /**
   * Warm-up files to transform and cache the results in advance. This improves the
   * initial page load during server starts and prevents transform waterfalls.
   */
  warmup?: {
    /**
     * The files to be transformed and used on the client-side. Supports glob patterns.
     */
    clientFiles?: string[]
    /**
     * The files to be transformed and used in SSR. Supports glob patterns.
     */
    ssrFiles?: string[]
  }
  /**
   * chokidar watch options or null to disable FS watching
   * https://github.com/paulmillr/chokidar/tree/3.6.0#api
   */
  watch?: WatchOptions | null
  /**
   * Create Vite dev server to be used as a middleware in an existing server
   * @default false
   */
  middlewareMode?:
    | boolean
    | {
        /**
         * Parent server instance to attach to
         *
         * This is needed to proxy WebSocket connections to the parent server.
         */
        server: HttpServer
      }
  /**
   * Options for files served via '/\@fs/'.
   */
  fs?: FileSystemServeOptions
  /**
   * Origin for the generated asset URLs.
   *
   * @example `http://127.0.0.1:8080`
   */
  origin?: string
  /**
   * Pre-transform known direct imports
   * @default true
   */
  preTransformRequests?: boolean
  /**
   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate
   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).
   *
   * By default, it excludes all paths containing `node_modules`. You can pass `false` to
   * disable this behavior, or, for full control, a function that takes the source path and
   * sourcemap path and returns whether to ignore the source path.
   */
  sourcemapIgnoreList?:
    | false
    | ((sourcePath: string, sourcemapPath: string) => boolean)
  /**
   * Backward compatibility. The buildStart and buildEnd hooks were called only once for all
   * environments. This option enables per-environment buildStart and buildEnd hooks.
   * @default false
   * @experimental
   */
  perEnvironmentStartEndDuringDev?: boolean
  /**
   * Run HMR tasks, by default the HMR propagation is done in parallel for all environments
   * @experimental
   */
  hotUpdateEnvironments?: (
    server: ViteDevServer,
    hmr: (environment: DevEnvironment) => Promise<void>,
  ) => Promise<void>
}

export interface ResolvedServerOptions
  extends Omit<
    RequiredExceptFor<
      ServerOptions,
      | 'host'
      | 'https'
      | 'proxy'
      | 'hmr'
      | 'ws'
      | 'watch'
      | 'origin'
      | 'hotUpdateEnvironments'
    >,
    'fs' | 'middlewareMode' | 'sourcemapIgnoreList'
  > {
  fs: Required<FileSystemServeOptions>
  middlewareMode: NonNullable<ServerOptions['middlewareMode']>
  sourcemapIgnoreList: Exclude<
    ServerOptions['sourcemapIgnoreList'],
    false | undefined
  >
}

export interface FileSystemServeOptions {
  /**
   * Strictly restrict file accessing outside of allowing paths.
   *
   * Set to `false` to disable the warning
   *
   * @default true
   */
  strict?: boolean

  /**
   * Restrict accessing files outside the allowed directories.
   *
   * Accepts absolute path or a path relative to project root.
   * Will try to search up for workspace root by default.
   */
  allow?: string[]

  /**
   * Restrict accessing files that matches the patterns.
   *
   * This will have higher priority than `allow`.
   * picomatch patterns are supported.
   *
   * @default ['.env', '.env.*', '*.{crt,pem}', '**\/.git/**']
   */
  deny?: string[]
}

export type ServerHook = (
  this: MinimalPluginContextWithoutEnvironment,
  server: ViteDevServer,
) => (() => void) | void | Promise<(() => void) | void>

export type HttpServer = http.Server | Http2SecureServer

export interface ViteDevServer {
  /**
   * The resolved vite config object
   */
  config: ResolvedConfig
  /**
   * A connect app instance.
   * - Can be used to attach custom middlewares to the dev server.
   * - Can also be used as the handler function of a custom http server
   *   or as a middleware in any connect-style Node.js frameworks
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * native Node http server instance
   * will be null in middleware mode
   */
  httpServer: HttpServer | null
  /**
   * Chokidar watcher instance. If `config.server.watch` is set to `null`,
   * it will not watch any files and calling `add` or `unwatch` will have no effect.
   * https://github.com/paulmillr/chokidar/tree/3.6.0#api
   */
  watcher: FSWatcher
  /**
   * web socket server with `send(payload)` method
   */
  ws: WebSocketServer
  /**
   * An alias to `server.environments.client.hot`.
   * If you want to interact with all environments, loop over `server.environments`.
   */
  hot: NormalizedHotChannel
  /**
   * Rollup plugin container that can run plugin hooks on a given file
   */
  pluginContainer: PluginContainer
  /**
   * Module execution environments attached to the Vite server.
   */
  environments: Record<'client' | 'ssr' | (string & {}), DevEnvironment>
  /**
   * Module graph that tracks the import relationships, url to file mapping
   * and hmr state.
   */
  moduleGraph: ModuleGraph
  /**
   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`
   * in middleware mode or if the server is not listening on any port.
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * Programmatically resolve, load and transform a URL and get the result
   * without going through the http request pipeline.
   */
  transformRequest(
    url: string,
    options?: TransformOptions,
  ): Promise<TransformResult | null>
  /**
   * Same as `transformRequest` but only warm up the URLs so the next request
   * will already be cached. The function will never throw as it handles and
   * reports errors internally.
   */
  warmupRequest(url: string, options?: TransformOptions): Promise<void>
  /**
   * Apply vite built-in HTML transforms and any plugin HTML transforms.
   */
  transformIndexHtml(
    url: string,
    html: string,
    originalUrl?: string,
  ): Promise<string>
  /**
   * Transform module code into SSR format.
   */
  ssrTransform(
    code: string,
    inMap: SourceMap | { mappings: '' } | null,
    url: string,
    originalCode?: string,
  ): Promise<TransformResult | null>
  /**
   * Load a given URL as an instantiated module for SSR.
   */
  ssrLoadModule(
    url: string,
    opts?: { fixStacktrace?: boolean },
  ): Promise<Record<string, any>>
  /**
   * Returns a fixed version of the given stack
   */
  ssrRewriteStacktrace(stack: string): string
  /**
   * Mutates the given SSR error by rewriting the stacktrace
   */
  ssrFixStacktrace(e: Error): void
  /**
   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
   */
  reloadModule(module: ModuleNode): Promise<void>
  /**
   * Start the server.
   */
  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
  /**
   * Stop the server.
   */
  close(): Promise<void>
  /**
   * Print server urls
   */
  printUrls(): void
  /**
   * Bind CLI shortcuts
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
  /**
   * Restart the server.
   *
   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
   */
  restart(forceOptimize?: boolean): Promise<void>
  /**
   * Open browser
   */
  openBrowser(): void
  /**
   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
   * are processed. If called from a load or transform plugin hook, the id needs to be
   * passed as a parameter to avoid deadlocks. Calling this function after the first
   * static imports section of the module graph has been processed will resolve immediately.
   */
  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
  /**
   * @internal
   */
  _setInternalServer(server: ViteDevServer): void
  /**
   * @internal
   */
  _restartPromise: Promise<void> | null
  /**
   * @internal
   */
  _forceOptimizeOnRestart: boolean
  /**
   * @internal
   */
  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>
  /**
   * @internal
   */
  _currentServerPort?: number | undefined
  /**
   * @internal
   */
  _configServerPort?: number | undefined
  /**
   * @internal
   */
  _ssrCompatModuleRunner?: ModuleRunner
}

export interface ResolvedServerUrls {
  local: string[]
  network: string[]
}

export function createServer(
  inlineConfig: InlineConfig | ResolvedConfig = {},
): Promise<ViteDevServer> {
  return _createServer(inlineConfig, { listen: true })
}

export async function _createServer(
  inlineConfig: InlineConfig | ResolvedConfig = {},
  options: {
    listen: boolean
    previousEnvironments?: Record<string, DevEnvironment>
  },
): Promise<ViteDevServer> {
  const config = isResolvedConfig(inlineConfig)
    ? inlineConfig
    : await resolveConfig(inlineConfig, 'serve')

  if (usedConfigs.has(config)) {
    throw new Error(`There is already a server associated with the config.`)
  }

  if (config.command !== 'serve') {
    throw new Error(
      `Config was resolved for a "build", expected a "serve" command.`,
    )
  }

  usedConfigs.add(config)

  const initPublicFilesPromise = initPublicFiles(config)

  const { root, server: serverConfig } = config
  const httpsOptions = await resolveHttpsConfig(config.server.https)
  const { middlewareMode } = serverConfig

  const resolvedOutDirs = getResolvedOutDirs(
    config.root,
    config.build.outDir,
    config.build.rollupOptions.output,
  )
  const emptyOutDir = resolveEmptyOutDir(
    config.build.emptyOutDir,
    config.root,
    resolvedOutDirs,
  )
  const resolvedWatchOptions = resolveChokidarOptions(
    {
      disableGlobbing: true,
      ...serverConfig.watch,
    },
    resolvedOutDirs,
    emptyOutDir,
    config.cacheDir,
  )

  const middlewares = connect() as Connect.Server
  const httpServer = middlewareMode
    ? null
    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)

  const ws = createWebSocketServer(httpServer, config, httpsOptions)

  const publicFiles = await initPublicFilesPromise
  const { publicDir } = config

  if (httpServer) {
    setClientErrorHandler(httpServer, config.logger)
  }

  // eslint-disable-next-line eqeqeq
  const watchEnabled = serverConfig.watch !== null
  const watcher = watchEnabled
    ? (chokidar.watch(
        // config file dependencies and env file might be outside of root
        [
          root,
          ...config.configFileDependencies,
          ...getEnvFilesForMode(config.mode, config.envDir),
          // Watch the public directory explicitly because it might be outside
          // of the root directory.
          ...(publicDir && publicFiles ? [publicDir] : []),
        ],

        resolvedWatchOptions,
      ) as FSWatcher)
    : createNoopWatcher(resolvedWatchOptions)

  const environments: Record<string, DevEnvironment> = {}

  for (const [name, environmentOptions] of Object.entries(
    config.environments,
  )) {
    environments[name] = await environmentOptions.dev.createEnvironment(
      name,
      config,
      {
        ws,
      },
    )
  }

  for (const environment of Object.values(environments)) {
    const previousInstance = options.previousEnvironments?.[environment.name]
    await environment.init({ watcher, previousInstance })
  }

  // Backward compatibility

  let moduleGraph = new ModuleGraph({
    client: () => environments.client.moduleGraph,
    ssr: () => environments.ssr.moduleGraph,
  })
  let pluginContainer = createPluginContainer(environments)

  const closeHttpServer = createServerCloseFn(httpServer)

  const devHtmlTransformFn = createDevHtmlTransformFn(config)

  // Promise used by `server.close()` to ensure `closeServer()` is only called once
  let closeServerPromise: Promise<void> | undefined
  const closeServer = async () => {
    if (!middlewareMode) {
      teardownSIGTERMListener(closeServerAndExit)
    }

    await Promise.allSettled([
      watcher.close(),
      ws.close(),
      Promise.allSettled(
        Object.values(server.environments).map((environment) =>
          environment.close(),
        ),
      ),
      closeHttpServer(),
      server._ssrCompatModuleRunner?.close(),
    ])
    server.resolvedUrls = null
    server._ssrCompatModuleRunner = undefined
  }

  let hot = ws
  let server: ViteDevServer = {
    config,
    middlewares,
    httpServer,
    watcher,
    ws,
    get hot() {
      warnFutureDeprecation(config, 'removeServerHot')
      return hot
    },
    set hot(h) {
      hot = h
    },

    environments,
    get pluginContainer() {
      warnFutureDeprecation(config, 'removeServerPluginContainer')
      return pluginContainer
    },
    set pluginContainer(p) {
      pluginContainer = p
    },
    get moduleGraph() {
      warnFutureDeprecation(config, 'removeServerModuleGraph')
      return moduleGraph
    },
    set moduleGraph(graph) {
      moduleGraph = graph
    },

    resolvedUrls: null, // will be set on listen
    ssrTransform(
      code: string,
      inMap: SourceMap | { mappings: '' } | null,
      url: string,
      originalCode = code,
    ) {
      return ssrTransform(code, inMap, url, originalCode, {
        json: {
          stringify:
            config.json.stringify === true && config.json.namedExports !== true,
        },
      })
    },
    transformRequest(url, options) {
      warnFutureDeprecation(config, 'removeServerTransformRequest')
      const environment = server.environments[options?.ssr ? 'ssr' : 'client']
      return environment.transformRequest(url)
    },
    warmupRequest(url, options) {
      warnFutureDeprecation(config, 'removeServerWarmupRequest')
      const environment = server.environments[options?.ssr ? 'ssr' : 'client']
      return environment.warmupRequest(url)
    },
    transformIndexHtml(url, html, originalUrl) {
      return devHtmlTransformFn(server, url, html, originalUrl)
    },
    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {
      warnFutureDeprecation(config, 'removeSsrLoadModule')
      return ssrLoadModule(url, server, opts?.fixStacktrace)
    },
    ssrFixStacktrace(e) {
      warnFutureDeprecation(
        config,
        'removeSsrLoadModule',
        "ssrFixStacktrace doesn't need to be used for Environment Module Runners.",
      )
      ssrFixStacktrace(e, server.environments.ssr.moduleGraph)
    },
    ssrRewriteStacktrace(stack: string) {
      warnFutureDeprecation(
        config,
        'removeSsrLoadModule',
        "ssrRewriteStacktrace doesn't need to be used for Environment Module Runners.",
      )
      return ssrRewriteStacktrace(stack, server.environments.ssr.moduleGraph)
    },
    async reloadModule(module) {
      warnFutureDeprecation(config, 'removeServerReloadModule')
      if (serverConfig.hmr !== false && module.file) {
        // TODO: Should we also update the node moduleGraph for backward compatibility?
        const environmentModule = (module._clientModule ?? module._ssrModule)!
        updateModules(
          environments[environmentModule.environment]!,
          module.file,
          [environmentModule],
          monotonicDateNow(),
        )
      }
    },
    async listen(port?: number, isRestart?: boolean) {
      const hostname = await resolveHostname(config.server.host)
      if (httpServer) {
        httpServer.prependListener('listening', () => {
          server.resolvedUrls = resolveServerUrls(
            httpServer,
            config.server,
            hostname,
            httpsOptions,
            config,
          )
        })
      }
      await startServer(server, hostname, port)
      if (httpServer) {
        if (!isRestart && config.server.open) server.openBrowser()
      }
      return server
    },
    openBrowser() {
      const options = server.config.server
      const url = getServerUrlByHost(server.resolvedUrls, options.host)
      if (url) {
        const path =
          typeof options.open === 'string'
            ? new URL(options.open, url).href
            : url

        // We know the url that the browser would be opened to, so we can
        // start the request while we are awaiting the browser. This will
        // start the crawling of static imports ~500ms before.
        // preTransformRequests needs to be enabled for this optimization.
        if (server.config.server.preTransformRequests) {
          setTimeout(() => {
            const getMethod = path.startsWith('https:') ? httpsGet : httpGet

            getMethod(
              path,
              {
                headers: {
                  // Allow the history middleware to redirect to /index.html
                  Accept: 'text/html',
                },
              },
              (res) => {
                res.on('end', () => {
                  // Ignore response, scripts discovered while processing the entry
                  // will be preprocessed (server.config.server.preTransformRequests)
                })
              },
            )
              .on('error', () => {
                // Ignore errors
              })
              .end()
          }, 0)
        }

        _openBrowser(path, true, server.config.logger)
      } else {
        server.config.logger.warn('No URL available to open in browser')
      }
    },
    async close() {
      if (!closeServerPromise) {
        closeServerPromise = closeServer()
      }
      return closeServerPromise
    },
    printUrls() {
      if (server.resolvedUrls) {
        printServerUrls(
          server.resolvedUrls,
          serverConfig.host,
          config.logger.info,
        )
      } else if (middlewareMode) {
        throw new Error('cannot print server URLs in middleware mode.')
      } else {
        throw new Error(
          'cannot print server URLs before server.listen is called.',
        )
      }
    },
    bindCLIShortcuts(options) {
      bindCLIShortcuts(server, options)
    },
    async restart(forceOptimize?: boolean) {
      if (!server._restartPromise) {
        server._forceOptimizeOnRestart = !!forceOptimize
        server._restartPromise = restartServer(server).finally(() => {
          server._restartPromise = null
          server._forceOptimizeOnRestart = false
        })
      }
      return server._restartPromise
    },

    waitForRequestsIdle(ignoredId?: string): Promise<void> {
      return environments.client.waitForRequestsIdle(ignoredId)
    },

    _setInternalServer(_server: ViteDevServer) {
      // Rebind internal the server variable so functions reference the user
      // server instance after a restart
      server = _server
    },
    _restartPromise: null,
    _forceOptimizeOnRestart: false,
    _shortcutsOptions: undefined,
  }

  // maintain consistency with the server instance after restarting.
  const reflexServer = new Proxy(server, {
    get: (_, property: keyof ViteDevServer) => {
      return server[property]
    },
    set: (_, property: keyof ViteDevServer, value: never) => {
      server[property] = value
      return true
    },
  })

  const closeServerAndExit = async (_: unknown, exitCode?: number) => {
    try {
      await server.close()
    } finally {
      process.exitCode ??= exitCode ? 128 + exitCode : undefined
      process.exit()
    }
  }

  if (!middlewareMode) {
    setupSIGTERMListener(closeServerAndExit)
  }

  const onHMRUpdate = async (
    type: 'create' | 'delete' | 'update',
    file: string,
  ) => {
    if (serverConfig.hmr !== false) {
      await handleHMRUpdate(type, file, server)
    }
  }

  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {
    file = normalizePath(file)
    reloadOnTsconfigChange(server, file)

    await pluginContainer.watchChange(file, {
      event: isUnlink ? 'delete' : 'create',
    })

    if (publicDir && publicFiles) {
      if (file.startsWith(publicDir)) {
        const path = file.slice(publicDir.length)
        publicFiles[isUnlink ? 'delete' : 'add'](path)
        if (!isUnlink) {
          const clientModuleGraph = server.environments.client.moduleGraph
          const moduleWithSamePath =
            await clientModuleGraph.getModuleByUrl(path)
          const etag = moduleWithSamePath?.transformResult?.etag
          if (etag) {
            // The public file should win on the next request over a module with the
            // same path. Prevent the transform etag fast path from serving the module
            clientModuleGraph.etagToModuleMap.delete(etag)
          }
        }
      }
    }
    if (isUnlink) {
      // invalidate module graph cache on file change
      for (const environment of Object.values(server.environments)) {
        environment.moduleGraph.onFileDelete(file)
      }
    }
    await onHMRUpdate(isUnlink ? 'delete' : 'create', file)
  }

  watcher.on('change', async (file) => {
    file = normalizePath(file)
    reloadOnTsconfigChange(server, file)

    await pluginContainer.watchChange(file, { event: 'update' })
    // invalidate module graph cache on file change
    for (const environment of Object.values(server.environments)) {
      environment.moduleGraph.onFileChange(file)
    }
    await onHMRUpdate('update', file)
  })

  watcher.on('add', (file) => {
    onFileAddUnlink(file, false)
  })
  watcher.on('unlink', (file) => {
    onFileAddUnlink(file, true)
  })

  if (!middlewareMode && httpServer) {
    httpServer.once('listening', () => {
      // update actual port since this may be different from initial value
      serverConfig.port = (httpServer.address() as net.AddressInfo).port
    })
  }

  // Pre applied internal middlewares ------------------------------------------

  // request timer
  if (process.env.DEBUG) {
    middlewares.use(timeMiddleware(root))
  }

  // disallows request that contains `#` in the URL
  middlewares.use(rejectInvalidRequestMiddleware())

  // cors
  const { cors } = serverConfig
  if (cors !== false) {
    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))
  }

  // host check (to prevent DNS rebinding attacks)
  const { allowedHosts } = serverConfig
  // no need to check for HTTPS as HTTPS is not vulnerable to DNS rebinding attacks
  if (allowedHosts !== true && !serverConfig.https) {
    middlewares.use(hostValidationMiddleware(allowedHosts, false))
  }

  // apply configureServer hooks ------------------------------------------------

  const configureServerContext = new BasicMinimalPluginContext(
    { ...basePluginContextMeta, watchMode: true },
    config.logger,
  )
  const postHooks: ((() => void) | void)[] = []
  for (const hook of config.getSortedPluginHooks('configureServer')) {
    postHooks.push(await hook.call(configureServerContext, reflexServer))
  }

  // Internal middlewares ------------------------------------------------------

  middlewares.use(cachedTransformMiddleware(server))

  // proxy
  const { proxy } = serverConfig
  if (proxy) {
    const middlewareServer =
      (isObject(middlewareMode) ? middlewareMode.server : null) || httpServer
    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))
  }

  // base
  if (config.base !== '/') {
    middlewares.use(baseMiddleware(config.rawBase, !!middlewareMode))
  }

  // open in editor support
  middlewares.use('/__open-in-editor', launchEditorMiddleware())

  // ping request handler
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  middlewares.use(function viteHMRPingMiddleware(req, res, next) {
    if (req.headers['accept'] === 'text/x-vite-ping') {
      res.writeHead(204).end()
    } else {
      next()
    }
  })

  // serve static files under /public
  // this applies before the transform middleware so that these files are served
  // as-is without transforms.
  if (publicDir) {
    middlewares.use(servePublicMiddleware(server, publicFiles))
  }

  // main transform middleware
  middlewares.use(transformMiddleware(server))

  // serve static files
  middlewares.use(serveRawFsMiddleware(server))
  middlewares.use(serveStaticMiddleware(server))

  // html fallback
  if (config.appType === 'spa' || config.appType === 'mpa') {
    middlewares.use(htmlFallbackMiddleware(root, config.appType === 'spa'))
  }

  // apply configureServer post hooks ------------------------------------------

  // This is applied before the html middleware so that user middleware can
  // serve custom content instead of index.html.
  postHooks.forEach((fn) => fn && fn())

  if (config.appType === 'spa' || config.appType === 'mpa') {
    // transform index.html
    middlewares.use(indexHtmlMiddleware(root, server))

    // handle 404s
    middlewares.use(notFoundMiddleware())
  }

  // error handler
  middlewares.use(errorMiddleware(server, !!middlewareMode))

  // httpServer.listen can be called multiple times
  // when port when using next port number
  // this code is to avoid calling buildStart multiple times
  let initingServer: Promise<void> | undefined
  let serverInited = false
  const initServer = async (onListen: boolean) => {
    if (serverInited) return
    if (initingServer) return initingServer

    initingServer = (async function () {
      // For backward compatibility, we call buildStart for the client
      // environment when initing the server. For other environments
      // buildStart will be called when the first request is transformed
      await environments.client.pluginContainer.buildStart()

      // ensure ws server started
      if (onListen || options.listen) {
        await Promise.all(
          Object.values(environments).map((e) => e.listen(server)),
        )
      }

      initingServer = undefined
      serverInited = true
    })()
    return initingServer
  }

  if (!middlewareMode && httpServer) {
    // overwrite listen to init optimizer before server start
    const listen = httpServer.listen.bind(httpServer)
    httpServer.listen = (async (port: number, ...args: any[]) => {
      try {
        await initServer(true)
      } catch (e) {
        httpServer.emit('error', e)
        return
      }
      return listen(port, ...args)
    }) as any
  } else {
    await initServer(false)
  }

  return server
}

async function startServer(
  server: ViteDevServer,
  hostname: Hostname,
  inlinePort?: number,
): Promise<void> {
  const httpServer = server.httpServer
  if (!httpServer) {
    throw new Error('Cannot call server.listen in middleware mode.')
  }

  const options = server.config.server
  const configPort = inlinePort ?? options.port
  // When using non strict port for the dev server, the running port can be different from the config one.
  // When restarting, the original port may be available but to avoid a switch of URL for the running
  // browser tabs, we enforce the previously used port, expect if the config port changed.
  const port =
    (!configPort || configPort === server._configServerPort
      ? server._currentServerPort
      : configPort) ?? DEFAULT_DEV_PORT
  server._configServerPort = configPort

  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options.strictPort,
    host: hostname.host,
    logger: server.config.logger,
  })
  server._currentServerPort = serverPort
}

export function createServerCloseFn(
  server: HttpServer | null,
): () => Promise<void> {
  if (!server) {
    return () => Promise.resolve()
  }

  let hasListened = false
  const openSockets = new Set<net.Socket>()

  server.on('connection', (socket) => {
    openSockets.add(socket)
    socket.on('close', () => {
      openSockets.delete(socket)
    })
  })

  server.once('listening', () => {
    hasListened = true
  })

  return () =>
    new Promise<void>((resolve, reject) => {
      openSockets.forEach((s) => s.destroy())
      if (hasListened) {
        server.close((err) => {
          if (err) {
            reject(err)
          } else {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
}

function resolvedAllowDir(root: string, dir: string): string {
  return normalizePath(path.resolve(root, dir))
}

export const serverConfigDefaults = Object.freeze({
  port: DEFAULT_DEV_PORT,
  strictPort: false,
  host: 'localhost',
  allowedHosts: [],
  https: undefined,
  open: false,
  proxy: undefined,
  cors: { origin: defaultAllowedOrigins },
  headers: {},
  // hmr
  // ws
  warmup: {
    clientFiles: [],
    ssrFiles: [],
  },
  // watch
  middlewareMode: false,
  fs: {
    strict: true,
    // allow
    deny: ['.env', '.env.*', '*.{crt,pem}', '**/.git/**'],
  },
  // origin
  preTransformRequests: true,
  // sourcemapIgnoreList
  perEnvironmentStartEndDuringDev: false,
  // hotUpdateEnvironments
} satisfies ServerOptions)

export function resolveServerOptions(
  root: string,
  raw: ServerOptions | undefined,
  logger: Logger,
): ResolvedServerOptions {
  const _server = mergeWithDefaults(
    {
      ...serverConfigDefaults,
      host: undefined, // do not set here to detect whether host is set or not
      sourcemapIgnoreList: isInNodeModules,
    },
    raw ?? {},
  )

  const server: ResolvedServerOptions = {
    ..._server,
    fs: {
      ..._server.fs,
      // run searchForWorkspaceRoot only if needed
      allow: raw?.fs?.allow ?? [searchForWorkspaceRoot(root)],
    },
    sourcemapIgnoreList:
      _server.sourcemapIgnoreList === false
        ? () => false
        : _server.sourcemapIgnoreList,
  }

  let allowDirs = server.fs.allow

  if (process.versions.pnp) {
    // running a command fails if cwd doesn't exist and root may not exist
    // search for package root to find a path that exists
    const cwd = searchForPackageRoot(root)
    try {
      const enableGlobalCache =
        execSync('yarn config get enableGlobalCache', { cwd })
          .toString()
          .trim() === 'true'
      const yarnCacheDir = execSync(
        `yarn config get ${enableGlobalCache ? 'globalFolder' : 'cacheFolder'}`,
        { cwd },
      )
        .toString()
        .trim()
      allowDirs.push(yarnCacheDir)
    } catch (e) {
      logger.warn(`Get yarn cache dir error: ${e.message}`, {
        timestamp: true,
      })
    }
  }

  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))

  // only push client dir when vite itself is outside-of-root
  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)
  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
    allowDirs.push(resolvedClientDir)
  }

  server.fs.allow = allowDirs

  if (server.origin?.endsWith('/')) {
    server.origin = server.origin.slice(0, -1)
    logger.warn(
      colors.yellow(
        `${colors.bold('(!)')} server.origin should not end with "/". Using "${
          server.origin
        }" instead.`,
      ),
    )
  }

  if (
    process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS &&
    Array.isArray(server.allowedHosts)
  ) {
    const additionalHost = process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS
    server.allowedHosts = [...server.allowedHosts, additionalHost]
  }

  return server
}

async function restartServer(server: ViteDevServer) {
  global.__vite_start_time = performance.now()
  const shortcutsOptions = server._shortcutsOptions

  let inlineConfig = server.config.inlineConfig
  if (server._forceOptimizeOnRestart) {
    inlineConfig = mergeConfig(inlineConfig, {
      forceOptimizeDeps: true,
    })
  }

  // Reinit the server by creating a new instance using the same inlineConfig
  // This will trigger a reload of the config file and re-create the plugins and
  // middlewares. We then assign all properties of the new server to the existing
  // server instance and set the user instance to be used in the new server.
  // This allows us to keep the same server instance for the user.
  {
    let newServer: ViteDevServer | null = null
    try {
      // delay ws server listen
      newServer = await _createServer(inlineConfig, {
        listen: false,
        previousEnvironments: server.environments,
      })
    } catch (err: any) {
      server.config.logger.error(err.message, {
        timestamp: true,
      })
      server.config.logger.error('server restart failed', { timestamp: true })
      return
    }

    await server.close()

    // Assign new server props to existing server instance
    const middlewares = server.middlewares
    newServer._configServerPort = server._configServerPort
    newServer._currentServerPort = server._currentServerPort
    Object.assign(server, newServer)

    // Keep the same connect instance so app.use(vite.middlewares) works
    // after a restart in middlewareMode (.route is always '/')
    middlewares.stack = newServer.middlewares.stack
    server.middlewares = middlewares

    // Rebind internal server variable so functions reference the user server
    newServer._setInternalServer(server)
  }

  const {
    logger,
    server: { port, middlewareMode },
  } = server.config
  if (!middlewareMode) {
    await server.listen(port, true)
  } else {
    await Promise.all(
      Object.values(server.environments).map((e) => e.listen(server)),
    )
  }
  logger.info('server restarted.', { timestamp: true })

  if (shortcutsOptions) {
    shortcutsOptions.print = false
    bindCLIShortcuts(server, shortcutsOptions)
  }
}

/**
 * Internal function to restart the Vite server and print URLs if changed
 */
export async function restartServerWithUrls(
  server: ViteDevServer,
): Promise<void> {
  if (server.config.server.middlewareMode) {
    await server.restart()
    return
  }

  const { port: prevPort, host: prevHost } = server.config.server
  const prevUrls = server.resolvedUrls

  await server.restart()

  const {
    logger,
    server: { port, host },
  } = server.config
  if (
    (port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) ||
    host !== prevHost ||
    diffDnsOrderChange(prevUrls, server.resolvedUrls)
  ) {
    logger.info('')
    server.printUrls()
  }
}



================================================
FILE: packages/vite/src/node/server/mixedModuleGraph.ts
================================================
import type { ModuleInfo } from 'rollup'
import { monotonicDateNow } from '../utils'
import type { TransformResult } from './transformRequest'
import type {
  EnvironmentModuleGraph,
  EnvironmentModuleNode,
  ResolvedUrl,
} from './moduleGraph'

/**
 * Backward compatible ModuleNode and ModuleGraph with mixed nodes from both the client and ssr environments
 * It would be good to take the types names for the new EnvironmentModuleNode and EnvironmentModuleGraph but we can't
 * do that at this point without breaking to much code in the ecosystem.
 * We are going to deprecate these types and we can try to use them back in the future.
 */

// same default value of "moduleInfo.meta" as in Rollup
const EMPTY_OBJECT = Object.freeze({})

export class ModuleNode {
  _moduleGraph: ModuleGraph
  _clientModule: EnvironmentModuleNode | undefined
  _ssrModule: EnvironmentModuleNode | undefined
  constructor(
    moduleGraph: ModuleGraph,
    clientModule?: EnvironmentModuleNode,
    ssrModule?: EnvironmentModuleNode,
  ) {
    this._moduleGraph = moduleGraph
    this._clientModule = clientModule
    this._ssrModule = ssrModule
  }
  _get<T extends keyof EnvironmentModuleNode>(
    prop: T,
  ): EnvironmentModuleNode[T] {
    return (this._clientModule?.[prop] ?? this._ssrModule?.[prop])!
  }
  _set<T extends keyof EnvironmentModuleNode>(
    prop: T,
    value: EnvironmentModuleNode[T],
  ): void {
    if (this._clientModule) {
      this._clientModule[prop] = value
    }
    if (this._ssrModule) {
      this._ssrModule[prop] = value
    }
  }

  _wrapModuleSet(
    prop: ModuleSetNames,
    module: EnvironmentModuleNode | undefined,
  ): Set<ModuleNode> {
    if (!module) {
      return new Set()
    }
    return createBackwardCompatibleModuleSet(this._moduleGraph, prop, module)
  }
  _getModuleSetUnion(prop: 'importedModules' | 'importers'): Set<ModuleNode> {
    // A good approximation to the previous logic that returned the union of
    // the importedModules and importers from both the browser and server
    const importedModules = new Set<ModuleNode>()
    const ids = new Set<string>()
    if (this._clientModule) {
      for (const mod of this._clientModule[prop]) {
        if (mod.id) ids.add(mod.id)
        importedModules.add(
          this._moduleGraph.getBackwardCompatibleModuleNode(mod),
        )
      }
    }
    if (this._ssrModule) {
      for (const mod of this._ssrModule[prop]) {
        if (mod.id && !ids.has(mod.id)) {
          importedModules.add(
            this._moduleGraph.getBackwardCompatibleModuleNode(mod),
          )
        }
      }
    }
    return importedModules
  }
  _getModuleInfoUnion(prop: 'info'): ModuleInfo | undefined {
    const _clientValue = this._clientModule?.[prop]
    const _ssrValue = this._ssrModule?.[prop]

    if (_clientValue == null && _ssrValue == null) return undefined

    return new Proxy({} as any, {
      get: (_, key: string) => {
        // `meta` refers to `ModuleInfo.meta` so we refer to `this.meta` to
        // handle the object union between client and ssr
        if (key === 'meta') {
          return this.meta || EMPTY_OBJECT
        }
        if (_clientValue) {
          if (key in _clientValue) {
            return _clientValue[key as keyof ModuleInfo]
          }
        }
        if (_ssrValue) {
          if (key in _ssrValue) {
            return _ssrValue[key as keyof ModuleInfo]
          }
        }
      },
    })
  }
  _getModuleObjectUnion(prop: 'meta'): Record<string, any> | undefined {
    const _clientValue = this._clientModule?.[prop]
    const _ssrValue = this._ssrModule?.[prop]

    if (_clientValue == null && _ssrValue == null) return undefined

    const info: Record<string, any> = {}
    if (_ssrValue) {
      Object.assign(info, _ssrValue)
    }
    if (_clientValue) {
      Object.assign(info, _clientValue)
    }
    return info
  }

  get url(): string {
    return this._get('url')
  }
  set url(value: string) {
    this._set('url', value)
  }
  get id(): string | null {
    return this._get('id')
  }
  set id(value: string | null) {
    this._set('id', value)
  }
  get file(): string | null {
    return this._get('file')
  }
  set file(value: string | null) {
    this._set('file', value)
  }
  get type(): 'js' | 'css' | 'asset' {
    return this._get('type')
  }
  // `info` needs special care as it's defined as a proxy in `pluginContainer`,
  // so we also merge it as a proxy too
  get info(): ModuleInfo | undefined {
    return this._getModuleInfoUnion('info')
  }
  get meta(): Record<string, any> | undefined {
    return this._getModuleObjectUnion('meta')
  }
  get importers(): Set<ModuleNode> {
    return this._getModuleSetUnion('importers')
  }
  get clientImportedModules(): Set<ModuleNode> {
    return this._wrapModuleSet('importedModules', this._clientModule)
  }
  get ssrImportedModules(): Set<ModuleNode> {
    return this._wrapModuleSet('importedModules', this._ssrModule)
  }
  get importedModules(): Set<ModuleNode> {
    return this._getModuleSetUnion('importedModules')
  }
  get acceptedHmrDeps(): Set<ModuleNode> {
    return this._wrapModuleSet('acceptedHmrDeps', this._clientModule)
  }
  get acceptedHmrExports(): Set<string> | null {
    return this._clientModule?.acceptedHmrExports ?? null
  }
  get importedBindings(): Map<string, Set<string>> | null {
    return this._clientModule?.importedBindings ?? null
  }
  get isSelfAccepting(): boolean | undefined {
    return this._clientModule?.isSelfAccepting
  }
  get transformResult(): TransformResult | null {
    return this._clientModule?.transformResult ?? null
  }
  set transformResult(value: TransformResult | null) {
    if (this._clientModule) {
      this._clientModule.transformResult = value
    }
  }
  get ssrTransformResult(): TransformResult | null {
    return this._ssrModule?.transformResult ?? null
  }
  set ssrTransformResult(value: TransformResult | null) {
    if (this._ssrModule) {
      this._ssrModule.transformResult = value
    }
  }
  get ssrModule(): Record<string, any> | null {
    return this._ssrModule?.ssrModule ?? null
  }
  get ssrError(): Error | null {
    return this._ssrModule?.ssrError ?? null
  }
  get lastHMRTimestamp(): number {
    return Math.max(
      this._clientModule?.lastHMRTimestamp ?? 0,
      this._ssrModule?.lastHMRTimestamp ?? 0,
    )
  }
  set lastHMRTimestamp(value: number) {
    if (this._clientModule) {
      this._clientModule.lastHMRTimestamp = value
    }
    if (this._ssrModule) {
      this._ssrModule.lastHMRTimestamp = value
    }
  }
  get lastInvalidationTimestamp(): number {
    return Math.max(
      this._clientModule?.lastInvalidationTimestamp ?? 0,
      this._ssrModule?.lastInvalidationTimestamp ?? 0,
    )
  }
  get invalidationState(): TransformResult | 'HARD_INVALIDATED' | undefined {
    return this._clientModule?.invalidationState
  }
  get ssrInvalidationState(): TransformResult | 'HARD_INVALIDATED' | undefined {
    return this._ssrModule?.invalidationState
  }
}

function mapIterator<T, K = T>(
  iterable: IterableIterator<T>,
  transform: (value: T) => K,
): IterableIterator<K> {
  return {
    [Symbol.iterator](): IterableIterator<K> {
      return this
    },
    next(): IteratorResult<K> {
      const r = iterable.next()
      return r.done
        ? r
        : {
            value: transform(r.value),
            done: false,
          }
    },
  }
}

export class ModuleGraph {
  /** @internal */
  _moduleGraphs: {
    client: () => EnvironmentModuleGraph
    ssr: () => EnvironmentModuleGraph
  }

  /** @internal */
  get _client(): EnvironmentModuleGraph {
    return this._moduleGraphs.client()
  }

  /** @internal */
  get _ssr(): EnvironmentModuleGraph {
    return this._moduleGraphs.ssr()
  }

  urlToModuleMap: Map<string, ModuleNode>
  idToModuleMap: Map<string, ModuleNode>
  etagToModuleMap: Map<string, ModuleNode>

  fileToModulesMap: Map<string, Set<ModuleNode>>

  private moduleNodeCache = new DualWeakMap<
    EnvironmentModuleNode,
    EnvironmentModuleNode,
    ModuleNode
  >()

  constructor(moduleGraphs: {
    client: () => EnvironmentModuleGraph
    ssr: () => EnvironmentModuleGraph
  }) {
    this._moduleGraphs = moduleGraphs

    const getModuleMapUnion =
      (prop: 'urlToModuleMap' | 'idToModuleMap') => () => {
        // A good approximation to the previous logic that returned the union of
        // the importedModules and importers from both the browser and server
        if (this._ssr[prop].size === 0) {
          return this._client[prop]
        }
        const map = new Map(this._client[prop])
        for (const [key, module] of this._ssr[prop]) {
          if (!map.has(key)) {
            map.set(key, module)
          }
        }
        return map
      }

    this.urlToModuleMap = createBackwardCompatibleModuleMap(
      this,
      'urlToModuleMap',
      getModuleMapUnion('urlToModuleMap'),
    )
    this.idToModuleMap = createBackwardCompatibleModuleMap(
      this,
      'idToModuleMap',
      getModuleMapUnion('idToModuleMap'),
    )
    this.etagToModuleMap = createBackwardCompatibleModuleMap(
      this,
      'etagToModuleMap',
      () => this._client.etagToModuleMap,
    )
    this.fileToModulesMap = createBackwardCompatibleFileToModulesMap(this)
  }

  getModuleById(id: string): ModuleNode | undefined {
    const clientModule = this._client.getModuleById(id)
    const ssrModule = this._ssr.getModuleById(id)
    if (!clientModule && !ssrModule) {
      return
    }
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule)
  }

  async getModuleByUrl(
    url: string,
    _ssr?: boolean,
  ): Promise<ModuleNode | undefined> {
    // In the mixed graph, the ssr flag was used to resolve the id.
    const [clientModule, ssrModule] = await Promise.all([
      this._client.getModuleByUrl(url),
      this._ssr.getModuleByUrl(url),
    ])
    if (!clientModule && !ssrModule) {
      return
    }
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule)
  }

  getModulesByFile(file: string): Set<ModuleNode> | undefined {
    // Until Vite 5.1.x, the moduleGraph contained modules from both the browser and server
    // We maintain backwards compatibility by returning a Set of module proxies assuming
    // that the modules for a certain file are the same in both the browser and server
    const clientModules = this._client.getModulesByFile(file)
    const ssrModules = this._ssr.getModulesByFile(file)
    if (!clientModules && !ssrModules) {
      return undefined
    }
    const result = new Set<ModuleNode>()
    if (clientModules) {
      for (const mod of clientModules) {
        result.add(this.getBackwardCompatibleBrowserModuleNode(mod)!)
      }
    }
    if (ssrModules) {
      for (const mod of ssrModules) {
        if (mod.id == null || !this._client.getModuleById(mod.id)) {
          result.add(this.getBackwardCompatibleServerModuleNode(mod)!)
        }
      }
    }
    return result
  }

  onFileChange(file: string): void {
    this._client.onFileChange(file)
    this._ssr.onFileChange(file)
  }

  onFileDelete(file: string): void {
    this._client.onFileDelete(file)
    this._ssr.onFileDelete(file)
  }

  /** @internal */
  _getModuleGraph(environment: string): EnvironmentModuleGraph {
    switch (environment) {
      case 'client':
        return this._client
      case 'ssr':
        return this._ssr
      default:
        throw new Error(`Invalid module node environment ${environment}`)
    }
  }

  invalidateModule(
    mod: ModuleNode,
    seen = new Set<ModuleNode>(),
    timestamp: number = monotonicDateNow(),
    isHmr: boolean = false,
    /** @internal */
    softInvalidate = false,
  ): void {
    if (mod._clientModule) {
      this._client.invalidateModule(
        mod._clientModule,
        new Set(
          [...seen].map((mod) => mod._clientModule).filter(Boolean),
        ) as Set<EnvironmentModuleNode>,
        timestamp,
        isHmr,
        softInvalidate,
      )
    }
    if (mod._ssrModule) {
      // TODO: Maybe this isn't needed?
      this._ssr.invalidateModule(
        mod._ssrModule,
        new Set(
          [...seen].map((mod) => mod._ssrModule).filter(Boolean),
        ) as Set<EnvironmentModuleNode>,
        timestamp,
        isHmr,
        softInvalidate,
      )
    }
  }

  invalidateAll(): void {
    this._client.invalidateAll()
    this._ssr.invalidateAll()
  }

  /* TODO: It seems there isn't usage of this method in the ecosystem
     Waiting to check if we really need this for backwards compatibility
  async updateModuleInfo(
    module: ModuleNode,
    importedModules: Set<string | ModuleNode>,
    importedBindings: Map<string, Set<string>> | null,
    acceptedModules: Set<string | ModuleNode>,
    acceptedExports: Set<string> | null,
    isSelfAccepting: boolean,
    ssr?: boolean,
    staticImportedUrls?: Set<string>, // internal
  ): Promise<Set<ModuleNode> | undefined> {
    // Not implemented
  }
  */

  async ensureEntryFromUrl(
    rawUrl: string,
    ssr?: boolean,
    setIsSelfAccepting = true,
  ): Promise<ModuleNode> {
    const module = await (ssr ? this._ssr : this._client).ensureEntryFromUrl(
      rawUrl,
      setIsSelfAccepting,
    )
    return this.getBackwardCompatibleModuleNode(module)!
  }

  createFileOnlyEntry(file: string): ModuleNode {
    const clientModule = this._client.createFileOnlyEntry(file)
    const ssrModule = this._ssr.createFileOnlyEntry(file)
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule)!
  }

  async resolveUrl(url: string, ssr?: boolean): Promise<ResolvedUrl> {
    return ssr ? this._ssr.resolveUrl(url) : this._client.resolveUrl(url)
  }

  updateModuleTransformResult(
    mod: ModuleNode,
    result: TransformResult | null,
    ssr?: boolean,
  ): void {
    const environment = ssr ? 'ssr' : 'client'
    this._getModuleGraph(environment).updateModuleTransformResult(
      (environment === 'client' ? mod._clientModule : mod._ssrModule)!,
      result,
    )
  }

  getModuleByEtag(etag: string): ModuleNode | undefined {
    const mod = this._client.etagToModuleMap.get(etag)
    return mod && this.getBackwardCompatibleBrowserModuleNode(mod)
  }

  getBackwardCompatibleBrowserModuleNode(
    clientModule: EnvironmentModuleNode,
  ): ModuleNode {
    return this.getBackwardCompatibleModuleNodeDual(
      clientModule,
      clientModule.id ? this._ssr.getModuleById(clientModule.id) : undefined,
    )
  }

  getBackwardCompatibleServerModuleNode(
    ssrModule: EnvironmentModuleNode,
  ): ModuleNode {
    return this.getBackwardCompatibleModuleNodeDual(
      ssrModule.id ? this._client.getModuleById(ssrModule.id) : undefined,
      ssrModule,
    )
  }

  getBackwardCompatibleModuleNode(mod: EnvironmentModuleNode): ModuleNode {
    return mod.environment === 'client'
      ? this.getBackwardCompatibleBrowserModuleNode(mod)
      : this.getBackwardCompatibleServerModuleNode(mod)
  }

  getBackwardCompatibleModuleNodeDual(
    clientModule?: EnvironmentModuleNode,
    ssrModule?: EnvironmentModuleNode,
  ): ModuleNode {
    const cached = this.moduleNodeCache.get(clientModule, ssrModule)
    if (cached) {
      return cached
    }

    const moduleNode = new ModuleNode(this, clientModule, ssrModule)
    this.moduleNodeCache.set(clientModule, ssrModule, moduleNode)
    return moduleNode
  }
}

class DualWeakMap<K1 extends WeakKey, K2 extends WeakKey, V> {
  private map = new WeakMap<K1 | object, WeakMap<K2 | object, V>>()
  private undefinedKey = {}

  get(key1: K1 | undefined, key2: K2 | undefined): V | undefined {
    const k1 = key1 ?? this.undefinedKey
    const k2 = key2 ?? this.undefinedKey
    return this.map.get(k1)?.get(k2)
  }

  set(key1: K1 | undefined, key2: K2 | undefined, value: V): void {
    const k1 = key1 ?? this.undefinedKey
    const k2 = key2 ?? this.undefinedKey
    if (!this.map.has(k1)) {
      this.map.set(k1, new Map<K2, V>())
    }

    const m = this.map.get(k1)!
    m.set(k2, value)
  }
}

type ModuleSetNames = 'acceptedHmrDeps' | 'importedModules'

function createBackwardCompatibleModuleSet(
  moduleGraph: ModuleGraph,
  prop: ModuleSetNames,
  module: EnvironmentModuleNode,
): Set<ModuleNode> {
  return {
    [Symbol.iterator]() {
      return this.keys()
    },
    has(key) {
      if (!key.id) {
        return false
      }
      const keyModule = moduleGraph
        ._getModuleGraph(module.environment)
        .getModuleById(key.id)
      return keyModule !== undefined && module[prop].has(keyModule)
    },
    values() {
      return this.keys()
    },
    keys() {
      return mapIterator(module[prop].keys(), (mod) =>
        moduleGraph.getBackwardCompatibleModuleNode(mod),
      )
    },
    get size() {
      return module[prop].size
    },
    forEach(callback, thisArg) {
      return module[prop].forEach((mod) => {
        const backwardCompatibleMod =
          moduleGraph.getBackwardCompatibleModuleNode(mod)
        callback.call(
          thisArg,
          backwardCompatibleMod,
          backwardCompatibleMod,
          this,
        )
      })
    },
    // There are several methods missing. We can implement them if downstream
    // projects are relying on them: add, clear, delete, difference, intersection,
    // sDisjointFrom, isSubsetOf, isSupersetOf, symmetricDifference, union
  } as Set<ModuleNode>
}

function createBackwardCompatibleModuleMap(
  moduleGraph: ModuleGraph,
  prop: 'urlToModuleMap' | 'idToModuleMap' | 'etagToModuleMap',
  getModuleMap: () => Map<string, EnvironmentModuleNode>,
): Map<string, ModuleNode> {
  return {
    [Symbol.iterator]() {
      return this.entries()
    },
    get(key) {
      const clientModule = moduleGraph._client[prop].get(key)
      const ssrModule = moduleGraph._ssr[prop].get(key)
      if (!clientModule && !ssrModule) {
        return
      }
      return moduleGraph.getBackwardCompatibleModuleNodeDual(
        clientModule,
        ssrModule,
      )
    },
    set(key, mod) {
      const clientModule = mod._clientModule
      if (clientModule) {
        moduleGraph._client[prop].set(key, clientModule)
      }
      const ssrModule = mod._ssrModule
      if (ssrModule) {
        moduleGraph._ssr[prop].set(key, ssrModule)
      }
    },
    keys() {
      return getModuleMap().keys()
    },
    values() {
      return mapIterator(getModuleMap().values(), (mod) =>
        moduleGraph.getBackwardCompatibleModuleNode(mod),
      )
    },
    entries() {
      return mapIterator(getModuleMap().entries(), ([key, mod]) => [
        key,
        moduleGraph.getBackwardCompatibleModuleNode(mod),
      ])
    },
    get size() {
      return getModuleMap().size
    },
    forEach(callback, thisArg) {
      return getModuleMap().forEach((mod, key) => {
        const backwardCompatibleMod =
          moduleGraph.getBackwardCompatibleModuleNode(mod)
        callback.call(thisArg, backwardCompatibleMod, key, this)
      })
    },
  } as Map<string, ModuleNode>
}

function createBackwardCompatibleFileToModulesMap(
  moduleGraph: ModuleGraph,
): Map<string, Set<ModuleNode>> {
  const getFileToModulesMap = (): Map<string, Set<EnvironmentModuleNode>> => {
    // A good approximation to the previous logic that returned the union of
    // the importedModules and importers from both the browser and server
    if (!moduleGraph._ssr.fileToModulesMap.size) {
      return moduleGraph._client.fileToModulesMap
    }
    const map = new Map(moduleGraph._client.fileToModulesMap)
    for (const [key, modules] of moduleGraph._ssr.fileToModulesMap) {
      const modulesSet = map.get(key)
      if (!modulesSet) {
        map.set(key, modules)
      } else {
        for (const ssrModule of modules) {
          let hasModule = false
          for (const clientModule of modulesSet) {
            hasModule ||= clientModule.id === ssrModule.id
            if (hasModule) {
              break
            }
          }
          if (!hasModule) {
            modulesSet.add(ssrModule)
          }
        }
      }
    }
    return map
  }
  const getBackwardCompatibleModules = (
    modules: Set<EnvironmentModuleNode>,
  ): Set<ModuleNode> =>
    new Set(
      [...modules].map((mod) =>
        moduleGraph.getBackwardCompatibleModuleNode(mod),
      ),
    )

  return {
    [Symbol.iterator]() {
      return this.entries()
    },
    get(key) {
      const clientModules = moduleGraph._client.fileToModulesMap.get(key)
      const ssrModules = moduleGraph._ssr.fileToModulesMap.get(key)
      if (!clientModules && !ssrModules) {
        return
      }
      const modules = clientModules ?? new Set<EnvironmentModuleNode>()
      if (ssrModules) {
        for (const ssrModule of ssrModules) {
          if (ssrModule.id) {
            let found = false
            for (const mod of modules) {
              found ||= mod.id === ssrModule.id
              if (found) {
                break
              }
            }
            if (!found) {
              modules.add(ssrModule)
            }
          }
        }
      }
      return getBackwardCompatibleModules(modules)
    },
    keys() {
      return getFileToModulesMap().keys()
    },
    values() {
      return mapIterator(
        getFileToModulesMap().values(),
        getBackwardCompatibleModules,
      )
    },
    entries() {
      return mapIterator(getFileToModulesMap().entries(), ([key, modules]) => [
        key,
        getBackwardCompatibleModules(modules),
      ])
    },
    get size() {
      return getFileToModulesMap().size
    },
    forEach(callback, thisArg) {
      return getFileToModulesMap().forEach((modules, key) => {
        callback.call(thisArg, getBackwardCompatibleModules(modules), key, this)
      })
    },
  } as Map<string, Set<ModuleNode>>
}



================================================
FILE: packages/vite/src/node/server/moduleGraph.ts
================================================
import { extname } from 'node:path'
import type { ModuleInfo, PartialResolvedId } from 'rollup'
import { isDirectCSSRequest } from '../plugins/css'
import {
  monotonicDateNow,
  normalizePath,
  removeImportQuery,
  removeTimestampQuery,
} from '../utils'
import { FS_PREFIX } from '../constants'
import { cleanUrl } from '../../shared/utils'
import type { TransformResult } from './transformRequest'

export class EnvironmentModuleNode {
  environment: string
  /**
   * Public served url path, starts with /
   */
  url: string
  /**
   * Resolved file system path + query
   */
  id: string | null = null
  file: string | null = null
  type: 'js' | 'css' | 'asset'
  info?: ModuleInfo
  meta?: Record<string, any>
  importers = new Set<EnvironmentModuleNode>()

  importedModules = new Set<EnvironmentModuleNode>()

  acceptedHmrDeps = new Set<EnvironmentModuleNode>()
  acceptedHmrExports: Set<string> | null = null
  importedBindings: Map<string, Set<string>> | null = null
  isSelfAccepting?: boolean
  transformResult: TransformResult | null = null

  // ssrModule and ssrError are no longer needed. They are on the module runner module cache.
  // Once `ssrLoadModule` is re-implemented on top of the new APIs, we can delete these.
  ssrModule: Record<string, any> | null = null
  ssrError: Error | null = null

  lastHMRTimestamp = 0
  /**
   * `import.meta.hot.invalidate` is called by the client.
   * If there's multiple clients, multiple `invalidate` request is received.
   * This property is used to dedupe those request to avoid multiple updates happening.
   * @internal
   */
  lastHMRInvalidationReceived = false
  lastInvalidationTimestamp = 0
  /**
   * If the module only needs to update its imports timestamp (e.g. within an HMR chain),
   * it is considered soft-invalidated. In this state, its `transformResult` should exist,
   * and the next `transformRequest` for this module will replace the timestamps.
   *
   * By default the value is `undefined` if it's not soft/hard-invalidated. If it gets
   * soft-invalidated, this will contain the previous `transformResult` value. If it gets
   * hard-invalidated, this will be set to `'HARD_INVALIDATED'`.
   * @internal
   */
  invalidationState: TransformResult | 'HARD_INVALIDATED' | undefined
  /**
   * The module urls that are statically imported in the code. This information is separated
   * out from `importedModules` as only importers that statically import the module can be
   * soft invalidated. Other imports (e.g. watched files) needs the importer to be hard invalidated.
   * @internal
   */
  staticImportedUrls?: Set<string>

  /**
   * @param setIsSelfAccepting - set `false` to set `isSelfAccepting` later. e.g. #7870
   */
  constructor(url: string, environment: string, setIsSelfAccepting = true) {
    this.environment = environment
    this.url = url
    this.type = isDirectCSSRequest(url) ? 'css' : 'js'
    if (setIsSelfAccepting) {
      this.isSelfAccepting = false
    }
  }
}

export type ResolvedUrl = [
  url: string,
  resolvedId: string,
  meta: object | null | undefined,
]

export class EnvironmentModuleGraph {
  environment: string

  urlToModuleMap = new Map<string, EnvironmentModuleNode>()
  idToModuleMap = new Map<string, EnvironmentModuleNode>()
  etagToModuleMap = new Map<string, EnvironmentModuleNode>()
  // a single file may corresponds to multiple modules with different queries
  fileToModulesMap = new Map<string, Set<EnvironmentModuleNode>>()

  /**
   * @internal
   */
  _unresolvedUrlToModuleMap = new Map<
    string,
    Promise<EnvironmentModuleNode> | EnvironmentModuleNode
  >()

  /**
   * @internal
   */
  _resolveId: (url: string) => Promise<PartialResolvedId | null>

  /** @internal */
  _hasResolveFailedErrorModules = new Set<EnvironmentModuleNode>()

  constructor(
    environment: string,
    resolveId: (url: string) => Promise<PartialResolvedId | null>,
  ) {
    this.environment = environment
    this._resolveId = resolveId
  }

  async getModuleByUrl(
    rawUrl: string,
  ): Promise<EnvironmentModuleNode | undefined> {
    // Quick path, if we already have a module for this rawUrl (even without extension)
    rawUrl = removeImportQuery(removeTimestampQuery(rawUrl))
    const mod = this._getUnresolvedUrlToModule(rawUrl)
    if (mod) {
      return mod
    }

    const [url] = await this._resolveUrl(rawUrl)
    return this.urlToModuleMap.get(url)
  }

  getModuleById(id: string): EnvironmentModuleNode | undefined {
    return this.idToModuleMap.get(removeTimestampQuery(id))
  }

  getModulesByFile(file: string): Set<EnvironmentModuleNode> | undefined {
    return this.fileToModulesMap.get(file)
  }

  onFileChange(file: string): void {
    const mods = this.getModulesByFile(file)
    if (mods) {
      const seen = new Set<EnvironmentModuleNode>()
      mods.forEach((mod) => {
        this.invalidateModule(mod, seen)
      })
    }
  }

  onFileDelete(file: string): void {
    const mods = this.getModulesByFile(file)
    if (mods) {
      mods.forEach((mod) => {
        mod.importedModules.forEach((importedMod) => {
          importedMod.importers.delete(mod)
        })
      })
    }
  }

  invalidateModule(
    mod: EnvironmentModuleNode,
    seen = new Set<EnvironmentModuleNode>(),
    timestamp: number = monotonicDateNow(),
    isHmr: boolean = false,
    /** @internal */
    softInvalidate = false,
  ): void {
    const prevInvalidationState = mod.invalidationState

    // Handle soft invalidation before the `seen` check, as consecutive soft/hard invalidations can
    // cause the final soft invalidation state to be different.
    // If soft invalidated, save the previous `transformResult` so that we can reuse and transform the
    // import timestamps only in `transformRequest`. If there's no previous `transformResult`, hard invalidate it.
    if (softInvalidate) {
      mod.invalidationState ??= mod.transformResult ?? 'HARD_INVALIDATED'
    }
    // If hard invalidated, further soft invalidations have no effect until it's reset to `undefined`
    else {
      mod.invalidationState = 'HARD_INVALIDATED'
    }

    // Skip updating the module if it was already invalidated before and the invalidation state has not changed
    if (seen.has(mod) && prevInvalidationState === mod.invalidationState) {
      return
    }
    seen.add(mod)

    if (isHmr) {
      mod.lastHMRTimestamp = timestamp
      mod.lastHMRInvalidationReceived = false
    } else {
      // Save the timestamp for this invalidation, so we can avoid caching the result of possible already started
      // processing being done for this module
      mod.lastInvalidationTimestamp = timestamp
    }

    // Don't invalidate mod.info and mod.meta, as they are part of the processing pipeline
    // Invalidating the transform result is enough to ensure this module is re-processed next time it is requested
    const etag = mod.transformResult?.etag
    if (etag) this.etagToModuleMap.delete(etag)

    mod.transformResult = null

    mod.ssrModule = null
    mod.ssrError = null

    mod.importers.forEach((importer) => {
      if (!importer.acceptedHmrDeps.has(mod)) {
        // If the importer statically imports the current module, we can soft-invalidate the importer
        // to only update the import timestamps. If it's not statically imported, e.g. watched/glob file,
        // we can only soft invalidate if the current module was also soft-invalidated. A soft-invalidation
        // doesn't need to trigger a re-load and re-transform of the importer.
        // But we exclude direct CSS files as those cannot be soft invalidated.
        const shouldSoftInvalidateImporter =
          (importer.staticImportedUrls?.has(mod.url) || softInvalidate) &&
          importer.type === 'js'
        this.invalidateModule(
          importer,
          seen,
          timestamp,
          isHmr,
          shouldSoftInvalidateImporter,
        )
      }
    })

    this._hasResolveFailedErrorModules.delete(mod)
  }

  invalidateAll(): void {
    const timestamp = monotonicDateNow()
    const seen = new Set<EnvironmentModuleNode>()
    this.idToModuleMap.forEach((mod) => {
      this.invalidateModule(mod, seen, timestamp)
    })
  }

  /**
   * Update the module graph based on a module's updated imports information
   * If there are dependencies that no longer have any importers, they are
   * returned as a Set.
   *
   * @param staticImportedUrls Subset of `importedModules` where they're statically imported in code.
   *   This is only used for soft invalidations so `undefined` is fine but may cause more runtime processing.
   */
  async updateModuleInfo(
    mod: EnvironmentModuleNode,
    importedModules: Set<string | EnvironmentModuleNode>,
    importedBindings: Map<string, Set<string>> | null,
    acceptedModules: Set<string | EnvironmentModuleNode>,
    acceptedExports: Set<string> | null,
    isSelfAccepting: boolean,
    /** @internal */
    staticImportedUrls?: Set<string>,
  ): Promise<Set<EnvironmentModuleNode> | undefined> {
    mod.isSelfAccepting = isSelfAccepting
    const prevImports = mod.importedModules
    let noLongerImported: Set<EnvironmentModuleNode> | undefined

    let resolvePromises = []
    let resolveResults = new Array(importedModules.size)
    let index = 0
    // update import graph
    for (const imported of importedModules) {
      const nextIndex = index++
      if (typeof imported === 'string') {
        resolvePromises.push(
          this.ensureEntryFromUrl(imported).then((dep) => {
            dep.importers.add(mod)
            resolveResults[nextIndex] = dep
          }),
        )
      } else {
        imported.importers.add(mod)
        resolveResults[nextIndex] = imported
      }
    }

    if (resolvePromises.length) {
      await Promise.all(resolvePromises)
    }

    const nextImports = new Set(resolveResults)
    mod.importedModules = nextImports

    // remove the importer from deps that were imported but no longer are.
    prevImports.forEach((dep) => {
      if (!mod.importedModules.has(dep)) {
        dep.importers.delete(mod)
        if (!dep.importers.size) {
          // dependency no longer imported
          ;(noLongerImported || (noLongerImported = new Set())).add(dep)
        }
      }
    })

    // update accepted hmr deps
    resolvePromises = []
    resolveResults = new Array(acceptedModules.size)
    index = 0
    for (const accepted of acceptedModules) {
      const nextIndex = index++
      if (typeof accepted === 'string') {
        resolvePromises.push(
          this.ensureEntryFromUrl(accepted).then((dep) => {
            resolveResults[nextIndex] = dep
          }),
        )
      } else {
        resolveResults[nextIndex] = accepted
      }
    }

    if (resolvePromises.length) {
      await Promise.all(resolvePromises)
    }

    mod.acceptedHmrDeps = new Set(resolveResults)
    mod.staticImportedUrls = staticImportedUrls

    // update accepted hmr exports
    mod.acceptedHmrExports = acceptedExports
    mod.importedBindings = importedBindings
    return noLongerImported
  }

  async ensureEntryFromUrl(
    rawUrl: string,
    setIsSelfAccepting = true,
  ): Promise<EnvironmentModuleNode> {
    return this._ensureEntryFromUrl(rawUrl, setIsSelfAccepting)
  }

  /**
   * @internal
   */
  async _ensureEntryFromUrl(
    rawUrl: string,
    setIsSelfAccepting = true,
    // Optimization, avoid resolving the same url twice if the caller already did it
    resolved?: PartialResolvedId,
  ): Promise<EnvironmentModuleNode> {
    // Quick path, if we already have a module for this rawUrl (even without extension)
    rawUrl = removeImportQuery(removeTimestampQuery(rawUrl))
    let mod = this._getUnresolvedUrlToModule(rawUrl)
    if (mod) {
      return mod
    }
    const modPromise = (async () => {
      const [url, resolvedId, meta] = await this._resolveUrl(rawUrl, resolved)
      mod = this.idToModuleMap.get(resolvedId)
      if (!mod) {
        mod = new EnvironmentModuleNode(
          url,
          this.environment,
          setIsSelfAccepting,
        )
        if (meta) mod.meta = meta
        this.urlToModuleMap.set(url, mod)
        mod.id = resolvedId
        this.idToModuleMap.set(resolvedId, mod)
        const file = (mod.file = cleanUrl(resolvedId))
        let fileMappedModules = this.fileToModulesMap.get(file)
        if (!fileMappedModules) {
          fileMappedModules = new Set()
          this.fileToModulesMap.set(file, fileMappedModules)
        }
        fileMappedModules.add(mod)
      }
      // multiple urls can map to the same module and id, make sure we register
      // the url to the existing module in that case
      else if (!this.urlToModuleMap.has(url)) {
        this.urlToModuleMap.set(url, mod)
      }
      this._setUnresolvedUrlToModule(rawUrl, mod)
      return mod
    })()

    // Also register the clean url to the module, so that we can short-circuit
    // resolving the same url twice
    this._setUnresolvedUrlToModule(rawUrl, modPromise)
    return modPromise
  }

  // some deps, like a css file referenced via @import, don't have its own
  // url because they are inlined into the main css import. But they still
  // need to be represented in the module graph so that they can trigger
  // hmr in the importing css file.
  createFileOnlyEntry(file: string): EnvironmentModuleNode {
    file = normalizePath(file)
    let fileMappedModules = this.fileToModulesMap.get(file)
    if (!fileMappedModules) {
      fileMappedModules = new Set()
      this.fileToModulesMap.set(file, fileMappedModules)
    }

    const url = `${FS_PREFIX}${file}`
    for (const m of fileMappedModules) {
      if ((m.url === url || m.id === file) && m.type === 'asset') {
        return m
      }
    }

    const mod = new EnvironmentModuleNode(url, this.environment)
    mod.type = 'asset'
    mod.file = file
    fileMappedModules.add(mod)
    return mod
  }

  // for incoming urls, it is important to:
  // 1. remove the HMR timestamp query (?t=xxxx) and the ?import query
  // 2. resolve its extension so that urls with or without extension all map to
  // the same module
  async resolveUrl(url: string): Promise<ResolvedUrl> {
    url = removeImportQuery(removeTimestampQuery(url))
    const mod = await this._getUnresolvedUrlToModule(url)
    if (mod?.id) {
      return [mod.url, mod.id, mod.meta]
    }
    return this._resolveUrl(url)
  }

  updateModuleTransformResult(
    mod: EnvironmentModuleNode,
    result: TransformResult | null,
  ): void {
    if (this.environment === 'client') {
      const prevEtag = mod.transformResult?.etag
      if (prevEtag) this.etagToModuleMap.delete(prevEtag)
      if (result?.etag) this.etagToModuleMap.set(result.etag, mod)
    }

    mod.transformResult = result
  }

  getModuleByEtag(etag: string): EnvironmentModuleNode | undefined {
    return this.etagToModuleMap.get(etag)
  }

  /**
   * @internal
   */
  _getUnresolvedUrlToModule(
    url: string,
  ): Promise<EnvironmentModuleNode> | EnvironmentModuleNode | undefined {
    return this._unresolvedUrlToModuleMap.get(url)
  }
  /**
   * @internal
   */
  _setUnresolvedUrlToModule(
    url: string,
    mod: Promise<EnvironmentModuleNode> | EnvironmentModuleNode,
  ): void {
    this._unresolvedUrlToModuleMap.set(url, mod)
  }

  /**
   * @internal
   */
  async _resolveUrl(
    url: string,
    alreadyResolved?: PartialResolvedId,
  ): Promise<ResolvedUrl> {
    const resolved = alreadyResolved ?? (await this._resolveId(url))
    const resolvedId = resolved?.id || url
    if (
      url !== resolvedId &&
      !url.includes('\0') &&
      !url.startsWith(`virtual:`)
    ) {
      const ext = extname(cleanUrl(resolvedId))
      if (ext) {
        const pathname = cleanUrl(url)
        if (!pathname.endsWith(ext)) {
          url = pathname + ext + url.slice(pathname.length)
        }
      }
    }
    return [url, resolvedId, resolved?.meta]
  }
}



================================================
FILE: packages/vite/src/node/server/openBrowser.ts
================================================
/**
 * The following is modified based on source found in
 * https://github.com/facebook/create-react-app
 *
 * MIT Licensed
 * Copyright (c) 2015-present, Facebook, Inc.
 * https://github.com/facebook/create-react-app/blob/master/LICENSE
 *
 */

import { join } from 'node:path'
import { exec } from 'node:child_process'
import type { ExecOptions } from 'node:child_process'
import open from 'open'
import type { Options } from 'open'
import spawn from 'cross-spawn'
import colors from 'picocolors'
import type { Logger } from '../logger'
import { VITE_PACKAGE_DIR } from '../constants'

/**
 * Reads the BROWSER environment variable and decides what to do with it.
 */
export function openBrowser(
  url: string,
  opt: string | true,
  logger: Logger,
): void {
  // The browser executable to open.
  // See https://github.com/sindresorhus/open#app for documentation.
  const browser = typeof opt === 'string' ? opt : process.env.BROWSER || ''
  if (browser.toLowerCase().endsWith('.js')) {
    executeNodeScript(browser, url, logger)
  } else if (browser.toLowerCase() !== 'none') {
    const browserArgs = process.env.BROWSER_ARGS
      ? process.env.BROWSER_ARGS.split(' ')
      : []
    startBrowserProcess(browser, browserArgs, url, logger)
  }
}

function executeNodeScript(scriptPath: string, url: string, logger: Logger) {
  const extraArgs = process.argv.slice(2)
  const child = spawn(process.execPath, [scriptPath, ...extraArgs, url], {
    stdio: 'inherit',
  })
  child.on('close', (code) => {
    if (code !== 0) {
      logger.error(
        colors.red(
          `\nThe script specified as BROWSER environment variable failed.\n\n${colors.cyan(
            scriptPath,
          )} exited with code ${code}.`,
        ),
        { error: null },
      )
    }
  })
}

const supportedChromiumBrowsers = [
  'Google Chrome Canary',
  'Google Chrome Dev',
  'Google Chrome Beta',
  'Google Chrome',
  'Microsoft Edge',
  'Brave Browser',
  'Vivaldi',
  'Chromium',
]

async function startBrowserProcess(
  browser: string | undefined,
  browserArgs: string[],
  url: string,
  logger: Logger,
) {
  // If we're on OS X, the user hasn't specifically
  // requested a different browser, we can try opening
  // a Chromium browser with JXA. This lets us reuse an
  // existing tab when possible instead of creating a new one.
  const preferredOSXBrowser =
    browser === 'google chrome' ? 'Google Chrome' : browser
  const shouldTryOpenChromeWithJXA =
    process.platform === 'darwin' &&
    (!preferredOSXBrowser ||
      supportedChromiumBrowsers.includes(preferredOSXBrowser))

  if (shouldTryOpenChromeWithJXA) {
    try {
      const ps = await execAsync('ps cax')
      const openedBrowser =
        preferredOSXBrowser && ps.includes(preferredOSXBrowser)
          ? preferredOSXBrowser
          : supportedChromiumBrowsers.find((b) => ps.includes(b))
      if (openedBrowser) {
        // Try our best to reuse existing tab with JXA
        await execAsync(`osascript openChrome.js "${url}" "${openedBrowser}"`, {
          cwd: join(VITE_PACKAGE_DIR, 'bin'),
        })
        return true
      }
    } catch {
      // Ignore errors
    }
  }

  // Another special case: on OS X, check if BROWSER has been set to "open".
  // In this case, instead of passing the string `open` to `open` function (which won't work),
  // just ignore it (thus ensuring the intended behavior, i.e. opening the system browser):
  // https://github.com/facebook/create-react-app/pull/1690#issuecomment-283518768
  if (process.platform === 'darwin' && browser === 'open') {
    browser = undefined
  }

  // Fallback to open
  // (It will always open new tab)
  try {
    const options: Options = browser
      ? { app: { name: browser, arguments: browserArgs } }
      : {}

    new Promise((_, reject) => {
      open(url, options)
        .then((subprocess) => {
          subprocess.on('error', reject)
        })
        .catch(reject)
    }).catch((err) => {
      logger.error(err.stack || err.message)
    })

    return true
  } catch {
    return false
  }
}

function execAsync(command: string, options?: ExecOptions): Promise<string> {
  return new Promise((resolve, reject) => {
    exec(command, options, (error, stdout) => {
      if (error) {
        reject(error)
      } else {
        resolve(stdout.toString())
      }
    })
  })
}



================================================
FILE: packages/vite/src/node/server/pluginContainer.ts
================================================
/**
 * This file is refactored into TypeScript based on
 * https://github.com/preactjs/wmr/blob/main/packages/wmr/src/lib/rollup-plugin-container.js
 */

/**
https://github.com/preactjs/wmr/blob/master/LICENSE

MIT License

Copyright (c) 2020 The Preact Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import fs from 'node:fs'
import fsp from 'node:fs/promises'
import { join } from 'node:path'
import { performance } from 'node:perf_hooks'
import { parseAst as rollupParseAst } from 'rollup/parseAst'
import type {
  AsyncPluginHooks,
  CustomPluginOptions,
  EmittedFile,
  FunctionPluginHooks,
  InputOptions,
  LoadResult,
  ModuleInfo,
  ModuleOptions,
  NormalizedInputOptions,
  OutputOptions,
  ParallelPluginHooks,
  PartialNull,
  PartialResolvedId,
  PluginContextMeta,
  ResolvedId,
  RollupError,
  RollupFsModule,
  RollupLog,
  MinimalPluginContext as RollupMinimalPluginContext,
  PluginContext as RollupPluginContext,
  TransformPluginContext as RollupTransformPluginContext,
  SourceDescription,
  SourceMap,
  TransformResult,
} from 'rollup'
import type { RawSourceMap } from '@jridgewell/remapping'
import { TraceMap, originalPositionFor } from '@jridgewell/trace-mapping'
import MagicString from 'magic-string'
import type { FSWatcher } from 'dep-types/chokidar'
import colors from 'picocolors'
import type { Plugin } from '../plugin'
import {
  combineSourcemaps,
  createDebugger,
  ensureWatchedFile,
  generateCodeFrame,
  isExternalUrl,
  isObject,
  normalizePath,
  numberToPos,
  prettifyUrl,
  rollupVersion,
  timeFrom,
} from '../utils'
import { FS_PREFIX, VERSION as viteVersion } from '../constants'
import {
  createPluginHookUtils,
  getCachedFilterForPlugin,
  getHookHandler,
} from '../plugins'
import { cleanUrl, unwrapId } from '../../shared/utils'
import type { PluginHookUtils } from '../config'
import type { Environment } from '../environment'
import type { Logger } from '../logger'
import {
  isFutureDeprecationEnabled,
  warnFutureDeprecation,
} from '../deprecations'
import type { DevEnvironment } from './environment'
import { buildErrorMessage } from './middlewares/error'
import type {
  EnvironmentModuleGraph,
  EnvironmentModuleNode,
} from './moduleGraph'

// same default value of "moduleInfo.meta" as in Rollup
const EMPTY_OBJECT = Object.freeze({})

const debugSourcemapCombineFilter =
  process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER
const debugSourcemapCombine = createDebugger('vite:sourcemap-combine', {
  onlyWhenFocused: true,
})
const debugResolve = createDebugger('vite:resolve')
const debugPluginResolve = createDebugger('vite:plugin-resolve', {
  onlyWhenFocused: 'vite:plugin',
})
const debugPluginTransform = createDebugger('vite:plugin-transform', {
  onlyWhenFocused: 'vite:plugin',
})
const debugPluginContainerContext = createDebugger(
  'vite:plugin-container-context',
)

export const ERR_CLOSED_SERVER = 'ERR_CLOSED_SERVER'

export function throwClosedServerError(): never {
  const err: any = new Error(
    'The server is being restarted or closed. Request is outdated',
  )
  err.code = ERR_CLOSED_SERVER
  // This error will be caught by the transform middleware that will
  // send a 504 status code request timeout
  throw err
}

export interface PluginContainerOptions {
  cwd?: string
  output?: OutputOptions
  modules?: Map<string, { info: ModuleInfo }>
  writeFile?: (name: string, source: string | Uint8Array) => void
}

/**
 * Create a plugin container with a set of plugins. We pass them as a parameter
 * instead of using environment.plugins to allow the creation of different
 * pipelines working with the same environment (used for createIdResolver).
 */
export async function createEnvironmentPluginContainer<
  Env extends Environment = Environment,
>(
  environment: Env,
  plugins: readonly Plugin[],
  watcher?: FSWatcher,
  autoStart = true,
): Promise<EnvironmentPluginContainer<Env>> {
  const container = new EnvironmentPluginContainer(
    environment,
    plugins,
    watcher,
    autoStart,
  )
  await container.resolveRollupOptions()
  return container
}

export type SkipInformation = {
  id: string
  importer: string | undefined
  plugin: Plugin
  called?: boolean
}

class EnvironmentPluginContainer<Env extends Environment = Environment> {
  private _pluginContextMap = new Map<Plugin, PluginContext>()
  private _resolvedRollupOptions?: InputOptions
  private _processesing = new Set<Promise<any>>()
  private _seenResolves: Record<string, true | undefined> = {}

  // _addedFiles from the `load()` hook gets saved here so it can be reused in the `transform()` hook
  private _moduleNodeToLoadAddedImports = new WeakMap<
    EnvironmentModuleNode,
    Set<string> | null
  >()

  getSortedPluginHooks: PluginHookUtils['getSortedPluginHooks']
  getSortedPlugins: PluginHookUtils['getSortedPlugins']

  moduleGraph: EnvironmentModuleGraph | undefined
  watchFiles = new Set<string>()
  minimalContext: MinimalPluginContext<Env>

  private _started = false
  private _buildStartPromise: Promise<void> | undefined
  private _closed = false

  /**
   * @internal use `createEnvironmentPluginContainer` instead
   */
  constructor(
    public environment: Env,
    public plugins: readonly Plugin[],
    public watcher?: FSWatcher,
    autoStart = true,
  ) {
    this._started = !autoStart
    this.minimalContext = new MinimalPluginContext(
      { ...basePluginContextMeta, watchMode: true },
      environment,
    )
    const utils = createPluginHookUtils(plugins)
    this.getSortedPlugins = utils.getSortedPlugins
    this.getSortedPluginHooks = utils.getSortedPluginHooks
    this.moduleGraph =
      environment.mode === 'dev' ? environment.moduleGraph : undefined
  }

  private _updateModuleLoadAddedImports(
    id: string,
    addedImports: Set<string> | null,
  ): void {
    const module = this.moduleGraph?.getModuleById(id)
    if (module) {
      this._moduleNodeToLoadAddedImports.set(module, addedImports)
    }
  }

  private _getAddedImports(id: string): Set<string> | null {
    const module = this.moduleGraph?.getModuleById(id)
    return module
      ? this._moduleNodeToLoadAddedImports.get(module) || null
      : null
  }

  getModuleInfo(id: string): ModuleInfo | null {
    const module = this.moduleGraph?.getModuleById(id)
    if (!module) {
      return null
    }
    if (!module.info) {
      module.info = new Proxy(
        { id, meta: module.meta || EMPTY_OBJECT } as ModuleInfo,
        // throw when an unsupported ModuleInfo property is accessed,
        // so that incompatible plugins fail in a non-cryptic way.
        {
          get(info: any, key: string) {
            if (key in info) {
              return info[key]
            }
            // Don't throw an error when returning from an async function
            if (key === 'then') {
              return undefined
            }
            throw Error(
              `[vite] The "${key}" property of ModuleInfo is not supported.`,
            )
          },
        },
      )
    }
    return module.info ?? null
  }

  // keeps track of hook promises so that we can wait for them all to finish upon closing the server
  private handleHookPromise<T>(maybePromise: undefined | T | Promise<T>) {
    if (!(maybePromise as any)?.then) {
      return maybePromise
    }
    const promise = maybePromise as Promise<T>
    this._processesing.add(promise)
    return promise.finally(() => this._processesing.delete(promise))
  }

  get options(): InputOptions {
    return this._resolvedRollupOptions!
  }

  async resolveRollupOptions(): Promise<InputOptions> {
    if (!this._resolvedRollupOptions) {
      let options = this.environment.config.build.rollupOptions
      for (const optionsHook of this.getSortedPluginHooks('options')) {
        if (this._closed) {
          throwClosedServerError()
        }
        options =
          (await this.handleHookPromise(
            optionsHook.call(this.minimalContext, options),
          )) || options
      }
      this._resolvedRollupOptions = options
    }
    return this._resolvedRollupOptions
  }

  private _getPluginContext(plugin: Plugin) {
    if (!this._pluginContextMap.has(plugin)) {
      this._pluginContextMap.set(plugin, new PluginContext(plugin, this))
    }
    return this._pluginContextMap.get(plugin)!
  }

  // parallel, ignores returns
  private async hookParallel<H extends AsyncPluginHooks & ParallelPluginHooks>(
    hookName: H,
    context: (plugin: Plugin) => ThisType<FunctionPluginHooks[H]>,
    args: (plugin: Plugin) => Parameters<FunctionPluginHooks[H]>,
    condition?: (plugin: Plugin) => boolean | undefined,
  ): Promise<void> {
    const parallelPromises: Promise<unknown>[] = []
    for (const plugin of this.getSortedPlugins(hookName)) {
      // Don't throw here if closed, so buildEnd and closeBundle hooks can finish running
      if (condition && !condition(plugin)) continue

      const hook = plugin[hookName]
      const handler: Function = getHookHandler(hook)
      if ((hook as { sequential?: boolean }).sequential) {
        await Promise.all(parallelPromises)
        parallelPromises.length = 0
        await handler.apply(context(plugin), args(plugin))
      } else {
        parallelPromises.push(handler.apply(context(plugin), args(plugin)))
      }
    }
    await Promise.all(parallelPromises)
  }

  async buildStart(_options?: InputOptions): Promise<void> {
    if (this._started) {
      if (this._buildStartPromise) {
        await this._buildStartPromise
      }
      return
    }
    this._started = true
    const config = this.environment.getTopLevelConfig()
    this._buildStartPromise = this.handleHookPromise(
      this.hookParallel(
        'buildStart',
        (plugin) => this._getPluginContext(plugin),
        () => [this.options as NormalizedInputOptions],
        (plugin) =>
          this.environment.name === 'client' ||
          config.server.perEnvironmentStartEndDuringDev ||
          plugin.perEnvironmentStartEndDuringDev,
      ),
    ) as Promise<void>
    await this._buildStartPromise
    this._buildStartPromise = undefined
  }

  async resolveId(
    rawId: string,
    importer: string | undefined = join(
      this.environment.config.root,
      'index.html',
    ),
    options?: {
      attributes?: Record<string, string>
      custom?: CustomPluginOptions
      /** @deprecated use `skipCalls` instead */
      skip?: Set<Plugin>
      skipCalls?: readonly SkipInformation[]
      /**
       * @internal
       */
      scan?: boolean
      isEntry?: boolean
    },
  ): Promise<PartialResolvedId | null> {
    if (!this._started) {
      this.buildStart()
      await this._buildStartPromise
    }
    const skip = options?.skip
    const skipCalls = options?.skipCalls
    const scan = !!options?.scan
    const ssr = this.environment.config.consumer === 'server'
    const ctx = new ResolveIdContext(this, skip, skipCalls, scan)
    const topLevelConfig = this.environment.getTopLevelConfig()

    const mergedSkip = new Set<Plugin>(skip)
    for (const call of skipCalls ?? []) {
      if (call.called || (call.id === rawId && call.importer === importer)) {
        mergedSkip.add(call.plugin)
      }
    }

    const resolveStart = debugResolve ? performance.now() : 0
    let id: string | null = null
    const partial: Partial<PartialResolvedId> = {}
    for (const plugin of this.getSortedPlugins('resolveId')) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError()
      if (mergedSkip?.has(plugin)) continue

      const filter = getCachedFilterForPlugin(plugin, 'resolveId')
      if (filter && !filter(rawId)) continue

      ctx._plugin = plugin

      const normalizedOptions = {
        attributes: options?.attributes ?? {},
        custom: options?.custom,
        isEntry: !!options?.isEntry,
        ssr,
        scan,
      }
      if (
        isFutureDeprecationEnabled(
          topLevelConfig,
          'removePluginHookSsrArgument',
        )
      ) {
        let ssrTemp = ssr
        Object.defineProperty(normalizedOptions, 'ssr', {
          get() {
            warnFutureDeprecation(
              topLevelConfig,
              'removePluginHookSsrArgument',
              `Used in plugin "${plugin.name}".`,
            )
            return ssrTemp
          },
          set(v) {
            ssrTemp = v
          },
        })
      }

      const pluginResolveStart = debugPluginResolve ? performance.now() : 0
      const handler = getHookHandler(plugin.resolveId)
      const result = await this.handleHookPromise(
        handler.call(ctx as any, rawId, importer, normalizedOptions),
      )
      if (!result) continue

      if (typeof result === 'string') {
        id = result
      } else {
        id = result.id
        Object.assign(partial, result)
      }

      debugPluginResolve?.(
        timeFrom(pluginResolveStart),
        plugin.name,
        prettifyUrl(id, this.environment.config.root),
      )

      // resolveId() is hookFirst - first non-null result is returned.
      break
    }

    if (debugResolve && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
      const key = rawId + id
      // avoid spamming
      if (!this._seenResolves[key]) {
        this._seenResolves[key] = true
        debugResolve(
          `${timeFrom(resolveStart)} ${colors.cyan(rawId)} -> ${colors.dim(
            id,
          )}`,
        )
      }
    }

    if (id) {
      partial.id = isExternalUrl(id) ? id : normalizePath(id)
      return partial as PartialResolvedId
    } else {
      return null
    }
  }

  async load(id: string): Promise<LoadResult | null> {
    let ssr = this.environment.config.consumer === 'server'
    const topLevelConfig = this.environment.getTopLevelConfig()
    const options = { ssr }
    const ctx = new LoadPluginContext(this)
    for (const plugin of this.getSortedPlugins('load')) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError()

      const filter = getCachedFilterForPlugin(plugin, 'load')
      if (filter && !filter(id)) continue

      ctx._plugin = plugin

      if (
        isFutureDeprecationEnabled(
          topLevelConfig,
          'removePluginHookSsrArgument',
        )
      ) {
        Object.defineProperty(options, 'ssr', {
          get() {
            warnFutureDeprecation(
              topLevelConfig,
              'removePluginHookSsrArgument',
              `Used in plugin "${plugin.name}".`,
            )
            return ssr
          },
          set(v) {
            ssr = v
          },
        })
      }

      const handler = getHookHandler(plugin.load)
      const result = await this.handleHookPromise(
        handler.call(ctx as any, id, options),
      )
      if (result != null) {
        if (isObject(result)) {
          ctx._updateModuleInfo(id, result)
        }
        this._updateModuleLoadAddedImports(id, ctx._addedImports)
        return result
      }
    }
    this._updateModuleLoadAddedImports(id, ctx._addedImports)
    return null
  }

  async transform(
    code: string,
    id: string,
    options?: {
      inMap?: SourceDescription['map']
    },
  ): Promise<{ code: string; map: SourceMap | { mappings: '' } | null }> {
    let ssr = this.environment.config.consumer === 'server'
    const topLevelConfig = this.environment.getTopLevelConfig()
    const optionsWithSSR = options ? { ...options, ssr } : { ssr }
    const inMap = options?.inMap

    const ctx = new TransformPluginContext(this, id, code, inMap as SourceMap)
    ctx._addedImports = this._getAddedImports(id)

    for (const plugin of this.getSortedPlugins('transform')) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError()

      const filter = getCachedFilterForPlugin(plugin, 'transform')
      if (filter && !filter(id, code)) continue

      if (
        isFutureDeprecationEnabled(
          topLevelConfig,
          'removePluginHookSsrArgument',
        )
      ) {
        Object.defineProperty(optionsWithSSR, 'ssr', {
          get() {
            warnFutureDeprecation(
              topLevelConfig,
              'removePluginHookSsrArgument',
              `Used in plugin "${plugin.name}".`,
            )
            return ssr
          },
          set(v) {
            ssr = v
          },
        })
      }

      ctx._updateActiveInfo(plugin, id, code)
      const start = debugPluginTransform ? performance.now() : 0
      let result: TransformResult | string | undefined
      const handler = getHookHandler(plugin.transform)
      try {
        result = await this.handleHookPromise(
          handler.call(ctx as any, code, id, optionsWithSSR),
        )
      } catch (e) {
        ctx.error(e)
      }
      if (!result) continue
      debugPluginTransform?.(
        timeFrom(start),
        plugin.name,
        prettifyUrl(id, this.environment.config.root),
      )
      if (isObject(result)) {
        if (result.code !== undefined) {
          code = result.code
          if (result.map) {
            if (debugSourcemapCombine) {
              // @ts-expect-error inject plugin name for debug purpose
              result.map.name = plugin.name
            }
            ctx.sourcemapChain.push(result.map)
          }
        }
        ctx._updateModuleInfo(id, result)
      } else {
        code = result
      }
    }
    return {
      code,
      map: ctx._getCombinedSourcemap(),
    }
  }

  async watchChange(
    id: string,
    change: { event: 'create' | 'update' | 'delete' },
  ): Promise<void> {
    await this.hookParallel(
      'watchChange',
      (plugin) => this._getPluginContext(plugin),
      () => [id, change],
    )
  }

  async close(): Promise<void> {
    if (this._closed) return
    this._closed = true
    await Promise.allSettled(Array.from(this._processesing))
    const config = this.environment.getTopLevelConfig()
    await this.hookParallel(
      'buildEnd',
      (plugin) => this._getPluginContext(plugin),
      () => [],
      (plugin) =>
        this.environment.name === 'client' ||
        config.server.perEnvironmentStartEndDuringDev ||
        plugin.perEnvironmentStartEndDuringDev,
    )
    await this.hookParallel(
      'closeBundle',
      (plugin) => this._getPluginContext(plugin),
      () => [],
    )
  }
}

export const basePluginContextMeta = {
  viteVersion,
  rollupVersion,
}

export class BasicMinimalPluginContext<Meta = PluginContextMeta> {
  constructor(
    public meta: Meta,
    private _logger: Logger,
  ) {}

  debug(rawLog: string | RollupLog | (() => string | RollupLog)): void {
    const log = this._normalizeRawLog(rawLog)
    const msg = buildErrorMessage(log, [`debug: ${log.message}`], false)
    debugPluginContainerContext?.(msg)
  }

  info(rawLog: string | RollupLog | (() => string | RollupLog)): void {
    const log = this._normalizeRawLog(rawLog)
    const msg = buildErrorMessage(log, [`info: ${log.message}`], false)
    this._logger.info(msg, { clear: true, timestamp: true })
  }

  warn(rawLog: string | RollupLog | (() => string | RollupLog)): void {
    const log = this._normalizeRawLog(rawLog)
    const msg = buildErrorMessage(
      log,
      [colors.yellow(`warning: ${log.message}`)],
      false,
    )
    this._logger.warn(msg, { clear: true, timestamp: true })
  }

  error(e: string | RollupError): never {
    const err = (typeof e === 'string' ? new Error(e) : e) as RollupError
    throw err
  }

  private _normalizeRawLog(
    rawLog: string | RollupLog | (() => string | RollupLog),
  ): RollupLog {
    const logValue = typeof rawLog === 'function' ? rawLog() : rawLog
    return typeof logValue === 'string' ? new Error(logValue) : logValue
  }
}

class MinimalPluginContext<T extends Environment = Environment>
  extends BasicMinimalPluginContext
  implements RollupMinimalPluginContext
{
  public environment: T
  constructor(meta: PluginContextMeta, environment: T) {
    super(meta, environment.logger)
    this.environment = environment
  }
}

const fsModule: RollupFsModule = {
  appendFile: fsp.appendFile,
  copyFile: fsp.copyFile,
  mkdir: fsp.mkdir as RollupFsModule['mkdir'],
  mkdtemp: fsp.mkdtemp,
  readdir: fsp.readdir,
  readFile: fsp.readFile as RollupFsModule['readFile'],
  realpath: fsp.realpath,
  rename: fsp.rename,
  rmdir: fsp.rmdir,
  stat: fsp.stat,
  lstat: fsp.lstat,
  unlink: fsp.unlink,
  writeFile: fsp.writeFile,
}

class PluginContext
  extends MinimalPluginContext
  implements Omit<RollupPluginContext, 'cache'>
{
  ssr = false
  _scan = false
  _activeId: string | null = null
  _activeCode: string | null = null
  _resolveSkips?: Set<Plugin>
  _resolveSkipCalls?: readonly SkipInformation[]

  constructor(
    public _plugin: Plugin,
    public _container: EnvironmentPluginContainer,
  ) {
    super(_container.minimalContext.meta, _container.environment)
  }

  fs = fsModule

  parse(code: string, opts: any) {
    return rollupParseAst(code, opts)
  }

  async resolve(
    id: string,
    importer?: string,
    options?: {
      attributes?: Record<string, string>
      custom?: CustomPluginOptions
      isEntry?: boolean
      skipSelf?: boolean
    },
  ) {
    let skipCalls: readonly SkipInformation[] | undefined
    if (options?.skipSelf === false) {
      skipCalls = this._resolveSkipCalls
    } else if (this._resolveSkipCalls) {
      const skipCallsTemp = [...this._resolveSkipCalls]
      const sameCallIndex = this._resolveSkipCalls.findIndex(
        (c) =>
          c.id === id && c.importer === importer && c.plugin === this._plugin,
      )
      if (sameCallIndex !== -1) {
        skipCallsTemp[sameCallIndex] = {
          ...skipCallsTemp[sameCallIndex],
          called: true,
        }
      } else {
        skipCallsTemp.push({ id, importer, plugin: this._plugin })
      }
      skipCalls = skipCallsTemp
    } else {
      skipCalls = [{ id, importer, plugin: this._plugin }]
    }

    let out = await this._container.resolveId(id, importer, {
      attributes: options?.attributes,
      custom: options?.custom,
      isEntry: !!options?.isEntry,
      skip: this._resolveSkips,
      skipCalls,
      scan: this._scan,
    })
    if (typeof out === 'string') out = { id: out }
    return out as ResolvedId | null
  }

  async load(
    options: {
      id: string
      resolveDependencies?: boolean
    } & Partial<PartialNull<ModuleOptions>>,
  ): Promise<ModuleInfo> {
    // We may not have added this to our module graph yet, so ensure it exists
    await this._container.moduleGraph?.ensureEntryFromUrl(unwrapId(options.id))
    // Not all options passed to this function make sense in the context of loading individual files,
    // but we can at least update the module info properties we support
    this._updateModuleInfo(options.id, options)

    const loadResult = await this._container.load(options.id)
    const code = typeof loadResult === 'object' ? loadResult?.code : loadResult
    if (code != null) {
      await this._container.transform(code, options.id)
    }

    const moduleInfo = this.getModuleInfo(options.id)
    // This shouldn't happen due to calling ensureEntryFromUrl, but 1) our types can't ensure that
    // and 2) moduleGraph may not have been provided (though in the situations where that happens,
    // we should never have plugins calling this.load)
    if (!moduleInfo) throw Error(`Failed to load module with id ${options.id}`)
    return moduleInfo
  }

  getModuleInfo(id: string): ModuleInfo | null {
    return this._container.getModuleInfo(id)
  }

  _updateModuleInfo(id: string, { meta }: { meta?: object | null }) {
    if (meta) {
      const moduleInfo = this.getModuleInfo(id)
      if (moduleInfo) {
        moduleInfo.meta = { ...moduleInfo.meta, ...meta }
      }
    }
  }

  getModuleIds(): IterableIterator<string> {
    return this._container.moduleGraph
      ? this._container.moduleGraph.idToModuleMap.keys()
      : Array.prototype[Symbol.iterator]()
  }

  addWatchFile(id: string): void {
    this._container.watchFiles.add(id)
    if (this._container.watcher)
      ensureWatchedFile(
        this._container.watcher,
        id,
        this.environment.config.root,
      )
  }

  getWatchFiles(): string[] {
    return [...this._container.watchFiles]
  }

  emitFile(_assetOrFile: EmittedFile): string {
    this._warnIncompatibleMethod(`emitFile`)
    return ''
  }

  setAssetSource(): void {
    this._warnIncompatibleMethod(`setAssetSource`)
  }

  getFileName(): string {
    this._warnIncompatibleMethod(`getFileName`)
    return ''
  }

  override debug(log: string | RollupLog | (() => string | RollupLog)): void {
    const err = this._formatLog(typeof log === 'function' ? log() : log)
    super.debug(err)
  }

  override info(log: string | RollupLog | (() => string | RollupLog)): void {
    const err = this._formatLog(typeof log === 'function' ? log() : log)
    super.info(err)
  }

  override warn(
    log: string | RollupLog | (() => string | RollupLog),
    position?: number | { column: number; line: number },
  ): void {
    const err = this._formatLog(
      typeof log === 'function' ? log() : log,
      position,
    )
    super.warn(err)
  }

  override error(
    e: string | RollupError,
    position?: number | { column: number; line: number },
  ): never {
    // error thrown here is caught by the transform middleware and passed on
    // the error middleware.
    throw this._formatLog(e, position)
  }

  private _formatLog<E extends RollupLog>(
    e: string | E,
    position?: number | { column: number; line: number } | undefined,
  ): E {
    const err = (typeof e === 'string' ? new Error(e) : e) as E
    if (err.pluginCode) {
      return err // The plugin likely called `this.error`
    }
    err.plugin = this._plugin.name
    if (this._activeId && !err.id) err.id = this._activeId
    if (this._activeCode) {
      err.pluginCode = this._activeCode

      // some rollup plugins, e.g. json, sets err.position instead of err.pos
      const pos = position ?? err.pos ?? (err as any).position

      if (pos != null) {
        let errLocation
        try {
          errLocation = numberToPos(this._activeCode, pos)
        } catch (err2) {
          this.environment.logger.error(
            colors.red(
              `Error in error handler:\n${err2.stack || err2.message}\n`,
            ),
            // print extra newline to separate the two errors
            { error: err2 },
          )
          throw err
        }
        err.loc = err.loc || {
          file: err.id,
          ...errLocation,
        }
        err.frame = err.frame || generateCodeFrame(this._activeCode, pos)
      } else if (err.loc) {
        // css preprocessors may report errors in an included file
        if (!err.frame) {
          let code = this._activeCode
          if (err.loc.file) {
            err.id = normalizePath(err.loc.file)
            try {
              code = fs.readFileSync(err.loc.file, 'utf-8')
            } catch {}
          }
          err.frame = generateCodeFrame(code, err.loc)
        }
      } else if ((err as any).line && (err as any).column) {
        err.loc = {
          file: err.id,
          line: (err as any).line,
          column: (err as any).column,
        }
        err.frame = err.frame || generateCodeFrame(this._activeCode, err.loc)
      }

      // TODO: move it to overrides
      if (
        this instanceof TransformPluginContext &&
        typeof err.loc?.line === 'number' &&
        typeof err.loc.column === 'number'
      ) {
        const rawSourceMap = this._getCombinedSourcemap()
        if (rawSourceMap && 'version' in rawSourceMap) {
          const traced = new TraceMap(rawSourceMap as any)
          const { source, line, column } = originalPositionFor(traced, {
            line: Number(err.loc.line),
            column: Number(err.loc.column),
          })
          if (source) {
            err.loc = { file: source, line, column }
          }
        }
      }
    } else if (err.loc) {
      if (!err.frame) {
        let code = err.pluginCode
        if (err.loc.file) {
          err.id = normalizePath(err.loc.file)
          if (!code) {
            try {
              code = fs.readFileSync(err.loc.file, 'utf-8')
            } catch {}
          }
        }
        if (code) {
          err.frame = generateCodeFrame(`${code}`, err.loc)
        }
      }
    }

    if (
      typeof err.loc?.column !== 'number' &&
      typeof err.loc?.line !== 'number' &&
      !err.loc?.file
    ) {
      delete err.loc
    }

    return err
  }

  _warnIncompatibleMethod(method: string): void {
    this.environment.logger.warn(
      colors.cyan(`[plugin:${this._plugin.name}] `) +
        colors.yellow(
          `context method ${colors.bold(
            `${method}()`,
          )} is not supported in serve mode. This plugin is likely not vite-compatible.`,
        ),
    )
  }
}

class ResolveIdContext extends PluginContext {
  constructor(
    container: EnvironmentPluginContainer,
    skip: Set<Plugin> | undefined,
    skipCalls: readonly SkipInformation[] | undefined,
    scan: boolean,
  ) {
    super(null!, container)
    this._resolveSkips = skip
    this._resolveSkipCalls = skipCalls
    this._scan = scan
  }
}

class LoadPluginContext extends PluginContext {
  _addedImports: Set<string> | null = null

  constructor(container: EnvironmentPluginContainer) {
    super(null!, container)
  }

  override addWatchFile(id: string): void {
    if (!this._addedImports) {
      this._addedImports = new Set()
    }
    this._addedImports.add(id)
    super.addWatchFile(id)
  }
}

class TransformPluginContext
  extends LoadPluginContext
  implements Omit<RollupTransformPluginContext, 'cache'>
{
  filename: string
  originalCode: string
  originalSourcemap: SourceMap | null = null
  sourcemapChain: NonNullable<SourceDescription['map']>[] = []
  combinedMap: SourceMap | { mappings: '' } | null = null

  constructor(
    container: EnvironmentPluginContainer,
    id: string,
    code: string,
    inMap?: SourceMap | string,
  ) {
    super(container)

    this.filename = id
    this.originalCode = code
    if (inMap) {
      if (debugSourcemapCombine) {
        // @ts-expect-error inject name for debug purpose
        inMap.name = '$inMap'
      }
      this.sourcemapChain.push(inMap)
    }
  }

  _getCombinedSourcemap(): SourceMap | { mappings: '' } | null {
    if (
      debugSourcemapCombine &&
      debugSourcemapCombineFilter &&
      this.filename.includes(debugSourcemapCombineFilter)
    ) {
      debugSourcemapCombine('----------', this.filename)
      debugSourcemapCombine(this.combinedMap)
      debugSourcemapCombine(this.sourcemapChain)
      debugSourcemapCombine('----------')
    }

    let combinedMap = this.combinedMap
    // { mappings: '' }
    if (
      combinedMap &&
      !('version' in combinedMap) &&
      combinedMap.mappings === ''
    ) {
      this.sourcemapChain.length = 0
      return combinedMap
    }

    for (let m of this.sourcemapChain) {
      if (typeof m === 'string') m = JSON.parse(m)
      if (!('version' in (m as SourceMap))) {
        // { mappings: '' }
        if ((m as SourceMap).mappings === '') {
          combinedMap = { mappings: '' }
          break
        }
        // empty, nullified source map
        combinedMap = null
        break
      }
      if (!combinedMap) {
        const sm = m as SourceMap
        // sourcemap should not include `sources: [null]` (because `sources` should be string) nor
        // `sources: ['']` (because `''` means the path of sourcemap)
        // but MagicString generates this when `filename` option is not set.
        // Rollup supports these and therefore we support this as well
        if (sm.sources.length === 1 && !sm.sources[0]) {
          combinedMap = {
            ...sm,
            sources: [this.filename],
            sourcesContent: [this.originalCode],
          }
        } else {
          combinedMap = sm
        }
      } else {
        combinedMap = combineSourcemaps(cleanUrl(this.filename), [
          m as RawSourceMap,
          combinedMap as RawSourceMap,
        ]) as SourceMap
      }
    }
    if (combinedMap !== this.combinedMap) {
      this.combinedMap = combinedMap
      this.sourcemapChain.length = 0
    }
    return this.combinedMap
  }

  getCombinedSourcemap(): SourceMap {
    const map = this._getCombinedSourcemap()
    if (!map || (!('version' in map) && map.mappings === '')) {
      return new MagicString(this.originalCode).generateMap({
        includeContent: true,
        hires: 'boundary',
        source: cleanUrl(this.filename),
      })
    }
    return map
  }

  _updateActiveInfo(plugin: Plugin, id: string, code: string): void {
    this._plugin = plugin
    this._activeId = id
    this._activeCode = code
  }
}

export type {
  EnvironmentPluginContainer,
  TransformPluginContext,
  TransformResult,
}

// Backward compatibility
class PluginContainer {
  constructor(private environments: Record<string, Environment>) {}

  // Backward compatibility
  // Users should call pluginContainer.resolveId (and load/transform) passing the environment they want to work with
  // But there is code that is going to call it without passing an environment, or with the ssr flag to get the ssr environment
  private _getEnvironment(options?: {
    ssr?: boolean
    environment?: Environment
  }) {
    return options?.environment
      ? options.environment
      : this.environments[options?.ssr ? 'ssr' : 'client']
  }

  private _getPluginContainer(options?: {
    ssr?: boolean
    environment?: Environment
  }) {
    return (this._getEnvironment(options) as DevEnvironment).pluginContainer
  }

  getModuleInfo(id: string): ModuleInfo | null {
    const clientModuleInfo = (
      this.environments.client as DevEnvironment
    ).pluginContainer.getModuleInfo(id)
    const ssrModuleInfo = (
      this.environments.ssr as DevEnvironment
    ).pluginContainer.getModuleInfo(id)

    if (clientModuleInfo == null && ssrModuleInfo == null) return null

    return new Proxy({} as any, {
      get: (_, key: string) => {
        // `meta` refers to `ModuleInfo.meta` of both environments, so we also
        // need to merge it here
        if (key === 'meta') {
          const meta: Record<string, any> = {}
          if (ssrModuleInfo) {
            Object.assign(meta, ssrModuleInfo.meta)
          }
          if (clientModuleInfo) {
            Object.assign(meta, clientModuleInfo.meta)
          }
          return meta
        }
        if (clientModuleInfo) {
          if (key in clientModuleInfo) {
            return clientModuleInfo[key as keyof ModuleInfo]
          }
        }
        if (ssrModuleInfo) {
          if (key in ssrModuleInfo) {
            return ssrModuleInfo[key as keyof ModuleInfo]
          }
        }
      },
    })
  }

  get options(): InputOptions {
    return (this.environments.client as DevEnvironment).pluginContainer.options
  }

  // For backward compatibility, buildStart and watchChange are called only for the client environment
  // buildStart is called per environment for a plugin with the perEnvironmentStartEndDuring dev flag

  async buildStart(_options?: InputOptions): Promise<void> {
    return (
      this.environments.client as DevEnvironment
    ).pluginContainer.buildStart(_options)
  }

  async watchChange(
    id: string,
    change: { event: 'create' | 'update' | 'delete' },
  ): Promise<void> {
    return (
      this.environments.client as DevEnvironment
    ).pluginContainer.watchChange(id, change)
  }

  async resolveId(
    rawId: string,
    importer?: string,
    options?: {
      attributes?: Record<string, string>
      custom?: CustomPluginOptions
      /** @deprecated use `skipCalls` instead */
      skip?: Set<Plugin>
      skipCalls?: readonly SkipInformation[]
      ssr?: boolean
      /**
       * @internal
       */
      scan?: boolean
      isEntry?: boolean
    },
  ): Promise<PartialResolvedId | null> {
    return this._getPluginContainer(options).resolveId(rawId, importer, options)
  }

  async load(
    id: string,
    options?: {
      ssr?: boolean
    },
  ): Promise<LoadResult | null> {
    return this._getPluginContainer(options).load(id)
  }

  async transform(
    code: string,
    id: string,
    options?: {
      ssr?: boolean
      environment?: Environment
      inMap?: SourceDescription['map']
    },
  ): Promise<{ code: string; map: SourceMap | { mappings: '' } | null }> {
    return this._getPluginContainer(options).transform(code, id, options)
  }

  async close(): Promise<void> {
    // noop, close will be called for each environment
  }
}

/**
 * server.pluginContainer compatibility
 *
 * The default environment is in buildStart, buildEnd, watchChange, and closeBundle hooks,
 * which are called once for all environments, or when no environment is passed in other hooks.
 * The ssrEnvironment is needed for backward compatibility when the ssr flag is passed without
 * an environment. The defaultEnvironment in the main pluginContainer in the server should be
 * the client environment for backward compatibility.
 **/
export function createPluginContainer(
  environments: Record<string, Environment>,
): PluginContainer {
  return new PluginContainer(environments)
}

export type { PluginContainer }



================================================
FILE: packages/vite/src/node/server/searchRoot.ts
================================================
import fs from 'node:fs'
import { dirname, join } from 'node:path'
import { isFileReadable } from '../utils'

// https://github.com/vitejs/vite/issues/2820#issuecomment-812495079
const ROOT_FILES = [
  // '.git',

  // https://pnpm.io/workspaces/
  'pnpm-workspace.yaml',

  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',

  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json',

  // https://github.com/lerna/lerna#lernajson
  'lerna.json',
]

// npm: https://docs.npmjs.com/cli/v7/using-npm/workspaces#installing-workspaces
// yarn: https://classic.yarnpkg.com/en/docs/workspaces/#toc-how-to-use-it
function hasWorkspacePackageJSON(root: string): boolean {
  const path = join(root, 'package.json')
  if (!isFileReadable(path)) {
    return false
  }
  try {
    const content = JSON.parse(fs.readFileSync(path, 'utf-8')) || {}
    return !!content.workspaces
  } catch {
    return false
  }
}

function hasRootFile(root: string): boolean {
  return ROOT_FILES.some((file) => fs.existsSync(join(root, file)))
}

function hasPackageJSON(root: string) {
  const path = join(root, 'package.json')
  return fs.existsSync(path)
}

/**
 * Search up for the nearest `package.json`
 */
export function searchForPackageRoot(current: string, root = current): string {
  if (hasPackageJSON(current)) return current

  const dir = dirname(current)
  // reach the fs root
  if (!dir || dir === current) return root

  return searchForPackageRoot(dir, root)
}

/**
 * Search up for the nearest workspace root
 */
export function searchForWorkspaceRoot(
  current: string,
  root = searchForPackageRoot(current),
): string {
  if (hasRootFile(current)) return current
  if (hasWorkspacePackageJSON(current)) return current

  const dir = dirname(current)
  // reach the fs root
  if (!dir || dir === current) return root

  return searchForWorkspaceRoot(dir, root)
}



================================================
FILE: packages/vite/src/node/server/send.ts
================================================
import type {
  IncomingMessage,
  OutgoingHttpHeaders,
  ServerResponse,
} from 'node:http'
import path from 'node:path'
import convertSourceMap from 'convert-source-map'
import getEtag from 'etag'
import type { SourceMap } from 'rollup'
import MagicString from 'magic-string'
import { createDebugger, removeTimestampQuery } from '../utils'
import { getCodeWithSourcemap } from './sourcemap'

const debug = createDebugger('vite:send', {
  onlyWhenFocused: true,
})

const alias: Record<string, string | undefined> = {
  js: 'text/javascript',
  css: 'text/css',
  html: 'text/html',
  json: 'application/json',
}

export interface SendOptions {
  etag?: string
  cacheControl?: string
  headers?: OutgoingHttpHeaders
  map?: SourceMap | { mappings: '' } | null
}

export function send(
  req: IncomingMessage,
  res: ServerResponse,
  content: string | Buffer,
  type: string,
  options: SendOptions,
): void {
  const {
    etag = getEtag(content, { weak: true }),
    cacheControl = 'no-cache',
    headers,
    map,
  } = options

  if (res.writableEnded) {
    return
  }

  if (req.headers['if-none-match'] === etag) {
    res.statusCode = 304
    res.end()
    return
  }

  res.setHeader('Content-Type', alias[type] || type)
  res.setHeader('Cache-Control', cacheControl)
  res.setHeader('Etag', etag)

  if (headers) {
    for (const name in headers) {
      res.setHeader(name, headers[name]!)
    }
  }

  // inject source map reference
  if (map && 'version' in map && map.mappings) {
    if (type === 'js' || type === 'css') {
      content = getCodeWithSourcemap(type, content.toString(), map)
    }
  }
  // inject fallback sourcemap for js for improved debugging
  // https://github.com/vitejs/vite/pull/13514#issuecomment-1592431496
  else if (type === 'js' && (!map || map.mappings !== '')) {
    const code = content.toString()
    // if the code has existing inline sourcemap, assume it's correct and skip
    if (convertSourceMap.mapFileCommentRegex.test(code)) {
      debug?.(`Skipped injecting fallback sourcemap for ${req.url}`)
    } else {
      const urlWithoutTimestamp = removeTimestampQuery(req.url!)
      const ms = new MagicString(code)
      content = getCodeWithSourcemap(
        type,
        code,
        ms.generateMap({
          source: path.basename(urlWithoutTimestamp),
          hires: 'boundary',
          includeContent: true,
        }),
      )
    }
  }

  res.statusCode = 200
  if (req.method === 'HEAD') {
    res.end()
  } else {
    res.end(content)
  }
  return
}



================================================
FILE: packages/vite/src/node/server/sourcemap.ts
================================================
import path from 'node:path'
import fsp from 'node:fs/promises'
import convertSourceMap from 'convert-source-map'
import type { ExistingRawSourceMap, SourceMap } from 'rollup'
import type { Logger } from '../logger'
import { blankReplacer, createDebugger } from '../utils'
import { cleanUrl } from '../../shared/utils'

const debug = createDebugger('vite:sourcemap', {
  onlyWhenFocused: true,
})

// Virtual modules should be prefixed with a null byte to avoid a
// false positive "missing source" warning. We also check for certain
// prefixes used for special handling in esbuildDepPlugin.
const virtualSourceRE = /^(?:dep:|browser-external:|virtual:)|\0/

interface SourceMapLike {
  sources: string[]
  sourcesContent?: (string | null)[]
  sourceRoot?: string
}

async function computeSourceRoute(map: SourceMapLike, file: string) {
  let sourceRoot: string | undefined
  try {
    // The source root is undefined for virtual modules and permission errors.
    sourceRoot = await fsp.realpath(
      path.resolve(path.dirname(file), map.sourceRoot || ''),
    )
  } catch {}
  return sourceRoot
}

export async function injectSourcesContent(
  map: SourceMapLike,
  file: string,
  logger: Logger,
): Promise<void> {
  let sourceRootPromise: Promise<string | undefined>

  const missingSources: string[] = []
  const sourcesContent = map.sourcesContent || []
  const sourcesContentPromises: Promise<void>[] = []
  for (let index = 0; index < map.sources.length; index++) {
    const sourcePath = map.sources[index]
    if (
      sourcesContent[index] == null &&
      sourcePath &&
      !virtualSourceRE.test(sourcePath)
    ) {
      sourcesContentPromises.push(
        (async () => {
          // inject content from source file when sourcesContent is null
          sourceRootPromise ??= computeSourceRoute(map, file)
          const sourceRoot = await sourceRootPromise
          let resolvedSourcePath = cleanUrl(decodeURI(sourcePath))
          if (sourceRoot) {
            resolvedSourcePath = path.resolve(sourceRoot, resolvedSourcePath)
          }

          sourcesContent[index] = await fsp
            .readFile(resolvedSourcePath, 'utf-8')
            .catch(() => {
              missingSources.push(resolvedSourcePath)
              return null
            })
        })(),
      )
    }
  }

  await Promise.all(sourcesContentPromises)

  map.sourcesContent = sourcesContent

  // Use this command…
  //    DEBUG="vite:sourcemap" vite build
  // …to log the missing sources.
  if (missingSources.length) {
    logger.warnOnce(`Sourcemap for "${file}" points to missing source files`)
    debug?.(`Missing sources:\n  ` + missingSources.join(`\n  `))
  }
}

export function genSourceMapUrl(map: SourceMap | string): string {
  if (typeof map !== 'string') {
    map = JSON.stringify(map)
  }
  return `data:application/json;base64,${Buffer.from(map).toString('base64')}`
}

export function getCodeWithSourcemap(
  type: 'js' | 'css',
  code: string,
  map: SourceMap,
): string {
  if (debug) {
    code += `\n/*${JSON.stringify(map, null, 2).replace(/\*\//g, '*\\/')}*/\n`
  }

  if (type === 'js') {
    code += `\n//# sourceMappingURL=${genSourceMapUrl(map)}`
  } else if (type === 'css') {
    code += `\n/*# sourceMappingURL=${genSourceMapUrl(map)} */`
  }

  return code
}

export function applySourcemapIgnoreList(
  map: ExistingRawSourceMap,
  sourcemapPath: string,
  sourcemapIgnoreList: (sourcePath: string, sourcemapPath: string) => boolean,
  logger?: Logger,
): void {
  let { x_google_ignoreList } = map
  if (x_google_ignoreList === undefined) {
    x_google_ignoreList = []
  }
  for (
    let sourcesIndex = 0;
    sourcesIndex < map.sources.length;
    ++sourcesIndex
  ) {
    const sourcePath = map.sources[sourcesIndex]
    if (!sourcePath) continue

    const ignoreList = sourcemapIgnoreList(
      path.isAbsolute(sourcePath)
        ? sourcePath
        : path.resolve(path.dirname(sourcemapPath), sourcePath),
      sourcemapPath,
    )
    if (logger && typeof ignoreList !== 'boolean') {
      logger.warn('sourcemapIgnoreList function must return a boolean.')
    }

    if (ignoreList && !x_google_ignoreList.includes(sourcesIndex)) {
      x_google_ignoreList.push(sourcesIndex)
    }
  }

  if (x_google_ignoreList.length > 0) {
    if (!map.x_google_ignoreList) map.x_google_ignoreList = x_google_ignoreList
  }
}

export async function extractSourcemapFromFile(
  code: string,
  filePath: string,
): Promise<{ code: string; map: SourceMap } | undefined> {
  const map = (
    convertSourceMap.fromSource(code) ||
    (await convertSourceMap.fromMapFileSource(
      code,
      createConvertSourceMapReadMap(filePath),
    ))
  )?.toObject()

  if (map) {
    return {
      code: code.replace(convertSourceMap.mapFileCommentRegex, blankReplacer),
      map,
    }
  }
}

function createConvertSourceMapReadMap(originalFileName: string) {
  return (filename: string) => {
    return fsp.readFile(
      path.resolve(path.dirname(originalFileName), filename),
      'utf-8',
    )
  }
}



================================================
FILE: packages/vite/src/node/server/transformRequest.ts
================================================
import fsp from 'node:fs/promises'
import path from 'node:path'
import { performance } from 'node:perf_hooks'
import getEtag from 'etag'
import MagicString from 'magic-string'
import { init, parse as parseImports } from 'es-module-lexer'
import type { PartialResolvedId, SourceDescription, SourceMap } from 'rollup'
import colors from 'picocolors'
import type { EnvironmentModuleNode } from '../server/moduleGraph'
import {
  createDebugger,
  ensureWatchedFile,
  injectQuery,
  isObject,
  monotonicDateNow,
  prettifyUrl,
  removeImportQuery,
  removeTimestampQuery,
  stripBase,
  timeFrom,
} from '../utils'
import { ssrTransform } from '../ssr/ssrTransform'
import { checkPublicFile } from '../publicDir'
import { cleanUrl, slash, unwrapId } from '../../shared/utils'
import {
  applySourcemapIgnoreList,
  extractSourcemapFromFile,
  injectSourcesContent,
} from './sourcemap'
import { isFileLoadingAllowed } from './middlewares/static'
import { throwClosedServerError } from './pluginContainer'
import type { DevEnvironment } from './environment'

export const ERR_LOAD_URL = 'ERR_LOAD_URL'
export const ERR_LOAD_PUBLIC_URL = 'ERR_LOAD_PUBLIC_URL'
export const ERR_DENIED_ID = 'ERR_DENIED_ID'

const debugLoad = createDebugger('vite:load')
const debugTransform = createDebugger('vite:transform')
const debugCache = createDebugger('vite:cache')

export interface TransformResult {
  code: string
  map: SourceMap | { mappings: '' } | null
  ssr?: boolean
  etag?: string
  deps?: string[]
  dynamicDeps?: string[]
}

export interface TransformOptions {
  /**
   * @deprecated inferred from environment
   */
  ssr?: boolean
}

export interface TransformOptionsInternal {
  /**
   * @internal
   */
  allowId?: (id: string) => boolean
}

// TODO: This function could be moved to the DevEnvironment class.
// It was already using private fields from the server before, and it now does
// the same with environment._closing, environment._pendingRequests and
// environment._registerRequestProcessing. Maybe it makes sense to keep it in
// separate file to preserve the history or keep the DevEnvironment class cleaner,
// but conceptually this is: `environment.transformRequest(url, options)`

export function transformRequest(
  environment: DevEnvironment,
  url: string,
  options: TransformOptionsInternal = {},
): Promise<TransformResult | null> {
  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError()

  // This module may get invalidated while we are processing it. For example
  // when a full page reload is needed after the re-processing of pre-bundled
  // dependencies when a missing dep is discovered. We save the current time
  // to compare it to the last invalidation performed to know if we should
  // cache the result of the transformation or we should discard it as stale.
  //
  // A module can be invalidated due to:
  // 1. A full reload because of pre-bundling newly discovered deps
  // 2. A full reload after a config change
  // 3. The file that generated the module changed
  // 4. Invalidation for a virtual module
  //
  // For 1 and 2, a new request for this module will be issued after
  // the invalidation as part of the browser reloading the page. For 3 and 4
  // there may not be a new request right away because of HMR handling.
  // In all cases, the next time this module is requested, it should be
  // re-processed.
  //
  // We save the timestamp when we start processing and compare it with the
  // last time this module is invalidated
  const timestamp = monotonicDateNow()

  const pending = environment._pendingRequests.get(url)
  if (pending) {
    return environment.moduleGraph
      .getModuleByUrl(removeTimestampQuery(url))
      .then((module) => {
        if (!module || pending.timestamp > module.lastInvalidationTimestamp) {
          // The pending request is still valid, we can safely reuse its result
          return pending.request
        } else {
          // Request 1 for module A     (pending.timestamp)
          // Invalidate module A        (module.lastInvalidationTimestamp)
          // Request 2 for module A     (timestamp)

          // First request has been invalidated, abort it to clear the cache,
          // then perform a new doTransform.
          pending.abort()
          return transformRequest(environment, url, options)
        }
      })
  }

  const request = doTransform(environment, url, options, timestamp)

  // Avoid clearing the cache of future requests if aborted
  let cleared = false
  const clearCache = () => {
    if (!cleared) {
      environment._pendingRequests.delete(url)
      cleared = true
    }
  }

  // Cache the request and clear it once processing is done
  environment._pendingRequests.set(url, {
    request,
    timestamp,
    abort: clearCache,
  })

  return request.finally(clearCache)
}

async function doTransform(
  environment: DevEnvironment,
  url: string,
  options: TransformOptionsInternal,
  timestamp: number,
) {
  url = removeTimestampQuery(url)

  const { pluginContainer } = environment

  let module = await environment.moduleGraph.getModuleByUrl(url)
  if (module) {
    // try use cache from url
    const cached = await getCachedTransformResult(
      environment,
      url,
      module,
      timestamp,
    )
    if (cached) return cached
  }

  const resolved = module
    ? undefined
    : ((await pluginContainer.resolveId(url, undefined)) ?? undefined)

  // resolve
  const id = module?.id ?? resolved?.id ?? url

  module ??= environment.moduleGraph.getModuleById(id)
  if (module) {
    // if a different url maps to an existing loaded id,  make sure we relate this url to the id
    await environment.moduleGraph._ensureEntryFromUrl(url, undefined, resolved)
    // try use cache from id
    const cached = await getCachedTransformResult(
      environment,
      url,
      module,
      timestamp,
    )
    if (cached) return cached
  }

  const result = loadAndTransform(
    environment,
    id,
    url,
    options,
    timestamp,
    module,
    resolved,
  )

  const { depsOptimizer } = environment
  if (!depsOptimizer?.isOptimizedDepFile(id)) {
    environment._registerRequestProcessing(id, () => result)
  }

  return result
}

async function getCachedTransformResult(
  environment: DevEnvironment,
  url: string,
  module: EnvironmentModuleNode,
  timestamp: number,
) {
  const prettyUrl = debugCache ? prettifyUrl(url, environment.config.root) : ''

  // tries to handle soft invalidation of the module if available,
  // returns a boolean true is successful, or false if no handling is needed
  const softInvalidatedTransformResult = await handleModuleSoftInvalidation(
    environment,
    module,
    timestamp,
  )
  if (softInvalidatedTransformResult) {
    debugCache?.(`[memory-hmr] ${prettyUrl}`)
    return softInvalidatedTransformResult
  }

  // check if we have a fresh cache
  const cached = module.transformResult
  if (cached) {
    debugCache?.(`[memory] ${prettyUrl}`)
    return cached
  }
}

async function loadAndTransform(
  environment: DevEnvironment,
  id: string,
  url: string,
  options: TransformOptionsInternal,
  timestamp: number,
  mod?: EnvironmentModuleNode,
  resolved?: PartialResolvedId,
) {
  const { config, pluginContainer, logger } = environment
  const prettyUrl =
    debugLoad || debugTransform ? prettifyUrl(url, config.root) : ''

  const moduleGraph = environment.moduleGraph

  if (options.allowId && !options.allowId(id)) {
    const err: any = new Error(`Denied ID ${id}`)
    err.code = ERR_DENIED_ID
    err.id = id
    throw err
  }

  let code: string | null = null
  let map: SourceDescription['map'] = null

  // load
  const loadStart = debugLoad ? performance.now() : 0
  const loadResult = await pluginContainer.load(id)

  if (loadResult == null) {
    const file = cleanUrl(id)

    // try fallback loading it from fs as string
    // if the file is a binary, there should be a plugin that already loaded it
    // as string
    // only try the fallback if access is allowed, skip for out of root url
    // like /service-worker.js or /api/users
    if (
      environment.config.consumer === 'server' ||
      isFileLoadingAllowed(environment.getTopLevelConfig(), slash(file))
    ) {
      try {
        code = await fsp.readFile(file, 'utf-8')
        debugLoad?.(`${timeFrom(loadStart)} [fs] ${prettyUrl}`)
      } catch (e) {
        if (e.code !== 'ENOENT' && e.code !== 'EISDIR') {
          throw e
        }
      }
      if (code != null && environment.pluginContainer.watcher) {
        ensureWatchedFile(
          environment.pluginContainer.watcher,
          file,
          config.root,
        )
      }
    }
    if (code) {
      try {
        const extracted = await extractSourcemapFromFile(code, file)
        if (extracted) {
          code = extracted.code
          map = extracted.map
        }
      } catch (e) {
        logger.warn(`Failed to load source map for ${file}.\n${e}`, {
          timestamp: true,
        })
      }
    }
  } else {
    debugLoad?.(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`)
    if (isObject(loadResult)) {
      code = loadResult.code
      map = loadResult.map
    } else {
      code = loadResult
    }
  }
  if (code == null) {
    const isPublicFile = checkPublicFile(url, environment.getTopLevelConfig())
    let publicDirName = path.relative(config.root, config.publicDir)
    if (publicDirName[0] !== '.') publicDirName = '/' + publicDirName
    const msg = isPublicFile
      ? `This file is in ${publicDirName} and will be copied as-is during ` +
        `build without going through the plugin transforms, and therefore ` +
        `should not be imported from source code. It can only be referenced ` +
        `via HTML tags.`
      : `Does the file exist?`
    const importerMod: EnvironmentModuleNode | undefined =
      moduleGraph.idToModuleMap.get(id)?.importers.values().next().value
    const importer = importerMod?.file || importerMod?.url
    const err: any = new Error(
      `Failed to load url ${url} (resolved id: ${id})${
        importer ? ` in ${importer}` : ''
      }. ${msg}`,
    )
    err.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL
    throw err
  }

  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError()

  // ensure module in graph after successful load
  mod ??= await moduleGraph._ensureEntryFromUrl(url, undefined, resolved)

  // transform
  const transformStart = debugTransform ? performance.now() : 0
  const transformResult = await pluginContainer.transform(code, id, {
    inMap: map,
  })
  const originalCode = code
  if (transformResult.code === originalCode) {
    // no transform applied, keep code as-is
    debugTransform?.(
      timeFrom(transformStart) + colors.dim(` [skipped] ${prettyUrl}`),
    )
  } else {
    debugTransform?.(`${timeFrom(transformStart)} ${prettyUrl}`)
    code = transformResult.code!
    map = transformResult.map
  }

  let normalizedMap: SourceMap | { mappings: '' } | null
  if (typeof map === 'string') {
    normalizedMap = JSON.parse(map)
  } else if (map) {
    normalizedMap = map as SourceMap | { mappings: '' }
  } else {
    normalizedMap = null
  }

  if (normalizedMap && 'version' in normalizedMap && mod.file) {
    if (normalizedMap.mappings) {
      await injectSourcesContent(normalizedMap, mod.file, logger)
    }

    const sourcemapPath = `${mod.file}.map`
    applySourcemapIgnoreList(
      normalizedMap,
      sourcemapPath,
      config.server.sourcemapIgnoreList,
      logger,
    )

    if (path.isAbsolute(mod.file)) {
      let modDirname
      for (
        let sourcesIndex = 0;
        sourcesIndex < normalizedMap.sources.length;
        ++sourcesIndex
      ) {
        const sourcePath = normalizedMap.sources[sourcesIndex]
        if (sourcePath) {
          // Rewrite sources to relative paths to give debuggers the chance
          // to resolve and display them in a meaningful way (rather than
          // with absolute paths).
          if (path.isAbsolute(sourcePath)) {
            modDirname ??= path.dirname(mod.file)
            normalizedMap.sources[sourcesIndex] = path.relative(
              modDirname,
              sourcePath,
            )
          }
        }
      }
    }
  }

  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError()

  const topLevelConfig = environment.getTopLevelConfig()
  const result = environment.config.dev.moduleRunnerTransform
    ? await ssrTransform(code, normalizedMap, url, originalCode, {
        json: {
          stringify:
            topLevelConfig.json.stringify === true &&
            topLevelConfig.json.namedExports !== true,
        },
      })
    : ({
        code,
        map: normalizedMap,
        etag: getEtag(code, { weak: true }),
      } satisfies TransformResult)

  // Only cache the result if the module wasn't invalidated while it was
  // being processed, so it is re-processed next time if it is stale
  if (timestamp > mod.lastInvalidationTimestamp)
    moduleGraph.updateModuleTransformResult(mod, result)

  return result
}

/**
 * When a module is soft-invalidated, we can preserve its previous `transformResult` and
 * return similar code to before:
 *
 * - Client: We need to transform the import specifiers with new timestamps
 * - SSR: We don't need to change anything as `ssrLoadModule` controls it
 */
async function handleModuleSoftInvalidation(
  environment: DevEnvironment,
  mod: EnvironmentModuleNode,
  timestamp: number,
) {
  const transformResult = mod.invalidationState

  // Reset invalidation state
  mod.invalidationState = undefined

  // Skip if not soft-invalidated
  if (!transformResult || transformResult === 'HARD_INVALIDATED') return

  if (mod.transformResult) {
    throw new Error(
      `Internal server error: Soft-invalidated module "${mod.url}" should not have existing transform result`,
    )
  }

  let result: TransformResult
  // For SSR soft-invalidation, no transformation is needed
  if (transformResult.ssr) {
    result = transformResult
  }
  // We need to transform each imports with new timestamps if available
  else {
    await init
    const source = transformResult.code
    const s = new MagicString(source)
    const [imports] = parseImports(source, mod.id || undefined)

    for (const imp of imports) {
      let rawUrl = source.slice(imp.s, imp.e)
      if (rawUrl === 'import.meta') continue

      const hasQuotes = rawUrl[0] === '"' || rawUrl[0] === "'"
      if (hasQuotes) {
        rawUrl = rawUrl.slice(1, -1)
      }

      const urlWithoutTimestamp = removeTimestampQuery(rawUrl)
      // hmrUrl must be derived the same way as importAnalysis
      const hmrUrl = unwrapId(
        stripBase(
          removeImportQuery(urlWithoutTimestamp),
          environment.config.base,
        ),
      )
      for (const importedMod of mod.importedModules) {
        if (importedMod.url !== hmrUrl) continue
        if (importedMod.lastHMRTimestamp > 0) {
          const replacedUrl = injectQuery(
            urlWithoutTimestamp,
            `t=${importedMod.lastHMRTimestamp}`,
          )
          const start = hasQuotes ? imp.s + 1 : imp.s
          const end = hasQuotes ? imp.e - 1 : imp.e
          s.overwrite(start, end, replacedUrl)
        }

        if (imp.d === -1 && environment.config.dev.preTransformRequests) {
          // pre-transform known direct imports
          environment.warmupRequest(hmrUrl)
        }

        break
      }
    }

    // Update `transformResult` with new code. We don't have to update the sourcemap
    // as the timestamp changes doesn't affect the code lines (stable).
    const code = s.toString()
    result = {
      ...transformResult,
      code,
      etag: getEtag(code, { weak: true }),
    }
  }

  // Only cache the result if the module wasn't invalidated while it was
  // being processed, so it is re-processed next time if it is stale
  if (timestamp > mod.lastInvalidationTimestamp)
    environment.moduleGraph.updateModuleTransformResult(mod, result)

  return result
}



================================================
FILE: packages/vite/src/node/server/warmup.ts
================================================
import fs from 'node:fs/promises'
import path from 'node:path'
import colors from 'picocolors'
import { glob, isDynamicPattern } from 'tinyglobby'
import { FS_PREFIX } from '../constants'
import { normalizePath } from '../utils'
import type { ViteDevServer } from '../index'
import type { DevEnvironment } from './environment'

export function warmupFiles(
  server: ViteDevServer,
  environment: DevEnvironment,
): void {
  const { root } = server.config
  mapFiles(environment.config.dev.warmup, root).then((files) => {
    for (const file of files) {
      warmupFile(server, environment, file)
    }
  })
}

async function warmupFile(
  server: ViteDevServer,
  environment: DevEnvironment,
  file: string,
) {
  // transform html with the `transformIndexHtml` hook as Vite internals would
  // pre-transform the imported JS modules linked. this may cause `transformIndexHtml`
  // plugins to be executed twice, but that's probably fine.
  if (file.endsWith('.html')) {
    const url = htmlFileToUrl(file, server.config.root)
    if (url) {
      try {
        const html = await fs.readFile(file, 'utf-8')
        await server.transformIndexHtml(url, html)
      } catch (e) {
        // Unexpected error, log the issue but avoid an unhandled exception
        environment.logger.error(
          `Pre-transform error (${colors.cyan(file)}): ${e.message}`,
          {
            error: e,
            timestamp: true,
          },
        )
      }
    }
  }
  // for other files, pass it through `transformRequest` with warmup
  else {
    const url = fileToUrl(file, server.config.root)
    await environment.warmupRequest(url)
  }
}

function htmlFileToUrl(file: string, root: string) {
  const url = path.relative(root, file)
  // out of root, ignore file
  if (url[0] === '.') return
  // file within root, create root-relative url
  return '/' + normalizePath(url)
}

function fileToUrl(file: string, root: string) {
  const url = path.relative(root, file)
  // out of root, use /@fs/ prefix
  if (url[0] === '.') {
    return path.posix.join(FS_PREFIX, normalizePath(file))
  }
  // file within root, create root-relative url
  return '/' + normalizePath(url)
}

async function mapFiles(files: string[], root: string) {
  if (!files.length) return []

  const result: string[] = []
  const globs: string[] = []
  for (const file of files) {
    if (isDynamicPattern(file)) {
      globs.push(file)
    } else {
      if (path.isAbsolute(file)) {
        result.push(file)
      } else {
        result.push(path.resolve(root, file))
      }
    }
  }
  if (globs.length) {
    result.push(
      ...(await glob(globs, {
        absolute: true,
        cwd: root,
        expandDirectories: false,
        ignore: ['**/.git/**', '**/node_modules/**'],
      })),
    )
  }
  return result
}



================================================
FILE: packages/vite/src/node/server/ws.ts
================================================
import path from 'node:path'
import type { IncomingMessage, Server } from 'node:http'
import { STATUS_CODES, createServer as createHttpServer } from 'node:http'
import type { ServerOptions as HttpsServerOptions } from 'node:https'
import { createServer as createHttpsServer } from 'node:https'
import type { Socket } from 'node:net'
import type { Duplex } from 'node:stream'
import crypto from 'node:crypto'
import colors from 'picocolors'
import type { WebSocket as WebSocketRaw } from 'ws'
import { WebSocketServer as WebSocketServerRaw_ } from 'ws'
import type { WebSocket as WebSocketTypes } from 'dep-types/ws'
import type { ErrorPayload, HotPayload } from 'types/hmrPayload'
import type { InferCustomEventPayload } from 'types/customEvent'
import { isHostAllowed } from 'host-validation-middleware'
import type { ResolvedConfig } from '..'
import { isObject } from '../utils'
import type { NormalizedHotChannel, NormalizedHotChannelClient } from './hmr'
import { normalizeHotChannel } from './hmr'
import type { HttpServer } from '.'

/* In Bun, the `ws` module is overridden to hook into the native code. Using the bundled `js` version
 * of `ws` will not work as Bun's req.socket does not allow reading/writing to the underlying socket.
 */
const WebSocketServerRaw = process.versions.bun
  ? // @ts-expect-error: Bun defines `import.meta.require`
    import.meta.require('ws').WebSocketServer
  : WebSocketServerRaw_

export const HMR_HEADER = 'vite-hmr'

export type WebSocketCustomListener<T> = (
  data: T,
  client: WebSocketClient,
  invoke?: 'send' | `send:${string}`,
) => void

export const isWebSocketServer = Symbol('isWebSocketServer')

export interface WebSocketServer extends NormalizedHotChannel {
  /**
   * Handle custom event emitted by `import.meta.hot.send`
   */
  on: WebSocketTypes.Server['on'] & {
    <T extends string>(
      event: T,
      listener: WebSocketCustomListener<InferCustomEventPayload<T>>,
    ): void
  }
  /**
   * Unregister event listener.
   */
  off: WebSocketTypes.Server['off'] & {
    (event: string, listener: Function): void
  }
  /**
   * Listen on port and host
   */
  listen(): void
  /**
   * Disconnect all clients and terminate the server.
   */
  close(): Promise<void>

  [isWebSocketServer]: true
  /**
   * Get all connected clients.
   */
  clients: Set<WebSocketClient>
}

export interface WebSocketClient extends NormalizedHotChannelClient {
  /**
   * The raw WebSocket instance
   * @advanced
   */
  socket: WebSocketTypes
}

const wsServerEvents = [
  'connection',
  'error',
  'headers',
  'listening',
  'message',
]

function noop() {
  // noop
}

// we only allow websockets to be connected if it has a valid token
// this is to prevent untrusted origins to connect to the server
// for example, Cross-site WebSocket hijacking
//
// we should check the token before calling wss.handleUpgrade
// otherwise untrusted ws clients will be included in wss.clients
//
// using the query params means the token might be logged out in server or middleware logs
// but we assume that is not an issue since the token is regenerated for each process
function hasValidToken(config: ResolvedConfig, url: URL) {
  const token = url.searchParams.get('token')
  if (!token) return false

  try {
    const isValidToken = crypto.timingSafeEqual(
      Buffer.from(token),
      Buffer.from(config.webSocketToken),
    )
    return isValidToken
  } catch {} // an error is thrown when the length is incorrect
  return false
}

export function createWebSocketServer(
  server: HttpServer | null,
  config: ResolvedConfig,
  httpsOptions?: HttpsServerOptions,
): WebSocketServer {
  if (config.server.ws === false) {
    return {
      [isWebSocketServer]: true,
      get clients() {
        return new Set<WebSocketClient>()
      },
      async close() {
        // noop
      },
      on: noop as any as WebSocketServer['on'],
      off: noop as any as WebSocketServer['off'],
      setInvokeHandler: noop,
      handleInvoke: async () => ({
        error: {
          name: 'TransportError',
          message: 'handleInvoke not implemented',
          stack: new Error().stack,
        },
      }),
      listen: noop,
      send: noop,
    }
  }

  let wsHttpServer: Server | undefined = undefined

  const hmr = isObject(config.server.hmr) && config.server.hmr
  const hmrServer = hmr && hmr.server
  const hmrPort = hmr && hmr.port
  // TODO: the main server port may not have been chosen yet as it may use the next available
  const portsAreCompatible = !hmrPort || hmrPort === config.server.port
  const wsServer = hmrServer || (portsAreCompatible && server)
  let hmrServerWsListener: (
    req: InstanceType<typeof IncomingMessage>,
    socket: Duplex,
    head: Buffer,
  ) => void
  const customListeners = new Map<string, Set<WebSocketCustomListener<any>>>()
  const clientsMap = new WeakMap<WebSocketRaw, WebSocketClient>()
  const port = hmrPort || 24678
  const host = (hmr && hmr.host) || undefined
  const allowedHosts =
    config.server.allowedHosts === true
      ? config.server.allowedHosts
      : Object.freeze([...config.server.allowedHosts]) // Freeze the array to allow caching

  const shouldHandle = (req: IncomingMessage) => {
    const protocol = req.headers['sec-websocket-protocol']!
    // vite-ping is allowed to connect from anywhere
    // because it needs to be connected before the client fetches the new `/@vite/client`
    // this is fine because vite-ping does not receive / send any meaningful data
    if (protocol === 'vite-ping') return true

    if (
      allowedHosts !== true &&
      !isHostAllowed(req.headers.host, allowedHosts)
    ) {
      return false
    }

    if (config.legacy?.skipWebSocketTokenCheck) {
      return true
    }

    // If the Origin header is set, this request might be coming from a browser.
    // Browsers always sets the Origin header for WebSocket connections.
    if (req.headers.origin) {
      const parsedUrl = new URL(`http://example.com${req.url!}`)
      return hasValidToken(config, parsedUrl)
    }

    // We allow non-browser requests to connect without a token
    // for backward compat and convenience
    // This is fine because if you can sent a request without the SOP limitation,
    // you can also send a normal HTTP request to the server.
    return true
  }
  const handleUpgrade = (
    req: IncomingMessage,
    socket: Duplex,
    head: Buffer,
    isPing: boolean,
  ) => {
    wss.handleUpgrade(req, socket as Socket, head, (ws) => {
      // vite-ping is allowed to connect from anywhere
      // we close the connection immediately without connection event
      // so that the client does not get included in `wss.clients`
      if (isPing) {
        ws.close(/* Normal Closure */ 1000)
        return
      }
      wss.emit('connection', ws, req)
    })
  }
  const wss: WebSocketServerRaw_ = new WebSocketServerRaw({ noServer: true })
  wss.shouldHandle = shouldHandle

  if (wsServer) {
    let hmrBase = config.base
    const hmrPath = hmr ? hmr.path : undefined
    if (hmrPath) {
      hmrBase = path.posix.join(hmrBase, hmrPath)
    }
    hmrServerWsListener = (req, socket, head) => {
      const protocol = req.headers['sec-websocket-protocol']!
      const parsedUrl = new URL(`http://example.com${req.url!}`)
      if (
        [HMR_HEADER, 'vite-ping'].includes(protocol) &&
        parsedUrl.pathname === hmrBase
      ) {
        handleUpgrade(req, socket as Socket, head, protocol === 'vite-ping')
      }
    }
    wsServer.on('upgrade', hmrServerWsListener)
  } else {
    // http server request handler keeps the same with
    // https://github.com/websockets/ws/blob/45e17acea791d865df6b255a55182e9c42e5877a/lib/websocket-server.js#L88-L96
    const route = ((_, res) => {
      const statusCode = 426
      const body = STATUS_CODES[statusCode]
      if (!body)
        throw new Error(`No body text found for the ${statusCode} status code`)

      res.writeHead(statusCode, {
        'Content-Length': body.length,
        'Content-Type': 'text/plain',
      })
      res.end(body)
    }) as Parameters<typeof createHttpServer>[1]
    // vite dev server in middleware mode
    // need to call ws listen manually
    if (httpsOptions) {
      wsHttpServer = createHttpsServer(httpsOptions, route)
    } else {
      wsHttpServer = createHttpServer(route)
    }
    wsHttpServer.on('upgrade', (req, socket, head) => {
      const protocol = req.headers['sec-websocket-protocol']!
      if (protocol === 'vite-ping' && server && !server.listening) {
        // reject connection to tell the vite/client that the server is not ready
        // if the http server is not listening
        // because the ws server listens before the http server listens
        req.destroy()
        return
      }
      handleUpgrade(req, socket as Socket, head, protocol === 'vite-ping')
    })
    wsHttpServer.on('error', (e: Error & { code: string; port: number }) => {
      if (e.code === 'EADDRINUSE') {
        config.logger.error(
          colors.red(
            `WebSocket server error: Port ${e.port} is already in use`,
          ),
          { error: e },
        )
      } else {
        config.logger.error(
          colors.red(`WebSocket server error:\n${e.stack || e.message}`),
          { error: e },
        )
      }
    })
  }

  wss.on('connection', (socket) => {
    socket.on('message', (raw) => {
      if (!customListeners.size) return
      let parsed: any
      try {
        parsed = JSON.parse(String(raw))
      } catch {}
      if (!parsed || parsed.type !== 'custom' || !parsed.event) return
      const listeners = customListeners.get(parsed.event)
      if (!listeners?.size) return
      const client = getSocketClient(socket)
      listeners.forEach((listener) =>
        listener(parsed.data, client, parsed.invoke),
      )
    })
    socket.on('error', (err) => {
      config.logger.error(`${colors.red(`ws error:`)}\n${err.stack}`, {
        timestamp: true,
        error: err,
      })
    })
    socket.send(JSON.stringify({ type: 'connected' }))
    if (bufferedError) {
      socket.send(JSON.stringify(bufferedError))
      bufferedError = null
    }
  })

  wss.on('error', (e: Error & { code: string; port: number }) => {
    if (e.code === 'EADDRINUSE') {
      config.logger.error(
        colors.red(`WebSocket server error: Port ${e.port} is already in use`),
        { error: e },
      )
    } else {
      config.logger.error(
        colors.red(`WebSocket server error:\n${e.stack || e.message}`),
        { error: e },
      )
    }
  })

  // Provide a wrapper to the ws client so we can send messages in JSON format
  // To be consistent with server.ws.send
  function getSocketClient(socket: WebSocketRaw) {
    if (!clientsMap.has(socket)) {
      clientsMap.set(socket, {
        send: (...args: any[]) => {
          let payload: HotPayload
          if (typeof args[0] === 'string') {
            payload = {
              type: 'custom',
              event: args[0],
              data: args[1],
            }
          } else {
            payload = args[0]
          }
          socket.send(JSON.stringify(payload))
        },
        socket,
      })
    }
    return clientsMap.get(socket)!
  }

  // On page reloads, if a file fails to compile and returns 500, the server
  // sends the error payload before the client connection is established.
  // If we have no open clients, buffer the error and send it to the next
  // connected client.
  let bufferedError: ErrorPayload | null = null

  const normalizedHotChannel = normalizeHotChannel(
    {
      send(payload) {
        if (payload.type === 'error' && !wss.clients.size) {
          bufferedError = payload
          return
        }

        const stringified = JSON.stringify(payload)
        wss.clients.forEach((client) => {
          // readyState 1 means the connection is open
          if (client.readyState === 1) {
            client.send(stringified)
          }
        })
      },
      on(event: string, fn: any) {
        if (!customListeners.has(event)) {
          customListeners.set(event, new Set())
        }
        customListeners.get(event)!.add(fn)
      },
      off(event: string, fn: any) {
        customListeners.get(event)?.delete(fn)
      },
      listen() {
        wsHttpServer?.listen(port, host)
      },
      close() {
        // should remove listener if hmr.server is set
        // otherwise the old listener swallows all WebSocket connections
        if (hmrServerWsListener && wsServer) {
          wsServer.off('upgrade', hmrServerWsListener)
        }
        return new Promise<void>((resolve, reject) => {
          wss.clients.forEach((client) => {
            client.terminate()
          })
          wss.close((err) => {
            if (err) {
              reject(err)
            } else {
              if (wsHttpServer) {
                wsHttpServer.close((err) => {
                  if (err) {
                    reject(err)
                  } else {
                    resolve()
                  }
                })
              } else {
                resolve()
              }
            }
          })
        })
      },
    },
    config.server.hmr !== false,
    // Don't normalize client as we already handles the send, and to keep `.socket`
    false,
  )
  return {
    ...normalizedHotChannel,

    on: ((event: string, fn: any) => {
      if (wsServerEvents.includes(event)) {
        wss.on(event, fn)
        return
      }
      normalizedHotChannel.on(event, fn)
    }) as WebSocketServer['on'],
    off: ((event: string, fn: any) => {
      if (wsServerEvents.includes(event)) {
        wss.off(event, fn)
        return
      }
      normalizedHotChannel.off(event, fn)
    }) as WebSocketServer['off'],
    async close() {
      await normalizedHotChannel.close()
    },

    [isWebSocketServer]: true,
    get clients() {
      return new Set(Array.from(wss.clients).map(getSocketClient))
    },
  }
}



================================================
FILE: packages/vite/src/node/server/__tests__/moduleGraph.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { EnvironmentModuleGraph } from '../moduleGraph'
import type { ModuleNode } from '../mixedModuleGraph'
import { ModuleGraph } from '../mixedModuleGraph'

describe('moduleGraph', () => {
  describe('invalidateModule', () => {
    it('removes an ssr error', async () => {
      const moduleGraph = new EnvironmentModuleGraph('ssr', async (url) => ({
        id: url,
      }))
      const entryUrl = '/x.js'

      const entryModule = await moduleGraph.ensureEntryFromUrl(entryUrl, false)
      entryModule.ssrError = new Error(`unable to execute module`)

      expect(entryModule.ssrError).to.be.a('error')
      moduleGraph.invalidateModule(entryModule)
      expect(entryModule.ssrError).toBe(null)
    })

    it('ensureEntryFromUrl should based on resolvedId', async () => {
      const moduleGraph = new EnvironmentModuleGraph('client', async (url) => {
        if (url === '/xx.js') {
          return { id: '/x.js' }
        } else {
          return { id: url }
        }
      })
      const meta = { vite: 'test' }

      const mod1 = await moduleGraph.ensureEntryFromUrl('/x.js', false)
      mod1.meta = meta
      const mod2 = await moduleGraph.ensureEntryFromUrl('/xx.js', false)
      expect(mod2.meta).to.equal(meta)
    })

    it('ensure backward compatibility', async () => {
      const clientModuleGraph = new EnvironmentModuleGraph(
        'client',
        async (url) => ({ id: url }),
      )
      const ssrModuleGraph = new EnvironmentModuleGraph('ssr', async (url) => ({
        id: url,
      }))
      const moduleGraph = new ModuleGraph({
        client: () => clientModuleGraph,
        ssr: () => ssrModuleGraph,
      })

      const addBrowserModule = (url: string) =>
        clientModuleGraph.ensureEntryFromUrl(url)
      const getBrowserModule = (url: string) =>
        clientModuleGraph.getModuleById(url)

      const addServerModule = (url: string) =>
        ssrModuleGraph.ensureEntryFromUrl(url)
      const getServerModule = (url: string) => ssrModuleGraph.getModuleById(url)

      const clientModule1 = await addBrowserModule('/1.js')
      const ssrModule1 = await addServerModule('/1.js')
      const module1 = moduleGraph.getModuleById('/1.js')!
      expect(module1._clientModule).toBe(clientModule1)
      expect(module1._ssrModule).toBe(ssrModule1)

      const module2b = await moduleGraph.ensureEntryFromUrl('/b/2.js')
      const module2s = await moduleGraph.ensureEntryFromUrl('/s/2.js')
      expect(module2b._clientModule).toBe(getBrowserModule('/b/2.js'))
      expect(module2s._ssrModule).toBe(getServerModule('/s/2.js'))

      const importersUrls = ['/1/a.js', '/1/b.js', '/1/c.js']
      ;(await Promise.all(importersUrls.map(addBrowserModule))).forEach((mod) =>
        clientModule1.importers.add(mod),
      )
      ;(await Promise.all(importersUrls.map(addServerModule))).forEach((mod) =>
        ssrModule1.importers.add(mod),
      )

      expect(module1.importers.size).toBe(importersUrls.length)

      const clientModule1importersValues = [...clientModule1.importers]
      const ssrModule1importersValues = [...ssrModule1.importers]

      const module1importers = module1.importers
      const module1importersValues = [...module1importers.values()]
      expect(module1importersValues.length).toBe(importersUrls.length)
      expect(module1importersValues[1]._clientModule).toBe(
        clientModule1importersValues[1],
      )
      expect(module1importersValues[1]._ssrModule).toBe(
        ssrModule1importersValues[1],
      )

      const module1importersFromForEach: ModuleNode[] = []
      module1.importers.forEach((imp) => {
        moduleGraph.invalidateModule(imp)
        module1importersFromForEach.push(imp)
      })
      expect(module1importersFromForEach.length).toBe(importersUrls.length)
      expect(module1importersFromForEach[1]._clientModule).toBe(
        clientModule1importersValues[1],
      )
      expect(module1importersFromForEach[1]._ssrModule).toBe(
        ssrModule1importersValues[1],
      )
    })
  })
})



================================================
FILE: packages/vite/src/node/server/__tests__/pluginContainer.spec.ts
================================================
import { stripVTControlCharacters } from 'node:util'
import { describe, expect, it, vi } from 'vitest'
import type { UserConfig } from '../../config'
import { resolveConfig } from '../../config'
import type { Plugin } from '../../plugin'
import { DevEnvironment } from '../environment'
import { createLogger } from '../../logger'

describe('plugin container', () => {
  describe('getModuleInfo', () => {
    it('can pass metadata between hooks', async () => {
      const entryUrl = '/x.js'

      const metaArray: any[] = []
      const plugin: Plugin = {
        name: 'p1',
        resolveId(id) {
          if (id === entryUrl) {
            // The module hasn't been resolved yet, so its info is null.
            const moduleInfo = this.getModuleInfo(entryUrl)
            expect(moduleInfo).toEqual(null)

            return { id, meta: { x: 1 } }
          }
        },
        load(id) {
          if (id === entryUrl) {
            const { meta } = this.getModuleInfo(entryUrl) ?? {}
            metaArray.push(meta)

            return { code: 'export {}', meta: { x: 2 } }
          }
        },
        transform(_code, id) {
          if (id === entryUrl) {
            const { meta } = this.getModuleInfo(entryUrl) ?? {}
            metaArray.push(meta)

            return { meta: { x: 3 } }
          }
        },
        buildEnd() {
          const { meta } = this.getModuleInfo(entryUrl) ?? {}
          metaArray.push(meta)
        },
      }

      const environment = await getDevEnvironment({
        plugins: [plugin],
      })

      const entryModule = await environment.moduleGraph.ensureEntryFromUrl(
        entryUrl,
        false,
      )
      expect(entryModule.meta).toEqual({ x: 1 })

      const loadResult: any = await environment.pluginContainer.load(entryUrl)
      expect(loadResult?.meta).toEqual({ x: 2 })

      await environment.pluginContainer.transform(loadResult.code, entryUrl)
      await environment.pluginContainer.close()

      expect(metaArray).toEqual([{ x: 1 }, { x: 2 }, { x: 3 }])
    })

    it('can pass metadata between plugins', async () => {
      const entryUrl = '/x.js'

      const plugin1: Plugin = {
        name: 'p1',
        resolveId(id) {
          if (id === entryUrl) {
            return { id, meta: { x: 1 } }
          }
        },
      }

      const plugin2: Plugin = {
        name: 'p2',
        load(id) {
          if (id === entryUrl) {
            const { meta } = this.getModuleInfo(entryUrl) ?? {}
            expect(meta).toEqual({ x: 1 })
            return null
          }
        },
      }

      const environment = await getDevEnvironment({
        plugins: [plugin1, plugin2],
      })

      await environment.moduleGraph.ensureEntryFromUrl(entryUrl, false)
      await environment.pluginContainer.load(entryUrl)

      expect.assertions(1)
    })

    it('can pass custom resolve opts between plugins', async () => {
      const entryUrl = '/x.js'

      const plugin1: Plugin = {
        name: 'p1',
        resolveId(id) {
          if (id === entryUrl) {
            return this.resolve('foobar', 'notreal', {
              custom: { p1: 'success' },
              isEntry: true,
            })
          }
        },
      }

      const plugin2: Plugin = {
        name: 'p2',
        resolveId(id, importer, opts) {
          if (id === 'foobar') {
            expect(importer).toBe('notreal')
            expect(opts).toEqual(
              expect.objectContaining({
                custom: { p1: 'success' },
                isEntry: true,
              }),
            )
            return entryUrl
          }
        },
        load(id) {
          if (id === entryUrl) {
            return null
          }
        },
      }

      const environment = await getDevEnvironment({
        plugins: [plugin1, plugin2],
      })

      await environment.moduleGraph.ensureEntryFromUrl(entryUrl, false)
      await environment.pluginContainer.load(entryUrl)

      expect.assertions(2)
    })
  })

  describe('options', () => {
    it('should not throw errors when this.debug is called', async () => {
      const plugin: Plugin = {
        name: 'p1',
        options() {
          this.debug('test')
        },
      }
      await getDevEnvironment({
        plugins: [plugin],
      })
    })

    const logFunctions = ['info', 'warn'] as const
    for (const logFunction of logFunctions) {
      it(`should support this.${logFunction}`, async () => {
        const logger = createLogger()
        const mockedFn = vi
          .spyOn(logger, logFunction)
          .mockImplementation(() => {})
        const plugin: Plugin = {
          name: 'p1',
          options() {
            this[logFunction]('test')
          },
        }
        await getDevEnvironment({
          plugins: [plugin],
          customLogger: logger,
        })
        expect(mockedFn).toHaveBeenCalledOnce()
      })
    }

    it('should support this.error', async () => {
      const plugin: Plugin = {
        name: 'p1',
        options() {
          this.error('test')
        },
      }
      await expect(() =>
        getDevEnvironment({
          plugins: [plugin],
        }),
      ).rejects.toThrowError('test')
    })
  })

  describe('load', () => {
    it('can resolve a secondary module', async () => {
      const entryUrl = '/x.js'

      const plugin: Plugin = {
        name: 'p1',
        resolveId(id) {
          return id
        },
        load(id) {
          if (id === entryUrl) return { code: '1', meta: { x: 1 } }
          else return { code: '2', meta: { x: 2 } }
        },
        async transform(code, id) {
          if (id === entryUrl)
            return {
              code: `${
                (await this.load({ id: '/secondary.js' })).meta.x || undefined
              }`,
            }
          return { code }
        },
      }

      const environment = await getDevEnvironment({
        plugins: [plugin],
      })
      await environment.moduleGraph.ensureEntryFromUrl(entryUrl, false)
      const loadResult: any = await environment.pluginContainer.load(entryUrl)
      const result: any = await environment.pluginContainer.transform(
        loadResult.code,
        entryUrl,
      )
      expect(result.code).equals('2')
    })

    it('will load and transform the module', async () => {
      const entryUrl = '/x.js'
      const otherUrl = '/y.js'

      const plugin: Plugin = {
        name: 'p1',
        resolveId(id) {
          return id
        },
        load(id) {
          if (id === entryUrl) return { code: '1' }
          else if (id === otherUrl) return { code: '2', meta: { code: '2' } }
        },
        async transform(_code, id) {
          if (id === entryUrl) {
            // NOTE: ModuleInfo.code not implemented, used `.meta.code` for now
            return (await this.load({ id: otherUrl }))?.meta.code
          } else if (id === otherUrl) {
            return { code: '3', meta: { code: '3' } }
          }
        },
      }

      const environment = await getDevEnvironment({
        plugins: [plugin],
      })
      await environment.moduleGraph.ensureEntryFromUrl(entryUrl, false)
      const loadResult: any = await environment.pluginContainer.load(entryUrl)
      const result: any = await environment.pluginContainer.transform(
        loadResult.code,
        entryUrl,
      )
      expect(result.code).equals('3')
    })

    it('should not throw errors when this.debug is called', async () => {
      const plugin: Plugin = {
        name: 'p1',
        load() {
          this.debug({ message: 'test', pos: 12 })
        },
      }
      const environment = await getDevEnvironment({
        plugins: [plugin],
      })
      await environment.pluginContainer.load('foo')
    })

    const logFunctions = ['info', 'warn'] as const
    for (const logFunction of logFunctions) {
      it(`should support this.${logFunction}`, async () => {
        const logger = createLogger()
        const mockedFn = vi
          .spyOn(logger, logFunction)
          .mockImplementation(() => {})
        const plugin: Plugin = {
          name: 'p1',
          load() {
            this[logFunction]({ message: 'test', pos: 12 })
          },
        }
        const environment = await getDevEnvironment({
          plugins: [plugin],
          customLogger: logger,
        })
        await environment.pluginContainer.load('foo')
        expect(mockedFn).toHaveBeenCalledOnce()
        expect(stripVTControlCharacters(mockedFn.mock.calls[0][0])).toBe(
          `${logFunction === 'warn' ? 'warning' : logFunction}: test\n` +
            '  Plugin: p1',
        )
      })
    }

    it('should support this.error', async () => {
      const plugin: Plugin = {
        name: 'p1',
        load() {
          this.error({ message: 'test', pos: 12 })
        },
      }
      const environment = await getDevEnvironment({
        plugins: [plugin],
      })
      await expect(() => environment.pluginContainer.load('foo')).rejects
        .toThrowErrorMatchingInlineSnapshot(`
        {
          "message": "test",
          "plugin": "p1",
          "pos": 12,
        }
      `)
    })
  })

  describe('resolveId', () => {
    describe('skipSelf', () => {
      it('should skip the plugin itself when skipSelf is true', async () => {
        let calledCount = 0
        const plugin: Plugin = {
          name: 'p1',
          async resolveId(id, importer) {
            calledCount++
            if (calledCount <= 1) {
              return await this.resolve(id, importer, { skipSelf: true })
            }
            return id
          },
        }

        const environment = await getDevEnvironment({ plugins: [plugin] })
        await environment.pluginContainer.resolveId('/x.js')
        expect(calledCount).toBe(1)
      })

      it('should skip the plugin only when id and importer is same', async () => {
        const p1: Plugin = {
          name: 'p1',
          async resolveId(id, importer) {
            if (id === 'foo/modified') {
              return 'success'
            }
            return await this.resolve(id, importer, { skipSelf: true })
          },
        }
        const p2: Plugin = {
          name: 'p2',
          async resolveId(id, importer) {
            const resolved = await this.resolve(id + '/modified', importer, {
              skipSelf: true,
            })
            return resolved ?? 'failed'
          },
        }

        const environment = await getDevEnvironment({ plugins: [p1, p2] })
        const result = await environment.pluginContainer.resolveId('foo')
        expect(result).toStrictEqual({ id: 'success' })
      })

      it('should skip the plugin if it has been called before with the same id and importer (1)', async () => {
        const p1: Plugin = {
          name: 'p1',
          async resolveId(id, importer) {
            return (
              (await this.resolve(id.replace(/\/modified$/, ''), importer, {
                skipSelf: true,
              })) ?? 'success'
            )
          },
        }
        const p2: Plugin = {
          name: 'p2',
          async resolveId(id, importer) {
            return await this.resolve(id + '/modified', importer, {
              skipSelf: true,
            })
          },
        }
        const environment = await getDevEnvironment({ plugins: [p1, p2] })
        const result = await environment.pluginContainer.resolveId('foo')
        expect(result).toStrictEqual({ id: 'success' })
      })

      it('should skip the plugin if it has been called before with the same id and importer (2)', async () => {
        const p1: Plugin = {
          name: 'p1',
          async resolveId(id, importer) {
            return (
              (await this.resolve(id.replace(/\/modified$/, ''), importer, {
                skipSelf: true,
              })) ?? 'failure1'
            )
          },
        }
        const p2: Plugin = {
          name: 'p2',
          async resolveId(id, importer) {
            return await this.resolve(id + '/modified', importer, {
              skipSelf: true,
            })
          },
        }
        const p3: Plugin = {
          name: 'p3',
          resolveId(id) {
            if (id.endsWith('/modified')) {
              return 'success'
            }
            return 'failure2'
          },
        }
        const environment = await getDevEnvironment({ plugins: [p1, p2, p3] })
        const result = await environment.pluginContainer.resolveId('foo')
        expect(result).toStrictEqual({ id: 'success' })
      })
    })
  })
})

async function getDevEnvironment(
  inlineConfig?: UserConfig,
): Promise<DevEnvironment> {
  const config = await resolveConfig(
    { configFile: false, ...inlineConfig },
    'serve',
  )

  // @ts-expect-error This plugin requires a ViteDevServer instance.
  config.plugins = config.plugins.filter((p) => !p.name.includes('pre-alias'))

  const environment = new DevEnvironment('client', config, { hot: true })
  await environment.init()

  return environment
}



================================================
FILE: packages/vite/src/node/server/__tests__/search-root.spec.ts
================================================
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { searchForWorkspaceRoot } from '../searchRoot'

const __dirname = dirname(fileURLToPath(import.meta.url))

describe('searchForWorkspaceRoot', () => {
  test('lerna', () => {
    const resolved = searchForWorkspaceRoot(
      resolve(__dirname, 'fixtures/lerna/nested'),
    )
    expect(resolved).toBe(resolve(__dirname, 'fixtures/lerna'))
  })

  test('pnpm', () => {
    const resolved = searchForWorkspaceRoot(
      resolve(__dirname, 'fixtures/pnpm/nested'),
    )
    expect(resolved).toBe(resolve(__dirname, 'fixtures/pnpm'))
  })

  test('yarn', () => {
    const resolved = searchForWorkspaceRoot(
      resolve(__dirname, 'fixtures/yarn/nested'),
    )
    expect(resolved).toBe(resolve(__dirname, 'fixtures/yarn'))
  })

  test('yarn at root', () => {
    const resolved = searchForWorkspaceRoot(resolve(__dirname, 'fixtures/yarn'))
    expect(resolved).toBe(resolve(__dirname, 'fixtures/yarn'))
  })

  test('none', () => {
    const resolved = searchForWorkspaceRoot(
      resolve(__dirname, 'fixtures/none/nested'),
    )
    // resolved to vite repo's root
    expect(resolved).toBe(resolve(__dirname, '../../../../../..'))
  })
})



================================================
FILE: packages/vite/src/node/server/__tests__/watcher.spec.ts
================================================
import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { afterEach, describe, expect, it, vi } from 'vitest'
import { type ViteDevServer, createServer } from '../index'

const stubGetWatchedCode = /\(\)\s*\{\s*return this;\s*\}/

describe('watcher configuration', () => {
  let server: ViteDevServer | undefined

  afterEach(async () => {
    if (server) {
      await server.close()
      server = undefined
    }
  })

  it('when watcher is disabled, return noop watcher', async () => {
    server = await createServer({
      server: {
        watch: null,
      },
    })
    expect(server.watcher.add.toString()).toMatch(stubGetWatchedCode)
  })

  it('when watcher is not disabled, return chokidar watcher', async () => {
    server = await createServer({
      server: {
        watch: {},
      },
    })
    expect(server.watcher.add.toString()).not.toMatch(stubGetWatchedCode)
  })

  it('should watch the root directory, config file dependencies, dotenv files, and the public directory', async () => {
    const root = fileURLToPath(
      new URL('./fixtures/watcher/nested-root', import.meta.url),
    )
    server = await createServer({ root })
    await new Promise((resolve) => server!.watcher.once('ready', resolve))
    // Perform retries here as chokidar may still not be completely watching all directories
    // after the `ready` event
    await vi.waitFor(() => {
      const watchedDirs = Object.keys(server!.watcher.getWatched())
      expect(watchedDirs).toEqual(
        expect.arrayContaining([
          root,
          resolve(root, '../config-deps'),
          resolve(root, '../custom-env'),
          resolve(root, '../custom-public'),
        ]),
      )
    })
  })
})



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/lerna/lerna.json
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/lerna/nested/package.json
================================================
{
  "private": true
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/none/nested/package.json
================================================
{
  "private": true
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/pnpm/package.json
================================================
{
  "private": true
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/pnpm/pnpm-workspace.yaml
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/pnpm/nested/package.json
================================================
{
  "private": true
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/watcher/package.json
================================================
{
  "private": true,
  "type": "module"
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/watcher/config-deps/foo.js
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/watcher/custom-public/foo.txt
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/watcher/nested-root/vite.config.js
================================================
import { defineConfig } from 'vite'
import '../config-deps/foo.js'

export default defineConfig({
  envDir: '../custom-env',
  publicDir: '../custom-public',
})



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/yarn/package.json
================================================
{
  "private": true,
  "workspaces": [
    "nested"
  ]
}



================================================
FILE: packages/vite/src/node/server/__tests__/fixtures/yarn/nested/package.json
================================================
{
  "private": true
}



================================================
FILE: packages/vite/src/node/server/environments/fetchableEnvironments.ts
================================================
import type { ResolvedConfig } from '../../config'
import type { DevEnvironmentContext } from '../environment'
import { DevEnvironment } from '../environment'
import type { Environment } from '../../environment'

export interface FetchableDevEnvironmentContext extends DevEnvironmentContext {
  handleRequest(request: Request): Promise<Response> | Response
}

export function createFetchableDevEnvironment(
  name: string,
  config: ResolvedConfig,
  context: FetchableDevEnvironmentContext,
): FetchableDevEnvironment {
  if (typeof Request === 'undefined' || typeof Response === 'undefined') {
    throw new TypeError(
      'FetchableDevEnvironment requires a global `Request` and `Response` object.',
    )
  }

  if (!context.handleRequest) {
    throw new TypeError(
      'FetchableDevEnvironment requires a `handleRequest` method during initialisation.',
    )
  }

  return new FetchableDevEnvironment(name, config, context)
}

export function isFetchableDevEnvironment(
  environment: Environment,
): environment is FetchableDevEnvironment {
  return environment instanceof FetchableDevEnvironment
}

class FetchableDevEnvironment extends DevEnvironment {
  private _handleRequest: (request: Request) => Promise<Response> | Response

  constructor(
    name: string,
    config: ResolvedConfig,
    context: FetchableDevEnvironmentContext,
  ) {
    super(name, config, context)
    this._handleRequest = context.handleRequest
  }

  public async dispatchFetch(request: Request): Promise<Response> {
    if (!(request instanceof Request)) {
      throw new TypeError(
        'FetchableDevEnvironment `dispatchFetch` must receive a `Request` object.',
      )
    }
    const response = await this._handleRequest(request)
    if (!(response instanceof Response)) {
      throw new TypeError(
        'FetchableDevEnvironment `context.handleRequest` must return a `Response` object.',
      )
    }
    return response
  }
}

export type { FetchableDevEnvironment }



================================================
FILE: packages/vite/src/node/server/environments/runnableEnvironment.ts
================================================
import type { ModuleRunner } from 'vite/module-runner'
import type { ResolvedConfig } from '../../config'
import type { DevEnvironmentContext } from '../environment'
import { DevEnvironment } from '../environment'
import type { ServerModuleRunnerOptions } from '../../ssr/runtime/serverModuleRunner'
import { createServerModuleRunner } from '../../ssr/runtime/serverModuleRunner'
import { createServerHotChannel } from '../hmr'
import type { Environment } from '../../environment'

export function createRunnableDevEnvironment(
  name: string,
  config: ResolvedConfig,
  context: RunnableDevEnvironmentContext = {},
): RunnableDevEnvironment {
  if (context.transport == null) {
    context.transport = createServerHotChannel()
  }
  if (context.hot == null) {
    context.hot = true
  }

  return new RunnableDevEnvironment(name, config, context)
}

export interface RunnableDevEnvironmentContext
  extends Omit<DevEnvironmentContext, 'hot'> {
  runner?: (
    environment: RunnableDevEnvironment,
    options?: ServerModuleRunnerOptions,
  ) => ModuleRunner
  runnerOptions?: ServerModuleRunnerOptions
  hot?: boolean
}

export function isRunnableDevEnvironment(
  environment: Environment,
): environment is RunnableDevEnvironment {
  return environment instanceof RunnableDevEnvironment
}

class RunnableDevEnvironment extends DevEnvironment {
  private _runner: ModuleRunner | undefined
  private _runnerFactory:
    | ((
        environment: RunnableDevEnvironment,
        options?: ServerModuleRunnerOptions,
      ) => ModuleRunner)
    | undefined
  private _runnerOptions: ServerModuleRunnerOptions | undefined

  constructor(
    name: string,
    config: ResolvedConfig,
    context: RunnableDevEnvironmentContext,
  ) {
    super(name, config, context as DevEnvironmentContext)
    this._runnerFactory = context.runner
    this._runnerOptions = context.runnerOptions
  }

  get runner(): ModuleRunner {
    if (this._runner) {
      return this._runner
    }
    const factory = this._runnerFactory || createServerModuleRunner
    this._runner = factory(this, this._runnerOptions)
    return this._runner
  }

  override async close(): Promise<void> {
    await super.close()
    if (this._runner) {
      await this._runner.close()
    }
  }
}

export type { RunnableDevEnvironment }



================================================
FILE: packages/vite/src/node/server/middlewares/base.ts
================================================
import type { Connect } from 'dep-types/connect'
import { joinUrlSegments, stripBase } from '../../utils'
import { cleanUrl, withTrailingSlash } from '../../../shared/utils'

// this middleware is only active when (base !== '/')

export function baseMiddleware(
  rawBase: string,
  middlewareMode: boolean,
): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteBaseMiddleware(req, res, next) {
    const url = req.url!
    const pathname = cleanUrl(url)
    const base = rawBase

    if (pathname.startsWith(base)) {
      // rewrite url to remove base. this ensures that other middleware does
      // not need to consider base being prepended or not
      req.url = stripBase(url, base)
      return next()
    }

    // skip redirect and error fallback on middleware mode, #4057
    if (middlewareMode) {
      return next()
    }

    if (pathname === '/' || pathname === '/index.html') {
      // redirect root visit to based url with search and hash
      res.writeHead(302, {
        Location: base + url.slice(pathname.length),
      })
      res.end()
      return
    }

    // non-based page visit
    const redirectPath =
      withTrailingSlash(url) !== base ? joinUrlSegments(base, url) : base
    if (req.headers.accept?.includes('text/html')) {
      res.writeHead(404, {
        'Content-Type': 'text/html',
      })
      res.end(
        `The server is configured with a public base URL of ${base} - ` +
          `did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`,
      )
      return
    } else {
      // not found for resources
      res.writeHead(404, {
        'Content-Type': 'text/plain',
      })
      res.end(
        `The server is configured with a public base URL of ${base} - ` +
          `did you mean to visit ${redirectPath} instead?`,
      )
      return
    }
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/error.ts
================================================
import path from 'node:path'
import { stripVTControlCharacters as strip } from 'node:util'
import colors from 'picocolors'
import type { RollupError } from 'rollup'
import type { Connect } from 'dep-types/connect'
import type { ErrorPayload } from 'types/hmrPayload'
import { pad } from '../../utils'
import type { ViteDevServer } from '../..'
import { CLIENT_PUBLIC_PATH } from '../../constants'

export function prepareError(err: Error | RollupError): ErrorPayload['err'] {
  // only copy the information we need and avoid serializing unnecessary
  // properties, since some errors may attach full objects (e.g. PostCSS)
  return {
    message: strip(err.message),
    stack: strip(cleanStack(err.stack || '')),
    id: (err as RollupError).id,
    frame: strip((err as RollupError).frame || ''),
    plugin: (err as RollupError).plugin,
    pluginCode: (err as RollupError).pluginCode?.toString(),
    loc: (err as RollupError).loc,
  }
}

export function buildErrorMessage(
  err: RollupError,
  args: string[] = [],
  includeStack = true,
): string {
  if (err.plugin) args.push(`  Plugin: ${colors.magenta(err.plugin)}`)
  const loc = err.loc ? `:${err.loc.line}:${err.loc.column}` : ''
  if (err.id) args.push(`  File: ${colors.cyan(err.id)}${loc}`)
  if (err.frame) args.push(colors.yellow(pad(err.frame)))
  if (includeStack && err.stack) args.push(pad(cleanStack(err.stack)))
  return args.join('\n')
}

function cleanStack(stack: string) {
  return stack
    .split(/\n/)
    .filter((l) => /^\s*at/.test(l))
    .join('\n')
}

export function logError(server: ViteDevServer, err: RollupError): void {
  const msg = buildErrorMessage(err, [
    colors.red(`Internal server error: ${err.message}`),
  ])

  server.config.logger.error(msg, {
    clear: true,
    timestamp: true,
    error: err,
  })

  server.environments.client.hot.send({
    type: 'error',
    err: prepareError(err),
  })
}

export function errorMiddleware(
  server: ViteDevServer,
  allowNext = false,
): Connect.ErrorHandleFunction {
  // note the 4 args must be kept for connect to treat this as error middleware
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteErrorMiddleware(err: RollupError, _req, res, next) {
    logError(server, err)

    if (allowNext) {
      next()
    } else {
      res.statusCode = 500
      res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              const error = ${JSON.stringify(prepareError(err)).replace(
                /</g,
                '\\u003c',
              )}
              try {
                const { ErrorOverlay } = await import(${JSON.stringify(path.posix.join(server.config.base, CLIENT_PUBLIC_PATH))})
                document.body.appendChild(new ErrorOverlay(error))
              } catch {
                const h = (tag, text) => {
                  const el = document.createElement(tag)
                  el.textContent = text
                  return el
                }
                document.body.appendChild(h('h1', 'Internal Server Error'))
                document.body.appendChild(h('h2', error.message))
                document.body.appendChild(h('pre', error.stack))
                document.body.appendChild(h('p', '(Error overlay failed to load)'))
              }
            </script>
          </head>
          <body>
          </body>
        </html>
      `)
    }
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/hostCheck.ts
================================================
import type { Connect } from 'dep-types/connect'
import { hostValidationMiddleware as originalHostValidationMiddleware } from 'host-validation-middleware'
import type { ResolvedPreviewOptions, ResolvedServerOptions } from '../..'

export function getAdditionalAllowedHosts(
  resolvedServerOptions: Pick<ResolvedServerOptions, 'host' | 'hmr' | 'origin'>,
  resolvedPreviewOptions: Pick<ResolvedPreviewOptions, 'host'>,
): string[] {
  const list = []

  // allow host option by default as that indicates that the user is
  // expecting Vite to respond on that host
  if (
    typeof resolvedServerOptions.host === 'string' &&
    resolvedServerOptions.host
  ) {
    list.push(resolvedServerOptions.host)
  }
  if (
    typeof resolvedServerOptions.hmr === 'object' &&
    resolvedServerOptions.hmr.host
  ) {
    list.push(resolvedServerOptions.hmr.host)
  }
  if (
    typeof resolvedPreviewOptions.host === 'string' &&
    resolvedPreviewOptions.host
  ) {
    list.push(resolvedPreviewOptions.host)
  }

  // allow server origin by default as that indicates that the user is
  // expecting Vite to respond on that host
  if (resolvedServerOptions.origin) {
    // some frameworks may pass the origin as a placeholder, so it's not
    // possible to parse as URL, so use a try-catch here as a best effort
    try {
      const serverOriginUrl = new URL(resolvedServerOptions.origin)
      list.push(serverOriginUrl.hostname)
    } catch {}
  }

  return list
}

export function hostValidationMiddleware(
  allowedHosts: string[],
  isPreview: boolean,
): Connect.NextHandleFunction {
  return originalHostValidationMiddleware({
    // Freeze the array to allow caching
    allowedHosts: Object.freeze([...allowedHosts]),
    generateErrorMessage(hostname) {
      const hostnameWithQuotes = JSON.stringify(hostname)
      const optionName = `${isPreview ? 'preview' : 'server'}.allowedHosts`
      return (
        `Blocked request. This host (${hostnameWithQuotes}) is not allowed.\n` +
        `To allow this host, add ${hostnameWithQuotes} to \`${optionName}\` in vite.config.js.`
      )
    },
  })
}



================================================
FILE: packages/vite/src/node/server/middlewares/htmlFallback.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import type { Connect } from 'dep-types/connect'
import { createDebugger } from '../../utils'
import { cleanUrl } from '../../../shared/utils'

const debug = createDebugger('vite:html-fallback')

export function htmlFallbackMiddleware(
  root: string,
  spaFallback: boolean,
): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteHtmlFallbackMiddleware(req, _res, next) {
    if (
      // Only accept GET or HEAD
      (req.method !== 'GET' && req.method !== 'HEAD') ||
      // Exclude default favicon requests
      req.url === '/favicon.ico' ||
      // Require Accept: text/html or */*
      !(
        req.headers.accept === undefined || // equivalent to `Accept: */*`
        req.headers.accept === '' || // equivalent to `Accept: */*`
        req.headers.accept.includes('text/html') ||
        req.headers.accept.includes('*/*')
      )
    ) {
      return next()
    }

    const url = cleanUrl(req.url!)
    const pathname = decodeURIComponent(url)

    // .html files are not handled by serveStaticMiddleware
    // so we need to check if the file exists
    if (pathname.endsWith('.html')) {
      const filePath = path.join(root, pathname)
      if (fs.existsSync(filePath)) {
        debug?.(`Rewriting ${req.method} ${req.url} to ${url}`)
        req.url = url
        return next()
      }
    }
    // trailing slash should check for fallback index.html
    else if (pathname.endsWith('/')) {
      const filePath = path.join(root, pathname, 'index.html')
      if (fs.existsSync(filePath)) {
        const newUrl = url + 'index.html'
        debug?.(`Rewriting ${req.method} ${req.url} to ${newUrl}`)
        req.url = newUrl
        return next()
      }
    }
    // non-trailing slash should check for fallback .html
    else {
      const filePath = path.join(root, pathname + '.html')
      if (fs.existsSync(filePath)) {
        const newUrl = url + '.html'
        debug?.(`Rewriting ${req.method} ${req.url} to ${newUrl}`)
        req.url = newUrl
        return next()
      }
    }

    if (spaFallback) {
      debug?.(`Rewriting ${req.method} ${req.url} to /index.html`)
      req.url = '/index.html'
    }

    next()
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/indexHtml.ts
================================================
import fs from 'node:fs'
import fsp from 'node:fs/promises'
import path from 'node:path'
import MagicString from 'magic-string'
import type { SourceMapInput } from 'rollup'
import type { Connect } from 'dep-types/connect'
import type { DefaultTreeAdapterMap, Token } from 'parse5'
import type { IndexHtmlTransformHook } from '../../plugins/html'
import {
  addToHTMLProxyCache,
  applyHtmlTransforms,
  extractImportExpressionFromClassicScript,
  findNeedTransformStyleAttribute,
  getScriptInfo,
  htmlEnvHook,
  htmlProxyResult,
  injectCspNonceMetaTagHook,
  injectNonceAttributeTagHook,
  nodeIsElement,
  overwriteAttrValue,
  postImportMapHook,
  preImportMapHook,
  removeViteIgnoreAttr,
  resolveHtmlTransforms,
  traverseHtml,
} from '../../plugins/html'
import type { PreviewServer, ResolvedConfig, ViteDevServer } from '../..'
import { send } from '../send'
import { CLIENT_PUBLIC_PATH, FS_PREFIX } from '../../constants'
import {
  ensureWatchedFile,
  fsPathFromId,
  getHash,
  injectQuery,
  isCSSRequest,
  isDevServer,
  isJSRequest,
  joinUrlSegments,
  normalizePath,
  processSrcSetSync,
  stripBase,
} from '../../utils'
import { checkPublicFile } from '../../publicDir'
import { getCodeWithSourcemap, injectSourcesContent } from '../sourcemap'
import { cleanUrl, unwrapId, wrapId } from '../../../shared/utils'
import { getNodeAssetAttributes } from '../../assetSource'
import {
  BasicMinimalPluginContext,
  basePluginContextMeta,
} from '../pluginContainer'

interface AssetNode {
  start: number
  end: number
  code: string
}

interface InlineStyleAttribute {
  index: number
  location: Token.Location
  code: string
}

export function createDevHtmlTransformFn(
  config: ResolvedConfig,
): (
  server: ViteDevServer,
  url: string,
  html: string,
  originalUrl?: string,
) => Promise<string> {
  const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(
    config.plugins,
  )
  const transformHooks = [
    preImportMapHook(config),
    injectCspNonceMetaTagHook(config),
    ...preHooks,
    htmlEnvHook(config),
    devHtmlHook,
    ...normalHooks,
    ...postHooks,
    injectNonceAttributeTagHook(config),
    postImportMapHook(),
  ]
  const pluginContext = new BasicMinimalPluginContext(
    { ...basePluginContextMeta, watchMode: true },
    config.logger,
  )
  return (
    server: ViteDevServer,
    url: string,
    html: string,
    originalUrl?: string,
  ): Promise<string> => {
    return applyHtmlTransforms(html, transformHooks, pluginContext, {
      path: url,
      filename: getHtmlFilename(url, server),
      server,
      originalUrl,
    })
  }
}

function getHtmlFilename(url: string, server: ViteDevServer) {
  if (url.startsWith(FS_PREFIX)) {
    return decodeURIComponent(fsPathFromId(url))
  } else {
    return decodeURIComponent(
      normalizePath(path.join(server.config.root, url.slice(1))),
    )
  }
}

function shouldPreTransform(url: string, config: ResolvedConfig) {
  return (
    !checkPublicFile(url, config) && (isJSRequest(url) || isCSSRequest(url))
  )
}

const wordCharRE = /\w/

function isBareRelative(url: string) {
  return wordCharRE.test(url[0]) && !url.includes(':')
}

const processNodeUrl = (
  url: string,
  useSrcSetReplacer: boolean,
  config: ResolvedConfig,
  htmlPath: string,
  originalUrl?: string,
  server?: ViteDevServer,
  isClassicScriptLink?: boolean,
): string => {
  // prefix with base (dev only, base is never relative)
  const replacer = (url: string) => {
    if (
      (url[0] === '/' && url[1] !== '/') ||
      // #3230 if some request url (localhost:3000/a/b) return to fallback html, the relative assets
      // path will add `/a/` prefix, it will caused 404.
      //
      // skip if url contains `:` as it implies a url protocol or Windows path that we don't want to replace.
      //
      // rewrite `./index.js` -> `localhost:5173/a/index.js`.
      // rewrite `../index.js` -> `localhost:5173/index.js`.
      // rewrite `relative/index.js` -> `localhost:5173/a/relative/index.js`.
      ((url[0] === '.' || isBareRelative(url)) &&
        originalUrl &&
        originalUrl !== '/' &&
        htmlPath === '/index.html')
    ) {
      url = path.posix.join(config.base, url)
    }

    let preTransformUrl: string | undefined

    if (!isClassicScriptLink && shouldPreTransform(url, config)) {
      if (url[0] === '/' && url[1] !== '/') {
        preTransformUrl = url
      } else if (url[0] === '.' || isBareRelative(url)) {
        preTransformUrl = path.posix.join(
          config.base,
          path.posix.dirname(htmlPath),
          url,
        )
      }
    }

    if (server) {
      const mod = server.environments.client.moduleGraph.urlToModuleMap.get(
        preTransformUrl || url,
      )
      if (mod && mod.lastHMRTimestamp > 0) {
        url = injectQuery(url, `t=${mod.lastHMRTimestamp}`)
      }
    }

    if (server && preTransformUrl) {
      try {
        preTransformUrl = decodeURI(preTransformUrl)
      } catch {
        // Malformed uri. Skip pre-transform.
        return url
      }
      preTransformRequest(server, preTransformUrl, config.decodedBase)
    }

    return url
  }

  const processedUrl = useSrcSetReplacer
    ? processSrcSetSync(url, ({ url }) => replacer(url))
    : replacer(url)
  return processedUrl
}
const devHtmlHook: IndexHtmlTransformHook = async (
  html,
  { path: htmlPath, filename, server, originalUrl },
) => {
  const { config, watcher } = server!
  const base = config.base || '/'
  const decodedBase = config.decodedBase || '/'

  let proxyModulePath: string
  let proxyModuleUrl: string

  const trailingSlash = htmlPath.endsWith('/')
  if (!trailingSlash && fs.existsSync(filename)) {
    proxyModulePath = htmlPath
    proxyModuleUrl = proxyModulePath
  } else {
    // There are users of vite.transformIndexHtml calling it with url '/'
    // for SSR integrations #7993, filename is root for this case
    // A user may also use a valid name for a virtual html file
    // Mark the path as virtual in both cases so sourcemaps aren't processed
    // and ids are properly handled
    const validPath = `${htmlPath}${trailingSlash ? 'index.html' : ''}`
    proxyModulePath = `\0${validPath}`
    proxyModuleUrl = wrapId(proxyModulePath)
  }
  proxyModuleUrl = joinUrlSegments(decodedBase, proxyModuleUrl)

  const s = new MagicString(html)
  let inlineModuleIndex = -1
  // The key to the proxyHtml cache is decoded, as it will be compared
  // against decoded URLs by the HTML plugins.
  const proxyCacheUrl = decodeURI(
    cleanUrl(proxyModulePath).replace(normalizePath(config.root), ''),
  )
  const styleUrl: AssetNode[] = []
  const inlineStyles: InlineStyleAttribute[] = []
  const inlineModulePaths: string[] = []

  const addInlineModule = (
    node: DefaultTreeAdapterMap['element'],
    ext: 'js',
  ) => {
    inlineModuleIndex++

    const contentNode = node.childNodes[0] as DefaultTreeAdapterMap['textNode']

    const code = contentNode.value

    let map: SourceMapInput | undefined
    if (proxyModulePath[0] !== '\0') {
      map = new MagicString(html)
        .snip(
          contentNode.sourceCodeLocation!.startOffset,
          contentNode.sourceCodeLocation!.endOffset,
        )
        .generateMap({ hires: 'boundary' })
      map.sources = [filename]
      map.file = filename
    }

    // add HTML Proxy to Map
    addToHTMLProxyCache(config, proxyCacheUrl, inlineModuleIndex, { code, map })

    // inline js module. convert to src="proxy" (dev only, base is never relative)
    const modulePath = `${proxyModuleUrl}?html-proxy&index=${inlineModuleIndex}.${ext}`
    inlineModulePaths.push(modulePath)

    s.update(
      node.sourceCodeLocation!.startOffset,
      node.sourceCodeLocation!.endOffset,
      `<script type="module" src="${modulePath}"></script>`,
    )
    preTransformRequest(server!, modulePath, decodedBase)
  }

  await traverseHtml(html, filename, config.logger.warn, (node) => {
    if (!nodeIsElement(node)) {
      return
    }

    // script tags
    if (node.nodeName === 'script') {
      const { src, srcSourceCodeLocation, isModule, isIgnored } =
        getScriptInfo(node)

      if (isIgnored) {
        removeViteIgnoreAttr(s, node.sourceCodeLocation!)
      } else if (src) {
        const processedUrl = processNodeUrl(
          src.value,
          /* useSrcSetReplacer */ false,
          config,
          htmlPath,
          originalUrl,
          server,
          !isModule,
        )
        if (processedUrl !== src.value) {
          overwriteAttrValue(s, srcSourceCodeLocation!, processedUrl)
        }
      } else if (isModule && node.childNodes.length) {
        addInlineModule(node, 'js')
      } else if (node.childNodes.length) {
        const scriptNode = node.childNodes[
          node.childNodes.length - 1
        ] as DefaultTreeAdapterMap['textNode']
        for (const {
          url,
          start,
          end,
        } of extractImportExpressionFromClassicScript(scriptNode)) {
          const processedUrl = processNodeUrl(
            url,
            false,
            config,
            htmlPath,
            originalUrl,
          )
          if (processedUrl !== url) {
            s.update(start, end, processedUrl)
          }
        }
      }
    }

    const inlineStyle = findNeedTransformStyleAttribute(node)
    if (inlineStyle) {
      inlineModuleIndex++
      inlineStyles.push({
        index: inlineModuleIndex,
        location: inlineStyle.location!,
        code: inlineStyle.attr.value,
      })
    }

    if (node.nodeName === 'style' && node.childNodes.length) {
      const children = node.childNodes[0] as DefaultTreeAdapterMap['textNode']
      styleUrl.push({
        start: children.sourceCodeLocation!.startOffset,
        end: children.sourceCodeLocation!.endOffset,
        code: children.value,
      })
    }

    // elements with [href/src] attrs
    const assetAttributes = getNodeAssetAttributes(node)
    for (const attr of assetAttributes) {
      if (attr.type === 'remove') {
        s.remove(attr.location.startOffset, attr.location.endOffset)
      } else {
        const processedUrl = processNodeUrl(
          attr.value,
          attr.type === 'srcset',
          config,
          htmlPath,
          originalUrl,
        )
        if (processedUrl !== attr.value) {
          overwriteAttrValue(s, attr.location, processedUrl)
        }
      }
    }
  })

  // invalidate the module so the newly cached contents will be served
  const clientModuelGraph = server?.environments.client.moduleGraph
  if (clientModuelGraph) {
    await Promise.all(
      inlineModulePaths.map(async (url) => {
        const module = await clientModuelGraph.getModuleByUrl(url)
        if (module) {
          clientModuelGraph.invalidateModule(module)
        }
      }),
    )
  }

  await Promise.all([
    ...styleUrl.map(async ({ start, end, code }, index) => {
      const url = `${proxyModulePath}?html-proxy&direct&index=${index}.css`

      // ensure module in graph after successful load
      const mod =
        await server!.environments.client.moduleGraph.ensureEntryFromUrl(
          url,
          false,
        )
      ensureWatchedFile(watcher, mod.file, config.root)

      const result =
        await server!.environments.client.pluginContainer.transform(
          code,
          mod.id!,
        )
      let content = ''
      if (result.map && 'version' in result.map) {
        if (result.map.mappings) {
          await injectSourcesContent(result.map, proxyModulePath, config.logger)
        }
        content = getCodeWithSourcemap('css', result.code, result.map)
      } else {
        content = result.code
      }
      s.overwrite(start, end, content)
    }),
    ...inlineStyles.map(async ({ index, location, code }) => {
      // will transform with css plugin and cache result with css-post plugin
      const url = `${proxyModulePath}?html-proxy&inline-css&style-attr&index=${index}.css`

      const mod =
        await server!.environments.client.moduleGraph.ensureEntryFromUrl(
          url,
          false,
        )
      ensureWatchedFile(watcher, mod.file, config.root)

      await server?.environments.client.pluginContainer.transform(code, mod.id!)

      const hash = getHash(cleanUrl(mod.id!))
      const result = htmlProxyResult.get(`${hash}_${index}`)
      overwriteAttrValue(s, location, result ?? '')
    }),
  ])

  html = s.toString()

  return {
    html,
    tags: [
      {
        tag: 'script',
        attrs: {
          type: 'module',
          src: path.posix.join(base, CLIENT_PUBLIC_PATH),
        },
        injectTo: 'head-prepend',
      },
    ],
  }
}

export function indexHtmlMiddleware(
  root: string,
  server: ViteDevServer | PreviewServer,
): Connect.NextHandleFunction {
  const isDev = isDevServer(server)

  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return async function viteIndexHtmlMiddleware(req, res, next) {
    if (res.writableEnded) {
      return next()
    }

    const url = req.url && cleanUrl(req.url)
    // htmlFallbackMiddleware appends '.html' to URLs
    if (url?.endsWith('.html') && req.headers['sec-fetch-dest'] !== 'script') {
      let filePath: string
      if (isDev && url.startsWith(FS_PREFIX)) {
        filePath = decodeURIComponent(fsPathFromId(url))
      } else {
        filePath = path.join(root, decodeURIComponent(url))
      }

      if (fs.existsSync(filePath)) {
        const headers = isDev
          ? server.config.server.headers
          : server.config.preview.headers

        try {
          let html = await fsp.readFile(filePath, 'utf-8')
          if (isDev) {
            html = await server.transformIndexHtml(url, html, req.originalUrl)
          }
          return send(req, res, html, 'html', { headers })
        } catch (e) {
          return next(e)
        }
      }
    }
    next()
  }
}

// NOTE: We usually don't prefix `url` and `base` with `decoded`, but in this file particularly
// we're dealing with mixed encoded/decoded paths often, so we make this explicit for now.
function preTransformRequest(
  server: ViteDevServer,
  decodedUrl: string,
  decodedBase: string,
) {
  if (!server.config.server.preTransformRequests) return

  // transform all url as non-ssr as html includes client-side assets only
  decodedUrl = unwrapId(stripBase(decodedUrl, decodedBase))
  server.warmupRequest(decodedUrl)
}



================================================
FILE: packages/vite/src/node/server/middlewares/notFound.ts
================================================
import type { Connect } from 'dep-types/connect'

export function notFoundMiddleware(): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function vite404Middleware(_, res) {
    res.statusCode = 404
    res.end()
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/proxy.ts
================================================
import type * as http from 'node:http'
import * as httpProxy from 'http-proxy-3'
import type { Connect } from 'dep-types/connect'
import colors from 'picocolors'
import { createDebugger } from '../../utils'
import type { CommonServerOptions, ResolvedConfig } from '../..'
import type { HttpServer } from '..'

const debug = createDebugger('vite:proxy')

export interface ProxyOptions extends httpProxy.ServerOptions {
  /**
   * rewrite path
   */
  rewrite?: (path: string) => string
  /**
   * configure the proxy server (e.g. listen to events)
   */
  configure?: (proxy: httpProxy.ProxyServer, options: ProxyOptions) => void
  /**
   * webpack-dev-server style bypass function
   */
  bypass?: (
    req: http.IncomingMessage,
    /** undefined for WebSocket upgrade requests */
    res: http.ServerResponse | undefined,
    options: ProxyOptions,
  ) =>
    | void
    | null
    | undefined
    | false
    | string
    | Promise<void | null | undefined | boolean | string>
  /**
   * rewrite the Origin header of a WebSocket request to match the target
   *
   * **Exercise caution as rewriting the Origin can leave the proxying open to [CSRF attacks](https://owasp.org/www-community/attacks/csrf).**
   */
  rewriteWsOrigin?: boolean | undefined
}

const rewriteOriginHeader = (
  proxyReq: http.ClientRequest,
  options: ProxyOptions,
  config: ResolvedConfig,
) => {
  // Browsers may send Origin headers even with same-origin
  // requests. It is common for WebSocket servers to check the Origin
  // header, so if rewriteWsOrigin is true we change the Origin to match
  // the target URL.
  if (options.rewriteWsOrigin) {
    const { target } = options

    if (proxyReq.headersSent) {
      config.logger.warn(
        colors.yellow(
          `Unable to rewrite Origin header as headers are already sent.`,
        ),
      )
      return
    }

    if (proxyReq.getHeader('origin') && target) {
      const changedOrigin =
        typeof target === 'object'
          ? `${target.protocol ?? 'http:'}//${target.host}`
          : target

      proxyReq.setHeader('origin', changedOrigin)
    }
  }
}

export function proxyMiddleware(
  httpServer: HttpServer | null,
  options: NonNullable<CommonServerOptions['proxy']>,
  config: ResolvedConfig,
): Connect.NextHandleFunction {
  // lazy require only when proxy is used
  const proxies: Record<string, [httpProxy.ProxyServer, ProxyOptions]> = {}

  Object.keys(options).forEach((context) => {
    let opts = options[context]
    if (!opts) {
      return
    }
    if (typeof opts === 'string') {
      opts = { target: opts, changeOrigin: true }
    }
    const proxy = httpProxy.createProxyServer(opts)

    if (opts.configure) {
      opts.configure(proxy, opts)
    }

    proxy.on('error', (err, _req, res) => {
      // When it is ws proxy, res is net.Socket
      if ('req' in res) {
        config.logger.error(
          `${colors.red(`http proxy error: ${res.req.url}`)}\n${err.stack}`,
          {
            timestamp: true,
            error: err,
          },
        )
        if (!res.headersSent && !res.writableEnded) {
          res
            .writeHead(500, {
              'Content-Type': 'text/plain',
            })
            .end()
        }
      } else {
        config.logger.error(`${colors.red(`ws proxy error:`)}\n${err.stack}`, {
          timestamp: true,
          error: err,
        })
        res.end()
      }
    })

    proxy.on('proxyReqWs', (proxyReq, _req, socket, options) => {
      rewriteOriginHeader(proxyReq, options, config)

      socket.on('error', (err) => {
        config.logger.error(
          `${colors.red(`ws proxy socket error:`)}\n${err.stack}`,
          {
            timestamp: true,
            error: err,
          },
        )
      })
    })

    // clone before saving because http-proxy mutates the options
    proxies[context] = [proxy, { ...opts }]
  })

  if (httpServer) {
    httpServer.on('upgrade', async (req, socket, head) => {
      const url = req.url!
      for (const context in proxies) {
        if (doesProxyContextMatchUrl(context, url)) {
          const [proxy, opts] = proxies[context]
          if (
            opts.ws ||
            opts.target?.toString().startsWith('ws:') ||
            opts.target?.toString().startsWith('wss:')
          ) {
            if (opts.bypass) {
              try {
                const bypassResult = await opts.bypass(req, undefined, opts)
                if (typeof bypassResult === 'string') {
                  debug?.(`bypass: ${req.url} -> ${bypassResult}`)
                  req.url = bypassResult
                  return
                }
                if (bypassResult === false) {
                  debug?.(`bypass: ${req.url} -> 404`)
                  socket.end('HTTP/1.1 404 Not Found\r\n\r\n', '')
                  return
                }
              } catch (err) {
                config.logger.error(
                  `${colors.red(`ws proxy bypass error:`)}\n${err.stack}`,
                  {
                    timestamp: true,
                    error: err,
                  },
                )
                return
              }
            }

            if (opts.rewrite) {
              req.url = opts.rewrite(url)
            }
            debug?.(`${req.url} -> ws ${opts.target}`)
            proxy.ws(req, socket, head)
            return
          }
        }
      }
    })
  }

  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return async function viteProxyMiddleware(req, res, next) {
    const url = req.url!
    for (const context in proxies) {
      if (doesProxyContextMatchUrl(context, url)) {
        const [proxy, opts] = proxies[context]
        const options: httpProxy.ServerOptions = {}

        if (opts.bypass) {
          try {
            const bypassResult = await opts.bypass(req, res, opts)
            if (typeof bypassResult === 'string') {
              debug?.(`bypass: ${req.url} -> ${bypassResult}`)
              req.url = bypassResult
              if (res.writableEnded) {
                return
              }
              return next()
            }
            if (bypassResult === false) {
              debug?.(`bypass: ${req.url} -> 404`)
              res.statusCode = 404
              return res.end()
            }
          } catch (e) {
            debug?.(`bypass: ${req.url} -> ${e}`)
            return next(e)
          }
        }

        debug?.(`${req.url} -> ${opts.target || opts.forward}`)
        if (opts.rewrite) {
          req.url = opts.rewrite(req.url!)
        }
        proxy.web(req, res, options)
        return
      }
    }
    next()
  }
}

function doesProxyContextMatchUrl(context: string, url: string): boolean {
  return (
    (context[0] === '^' && new RegExp(context).test(url)) ||
    url.startsWith(context)
  )
}



================================================
FILE: packages/vite/src/node/server/middlewares/rejectInvalidRequest.ts
================================================
import type { Connect } from 'dep-types/connect'

export function rejectInvalidRequestMiddleware(): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteRejectInvalidRequestMiddleware(req, res, next) {
    // HTTP spec does not allow `#` in the request-target
    // (HTTP 1.1: https://datatracker.ietf.org/doc/html/rfc9112#section-3.2)
    // (HTTP 2: https://datatracker.ietf.org/doc/html/rfc9113#section-8.3.1-2.4.1)
    // But Node.js allows those requests.
    // Our middlewares don't expect `#` to be included in `req.url`, especially the `server.fs.deny` checks.
    if (req.url?.includes('#')) {
      // HTTP 1.1 spec recommends sending 400 Bad Request
      // (https://datatracker.ietf.org/doc/html/rfc9112#section-3.2-4)
      res.writeHead(400)
      res.end()
      return
    }
    return next()
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/static.ts
================================================
import path from 'node:path'
import type { OutgoingHttpHeaders, ServerResponse } from 'node:http'
import type { Options } from 'sirv'
import sirv from 'sirv'
import type { Connect } from 'dep-types/connect'
import escapeHtml from 'escape-html'
import type { ViteDevServer } from '../../server'
import type { ResolvedConfig } from '../../config'
import { FS_PREFIX } from '../../constants'
import {
  fsPathFromUrl,
  isFileReadable,
  isImportRequest,
  isInternalRequest,
  isParentDirectory,
  isSameFilePath,
  normalizePath,
  removeLeadingSlash,
  urlRE,
} from '../../utils'
import {
  cleanUrl,
  isWindows,
  slash,
  withTrailingSlash,
} from '../../../shared/utils'

const knownJavascriptExtensionRE = /\.(?:[tj]sx?|[cm][tj]s)$/
const ERR_DENIED_FILE = 'ERR_DENIED_FILE'

const sirvOptions = ({
  config,
  getHeaders,
  disableFsServeCheck,
}: {
  config: ResolvedConfig
  getHeaders: () => OutgoingHttpHeaders | undefined
  disableFsServeCheck?: boolean
}): Options => {
  return {
    dev: true,
    etag: true,
    extensions: [],
    setHeaders(res, pathname) {
      // Matches js, jsx, ts, tsx, mts, mjs, cjs, cts, ctx, mtx
      // The reason this is done, is that the .ts and .mts file extensions are
      // reserved for the MIME type video/mp2t. In almost all cases, we can expect
      // these files to be TypeScript files, and for Vite to serve them with
      // this Content-Type.
      if (knownJavascriptExtensionRE.test(pathname)) {
        res.setHeader('Content-Type', 'text/javascript')
      }
      const headers = getHeaders()
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]!)
        }
      }
    },
    shouldServe: disableFsServeCheck
      ? undefined
      : (filePath) => {
          const servingAccessResult = checkLoadingAccess(config, filePath)
          if (servingAccessResult === 'denied') {
            const error: any = new Error('denied access')
            error.code = ERR_DENIED_FILE
            error.path = filePath
            throw error
          }
          if (servingAccessResult === 'fallback') {
            return false
          }
          servingAccessResult satisfies 'allowed'
          return true
        },
  }
}

export function servePublicMiddleware(
  server: ViteDevServer,
  publicFiles?: Set<string>,
): Connect.NextHandleFunction {
  const dir = server.config.publicDir
  const serve = sirv(
    dir,
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers,
      disableFsServeCheck: true,
    }),
  )

  const toFilePath = (url: string) => {
    let filePath = cleanUrl(url)
    if (filePath.indexOf('%') !== -1) {
      try {
        filePath = decodeURI(filePath)
      } catch {
        /* malform uri */
      }
    }
    return normalizePath(filePath)
  }

  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteServePublicMiddleware(req, res, next) {
    // To avoid the performance impact of `existsSync` on every request, we check against an
    // in-memory set of known public files. This set is updated on restarts.
    // also skip import request and internal requests `/@fs/ /@vite-client` etc...
    if (
      (publicFiles && !publicFiles.has(toFilePath(req.url!))) ||
      isImportRequest(req.url!) ||
      isInternalRequest(req.url!) ||
      // for `/public-file.js?url` to be transformed
      urlRE.test(req.url!)
    ) {
      return next()
    }
    serve(req, res, next)
  }
}

export function serveStaticMiddleware(
  server: ViteDevServer,
): Connect.NextHandleFunction {
  const dir = server.config.root
  const serve = sirv(
    dir,
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers,
    }),
  )

  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteServeStaticMiddleware(req, res, next) {
    // only serve the file if it's not an html request or ends with `/`
    // so that html requests can fallthrough to our html middleware for
    // special processing
    // also skip internal requests `/@fs/ /@vite-client` etc...
    const cleanedUrl = cleanUrl(req.url!)
    if (
      cleanedUrl.endsWith('/') ||
      path.extname(cleanedUrl) === '.html' ||
      isInternalRequest(req.url!) ||
      // skip url starting with // as these will be interpreted as
      // scheme relative URLs by new URL() and will not be a valid file path
      req.url?.startsWith('//')
    ) {
      return next()
    }

    const url = new URL(req.url!, 'http://example.com')
    const pathname = decodeURI(url.pathname)

    // apply aliases to static requests as well
    let redirectedPathname: string | undefined
    for (const { find, replacement } of server.config.resolve.alias) {
      const matches =
        typeof find === 'string'
          ? pathname.startsWith(find)
          : find.test(pathname)
      if (matches) {
        redirectedPathname = pathname.replace(find, replacement)
        break
      }
    }
    if (redirectedPathname) {
      // dir is pre-normalized to posix style
      if (redirectedPathname.startsWith(withTrailingSlash(dir))) {
        redirectedPathname = redirectedPathname.slice(dir.length)
      }
    }

    const resolvedPathname = redirectedPathname || pathname
    let fileUrl = path.resolve(dir, removeLeadingSlash(resolvedPathname))
    if (resolvedPathname.endsWith('/') && fileUrl[fileUrl.length - 1] !== '/') {
      fileUrl = withTrailingSlash(fileUrl)
    }
    if (redirectedPathname) {
      url.pathname = encodeURI(redirectedPathname)
      req.url = url.href.slice(url.origin.length)
    }

    try {
      serve(req, res, next)
    } catch (e) {
      if (e && 'code' in e && e.code === ERR_DENIED_FILE) {
        respondWithAccessDenied(e.path, server, res)
        return
      }
      throw e
    }
  }
}

export function serveRawFsMiddleware(
  server: ViteDevServer,
): Connect.NextHandleFunction {
  const serveFromRoot = sirv(
    '/',
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers,
    }),
  )

  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteServeRawFsMiddleware(req, res, next) {
    // In some cases (e.g. linked monorepos) files outside of root will
    // reference assets that are also out of served root. In such cases
    // the paths are rewritten to `/@fs/` prefixed paths and must be served by
    // searching based from fs root.
    if (req.url!.startsWith(FS_PREFIX)) {
      const url = new URL(req.url!, 'http://example.com')
      const pathname = decodeURI(url.pathname)
      let newPathname = pathname.slice(FS_PREFIX.length)
      if (isWindows) newPathname = newPathname.replace(/^[A-Z]:/i, '')
      url.pathname = encodeURI(newPathname)
      req.url = url.href.slice(url.origin.length)

      try {
        serveFromRoot(req, res, next)
      } catch (e) {
        if (e && 'code' in e && e.code === ERR_DENIED_FILE) {
          respondWithAccessDenied(e.path, server, res)
          return
        }
        throw e
      }
    } else {
      next()
    }
  }
}

/**
 * Check if the url is allowed to be served, via the `server.fs` config.
 * @deprecated Use the `isFileLoadingAllowed` function instead.
 */
export function isFileServingAllowed(
  config: ResolvedConfig,
  url: string,
): boolean
export function isFileServingAllowed(
  url: string,
  server: ViteDevServer,
): boolean
export function isFileServingAllowed(
  configOrUrl: ResolvedConfig | string,
  urlOrServer: string | ViteDevServer,
): boolean {
  const config = (
    typeof urlOrServer === 'string' ? configOrUrl : urlOrServer.config
  ) as ResolvedConfig
  const url = (
    typeof urlOrServer === 'string' ? urlOrServer : configOrUrl
  ) as string

  if (!config.server.fs.strict) return true
  const filePath = fsPathFromUrl(url)
  return isFileLoadingAllowed(config, filePath)
}

/**
 * Warning: parameters are not validated, only works with normalized absolute paths
 *
 * @param targetPath - normalized absolute path
 * @param filePath - normalized absolute path
 */
function isFileInTargetPath(targetPath: string, filePath: string) {
  return (
    isSameFilePath(targetPath, filePath) ||
    isParentDirectory(targetPath, filePath)
  )
}

/**
 * Warning: parameters are not validated, only works with normalized absolute paths
 */
export function isFileLoadingAllowed(
  config: ResolvedConfig,
  filePath: string,
): boolean {
  const { fs } = config.server

  if (!fs.strict) return true

  if (config.fsDenyGlob(filePath)) return false

  if (config.safeModulePaths.has(filePath)) return true

  if (fs.allow.some((uri) => isFileInTargetPath(uri, filePath))) return true

  return false
}

export function checkLoadingAccess(
  config: ResolvedConfig,
  path: string,
): 'allowed' | 'denied' | 'fallback' {
  if (isFileLoadingAllowed(config, slash(path))) {
    return 'allowed'
  }
  if (isFileReadable(path)) {
    return 'denied'
  }
  // if the file doesn't exist, we shouldn't restrict this path as it can
  // be an API call. Middlewares would issue a 404 if the file isn't handled
  return 'fallback'
}

export function respondWithAccessDenied(
  id: string,
  server: ViteDevServer,
  res: ServerResponse,
): void {
  const urlMessage = `The request id "${id}" is outside of Vite serving allow list.`
  const hintMessage = `
${server.config.server.fs.allow.map((i) => `- ${i}`).join('\n')}

Refer to docs https://vite.dev/config/server-options.html#server-fs-allow for configurations and more details.`

  server.config.logger.error(urlMessage)
  server.config.logger.warnOnce(hintMessage + '\n')
  res.statusCode = 403
  res.write(renderRestrictedErrorHTML(urlMessage + '\n' + hintMessage))
  res.end()
}

function renderRestrictedErrorHTML(msg: string): string {
  // to have syntax highlighting and autocompletion in IDE
  const html = String.raw
  return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${escapeHtml(msg).replace(/\n/g, '<br/>')}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `
}



================================================
FILE: packages/vite/src/node/server/middlewares/time.ts
================================================
import { performance } from 'node:perf_hooks'
import type { Connect } from 'dep-types/connect'
import { createDebugger, prettifyUrl, timeFrom } from '../../utils'

const logTime = createDebugger('vite:time')

export function timeMiddleware(root: string): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteTimeMiddleware(req, res, next) {
    const start = performance.now()
    const end = res.end
    res.end = (...args: readonly [any, any?, any?]) => {
      logTime?.(`${timeFrom(start)} ${prettifyUrl(req.url!, root)}`)
      return end.call(res, ...args)
    }
    next()
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/transform.ts
================================================
import path from 'node:path'
import fsp from 'node:fs/promises'
import type { Connect } from 'dep-types/connect'
import colors from 'picocolors'
import type { ExistingRawSourceMap } from 'rollup'
import type { ViteDevServer } from '..'
import {
  createDebugger,
  fsPathFromId,
  injectQuery,
  isCSSRequest,
  isImportRequest,
  isJSRequest,
  normalizePath,
  prettifyUrl,
  removeImportQuery,
  removeTimestampQuery,
} from '../../utils'
import { send } from '../send'
import { ERR_DENIED_ID, ERR_LOAD_URL } from '../transformRequest'
import { applySourcemapIgnoreList } from '../sourcemap'
import { isHTMLProxy } from '../../plugins/html'
import {
  DEP_VERSION_RE,
  ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR,
  ERR_OPTIMIZE_DEPS_PROCESSING_ERROR,
  FS_PREFIX,
} from '../../constants'
import { isDirectCSSRequest, isDirectRequest } from '../../plugins/css'
import { ERR_CLOSED_SERVER } from '../pluginContainer'
import { cleanUrl, unwrapId, withTrailingSlash } from '../../../shared/utils'
import {
  ERR_OUTDATED_OPTIMIZED_DEP,
  NULL_BYTE_PLACEHOLDER,
} from '../../../shared/constants'
import type { ResolvedConfig } from '../../config'
import { checkLoadingAccess, respondWithAccessDenied } from './static'

const debugCache = createDebugger('vite:cache')

const knownIgnoreList = new Set(['/', '/favicon.ico'])

// TODO: consolidate this regex pattern with the url, raw, and inline checks in plugins
const urlRE = /[?&]url\b/
const rawRE = /[?&]raw\b/
const inlineRE = /[?&]inline\b/
const svgRE = /\.svg\b/

function isServerAccessDeniedForTransform(config: ResolvedConfig, id: string) {
  if (rawRE.test(id) || urlRE.test(id) || inlineRE.test(id) || svgRE.test(id)) {
    return checkLoadingAccess(config, id) !== 'allowed'
  }
  return false
}

/**
 * A middleware that short-circuits the middleware chain to serve cached transformed modules
 */
export function cachedTransformMiddleware(
  server: ViteDevServer,
): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteCachedTransformMiddleware(req, res, next) {
    const environment = server.environments.client

    // check if we can return 304 early
    const ifNoneMatch = req.headers['if-none-match']
    if (ifNoneMatch) {
      const moduleByEtag = environment.moduleGraph.getModuleByEtag(ifNoneMatch)
      if (
        moduleByEtag?.transformResult?.etag === ifNoneMatch &&
        moduleByEtag.url === req.url
      ) {
        // For CSS requests, if the same CSS file is imported in a module,
        // the browser sends the request for the direct CSS request with the etag
        // from the imported CSS module. We ignore the etag in this case.
        const maybeMixedEtag = isCSSRequest(req.url!)
        if (!maybeMixedEtag) {
          debugCache?.(`[304] ${prettifyUrl(req.url!, server.config.root)}`)
          res.statusCode = 304
          return res.end()
        }
      }
    }

    next()
  }
}

export function transformMiddleware(
  server: ViteDevServer,
): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`

  // check if public dir is inside root dir
  const { root, publicDir } = server.config
  const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root))
  const publicPath = `${publicDir.slice(root.length)}/`

  return async function viteTransformMiddleware(req, res, next) {
    const environment = server.environments.client

    if (
      (req.method !== 'GET' && req.method !== 'HEAD') ||
      knownIgnoreList.has(req.url!)
    ) {
      return next()
    }

    let url: string
    try {
      url = decodeURI(removeTimestampQuery(req.url!)).replace(
        NULL_BYTE_PLACEHOLDER,
        '\0',
      )
    } catch (e) {
      if (e instanceof URIError) {
        server.config.logger.warn(
          colors.yellow('Malformed URI sequence in request URL'),
        )
        return next()
      }
      return next(e)
    }

    const withoutQuery = cleanUrl(url)

    try {
      const isSourceMap = withoutQuery.endsWith('.map')
      // since we generate source map references, handle those requests here
      if (isSourceMap) {
        const depsOptimizer = environment.depsOptimizer
        if (depsOptimizer?.isOptimizedDepUrl(url)) {
          // If the browser is requesting a source map for an optimized dep, it
          // means that the dependency has already been pre-bundled and loaded
          const sourcemapPath = url.startsWith(FS_PREFIX)
            ? fsPathFromId(url)
            : normalizePath(path.resolve(server.config.root, url.slice(1)))
          try {
            const map = JSON.parse(
              await fsp.readFile(sourcemapPath, 'utf-8'),
            ) as ExistingRawSourceMap

            applySourcemapIgnoreList(
              map,
              sourcemapPath,
              server.config.server.sourcemapIgnoreList,
              server.config.logger,
            )

            return send(req, res, JSON.stringify(map), 'json', {
              headers: server.config.server.headers,
            })
          } catch {
            // Outdated source map request for optimized deps, this isn't an error
            // but part of the normal flow when re-optimizing after missing deps
            // Send back an empty source map so the browser doesn't issue warnings
            const dummySourceMap = {
              version: 3,
              file: sourcemapPath.replace(/\.map$/, ''),
              sources: [],
              sourcesContent: [],
              names: [],
              mappings: ';;;;;;;;;',
            }
            return send(req, res, JSON.stringify(dummySourceMap), 'json', {
              cacheControl: 'no-cache',
              headers: server.config.server.headers,
            })
          }
        } else {
          const originalUrl = url.replace(/\.map($|\?)/, '$1')
          const map = (
            await environment.moduleGraph.getModuleByUrl(originalUrl)
          )?.transformResult?.map
          if (map) {
            return send(req, res, JSON.stringify(map), 'json', {
              headers: server.config.server.headers,
            })
          } else {
            return next()
          }
        }
      }

      if (publicDirInRoot && url.startsWith(publicPath)) {
        warnAboutExplicitPublicPathInUrl(url)
      }

      if (
        req.headers['sec-fetch-dest'] === 'script' ||
        isJSRequest(url) ||
        isImportRequest(url) ||
        isCSSRequest(url) ||
        isHTMLProxy(url)
      ) {
        // strip ?import
        url = removeImportQuery(url)
        // Strip valid id prefix. This is prepended to resolved Ids that are
        // not valid browser import specifiers by the importAnalysis plugin.
        url = unwrapId(url)

        // for CSS, we differentiate between normal CSS requests and imports
        if (isCSSRequest(url)) {
          if (
            req.headers.accept?.includes('text/css') &&
            !isDirectRequest(url)
          ) {
            url = injectQuery(url, 'direct')
          }

          // check if we can return 304 early for CSS requests. These aren't handled
          // by the cachedTransformMiddleware due to the browser possibly mixing the
          // etags of direct and imported CSS
          const ifNoneMatch = req.headers['if-none-match']
          if (
            ifNoneMatch &&
            (await environment.moduleGraph.getModuleByUrl(url))?.transformResult
              ?.etag === ifNoneMatch
          ) {
            debugCache?.(`[304] ${prettifyUrl(url, server.config.root)}`)
            res.statusCode = 304
            return res.end()
          }
        }

        // resolve, load and transform using the plugin container
        const result = await environment.transformRequest(url, {
          allowId(id) {
            return (
              id.startsWith('\0') ||
              !isServerAccessDeniedForTransform(server.config, id)
            )
          },
        })
        if (result) {
          const depsOptimizer = environment.depsOptimizer
          const type = isDirectCSSRequest(url) ? 'css' : 'js'
          const isDep =
            DEP_VERSION_RE.test(url) || depsOptimizer?.isOptimizedDepUrl(url)
          return send(req, res, result.code, type, {
            etag: result.etag,
            // allow browser to cache npm deps!
            cacheControl: isDep ? 'max-age=31536000,immutable' : 'no-cache',
            headers: server.config.server.headers,
            map: result.map,
          })
        }
      }
    } catch (e) {
      if (e?.code === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 504 // status code request timeout
          res.statusMessage = 'Optimize Deps Processing Error'
          res.end()
        }
        // This timeout is unexpected
        server.config.logger.error(e.message)
        return
      }
      if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 504 // status code request timeout
          res.statusMessage = 'Outdated Optimize Dep'
          res.end()
        }
        // We don't need to log an error in this case, the request
        // is outdated because new dependencies were discovered and
        // the new pre-bundle dependencies have changed.
        // A full-page reload has been issued, and these old requests
        // can't be properly fulfilled. This isn't an unexpected
        // error but a normal part of the missing deps discovery flow
        return
      }
      if (e?.code === ERR_CLOSED_SERVER) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 504 // status code request timeout
          res.statusMessage = 'Outdated Request'
          res.end()
        }
        // We don't need to log an error in this case, the request
        // is outdated because new dependencies were discovered and
        // the new pre-bundle dependencies have changed.
        // A full-page reload has been issued, and these old requests
        // can't be properly fulfilled. This isn't an unexpected
        // error but a normal part of the missing deps discovery flow
        return
      }
      if (e?.code === ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 404
          res.end()
        }
        server.config.logger.warn(colors.yellow(e.message))
        return
      }
      if (e?.code === ERR_LOAD_URL) {
        // Let other middleware handle if we can't load the url via transformRequest
        return next()
      }
      if (e?.code === ERR_DENIED_ID) {
        const id: string = e.id
        const servingAccessResult = checkLoadingAccess(server.config, id)
        if (servingAccessResult === 'denied') {
          respondWithAccessDenied(id, server, res)
          return true
        }
        if (servingAccessResult === 'fallback') {
          next()
          return true
        }
        servingAccessResult satisfies 'allowed'
        throw new Error(`Unexpected access result for id ${id}`)
      }
      return next(e)
    }

    next()
  }

  function warnAboutExplicitPublicPathInUrl(url: string) {
    let warning: string

    if (isImportRequest(url)) {
      const rawUrl = removeImportQuery(url)
      if (urlRE.test(url)) {
        warning =
          `Assets in the public directory are served at the root path.\n` +
          `Instead of ${colors.cyan(rawUrl)}, use ${colors.cyan(
            rawUrl.replace(publicPath, '/'),
          )}.`
      } else {
        warning =
          'Assets in public directory cannot be imported from JavaScript.\n' +
          `If you intend to import that asset, put the file in the src directory, and use ${colors.cyan(
            rawUrl.replace(publicPath, '/src/'),
          )} instead of ${colors.cyan(rawUrl)}.\n` +
          `If you intend to use the URL of that asset, use ${colors.cyan(
            injectQuery(rawUrl.replace(publicPath, '/'), 'url'),
          )}.`
      }
    } else {
      warning =
        `Files in the public directory are served at the root path.\n` +
        `Instead of ${colors.cyan(url)}, use ${colors.cyan(
          url.replace(publicPath, '/'),
        )}.`
    }

    server.config.logger.warn(colors.yellow(warning))
  }
}



================================================
FILE: packages/vite/src/node/server/middlewares/__tests__/hostCheck.spec.ts
================================================
import { expect, test } from 'vitest'
import { getAdditionalAllowedHosts } from '../hostCheck'

test('getAdditionalAllowedHosts', async () => {
  const actual = getAdditionalAllowedHosts(
    {
      host: 'vite.host.example.com',
      hmr: {
        host: 'vite.hmr-host.example.com',
      },
      origin: 'http://vite.origin.example.com:5173',
    },
    {
      host: 'vite.preview-host.example.com',
    },
  ).sort()
  expect(actual).toStrictEqual(
    [
      'vite.host.example.com',
      'vite.hmr-host.example.com',
      'vite.origin.example.com',
      'vite.preview-host.example.com',
    ].sort(),
  )
})



================================================
FILE: packages/vite/src/node/ssr/fetchModule.ts
================================================
import { pathToFileURL } from 'node:url'
import type { FetchResult } from 'vite/module-runner'
import type { EnvironmentModuleNode, TransformResult } from '..'
import { tryNodeResolve } from '../plugins/resolve'
import { isBuiltin, isExternalUrl, isFilePathESM } from '../utils'
import { unwrapId } from '../../shared/utils'
import {
  MODULE_RUNNER_SOURCEMAPPING_SOURCE,
  SOURCEMAPPING_URL,
} from '../../shared/constants'
import { genSourceMapUrl } from '../server/sourcemap'
import type { DevEnvironment } from '../server/environment'

export interface FetchModuleOptions {
  cached?: boolean
  inlineSourceMap?: boolean
  startOffset?: number
}

/**
 * Fetch module information for Vite runner.
 * @experimental
 */
export async function fetchModule(
  environment: DevEnvironment,
  url: string,
  importer?: string,
  options: FetchModuleOptions = {},
): Promise<FetchResult> {
  if (
    url.startsWith('data:') ||
    isBuiltin(environment.config.resolve.builtins, url)
  ) {
    return { externalize: url, type: 'builtin' }
  }

  // handle file urls from not statically analyzable dynamic import
  const isFileUrl = url.startsWith('file://')

  if (isExternalUrl(url) && !isFileUrl) {
    return { externalize: url, type: 'network' }
  }

  // if there is no importer, the file is an entry point
  // entry points are always internalized
  if (!isFileUrl && importer && url[0] !== '.' && url[0] !== '/') {
    const { isProduction, root } = environment.config
    const { externalConditions, dedupe, preserveSymlinks } =
      environment.config.resolve

    const resolved = tryNodeResolve(url, importer, {
      mainFields: ['main'],
      conditions: externalConditions,
      externalConditions,
      external: [],
      noExternal: [],
      extensions: ['.js', '.cjs', '.json'],
      dedupe,
      preserveSymlinks,
      isBuild: false,
      isProduction,
      root,
      packageCache: environment.config.packageCache,
      builtins: environment.config.resolve.builtins,
    })
    if (!resolved) {
      const err: any = new Error(
        `Cannot find module '${url}' imported from '${importer}'`,
      )
      err.code = 'ERR_MODULE_NOT_FOUND'
      throw err
    }
    const file = pathToFileURL(resolved.id).toString()
    const type = isFilePathESM(resolved.id, environment.config.packageCache)
      ? 'module'
      : 'commonjs'
    return { externalize: file, type }
  }

  url = unwrapId(url)

  const mod = await environment.moduleGraph.ensureEntryFromUrl(url)
  const cached = !!mod.transformResult

  // if url is already cached, we can just confirm it's also cached on the server
  if (options.cached && cached) {
    return { cache: true }
  }

  let result = await environment.transformRequest(url)

  if (!result) {
    throw new Error(
      `[vite] transform failed for module '${url}'${
        importer ? ` imported from '${importer}'` : ''
      }.`,
    )
  }

  if (options.inlineSourceMap !== false) {
    result = inlineSourceMap(mod, result, options.startOffset)
  }

  // remove shebang
  if (result.code[0] === '#')
    result.code = result.code.replace(/^#!.*/, (s) => ' '.repeat(s.length))

  return {
    code: result.code,
    file: mod.file,
    id: mod.id!,
    url: mod.url,
    invalidate: !cached,
  }
}

const OTHER_SOURCE_MAP_REGEXP = new RegExp(
  `//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`,
  'gm',
)

function inlineSourceMap(
  mod: EnvironmentModuleNode,
  result: TransformResult,
  startOffset: number | undefined,
) {
  const map = result.map
  let code = result.code

  if (
    !map ||
    !('version' in map) ||
    code.includes(MODULE_RUNNER_SOURCEMAPPING_SOURCE)
  )
    return result

  // to reduce the payload size, we only inline vite node source map, because it's also the only one we use
  OTHER_SOURCE_MAP_REGEXP.lastIndex = 0
  if (OTHER_SOURCE_MAP_REGEXP.test(code))
    code = code.replace(OTHER_SOURCE_MAP_REGEXP, '')

  const sourceMap = startOffset
    ? Object.assign({}, map, {
        mappings: ';'.repeat(startOffset) + map.mappings,
      })
    : map
  result.code = `${code.trimEnd()}\n//# sourceURL=${
    mod.id
  }\n${MODULE_RUNNER_SOURCEMAPPING_SOURCE}\n//# ${SOURCEMAPPING_URL}=${genSourceMapUrl(sourceMap)}\n`

  return result
}



================================================
FILE: packages/vite/src/node/ssr/index.ts
================================================
import type { DepOptimizationConfig } from '../optimizer'
import { mergeWithDefaults } from '../utils'

export type SSRTarget = 'node' | 'webworker'

export type SsrDepOptimizationConfig = DepOptimizationConfig

export interface SSROptions {
  noExternal?: string | RegExp | (string | RegExp)[] | true
  external?: string[] | true

  /**
   * Define the target for the ssr build. The browser field in package.json
   * is ignored for node but used if webworker is the target
   * This option will be removed in a future major version
   * @default 'node'
   */
  target?: SSRTarget

  /**
   * Control over which dependencies are optimized during SSR and esbuild options
   * During build:
   *   no external CJS dependencies are optimized by default
   * During dev:
   *   explicit no external CJS dependencies are optimized by default
   * @experimental
   */
  optimizeDeps?: SsrDepOptimizationConfig

  resolve?: {
    /**
     * Conditions that are used in the plugin pipeline. The default value is the root config's `resolve.conditions`.
     *
     * Use this to override the default ssr conditions for the ssr build.
     *
     * @default rootConfig.resolve.conditions
     */
    conditions?: string[]

    /**
     * Conditions that are used during ssr import (including `ssrLoadModule`) of externalized dependencies.
     *
     * @default ['node', 'module-sync']
     */
    externalConditions?: string[]

    mainFields?: string[]
  }
}

export interface ResolvedSSROptions extends SSROptions {
  target: SSRTarget
  optimizeDeps: SsrDepOptimizationConfig
}

export const ssrConfigDefaults = Object.freeze({
  // noExternal
  // external
  target: 'node',
  optimizeDeps: {},
  // resolve
} satisfies SSROptions)

export function resolveSSROptions(
  ssr: SSROptions | undefined,
  preserveSymlinks: boolean,
): ResolvedSSROptions {
  const defaults = mergeWithDefaults(ssrConfigDefaults, {
    optimizeDeps: { esbuildOptions: { preserveSymlinks } },
  } satisfies SSROptions)
  return mergeWithDefaults(defaults, ssr ?? {})
}



================================================
FILE: packages/vite/src/node/ssr/runnerImport.ts
================================================
import type { InlineConfig } from '../config'
import { resolveConfig } from '../config'
import { createRunnableDevEnvironment } from '../server/environments/runnableEnvironment'
import { mergeConfig } from '../utils'

interface RunnerImportResult<T> {
  module: T
  dependencies: string[]
}

/**
 * Import any file using the default Vite environment.
 * @experimental
 */
export async function runnerImport<T>(
  moduleId: string,
  inlineConfig?: InlineConfig,
): Promise<RunnerImportResult<T>> {
  const isModuleSyncConditionEnabled = (await import('#module-sync-enabled'))
    .default
  const config = await resolveConfig(
    mergeConfig(inlineConfig || {}, {
      configFile: false,
      envDir: false,
      cacheDir: process.cwd(),
      environments: {
        inline: {
          consumer: 'server',
          dev: {
            moduleRunnerTransform: true,
          },
          resolve: {
            external: true,
            mainFields: [],
            conditions: [
              'node',
              ...(isModuleSyncConditionEnabled ? ['module-sync'] : []),
            ],
          },
        },
      },
    } satisfies InlineConfig),
    'serve',
  )
  const environment = createRunnableDevEnvironment('inline', config, {
    runnerOptions: {
      hmr: {
        logger: false,
      },
    },
    hot: false,
  })
  await environment.init()
  try {
    const module = await environment.runner.import(moduleId)
    const modules = [
      ...environment.runner.evaluatedModules.urlToIdModuleMap.values(),
    ]
    const dependencies = modules
      .filter((m) => {
        // ignore all externalized modules
        if (!m.meta || 'externalize' in m.meta) {
          return false
        }
        // ignore the current module
        return m.exports !== module
      })
      .map((m) => m.file)
    return {
      module,
      dependencies,
    }
  } finally {
    await environment.close()
  }
}



================================================
FILE: packages/vite/src/node/ssr/ssrManifestPlugin.ts
================================================
import { basename, dirname, join, relative } from 'node:path'
import { parse as parseImports } from 'es-module-lexer'
import type {
  ParseError as EsModuleLexerParseError,
  ImportSpecifier,
} from 'es-module-lexer'
import type { OutputChunk } from 'rollup'
import type { Plugin } from '../plugin'
import { preloadMethod } from '../plugins/importAnalysisBuild'
import {
  generateCodeFrame,
  joinUrlSegments,
  normalizePath,
  numberToPos,
  sortObjectKeys,
} from '../utils'
import { perEnvironmentState } from '../environment'

export function ssrManifestPlugin(): Plugin {
  // module id => preload assets mapping
  const getSsrManifest = perEnvironmentState(() => {
    return {} as Record<string, string[]>
  })

  return {
    name: 'vite:ssr-manifest',

    applyToEnvironment(environment) {
      return !!environment.config.build.ssrManifest
    },

    generateBundle(_options, bundle) {
      const config = this.environment.config
      const ssrManifest = getSsrManifest(this)
      const { base } = config
      for (const file in bundle) {
        const chunk = bundle[file]
        if (chunk.type === 'chunk') {
          for (const id in chunk.modules) {
            const normalizedId = normalizePath(relative(config.root, id))
            const mappedChunks =
              ssrManifest[normalizedId] ?? (ssrManifest[normalizedId] = [])
            if (!chunk.isEntry) {
              mappedChunks.push(joinUrlSegments(base, chunk.fileName))
              // <link> tags for entry chunks are already generated in static HTML,
              // so we only need to record info for non-entry chunks.
              chunk.viteMetadata!.importedCss.forEach((file) => {
                mappedChunks.push(joinUrlSegments(base, file))
              })
            }
            chunk.viteMetadata!.importedAssets.forEach((file) => {
              mappedChunks.push(joinUrlSegments(base, file))
            })
          }
          if (chunk.code.includes(preloadMethod)) {
            // generate css deps map
            const code = chunk.code
            let imports: ImportSpecifier[] = []
            try {
              imports = parseImports(code)[0].filter((i) => i.n && i.d > -1)
            } catch (_e: unknown) {
              const e = _e as EsModuleLexerParseError
              const loc = numberToPos(code, e.idx)
              this.error({
                name: e.name,
                message: e.message,
                stack: e.stack,
                cause: e.cause,
                pos: e.idx,
                loc: { ...loc, file: chunk.fileName },
                frame: generateCodeFrame(code, loc),
              })
            }
            if (imports.length) {
              for (let index = 0; index < imports.length; index++) {
                const { s: start, e: end, n: name } = imports[index]
                // check the chunk being imported
                const url = code.slice(start, end)
                const deps: string[] = []
                const ownerFilename = chunk.fileName
                // literal import - trace direct imports and add to deps
                const analyzed: Set<string> = new Set<string>()
                const addDeps = (filename: string) => {
                  if (filename === ownerFilename) return
                  if (analyzed.has(filename)) return
                  analyzed.add(filename)
                  const chunk = bundle[filename] as OutputChunk | undefined
                  if (chunk) {
                    chunk.viteMetadata!.importedCss.forEach((file) => {
                      deps.push(joinUrlSegments(base, file))
                    })
                    chunk.imports.forEach(addDeps)
                  }
                }
                const normalizedFile = normalizePath(
                  join(dirname(chunk.fileName), url.slice(1, -1)),
                )
                addDeps(normalizedFile)
                ssrManifest[basename(name!)] = deps
              }
            }
          }
        }
      }

      this.emitFile({
        fileName:
          typeof config.build.ssrManifest === 'string'
            ? config.build.ssrManifest
            : '.vite/ssr-manifest.json',
        type: 'asset',
        source: JSON.stringify(sortObjectKeys(ssrManifest), undefined, 2),
      })
    },
  }
}



================================================
FILE: packages/vite/src/node/ssr/ssrModuleLoader.ts
================================================
import colors from 'picocolors'
import type { EvaluatedModuleNode } from 'vite/module-runner'
import {
  ESModulesEvaluator,
  ModuleRunner,
  createNodeImportMeta,
} from 'vite/module-runner'
import type { ViteDevServer } from '../server'
import { unwrapId } from '../../shared/utils'
import type { DevEnvironment } from '../server/environment'
import type { NormalizedServerHotChannel } from '../server/hmr'
import { buildErrorMessage } from '../server/middlewares/error'
import { ssrFixStacktrace } from './ssrStacktrace'
import { createServerModuleRunnerTransport } from './runtime/serverModuleRunner'

type SSRModule = Record<string, any>

export async function ssrLoadModule(
  url: string,
  server: ViteDevServer,
  fixStacktrace?: boolean,
): Promise<SSRModule> {
  const environment = server.environments.ssr
  server._ssrCompatModuleRunner ||= new SSRCompatModuleRunner(environment)
  url = unwrapId(url)

  return instantiateModule(
    url,
    server._ssrCompatModuleRunner,
    environment,
    fixStacktrace,
  )
}

async function instantiateModule(
  url: string,
  runner: ModuleRunner,
  environment: DevEnvironment,
  fixStacktrace?: boolean,
): Promise<SSRModule> {
  const mod = await environment.moduleGraph.ensureEntryFromUrl(url)

  if (mod.ssrError) {
    throw mod.ssrError
  }

  try {
    return await runner.import(url)
  } catch (e: any) {
    if (e.stack && fixStacktrace) {
      ssrFixStacktrace(e, environment.moduleGraph)
    }

    environment.logger.error(
      buildErrorMessage(e, [
        colors.red(`Error when evaluating SSR module ${url}: ${e.message}`),
      ]),
      {
        timestamp: true,
        clear: environment.config.clearScreen,
        error: e,
      },
    )

    throw e
  }
}

class SSRCompatModuleRunner extends ModuleRunner {
  constructor(private environment: DevEnvironment) {
    super(
      {
        transport: createServerModuleRunnerTransport({
          channel: environment.hot as NormalizedServerHotChannel,
        }),
        createImportMeta: createNodeImportMeta,
        sourcemapInterceptor: false,
        hmr: false,
      },
      new ESModulesEvaluator(),
    )
  }

  protected override async directRequest(
    url: string,
    mod: EvaluatedModuleNode,
    callstack: string[],
  ): Promise<any> {
    const id = mod.meta && 'id' in mod.meta && mod.meta.id
    // serverId doesn't exist for external modules
    if (!id) {
      return super.directRequest(url, mod, callstack)
    }

    const viteMod = this.environment.moduleGraph.getModuleById(id)

    if (!viteMod) {
      return super.directRequest(id, mod, callstack)
    }

    try {
      const exports = await super.directRequest(id, mod, callstack)
      viteMod.ssrModule = exports
      return exports
    } catch (err) {
      viteMod.ssrError = err
      throw err
    }
  }
}



================================================
FILE: packages/vite/src/node/ssr/ssrStacktrace.ts
================================================
import path from 'node:path'
import { TraceMap, originalPositionFor } from '@jridgewell/trace-mapping'
import type { EnvironmentModuleGraph } from '..'

let offset: number

function calculateOffsetOnce() {
  if (offset !== undefined) {
    return
  }

  try {
    new Function('throw new Error(1)')()
  } catch (e) {
    // in Node 12, stack traces account for the function wrapper.
    // in Node 13 and later, the function wrapper adds two lines,
    // which must be subtracted to generate a valid mapping
    const match = /:(\d+):\d+\)$/.exec(e.stack.split('\n')[1])
    offset = match ? +match[1] - 1 : 0
  }
}

export function ssrRewriteStacktrace(
  stack: string,
  moduleGraph: EnvironmentModuleGraph,
): string {
  calculateOffsetOnce()
  return stack
    .split('\n')
    .map((line) => {
      return line.replace(
        /^ {4}at (?:(\S.*?)\s\()?(.+?):(\d+)(?::(\d+))?\)?/,
        (input, varName, id, line, column) => {
          if (!id) return input

          const mod = moduleGraph.getModuleById(id)
          const rawSourceMap = mod?.transformResult?.map

          if (!rawSourceMap) {
            return input
          }

          const traced = new TraceMap(rawSourceMap as any)

          const pos = originalPositionFor(traced, {
            line: Number(line) - offset,
            // stacktrace's column is 1-indexed, but sourcemap's one is 0-indexed
            column: Number(column) - 1,
          })

          if (!pos.source) {
            return input
          }

          const trimmedVarName = varName?.trim()
          const sourceFile = path.resolve(path.dirname(id), pos.source)
          // stacktrace's column is 1-indexed, but sourcemap's one is 0-indexed
          const source = `${sourceFile}:${pos.line}:${pos.column + 1}`
          if (!trimmedVarName || trimmedVarName === 'eval') {
            return `    at ${source}`
          } else {
            return `    at ${trimmedVarName} (${source})`
          }
        },
      )
    })
    .join('\n')
}

export function rebindErrorStacktrace(e: Error, stacktrace: string): void {
  const { configurable, writable } = Object.getOwnPropertyDescriptor(
    e,
    'stack',
  )!
  if (configurable) {
    Object.defineProperty(e, 'stack', {
      value: stacktrace,
      enumerable: true,
      configurable: true,
      writable: true,
    })
  } else if (writable) {
    e.stack = stacktrace
  }
}

const rewroteStacktraces = new WeakSet()

export function ssrFixStacktrace(
  e: Error,
  moduleGraph: EnvironmentModuleGraph,
): void {
  if (!e.stack) return
  // stacktrace shouldn't be rewritten more than once
  if (rewroteStacktraces.has(e)) return

  const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph)
  rebindErrorStacktrace(e, stacktrace)

  rewroteStacktraces.add(e)
}



================================================
FILE: packages/vite/src/node/ssr/ssrTransform.ts
================================================
import path from 'node:path'
import MagicString from 'magic-string'
import type { RollupAstNode, SourceMap } from 'rollup'
import type {
  ExportAllDeclaration,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  Function as FunctionNode,
  Identifier,
  ImportDeclaration,
  Literal,
  Pattern,
  Property,
  VariableDeclaration,
  Node as _Node,
} from 'estree'
import { extract_names as extractNames } from 'periscopic'
import { walk as eswalk } from 'estree-walker'
import type { RawSourceMap } from '@jridgewell/remapping'
import { parseAstAsync as rollupParseAstAsync } from 'rollup/parseAst'
import type { TransformResult } from '../server/transformRequest'
import {
  combineSourcemaps,
  generateCodeFrame,
  isDefined,
  numberToPos,
} from '../utils'
import { isJSONRequest } from '../plugins/json'
import type { DefineImportMetadata } from '../../shared/ssrTransform'

type Node = _Node & {
  start: number
  end: number
}

export interface ModuleRunnerTransformOptions {
  json?: {
    stringify?: boolean
  }
}

export const ssrModuleExportsKey = `__vite_ssr_exports__`
export const ssrImportKey = `__vite_ssr_import__`
export const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`
export const ssrExportAllKey = `__vite_ssr_exportAll__`
export const ssrExportNameKey = `__vite_ssr_exportName__`
export const ssrImportMetaKey = `__vite_ssr_import_meta__`

const hashbangRE = /^#!.*\n/

export async function ssrTransform(
  code: string,
  inMap: SourceMap | { mappings: '' } | null,
  url: string,
  originalCode: string,
  options?: ModuleRunnerTransformOptions,
): Promise<TransformResult | null> {
  if (options?.json?.stringify && isJSONRequest(url)) {
    return ssrTransformJSON(code, inMap)
  }
  return ssrTransformScript(code, inMap, url, originalCode)
}

async function ssrTransformJSON(
  code: string,
  inMap: SourceMap | { mappings: '' } | null,
): Promise<TransformResult> {
  return {
    code: code.replace('export default', `${ssrModuleExportsKey}.default =`),
    map: inMap,
    deps: [],
    dynamicDeps: [],
    ssr: true,
  }
}

async function ssrTransformScript(
  code: string,
  inMap: SourceMap | { mappings: '' } | null,
  url: string,
  originalCode: string,
): Promise<TransformResult | null> {
  const s = new MagicString(code)

  let ast: any
  try {
    ast = await rollupParseAstAsync(code)
  } catch (err) {
    // enhance known rollup errors
    // https://github.com/rollup/rollup/blob/42e587e0e37bc0661aa39fe7ad6f1d7fd33f825c/src/utils/bufferToAst.ts#L17-L22
    if (err.code === 'PARSE_ERROR') {
      err.message = `Parse failure: ${err.message}\n`
      err.id = url
      if (typeof err.pos === 'number') {
        err.loc = numberToPos(code, err.pos)
        err.loc.file = url
        err.frame = generateCodeFrame(code, err.pos)
        err.message += `At file: ${url}:${err.loc.line}:${err.loc.column}`
      } else {
        err.message += `At file: ${url}`
      }
    }
    throw err
  }

  let uid = 0
  const deps = new Set<string>()
  const dynamicDeps = new Set<string>()
  const idToImportMap = new Map<string, string>()
  const declaredConst = new Set<string>()

  // hoist at the start of the file, after the hashbang
  const fileStartIndex = hashbangRE.exec(code)?.[0].length ?? 0
  let hoistIndex = fileStartIndex

  function defineImport(
    index: number,
    importNode: (
      | ImportDeclaration
      | (ExportNamedDeclaration & { source: Literal })
      | ExportAllDeclaration
    ) & {
      start: number
      end: number
    },
    metadata?: DefineImportMetadata,
  ) {
    const source = importNode.source.value as string
    deps.add(source)

    // Reduce metadata to undefined if it's all default values
    const metadataArg =
      (metadata?.importedNames?.length ?? 0) > 0
        ? `, ${JSON.stringify(metadata)}`
        : ''

    const importId = `__vite_ssr_import_${uid++}__`
    const transformedImport = `const ${importId} = await ${ssrImportKey}(${JSON.stringify(
      source,
    )}${metadataArg});\n`

    s.update(importNode.start, importNode.end, transformedImport)

    if (importNode.start === index) {
      // no need to hoist, but update hoistIndex to keep the order
      hoistIndex = importNode.end
    } else {
      // There will be an error if the module is called before it is imported,
      // so the module import statement is hoisted to the top
      s.move(importNode.start, importNode.end, index)
    }

    return importId
  }

  function defineExport(name: string, local = name) {
    // wrap with try/catch to fallback to `undefined` for backward compat.
    s.appendLeft(
      fileStartIndex,
      `${ssrExportNameKey}(${JSON.stringify(name)}, () => { try { return ${local} } catch {} });\n`,
    )
  }

  const imports: (
    | RollupAstNode<ImportDeclaration>
    | RollupAstNode<ExportNamedDeclaration>
    | RollupAstNode<ExportAllDeclaration>
  )[] = []
  const exports: (
    | RollupAstNode<ExportNamedDeclaration>
    | RollupAstNode<ExportDefaultDeclaration>
    | RollupAstNode<ExportAllDeclaration>
  )[] = []
  const reExportImportIdMap = new Map<
    RollupAstNode<ExportNamedDeclaration> | RollupAstNode<ExportAllDeclaration>,
    string
  >()

  for (const node of ast.body as Node[]) {
    if (node.type === 'ImportDeclaration') {
      imports.push(node)
    } else if (node.type === 'ExportDefaultDeclaration') {
      exports.push(node)
    } else if (
      node.type === 'ExportNamedDeclaration' ||
      node.type === 'ExportAllDeclaration'
    ) {
      imports.push(node)
      exports.push(node)
    }
  }

  // 1. check all import statements, hoist imports, and record id -> importName map
  for (const node of imports) {
    // hoist re-export's import at the same time as normal imports to preserve execution order
    if (node.type === 'ExportNamedDeclaration') {
      if (node.source) {
        // export { foo, bar } from './foo'
        const importId = defineImport(
          hoistIndex,
          node as RollupAstNode<ExportNamedDeclaration & { source: Literal }>,
          {
            importedNames: node.specifiers.map(
              (s) => getIdentifierNameOrLiteralValue(s.local) as string,
            ),
          },
        )
        reExportImportIdMap.set(node, importId)
      }
      continue
    }
    if (node.type === 'ExportAllDeclaration') {
      if (node.source) {
        // export * from './foo'
        const importId = defineImport(hoistIndex, node)
        reExportImportIdMap.set(node, importId)
      }
      continue
    }

    // import foo from 'foo' --> foo -> __import_foo__.default
    // import { baz } from 'foo' --> baz -> __import_foo__.baz
    // import * as ok from 'foo' --> ok -> __import_foo__
    const importId = defineImport(hoistIndex, node, {
      importedNames: node.specifiers
        .map((s) => {
          if (s.type === 'ImportSpecifier')
            return getIdentifierNameOrLiteralValue(s.imported) as string
          else if (s.type === 'ImportDefaultSpecifier') return 'default'
        })
        .filter(isDefined),
    })
    for (const spec of node.specifiers) {
      if (spec.type === 'ImportSpecifier') {
        if (spec.imported.type === 'Identifier') {
          idToImportMap.set(
            spec.local.name,
            `${importId}.${spec.imported.name}`,
          )
        } else {
          idToImportMap.set(
            spec.local.name,
            `${importId}[${JSON.stringify(spec.imported.value as string)}]`,
          )
        }
      } else if (spec.type === 'ImportDefaultSpecifier') {
        idToImportMap.set(spec.local.name, `${importId}.default`)
      } else {
        // namespace specifier
        idToImportMap.set(spec.local.name, importId)
      }
    }
  }

  // 2. check all export statements and define exports
  for (const node of exports) {
    // named exports
    if (node.type === 'ExportNamedDeclaration') {
      if (node.declaration) {
        if (
          node.declaration.type === 'FunctionDeclaration' ||
          node.declaration.type === 'ClassDeclaration'
        ) {
          // export function foo() {}
          defineExport(node.declaration.id!.name)
        } else {
          // export const foo = 1, bar = 2
          for (const declaration of node.declaration.declarations) {
            const names = extractNames(declaration.id as any)
            for (const name of names) {
              defineExport(name)
            }
          }
        }
        s.remove(node.start, (node.declaration as Node).start)
      } else {
        if (node.source) {
          // export { foo, bar } from './foo'
          const importId = reExportImportIdMap.get(node)!
          for (const spec of node.specifiers) {
            const exportedAs = getIdentifierNameOrLiteralValue(
              spec.exported,
            ) as string

            if (spec.local.type === 'Identifier') {
              defineExport(exportedAs, `${importId}.${spec.local.name}`)
            } else {
              defineExport(
                exportedAs,
                `${importId}[${JSON.stringify(spec.local.value as string)}]`,
              )
            }
          }
        } else {
          s.remove(node.start, node.end)
          // export { foo, bar }
          for (const spec of node.specifiers) {
            // spec.local can be Literal only when it has "from 'something'"
            const local = (spec.local as Identifier).name
            const binding = idToImportMap.get(local)
            const exportedAs = getIdentifierNameOrLiteralValue(
              spec.exported,
            ) as string

            defineExport(exportedAs, binding || local)
          }
        }
      }
    }

    // default export
    if (node.type === 'ExportDefaultDeclaration') {
      const expressionTypes = ['FunctionExpression', 'ClassExpression']
      if (
        'id' in node.declaration &&
        node.declaration.id &&
        !expressionTypes.includes(node.declaration.type)
      ) {
        // named hoistable/class exports
        // export default function foo() {}
        // export default class A {}
        const { name } = node.declaration.id
        s.remove(node.start, node.start + 15 /* 'export default '.length */)
        defineExport('default', name)
      } else {
        // anonymous default exports
        const name = `__vite_ssr_export_default__`
        s.update(
          node.start,
          node.start + 14 /* 'export default'.length */,
          `const ${name} =`,
        )
        defineExport('default', name)
      }
    }

    // export * from './foo'
    if (node.type === 'ExportAllDeclaration') {
      const importId = reExportImportIdMap.get(node)!
      if (node.exported) {
        const exportedAs = getIdentifierNameOrLiteralValue(
          node.exported,
        ) as string
        defineExport(exportedAs, `${importId}`)
      } else {
        s.appendLeft(node.end, `${ssrExportAllKey}(${importId});\n`)
      }
    }
  }

  // 3. convert references to import bindings & import.meta references
  walk(ast, {
    onStatements(statements) {
      // ensure ";" between statements
      for (let i = 0; i < statements.length - 1; i++) {
        const stmt = statements[i]
        if (
          code[stmt.end - 1] !== ';' &&
          stmt.type !== 'FunctionDeclaration' &&
          stmt.type !== 'ClassDeclaration' &&
          stmt.type !== 'BlockStatement' &&
          stmt.type !== 'ImportDeclaration'
        ) {
          s.appendLeft(stmt.end, ';')
        }
      }
    },
    onIdentifier(id, parent, parentStack) {
      const grandparent = parentStack[1]
      const binding = idToImportMap.get(id.name)
      if (!binding) {
        return
      }
      if (isStaticProperty(parent) && parent.shorthand) {
        // let binding used in a property shorthand
        // { foo } -> { foo: __import_x__.foo }
        // skip for destructuring patterns
        if (
          !isNodeInPattern(parent) ||
          isInDestructuringAssignment(parent, parentStack)
        ) {
          s.appendLeft(id.end, `: ${binding}`)
        }
      } else if (
        (parent.type === 'PropertyDefinition' &&
          grandparent?.type === 'ClassBody') ||
        (parent.type === 'ClassDeclaration' && id === parent.superClass)
      ) {
        if (!declaredConst.has(id.name)) {
          declaredConst.add(id.name)
          // locate the top-most node containing the class declaration
          const topNode = parentStack[parentStack.length - 2]
          s.prependRight(topNode.start, `const ${id.name} = ${binding};\n`)
        }
      } else if (parent.type === 'CallExpression') {
        s.update(id.start, id.end, binding)
        // wrap with (0, ...) to avoid method binding `this`
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors#method_binding
        s.prependRight(id.start, `(0,`)
        s.appendLeft(id.end, `)`)
      } else if (
        // don't transform class name identifier
        !(parent.type === 'ClassExpression' && id === parent.id)
      ) {
        s.update(id.start, id.end, binding)
      }
    },
    onImportMeta(node) {
      s.update(node.start, node.end, ssrImportMetaKey)
    },
    onDynamicImport(node) {
      s.update(node.start, node.start + 6, ssrDynamicImportKey)
      if (node.type === 'ImportExpression' && node.source.type === 'Literal') {
        dynamicDeps.add(node.source.value as string)
      }
    },
  })

  let map: TransformResult['map']
  if (inMap?.mappings === '') {
    map = inMap
  } else {
    map = s.generateMap({ hires: 'boundary' })
    map.sources = [path.basename(url)]
    // needs to use originalCode instead of code
    // because code might be already transformed even if map is null
    map.sourcesContent = [originalCode]
    if (
      inMap &&
      inMap.mappings &&
      'sources' in inMap &&
      inMap.sources.length > 0
    ) {
      map = combineSourcemaps(url, [
        map as RawSourceMap,
        inMap as RawSourceMap,
      ]) as SourceMap
    }
  }

  return {
    code: s.toString(),
    map,
    ssr: true,
    deps: [...deps],
    dynamicDeps: [...dynamicDeps],
  }
}

function getIdentifierNameOrLiteralValue(node: Identifier | Literal) {
  return node.type === 'Identifier' ? node.name : node.value
}

interface Visitors {
  onIdentifier: (
    node: Identifier & {
      start: number
      end: number
    },
    parent: Node,
    parentStack: Node[],
  ) => void
  onImportMeta: (node: Node) => void
  onDynamicImport: (node: Node) => void
  onStatements: (statements: Node[]) => void
}

const isNodeInPatternWeakSet = new WeakSet<_Node>()
const setIsNodeInPattern = (node: Property) => isNodeInPatternWeakSet.add(node)
const isNodeInPattern = (node: _Node): node is Property =>
  isNodeInPatternWeakSet.has(node)

/**
 * Same logic from \@vue/compiler-core & \@vue/compiler-sfc
 * Except this is using acorn AST
 */
function walk(
  root: Node,
  { onIdentifier, onImportMeta, onDynamicImport, onStatements }: Visitors,
) {
  const parentStack: Node[] = []
  const varKindStack: VariableDeclaration['kind'][] = []
  const scopeMap = new WeakMap<_Node, Set<string>>()
  const identifiers: [id: any, stack: Node[]][] = []

  const setScope = (node: _Node, name: string) => {
    let scopeIds = scopeMap.get(node)
    if (scopeIds && scopeIds.has(name)) {
      return
    }
    if (!scopeIds) {
      scopeIds = new Set()
      scopeMap.set(node, scopeIds)
    }
    scopeIds.add(name)
  }

  function isInScope(name: string, parents: Node[]) {
    return parents.some((node) => scopeMap.get(node)?.has(name))
  }
  function handlePattern(p: Pattern, parentScope: _Node) {
    if (p.type === 'Identifier') {
      setScope(parentScope, p.name)
    } else if (p.type === 'RestElement') {
      handlePattern(p.argument, parentScope)
    } else if (p.type === 'ObjectPattern') {
      p.properties.forEach((property) => {
        if (property.type === 'RestElement') {
          setScope(parentScope, (property.argument as Identifier).name)
        } else {
          handlePattern(property.value, parentScope)
        }
      })
    } else if (p.type === 'ArrayPattern') {
      p.elements.forEach((element) => {
        if (element) {
          handlePattern(element, parentScope)
        }
      })
    } else if (p.type === 'AssignmentPattern') {
      handlePattern(p.left, parentScope)
    } else {
      setScope(parentScope, (p as any).name)
    }
  }

  ;(eswalk as any)(root, {
    enter(node: Node, parent: Node | null) {
      if (node.type === 'ImportDeclaration') {
        return this.skip()
      }

      // for nodes that can contain multiple statements
      if (
        node.type === 'Program' ||
        node.type === 'BlockStatement' ||
        node.type === 'StaticBlock'
      ) {
        onStatements(node.body as Node[])
      } else if (node.type === 'SwitchCase') {
        onStatements(node.consequent as Node[])
      }

      // track parent stack, skip for "else-if"/"else" branches as acorn nests
      // the ast within "if" nodes instead of flattening them
      if (
        parent &&
        !(parent.type === 'IfStatement' && node === parent.alternate)
      ) {
        parentStack.unshift(parent)
      }

      // track variable declaration kind stack used by VariableDeclarator
      if (node.type === 'VariableDeclaration') {
        varKindStack.unshift(node.kind)
      }

      if (node.type === 'MetaProperty' && node.meta.name === 'import') {
        onImportMeta(node)
      } else if (node.type === 'ImportExpression') {
        onDynamicImport(node)
      }

      if (node.type === 'Identifier') {
        if (
          !isInScope(node.name, parentStack) &&
          isRefIdentifier(node, parent!, parentStack)
        ) {
          // record the identifier, for DFS -> BFS
          identifiers.push([node, parentStack.slice(0)])
        }
      } else if (isFunction(node)) {
        // If it is a function declaration, it could be shadowing an import
        // Add its name to the scope so it won't get replaced
        if (node.type === 'FunctionDeclaration') {
          const parentScope = findParentScope(parentStack)
          if (parentScope) {
            setScope(parentScope, node.id.name)
          }
        }
        // If it is a function expression, its name (if exist) could also be
        // shadowing an import. So add its own name to the scope
        if (node.type === 'FunctionExpression' && node.id) {
          setScope(node, node.id.name)
        }
        // walk function expressions and add its arguments to known identifiers
        // so that we don't prefix them
        node.params.forEach((p) => {
          if (p.type === 'ObjectPattern' || p.type === 'ArrayPattern') {
            handlePattern(p, node)
            return
          }
          ;(eswalk as any)(p.type === 'AssignmentPattern' ? p.left : p, {
            enter(child: Node, parent: Node | undefined) {
              // skip params default value of destructure
              if (
                parent?.type === 'AssignmentPattern' &&
                parent.right === child
              ) {
                return this.skip()
              }
              if (child.type !== 'Identifier') return
              // do not record as scope variable if is a destructuring keyword
              if (isStaticPropertyKey(child, parent)) return
              // do not record if this is a default value
              // assignment of a destructuring variable
              if (
                (parent?.type === 'TemplateLiteral' &&
                  parent.expressions.includes(child)) ||
                (parent?.type === 'CallExpression' && parent.callee === child)
              ) {
                return
              }
              setScope(node, child.name)
            },
          })
        })
      } else if (node.type === 'ClassDeclaration') {
        // A class declaration name could shadow an import, so add its name to the parent scope
        const parentScope = findParentScope(parentStack)
        if (parentScope) {
          setScope(parentScope, node.id.name)
        }
      } else if (node.type === 'ClassExpression' && node.id) {
        // A class expression name could shadow an import, so add its name to the scope
        setScope(node, node.id.name)
      } else if (node.type === 'Property' && parent!.type === 'ObjectPattern') {
        // mark property in destructuring pattern
        setIsNodeInPattern(node)
      } else if (node.type === 'VariableDeclarator') {
        const parentFunction = findParentScope(
          parentStack,
          varKindStack[0] === 'var',
        )
        if (parentFunction) {
          handlePattern(node.id, parentFunction)
        }
      } else if (node.type === 'CatchClause' && node.param) {
        handlePattern(node.param, node)
      }
    },

    leave(node: Node, parent: Node | null) {
      // untrack parent stack from above
      if (
        parent &&
        !(parent.type === 'IfStatement' && node === parent.alternate)
      ) {
        parentStack.shift()
      }

      if (node.type === 'VariableDeclaration') {
        varKindStack.shift()
      }
    },
  })

  // emit the identifier events in BFS so the hoisted declarations
  // can be captured correctly
  identifiers.forEach(([node, stack]) => {
    if (!isInScope(node.name, stack)) onIdentifier(node, stack[0], stack)
  })
}

function isRefIdentifier(id: Identifier, parent: _Node, parentStack: _Node[]) {
  // declaration id
  if (
    parent.type === 'CatchClause' ||
    ((parent.type === 'VariableDeclarator' ||
      parent.type === 'ClassDeclaration') &&
      parent.id === id)
  ) {
    return false
  }

  if (isFunction(parent)) {
    // function declaration/expression id
    if ((parent as any).id === id) {
      return false
    }
    // params list
    if (parent.params.includes(id)) {
      return false
    }
  }

  // class method name
  if (parent.type === 'MethodDefinition' && !parent.computed) {
    return false
  }

  // property key
  if (isStaticPropertyKey(id, parent)) {
    return false
  }

  // object destructuring pattern
  if (isNodeInPattern(parent) && parent.value === id) {
    return false
  }

  // non-assignment array destructuring pattern
  if (
    parent.type === 'ArrayPattern' &&
    !isInDestructuringAssignment(parent, parentStack)
  ) {
    return false
  }

  // member expression property
  if (
    parent.type === 'MemberExpression' &&
    parent.property === id &&
    !parent.computed
  ) {
    return false
  }

  // export { id } from "lib"
  // export * as id from "lib"
  if (
    parent.type === 'ExportSpecifier' ||
    parent.type === 'ExportAllDeclaration'
  ) {
    return false
  }

  // is a special keyword but parsed as identifier
  if (id.name === 'arguments') {
    return false
  }

  return true
}

const isStaticProperty = (node: _Node): node is Property =>
  node.type === 'Property' && !node.computed

const isStaticPropertyKey = (node: _Node, parent: _Node | undefined) =>
  parent && isStaticProperty(parent) && parent.key === node

const functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/
function isFunction(node: _Node): node is FunctionNode {
  return functionNodeTypeRE.test(node.type)
}

const blockNodeTypeRE = /^BlockStatement$|^For(?:In|Of)?Statement$/
function isBlock(node: _Node) {
  return blockNodeTypeRE.test(node.type)
}

function findParentScope(
  parentStack: _Node[],
  isVar = false,
): _Node | undefined {
  return parentStack.find(isVar ? isFunction : isBlock)
}

function isInDestructuringAssignment(
  parent: _Node,
  parentStack: _Node[],
): boolean {
  if (parent.type === 'Property' || parent.type === 'ArrayPattern') {
    return parentStack.some((i) => i.type === 'AssignmentExpression')
  }
  return false
}



================================================
FILE: packages/vite/src/node/ssr/__tests__/ssrLoadModule.spec.ts
================================================
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import fs from 'node:fs'
import { stripVTControlCharacters } from 'node:util'
import { expect, onTestFinished, test, vi } from 'vitest'
import { createServer } from '../../server'
import { normalizePath } from '../../utils'

const root = fileURLToPath(new URL('./', import.meta.url))

async function createDevServer() {
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'silent',
    optimizeDeps: {
      noDiscovery: true,
    },
  })
  server.environments.ssr.pluginContainer.buildStart({})
  return server
}

test('ssrLoad', async () => {
  expect.assertions(1)
  const server = await createDevServer()
  const moduleRelativePath = '/fixtures/modules/has-invalid-import.js'
  const moduleAbsolutePath = normalizePath(path.join(root, moduleRelativePath))
  try {
    await server.ssrLoadModule(moduleRelativePath)
  } catch (e) {
    expect(e.message).toBe(
      `Failed to load url ./non-existent.js (resolved id: ./non-existent.js) in ${moduleAbsolutePath}. Does the file exist?`,
    )
  }
})

test('error has same instance', async () => {
  expect.assertions(3)
  const s = Symbol()

  const server = await createDevServer()
  try {
    await server.ssrLoadModule('/fixtures/modules/has-error.js')
  } catch (e) {
    expect(e[s]).toBeUndefined()
    e[s] = true
    expect(e[s]).toBe(true)
  }

  try {
    await server.ssrLoadModule('/fixtures/modules/has-error.js')
  } catch (e) {
    expect(e[s]).toBe(true)
  }
})

test('import.meta.filename/dirname returns same value with Node', async () => {
  const server = await createDevServer()
  const moduleRelativePath = '/fixtures/modules/import-meta.js'
  const filename = path.resolve(root, '.' + moduleRelativePath)

  const viteValue = await server.ssrLoadModule(moduleRelativePath)
  expect(viteValue.dirname).toBe(path.dirname(filename))
  expect(viteValue.filename).toBe(filename)
})

test('virtual module invalidation simple', async () => {
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'silent',
    optimizeDeps: {
      noDiscovery: true,
    },
    plugins: [
      {
        name: 'virtual-test',
        resolveId(id) {
          if (id === 'virtual:test') {
            return '\0virtual:test'
          }
        },
        load(id) {
          if (id === '\0virtual:test') {
            return `
              globalThis.__virtual_test_state ??= 0;
              globalThis.__virtual_test_state++;
              export default globalThis.__virtual_test_state;
            `
          }
        },
      },
    ],
  })
  server.environments.ssr.pluginContainer.buildStart({})

  const mod1 = await server.ssrLoadModule('virtual:test')
  expect(mod1.default).toEqual(1)
  const mod2 = await server.ssrLoadModule('virtual:test')
  expect(mod2.default).toEqual(1)

  const modNode = server.moduleGraph.getModuleById('\0virtual:test')
  server.moduleGraph.invalidateModule(modNode!)

  const mod3 = await server.ssrLoadModule('virtual:test')
  expect(mod3.default).toEqual(2)
})

test('virtual module invalidation nested', async () => {
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'silent',
    optimizeDeps: {
      noDiscovery: true,
    },
    plugins: [
      {
        name: 'test-virtual',
        resolveId(id) {
          if (id === 'virtual:test') {
            return '\0virtual:test'
          }
        },
        load(id) {
          if (id === '\0virtual:test') {
            return `
              import testDep from "virtual:test-dep";
              export default testDep;
            `
          }
        },
      },
      {
        name: 'test-virtual-dep',
        resolveId(id) {
          if (id === 'virtual:test-dep') {
            return '\0virtual:test-dep'
          }
        },
        load(id) {
          if (id === '\0virtual:test-dep') {
            return `
              globalThis.__virtual_test_state2 ??= 0;
              globalThis.__virtual_test_state2++;
              export default globalThis.__virtual_test_state2;
            `
          }
        },
      },
    ],
  })
  server.environments.ssr.pluginContainer.buildStart({})

  const mod1 = await server.ssrLoadModule('virtual:test')
  expect(mod1.default).toEqual(1)
  const mod2 = await server.ssrLoadModule('virtual:test')
  expect(mod2.default).toEqual(1)

  server.moduleGraph.invalidateModule(
    server.moduleGraph.getModuleById('\0virtual:test')!,
  )
  server.moduleGraph.invalidateModule(
    server.moduleGraph.getModuleById('\0virtual:test-dep')!,
  )

  const mod3 = await server.ssrLoadModule('virtual:test')
  expect(mod3.default).toEqual(2)
})

test('can export global', async () => {
  const server = await createDevServer()
  const mod = await server.ssrLoadModule('/fixtures/global/export.js')
  expect(mod.global).toBe('ok')
})

test('can access nodejs global', async () => {
  const server = await createDevServer()
  const mod = await server.ssrLoadModule('/fixtures/global/test.js')
  expect(mod.default).toBe(globalThis)
})

test('parse error', async () => {
  const server = await createDevServer()

  function stripRoot(s?: string) {
    return (s || '').replace(server.config.root, '<root>')
  }

  for (const file of [
    '/fixtures/errors/syntax-error.ts',
    '/fixtures/errors/syntax-error.js',
    '/fixtures/errors/syntax-error-dep.ts',
    '/fixtures/errors/syntax-error-dep.js',
  ]) {
    try {
      await server.ssrLoadModule(file)
    } catch (e) {
      expect(e).toBeInstanceOf(Error)
      expect({
        message: stripRoot(e.message),
        frame: stripVTControlCharacters(e.frame || ''),
        id: stripRoot(e.id),
        loc: e.loc && {
          file: stripRoot(e.loc.file),
          column: e.loc.column,
          line: e.loc.line,
        },
      }).toMatchSnapshot()
      continue
    }
    expect.unreachable()
  }
})

test('json', async () => {
  const server = await createDevServer()
  const mod = await server.ssrLoadModule('/fixtures/json/test.json')
  expect(mod).toMatchInlineSnapshot(`
    {
      "default": {
        "hello": "this is json",
      },
      "hello": "this is json",
    }
  `)

  const source = fs.readFileSync(
    path.join(root, 'fixtures/json/test.json'),
    'utf-8',
  )
  const json = await server.ssrTransform(
    `export default ${source}`,
    null,
    '/test.json',
  )
  expect(json?.code.length).toMatchInlineSnapshot(`165`)
})

test('file url', async () => {
  const server = await createDevServer()

  const mod = await server.ssrLoadModule(
    new URL('./fixtures/file-url/test.js', import.meta.url).href,
  )
  expect(mod.msg).toBe('works')

  const modWithSpace = await server.ssrLoadModule(
    new URL('./fixtures/file-url/test space.js', import.meta.url).href,
  )
  expect(modWithSpace.msg).toBe('works')
})

test('plugin error', async () => {
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'error',
    plugins: [
      {
        name: 'test-plugin',
        resolveId(source) {
          if (source === 'virtual:test') {
            return '\0' + source
          }
        },
        load(id) {
          if (id === '\0virtual:test') {
            return this.error('test-error')
          }
        },
      },
    ],
  })
  onTestFinished(() => server.close())

  const spy = vi
    .spyOn(server.config.logger, 'error')
    .mockImplementation(() => {})
  try {
    await server.ssrLoadModule('virtual:test')
    expect.unreachable()
  } catch {}
  expect(
    stripVTControlCharacters(spy.mock.lastCall![0])
      .split('\n')
      .slice(0, 2)
      .join('\n'),
  ).toMatchInlineSnapshot(`
    "Error when evaluating SSR module virtual:test: test-error
      Plugin: test-plugin"
  `)
})

test('named exports overwrite export all', async () => {
  const server = await createDevServer()
  const mod = await server.ssrLoadModule(
    './fixtures/named-overwrite-all/main.js',
  )

  // ESM spec doesn't allow conflicting `export *` and such duplicate exports are removed (in this case "d"),
  // but this is likely not possible to support due to Vite dev SSR's lazy nature.
  // [Node]
  //   $ node -e 'import("./packages/vite/src/node/ssr/__tests__/fixtures/named-overwrite-all/main.js").then(console.log)'
  //   [Module: null prototype] { a: 'main-a', b: 'dep1-b', c: 'main-c' }
  // [Rollup]
  //   Conflicting namespaces: "main.js" re-exports "d" from one of the modules "dep1.js" and "dep2.js" (will be ignored).
  expect(mod).toMatchInlineSnapshot(`
    {
      "a": "main-a",
      "b": "dep1-b",
      "c": "main-c",
      "d": "dep1-d",
    }
  `)
})

test('buildStart before transform', async () => {
  const fn = vi.fn()
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'error',
    plugins: [
      {
        name: 'test-plugin',
        async buildStart() {
          fn('buildStart:in')
          await new Promise((r) => setTimeout(r, 200))
          fn('buildStart:out')
        },
        resolveId(source) {
          if (source === 'virtual:test') {
            fn('resolveId')
            return '\0' + source
          }
        },
        load(id) {
          if (id === '\0virtual:test') {
            fn('load')
            return `export default 'ok'`
          }
        },
        transform(code, id) {
          if (id === '\0virtual:test') {
            fn('transform')
            return code
          }
        },
      },
    ],
  })
  onTestFinished(() => server.close())
  await server.pluginContainer.buildStart({})

  const mod = await server.ssrLoadModule('virtual:test')
  expect(mod.default).toBe('ok')
  expect(fn.mock.calls).toMatchInlineSnapshot(`
    [
      [
        "buildStart:in",
      ],
      [
        "buildStart:out",
      ],
      [
        "resolveId",
      ],
      [
        "load",
      ],
      [
        "transform",
      ],
    ]
  `)
})



================================================
FILE: packages/vite/src/node/ssr/__tests__/ssrStacktrace.spec.ts
================================================
import { fileURLToPath } from 'node:url'
import { test } from 'vitest'
import { createServer } from '../../server'

const root = fileURLToPath(new URL('./', import.meta.url))

async function createDevServer() {
  const server = await createServer({
    configFile: false,
    root,
    logLevel: 'silent',
    optimizeDeps: {
      noDiscovery: true,
    },
  })
  server.environments.ssr.pluginContainer.buildStart({})
  return server
}

test('call rewriteStacktrace twice', async () => {
  const server = await createDevServer()
  for (let i = 0; i < 2; i++) {
    try {
      await server.ssrLoadModule('/fixtures/modules/has-error.js')
    } catch (e) {
      server.ssrFixStacktrace(e)
    }
  }
})



================================================
FILE: packages/vite/src/node/ssr/__tests__/ssrTransform.spec.ts
================================================
import { readFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { assert, expect, test } from 'vitest'
import type { SourceMap } from 'rollup'
import { TraceMap, originalPositionFor } from '@jridgewell/trace-mapping'
import { transformWithEsbuild } from '../../plugins/esbuild'
import { ssrTransform } from '../ssrTransform'
import { createServer } from '../..'

const ssrTransformSimple = async (code: string, url = '') =>
  ssrTransform(code, null, url, code)
const ssrTransformSimpleCode = async (code: string, url?: string) =>
  (await ssrTransformSimple(code, url))?.code

test('default import', async () => {
  expect(
    await ssrTransformSimpleCode(`import foo from 'vue';console.log(foo.bar)`),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["default"]});
    console.log(__vite_ssr_import_0__.default.bar)"
  `,
  )
})

test('named import', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import { ref } from 'vue';function foo() { return ref(0) }`,
    ),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["ref"]});
    function foo() { return (0,__vite_ssr_import_0__.ref)(0) }"
  `,
  )
})

test('named import: arbitrary module namespace specifier', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import { "some thing" as ref } from 'vue';function foo() { return ref(0) }`,
    ),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["some thing"]});
    function foo() { return (0,__vite_ssr_import_0__["some thing"])(0) }"
  `,
  )
})

test('namespace import', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import * as vue from 'vue';function foo() { return vue.ref(0) }`,
    ),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue");
    function foo() { return __vite_ssr_import_0__.ref(0) }"
  `,
  )
})

test('export function declaration', async () => {
  expect(
    await ssrTransformSimpleCode(`export function foo() {}`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("foo", () => { try { return foo } catch {} });
    function foo() {}"
  `,
  )
})

test('export class declaration', async () => {
  expect(
    await ssrTransformSimpleCode(`export class foo {}`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("foo", () => { try { return foo } catch {} });
    class foo {}"
  `,
  )
})

test('export var declaration', async () => {
  expect(
    await ssrTransformSimpleCode(`export const a = 1, b = 2`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("a", () => { try { return a } catch {} });
    __vite_ssr_exportName__("b", () => { try { return b } catch {} });
    const a = 1, b = 2"
  `,
  )
})

test('export named', async () => {
  expect(
    await ssrTransformSimpleCode(`const a = 1, b = 2; export { a, b as c }`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("a", () => { try { return a } catch {} });
    __vite_ssr_exportName__("c", () => { try { return b } catch {} });
    const a = 1, b = 2; "
  `,
  )
})

test('export named from', async () => {
  expect(
    await ssrTransformSimpleCode(`export { ref, computed as c } from 'vue'`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("ref", () => { try { return __vite_ssr_import_0__.ref } catch {} });
    __vite_ssr_exportName__("c", () => { try { return __vite_ssr_import_0__.computed } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["ref","computed"]});
    "
  `,
  )
})

test('named exports of imported binding', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import {createApp} from 'vue';export {createApp}`,
    ),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("createApp", () => { try { return __vite_ssr_import_0__.createApp } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["createApp"]});
    "
  `,
  )
})

test('export * from', async () => {
  expect(
    await ssrTransformSimpleCode(
      `export * from 'vue'\n` + `export * from 'react'`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue");
    __vite_ssr_exportAll__(__vite_ssr_import_0__);
    ;const __vite_ssr_import_1__ = await __vite_ssr_import__("react");
    __vite_ssr_exportAll__(__vite_ssr_import_1__);

    "
  `)
})

test('export * as from', async () => {
  expect(
    await ssrTransformSimpleCode(`export * as foo from 'vue'`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("foo", () => { try { return __vite_ssr_import_0__ } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("vue");
    "
  `,
  )
})

test('re-export by imported name', async () => {
  expect(
    await ssrTransformSimpleCode(`\
import * as foo from 'foo'
export * as foo from 'foo'
`),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("foo", () => { try { return __vite_ssr_import_1__ } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foo");
    const __vite_ssr_import_1__ = await __vite_ssr_import__("foo");


    "
  `)

  expect(
    await ssrTransformSimpleCode(`\
import { foo } from 'foo'
export { foo } from 'foo'
`),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("foo", () => { try { return __vite_ssr_import_1__.foo } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["foo"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("foo", {"importedNames":["foo"]});


    "
  `)

  expect(
    await ssrTransformSimpleCode(`\
import { foo } from 'foo'
export { foo as foo } from 'foo'
`),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("foo", () => { try { return __vite_ssr_import_1__.foo } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["foo"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("foo", {"importedNames":["foo"]});


    "
  `)
})

test('export * as from arbitrary module namespace identifier', async () => {
  expect(
    await ssrTransformSimpleCode(`export * as "arbitrary string" from 'vue'`),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("arbitrary string", () => { try { return __vite_ssr_import_0__ } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("vue");
    "
  `,
  )
})

test('export as arbitrary module namespace identifier', async () => {
  expect(
    await ssrTransformSimpleCode(
      `const something = "Something";export { something as "arbitrary string" };`,
    ),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("arbitrary string", () => { try { return something } catch {} });
    const something = "Something";"
  `,
  )
})

test('export as from arbitrary module namespace identifier', async () => {
  expect(
    await ssrTransformSimpleCode(
      `export { "arbitrary string2" as "arbitrary string" } from 'vue';`,
    ),
  ).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("arbitrary string", () => { try { return __vite_ssr_import_0__["arbitrary string2"] } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["arbitrary string2"]});
    "
  `,
  )
})

test('export default', async () => {
  expect(await ssrTransformSimpleCode(`export default {}`))
    .toMatchInlineSnapshot(`
      "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
      const __vite_ssr_export_default__ = {}"
    `)
})

test('export then import minified', async () => {
  expect(
    await ssrTransformSimpleCode(
      `export * from 'vue';import {createApp} from 'vue';`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue");
    __vite_ssr_exportAll__(__vite_ssr_import_0__);
    const __vite_ssr_import_1__ = await __vite_ssr_import__("vue", {"importedNames":["createApp"]});
    "
  `)
})

test('hoist import to top', async () => {
  expect(
    await ssrTransformSimpleCode(
      `path.resolve('server.js');import path from 'node:path';`,
    ),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("node:path", {"importedNames":["default"]});
    __vite_ssr_import_0__.default.resolve('server.js');"
  `,
  )
})

test('whitespace between imports does not trigger hoisting', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import { dirname } from 'node:path';\n\n\nimport fs from 'node:fs';`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("node:path", {"importedNames":["dirname"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("node:fs", {"importedNames":["default"]});



    "
  `)
})

test('import.meta', async () => {
  expect(
    await ssrTransformSimpleCode(`console.log(import.meta.url)`),
  ).toMatchInlineSnapshot(`"console.log(__vite_ssr_import_meta__.url)"`)
})

test('dynamic import', async () => {
  const result = await ssrTransformSimple(
    `export const i = () => import('./foo')`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "__vite_ssr_exportName__("i", () => { try { return i } catch {} });
    const i = () => __vite_ssr_dynamic_import__('./foo')"
  `,
  )
  expect(result?.deps).toEqual([])
  expect(result?.dynamicDeps).toEqual(['./foo'])
})

test('do not rewrite method definition', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';class A { fn() { fn() } }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    class A { fn() { (0,__vite_ssr_import_0__.fn)() } }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

test('do not rewrite when variable is in scope', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A(){ const fn = () => {}; return { fn }; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A(){ const fn = () => {}; return { fn }; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

// #5472
test('do not rewrite when variable is in scope with object destructuring', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A(){ let {fn, test} = {fn: 'foo', test: 'bar'}; return { fn }; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A(){ let {fn, test} = {fn: 'foo', test: 'bar'}; return { fn }; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

// #5472
test('do not rewrite when variable is in scope with array destructuring', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A(){ let [fn, test] = ['foo', 'bar']; return { fn }; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A(){ let [fn, test] = ['foo', 'bar']; return { fn }; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

// #5727
test('rewrite variable in string interpolation in function nested arguments', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A({foo = \`test\${fn}\`} = {}){ return {}; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A({foo = \`test\${__vite_ssr_import_0__.fn}\`} = {}){ return {}; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

// #6520
test('rewrite variables in default value of destructuring params', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A({foo = fn}){ return {}; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A({foo = __vite_ssr_import_0__.fn}){ return {}; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

test('do not rewrite when function declaration is in scope', async () => {
  const result = await ssrTransformSimple(
    `import { fn } from 'vue';function A(){ function fn() {}; return { fn }; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["fn"]});
    function A(){ function fn() {}; return { fn }; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

// #16452
test('do not rewrite when function expression is in scope', async () => {
  const result = await ssrTransformSimple(
    `import {fn} from './vue';var a = function() { return function fn() { console.log(fn) } }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./vue", {"importedNames":["fn"]});
    var a = function() { return function fn() { console.log(fn) } }"
  `,
  )
})

// #16452
test('do not rewrite when function expression is in global scope', async () => {
  const result = await ssrTransformSimple(
    `import {fn} from './vue';foo(function fn(a = fn) { console.log(fn) })`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./vue", {"importedNames":["fn"]});
    foo(function fn(a = fn) { console.log(fn) })"
  `,
  )
})

test('do not rewrite when class declaration is in scope', async () => {
  const result = await ssrTransformSimple(
    `import { cls } from 'vue';function A(){ class cls {} return { cls }; }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["cls"]});
    function A(){ class cls {} return { cls }; }"
  `,
  )
  expect(result?.deps).toEqual(['vue'])
})

test('do not rewrite when class expression is in scope', async () => {
  const result = await ssrTransformSimple(
    `import { cls } from './vue';var a = function() { return class cls { constructor() { console.log(cls) } } }`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./vue", {"importedNames":["cls"]});
    var a = function() { return class cls { constructor() { console.log(cls) } } }"
  `,
  )
})

test('do not rewrite when class expression is in global scope', async () => {
  const result = await ssrTransformSimple(
    `import { cls } from './vue';foo(class cls { constructor() { console.log(cls) } })`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./vue", {"importedNames":["cls"]});
    foo(class cls { constructor() { console.log(cls) } })"
  `,
  )
})

test('do not rewrite catch clause', async () => {
  const result = await ssrTransformSimple(
    `import {error} from './dependency';try {} catch(error) {}`,
  )
  expect(result?.code).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./dependency", {"importedNames":["error"]});
    try {} catch(error) {}"
  `,
  )
  expect(result?.deps).toEqual(['./dependency'])
})

// #2221
test('should declare variable for imported super class', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import { Foo } from './dependency';` + `class A extends Foo {}`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./dependency", {"importedNames":["Foo"]});
    const Foo = __vite_ssr_import_0__.Foo;
    class A extends Foo {}"
  `)

  // exported classes: should prepend the declaration at root level, before the
  // first class that uses the binding
  expect(
    await ssrTransformSimpleCode(
      `import { Foo } from './dependency';` +
        `export default class A extends Foo {}\n` +
        `export class B extends Foo {}`,
    ),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("default", () => { try { return A } catch {} });
    __vite_ssr_exportName__("B", () => { try { return B } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("./dependency", {"importedNames":["Foo"]});
    const Foo = __vite_ssr_import_0__.Foo;
    class A extends Foo {};
    class B extends Foo {}"
  `)
})

// #4049
test('should handle default export variants', async () => {
  // default anonymous functions
  expect(await ssrTransformSimpleCode(`export default function() {}\n`))
    .toMatchInlineSnapshot(`
      "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
      const __vite_ssr_export_default__ = function() {}
      "
    `)
  // default anonymous class
  expect(await ssrTransformSimpleCode(`export default class {}\n`))
    .toMatchInlineSnapshot(`
      "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
      const __vite_ssr_export_default__ = class {}
      "
    `)
  // default named functions
  expect(
    await ssrTransformSimpleCode(
      `export default function foo() {}\n` +
        `foo.prototype = Object.prototype;`,
    ),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("default", () => { try { return foo } catch {} });
    function foo() {};
    foo.prototype = Object.prototype;"
  `)
  // default named classes
  expect(
    await ssrTransformSimpleCode(
      `export default class A {}\n` + `export class B extends A {}`,
    ),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("default", () => { try { return A } catch {} });
    __vite_ssr_exportName__("B", () => { try { return B } catch {} });
    class A {};
    class B extends A {}"
  `)
})

test('sourcemap source', async () => {
  const map = (
    await ssrTransform(
      `export const a = 1`,
      null,
      'input.js',
      'export const a = 1 /* */',
    )
  )?.map as SourceMap

  expect(map?.sources).toStrictEqual(['input.js'])
  expect(map?.sourcesContent).toStrictEqual(['export const a = 1 /* */'])
})

test('sourcemap is correct for hoisted imports', async () => {
  const code = `\n\n\nconsole.log(foo, bar);\nimport { foo } from 'vue';\nimport { bar } from 'vue2';`
  const result = (await ssrTransform(code, null, 'input.js', code))!

  expect(result.code).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["foo"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("vue2", {"importedNames":["bar"]});



    console.log((0,__vite_ssr_import_0__.foo), (0,__vite_ssr_import_1__.bar));

    "
  `)

  const traceMap = new TraceMap(result.map as any)
  expect(originalPositionFor(traceMap, { line: 1, column: 0 })).toStrictEqual({
    source: 'input.js',
    line: 5,
    column: 0,
    name: null,
  })
  expect(originalPositionFor(traceMap, { line: 2, column: 0 })).toStrictEqual({
    source: 'input.js',
    line: 6,
    column: 0,
    name: null,
  })
})

test('sourcemap with multiple sources', async () => {
  const code = readFixture('bundle.js')
  const map = readFixture('bundle.js.map')

  const result = await ssrTransform(code, JSON.parse(map), '', code)
  assert(result?.map)

  const { sources } = result.map as SourceMap
  expect(sources).toContain('./first.ts')
  expect(sources).toContain('./second.ts')

  function readFixture(filename: string) {
    const url = new URL(
      `./fixtures/bundled-with-sourcemaps/${filename}`,
      import.meta.url,
    )

    return readFileSync(fileURLToPath(url), 'utf8')
  }
})

test('sourcemap with multiple sources and nested paths', async () => {
  const code = readFixture('dist.js')
  const map = readFixture('dist.js.map')

  const result = await ssrTransform(code, JSON.parse(map), '', code)
  assert(result?.map)

  const { sources } = result.map as SourceMap
  expect(sources).toMatchInlineSnapshot(`
    [
      "nested-directory/nested-file.js",
      "entrypoint.js",
    ]
  `)

  function readFixture(filename: string) {
    const url = new URL(
      `./fixtures/multi-source-sourcemaps/${filename}`,
      import.meta.url,
    )

    return readFileSync(fileURLToPath(url), 'utf8')
  }
})

test('overwrite bindings', async () => {
  expect(
    await ssrTransformSimpleCode(
      `import { inject } from 'vue';` +
        `const a = { inject }\n` +
        `const b = { test: inject }\n` +
        `function c() { const { test: inject } = { test: true }; console.log(inject) }\n` +
        `const d = inject\n` +
        `function f() {  console.log(inject) }\n` +
        `function e() { const { inject } = { inject: true } }\n` +
        `function g() { const f = () => { const inject = true }; console.log(inject) }\n`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["inject"]});
    const a = { inject: __vite_ssr_import_0__.inject };
    const b = { test: __vite_ssr_import_0__.inject };
    function c() { const { test: inject } = { test: true }; console.log(inject) }
    const d = __vite_ssr_import_0__.inject;
    function f() {  console.log((0,__vite_ssr_import_0__.inject)) }
    function e() { const { inject } = { inject: true } }
    function g() { const f = () => { const inject = true }; console.log((0,__vite_ssr_import_0__.inject)) }
    "
  `)
})

test('Empty array pattern', async () => {
  expect(
    await ssrTransformSimpleCode(`const [, LHS, RHS] = inMatch;`),
  ).toMatchInlineSnapshot(`"const [, LHS, RHS] = inMatch;"`)
})

test('function argument destructure', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import { foo, bar } from 'foo'
const a = ({ _ = foo() }) => {}
function b({ _ = bar() }) {}
function c({ _ = bar() + foo() }) {}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["foo","bar"]});


    const a = ({ _ = (0,__vite_ssr_import_0__.foo)() }) => {};
    function b({ _ = (0,__vite_ssr_import_0__.bar)() }) {}
    function c({ _ = (0,__vite_ssr_import_0__.bar)() + (0,__vite_ssr_import_0__.foo)() }) {}
    "
  `)
})

test('object destructure alias', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import { n } from 'foo'
const a = () => {
  const { type: n = 'bar' } = {}
  console.log(n)
}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["n"]});


    const a = () => {
      const { type: n = 'bar' } = {};
      console.log(n)
    }
    "
  `)

  // #9585
  expect(
    await ssrTransformSimpleCode(
      `
import { n, m } from 'foo'
const foo = {}

{
  const { [n]: m } = foo
}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["n","m"]});


    const foo = {};

    {
      const { [__vite_ssr_import_0__.n]: m } = foo
    }
    "
  `)
})

test('nested object destructure alias', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import { remove, add, get, set, rest, objRest } from 'vue'

function a() {
  const {
    o: { remove },
    a: { b: { c: [ add ] }},
    d: [{ get }, set, ...rest],
    ...objRest
  } = foo

  remove()
  add()
  get()
  set()
  rest()
  objRest()
}

remove()
add()
get()
set()
rest()
objRest()
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["remove","add","get","set","rest","objRest"]});



    function a() {
      const {
        o: { remove },
        a: { b: { c: [ add ] }},
        d: [{ get }, set, ...rest],
        ...objRest
      } = foo;

      remove();
      add();
      get();
      set();
      rest();
      objRest()
    }

    (0,__vite_ssr_import_0__.remove)();
    (0,__vite_ssr_import_0__.add)();
    (0,__vite_ssr_import_0__.get)();
    (0,__vite_ssr_import_0__.set)();
    (0,__vite_ssr_import_0__.rest)();
    (0,__vite_ssr_import_0__.objRest)()
    "
  `)
})

test('object props and methods', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import foo from 'foo'

const bar = 'bar'

const obj = {
  foo() {},
  [foo]() {},
  [bar]() {},
  foo: () => {},
  [foo]: () => {},
  [bar]: () => {},
  bar(foo) {}
}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["default"]});



    const bar = 'bar';

    const obj = {
      foo() {},
      [__vite_ssr_import_0__.default]() {},
      [bar]() {},
      foo: () => {},
      [__vite_ssr_import_0__.default]: () => {},
      [bar]: () => {},
      bar(foo) {}
    }
    "
  `)
})

test('class props', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import { remove, add } from 'vue'

class A {
  remove = 1
  add = null
}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["remove","add"]});



    const add = __vite_ssr_import_0__.add;
    const remove = __vite_ssr_import_0__.remove;
    class A {
      remove = 1
      add = null
    }
    "
  `)
})

test('class methods', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import foo from 'foo'

const bar = 'bar'

class A {
  foo() {}
  [foo]() {}
  [bar]() {}
  #foo() {}
  bar(foo) {}
}
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["default"]});



    const bar = 'bar';

    class A {
      foo() {}
      [__vite_ssr_import_0__.default]() {}
      [bar]() {}
      #foo() {}
      bar(foo) {}
    }
    "
  `)
})

test('declare scope', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
import { aaa, bbb, ccc, ddd } from 'vue'

function foobar() {
  ddd()

  const aaa = () => {
    bbb(ccc)
    ddd()
  }
  const bbb = () => {
    console.log('hi')
  }
  const ccc = 1
  function ddd() {}

  aaa()
  bbb()
  ccc()
}

aaa()
bbb()
`,
    ),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["aaa","bbb","ccc","ddd"]});



    function foobar() {
      ddd();

      const aaa = () => {
        bbb(ccc);
        ddd()
      };
      const bbb = () => {
        console.log('hi')
      };
      const ccc = 1;
      function ddd() {}

      aaa();
      bbb();
      ccc()
    }

    (0,__vite_ssr_import_0__.aaa)();
    (0,__vite_ssr_import_0__.bbb)()
    "
  `)
})

test('jsx', async () => {
  const code = `
  import React from 'react'
  import { Foo, Slot } from 'foo'

  function Bar({ Slot = <Foo /> }) {
    return (
      <>
        <Slot />
      </>
    )
  }
  `
  const id = '/foo.jsx'
  const result = await transformWithEsbuild(code, id)
  expect(await ssrTransformSimpleCode(result.code, '/foo.jsx'))
    .toMatchInlineSnapshot(`
      "const __vite_ssr_import_0__ = await __vite_ssr_import__("react", {"importedNames":["default"]});
      const __vite_ssr_import_1__ = await __vite_ssr_import__("foo", {"importedNames":["Foo","Slot"]});


      function Bar({ Slot: Slot2 = /* @__PURE__ */ __vite_ssr_import_0__.default.createElement((0,__vite_ssr_import_1__.Foo), null) }) {
        return /* @__PURE__ */ __vite_ssr_import_0__.default.createElement(__vite_ssr_import_0__.default.Fragment, null, /* @__PURE__ */ __vite_ssr_import_0__.default.createElement(Slot2, null));
      }
      "
    `)
})

test('continuous exports', async () => {
  expect(
    await ssrTransformSimpleCode(
      `
export function fn1() {
}export function fn2() {
}
        `,
    ),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("fn1", () => { try { return fn1 } catch {} });
    __vite_ssr_exportName__("fn2", () => { try { return fn2 } catch {} });

    function fn1() {
    };function fn2() {
    }
            "
  `)
})

// https://github.com/vitest-dev/vitest/issues/1141
test('export default expression', async () => {
  // esbuild transform result of following TS code
  // export default <MyFn> function getRandom() {
  //   return Math.random()
  // }
  const code = `
export default (function getRandom() {
  return Math.random();
});
`.trim()

  expect(await ssrTransformSimpleCode(code)).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
    const __vite_ssr_export_default__ = (function getRandom() {
      return Math.random();
    });"
  `)

  expect(await ssrTransformSimpleCode(`export default (class A {});`))
    .toMatchInlineSnapshot(`
      "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
      const __vite_ssr_export_default__ = (class A {});"
    `)
})

// #8002
test('with hashbang', async () => {
  expect(
    await ssrTransformSimpleCode(
      `#!/usr/bin/env node
console.log("it can parse the hashbang")`,
    ),
  ).toMatchInlineSnapshot(`
    "#!/usr/bin/env node
    console.log("it can parse the hashbang")"
  `)
})

test('import hoisted after hashbang', async () => {
  expect(
    await ssrTransformSimpleCode(
      `#!/usr/bin/env node
console.log(foo);
import foo from "foo"`,
    ),
  ).toMatchInlineSnapshot(`
    "#!/usr/bin/env node
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["default"]});
    console.log((0,__vite_ssr_import_0__.default));
    "
  `)
})

test('identity function helper injected after hashbang', async () => {
  expect(
    await ssrTransformSimpleCode(
      `#!/usr/bin/env node
import { foo } from "foo"
foo()`,
    ),
  ).toMatchInlineSnapshot(`
    "#!/usr/bin/env node
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foo", {"importedNames":["foo"]});

    (0,__vite_ssr_import_0__.foo)()"
  `)
})

// #10289
test('track scope by class, function, condition blocks', async () => {
  const code = `
import { foo, bar } from 'foobar'
if (false) {
  const foo = 'foo'
  console.log(foo)
} else if (false) {
  const [bar] = ['bar']
  console.log(bar)
} else {
  console.log(foo)
  console.log(bar)
}
export class Test {
  constructor() {
    if (false) {
      const foo = 'foo'
      console.log(foo)
    } else if (false) {
      const [bar] = ['bar']
      console.log(bar)
    } else {
      console.log(foo)
      console.log(bar)
    }
  }
};`.trim()

  expect(await ssrTransformSimpleCode(code)).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("Test", () => { try { return Test } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("foobar", {"importedNames":["foo","bar"]});

    if (false) {
      const foo = 'foo';
      console.log(foo)
    } else if (false) {
      const [bar] = ['bar'];
      console.log(bar)
    } else {
      console.log((0,__vite_ssr_import_0__.foo));
      console.log((0,__vite_ssr_import_0__.bar))
    };
    class Test {
      constructor() {
        if (false) {
          const foo = 'foo';
          console.log(foo)
        } else if (false) {
          const [bar] = ['bar'];
          console.log(bar)
        } else {
          console.log((0,__vite_ssr_import_0__.foo));
          console.log((0,__vite_ssr_import_0__.bar))
        }
      }
    };;"
  `)
})

// #10386
test('track var scope by function', async () => {
  expect(
    await ssrTransformSimpleCode(`
import { foo, bar } from 'foobar'
function test() {
  if (true) {
    var foo = () => { var why = 'would' }, bar = 'someone'
  }
  return [foo, bar]
}`),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foobar", {"importedNames":["foo","bar"]});


    function test() {
      if (true) {
        var foo = () => { var why = 'would' }, bar = 'someone'
      };
      return [foo, bar]
    }"
  `)
})

// #11806
test('track scope by blocks', async () => {
  expect(
    await ssrTransformSimpleCode(`
import { foo, bar, baz } from 'foobar'
function test() {
  [foo];
  {
    let foo = 10;
    let bar = 10;
  }
  try {} catch (baz){ baz };
  return bar;
}`),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("foobar", {"importedNames":["foo","bar","baz"]});


    function test() {
      [__vite_ssr_import_0__.foo];
      {
        let foo = 10;
        let bar = 10;
      }
      try {} catch (baz){ baz };;
      return __vite_ssr_import_0__.bar;
    }"
  `)
})

test('track scope in for loops', async () => {
  expect(
    await ssrTransformSimpleCode(`
import { test } from './test.js'

for (const test of tests) {
  console.log(test)
}

for (let test = 0; test < 10; test++) {
  console.log(test)
}

for (const test in tests) {
  console.log(test)
}`),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./test.js", {"importedNames":["test"]});



    for (const test of tests) {
      console.log(test)
    };

    for (let test = 0; test < 10; test++) {
      console.log(test)
    };

    for (const test in tests) {
      console.log(test)
    }"
  `)
})

test('avoid binding ClassExpression', async () => {
  const result = await ssrTransformSimple(
    `
import Foo, { Bar } from './foo';

console.log(Foo, Bar);
const obj = {
  foo: class Foo {},
  bar: class Bar {}
}
const Baz = class extends Foo {}
`,
  )
  expect(result?.code).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./foo", {"importedNames":["default","Bar"]});



    console.log((0,__vite_ssr_import_0__.default), (0,__vite_ssr_import_0__.Bar));
    const obj = {
      foo: class Foo {},
      bar: class Bar {}
    };
    const Baz = class extends __vite_ssr_import_0__.default {}
    "
  `)
})

test('import assertion attribute', async () => {
  expect(
    await ssrTransformSimpleCode(`
import * as foo from './foo.json' with { type: 'json' };
import('./bar.json', { with: { type: 'json' } });
`),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./foo.json");


    __vite_ssr_dynamic_import__('./bar.json', { with: { type: 'json' } });
    "
  `)
})

test('import and export ordering', async () => {
  // Given all imported modules logs `mod ${mod}` on execution,
  // and `foo` is `bar`, the logging order should be:
  // "mod a", "mod foo", "mod b", "bar1", "bar2"
  expect(
    await ssrTransformSimpleCode(`
console.log(foo + 1)
export * from './a'
import { foo } from './foo'
export * from './b'
console.log(foo + 2)
  `),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./a");
    __vite_ssr_exportAll__(__vite_ssr_import_0__);
    ;const __vite_ssr_import_1__ = await __vite_ssr_import__("./foo", {"importedNames":["foo"]});
    const __vite_ssr_import_2__ = await __vite_ssr_import__("./b");
    __vite_ssr_exportAll__(__vite_ssr_import_2__);
    ;
    console.log(__vite_ssr_import_1__.foo + 1);



    console.log(__vite_ssr_import_1__.foo + 2)
      "
  `)
})

test('identity function is declared before used', async () => {
  expect(
    await ssrTransformSimpleCode(`
import { foo } from './foo'
export default foo()
export * as bar from './bar'
console.log(bar)
  `),
  ).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("default", () => { try { return __vite_ssr_export_default__ } catch {} });
    __vite_ssr_exportName__("bar", () => { try { return __vite_ssr_import_1__ } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("./foo", {"importedNames":["foo"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("./bar");
    ;

    const __vite_ssr_export_default__ = (0,__vite_ssr_import_0__.foo)();

    console.log(bar)
      "
  `)
})

test('repro', async () => {
  expect(
    await ssrTransformSimpleCode(`\
import 'x'
import 'y'
  `),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("x");
    const __vite_ssr_import_1__ = await __vite_ssr_import__("y");


      "
  `)
})

test('inject semicolon for (0, ...) wrapper', async () => {
  expect(
    await ssrTransformSimpleCode(`
import { f } from './f'

let x = 0;

x
f()

if (1)
  x
f()

if (1)
  x
else
  x
f()


let y = x
f()

x /*;;*/ /*;;*/
f()

function z() {
  x
  f()

  if (1) {
    x
    f()
  }
}

let a = {}
f()

let b = () => {}
f()

function c() {
}
f()

class D {
}
f()

{
  x
}
f()

switch (1) {
  case 1:
    x
    f()
    break
}

if(0){}f()

if(0){}else{}f()

switch(1){}f()

{}f(1)
`),
  ).toMatchInlineSnapshot(`
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("./f", {"importedNames":["f"]});



    let x = 0;

    x;
    (0,__vite_ssr_import_0__.f)();

    if (1)
      x;
    (0,__vite_ssr_import_0__.f)();

    if (1)
      x
    else
      x;
    (0,__vite_ssr_import_0__.f)();


    let y = x;
    (0,__vite_ssr_import_0__.f)();

    x; /*;;*/ /*;;*/
    (0,__vite_ssr_import_0__.f)();

    function z() {
      x;
      (0,__vite_ssr_import_0__.f)();

      if (1) {
        x;
        (0,__vite_ssr_import_0__.f)()
      }
    }

    let a = {};
    (0,__vite_ssr_import_0__.f)();

    let b = () => {};
    (0,__vite_ssr_import_0__.f)();

    function c() {
    }
    (0,__vite_ssr_import_0__.f)();

    class D {
    }
    (0,__vite_ssr_import_0__.f)();

    {
      x
    }
    (0,__vite_ssr_import_0__.f)();

    switch (1) {
      case 1:
        x;
        (0,__vite_ssr_import_0__.f)();
        break
    };

    if(0){};(0,__vite_ssr_import_0__.f)();

    if(0){}else{};(0,__vite_ssr_import_0__.f)();

    switch(1){};(0,__vite_ssr_import_0__.f)();

    {}(0,__vite_ssr_import_0__.f)(1)
    "
  `)
})

test('does not break minified code', async () => {
  // Based on https://unpkg.com/@headlessui/vue@1.7.23/dist/components/transitions/transition.js
  expect(
    await ssrTransformSimpleCode(
      `import O from 'a';
const c = () => {
  if(true){return}O(1,{})
}`,
    ),
  ).toMatchInlineSnapshot(
    `
    "const __vite_ssr_import_0__ = await __vite_ssr_import__("a", {"importedNames":["default"]});

    const c = () => {
      if(true){return};(0,__vite_ssr_import_0__.default)(1,{})
    }"
  `,
  )
})

test('combine mappings', async () => {
  const server = await createServer({
    configFile: false,
    envDir: false,
    logLevel: 'error',
    plugins: [
      {
        name: 'test-mappings',
        resolveId(source) {
          if (source.startsWith('virtual:test-mappings')) {
            return '\0' + source
          }
        },
        load(id) {
          if (id.startsWith('\0virtual:test-mappings')) {
            const code = `export default "test";\n`
            if (id === '\0virtual:test-mappings:empty') {
              return { code, map: { mappings: '' } }
            }
            if (id === '\0virtual:test-mappings:null') {
              return { code, map: null }
            }
          }
        },
      },
    ],
  })

  {
    const result = await server.environments.ssr.transformRequest(
      'virtual:test-mappings:empty',
    )
    expect(result?.map).toMatchInlineSnapshot(`
      {
        "mappings": "",
      }
    `)
    const mod = await server.ssrLoadModule('virtual:test-mappings:empty')
    expect(mod).toMatchInlineSnapshot(`
      {
        "default": "test",
      }
    `)
  }

  {
    const result = await server.environments.ssr.transformRequest(
      'virtual:test-mappings:null',
    )
    expect(result?.map).toMatchInlineSnapshot(`
      SourceMap {
        "file": undefined,
        "mappings": ";AAAA,mCAAc,CAAC,CAAC,IAAI,CAAC;",
        "names": [],
        "sources": [
          "virtual:test-mappings:null",
        ],
        "sourcesContent": [
          "export default "test";
      ",
        ],
        "version": 3,
      }
    `)
    const mod = await server.ssrLoadModule('virtual:test-mappings:null')
    expect(mod).toMatchInlineSnapshot(`
      {
        "default": "test",
      }
    `)
  }
})

test('deps', async () => {
  const result = await ssrTransformSimple(`\
import a from "a";
export { b } from "b";
export * from "c";
export * as d from "d";
import("e")
export * as A from "a";
`)
  expect(result?.code).toMatchInlineSnapshot(`
    "__vite_ssr_exportName__("b", () => { try { return __vite_ssr_import_1__.b } catch {} });
    __vite_ssr_exportName__("d", () => { try { return __vite_ssr_import_3__ } catch {} });
    __vite_ssr_exportName__("A", () => { try { return __vite_ssr_import_4__ } catch {} });
    const __vite_ssr_import_0__ = await __vite_ssr_import__("a", {"importedNames":["default"]});
    const __vite_ssr_import_1__ = await __vite_ssr_import__("b", {"importedNames":["b"]});
    const __vite_ssr_import_2__ = await __vite_ssr_import__("c");
    __vite_ssr_exportAll__(__vite_ssr_import_2__);
    const __vite_ssr_import_3__ = await __vite_ssr_import__("d");
    const __vite_ssr_import_4__ = await __vite_ssr_import__("a");




    __vite_ssr_dynamic_import__("e");

    "
  `)
  expect({
    deps: result?.deps,
    dynamicDeps: result?.dynamicDeps,
  }).toMatchInlineSnapshot(`
    {
      "deps": [
        "a",
        "b",
        "c",
        "d",
      ],
      "dynamicDeps": [
        "e",
      ],
    }
  `)
})



================================================
FILE: packages/vite/src/node/ssr/__tests__/__snapshots__/ssrLoadModule.spec.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`parse error 1`] = `
{
  "frame": "
Expected ";" but found "code"
1  |  invalid code
   |          ^
2  |  
",
  "id": "<root>/fixtures/errors/syntax-error.ts",
  "loc": {
    "column": 8,
    "file": "<root>/fixtures/errors/syntax-error.ts",
    "line": 1,
  },
  "message": "Transform failed with 1 error:
<root>/fixtures/errors/syntax-error.ts:1:8: ERROR: Expected ";" but found "code"",
}
`;

exports[`parse error 2`] = `
{
  "frame": "1  |  invalid code
   |          ^
2  |  ",
  "id": "/fixtures/errors/syntax-error.js",
  "loc": {
    "column": 8,
    "file": "/fixtures/errors/syntax-error.js",
    "line": 1,
  },
  "message": "Parse failure: Expected ';', '}' or <eof>
At file: /fixtures/errors/syntax-error.js:1:8",
}
`;

exports[`parse error 3`] = `
{
  "frame": "
Expected ";" but found "code"
1  |  invalid code
   |          ^
2  |  
",
  "id": "<root>/fixtures/errors/syntax-error.ts",
  "loc": {
    "column": 8,
    "file": "<root>/fixtures/errors/syntax-error.ts",
    "line": 1,
  },
  "message": "Transform failed with 1 error:
<root>/fixtures/errors/syntax-error.ts:1:8: ERROR: Expected ";" but found "code"",
}
`;

exports[`parse error 4`] = `
{
  "frame": "1  |  invalid code
   |          ^
2  |  ",
  "id": "/fixtures/errors/syntax-error.js",
  "loc": {
    "column": 8,
    "file": "/fixtures/errors/syntax-error.js",
    "line": 1,
  },
  "message": "Parse failure: Expected ';', '}' or <eof>
At file: /fixtures/errors/syntax-error.js:1:8",
}
`;



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/bundled-with-sourcemaps/bundle.js
================================================
function covered$1() {
  return 'First'
}

function uncovered$1() {
  return 'Uncovered'
}

var first = /*#__PURE__*/ Object.freeze({
  __proto__: null,
  covered: covered$1,
  uncovered: uncovered$1,
})

function covered() {
  return 'Second'
}

function uncovered() {
  return 'Uncovered'
}

var second = /*#__PURE__*/ Object.freeze({
  __proto__: null,
  covered: covered,
  uncovered: uncovered,
})

export { first, second }
//# sourceMappingURL=bundle.js.map



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/errors/syntax-error-dep.js
================================================
import './syntax-error.js'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/errors/syntax-error-dep.ts
================================================
import './syntax-error.ts'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/errors/syntax-error.js
================================================
invalid code



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/errors/syntax-error.ts
================================================
invalid code



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/file-url/test space.js
================================================
export const msg = 'works'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/file-url/test.js
================================================
export const msg = 'works'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/global/export.js
================================================
export const global = 'ok'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/global/test.js
================================================
export default global



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/json/test.json
================================================
{
  "hello": "this is json"
}



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/modules/has-error.js
================================================
throw new Error()



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/modules/has-invalid-import.js
================================================
import { foo } from './non-existent.js'

export const hello = 'world'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/modules/import-meta.js
================================================
export const dirname = import.meta.dirname
export const filename = import.meta.filename



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/multi-source-sourcemaps/dist.js
================================================
// nested-directory/nested-file.js
var nested_file_default =
  'Nested file will trigger edge case that used to break sourcemaps'

// entrypoint.js
function entrypoint() {
  console.log(nested_file_default)
  throw new Error('Hello world')
}
export { entrypoint }
//# sourceMappingURL=dist.js.map



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/multi-source-sourcemaps/entrypoint.js
================================================
/*
 * You can rebuild this with:
 * - rm -f ./dist.js ./dist.js.map
 * - npx esbuild --bundle entrypoint.js --outfile=dist.js --sourcemap --format=esm
 */

import nested from './nested-directory/nested-file'

export function entrypoint() {
  console.log(nested)
  throw new Error('Hello world')
}



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/multi-source-sourcemaps/nested-directory/nested-file.js
================================================
export default 'Nested file will trigger edge case that used to break sourcemaps'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/named-overwrite-all/dep1.js
================================================
export const a = 'dep1-a'
export const b = 'dep1-b'
export const c = 'dep1-c'
export const d = 'dep1-d'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/named-overwrite-all/dep2.js
================================================
export const d = 'dep2-d'



================================================
FILE: packages/vite/src/node/ssr/__tests__/fixtures/named-overwrite-all/main.js
================================================
export const a = 'main-a'
export * from './dep1.js'
export const c = 'main-c'
export * from './dep2.js'



================================================
FILE: packages/vite/src/node/ssr/runtime/serverModuleRunner.ts
================================================
import { existsSync, readFileSync } from 'node:fs'
import type { HotPayload } from 'types/hmrPayload'
import { ModuleRunner, createNodeImportMeta } from 'vite/module-runner'
import type {
  ModuleEvaluator,
  ModuleRunnerHmr,
  ModuleRunnerOptions,
} from 'vite/module-runner'
import type { DevEnvironment } from '../../server/environment'
import type {
  HotChannelClient,
  NormalizedServerHotChannel,
} from '../../server/hmr'
import type { ModuleRunnerTransport } from '../../../shared/moduleRunnerTransport'

/**
 * @experimental
 */
export interface ServerModuleRunnerOptions
  extends Omit<
    ModuleRunnerOptions,
    'root' | 'fetchModule' | 'hmr' | 'transport'
  > {
  /**
   * Disable HMR or configure HMR logger.
   */
  hmr?:
    | false
    | {
        logger?: ModuleRunnerHmr['logger']
      }
  /**
   * Provide a custom module evaluator. This controls how the code is executed.
   */
  evaluator?: ModuleEvaluator
}

function createHMROptions(
  environment: DevEnvironment,
  options: ServerModuleRunnerOptions,
) {
  if (environment.config.server.hmr === false || options.hmr === false) {
    return false
  }
  if (!('api' in environment.hot)) return false
  return {
    logger: options.hmr?.logger,
  }
}

const prepareStackTrace = {
  retrieveFile(id: string) {
    if (existsSync(id)) {
      return readFileSync(id, 'utf-8')
    }
  },
}

function resolveSourceMapOptions(options: ServerModuleRunnerOptions) {
  if (options.sourcemapInterceptor != null) {
    if (options.sourcemapInterceptor === 'prepareStackTrace') {
      return prepareStackTrace
    }
    if (typeof options.sourcemapInterceptor === 'object') {
      return { ...prepareStackTrace, ...options.sourcemapInterceptor }
    }
    return options.sourcemapInterceptor
  }
  if (typeof process !== 'undefined' && 'setSourceMapsEnabled' in process) {
    return 'node'
  }
  return prepareStackTrace
}

export const createServerModuleRunnerTransport = (options: {
  channel: NormalizedServerHotChannel
}): ModuleRunnerTransport => {
  const hmrClient: HotChannelClient = {
    send: (payload: HotPayload) => {
      if (payload.type !== 'custom') {
        throw new Error(
          'Cannot send non-custom events from the client to the server.',
        )
      }
      options.channel.send(payload)
    },
  }

  let handler: ((data: HotPayload) => void) | undefined

  return {
    connect({ onMessage }) {
      options.channel.api!.outsideEmitter.on('send', onMessage)
      onMessage({ type: 'connected' })
      handler = onMessage
    },
    disconnect() {
      if (handler) {
        options.channel.api!.outsideEmitter.off('send', handler)
      }
    },
    send(payload) {
      if (payload.type !== 'custom') {
        throw new Error(
          'Cannot send non-custom events from the server to the client.',
        )
      }
      options.channel.api!.innerEmitter.emit(
        payload.event,
        payload.data,
        hmrClient,
      )
    },
  }
}

/**
 * Create an instance of the Vite SSR runtime that support HMR.
 * @experimental
 */
export function createServerModuleRunner(
  environment: DevEnvironment,
  options: ServerModuleRunnerOptions = {},
): ModuleRunner {
  const hmr = createHMROptions(environment, options)
  return new ModuleRunner(
    {
      ...options,
      transport: createServerModuleRunnerTransport({
        channel: environment.hot as NormalizedServerHotChannel,
      }),
      hmr,
      createImportMeta: createNodeImportMeta,
      sourcemapInterceptor: resolveSourceMapOptions(options),
    },
    options.evaluator,
  )
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/package.json
================================================
{
  "name": "@vitejs/unit-runtime",
  "private": true,
  "version": "0.0.0",
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "dependencies": {
    "@vitejs/cjs-external": "link:./fixtures/cjs-external",
    "@vitejs/esm-external": "link:./fixtures/esm-external",
    "tinyspy": "2.2.0",
    "birpc": "^0.2.19"
  }
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-hmr.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createModuleRunnerTester } from './utils'

describe(
  'module runner hmr works as expected',
  async () => {
    const it = await createModuleRunnerTester({
      server: {
        // override watch options because it's disabled by default
        watch: {},
      },
    })

    it('hmr options are defined', async ({ runner }) => {
      expect(runner.hmrClient).toBeDefined()

      const mod = await runner.import('/fixtures/hmr.js')
      expect(mod).toHaveProperty('hmr')
      expect(mod.hmr).toHaveProperty('accept')
    })

    it('correctly populates hmr client', async ({ runner }) => {
      const mod = await runner.import('/fixtures/d')
      expect(mod.d).toBe('a')

      const fixtureC = '/fixtures/c.ts'
      const fixtureD = '/fixtures/d.ts'

      expect(runner.hmrClient!.hotModulesMap.size).toBe(2)
      expect(runner.hmrClient!.dataMap.size).toBe(2)
      expect(runner.hmrClient!.ctxToListenersMap.size).toBe(2)

      for (const fixture of [fixtureC, fixtureD]) {
        expect(runner.hmrClient!.hotModulesMap.has(fixture)).toBe(true)
        expect(runner.hmrClient!.dataMap.has(fixture)).toBe(true)
        expect(runner.hmrClient!.ctxToListenersMap.has(fixture)).toBe(true)
      }
    })
  },
  process.env.CI ? 50_00 : 5_000,
)



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-no-hmr.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createModuleRunnerTester } from './utils'

describe('module runner hmr works as expected', async () => {
  const it = await createModuleRunnerTester({
    server: {
      // override watch options because it's disabled by default
      watch: {},
      hmr: false,
    },
  })

  it("hmr client is not defined if it's disabled", async ({ runner }) => {
    expect(runner.hmrClient).toBeUndefined()

    const mod = await runner.import('/fixtures/hmr.js')
    expect(mod).toHaveProperty('hmr')
    expect(mod.hmr).toBeUndefined()
  })
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-runtime.spec.ts
================================================
import { existsSync, readdirSync } from 'node:fs'
import { posix, win32 } from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, vi } from 'vitest'
import { isWindows } from '../../../../shared/utils'
import type { ExternalFetchResult } from '../../../../shared/invokeMethods'
import { createModuleRunnerTester } from './utils'

const _URL = URL

describe('module runner initialization', async () => {
  const it = await createModuleRunnerTester({
    resolve: {
      external: ['tinyglobby'],
    },
  })

  it('correctly runs ssr code', async ({ runner }) => {
    const mod = await runner.import('/fixtures/simple.js')
    expect(mod.test).toEqual('I am initialized')

    // loads the same module if id is a file url
    const fileUrl = new _URL('./fixtures/simple.js', import.meta.url)
    const mod2 = await runner.import(fileUrl.toString())
    expect(mod).toBe(mod2)

    // loads the same module if id is a file path
    const filePath = fileURLToPath(fileUrl)
    const mod3 = await runner.import(filePath)
    expect(mod).toBe(mod3)
  })

  it('can load virtual modules as an entry point', async ({ runner }) => {
    const mod = await runner.import('virtual:test')
    expect(mod.msg).toBe('virtual')

    // already resolved id works similar to `transformRequest`
    expect(await runner.import(`\0virtual:normal`)).toMatchInlineSnapshot(`
      {
        "default": "ok",
      }
    `)

    // escaped virtual module id works
    expect(await runner.import(`/@id/__x00__virtual:normal`))
      .toMatchInlineSnapshot(`
      {
        "default": "ok",
      }
    `)

    // timestamp query works
    expect(await runner.import(`virtual:normal?t=${Date.now()}`))
      .toMatchInlineSnapshot(`
      {
        "default": "ok",
      }
    `)

    // other arbitrary queries don't work
    await expect(() =>
      runner.import('virtual:normal?abcd=1234'),
    ).rejects.toMatchObject({
      message: expect.stringContaining(
        'Failed to load url virtual:normal?abcd=1234',
      ),
    })
  })

  it('css is loaded correctly', async ({ runner }) => {
    const css = await runner.import('/fixtures/test.css')
    expect(css.default).toBe(undefined)
    const module = await runner.import('/fixtures/test.module.css')
    expect(module).toMatchObject({
      default: {
        test: expect.stringMatching(/^_test_/),
      },
      test: expect.stringMatching(/^_test_/),
    })
  })

  it('assets are loaded correctly', async ({ runner }) => {
    const assets = await runner.import('/fixtures/assets.js')
    expect(assets).toMatchObject({
      mov: '/fixtures/assets/placeholder.mov',
      txt: '/fixtures/assets/placeholder.txt',
      png: '/fixtures/assets/placeholder.png',
      webp: '/fixtures/assets/placeholder.webp',
    })
  })

  it('ids with Vite queries are loaded correctly', async ({ runner }) => {
    const raw = await runner.import('/fixtures/simple.js?raw')
    expect(raw.default).toMatchInlineSnapshot(`
      "export const test = 'I am initialized'

      import.meta.hot?.accept()
      "
    `)
    const url = await runner.import('/fixtures/simple.js?url')
    expect(url.default).toMatchInlineSnapshot(`"/fixtures/simple.js"`)
    const inline = await runner.import('/fixtures/test.css?inline')
    expect(inline.default).toMatchInlineSnapshot(`
      ".test {
        color: red;
      }
      "
    `)
  })

  it('modules with query strings are treated as different modules', async ({
    runner,
  }) => {
    const modSimple = await runner.import('/fixtures/simple.js')
    const modUrl = await runner.import('/fixtures/simple.js?url')
    expect(modSimple).not.toBe(modUrl)
    expect(modUrl.default).toBe('/fixtures/simple.js')
  })

  it('exports is not modifiable', async ({ runner }) => {
    const mod = await runner.import('/fixtures/simple.js')
    expect(Object.isSealed(mod)).toBe(true)
    expect(() => {
      mod.test = 'I am modified'
    }).toThrowErrorMatchingInlineSnapshot(
      `[TypeError: Cannot set property test of [object Module] which has only a getter]`,
    )
    expect(() => {
      delete mod.test
    }).toThrowErrorMatchingInlineSnapshot(
      `[TypeError: Cannot delete property 'test' of [object Module]]`,
    )
    expect(() => {
      Object.defineProperty(mod, 'test', { value: 'I am modified' })
    }).toThrowErrorMatchingInlineSnapshot(
      `[TypeError: Cannot redefine property: test]`,
    )
    expect(() => {
      mod.other = 'I am added'
    }).toThrowErrorMatchingInlineSnapshot(
      `[TypeError: Cannot add property other, object is not extensible]`,
    )
  })

  it('throws the same error', async ({ runner }) => {
    expect.assertions(3)
    const s = Symbol()
    try {
      await runner.import('/fixtures/has-error.js')
    } catch (e) {
      expect(e[s]).toBeUndefined()
      e[s] = true
      expect(e[s]).toBe(true)
    }

    try {
      await runner.import('/fixtures/has-error.js')
    } catch (e) {
      expect(e[s]).toBe(true)
    }
  })

  it('importing external cjs library checks exports', async ({ runner }) => {
    await expect(() => runner.import('/fixtures/cjs-external-non-existing.js'))
      .rejects.toThrowErrorMatchingInlineSnapshot(`
      [SyntaxError: [vite] Named export 'nonExisting' not found. The requested module '@vitejs/cjs-external' is a CommonJS module, which may not support all module.exports as named exports.
      CommonJS modules can always be imported via the default export, for example using:

      import pkg from '@vitejs/cjs-external';
      const {nonExisting} = pkg;
      ]
    `)
    // subsequent imports of the same external package should not throw if imports are correct
    await expect(
      runner.import('/fixtures/cjs-external-existing.js'),
    ).resolves.toMatchObject({
      result: 'world',
    })
  })

  it('importing external esm library checks exports', async ({ runner }) => {
    await expect(() =>
      runner.import('/fixtures/esm-external-non-existing.js'),
    ).rejects.toThrowErrorMatchingInlineSnapshot(
      `[SyntaxError: [vite] The requested module '@vitejs/esm-external' does not provide an export named 'nonExisting']`,
    )
    // subsequent imports of the same external package should not throw if imports are correct
    await expect(
      runner.import('/fixtures/esm-external-existing.js'),
    ).resolves.toMatchObject({
      result: 'world',
    })
  })

  it("dynamic import doesn't produce duplicates", async ({ runner }) => {
    const mod = await runner.import('/fixtures/dynamic-import.js')
    const modules = await mod.initialize()
    // toBe checks that objects are actually the same, not just structurally
    // using toEqual here would be a mistake because it check the structural difference
    expect(modules.static).toBe(modules.dynamicProcessed)
    expect(modules.static).toBe(modules.dynamicRelative)
    expect(modules.static).toBe(modules.dynamicAbsolute)
    expect(modules.static).toBe(modules.dynamicAbsoluteExtension)
    expect(modules.static).toBe(modules.dynamicAbsoluteFull)
    expect(modules.static).toBe(modules.dynamicFileUrl)
  })

  it('correctly imports a virtual module', async ({ runner }) => {
    const mod = await runner.import('/fixtures/virtual.js')
    expect(mod.msg0).toBe('virtual0')
    expect(mod.msg).toBe('virtual')
  })

  it('importing package from node_modules', async ({ runner }) => {
    const mod = (await runner.import(
      '/fixtures/installed.js',
    )) as typeof import('tinyspy')
    const fn = mod.spy()
    fn()
    expect(fn.called).toBe(true)
  })

  it('importing native node package', async ({ runner }) => {
    const mod = await runner.import('/fixtures/native.js')
    expect(mod.readdirSync).toBe(readdirSync)
    expect(mod.existsSync).toBe(existsSync)
  })

  it('correctly resolves module url', async ({ runner, server }) => {
    const { meta } = await runner.import('/fixtures/basic')
    const basicUrl = new _URL('./fixtures/basic.js', import.meta.url).toString()
    expect(meta.url).toBe(basicUrl)

    const filename = meta.filename!
    const dirname = meta.dirname!

    if (isWindows) {
      const cwd = process.cwd()
      const drive = `${cwd[0].toUpperCase()}:\\`
      const root = server.config.root.replace(/\\/g, '/')

      expect(filename.startsWith(drive)).toBe(true)
      expect(dirname.startsWith(drive)).toBe(true)

      expect(filename).toBe(win32.join(root, '.\\fixtures\\basic.js'))
      expect(dirname).toBe(win32.join(root, '.\\fixtures'))
    } else {
      const root = server.config.root

      expect(posix.join(root, './fixtures/basic.js')).toBe(filename)
      expect(posix.join(root, './fixtures')).toBe(dirname)
    }
  })

  it(`no maximum call stack error ModuleRunner.isCircularImport`, async ({
    runner,
  }) => {
    // entry.js ⇔ entry-cyclic.js
    //   ⇓
    // action.js
    const mod = await runner.import('/fixtures/cyclic/entry')
    await mod.setupCyclic()
    const action = await mod.importAction('/fixtures/cyclic/action')
    expect(action).toBeDefined()
  })

  it('this of the exported function should be undefined', async ({
    runner,
  }) => {
    const mod = await runner.import('/fixtures/no-this/importer.js')
    expect(mod.result).toBe(undefined)
  })

  it.for([
    '/fixtures/cyclic2/test1/index.js',
    '/fixtures/cyclic2/test2/index.js',
    '/fixtures/cyclic2/test3/index.js',
    '/fixtures/cyclic2/test4/index.js',
  ] as const)(`cyclic %s`, async (entry, { runner }) => {
    const mod = await runner.import(entry)
    expect({ ...mod }).toEqual({
      dep1: {
        ok: true,
      },
      dep2: {
        ok: true,
      },
    })
  })

  it(`cyclic invalid 1`, async ({ runner }) => {
    // Node also fails but with a different message
    //   $ node packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test5/index.js
    //   ReferenceError: Cannot access 'dep1' before initialization
    await expect(() =>
      runner.import('/fixtures/cyclic2/test5/index.js'),
    ).rejects.toMatchInlineSnapshot(
      `[TypeError: Cannot read properties of undefined (reading 'ok')]`,
    )
  })

  it(`cyclic invalid 2`, async ({ runner }) => {
    // It should be an error but currently `undefined` fallback.
    expect(
      await runner.import('/fixtures/cyclic2/test6/index.js'),
    ).toMatchInlineSnapshot(
      `
      {
        "dep1": "dep1: dep2: undefined",
      }
    `,
    )
  })

  it(`cyclic with mixed import and re-export`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/cyclic2/test7/Ion.js')
    expect(mod).toMatchInlineSnapshot(`
      {
        "IonTypes": {
          "BLOB": "Blob",
        },
        "dom": {
          "Blob": "Blob",
        },
      }
    `)
  })

  it(`execution order with mixed import and re-export`, async ({
    runner,
    onTestFinished,
  }) => {
    const spy = vi.spyOn(console, 'log').mockImplementation(() => {})
    onTestFinished(() => spy.mockRestore())

    await runner.import('/fixtures/execution-order-re-export/index.js')
    expect(spy.mock.calls.map((v) => v[0])).toMatchInlineSnapshot(`
      [
        "dep1",
        "dep2",
      ]
    `)
  })

  it(`live binding (export default function f)`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/live-binding/test1/index.js')
    expect(mod.default).toMatchInlineSnapshot(`
      [
        2,
        3,
      ]
    `)
  })

  it(`live binding (export default f)`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/live-binding/test2/index.js')
    expect(mod.default).toMatchInlineSnapshot(`
      [
        1,
        1,
      ]
    `)
  })

  it(`live binding (export { f as default })`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/live-binding/test3/index.js')
    expect(mod.default).toMatchInlineSnapshot(`
      [
        2,
        3,
      ]
    `)
  })

  it(`live binding (export default class C)`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/live-binding/test4/index.js')
    expect(mod.default).toMatchInlineSnapshot(`
      [
        2,
        3,
      ]
    `)
  })

  it(`export default getter is hoisted`, async ({ runner }) => {
    // Node error is `ReferenceError: Cannot access 'dep' before initialization`
    // It should be an error but currently `undefined` fallback.
    expect(
      await runner.import('/fixtures/cyclic2/test9/index.js'),
    ).toMatchInlineSnapshot(
      `
      {
        "default": undefined,
      }
    `,
    )
  })

  it(`handle Object variable`, async ({ runner }) => {
    const mod = await runner.import('/fixtures/top-level-object.js')
    expect(mod).toMatchInlineSnapshot(`
      {
        "Object": "my-object",
      }
    `)
  })
})

describe('optimize-deps', async () => {
  const it = await createModuleRunnerTester({
    cacheDir: 'node_modules/.vite-test',
    ssr: {
      noExternal: true,
      optimizeDeps: {
        include: ['@vitejs/cjs-external'],
      },
    },
  })

  it('optimized dep as entry', async ({ runner }) => {
    const mod = await runner.import('@vitejs/cjs-external')
    expect(mod.default.hello()).toMatchInlineSnapshot(`"world"`)
  })
})

describe('resolveId absolute path entry', async () => {
  const it = await createModuleRunnerTester({
    plugins: [
      {
        name: 'test-resolevId',
        enforce: 'pre',
        resolveId(source) {
          if (
            source ===
            posix.join(this.environment.config.root, 'fixtures/basic.js')
          ) {
            return '\0virtual:basic'
          }
        },
        load(id) {
          if (id === '\0virtual:basic') {
            return `export const name = "virtual:basic"`
          }
        },
      },
    ],
  })

  it('ssrLoadModule', async ({ server }) => {
    const mod = await server.ssrLoadModule(
      posix.join(server.config.root, 'fixtures/basic.js'),
    )
    expect(mod.name).toMatchInlineSnapshot(`"virtual:basic"`)
  })

  it('runner', async ({ server, runner }) => {
    const mod = await runner.import(
      posix.join(server.config.root, 'fixtures/basic.js'),
    )
    expect(mod.name).toMatchInlineSnapshot(`"virtual:basic"`)
  })
})

describe('virtual module hmr', async () => {
  let state = 'init'

  const it = await createModuleRunnerTester({
    plugins: [
      {
        name: 'test-resolevId',
        enforce: 'pre',
        resolveId(source) {
          if (source === 'virtual:test') {
            return '\0' + source
          }
        },
        load(id) {
          if (id === '\0virtual:test') {
            return `export default ${JSON.stringify(state)}`
          }
        },
      },
    ],
  })

  it('full reload', async ({ server, runner }) => {
    const mod = await runner.import('virtual:test')
    expect(mod.default).toBe('init')
    state = 'reloaded'
    server.environments.ssr.moduleGraph.invalidateAll()
    server.environments.ssr.hot.send({ type: 'full-reload' })
    await vi.waitFor(() => {
      const mod = runner.evaluatedModules.getModuleById('\0virtual:test')
      expect(mod?.exports.default).toBe('reloaded')
    })
  })

  it("the external module's ID and file are resolved correctly", async ({
    server,
    runner,
  }) => {
    await runner.import(
      posix.join(server.config.root, 'fixtures/import-external.ts'),
    )
    const moduleNode = runner.evaluatedModules.getModuleByUrl('tinyglobby')!
    const meta = moduleNode.meta as ExternalFetchResult
    if (process.platform === 'win32') {
      expect(meta.externalize).toMatch(/^file:\/\/\/\w:\//) // file:///C:/
      expect(moduleNode.id).toMatch(/^\w:\//) // C:/
      expect(moduleNode.file).toMatch(/^\w:\//) // C:/
    } else {
      expect(meta.externalize).toMatch(/^file:\/\/\//) // file:///
      expect(moduleNode.id).toMatch(/^\//) // /
      expect(moduleNode.file).toMatch(/^\//) // /
    }
  })
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-source-maps.spec.ts
================================================
import { describe, expect } from 'vitest'
import type { ViteDevServer } from '../../..'
import { createModuleRunnerTester, editFile, resolvePath } from './utils'

describe('module runner initialization', async () => {
  const it = await createModuleRunnerTester(
    {},
    {
      sourcemapInterceptor: 'prepareStackTrace',
    },
  )

  const getError = async (cb: () => void): Promise<Error> => {
    try {
      await cb()
      expect.unreachable()
    } catch (err) {
      return err
    }
  }
  const serializeStack = (server: ViteDevServer, err: Error) => {
    return err.stack!.split('\n')[1].replace(server.config.root, '<root>')
  }
  const serializeStackDeep = (server: ViteDevServer, err: Error) => {
    return err
      .stack!.split('\n')
      .map((s) => s.replace(server.config.root, '<root>'))
  }

  it('source maps are correctly applied to stack traces', async ({
    runner,
    server,
  }) => {
    expect.assertions(3)
    const topLevelError = await getError(() =>
      runner.import('/fixtures/has-error.js'),
    )
    expect(serializeStack(server, topLevelError)).toBe(
      '    at <root>/fixtures/has-error.js:2:7',
    )

    const methodError = await getError(async () => {
      const mod = await runner.import('/fixtures/throws-error-method.ts')
      mod.throwError()
    })
    expect(serializeStack(server, methodError)).toBe(
      '    at Module.throwError (<root>/fixtures/throws-error-method.ts:6:9)',
    )

    // simulate HMR
    editFile(
      resolvePath(import.meta.url, './fixtures/throws-error-method.ts'),
      (code) => '\n\n\n\n\n' + code + '\n',
    )
    runner.evaluatedModules.clear()
    server.environments.ssr.moduleGraph.invalidateAll()

    const methodErrorNew = await getError(async () => {
      const mod = await runner.import('/fixtures/throws-error-method.ts')
      mod.throwError()
    })

    expect(serializeStack(server, methodErrorNew)).toBe(
      '    at Module.throwError (<root>/fixtures/throws-error-method.ts:11:9)',
    )
  })

  it('stacktrace column on first line', async ({ runner, server }) => {
    // column is off by "use strict"
    const topLevelError = await getError(() =>
      runner.import('/fixtures/has-error-first.js'),
    )
    expect(serializeStack(server, topLevelError)).toBe(
      '    at <root>/fixtures/has-error-first.js:1:18',
    )

    const topLevelErrorTs = await getError(() =>
      runner.import('/fixtures/has-error-first-comment.ts'),
    )
    expect(serializeStack(server, topLevelErrorTs)).toBe(
      '    at <root>/fixtures/has-error-first-comment.ts:2:17',
    )
  })

  it('deep stacktrace', async ({ runner, server }) => {
    const methodError = await getError(async () => {
      const mod = await runner.import('/fixtures/has-error-deep.ts')
      mod.main()
    })
    expect(serializeStackDeep(server, methodError).slice(0, 3)).toEqual([
      'Error: crash',
      '    at crash (<root>/fixtures/has-error-deep.ts:2:9)',
      '    at Module.main (<root>/fixtures/has-error-deep.ts:6:3)',
    ])
  })

  it('should not crash when sourceMappingURL pattern appears in string literals', async ({
    runner,
    server,
  }) => {
    const mod = await runner.import('/fixtures/string-literal-sourcemap.ts')
    expect(mod.getMessage()).toBe(
      '//# sourceMappingURL=data:application/json;base64,invalidbase64',
    )
    const error = await getError(() => mod.throwError())
    expect(error.message).toBe('Test error for stacktrace')
    expect(serializeStackDeep(server, error).slice(0, 2)).toEqual([
      'Error: Test error for stacktrace',
      '    at Module.throwError (<root>/fixtures/string-literal-sourcemap.ts:11:9)',
    ])
  })
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-worker-runner.invoke.spec.ts
================================================
import { BroadcastChannel, Worker } from 'node:worker_threads'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import type { BirpcReturn } from 'birpc'
import { createBirpc } from 'birpc'
import { DevEnvironment } from '../../..'
import { type ViteDevServer, createServer } from '../../../server'

describe('running module runner inside a worker and using the ModuleRunnerTransport#invoke API', () => {
  let worker: Worker
  let server: ViteDevServer
  let rpc: BirpcReturn<
    unknown,
    { invoke: (data: any) => Promise<{ result: any } | { error: any }> }
  >
  let handleInvoke: (data: any) => Promise<{ result: any } | { error: any }>

  beforeAll(async () => {
    worker = new Worker(
      new URL('./fixtures/worker.invoke.mjs', import.meta.url),
      {
        stdout: true,
      },
    )
    await new Promise<void>((resolve, reject) => {
      worker.on('message', () => resolve())
      worker.on('error', reject)
    })
    server = await createServer({
      root: __dirname,
      logLevel: 'error',
      server: {
        middlewareMode: true,
        watch: null,
        hmr: {
          port: 9610,
        },
      },
      environments: {
        worker: {
          dev: {
            createEnvironment: (name, config) => {
              return new DevEnvironment(name, config, {
                hot: false,
              })
            },
          },
        },
      },
    })
    handleInvoke = (data: any) => server.environments.ssr.hot.handleInvoke(data)
    rpc = createBirpc(
      {
        invoke: (data: any) => handleInvoke(data),
      },
      {
        post: (data) => worker.postMessage(data),
        on: (data) => worker.on('message', data),
      },
    )
  })

  afterAll(() => {
    server.close()
    worker.terminate()
    rpc.$close()
  })

  async function run(id: string) {
    const channel = new BroadcastChannel('vite-worker:invoke')
    return new Promise<any>((resolve, reject) => {
      channel.onmessage = (event) => {
        try {
          resolve((event as MessageEvent).data)
        } catch (e) {
          reject(e)
        }
      }
      channel.postMessage({ id })
    })
  }

  it('correctly runs ssr code', async () => {
    const output = await run('./fixtures/default-string.ts')
    expect(output).toStrictEqual({
      result: 'hello world',
    })
  })

  it('triggers an error', async () => {
    handleInvoke = async () => ({ error: new Error('This is an Invoke Error') })
    const output = await run('dummy')
    expect(output).not.toHaveProperty('result')
    expect(output.error).toContain('Error: This is an Invoke Error')
  })

  it('triggers an unknown error', async () => {
    handleInvoke = async () => ({ error: 'a string instead of an error' })
    const output = await run('dummy')
    expect(output).not.toHaveProperty('result')
    expect(output.error).toContain('Error: Unknown invoke error')
  })
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/server-worker-runner.spec.ts
================================================
import { BroadcastChannel, Worker } from 'node:worker_threads'
import { describe, expect, it, onTestFinished } from 'vitest'
import type { HotChannel, HotChannelListener, HotPayload } from 'vite'
import { DevEnvironment } from '../../..'
import { createServer } from '../../../server'

const createWorkerTransport = (w: Worker): HotChannel => {
  const handlerToWorkerListener = new WeakMap<
    HotChannelListener,
    (value: HotPayload) => void
  >()

  return {
    send: (data) => w.postMessage(data),
    on: (event: string, handler: HotChannelListener) => {
      if (event === 'connection') return

      const listener = (value: HotPayload) => {
        if (value.type === 'custom' && value.event === event) {
          const client = {
            send(payload: HotPayload) {
              w.postMessage(payload)
            },
          }
          handler(value.data, client)
        }
      }
      handlerToWorkerListener.set(handler, listener)
      w.on('message', listener)
    },
    off: (event, handler: HotChannelListener) => {
      if (event === 'connection') return
      const listener = handlerToWorkerListener.get(handler)
      if (listener) {
        w.off('message', listener)
        handlerToWorkerListener.delete(handler)
      }
    },
  }
}

describe('running module runner inside a worker', () => {
  it('correctly runs ssr code', async () => {
    expect.assertions(1)
    const worker = new Worker(
      new URL('./fixtures/worker.mjs', import.meta.url),
      {
        stdout: true,
      },
    )
    await new Promise<void>((resolve, reject) => {
      worker.on('message', () => resolve())
      worker.on('error', reject)
    })
    const server = await createServer({
      root: __dirname,
      logLevel: 'error',
      server: {
        middlewareMode: true,
        watch: null,
        hmr: {
          port: 9609,
        },
      },
      environments: {
        worker: {
          dev: {
            createEnvironment: (name, config) => {
              return new DevEnvironment(name, config, {
                hot: false,
                transport: createWorkerTransport(worker),
              })
            },
          },
        },
      },
    })
    onTestFinished(() => {
      server.close()
      worker.terminate()
    })
    const channel = new BroadcastChannel('vite-worker')
    return new Promise<void>((resolve, reject) => {
      channel.onmessage = (event) => {
        try {
          expect((event as MessageEvent).data).toEqual({
            result: 'hello world',
          })
        } catch (e) {
          reject(e)
        } finally {
          resolve()
        }
      }
      channel.postMessage({ id: './fixtures/default-string.ts' })
    })
  })
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/utils.ts
================================================
import fs from 'node:fs'
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import type { TestAPI } from 'vitest'
import { afterEach, beforeEach, test } from 'vitest'
import type { ModuleRunner } from 'vite/module-runner'
import type { ServerModuleRunnerOptions } from '../serverModuleRunner'
import type { ViteDevServer } from '../../../server'
import type { InlineConfig } from '../../../config'
import { createServer } from '../../../server'
import { createServerModuleRunner } from '../serverModuleRunner'
import type { DevEnvironment } from '../../../server/environment'

interface TestClient {
  server: ViteDevServer
  runner: ModuleRunner
  environment: DevEnvironment
}

export async function createModuleRunnerTester(
  config: InlineConfig = {},
  runnerConfig: ServerModuleRunnerOptions = {},
): Promise<TestAPI<TestClient>> {
  function waitForWatcher(server: ViteDevServer) {
    return new Promise<void>((resolve) => {
      if ((server.watcher as any)._readyEmitted) {
        resolve()
      } else {
        server.watcher.once('ready', () => resolve())
      }
    })
  }

  beforeEach<TestClient>(async (t) => {
    // @ts-ignore
    globalThis.__HMR__ = {}

    t.server = await createServer({
      root: __dirname,
      logLevel: 'error',
      server: {
        middlewareMode: true,
        watch: null,
        ws: false,
      },
      ssr: {
        external: ['@vitejs/cjs-external', '@vitejs/esm-external'],
      },
      optimizeDeps: {
        disabled: true,
        noDiscovery: true,
        include: [],
      },
      plugins: [
        {
          name: 'vite-plugin-virtual',
          resolveId(id) {
            if (id === 'virtual0:test') {
              return `\0virtual:test`
            }
            if (id === 'virtual:test') {
              return 'virtual:test'
            }
            if (id === 'virtual:normal') {
              return '\0' + id
            }
          },
          load(id) {
            if (id === `\0virtual:test`) {
              return `export const msg = 'virtual0'`
            }
            if (id === `virtual:test`) {
              return `export const msg = 'virtual'`
            }
            if (id === '\0virtual:normal') {
              return 'export default "ok"'
            }
          },
        },
        ...(config.plugins ?? []),
      ],
      ...config,
    })
    t.environment = t.server.environments.ssr
    t.runner = createServerModuleRunner(t.environment, {
      hmr: {
        logger: false,
      },
      // don't override by default so Vitest source maps are correct
      sourcemapInterceptor: false,
      ...runnerConfig,
    })
    if (config.server?.watch) {
      await waitForWatcher(t.server)
    }
  })

  afterEach<TestClient>(async (t) => {
    await t.runner.close()
    await t.server.close()
  })

  return test as TestAPI<TestClient>
}

const originalFiles = new Map<string, string>()
const createdFiles = new Set<string>()
afterEach(() => {
  originalFiles.forEach((content, file) => {
    fs.writeFileSync(file, content, 'utf-8')
  })
  createdFiles.forEach((file) => {
    if (fs.existsSync(file)) fs.unlinkSync(file)
  })
  originalFiles.clear()
  createdFiles.clear()
})

export function createFile(file: string, content: string): void {
  createdFiles.add(file)
  fs.mkdirSync(dirname(file), { recursive: true })
  fs.writeFileSync(file, content, 'utf-8')
}

export function editFile(
  file: string,
  callback: (content: string) => string,
): void {
  const content = fs.readFileSync(file, 'utf-8')
  if (!originalFiles.has(file)) originalFiles.set(file, content)
  fs.writeFileSync(file, callback(content), 'utf-8')
}

export function resolvePath(baseUrl: string, path: string): string {
  const filename = fileURLToPath(baseUrl)
  return resolve(dirname(filename), path).replace(/\\/g, '/')
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/a.ts
================================================
export const a = 'a'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/assets.js
================================================
export { default as mov } from './assets/placeholder.mov'
export { default as txt } from './assets/placeholder.txt'
export { default as png } from './assets/placeholder.png'
export { default as webp } from './assets/placeholder.webp'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/b.ts
================================================
export const b = 'b'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/basic.js
================================================
export const name = 'basic'

export const meta = import.meta



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/c.ts
================================================
export { a as c } from './a'

import.meta.hot?.accept(() => {
  console.log('accept c')
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cjs-external-existing.js
================================================
import { hello } from '@vitejs/cjs-external'

export const result = hello()



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cjs-external-non-existing.js
================================================
import { nonExisting } from '@vitejs/cjs-external'

console.log(nonExisting)



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/d.ts
================================================
export { c as d } from './c'

import.meta.hot?.accept(() => {
  console.log('accept d')
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/default-string.ts
================================================
const str: string = 'hello world'

export default str



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/dynamic-import.js
================================================
import path from 'node:path'
import * as staticModule from './simple'
import { pathToFileURL } from 'node:url'

export const initialize = async () => {
  const nameRelative = './simple'
  const nameAbsolute = '/fixtures/simple'
  const nameAbsoluteExtension = '/fixtures/simple.js'
  const absolutePath = path.join(import.meta.dirname, 'simple.js')
  const fileUrl = pathToFileURL(absolutePath)
  return {
    dynamicProcessed: await import('./simple'),
    dynamicRelative: await import(nameRelative),
    dynamicAbsolute: await import(nameAbsolute),
    dynamicAbsoluteExtension: await import(nameAbsoluteExtension),
    dynamicAbsoluteFull: await import(
      (process.platform === 'win32' ? '/@fs/' : '') + absolutePath
    ),
    dynamicFileUrl: await import(fileUrl),
    static: staticModule,
  }
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/esm-external-existing.js
================================================
import { hello } from '@vitejs/esm-external'

export const result = hello()



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/esm-external-non-existing.js
================================================
import { nonExisting } from '@vitejs/esm-external'

console.log(nonExisting)



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/has-error-deep.ts
================================================
function crash(message: string) {
  throw new Error(message)
}

export function main(): void {
  crash('crash')
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/has-error-first-comment.ts
================================================
// comment
throw new Error('__TEST__')



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/has-error-first.js
================================================
throw new Error('__TEST__')



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/has-error.js
================================================
// comment
throw new Error('module error')



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/hmr.js
================================================
export const hmr = import.meta.hot



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/import-external.ts
================================================
import 'tinyglobby'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/installed.js
================================================
export * from 'tinyspy'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/native.js
================================================
export { existsSync } from 'node:fs'
// eslint-disable-next-line n/prefer-node-protocol -- testing that importing without node prefix works
export { readdirSync } from 'fs'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/simple.js
================================================
export const test = 'I am initialized'

import.meta.hot?.accept()



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/string-literal-sourcemap.ts
================================================
// This file contains sourceMappingURL pattern in string literals
// which should not crash the module runner

const text = '//# sourceMappingURL=data:application/json;base64,invalidbase64'

export function getMessage() {
  return text
}

export function throwError() {
  throw new Error('Test error for stacktrace')
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/test.css
================================================
.test {
  color: red;
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/test.module.css
================================================
.test {
  color: red;
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/throws-error-method.ts
================================================
interface Foo {
  bar: string
}

export function throwError(foo?: Foo): void {
  throw new Error('method error')
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/top-level-object.js
================================================
const Object = 'my-object'
export { Object }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/virtual.js
================================================
import { msg as msg0 } from 'virtual0:test'
import { msg } from 'virtual:test'

export { msg0, msg }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/worker.invoke.mjs
================================================
// @ts-check

import { BroadcastChannel, parentPort } from 'node:worker_threads'
import {
  ESModulesEvaluator,
  ModuleRunner,
  createNodeImportMeta,
} from 'vite/module-runner'
import { createBirpc } from 'birpc'

if (!parentPort) {
  throw new Error('File "worker.js" must be run in a worker thread')
}

/** @type {import('worker_threads').MessagePort} */
const pPort = parentPort

/** @type {import('birpc').BirpcReturn<{ invoke: (data: any) => any }>} */
const rpc = createBirpc(
  {},
  {
    post: (data) => pPort.postMessage(data),
    on: (data) => pPort.on('message', data),
  },
)

const runner = new ModuleRunner(
  {
    transport: {
      invoke(data) {
        return rpc.invoke(data)
      },
    },
    createImportMeta: createNodeImportMeta,
    hmr: false,
  },
  new ESModulesEvaluator(),
)

const channel = new BroadcastChannel('vite-worker:invoke')
channel.onmessage = async (message) => {
  try {
    const mod = await runner.import(message.data.id)
    channel.postMessage({ result: mod.default })
  } catch (e) {
    channel.postMessage({ error: e.stack })
  }
}
parentPort.postMessage('ready')



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/worker.mjs
================================================
// @ts-check

import { BroadcastChannel, parentPort } from 'node:worker_threads'
import {
  ESModulesEvaluator,
  ModuleRunner,
  createNodeImportMeta,
} from 'vite/module-runner'

if (!parentPort) {
  throw new Error('File "worker.js" must be run in a worker thread')
}

/** @type {import('worker_threads').MessagePort} */
const pPort = parentPort

/** @type {import('vite/module-runner').ModuleRunnerTransport} */
const messagePortTransport = {
  connect({ onMessage, onDisconnection }) {
    pPort.on('message', onMessage)
    pPort.on('close', onDisconnection)
  },
  send(data) {
    pPort.postMessage(data)
  },
}

const runner = new ModuleRunner(
  {
    transport: messagePortTransport,
    createImportMeta: createNodeImportMeta,
  },
  new ESModulesEvaluator(),
)

const channel = new BroadcastChannel('vite-worker')
channel.onmessage = async (message) => {
  try {
    const mod = await runner.import(message.data.id)
    channel.postMessage({ result: mod.default })
  } catch (e) {
    channel.postMessage({ error: e.stack })
  }
}
parentPort.postMessage('ready')



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/assets/placeholder.txt
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/assets/placeholder.webp
================================================
[Empty file]


================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/circular/circular-a.js
================================================
export { b } from './circular-b'
export const a = 'a'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/circular/circular-b.js
================================================
export { a } from './circular-a'
export const b = 'b'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/circular/circular-index.js
================================================
export { a } from './circular-a'
export { b } from './circular-b'

// since there is no .accept, it does full reload
import.meta.hot.on('vite:beforeFullReload', () => {
  console.log('full reload')
})



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cjs-external/index.cjs
================================================
module.exports = {
  hello: () => 'world',
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cjs-external/package.json
================================================
{
  "name": "@vitejs/cjs-external",
  "private": true,
  "version": "0.0.0",
  "type": "commonjs",
  "main": "index.cjs"
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic/action.js
================================================
export function someAction() {}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic/entry-cyclic.js
================================================
export default async function main() {
  await import('./entry.js')
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic/entry.js
================================================
export async function setupCyclic() {
  const mod = await import('./entry-cyclic.js')
  await mod.default()
}

export async function importAction(id) {
  return await import(/* @vite-ignore */ id)
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/README.md
================================================
- `test1` - `test5`

Cyclic import example based on https://github.com/vitejs/vite/issues/14048#issuecomment-2354774156

```mermaid
flowchart TD
    B(dep1.js) -->|dep1| A(index.js)
    A -->|dep1| C(dep2.js)
    C -->|dep2| A
    A -->|dep1, dep2| entry.js
```

---

- `test6`

```mermaid
flowchart TD
    A(dep1.js) -->|dep1| B
    B(dep2.js) -->|dep2| A
    A -->|dep1| C(index.js)
```



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/package.json
================================================
{
  "type": "module"
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test1/dep1.js
================================================
export const dep1 = { ok: true }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test1/dep2.js
================================================
import { dep1 } from './index.js'
export const dep2 = { ok: dep1.ok }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test1/index.js
================================================
import { dep1 } from './dep1.js'
export { dep1 }

import { dep2 } from './dep2.js'
export { dep2 }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test2/dep1.js
================================================
export const dep1 = { ok: true }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test2/dep2.js
================================================
import { dep1 } from './index.js'
export const dep2 = { ok: dep1.ok }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test2/index.js
================================================
export { dep1 } from './dep1.js'
export { dep2 } from './dep2.js'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test3/dep1.js
================================================
export const dep1 = { ok: true }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test3/dep2.js
================================================
import { dep1 } from './index.js'
export const dep2 = { ok: dep1.ok }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test3/index.js
================================================
import { dep1 } from './dep1.js'
import { dep2 } from './dep2.js'
export { dep1 }
export { dep2 }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test4/dep1.js
================================================
export const dep1 = { ok: true }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test4/dep2.js
================================================
import { dep1 } from './index.js'
export const dep2 = { ok: dep1.ok }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test4/index.js
================================================
export * from './dep1.js'
export * from './dep2.js'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test5/dep1.js
================================================
export const dep1 = { ok: true }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test5/dep2.js
================================================
import { dep1 } from './index.js'
export const dep2 = { ok: dep1.ok }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test5/index.js
================================================
import { dep2 } from './dep2.js'
export { dep2 }

import { dep1 } from './dep1.js'
export { dep1 }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test6/dep1.js
================================================
import { dep2 } from './dep2.js'
export const dep1 = 'dep1: ' + dep2



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test6/dep2.js
================================================
import { dep1 } from './dep1.js'
export const dep2 = 'dep2: ' + dep1



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test6/index.js
================================================
import { dep1 } from './dep1.js'
export { dep1 }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test7/README.md
================================================
reproduction from https://github.com/vitest-dev/vitest/issues/4143#issuecomment-1724526796



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test7/Ion.js
================================================
export { IonTypes } from './IonTypes.js'
import * as dom from './dom/index.js'
export { dom }



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test7/IonTypes.js
================================================
export const IonTypes = {
  BLOB: 'Blob',
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test7/dom/Blob.js
================================================
import { IonTypes } from '../Ion.js'
export const Blob = IonTypes.BLOB



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test7/dom/index.js
================================================
export { Blob } from './Blob.js'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test9/dep.js
================================================
import dep from './index.js'
export default dep



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/cyclic2/test9/index.js
================================================
import dep from './dep.js'
export default dep



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/esm-external/index.mjs
================================================
export const hello = () => 'world'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/esm-external/package.json
================================================
{
  "name": "@vitejs/esm-external",
  "private": true,
  "type": "module",
  "version": "0.0.0",
  "main": "index.mjs"
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/execution-order-re-export/dep1.js
================================================
console.log('dep1')
export {}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/execution-order-re-export/dep2.js
================================================
console.log('dep2')
export {}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/execution-order-re-export/index.js
================================================
export * from './dep1.js'
import './dep2.js'



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/package.json
================================================
{
  "type": "module"
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test1/dep.js
================================================
export default function f() {
  return 0
}

f = () => 1

f = () => 2

export function update() {
  f = () => 3
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test1/index.js
================================================
import f, { update } from './dep.js'

const x = f()
update()
const y = f()
export default [x, y]



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test2/dep.js
================================================
function f() {
  return 0
}

f = () => 1

export default f

f = () => 2

export function update() {
  f = () => 3
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test2/index.js
================================================
import f, { update } from './dep.js'

const x = f()
update()
const y = f()
export default [x, y]



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test3/dep.js
================================================
function f() {
  return 0
}

f = () => 1

export { f as default }

f = () => 2

export function update() {
  f = () => 3
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test3/index.js
================================================
import f, { update } from './dep.js'

const x = f()
update()
const y = f()
export default [x, y]



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test4/dep.js
================================================
export default class C {
  static f = () => 0
}

C = class {
  static f = () => 1
}

C = class {
  static f = () => 2
}

export function update() {
  C = class {
    static f = () => 3
  }
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/live-binding/test4/index.js
================================================
import C, { update } from './dep.js'

const x = C.f()
update()
const y = C.f()
export default [x, y]



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/no-this/importee.js
================================================
export function foo() {
  return this
}



================================================
FILE: packages/vite/src/node/ssr/runtime/__tests__/fixtures/no-this/importer.js
================================================
import { foo } from './importee.js'

export const result = foo()



================================================
FILE: packages/vite/src/shared/constants.ts
================================================
/**
 * Prefix for resolved Ids that are not valid browser import specifiers
 */
export const VALID_ID_PREFIX = `/@id/`

/**
 * Plugins that use 'virtual modules' (e.g. for helper functions), prefix the
 * module ID with `\0`, a convention from the rollup ecosystem.
 * This prevents other plugins from trying to process the id (like node resolution),
 * and core features like sourcemaps can use this info to differentiate between
 * virtual modules and regular files.
 * `\0` is not a permitted char in import URLs so we have to replace them during
 * import analysis. The id will be decoded back before entering the plugins pipeline.
 * These encoded virtual ids are also prefixed by the VALID_ID_PREFIX, so virtual
 * modules in the browser end up encoded as `/@id/__x00__{id}`
 */
export const NULL_BYTE_PLACEHOLDER = `__x00__`

export let SOURCEMAPPING_URL = 'sourceMa'
SOURCEMAPPING_URL += 'ppingURL'

export const MODULE_RUNNER_SOURCEMAPPING_SOURCE =
  '//# sourceMappingSource=vite-generated'

export const ERR_OUTDATED_OPTIMIZED_DEP = 'ERR_OUTDATED_OPTIMIZED_DEP'



================================================
FILE: packages/vite/src/shared/hmr.ts
================================================
import type { HotPayload, Update } from 'types/hmrPayload'
import type { ModuleNamespace, ViteHotContext } from 'types/hot'
import type { InferCustomEventPayload } from 'types/customEvent'
import type { NormalizedModuleRunnerTransport } from './moduleRunnerTransport'

type CustomListenersMap = Map<string, ((data: any) => void)[]>

interface HotModule {
  id: string
  callbacks: HotCallback[]
}

interface HotCallback {
  // the dependencies must be fetchable paths
  deps: string[]
  fn: (modules: Array<ModuleNamespace | undefined>) => void
}

export interface HMRLogger {
  error(msg: string | Error): void
  debug(...msg: unknown[]): void
}

export class HMRContext implements ViteHotContext {
  private newListeners: CustomListenersMap

  constructor(
    private hmrClient: HMRClient,
    private ownerPath: string,
  ) {
    if (!hmrClient.dataMap.has(ownerPath)) {
      hmrClient.dataMap.set(ownerPath, {})
    }

    // when a file is hot updated, a new context is created
    // clear its stale callbacks
    const mod = hmrClient.hotModulesMap.get(ownerPath)
    if (mod) {
      mod.callbacks = []
    }

    // clear stale custom event listeners
    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath)
    if (staleListeners) {
      for (const [event, staleFns] of staleListeners) {
        const listeners = hmrClient.customListenersMap.get(event)
        if (listeners) {
          hmrClient.customListenersMap.set(
            event,
            listeners.filter((l) => !staleFns.includes(l)),
          )
        }
      }
    }

    this.newListeners = new Map()
    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners)
  }

  get data(): any {
    return this.hmrClient.dataMap.get(this.ownerPath)
  }

  accept(deps?: any, callback?: any): void {
    if (typeof deps === 'function' || !deps) {
      // self-accept: hot.accept(() => {})
      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod))
    } else if (typeof deps === 'string') {
      // explicit deps
      this.acceptDeps([deps], ([mod]) => callback?.(mod))
    } else if (Array.isArray(deps)) {
      this.acceptDeps(deps, callback)
    } else {
      throw new Error(`invalid hot.accept() usage.`)
    }
  }

  // export names (first arg) are irrelevant on the client side, they're
  // extracted in the server for propagation
  acceptExports(
    _: string | readonly string[],
    callback?: (data: any) => void,
  ): void {
    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod))
  }

  dispose(cb: (data: any) => void): void {
    this.hmrClient.disposeMap.set(this.ownerPath, cb)
  }

  prune(cb: (data: any) => void): void {
    this.hmrClient.pruneMap.set(this.ownerPath, cb)
  }

  // Kept for backward compatibility (#11036)
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  decline(): void {}

  invalidate(message: string): void {
    const firstInvalidatedBy =
      this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath
    this.hmrClient.notifyListeners('vite:invalidate', {
      path: this.ownerPath,
      message,
      firstInvalidatedBy,
    })
    this.send('vite:invalidate', {
      path: this.ownerPath,
      message,
      firstInvalidatedBy,
    })
    this.hmrClient.logger.debug(
      `invalidate ${this.ownerPath}${message ? `: ${message}` : ''}`,
    )
  }

  on<T extends string>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void {
    const addToMap = (map: Map<string, any[]>) => {
      const existing = map.get(event) || []
      existing.push(cb)
      map.set(event, existing)
    }
    addToMap(this.hmrClient.customListenersMap)
    addToMap(this.newListeners)
  }

  off<T extends string>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void {
    const removeFromMap = (map: Map<string, any[]>) => {
      const existing = map.get(event)
      if (existing === undefined) {
        return
      }
      const pruned = existing.filter((l) => l !== cb)
      if (pruned.length === 0) {
        map.delete(event)
        return
      }
      map.set(event, pruned)
    }
    removeFromMap(this.hmrClient.customListenersMap)
    removeFromMap(this.newListeners)
  }

  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void {
    this.hmrClient.send({ type: 'custom', event, data })
  }

  private acceptDeps(
    deps: string[],
    callback: HotCallback['fn'] = () => {},
  ): void {
    const mod: HotModule = this.hmrClient.hotModulesMap.get(this.ownerPath) || {
      id: this.ownerPath,
      callbacks: [],
    }
    mod.callbacks.push({
      deps,
      fn: callback,
    })
    this.hmrClient.hotModulesMap.set(this.ownerPath, mod)
  }
}

export class HMRClient {
  public hotModulesMap = new Map<string, HotModule>()
  public disposeMap = new Map<string, (data: any) => void | Promise<void>>()
  public pruneMap = new Map<string, (data: any) => void | Promise<void>>()
  public dataMap = new Map<string, any>()
  public customListenersMap: CustomListenersMap = new Map()
  public ctxToListenersMap = new Map<string, CustomListenersMap>()
  public currentFirstInvalidatedBy: string | undefined

  constructor(
    public logger: HMRLogger,
    private transport: NormalizedModuleRunnerTransport,
    // This allows implementing reloading via different methods depending on the environment
    private importUpdatedModule: (update: Update) => Promise<ModuleNamespace>,
  ) {}

  public async notifyListeners<T extends string>(
    event: T,
    data: InferCustomEventPayload<T>,
  ): Promise<void>
  public async notifyListeners(event: string, data: any): Promise<void> {
    const cbs = this.customListenersMap.get(event)
    if (cbs) {
      await Promise.allSettled(cbs.map((cb) => cb(data)))
    }
  }

  public send(payload: HotPayload): void {
    this.transport.send(payload).catch((err) => {
      this.logger.error(err)
    })
  }

  public clear(): void {
    this.hotModulesMap.clear()
    this.disposeMap.clear()
    this.pruneMap.clear()
    this.dataMap.clear()
    this.customListenersMap.clear()
    this.ctxToListenersMap.clear()
  }

  // After an HMR update, some modules are no longer imported on the page
  // but they may have left behind side effects that need to be cleaned up
  // (e.g. style injections)
  public async prunePaths(paths: string[]): Promise<void> {
    await Promise.all(
      paths.map((path) => {
        const disposer = this.disposeMap.get(path)
        if (disposer) return disposer(this.dataMap.get(path))
      }),
    )
    paths.forEach((path) => {
      const fn = this.pruneMap.get(path)
      if (fn) {
        fn(this.dataMap.get(path))
      }
    })
  }

  protected warnFailedUpdate(err: Error, path: string | string[]): void {
    if (!(err instanceof Error) || !err.message.includes('fetch')) {
      this.logger.error(err)
    }
    this.logger.error(
      `Failed to reload ${path}. ` +
        `This could be due to syntax errors or importing non-existent ` +
        `modules. (see errors above)`,
    )
  }

  private updateQueue: Promise<(() => void) | undefined>[] = []
  private pendingUpdateQueue = false

  /**
   * buffer multiple hot updates triggered by the same src change
   * so that they are invoked in the same order they were sent.
   * (otherwise the order may be inconsistent because of the http request round trip)
   */
  public async queueUpdate(payload: Update): Promise<void> {
    this.updateQueue.push(this.fetchUpdate(payload))
    if (!this.pendingUpdateQueue) {
      this.pendingUpdateQueue = true
      await Promise.resolve()
      this.pendingUpdateQueue = false
      const loading = [...this.updateQueue]
      this.updateQueue = []
      ;(await Promise.all(loading)).forEach((fn) => fn && fn())
    }
  }

  private async fetchUpdate(update: Update): Promise<(() => void) | undefined> {
    const { path, acceptedPath, firstInvalidatedBy } = update
    const mod = this.hotModulesMap.get(path)
    if (!mod) {
      // In a code-splitting project,
      // it is common that the hot-updating module is not loaded yet.
      // https://github.com/vitejs/vite/issues/721
      return
    }

    let fetchedModule: ModuleNamespace | undefined
    const isSelfUpdate = path === acceptedPath

    // determine the qualified callbacks before we re-import the modules
    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) =>
      deps.includes(acceptedPath),
    )

    if (isSelfUpdate || qualifiedCallbacks.length > 0) {
      const disposer = this.disposeMap.get(acceptedPath)
      if (disposer) await disposer(this.dataMap.get(acceptedPath))
      try {
        fetchedModule = await this.importUpdatedModule(update)
      } catch (e) {
        this.warnFailedUpdate(e, acceptedPath)
      }
    }

    return () => {
      try {
        this.currentFirstInvalidatedBy = firstInvalidatedBy
        for (const { deps, fn } of qualifiedCallbacks) {
          fn(
            deps.map((dep) =>
              dep === acceptedPath ? fetchedModule : undefined,
            ),
          )
        }
        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`
        this.logger.debug(`hot updated: ${loggedPath}`)
      } finally {
        this.currentFirstInvalidatedBy = undefined
      }
    }
  }
}



================================================
FILE: packages/vite/src/shared/hmrHandler.ts
================================================
import type { HotPayload } from 'types/hmrPayload'

// updates to HMR should go one after another. It is possible to trigger another update during the invalidation for example.
export function createHMRHandler(
  handler: (payload: HotPayload) => Promise<void>,
): (payload: HotPayload) => Promise<void> {
  const queue = new Queue()
  return (payload) => queue.enqueue(() => handler(payload))
}

class Queue {
  private queue: {
    promise: () => Promise<void>
    resolve: (value?: unknown) => void
    reject: (err?: unknown) => void
  }[] = []
  private pending = false

  enqueue(promise: () => Promise<void>): Promise<void> {
    return new Promise<any>((resolve, reject) => {
      this.queue.push({
        promise,
        resolve,
        reject,
      })
      this.dequeue()
    })
  }

  dequeue(): boolean {
    if (this.pending) {
      return false
    }
    const item = this.queue.shift()
    if (!item) {
      return false
    }
    this.pending = true
    item
      .promise()
      .then(item.resolve)
      .catch(item.reject)
      .finally(() => {
        this.pending = false
        this.dequeue()
      })
    return true
  }
}



================================================
FILE: packages/vite/src/shared/invokeMethods.ts
================================================
export interface FetchFunctionOptions {
  cached?: boolean
  startOffset?: number
}

export type FetchResult =
  | CachedFetchResult
  | ExternalFetchResult
  | ViteFetchResult

export interface CachedFetchResult {
  /**
   * If module cached in the runner, we can just confirm
   * it wasn't invalidated on the server side.
   */
  cache: true
}

export interface ExternalFetchResult {
  /**
   * The path to the externalized module starting with file://,
   * by default this will be imported via a dynamic "import"
   * instead of being transformed by vite and loaded with vite runner
   */
  externalize: string
  /**
   * Type of the module. Will be used to determine if import statement is correct.
   * For example, if Vite needs to throw an error if variable is not actually exported
   */
  type: 'module' | 'commonjs' | 'builtin' | 'network'
}

export interface ViteFetchResult {
  /**
   * Code that will be evaluated by vite runner
   * by default this will be wrapped in an async function
   */
  code: string
  /**
   * File path of the module on disk.
   * This will be resolved as import.meta.url/filename
   * Will be equal to `null` for virtual modules
   */
  file: string | null
  /**
   * Module ID in the server module graph.
   */
  id: string
  /**
   * Module URL used in the import.
   */
  url: string
  /**
   * Invalidate module on the client side.
   */
  invalidate: boolean
}

export type InvokeSendData<
  T extends keyof InvokeMethods = keyof InvokeMethods,
> = {
  name: T
  /** 'send' is for requests without an id */
  id: 'send' | `send:${string}`
  data: Parameters<InvokeMethods[T]>
}

export type InvokeResponseData<
  T extends keyof InvokeMethods = keyof InvokeMethods,
> = {
  name: T
  /** 'response' is for responses without an id */
  id: 'response' | `response:${string}`
  data:
    | { result: Awaited<ReturnType<InvokeMethods[T]>>; error?: undefined }
    | { result?: undefined; error: any }
}

export type InvokeMethods = {
  fetchModule: (
    id: string,
    importer?: string,
    options?: FetchFunctionOptions,
  ) => Promise<FetchResult>
}



================================================
FILE: packages/vite/src/shared/moduleRunnerTransport.ts
================================================
import { nanoid } from 'nanoid/non-secure'
import type { CustomPayload, HotPayload } from 'types/hmrPayload'
import { promiseWithResolvers } from './utils'
import type {
  InvokeMethods,
  InvokeResponseData,
  InvokeSendData,
} from './invokeMethods'

export type ModuleRunnerTransportHandlers = {
  onMessage: (data: HotPayload) => void
  onDisconnection: () => void
}

/**
 * "send and connect" or "invoke" must be implemented
 */
export interface ModuleRunnerTransport {
  connect?(handlers: ModuleRunnerTransportHandlers): Promise<void> | void
  disconnect?(): Promise<void> | void
  send?(data: HotPayload): Promise<void> | void
  invoke?(data: HotPayload): Promise<{ result: any } | { error: any }>
  timeout?: number
}

type InvokeableModuleRunnerTransport = Omit<ModuleRunnerTransport, 'invoke'> & {
  invoke<T extends keyof InvokeMethods>(
    name: T,
    data: Parameters<InvokeMethods[T]>,
  ): Promise<ReturnType<Awaited<InvokeMethods[T]>>>
}

function reviveInvokeError(e: any) {
  const error = new Error(e.message || 'Unknown invoke error')
  Object.assign(error, e, {
    // pass the whole error instead of just the stacktrace
    // so that it gets formatted nicely with console.log
    runnerError: new Error('RunnerError'),
  })
  return error
}

const createInvokeableTransport = (
  transport: ModuleRunnerTransport,
): InvokeableModuleRunnerTransport => {
  if (transport.invoke) {
    return {
      ...transport,
      async invoke(name, data) {
        const result = await transport.invoke!({
          type: 'custom',
          event: 'vite:invoke',
          data: {
            id: 'send',
            name,
            data,
          } satisfies InvokeSendData,
        } satisfies CustomPayload)
        if ('error' in result) {
          throw reviveInvokeError(result.error)
        }
        return result.result
      },
    }
  }

  if (!transport.send || !transport.connect) {
    throw new Error(
      'transport must implement send and connect when invoke is not implemented',
    )
  }

  const rpcPromises = new Map<
    string,
    {
      resolve: (data: any) => void
      reject: (data: any) => void
      name: string
      timeoutId?: ReturnType<typeof setTimeout>
    }
  >()

  return {
    ...transport,
    connect({ onMessage, onDisconnection }) {
      return transport.connect!({
        onMessage(payload) {
          if (payload.type === 'custom' && payload.event === 'vite:invoke') {
            const data = payload.data as InvokeResponseData
            if (data.id.startsWith('response:')) {
              const invokeId = data.id.slice('response:'.length)
              const promise = rpcPromises.get(invokeId)
              if (!promise) return

              if (promise.timeoutId) clearTimeout(promise.timeoutId)

              rpcPromises.delete(invokeId)

              const { error, result } = data.data
              if (error) {
                promise.reject(error)
              } else {
                promise.resolve(result)
              }
              return
            }
          }
          onMessage(payload)
        },
        onDisconnection,
      })
    },
    disconnect() {
      rpcPromises.forEach((promise) => {
        promise.reject(
          new Error(
            `transport was disconnected, cannot call ${JSON.stringify(promise.name)}`,
          ),
        )
      })
      rpcPromises.clear()
      return transport.disconnect?.()
    },
    send(data) {
      return transport.send!(data)
    },
    async invoke<T extends keyof InvokeMethods>(
      name: T,
      data: Parameters<InvokeMethods[T]>,
    ) {
      const promiseId = nanoid()
      const wrappedData: CustomPayload = {
        type: 'custom',
        event: 'vite:invoke',
        data: {
          name,
          id: `send:${promiseId}`,
          data,
        } satisfies InvokeSendData,
      }
      const sendPromise = transport.send!(wrappedData)

      const { promise, resolve, reject } =
        promiseWithResolvers<ReturnType<Awaited<InvokeMethods[T]>>>()
      const timeout = transport.timeout ?? 60000
      let timeoutId: ReturnType<typeof setTimeout> | undefined
      if (timeout > 0) {
        timeoutId = setTimeout(() => {
          rpcPromises.delete(promiseId)
          reject(
            new Error(
              `transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`,
            ),
          )
        }, timeout)
        timeoutId?.unref?.()
      }
      rpcPromises.set(promiseId, { resolve, reject, name, timeoutId })

      if (sendPromise) {
        sendPromise.catch((err) => {
          clearTimeout(timeoutId)
          rpcPromises.delete(promiseId)
          reject(err)
        })
      }

      try {
        return await promise
      } catch (err) {
        throw reviveInvokeError(err)
      }
    },
  }
}

export interface NormalizedModuleRunnerTransport {
  connect?(onMessage?: (data: HotPayload) => void): Promise<void> | void
  disconnect?(): Promise<void> | void
  send(data: HotPayload): Promise<void>
  invoke<T extends keyof InvokeMethods>(
    name: T,
    data: Parameters<InvokeMethods[T]>,
  ): Promise<ReturnType<Awaited<InvokeMethods[T]>>>
}

export const normalizeModuleRunnerTransport = (
  transport: ModuleRunnerTransport,
): NormalizedModuleRunnerTransport => {
  const invokeableTransport = createInvokeableTransport(transport)

  let isConnected = !invokeableTransport.connect
  let connectingPromise: Promise<void> | undefined

  return {
    ...(transport as Omit<ModuleRunnerTransport, 'connect'>),
    ...(invokeableTransport.connect
      ? {
          async connect(onMessage) {
            if (isConnected) return
            if (connectingPromise) {
              await connectingPromise
              return
            }

            const maybePromise = invokeableTransport.connect!({
              onMessage: onMessage ?? (() => {}),
              onDisconnection() {
                isConnected = false
              },
            })
            if (maybePromise) {
              connectingPromise = maybePromise
              await connectingPromise
              connectingPromise = undefined
            }
            isConnected = true
          },
        }
      : {}),
    ...(invokeableTransport.disconnect
      ? {
          async disconnect() {
            if (!isConnected) return
            if (connectingPromise) {
              await connectingPromise
            }
            isConnected = false
            await invokeableTransport.disconnect!()
          },
        }
      : {}),
    async send(data) {
      if (!invokeableTransport.send) return

      if (!isConnected) {
        if (connectingPromise) {
          await connectingPromise
        } else {
          throw new Error('send was called before connect')
        }
      }
      await invokeableTransport.send(data)
    },
    async invoke(name, data) {
      if (!isConnected) {
        if (connectingPromise) {
          await connectingPromise
        } else {
          throw new Error('invoke was called before connect')
        }
      }
      return invokeableTransport.invoke(name, data)
    },
  }
}

export const createWebSocketModuleRunnerTransport = (options: {
  // eslint-disable-next-line n/no-unsupported-features/node-builtins
  createConnection: () => WebSocket
  pingInterval?: number
}): Required<
  Pick<ModuleRunnerTransport, 'connect' | 'disconnect' | 'send'>
> => {
  const pingInterval = options.pingInterval ?? 30000

  // eslint-disable-next-line n/no-unsupported-features/node-builtins
  let ws: WebSocket | undefined
  let pingIntervalId: ReturnType<typeof setInterval> | undefined
  return {
    async connect({ onMessage, onDisconnection }) {
      const socket = options.createConnection()
      socket.addEventListener('message', async ({ data }) => {
        onMessage(JSON.parse(data))
      })

      let isOpened = socket.readyState === socket.OPEN
      if (!isOpened) {
        await new Promise<void>((resolve, reject) => {
          socket.addEventListener(
            'open',
            () => {
              isOpened = true
              resolve()
            },
            { once: true },
          )
          socket.addEventListener('close', async () => {
            if (!isOpened) {
              reject(new Error('WebSocket closed without opened.'))
              return
            }

            onMessage({
              type: 'custom',
              event: 'vite:ws:disconnect',
              data: { webSocket: socket },
            })
            onDisconnection()
          })
        })
      }

      onMessage({
        type: 'custom',
        event: 'vite:ws:connect',
        data: { webSocket: socket },
      })
      ws = socket

      // proxy(nginx, docker) hmr ws maybe caused timeout,
      // so send ping package let ws keep alive.
      pingIntervalId = setInterval(() => {
        if (socket.readyState === socket.OPEN) {
          socket.send(JSON.stringify({ type: 'ping' }))
        }
      }, pingInterval)
    },
    disconnect() {
      clearInterval(pingIntervalId)
      ws?.close()
    },
    send(data) {
      ws!.send(JSON.stringify(data))
    },
  }
}



================================================
FILE: packages/vite/src/shared/ssrTransform.ts
================================================
export interface DefineImportMetadata {
  /**
   * Imported names before being transformed to `ssrImportKey`
   *
   * import foo, { bar as baz, qux } from 'hello'
   * => ['default', 'bar', 'qux']
   *
   * import * as namespace from 'world
   * => undefined
   */
  importedNames?: string[]
}

export interface SSRImportMetadata extends DefineImportMetadata {
  isDynamicImport?: boolean
}

/**
 * Vite converts `import { } from 'foo'` to `const _ = __vite_ssr_import__('foo')`.
 * Top-level imports and dynamic imports work slightly differently in Node.js.
 * This function normalizes the differences so it matches prod behaviour.
 */
export function analyzeImportedModDifference(
  mod: any,
  rawId: string,
  moduleType: string | undefined,
  metadata?: SSRImportMetadata,
): void {
  // No normalization needed if the user already dynamic imports this module
  if (metadata?.isDynamicImport) return

  // If the user named imports a specifier that can't be analyzed, error.
  // If the module doesn't import anything explicitly, e.g. `import 'foo'` or
  // `import * as foo from 'foo'`, we can skip.
  if (metadata?.importedNames?.length) {
    const missingBindings = metadata.importedNames.filter((s) => !(s in mod))
    if (missingBindings.length) {
      const lastBinding = missingBindings[missingBindings.length - 1]

      // For invalid named exports only, similar to how Node.js errors for top-level imports.
      // But since we transform as dynamic imports, we need to emulate the error manually.
      if (moduleType === 'module') {
        throw new SyntaxError(
          `[vite] The requested module '${rawId}' does not provide an export named '${lastBinding}'`,
        )
      } else {
        // For non-ESM, named imports is done via static analysis with cjs-module-lexer in Node.js.
        // Copied from Node.js
        throw new SyntaxError(`\
[vite] Named export '${lastBinding}' not found. The requested module '${rawId}' is a CommonJS module, which may not support all module.exports as named exports.
CommonJS modules can always be imported via the default export, for example using:

import pkg from '${rawId}';
const {${missingBindings.join(', ')}} = pkg;
`)
      }
    }
  }
}



================================================
FILE: packages/vite/src/shared/tsconfig.json
================================================
{
  "extends": "../../tsconfig.base.json",
  "include": ["./", "../dep-types", "../types"],
  "exclude": ["**/__tests__", "**/__tests_dts__"],
  "compilerOptions": {
    "lib": ["ESNext", "DOM"],
    "stripInternal": true
  }
}



================================================
FILE: packages/vite/src/shared/utils.ts
================================================
import { NULL_BYTE_PLACEHOLDER, VALID_ID_PREFIX } from './constants'

export const isWindows =
  typeof process !== 'undefined' && process.platform === 'win32'

/**
 * Prepend `/@id/` and replace null byte so the id is URL-safe.
 * This is prepended to resolved ids that are not valid browser
 * import specifiers by the importAnalysis plugin.
 */
export function wrapId(id: string): string {
  return id.startsWith(VALID_ID_PREFIX)
    ? id
    : VALID_ID_PREFIX + id.replace('\0', NULL_BYTE_PLACEHOLDER)
}

/**
 * Undo {@link wrapId}'s `/@id/` and null byte replacements.
 */
export function unwrapId(id: string): string {
  return id.startsWith(VALID_ID_PREFIX)
    ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, '\0')
    : id
}

const windowsSlashRE = /\\/g
export function slash(p: string): string {
  return p.replace(windowsSlashRE, '/')
}

const postfixRE = /[?#].*$/
export function cleanUrl(url: string): string {
  return url.replace(postfixRE, '')
}

export function splitFileAndPostfix(path: string): {
  file: string
  postfix: string
} {
  const file = cleanUrl(path)
  return { file, postfix: path.slice(file.length) }
}

export function isPrimitive(value: unknown): boolean {
  return !value || (typeof value !== 'object' && typeof value !== 'function')
}

export function withTrailingSlash(path: string): string {
  if (path[path.length - 1] !== '/') {
    return `${path}/`
  }
  return path
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
export const AsyncFunction = async function () {}.constructor as typeof Function

// https://github.com/nodejs/node/issues/43047#issuecomment-1564068099
let asyncFunctionDeclarationPaddingLineCount: number | undefined

export function getAsyncFunctionDeclarationPaddingLineCount(): number {
  if (typeof asyncFunctionDeclarationPaddingLineCount === 'undefined') {
    const body = '/*code*/'
    const source = new AsyncFunction('a', 'b', body).toString()
    asyncFunctionDeclarationPaddingLineCount =
      source.slice(0, source.indexOf(body)).split('\n').length - 1
  }
  return asyncFunctionDeclarationPaddingLineCount
}

export interface PromiseWithResolvers<T> {
  promise: Promise<T>
  resolve: (value: T | PromiseLike<T>) => void
  reject: (reason?: any) => void
}
export function promiseWithResolvers<T>(): PromiseWithResolvers<T> {
  let resolve: any
  let reject: any
  const promise = new Promise<T>((_resolve, _reject) => {
    resolve = _resolve
    reject = _reject
  })
  return { promise, resolve, reject }
}



================================================
FILE: packages/vite/src/types/alias.d.ts
================================================
/**
Types from https://github.com/rollup/plugins/blob/master/packages/alias/types/index.d.ts
Inlined because the plugin is bundled.

https://github.com/rollup/plugins/blob/master/LICENSE

The MIT License (MIT)

Copyright (c) 2019 RollupJS Plugin Contributors (https://github.com/rollup/plugins/graphs/contributors)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

import type { PluginHooks } from 'rollup'

export interface Alias {
  find: string | RegExp
  replacement: string
  /**
   * Instructs the plugin to use an alternative resolving algorithm,
   * rather than the Rollup's resolver.
   * @default null
   */
  customResolver?: ResolverFunction | ResolverObject | null
}

export type MapToFunction<T> = T extends Function ? T : never

export type ResolverFunction = MapToFunction<PluginHooks['resolveId']>

export interface ResolverObject {
  buildStart?: PluginHooks['buildStart']
  resolveId: ResolverFunction
}

/**
 * Specifies an `Object`, or an `Array` of `Object`,
 * which defines aliases used to replace values in `import` or `require` statements.
 * With either format, the order of the entries is important,
 * in that the first defined rules are applied first.
 *
 * This is passed to \@rollup/plugin-alias as the "entries" field
 * https://github.com/rollup/plugins/tree/master/packages/alias#entries
 */
export type AliasOptions = readonly Alias[] | { [find: string]: string }



================================================
FILE: packages/vite/src/types/anymatch.d.ts
================================================
export type AnymatchFn = (testString: string) => boolean
export type AnymatchPattern = string | RegExp | AnymatchFn
type AnymatchMatcher = AnymatchPattern | AnymatchPattern[]

export { AnymatchMatcher as Matcher }



================================================
FILE: packages/vite/src/types/chokidar.d.ts
================================================
// Inlined to avoid extra dependency (chokidar is bundled in the published build)

// https://github.com/paulmillr/chokidar/blob/3.6.0/types/index.d.ts
// MIT Licensed https://github.com/paulmillr/chokidar/blob/3.6.0/LICENSE

/// <reference types="node" />

import type * as fs from 'node:fs'
import { EventEmitter } from 'node:events'
import type { Matcher } from './anymatch'

export class FSWatcher extends EventEmitter implements fs.FSWatcher {
  options: WatchOptions

  /**
   * Constructs a new FSWatcher instance with optional WatchOptions parameter.
   */
  constructor(options?: WatchOptions)

  /**
   * When called, requests that the Node.js event loop not exit so long as the fs.FSWatcher is active.
   * Calling watcher.ref() multiple times will have no effect.
   */
  ref(): this

  /**
   * When called, the active fs.FSWatcher object will not require the Node.js event loop to remain active.
   * If there is no other activity keeping the event loop running, the process may exit before the fs.FSWatcher object's callback is invoked.
   * Calling watcher.unref() multiple times will have no effect.
   */
  unref(): this

  /**
   * Add files, directories, or glob patterns for tracking. Takes an array of strings or just one
   * string.
   */
  add(paths: string | ReadonlyArray<string>): this

  /**
   * Stop watching files, directories, or glob patterns. Takes an array of strings or just one
   * string.
   */
  unwatch(paths: string | ReadonlyArray<string>): this

  /**
   * Returns an object representing all the paths on the file system being watched by this
   * `FSWatcher` instance. The object's keys are all the directories (using absolute paths unless
   * the `cwd` option was used), and the values are arrays of the names of the items contained in
   * each directory.
   */
  getWatched(): {
    [directory: string]: string[]
  }

  /**
   * Removes all listeners from watched files.
   */
  close(): Promise<void>

  on(
    event: 'add' | 'addDir' | 'change',
    listener: (path: string, stats?: fs.Stats) => void,
  ): this

  on(
    event: 'all',
    listener: (
      eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',
      path: string,
      stats?: fs.Stats,
    ) => void,
  ): this

  /**
   * Error occurred
   */
  on(event: 'error', listener: (error: Error) => void): this

  /**
   * Exposes the native Node `fs.FSWatcher events`
   */
  on(
    event: 'raw',
    listener: (eventName: string, path: string, details: any) => void,
  ): this

  /**
   * Fires when the initial scan is complete
   */
  on(event: 'ready', listener: () => void): this

  on(event: 'unlink' | 'unlinkDir', listener: (path: string) => void): this

  on(event: string, listener: (...args: any[]) => void): this
}

export interface WatchOptions {
  /**
   * Indicates whether the process should continue to run as long as files are being watched. If
   * set to `false` when using `fsevents` to watch, no more events will be emitted after `ready`,
   * even if the process continues to run.
   */
  persistent?: boolean

  /**
   * ([anymatch](https://github.com/micromatch/anymatch)-compatible definition) Defines files/paths to
   * be ignored. The whole relative or absolute path is tested, not just filename. If a function
   * with two arguments is provided, it gets called twice per path - once with a single argument
   * (the path), second time with two arguments (the path and the
   * [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object of that path).
   */
  ignored?: Matcher

  /**
   * If set to `false` then `add`/`addDir` events are also emitted for matching paths while
   * instantiating the watching as chokidar discovers these file paths (before the `ready` event).
   */
  ignoreInitial?: boolean

  /**
   * When `false`, only the symlinks themselves will be watched for changes instead of following
   * the link references and bubbling events through the link's path.
   */
  followSymlinks?: boolean

  /**
   * The base directory from which watch `paths` are to be derived. Paths emitted with events will
   * be relative to this.
   */
  cwd?: string

  /**
   * If set to true then the strings passed to .watch() and .add() are treated as literal path
   * names, even if they look like globs.
   *
   * @default false
   */
  disableGlobbing?: boolean

  /**
   * Whether to use fs.watchFile (backed by polling), or fs.watch. If polling leads to high CPU
   * utilization, consider setting this to `false`. It is typically necessary to **set this to
   * `true` to successfully watch files over a network**, and it may be necessary to successfully
   * watch files in other non-standard situations. Setting to `true` explicitly on OS X overrides
   * the `useFsEvents` default.
   */
  usePolling?: boolean

  /**
   * Whether to use the `fsevents` watching interface if available. When set to `true` explicitly
   * and `fsevents` is available this supersedes the `usePolling` setting. When set to `false` on
   * OS X, `usePolling: true` becomes the default.
   */
  useFsEvents?: boolean

  /**
   * If relying upon the [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object that
   * may get passed with `add`, `addDir`, and `change` events, set this to `true` to ensure it is
   * provided even in cases where it wasn't already available from the underlying watch events.
   */
  alwaysStat?: boolean

  /**
   * If set, limits how many levels of subdirectories will be traversed.
   */
  depth?: number

  /**
   * Interval of file system polling.
   */
  interval?: number

  /**
   * Interval of file system polling for binary files. ([see list of binary extensions](https://gi
   * thub.com/sindresorhus/binary-extensions/blob/master/binary-extensions.json))
   */
  binaryInterval?: number

  /**
   *  Indicates whether to watch files that don't have read permissions if possible. If watching
   *  fails due to `EPERM` or `EACCES` with this set to `true`, the errors will be suppressed
   *  silently.
   */
  ignorePermissionErrors?: boolean

  /**
   * `true` if `useFsEvents` and `usePolling` are `false`. Automatically filters out artifacts
   * that occur when using editors that use "atomic writes" instead of writing directly to the
   * source file. If a file is re-added within 100 ms of being deleted, Chokidar emits a `change`
   * event rather than `unlink` then `add`. If the default of 100 ms does not work well for you,
   * you can override it by setting `atomic` to a custom value, in milliseconds.
   */
  atomic?: boolean | number

  /**
   * can be set to an object in order to adjust timing params:
   */
  awaitWriteFinish?: AwaitWriteFinishOptions | boolean
}

export interface AwaitWriteFinishOptions {
  /**
   * Amount of time in milliseconds for a file size to remain constant before emitting its event.
   */
  stabilityThreshold?: number

  /**
   * File size polling interval.
   */
  pollInterval?: number
}

/**
 * produces an instance of `FSWatcher`.
 */
export function watch(
  paths: string | ReadonlyArray<string>,
  options?: WatchOptions,
): FSWatcher



================================================
FILE: packages/vite/src/types/commonjs.d.ts
================================================
/**
 * https://github.com/rollup/plugins/blob/master/packages/commonjs/types/index.d.ts
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/rollup/plugins/blob/master/LICENSE
 */
export interface RollupCommonJSOptions {
  /**
   * A minimatch pattern, or array of patterns, which specifies the files in
   * the build the plugin should operate on. By default, all files with
   * extension `".cjs"` or those in `extensions` are included, but you can
   * narrow this list by only including specific files. These files will be
   * analyzed and transpiled if either the analysis does not find ES module
   * specific statements or `transformMixedEsModules` is `true`.
   * @default undefined
   */
  include?: string | RegExp | readonly (string | RegExp)[]
  /**
   * A minimatch pattern, or array of patterns, which specifies the files in
   * the build the plugin should _ignore_. By default, all files with
   * extensions other than those in `extensions` or `".cjs"` are ignored, but you
   * can exclude additional files. See also the `include` option.
   * @default undefined
   */
  exclude?: string | RegExp | readonly (string | RegExp)[]
  /**
   * For extensionless imports, search for extensions other than .js in the
   * order specified. Note that you need to make sure that non-JavaScript files
   * are transpiled by another plugin first.
   * @default [ '.js' ]
   */
  extensions?: ReadonlyArray<string>
  /**
   * If true then uses of `global` won't be dealt with by this plugin
   * @default false
   */
  ignoreGlobal?: boolean
  /**
   * If false, skips source map generation for CommonJS modules. This will
   * improve performance.
   * @default true
   */
  sourceMap?: boolean
  /**
   * Some `require` calls cannot be resolved statically to be translated to
   * imports.
   * When this option is set to `false`, the generated code will either
   * directly throw an error when such a call is encountered or, when
   * `dynamicRequireTargets` is used, when such a call cannot be resolved with a
   * configured dynamic require target.
   * Setting this option to `true` will instead leave the `require` call in the
   * code or use it as a fallback for `dynamicRequireTargets`.
   * @default false
   */
  ignoreDynamicRequires?: boolean
  /**
   * Instructs the plugin whether to enable mixed module transformations. This
   * is useful in scenarios with modules that contain a mix of ES `import`
   * statements and CommonJS `require` expressions. Set to `true` if `require`
   * calls should be transformed to imports in mixed modules, or `false` if the
   * `require` expressions should survive the transformation. The latter can be
   * important if the code contains environment detection, or you are coding
   * for an environment with special treatment for `require` calls such as
   * ElectronJS. See also the `ignore` option.
   * @default false
   */
  transformMixedEsModules?: boolean
  /**
   * By default, this plugin will try to hoist `require` statements as imports
   * to the top of each file. While this works well for many code bases and
   * allows for very efficient ESM output, it does not perfectly capture
   * CommonJS semantics as the order of side effects like log statements may
   * change. But it is especially problematic when there are circular `require`
   * calls between CommonJS modules as those often rely on the lazy execution of
   * nested `require` calls.
   *
   * Setting this option to `true` will wrap all CommonJS files in functions
   * which are executed when they are required for the first time, preserving
   * NodeJS semantics. Note that this can have an impact on the size and
   * performance of the generated code.
   *
   * The default value of `"auto"` will only wrap CommonJS files when they are
   * part of a CommonJS dependency cycle, e.g. an index file that is required by
   * many of its dependencies. All other CommonJS files are hoisted. This is the
   * recommended setting for most code bases.
   *
   * `false` will entirely prevent wrapping and hoist all files. This may still
   * work depending on the nature of cyclic dependencies but will often cause
   * problems.
   *
   * You can also provide a minimatch pattern, or array of patterns, to only
   * specify a subset of files which should be wrapped in functions for proper
   * `require` semantics.
   *
   * `"debug"` works like `"auto"` but after bundling, it will display a warning
   * containing a list of ids that have been wrapped which can be used as
   * minimatch pattern for fine-tuning.
   * @default "auto"
   */
  strictRequires?: boolean | string | RegExp | readonly (string | RegExp)[]
  /**
   * Sometimes you have to leave require statements unconverted. Pass an array
   * containing the IDs or a `id => boolean` function.
   * @default []
   */
  ignore?: ReadonlyArray<string> | ((id: string) => boolean)
  /**
   * In most cases, where `require` calls are inside a `try-catch` clause,
   * they should be left unconverted as it requires an optional dependency
   * that may or may not be installed beside the rolled up package.
   * Due to the conversion of `require` to a static `import` - the call is
   * hoisted to the top of the file, outside the `try-catch` clause.
   *
   * - `true`: Default. All `require` calls inside a `try` will be left unconverted.
   * - `false`: All `require` calls inside a `try` will be converted as if the
   *   `try-catch` clause is not there.
   * - `remove`: Remove all `require` calls from inside any `try` block.
   * - `string[]`: Pass an array containing the IDs to left unconverted.
   * - `((id: string) => boolean|'remove')`: Pass a function that controls
   *   individual IDs.
   *
   * @default true
   */
  ignoreTryCatch?:
    | boolean
    | 'remove'
    | ReadonlyArray<string>
    | ((id: string) => boolean | 'remove')
  /**
   * Controls how to render imports from external dependencies. By default,
   * this plugin assumes that all external dependencies are CommonJS. This
   * means they are rendered as default imports to be compatible with e.g.
   * NodeJS where ES modules can only import a default export from a CommonJS
   * dependency.
   *
   * If you set `esmExternals` to `true`, this plugin assumes that all
   * external dependencies are ES modules and respect the
   * `requireReturnsDefault` option. If that option is not set, they will be
   * rendered as namespace imports.
   *
   * You can also supply an array of ids to be treated as ES modules, or a
   * function that will be passed each external id to determine whether it is
   * an ES module.
   * @default false
   */
  esmExternals?: boolean | ReadonlyArray<string> | ((id: string) => boolean)
  /**
   * Controls what is returned when requiring an ES module from a CommonJS file.
   * When using the `esmExternals` option, this will also apply to external
   * modules. By default, this plugin will render those imports as namespace
   * imports i.e.
   *
   * ```js
   * // input
   * const foo = require('foo');
   *
   * // output
   * import * as foo from 'foo';
   * ```
   *
   * However, there are some situations where this may not be desired.
   * For these situations, you can change Rollup's behaviour either globally or
   * per module. To change it globally, set the `requireReturnsDefault` option
   * to one of the following values:
   *
   * - `false`: This is the default, requiring an ES module returns its
   *   namespace. This is the only option that will also add a marker
   *   `__esModule: true` to the namespace to support interop patterns in
   *   CommonJS modules that are transpiled ES modules.
   * - `"namespace"`: Like `false`, requiring an ES module returns its
   *   namespace, but the plugin does not add the `__esModule` marker and thus
   *   creates more efficient code. For external dependencies when using
   *   `esmExternals: true`, no additional interop code is generated.
   * - `"auto"`: This is complementary to how `output.exports: "auto"` works in
   *   Rollup: If a module has a default export and no named exports, requiring
   *   that module returns the default export. In all other cases, the namespace
   *   is returned. For external dependencies when using `esmExternals: true`, a
   *   corresponding interop helper is added.
   * - `"preferred"`: If a module has a default export, requiring that module
   *   always returns the default export, no matter whether additional named
   *   exports exist. This is similar to how previous versions of this plugin
   *   worked. Again for external dependencies when using `esmExternals: true`,
   *   an interop helper is added.
   * - `true`: This will always try to return the default export on require
   *   without checking if it actually exists. This can throw at build time if
   *   there is no default export. This is how external dependencies are handled
   *   when `esmExternals` is not used. The advantage over the other options is
   *   that, like `false`, this does not add an interop helper for external
   *   dependencies, keeping the code lean.
   *
   * To change this for individual modules, you can supply a function for
   * `requireReturnsDefault` instead. This function will then be called once for
   * each required ES module or external dependency with the corresponding id
   * and allows you to return different values for different modules.
   * @default false
   */
  requireReturnsDefault?:
    | boolean
    | 'auto'
    | 'preferred'
    | 'namespace'
    | ((id: string) => boolean | 'auto' | 'preferred' | 'namespace')

  /**
   * @default "auto"
   */
  defaultIsModuleExports?: boolean | 'auto' | ((id: string) => boolean | 'auto')
  /**
   * Some modules contain dynamic `require` calls, or require modules that
   * contain circular dependencies, which are not handled well by static
   * imports. Including those modules as `dynamicRequireTargets` will simulate a
   * CommonJS (NodeJS-like) environment for them with support for dynamic
   * dependencies. It also enables `strictRequires` for those modules.
   *
   * Note: In extreme cases, this feature may result in some paths being
   * rendered as absolute in the final bundle. The plugin tries to avoid
   * exposing paths from the local machine, but if you are `dynamicRequirePaths`
   * with paths that are far away from your project's folder, that may require
   * replacing strings like `"/Users/John/Desktop/foo-project/"` -\> `"/"`.
   */
  dynamicRequireTargets?: string | ReadonlyArray<string>
  /**
   * To avoid long paths when using the `dynamicRequireTargets` option, you can use this option to specify a directory
   * that is a common parent for all files that use dynamic require statements. Using a directory higher up such as `/`
   * may lead to unnecessarily long paths in the generated code and may expose directory names on your machine like your
   * home directory name. By default, it uses the current working directory.
   */
  dynamicRequireRoot?: string
}



================================================
FILE: packages/vite/src/types/connect.d.ts
================================================
// Inlined to avoid extra dependency
// MIT Licensed https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/LICENSE

// Type definitions for connect v3.4.0
// Project: https://github.com/senchalabs/connect
// Definitions by: Maxime LUCE <https://github.com/SomaticIT>
//                 Evan Hahn <https://github.com/EvanHahn>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="node" />
import * as http from 'node:http'

export namespace Connect {
  export type ServerHandle = HandleFunction | http.Server

  export class IncomingMessage extends http.IncomingMessage {
    originalUrl?: http.IncomingMessage['url'] | undefined
  }

  export type NextFunction = (err?: any) => void

  export type SimpleHandleFunction = (
    req: IncomingMessage,
    res: http.ServerResponse,
  ) => void
  export type NextHandleFunction = (
    req: IncomingMessage,
    res: http.ServerResponse,
    next: NextFunction,
  ) => void
  export type ErrorHandleFunction = (
    err: any,
    req: IncomingMessage,
    res: http.ServerResponse,
    next: NextFunction,
  ) => void
  export type HandleFunction =
    | SimpleHandleFunction
    | NextHandleFunction
    | ErrorHandleFunction

  export interface ServerStackItem {
    route: string
    handle: ServerHandle
  }

  export interface Server extends NodeJS.EventEmitter {
    (req: http.IncomingMessage, res: http.ServerResponse, next?: Function): void

    route: string
    stack: ServerStackItem[]

    /**
     * Utilize the given middleware `handle` to the given `route`,
     * defaulting to _/_. This "route" is the mount-point for the
     * middleware, when given a value other than _/_ the middleware
     * is only effective when that segment is present in the request's
     * pathname.
     *
     * For example if we were to mount a function at _/admin_, it would
     * be invoked on _/admin_, and _/admin/settings_, however it would
     * not be invoked for _/_, or _/posts_.
     */
    use(fn: NextHandleFunction): Server
    use(fn: HandleFunction): Server
    use(route: string, fn: NextHandleFunction): Server
    use(route: string, fn: HandleFunction): Server

    /**
     * Handle server requests, punting them down
     * the middleware stack.
     */
    handle(
      req: http.IncomingMessage,
      res: http.ServerResponse,
      next: Function,
    ): void

    /**
     * Listen for connections.
     *
     * This method takes the same arguments
     * as node's `http.Server#listen()`.
     *
     * HTTP and HTTPS:
     *
     * If you run your application both as HTTP
     * and HTTPS you may wrap them individually,
     * since your Connect "server" is really just
     * a JavaScript `Function`.
     *
     *      var connect = require('connect')
     *        , http = require('http')
     *        , https = require('https');
     *
     *      var app = connect();
     *
     *      http.createServer(app).listen(80);
     *      https.createServer(options, app).listen(443);
     */
    listen(
      port: number,
      hostname?: string,
      backlog?: number,
      callback?: Function,
    ): http.Server
    listen(port: number, hostname?: string, callback?: Function): http.Server
    listen(path: string, callback?: Function): http.Server
    listen(handle: any, listeningListener?: Function): http.Server
  }
}



================================================
FILE: packages/vite/src/types/dynamicImportVars.d.ts
================================================
export interface RollupDynamicImportVarsOptions {
  /**
   * Files to include in this plugin (default all).
   * @default []
   */
  include?: string | RegExp | (string | RegExp)[]
  /**
   * Files to exclude in this plugin (default none).
   * @default []
   */
  exclude?: string | RegExp | (string | RegExp)[]
  /**
   * By default, the plugin quits the build process when it encounters an error. If you set this option to true, it will throw a warning instead and leave the code untouched.
   * @default false
   */
  warnOnError?: boolean
}



================================================
FILE: packages/vite/src/types/package.json
================================================
{
  "//": "this file is just here to make pnpm happy with --frozen-lockfile",
  "version": "0.0.0"
}



================================================
FILE: packages/vite/src/types/shims.d.ts
================================================
declare module 'connect' {
  const connect: () => any
  export = connect
}

declare module 'cors' {
  function cors(options: any): any
  export = cors
}

declare module 'launch-editor-middleware' {
  const plugin: any
  export = plugin
}

declare module 'postcss-import' {
  import type { Plugin } from 'postcss'
  const plugin: (options: {
    resolve: (
      id: string,
      basedir: string,
      importOptions: any,
    ) => string | string[] | Promise<string | string[]>
    load: (id: string) => Promise<string>
    nameLayer: (index: number, rootFilename: string) => string
  }) => Plugin
  export = plugin
}

// eslint-disable-next-line no-var
declare var __vite_profile_session: import('node:inspector').Session | undefined
// eslint-disable-next-line no-var
declare var __vite_start_time: number | undefined



================================================
FILE: packages/vite/src/types/ws.d.ts
================================================
// Modified and inlined to avoid extra dependency
// Source: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/ws/index.d.ts

// Type definitions for ws 8.5
// Project: https://github.com/websockets/ws
// Definitions by: Paul Loyd <https://github.com/loyd>
//                 Margus Lamp <https://github.com/mlamp>
//                 Philippe D'Alva <https://github.com/TitaneBoy>
//                 reduckted <https://github.com/reduckted>
//                 teidesu <https://github.com/teidesu>
//                 Bartosz Wojtkowiak <https://github.com/wojtkowiak>
//                 Kyle Hensel <https://github.com/k-yle>
//                 Samuel Skeen <https://github.com/cwadrupldijjit>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="node" />

import { EventEmitter } from 'node:events'
import type {
  Agent,
  ClientRequest,
  ClientRequestArgs,
  Server as HTTPServer,
  IncomingMessage,
  OutgoingHttpHeaders,
} from 'node:http'
import type { Server as HTTPSServer } from 'node:https'
import type { Duplex, DuplexOptions } from 'node:stream'
import type { SecureContextOptions } from 'node:tls'
import type { URL } from 'node:url'
import type { ZlibOptions } from 'node:zlib'

// WebSocket socket.
declare class WebSocket extends EventEmitter {
  /** The connection is not yet open. */
  static readonly CONNECTING: 0
  /** The connection is open and ready to communicate. */
  static readonly OPEN: 1
  /** The connection is in the process of closing. */
  static readonly CLOSING: 2
  /** The connection is closed. */
  static readonly CLOSED: 3

  binaryType: 'nodebuffer' | 'arraybuffer' | 'fragments'
  readonly bufferedAmount: number
  readonly extensions: string
  /** Indicates whether the websocket is paused */
  readonly isPaused: boolean
  readonly protocol: string
  /** The current state of the connection */
  readonly readyState:
    | typeof WebSocket.CONNECTING
    | typeof WebSocket.OPEN
    | typeof WebSocket.CLOSING
    | typeof WebSocket.CLOSED
  readonly url: string

  /** The connection is not yet open. */
  readonly CONNECTING: 0
  /** The connection is open and ready to communicate. */
  readonly OPEN: 1
  /** The connection is in the process of closing. */
  readonly CLOSING: 2
  /** The connection is closed. */
  readonly CLOSED: 3

  onopen: ((event: WebSocket.Event) => void) | null
  onerror: ((event: WebSocket.ErrorEvent) => void) | null
  onclose: ((event: WebSocket.CloseEvent) => void) | null
  onmessage: ((event: WebSocket.MessageEvent) => void) | null

  constructor(address: null)
  constructor(
    address: string | URL,
    options?: WebSocket.ClientOptions | ClientRequestArgs,
  )
  constructor(
    address: string | URL,
    protocols?: string | string[],
    options?: WebSocket.ClientOptions | ClientRequestArgs,
  )

  close(code?: number, data?: string | Buffer): void
  ping(data?: any, mask?: boolean, cb?: (err: Error) => void): void
  pong(data?: any, mask?: boolean, cb?: (err: Error) => void): void
  send(data: any, cb?: (err?: Error) => void): void
  send(
    data: any,
    options: {
      mask?: boolean | undefined
      binary?: boolean | undefined
      compress?: boolean | undefined
      fin?: boolean | undefined
    },
    cb?: (err?: Error) => void,
  ): void
  terminate(): void

  /**
   * Pause the websocket causing it to stop emitting events. Some events can still be
   * emitted after this is called, until all buffered data is consumed. This method
   * is a noop if the ready state is `CONNECTING` or `CLOSED`.
   */
  pause(): void
  /**
   * Make a paused socket resume emitting events. This method is a noop if the ready
   * state is `CONNECTING` or `CLOSED`.
   */
  resume(): void

  // HTML5 WebSocket events
  addEventListener(
    method: 'message',
    cb: (event: WebSocket.MessageEvent) => void,
    options?: WebSocket.EventListenerOptions,
  ): void
  addEventListener(
    method: 'close',
    cb: (event: WebSocket.CloseEvent) => void,
    options?: WebSocket.EventListenerOptions,
  ): void
  addEventListener(
    method: 'error',
    cb: (event: WebSocket.ErrorEvent) => void,
    options?: WebSocket.EventListenerOptions,
  ): void
  addEventListener(
    method: 'open',
    cb: (event: WebSocket.Event) => void,
    options?: WebSocket.EventListenerOptions,
  ): void

  removeEventListener(
    method: 'message',
    cb: (event: WebSocket.MessageEvent) => void,
  ): void
  removeEventListener(
    method: 'close',
    cb: (event: WebSocket.CloseEvent) => void,
  ): void
  removeEventListener(
    method: 'error',
    cb: (event: WebSocket.ErrorEvent) => void,
  ): void
  removeEventListener(
    method: 'open',
    cb: (event: WebSocket.Event) => void,
  ): void

  // Events
  on(
    event: 'close',
    listener: (this: WebSocket, code: number, reason: Buffer) => void,
  ): this
  on(event: 'error', listener: (this: WebSocket, err: Error) => void): this
  on(
    event: 'upgrade',
    listener: (this: WebSocket, request: IncomingMessage) => void,
  ): this
  on(
    event: 'message',
    listener: (
      this: WebSocket,
      data: WebSocket.RawData,
      isBinary: boolean,
    ) => void,
  ): this
  on(event: 'open', listener: (this: WebSocket) => void): this
  on(
    event: 'ping' | 'pong',
    listener: (this: WebSocket, data: Buffer) => void,
  ): this
  on(
    event: 'unexpected-response',
    listener: (
      this: WebSocket,
      request: ClientRequest,
      response: IncomingMessage,
    ) => void,
  ): this
  on(
    event: string | symbol,
    listener: (this: WebSocket, ...args: any[]) => void,
  ): this

  once(
    event: 'close',
    listener: (this: WebSocket, code: number, reason: Buffer) => void,
  ): this
  once(event: 'error', listener: (this: WebSocket, err: Error) => void): this
  once(
    event: 'upgrade',
    listener: (this: WebSocket, request: IncomingMessage) => void,
  ): this
  once(
    event: 'message',
    listener: (
      this: WebSocket,
      data: WebSocket.RawData,
      isBinary: boolean,
    ) => void,
  ): this
  once(event: 'open', listener: (this: WebSocket) => void): this
  once(
    event: 'ping' | 'pong',
    listener: (this: WebSocket, data: Buffer) => void,
  ): this
  once(
    event: 'unexpected-response',
    listener: (
      this: WebSocket,
      request: ClientRequest,
      response: IncomingMessage,
    ) => void,
  ): this
  once(
    event: string | symbol,
    listener: (this: WebSocket, ...args: any[]) => void,
  ): this

  off(
    event: 'close',
    listener: (this: WebSocket, code: number, reason: Buffer) => void,
  ): this
  off(event: 'error', listener: (this: WebSocket, err: Error) => void): this
  off(
    event: 'upgrade',
    listener: (this: WebSocket, request: IncomingMessage) => void,
  ): this
  off(
    event: 'message',
    listener: (
      this: WebSocket,
      data: WebSocket.RawData,
      isBinary: boolean,
    ) => void,
  ): this
  off(event: 'open', listener: (this: WebSocket) => void): this
  off(
    event: 'ping' | 'pong',
    listener: (this: WebSocket, data: Buffer) => void,
  ): this
  off(
    event: 'unexpected-response',
    listener: (
      this: WebSocket,
      request: ClientRequest,
      response: IncomingMessage,
    ) => void,
  ): this
  off(
    event: string | symbol,
    listener: (this: WebSocket, ...args: any[]) => void,
  ): this

  addListener(
    event: 'close',
    listener: (code: number, reason: Buffer) => void,
  ): this
  addListener(event: 'error', listener: (err: Error) => void): this
  addListener(
    event: 'upgrade',
    listener: (request: IncomingMessage) => void,
  ): this
  addListener(
    event: 'message',
    listener: (data: WebSocket.RawData, isBinary: boolean) => void,
  ): this
  addListener(event: 'open', listener: () => void): this
  addListener(event: 'ping' | 'pong', listener: (data: Buffer) => void): this
  addListener(
    event: 'unexpected-response',
    listener: (request: ClientRequest, response: IncomingMessage) => void,
  ): this
  addListener(event: string | symbol, listener: (...args: any[]) => void): this

  removeListener(
    event: 'close',
    listener: (code: number, reason: Buffer) => void,
  ): this
  removeListener(event: 'error', listener: (err: Error) => void): this
  removeListener(
    event: 'upgrade',
    listener: (request: IncomingMessage) => void,
  ): this
  removeListener(
    event: 'message',
    listener: (data: WebSocket.RawData, isBinary: boolean) => void,
  ): this
  removeListener(event: 'open', listener: () => void): this
  removeListener(event: 'ping' | 'pong', listener: (data: Buffer) => void): this
  removeListener(
    event: 'unexpected-response',
    listener: (request: ClientRequest, response: IncomingMessage) => void,
  ): this
  removeListener(
    event: string | symbol,
    listener: (...args: any[]) => void,
  ): this
}

declare const WebSocketAlias: typeof WebSocket
interface WebSocketAlias extends WebSocket {}

declare namespace WebSocket {
  /**
   * Data represents the raw message payload received over the WebSocket.
   */
  type RawData = Buffer | ArrayBuffer | Buffer[]

  /**
   * Data represents the message payload received over the WebSocket.
   */
  type Data = string | Buffer | ArrayBuffer | Buffer[]

  /**
   * CertMeta represents the accepted types for certificate & key data.
   */
  type CertMeta = string | string[] | Buffer | Buffer[]

  /**
   * VerifyClientCallbackSync is a synchronous callback used to inspect the
   * incoming message. The return value (boolean) of the function determines
   * whether or not to accept the handshake.
   */
  type VerifyClientCallbackSync = (info: {
    origin: string
    secure: boolean
    req: IncomingMessage
  }) => boolean

  /**
   * VerifyClientCallbackAsync is an asynchronous callback used to inspect the
   * incoming message. The return value (boolean) of the function determines
   * whether or not to accept the handshake.
   */
  type VerifyClientCallbackAsync = (
    info: { origin: string; secure: boolean; req: IncomingMessage },
    callback: (
      res: boolean,
      code?: number,
      message?: string,
      headers?: OutgoingHttpHeaders,
    ) => void,
  ) => void

  interface ClientOptions extends SecureContextOptions {
    protocol?: string | undefined
    followRedirects?: boolean | undefined
    generateMask?(mask: Buffer): void
    handshakeTimeout?: number | undefined
    maxRedirects?: number | undefined
    perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined
    localAddress?: string | undefined
    protocolVersion?: number | undefined
    headers?: { [key: string]: string } | undefined
    origin?: string | undefined
    agent?: Agent | undefined
    host?: string | undefined
    family?: number | undefined
    checkServerIdentity?(servername: string, cert: CertMeta): boolean
    rejectUnauthorized?: boolean | undefined
    maxPayload?: number | undefined
    skipUTF8Validation?: boolean | undefined
  }

  interface PerMessageDeflateOptions {
    serverNoContextTakeover?: boolean | undefined
    clientNoContextTakeover?: boolean | undefined
    serverMaxWindowBits?: number | undefined
    clientMaxWindowBits?: number | undefined
    zlibDeflateOptions?:
      | {
          flush?: number | undefined
          finishFlush?: number | undefined
          chunkSize?: number | undefined
          windowBits?: number | undefined
          level?: number | undefined
          memLevel?: number | undefined
          strategy?: number | undefined
          dictionary?: Buffer | Buffer[] | DataView | undefined
          info?: boolean | undefined
        }
      | undefined
    zlibInflateOptions?: ZlibOptions | undefined
    threshold?: number | undefined
    concurrencyLimit?: number | undefined
  }

  interface Event {
    type: string
    target: WebSocket
  }

  interface ErrorEvent {
    error: any
    message: string
    type: string
    target: WebSocket
  }

  interface CloseEvent {
    wasClean: boolean
    code: number
    reason: string
    type: string
    target: WebSocket
  }

  interface MessageEvent {
    data: Data
    type: string
    target: WebSocket
  }

  interface EventListenerOptions {
    once?: boolean | undefined
  }

  interface ServerOptions {
    host?: string | undefined
    port?: number | undefined
    backlog?: number | undefined
    server?: HTTPServer | HTTPSServer | undefined
    verifyClient?:
      | VerifyClientCallbackAsync
      | VerifyClientCallbackSync
      | undefined
    handleProtocols?: (
      protocols: Set<string>,
      request: IncomingMessage,
    ) => string | false
    path?: string | undefined
    noServer?: boolean | undefined
    clientTracking?: boolean | undefined
    perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined
    maxPayload?: number | undefined
    skipUTF8Validation?: boolean | undefined
    WebSocket?: typeof WebSocket.WebSocket | undefined
  }

  interface AddressInfo {
    address: string
    family: string
    port: number
  }

  // WebSocket Server
  class Server<T extends WebSocket = WebSocket> extends EventEmitter {
    options: ServerOptions
    path: string
    clients: Set<T>

    constructor(options?: ServerOptions, callback?: () => void)

    address(): AddressInfo | string
    close(cb?: (err?: Error) => void): void
    handleUpgrade(
      request: IncomingMessage,
      socket: Duplex,
      upgradeHead: Buffer,
      callback: (client: T, request: IncomingMessage) => void,
    ): void
    shouldHandle(request: IncomingMessage): boolean | Promise<boolean>

    // Events
    on(
      event: 'connection',
      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,
    ): this
    on(event: 'error', cb: (this: Server<T>, error: Error) => void): this
    on(
      event: 'headers',
      cb: (
        this: Server<T>,
        headers: string[],
        request: IncomingMessage,
      ) => void,
    ): this
    on(event: 'close' | 'listening', cb: (this: Server<T>) => void): this
    on(
      event: string | symbol,
      listener: (this: Server<T>, ...args: any[]) => void,
    ): this

    once(
      event: 'connection',
      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,
    ): this
    once(event: 'error', cb: (this: Server<T>, error: Error) => void): this
    once(
      event: 'headers',
      cb: (
        this: Server<T>,
        headers: string[],
        request: IncomingMessage,
      ) => void,
    ): this
    once(event: 'close' | 'listening', cb: (this: Server<T>) => void): this
    once(
      event: string | symbol,
      listener: (this: Server<T>, ...args: any[]) => void,
    ): this

    off(
      event: 'connection',
      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,
    ): this
    off(event: 'error', cb: (this: Server<T>, error: Error) => void): this
    off(
      event: 'headers',
      cb: (
        this: Server<T>,
        headers: string[],
        request: IncomingMessage,
      ) => void,
    ): this
    off(event: 'close' | 'listening', cb: (this: Server<T>) => void): this
    off(
      event: string | symbol,
      listener: (this: Server<T>, ...args: any[]) => void,
    ): this

    addListener(
      event: 'connection',
      cb: (client: T, request: IncomingMessage) => void,
    ): this
    addListener(event: 'error', cb: (err: Error) => void): this
    addListener(
      event: 'headers',
      cb: (headers: string[], request: IncomingMessage) => void,
    ): this
    addListener(event: 'close' | 'listening', cb: () => void): this
    addListener(
      event: string | symbol,
      listener: (...args: any[]) => void,
    ): this

    removeListener(event: 'connection', cb: (client: T) => void): this
    removeListener(event: 'error', cb: (err: Error) => void): this
    removeListener(
      event: 'headers',
      cb: (headers: string[], request: IncomingMessage) => void,
    ): this
    removeListener(event: 'close' | 'listening', cb: () => void): this
    removeListener(
      event: string | symbol,
      listener: (...args: any[]) => void,
    ): this
  }

  const WebSocketServer: typeof Server
  interface WebSocketServer extends Server {}
  const WebSocket: typeof WebSocketAlias
  interface WebSocket extends WebSocketAlias {}

  // WebSocket stream
  function createWebSocketStream(
    websocket: WebSocket,
    options?: DuplexOptions,
  ): Duplex
}

// export = WebSocket
export { WebSocket, WebSocketAlias }



================================================
FILE: packages/vite/types/customEvent.d.ts
================================================
import type {
  ErrorPayload,
  FullReloadPayload,
  PrunePayload,
  UpdatePayload,
} from './hmrPayload'

export interface CustomEventMap {
  'vite:beforeUpdate': UpdatePayload
  'vite:afterUpdate': UpdatePayload
  'vite:beforePrune': PrunePayload
  'vite:beforeFullReload': FullReloadPayload
  'vite:error': ErrorPayload
  'vite:invalidate': InvalidatePayload
  'vite:ws:connect': WebSocketConnectionPayload
  'vite:ws:disconnect': WebSocketConnectionPayload
}

export interface WebSocketConnectionPayload {
  /**
   * @experimental
   * We expose this instance experimentally to see potential usage.
   * This might be removed in the future if we didn't find reasonable use cases.
   * If you find this useful, please open an issue with details so we can discuss and make it stable API.
   */
  // eslint-disable-next-line n/no-unsupported-features/node-builtins
  webSocket: WebSocket
}

export interface InvalidatePayload {
  path: string
  message: string | undefined
  firstInvalidatedBy: string
}

/**
 * provides types for payloads of built-in Vite events
 */
export type InferCustomEventPayload<T extends string> =
  T extends keyof CustomEventMap ? CustomEventMap[T] : any

/**
 * provides types for names of built-in Vite events
 */
export type CustomEventName = keyof CustomEventMap | (string & {})



================================================
FILE: packages/vite/types/hmrPayload.d.ts
================================================
/** @deprecated use HotPayload */
export type HMRPayload = HotPayload
export type HotPayload =
  | ConnectedPayload
  | PingPayload
  | UpdatePayload
  | FullReloadPayload
  | CustomPayload
  | ErrorPayload
  | PrunePayload

export interface ConnectedPayload {
  type: 'connected'
}

export interface PingPayload {
  type: 'ping'
}

export interface UpdatePayload {
  type: 'update'
  updates: Update[]
}

export interface Update {
  type: 'js-update' | 'css-update'
  path: string
  acceptedPath: string
  timestamp: number
  /** @internal */
  explicitImportRequired?: boolean
  /** @internal */
  isWithinCircularImport?: boolean
  /** @internal */
  firstInvalidatedBy?: string
  /** @internal */
  invalidates?: string[]
}

export interface PrunePayload {
  type: 'prune'
  paths: string[]
}

export interface FullReloadPayload {
  type: 'full-reload'
  path?: string
  /** @internal */
  triggeredBy?: string
}

export interface CustomPayload {
  type: 'custom'
  event: string
  data?: any
}

export interface ErrorPayload {
  type: 'error'
  err: {
    [name: string]: any
    message: string
    stack: string
    id?: string
    frame?: string
    plugin?: string
    pluginCode?: string
    loc?: {
      file?: string
      line: number
      column: number
    }
  }
}



================================================
FILE: packages/vite/types/hot.d.ts
================================================
import type { CustomEventName, InferCustomEventPayload } from './customEvent'

export type ModuleNamespace = Record<string, any> & {
  [Symbol.toStringTag]: 'Module'
}

export interface ViteHotContext {
  readonly data: any

  accept(): void
  accept(cb: (mod: ModuleNamespace | undefined) => void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept(
    deps: readonly string[],
    cb: (mods: Array<ModuleNamespace | undefined>) => void,
  ): void

  acceptExports(
    exportNames: string | readonly string[],
    cb?: (mod: ModuleNamespace | undefined) => void,
  ): void

  dispose(cb: (data: any) => void): void
  prune(cb: (data: any) => void): void
  invalidate(message?: string): void

  on<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  off<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  send<T extends CustomEventName>(
    event: T,
    data?: InferCustomEventPayload<T>,
  ): void
}



================================================
FILE: packages/vite/types/import-meta.d.ts
================================================
/// <reference path="./importMeta.d.ts" />

// https://github.com/microsoft/TypeScript/issues/45096
// TypeScript has a bug that makes <reference types="vite/types/importMeta" />
// not possible in userland. This file provides a workaround for now.



================================================
FILE: packages/vite/types/importGlob.d.ts
================================================
export interface ImportGlobOptions<
  Eager extends boolean,
  AsType extends string,
> {
  /**
   * Import type for the import url.
   *
   * @deprecated Use `query` instead, e.g. `as: 'url'` -> `query: '?url', import: 'default'`
   */
  as?: AsType
  /**
   * Import as static or dynamic
   *
   * @default false
   */
  eager?: Eager
  /**
   * Import only the specific named export. Set to `default` to import the default export.
   */
  import?: string
  /**
   * Custom queries
   */
  query?: string | Record<string, string | number | boolean>
  /**
   * Search files also inside `node_modules/` and hidden directories (e.g. `.git/`). This might have impact on performance.
   *
   * @default false
   */
  exhaustive?: boolean
  /**
   * Base path to resolve relative paths.
   */
  base?: string
}

export type GeneralImportGlobOptions = ImportGlobOptions<boolean, string>

/**
 * Declare Worker in case DOM is not added to the tsconfig lib causing
 * Worker interface is not defined. For developers with DOM lib added,
 * the Worker interface will be merged correctly.
 */
declare global {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface Worker {}
}

export interface KnownAsTypeMap {
  raw: string
  url: string
  worker: Worker
}

export interface ImportGlobFunction {
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 1: No generic provided, infer the type from `eager` and `as`
   */
  <
    Eager extends boolean,
    As extends string,
    T = As extends keyof KnownAsTypeMap ? KnownAsTypeMap[As] : unknown,
  >(
    glob: string | string[],
    options?: ImportGlobOptions<Eager, As>,
  ): (Eager extends true ? true : false) extends true
    ? Record<string, T>
    : Record<string, () => Promise<T>>
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 2: Module generic provided, infer the type from `eager: false`
   */
  <M>(
    glob: string | string[],
    options?: ImportGlobOptions<false, string>,
  ): Record<string, () => Promise<M>>
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 3: Module generic provided, infer the type from `eager: true`
   */
  <M>(
    glob: string | string[],
    options: ImportGlobOptions<true, string>,
  ): Record<string, M>
}



================================================
FILE: packages/vite/types/importMeta.d.ts
================================================
// This file is an augmentation to the built-in ImportMeta interface
// Thus cannot contain any top-level imports
// <https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation>

// This is tested in `packages/vite/src/node/__tests_dts__/typeOptions.ts`
// eslint-disable-next-line @typescript-eslint/no-empty-object-type -- to allow extending by users
interface ViteTypeOptions {
  // strictImportMetaEnv: unknown
}

type ImportMetaEnvFallbackKey =
  'strictImportMetaEnv' extends keyof ViteTypeOptions ? never : string

interface ImportMetaEnv {
  [key: ImportMetaEnvFallbackKey]: any
  BASE_URL: string
  MODE: string
  DEV: boolean
  PROD: boolean
  SSR: boolean
}

interface ImportMeta {
  url: string

  readonly hot?: import('./hot').ViteHotContext

  readonly env: ImportMetaEnv

  glob: import('./importGlob').ImportGlobFunction
}



================================================
FILE: packages/vite/types/metadata.d.ts
================================================
export interface ChunkMetadata {
  importedAssets: Set<string>
  importedCss: Set<string>
}

export interface CustomPluginOptionsVite {
  /**
   * If this is a CSS Rollup module, you can scope to its importer's exports
   * so that if those exports are treeshaken away, the CSS module will also
   * be treeshaken.
   *
   * The "importerId" must import the CSS Rollup module statically.
   *
   * Example config if the CSS id is `/src/App.vue?vue&type=style&lang.css`:
   * ```js
   * cssScopeTo: ['/src/App.vue', 'default']
   * ```
   */
  cssScopeTo?: readonly [importerId: string, exportName: string | undefined]

  /** @deprecated no-op since Vite 6.1 */
  lang?: string
}

declare module 'rollup' {
  export interface RenderedChunk {
    viteMetadata?: ChunkMetadata
  }

  export interface CustomPluginOptions {
    vite?: CustomPluginOptionsVite
  }
}



================================================
FILE: packages/vite/types/package.json
================================================
{
  "//": "this file is here to make typescript happy when moduleResolution=node16+",
  "version": "0.0.0"
}



================================================
FILE: packages/vite/types/internal/cssPreprocessorOptions.d.ts
================================================
/* eslint-disable @typescript-eslint/ban-ts-comment */

// @ts-ignore `sass` may not be installed
import type DartSass from 'sass'
// @ts-ignore `sass-embedded` may not be installed
import type SassEmbedded from 'sass-embedded'
// @ts-ignore `less` may not be installed
import type Less from 'less'
// @ts-ignore `stylus` may not be installed
import type Stylus from 'stylus'

/* eslint-enable @typescript-eslint/ban-ts-comment */

// https://github.com/type-challenges/type-challenges/issues/29285
type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false

type DartSassStringOptionsAsync = DartSass.StringOptions<'async'>
type SassEmbeddedStringOptionsAsync = SassEmbedded.StringOptions<'async'>
type SassStringOptionsAsync =
  IsAny<SassEmbeddedStringOptionsAsync> extends false
    ? SassEmbeddedStringOptionsAsync
    : DartSassStringOptionsAsync

export type SassModernPreprocessBaseOptions = Omit<
  SassStringOptionsAsync,
  'url' | 'sourceMap'
>

export type LessPreprocessorBaseOptions = Omit<
  Less.Options,
  'sourceMap' | 'filename'
>

export type StylusPreprocessorBaseOptions = Omit<
  Stylus.RenderOptions,
  'filename'
> & { define?: Record<string, any> }

declare global {
  // LESS' types somewhat references this which doesn't make sense in Node,
  // so we have to shim it
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface HTMLLinkElement {}
}



================================================
FILE: packages/vite/types/internal/lightningcssOptions.d.ts
================================================
/* eslint-disable @typescript-eslint/ban-ts-comment */

// @ts-ignore `lightningcss` may not be installed
import type Lightningcss from 'lightningcss'

/* eslint-enable @typescript-eslint/ban-ts-comment */

export type LightningCSSOptions = Omit<
  Lightningcss.BundleAsyncOptions<Lightningcss.CustomAtRules>,
  | 'filename'
  | 'resolver'
  | 'minify'
  | 'sourceMap'
  | 'analyzeDependencies'
  // properties not overridden by Vite, but does not make sense to set by end users
  | 'inputSourceMap'
  | 'projectRoot'
>



================================================
FILE: packages/vite/types/internal/terserOptions.d.ts
================================================
/* eslint-disable @typescript-eslint/ban-ts-comment */

// @ts-ignore `terser` may not be installed
export type * as Terser from 'terser'
// @ts-ignore `terser` may not be installed
import type * as Terser from 'terser'

/* eslint-enable @typescript-eslint/ban-ts-comment */

export type TerserMinifyOptions = Terser.MinifyOptions
export type TerserMinifyOutput = Terser.MinifyOutput



================================================
FILE: patches/chokidar@3.6.0.patch
================================================
diff --git a/lib/fsevents-handler.js b/lib/fsevents-handler.js
index fe29393c179d3d6673f996ca6f95bbc83f9a0699..0a341f3d6a2f1497486a23ea99b3c6da003c026f 100644
--- a/lib/fsevents-handler.js
+++ b/lib/fsevents-handler.js
@@ -305,7 +305,8 @@ _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
   if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
   const opts = this.fsw.options;
   const watchCallback = async (fullPath, flags, info) => {
-    if (this.fsw.closed) return;
+    // PATCH: bypass the callback for better perf when fullPath hit the ignored file list
+    if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
     if (
       opts.depth !== undefined &&
       calcDepth(fullPath, realPath) > opts.depth



================================================
FILE: patches/dotenv-expand@12.0.2.patch
================================================
diff --git a/lib/main.js b/lib/main.js
index 794f3bf512ee8cd24fe20e83d159bf8682fb901e..5567e6e282d65b87deea02f8cb396d3e7276581e 100644
--- a/lib/main.js
+++ b/lib/main.js
@@ -64,7 +64,7 @@ function expandValue (value, processEnv, runningParsed) {
 
 function expand (options) {
   // for use with progressive expansion
-  const runningParsed = {}
+  // const runningParsed = {}
 
   let processEnv = process.env
   if (options && options.processEnv != null) {
@@ -79,13 +79,15 @@ function expand (options) {
     if (processEnv[key] && processEnv[key] !== value) {
       value = processEnv[key]
     } else {
-      value = expandValue(value, processEnv, runningParsed)
+      // PATCH: we pass options.parsed instead of runningParsed
+      //        to allow variables declared in other files to be used
+      value = expandValue(value, processEnv, options.parsed)
     }
 
     options.parsed[key] = _resolveEscapeSequences(value)
 
     // for use with progressive expansion
-    runningParsed[key] = _resolveEscapeSequences(value)
+    // runningParsed[key] = _resolveEscapeSequences(value)
   }
 
   for (const processKey in options.parsed) {



================================================
FILE: patches/sirv@3.0.1.patch
================================================
diff --git a/build.js b/build.js
index 0c6ed8e2c0949c93978dd1a244baa9bf2448e9b8..08a9347cfdca06e6a97077ea4582c5b0922ecb2d 100644
--- a/build.js
+++ b/build.js
@@ -35,7 +35,7 @@ function viaCache(cache, uri, extns) {
 	}
 }
 
-function viaLocal(dir, isEtag, uri, extns) {
+function viaLocal(dir, isEtag, uri, extns, shouldServe) {
 	let i=0, arr=toAssume(uri, extns);
 	let abs, stats, name, headers;
 	for (; i < arr.length; i++) {
@@ -43,6 +43,7 @@ function viaLocal(dir, isEtag, uri, extns) {
 		if (abs.startsWith(dir) && fs.existsSync(abs)) {
 			stats = fs.statSync(abs);
 			if (stats.isDirectory()) continue;
+			if (shouldServe && !shouldServe(abs)) continue;
 			headers = toHeaders(name, stats, isEtag);
 			headers['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';
 			return { abs, stats, headers };
@@ -176,7 +177,7 @@ module.exports = function (dir, opts={}) {
 			catch (err) { /* malform uri */ }
 		}
 
-		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
+		let data = lookup(pathname, extns, opts.shouldServe) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns, opts.shouldServe);
 		if (!data) return next ? next() : isNotFound(req, res);
 
 		if (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {
diff --git a/build.mjs b/build.mjs
index 3ad14d45630a8627b93842a04a96465120d3f223..8451277c015b56a7d2cb99aaee3a318d9c0893dd 100644
--- a/build.mjs
+++ b/build.mjs
@@ -35,7 +35,7 @@ function viaCache(cache, uri, extns) {
 	}
 }
 
-function viaLocal(dir, isEtag, uri, extns) {
+function viaLocal(dir, isEtag, uri, extns, shouldServe) {
 	let i=0, arr=toAssume(uri, extns);
 	let abs, stats, name, headers;
 	for (; i < arr.length; i++) {
@@ -43,6 +43,7 @@ function viaLocal(dir, isEtag, uri, extns) {
 		if (abs.startsWith(dir) && fs.existsSync(abs)) {
 			stats = fs.statSync(abs);
 			if (stats.isDirectory()) continue;
+			if (shouldServe && !shouldServe(abs)) continue;
 			headers = toHeaders(name, stats, isEtag);
 			headers['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';
 			return { abs, stats, headers };
@@ -176,7 +177,7 @@ export default function (dir, opts={}) {
 			catch (err) { /* malform uri */ }
 		}
 
-		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
+		let data = lookup(pathname, extns, opts.shouldServe) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns, opts.shouldServe);
 		if (!data) return next ? next() : isNotFound(req, res);
 
 		if (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {
diff --git a/index.d.mts b/index.d.mts
index 8bfe364f1db2d1382c56a9b75a014579083cfa70..a8dfa1c473ff15c979bbfbc28c3630a12e222c3a 100644
--- a/index.d.mts
+++ b/index.d.mts
@@ -24,6 +24,8 @@ export interface Options {
 	gzip?: boolean;
 	onNoMatch?: (req: IncomingMessage, res: ServerResponse) => void;
 	setHeaders?: (res: ServerResponse, pathname: string, stats: Stats) => void;
+	/** patched */
+	shouldServe?: (absoluteFilePath: string) => void;
 }
 
 export default function (dir?: string, opts?: Options): RequestHandler;
diff --git a/index.d.ts b/index.d.ts
index 96cc63e7ee1ccdd7266e9193252b799068ef2e3c..9e298d627002cd0b073073aa13528b7492541b5b 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -25,6 +25,8 @@ declare namespace sirv {
 		gzip?: boolean;
 		onNoMatch?: (req: IncomingMessage, res: ServerResponse) => void;
 		setHeaders?: (res: ServerResponse, pathname: string, stats: Stats) => void;
+		/** patched */
+		shouldServe?: (absoluteFilePath: string) => void;
 	}
 }
 



================================================
FILE: playground/package.json
================================================
{
  "name": "@vitejs/vite-playground",
  "private": true,
  "type": "module",
  "version": "1.0.0",
  "scripts": {
    "typecheck": "tsc"
  },
  "devDependencies": {
    "convert-source-map": "^2.0.0",
    "css-color-names": "^1.0.1",
    "kill-port": "^1.6.1"
  }
}



================================================
FILE: playground/shims.d.ts
================================================
declare module 'css-color-names' {
  const colors: Record<string, string>
  export default colors
}

declare module 'kill-port' {
  const kill: (port: number) => Promise<void>
  export default kill
}

declare module '*.vue' {
  import type { ComponentOptions } from 'vue'
  const component: ComponentOptions
  export default component
}



================================================
FILE: playground/test-utils.ts
================================================
// test utils used in e2e tests for playgrounds.
// `import { getColor } from '~utils'`

import fs from 'node:fs'
import path from 'node:path'
import colors from 'css-color-names'
import type {
  ConsoleMessage,
  ElementHandle,
  Locator,
} from 'playwright-chromium'
import type { DepOptimizationMetadata, Manifest } from 'vite'
import { normalizePath } from 'vite'
import { fromComment } from 'convert-source-map'
import { expect } from 'vitest'
import type { ResultPromise as ExecaResultPromise } from 'execa'
import { isWindows, page, testDir } from './vitestSetup'

export * from './vitestSetup'

// make sure these ports are unique
export const ports = {
  cli: 9510,
  'cli-module': 9511,
  json: 9512,
  'legacy/ssr': 9520,
  lib: 9521,
  'optimize-missing-deps': 9522,
  'legacy/client-and-ssr': 9523,
  'assets/encoded-base': 9554, // not imported but used in `assets/vite.config-encoded-base.js`
  'assets/url-base': 9525, // not imported but used in `assets/vite.config-url-base.js`
  ssr: 9600,
  'ssr-deps': 9601,
  'ssr-html': 9602,
  'ssr-noexternal': 9603,
  'ssr-pug': 9604,
  'ssr-webworker': 9605,
  'proxy-bypass': 9606, // not imported but used in `proxy-hmr/vite.config.js`
  'proxy-bypass/non-existent-app': 9607, // not imported but used in `proxy-hmr/other-app/vite.config.js`
  'ssr-hmr': 9609, // not imported but used in `hmr-ssr/__tests__/hmr.spec.ts`
  'proxy-hmr': 9616, // not imported but used in `proxy-hmr/vite.config.js`
  'proxy-hmr/other-app': 9617, // not imported but used in `proxy-hmr/other-app/vite.config.js`
  'ssr-conditions': 9620,
  'css/postcss-caching': 5005,
  'css/postcss-plugins-different-dir': 5006,
  'css/dynamic-import': 5007,
  'css/lightningcss-proxy': 5008,
  'backend-integration': 5009,
  'client-reload': 5010,
  'client-reload/hmr-port': 5011,
  'client-reload/cross-origin': 5012,
}
export const hmrPorts = {
  'optimize-missing-deps': 24680,
  ssr: 24681,
  'ssr-deps': 24682,
  'ssr-html': 24683,
  'ssr-noexternal': 24684,
  'ssr-pug': 24685,
  'css/lightningcss-proxy': 24686,
  json: 24687,
  'ssr-conditions': 24688,
  'client-reload/hmr-port': 24689,
  'client-reload/cross-origin': 24690,
}

const hexToNameMap: Record<string, string> = {}
Object.keys(colors).forEach((color) => {
  hexToNameMap[colors[color]] = color
})

function componentToHex(c: number): string {
  const hex = c.toString(16)
  return hex.length === 1 ? '0' + hex : hex
}

function rgbToHex(rgb: string): string | undefined {
  const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
  if (match) {
    const [_, rs, gs, bs] = match
    return (
      '#' +
      componentToHex(parseInt(rs, 10)) +
      componentToHex(parseInt(gs, 10)) +
      componentToHex(parseInt(bs, 10))
    )
  }
  return undefined
}

async function toEl(
  el: string | ElementHandle | Locator,
): Promise<ElementHandle> {
  if (typeof el === 'string') {
    const realEl = await page.$(el)
    if (realEl == null) {
      throw new Error(`Cannot find element: "${el}"`)
    }
    return realEl
  }
  if ('elementHandle' in el) {
    return el.elementHandle()
  }
  return el
}

export async function getColor(
  el: string | ElementHandle | Locator,
): Promise<string> {
  el = await toEl(el)
  const rgb = await el.evaluate((el) => getComputedStyle(el as Element).color)
  return hexToNameMap[rgbToHex(rgb)] ?? rgb
}

export async function getBg(
  el: string | ElementHandle | Locator,
): Promise<string> {
  el = await toEl(el)
  return el.evaluate((el) => getComputedStyle(el as Element).backgroundImage)
}

export async function getBgColor(
  el: string | ElementHandle | Locator,
): Promise<string> {
  el = await toEl(el)
  const rgb = await el.evaluate(
    (el) => getComputedStyle(el as Element).backgroundColor,
  )
  return hexToNameMap[rgbToHex(rgb)] ?? rgb
}

export function readFile(filename: string, encoding?: BufferEncoding): string
export function readFile(filename: string, encoding: null): Buffer
export function readFile(
  filename: string,
  encoding?: BufferEncoding | null,
): Buffer | string {
  if (encoding === undefined) encoding = 'utf-8'
  return fs.readFileSync(path.resolve(testDir, filename), encoding)
}

export function editFile(
  filename: string,
  replacer: (content: string) => string,
): void
export function editFile(
  filename: string,
  encoding: null,
  replacer: (content: Buffer) => Buffer,
): void
export function editFile(
  filename: string,
  encoding: BufferEncoding | null,
  replacer: ((content: Buffer) => Buffer) | ((content: string) => string),
): void
export function editFile(
  filename: string,
  encodingOrReplacer: BufferEncoding | null | ((content: string) => string),
  maybeReplacer?: ((content: Buffer) => Buffer) | ((content: string) => string),
): void {
  filename = path.resolve(testDir, filename)
  const [encoding, replacer] = maybeReplacer
    ? [encodingOrReplacer as BufferEncoding | null, maybeReplacer]
    : ['utf-8' as const, encodingOrReplacer as (content: string) => string]
  const content: string | Buffer = fs.readFileSync(filename, encoding)
  const modified = (replacer as (content: string | Buffer) => string | Buffer)(
    content,
  )
  fs.writeFileSync(filename, modified)
}

export function addFile(filename: string, content: string): void {
  const resolvedFilename = path.resolve(testDir, filename)
  fs.mkdirSync(path.dirname(resolvedFilename), { recursive: true })
  fs.writeFileSync(resolvedFilename, content)
}

export function removeFile(filename: string): void {
  fs.unlinkSync(path.resolve(testDir, filename))
}

export function listAssets(base = ''): string[] {
  const assetsDir = path.join(testDir, 'dist', base, 'assets')
  return fs.readdirSync(assetsDir)
}

export function findAssetFile(
  match: string | RegExp,
  base = '',
  assets = 'assets',
  matchAll = false,
): string | undefined {
  const assetsDir = path.join(testDir, 'dist', base, assets)
  let files: string[]
  try {
    files = fs.readdirSync(assetsDir)
  } catch (e) {
    if (e.code === 'ENOENT') {
      return undefined
    }
    throw e
  }
  if (matchAll) {
    const matchedFiles = files.filter((file) => file.match(match))
    return matchedFiles.length
      ? matchedFiles
          .map((file) =>
            fs.readFileSync(path.resolve(assetsDir, file), 'utf-8'),
          )
          .join('')
      : undefined
  } else {
    const matchedFile = files.find((file) => file.match(match))
    return matchedFile
      ? fs.readFileSync(path.resolve(assetsDir, matchedFile), 'utf-8')
      : undefined
  }
}

export function readManifest(base = ''): Manifest {
  return JSON.parse(
    fs.readFileSync(
      path.join(testDir, 'dist', base, '.vite/manifest.json'),
      'utf-8',
    ),
  )
}

export function readDepOptimizationMetadata(
  environmentName = 'client',
): DepOptimizationMetadata {
  const suffix = environmentName === 'client' ? '' : `_${environmentName}`
  return JSON.parse(
    fs.readFileSync(
      path.join(testDir, `node_modules/.vite/deps${suffix}/_metadata.json`),
      'utf-8',
    ),
  )
}

type UntilBrowserLogAfterCallback = (logs: string[]) => PromiseLike<void> | void

export async function untilBrowserLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  expectOrder?: boolean,
  callback?: UntilBrowserLogAfterCallback,
): Promise<string[]>
export async function untilBrowserLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  callback?: UntilBrowserLogAfterCallback,
): Promise<string[]>
export async function untilBrowserLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  arg3?: boolean | UntilBrowserLogAfterCallback,
  arg4?: UntilBrowserLogAfterCallback,
): Promise<string[]> {
  const expectOrder = typeof arg3 === 'boolean' ? arg3 : false
  const callback = typeof arg3 === 'boolean' ? arg4 : arg3

  const promise = untilBrowserLog(target, expectOrder)
  await operation()
  const logs = await promise
  if (callback) {
    await callback(logs)
  }
  return logs
}

async function untilBrowserLog(
  target?: string | RegExp | Array<string | RegExp>,
  expectOrder = true,
): Promise<string[]> {
  const { promise, resolve, reject } = promiseWithResolvers<void>()

  const logs = []

  try {
    const isMatch = (matcher: string | RegExp) => (text: string) =>
      typeof matcher === 'string' ? text === matcher : matcher.test(text)

    let processMsg: (text: string) => boolean

    if (!target) {
      processMsg = () => true
    } else if (Array.isArray(target)) {
      if (expectOrder) {
        const remainingTargets = [...target]
        processMsg = (text: string) => {
          const nextTarget = remainingTargets.shift()
          expect(text).toMatch(nextTarget)
          return remainingTargets.length === 0
        }
      } else {
        const remainingMatchers = target.map(isMatch)
        processMsg = (text: string) => {
          const nextIndex = remainingMatchers.findIndex((matcher) =>
            matcher(text),
          )
          if (nextIndex >= 0) {
            remainingMatchers.splice(nextIndex, 1)
          }
          return remainingMatchers.length === 0
        }
      }
    } else {
      processMsg = isMatch(target)
    }

    const handleMsg = (msg: ConsoleMessage) => {
      try {
        const text = msg.text()
        logs.push(text)
        const done = processMsg(text)
        if (done) {
          resolve()
        }
      } catch (err) {
        reject(err)
      }
    }

    page.on('console', handleMsg)
  } catch (err) {
    reject(err)
  }

  await promise

  return logs
}

export const extractSourcemap = (content: string): any => {
  const lines = content.trim().split('\n')
  return fromComment(lines[lines.length - 1]).toObject()
}

export const formatSourcemapForSnapshot = (map: any): any => {
  const root = normalizePath(testDir)
  const m = { ...map }
  delete m.file
  delete m.names
  if (m.debugId) {
    m.debugId = '00000000-0000-0000-0000-000000000000'
  }
  m.sources = m.sources.map((source) => source.replace(root, '/root'))
  if (m.sourceRoot) {
    m.sourceRoot = m.sourceRoot.replace(root, '/root')
  }
  return m
}

// helper function to kill process, uses taskkill on windows to ensure child process is killed too
export async function killProcess(
  serverProcess: ExecaResultPromise,
): Promise<void> {
  if (isWindows) {
    try {
      const { execaCommandSync } = await import('execa')
      execaCommandSync(`taskkill /pid ${serverProcess.pid} /T /F`)
    } catch (e) {
      console.error('failed to taskkill:', e)
    }
  } else {
    serverProcess.kill('SIGTERM')
  }
}

export interface PromiseWithResolvers<T> {
  promise: Promise<T>
  resolve: (value: T | PromiseLike<T>) => void
  reject: (reason?: any) => void
}
export function promiseWithResolvers<T>(): PromiseWithResolvers<T> {
  let resolve: any
  let reject: any
  const promise = new Promise<T>((_resolve, _reject) => {
    resolve = _resolve
    reject = _reject
  })
  return { promise, resolve, reject }
}



================================================
FILE: playground/tsconfig.json
================================================
{
  "include": ["**/vite*config*", "**/*.ts"],
  "exclude": ["**/dist/**"],
  "compilerOptions": {
    "checkJs": true,
    "target": "ES2023",
    "module": "Preserve",
    "noEmit": true,
    "allowJs": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "moduleResolution": "bundler",
    "erasableSyntaxOnly": true,
    "skipLibCheck": true,
    "noUnusedLocals": true,
    "jsx": "preserve",
    "types": ["vite/client", "node"],
    "paths": {
      "~utils": ["./test-utils.ts"]
    }
  }
}



================================================
FILE: playground/vitestGlobalSetup.ts
================================================
import fs from 'node:fs/promises'
import path from 'node:path'
import type { TestProject } from 'vitest/node'
import type { BrowserServer } from 'playwright-chromium'
import { chromium } from 'playwright-chromium'

let browserServer: BrowserServer | undefined

export async function setup({ provide }: TestProject): Promise<void> {
  process.env.NODE_ENV = process.env.VITE_TEST_BUILD
    ? 'production'
    : 'development'

  browserServer = await chromium.launchServer({
    headless: !process.env.VITE_DEBUG_SERVE,
    args: process.env.CI
      ? ['--no-sandbox', '--disable-setuid-sandbox']
      : undefined,
  })

  provide('wsEndpoint', browserServer.wsEndpoint())

  const tempDir = path.resolve(__dirname, '../playground-temp')
  await fs.rm(tempDir, { recursive: true, force: true })
  await fs.mkdir(tempDir, { recursive: true })
  await fs
    .cp(path.resolve(__dirname, '../playground'), tempDir, {
      recursive: true,
      dereference: false,
      filter(file) {
        file = file.replace(/\\/g, '/')
        return !file.includes('__tests__') && !/dist(?:\/|$)/.test(file)
      },
    })
    .catch(async (error) => {
      if (error.code === 'EPERM' && error.syscall === 'symlink') {
        throw new Error(
          'Could not create symlinks. On Windows, consider activating Developer Mode to allow non-admin users to create symlinks by following the instructions at https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development.',
        )
      } else {
        throw error
      }
    })
  // also setup dedicated copy for "variant" tests
  for (const [original, variants] of [
    ['assets', ['encoded-base', 'relative-base', 'runtime-base', 'url-base']],
    ['css', ['lightningcss']],
    ['transform-plugin', ['base']],
  ] as const) {
    for (const variant of variants) {
      await fs.cp(
        path.resolve(tempDir, original),
        path.resolve(tempDir, `${original}__${variant}`),
        { recursive: true },
      )
    }
  }
}

export async function teardown(): Promise<void> {
  await browserServer?.close()
  if (!process.env.VITE_PRESERVE_BUILD_ARTIFACTS) {
    await fs.rm(path.resolve(__dirname, '../playground-temp'), {
      recursive: true,
    })
  }
}



================================================
FILE: playground/vitestSetup.ts
================================================
import type * as http from 'node:http'
import fs from 'node:fs'
import path from 'node:path'
import { chromium } from 'playwright-chromium'
import type {
  ConfigEnv,
  InlineConfig,
  Logger,
  PluginOption,
  ResolvedConfig,
  UserConfig,
  ViteDevServer,
} from 'vite'
import {
  build,
  createBuilder,
  createServer,
  loadConfigFromFile,
  mergeConfig,
  preview,
} from 'vite'
import type { Browser, Page } from 'playwright-chromium'
import type { RollupError, RollupWatcher, RollupWatcherEvent } from 'rollup'
import type { RunnerTestFile } from 'vitest'
import { beforeAll, inject } from 'vitest'

// #region env

export const workspaceRoot = path.resolve(__dirname, '../')

export const isBuild = !!process.env.VITE_TEST_BUILD
export const isServe = !isBuild
export const isWindows = process.platform === 'win32'
export const viteBinPath = path.posix.join(
  workspaceRoot,
  'packages/vite/bin/vite.js',
)

// #endregion

// #region context

let server: ViteDevServer | http.Server

/**
 * Vite Dev Server when testing serve
 */
export let viteServer: ViteDevServer
/**
 * Root of the Vite fixture
 */
export let rootDir: string
/**
 * Path to the current test file
 */
export let testPath: string
/**
 * Path to the test folder
 */
export let testDir: string
/**
 * Test folder name
 */
export let testName: string

export const serverLogs: string[] = []
export const browserLogs: string[] = []
export const browserErrors: Error[] = []

export let page: Page = undefined!
export let browser: Browser = undefined!
export let viteTestUrl: string = ''
export let watcher: RollupWatcher | undefined = undefined

export function setViteUrl(url: string): void {
  viteTestUrl = url
}

function throwHtmlParseError() {
  return {
    name: 'vite-plugin-throw-html-parse-error',
    configResolved(config: ResolvedConfig) {
      const warn = config.logger.warn
      config.logger.warn = (msg, opts) => {
        // convert HTML parse warnings to make it easier to test
        if (msg.includes('Unable to parse HTML;')) {
          throw new Error(msg)
        }
        warn.call(config.logger, msg, opts)
      }
    },
  }
}
// #endregion

beforeAll(async (s) => {
  const suite = s as RunnerTestFile

  testPath = suite.filepath!
  testName = slash(testPath).match(/playground\/([\w-]+)\//)?.[1]
  testDir = path.dirname(testPath)
  if (testName) {
    testDir = path.resolve(workspaceRoot, 'playground-temp', testName)
  }

  // skip browser setup for non-playground tests
  // TODO: ssr playground?
  if (
    !suite.filepath.includes('playground') ||
    suite.filepath.includes('hmr-ssr')
  ) {
    return
  }

  const wsEndpoint = inject('wsEndpoint')
  if (!wsEndpoint) {
    throw new Error('wsEndpoint not found')
  }

  browser = await chromium.connect(wsEndpoint)
  page = await browser.newPage()

  try {
    page.on('console', (msg) => {
      // ignore favicon request in headed browser
      if (
        process.env.VITE_DEBUG_SERVE &&
        msg.text().includes('Failed to load resource:') &&
        msg.location().url.includes('favicon.ico')
      ) {
        return
      }
      browserLogs.push(msg.text())
    })
    page.on('pageerror', (error) => {
      browserErrors.push(error)
    })

    // if this is a test placed under playground/xxx/__tests__
    // start a vite server in that directory.
    if (testName) {
      // when `root` dir is present, use it as vite's root
      const testCustomRoot = path.resolve(testDir, 'root')
      rootDir = fs.existsSync(testCustomRoot) ? testCustomRoot : testDir

      // separate rootDir for variant
      const variantName = path.basename(path.dirname(testPath))
      if (variantName !== '__tests__') {
        const variantTestDir = testDir + '__' + variantName
        if (fs.existsSync(variantTestDir)) {
          rootDir = testDir = variantTestDir
        }
      }

      const testCustomServe = [
        path.resolve(path.dirname(testPath), 'serve.ts'),
        path.resolve(path.dirname(testPath), 'serve.js'),
      ].find((i) => fs.existsSync(i))

      if (testCustomServe) {
        // test has custom server configuration.
        const mod = await import(testCustomServe)
        const serve = mod.serve || mod.default?.serve
        const preServe = mod.preServe || mod.default?.preServe
        if (preServe) {
          await preServe()
        }
        if (serve) {
          server = await serve()
          viteServer = mod.viteServer
        }
      } else {
        await startDefaultServe()
      }
    }
  } catch (e) {
    // Closing the page since an error in the setup, for example a runtime error
    // when building the playground should skip further tests.
    // If the page remains open, a command like `await page.click(...)` produces
    // a timeout with an exception that hides the real error in the console.
    await page.close()
    await server?.close()
    throw e
  }

  return async () => {
    serverLogs.length = 0
    await page?.close()
    await server?.close()
    await watcher?.close()
    if (browser) {
      await browser.close()
    }
  }
})

async function loadConfig(configEnv: ConfigEnv) {
  let config: UserConfig | null = null

  // config file named by convention as the *.spec.ts folder
  const variantName = path.basename(path.dirname(testPath))
  if (variantName !== '__tests__') {
    const configVariantPath = path.resolve(
      rootDir,
      `vite.config-${variantName}.js`,
    )
    if (fs.existsSync(configVariantPath)) {
      const res = await loadConfigFromFile(configEnv, configVariantPath)
      if (res) {
        config = res.config
      }
    }
  }
  // config file from test root dir
  if (!config) {
    const res = await loadConfigFromFile(configEnv, undefined, rootDir)
    if (res) {
      config = res.config
    }
  }

  const options: InlineConfig = {
    root: rootDir,
    logLevel: 'silent',
    configFile: false,
    server: {
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
    },
    build: {
      // esbuild do not minify ES lib output since that would remove pure annotations and break tree-shaking
      // skip transpilation during tests to make it faster
      target: 'esnext',
      // tests are flaky when `emptyOutDir` is `true`
      emptyOutDir: false,
    },
    customLogger: createInMemoryLogger(serverLogs),
    plugins: [throwHtmlParseError()],
  }
  return mergeConfig(options, config || {})
}

export async function startDefaultServe(): Promise<void> {
  setupConsoleWarnCollector(serverLogs)

  if (!isBuild) {
    process.env.VITE_INLINE = 'inline-serve'
    const config = await loadConfig({ command: 'serve', mode: 'development' })
    viteServer = server = await (await createServer(config)).listen()
    viteTestUrl = stripTrailingSlashIfNeeded(
      server.resolvedUrls.local[0],
      server.config.base,
    )
    await page.goto(viteTestUrl)
  } else {
    process.env.VITE_INLINE = 'inline-build'
    let resolvedConfig: ResolvedConfig
    // determine build watch
    const resolvedPlugin: () => PluginOption = () => ({
      name: 'vite-plugin-watcher',
      configResolved(config) {
        resolvedConfig = config
      },
    })
    const buildConfig = mergeConfig(
      await loadConfig({ command: 'build', mode: 'production' }),
      {
        plugins: [resolvedPlugin()],
      },
    )
    if (buildConfig.builder) {
      const builder = await createBuilder(buildConfig)
      await builder.buildApp()
    } else {
      const rollupOutput = await build(buildConfig)
      const isWatch = !!resolvedConfig!.build.watch
      // in build watch,call startStaticServer after the build is complete
      if (isWatch) {
        watcher = rollupOutput as RollupWatcher
        await notifyRebuildComplete(watcher)
      }
      if (buildConfig.__test__) {
        buildConfig.__test__()
      }
    }

    const previewConfig = await loadConfig({
      command: 'serve',
      mode: 'development',
      isPreview: true,
    })
    const _nodeEnv = process.env.NODE_ENV
    const previewServer = await preview(previewConfig)
    // prevent preview change NODE_ENV
    process.env.NODE_ENV = _nodeEnv
    viteTestUrl = stripTrailingSlashIfNeeded(
      previewServer.resolvedUrls.local[0],
      previewServer.config.base,
    )
    await page.goto(viteTestUrl)
  }
}

/**
 * Send the rebuild complete message in build watch
 */
export async function notifyRebuildComplete(
  watcher: RollupWatcher,
): Promise<RollupWatcher> {
  let resolveFn: undefined | (() => void)
  const callback = (event: RollupWatcherEvent): void => {
    if (event.code === 'END') {
      resolveFn?.()
    }
  }
  watcher.on('event', callback)
  await new Promise<void>((resolve) => {
    resolveFn = resolve
  })
  return watcher.off('event', callback)
}

export function createInMemoryLogger(logs: string[]): Logger {
  const loggedErrors = new WeakSet<Error | RollupError>()
  const warnedMessages = new Set<string>()

  const logger: Logger = {
    hasWarned: false,
    hasErrorLogged: (err) => loggedErrors.has(err),
    clearScreen: () => {},
    info(msg) {
      logs.push(msg)
    },
    warn(msg) {
      logs.push(msg)
      logger.hasWarned = true
    },
    warnOnce(msg) {
      if (warnedMessages.has(msg)) return
      logs.push(msg)
      logger.hasWarned = true
      warnedMessages.add(msg)
    },
    error(msg, opts) {
      logs.push(msg)
      if (opts?.error) {
        loggedErrors.add(opts.error)
      }
    },
  }

  return logger
}

function setupConsoleWarnCollector(logs: string[]) {
  const warn = console.warn
  console.warn = (...args) => {
    logs.push(args.join(' '))
    return warn.call(console, ...args)
  }
}

export function slash(p: string): string {
  return p.replace(/\\/g, '/')
}

function stripTrailingSlashIfNeeded(url: string, base: string): string {
  if (base === '/') {
    return url.replace(/\/$/, '')
  }
  return url
}

declare module 'vite' {
  export interface UserConfig {
    /**
     * special test only hook
     *
     * runs after build and before preview
     */
    __test__?: () => void
  }
}

declare module 'vitest' {
  export interface ProvidedContext {
    wsEndpoint: string
  }
}



================================================
FILE: playground/alias/customResolver.js
================================================
export const msg = `[success] alias to custom-resolver path`



================================================
FILE: playground/alias/index.html
================================================
<h1>Alias</h1>

<p class="fs"></p>
<p class="fs-dir"></p>
<p class="regex"></p>
<p class="dep"></p>
<p class="from-script-src"></p>
<p class="aliased-module"></p>
<p class="custom-resolver"></p>

<div class="optimized"></div>

<script type="module">
  // no node: protocol intentionally
  import { msg as fsMsg } from 'fs'
  import { msg as fsDirMsg } from 'fs-dir/test'
  import { msg as regexMsg } from 'regex/test'
  import { msg as depMsg } from 'dep'
  import { msg as moduleMsg } from 'aliased-module/index.js'
  import { msg as customResolverMsg } from 'custom-resolver'

  function text(el, text) {
    document.querySelector(el).textContent = text
  }

  text('.fs', fsMsg)
  text('.fs-dir', fsDirMsg)
  text('.regex', regexMsg + ' via regex')
  text('.dep', depMsg)
  text('.aliased-module', moduleMsg)
  text('.custom-resolver', customResolverMsg)

  import { createApp } from 'vue'
  import { ref } from 'foo'
  // vue is aliased to the full browser build AND optimized.
  // should resolve as expected
  createApp({
    template: '[{{ msg }}] alias optimized dep',
    setup() {
      return {
        msg: ref('success'),
      }
    },
  }).mount('.optimized')

  // aliased to an absolute URL in CJS, should be optimized
  import { isFunction } from '@vue/shared'
  // also check name clash for aliased deps
  export { isFunction } from '@vue/shared'
  console.log(isFunction(() => {}))
</script>

<script type="module" src="/@/from-script-src.js"></script>
<link rel="stylesheet" href="/@/test.css" />



================================================
FILE: playground/alias/package.json
================================================
{
  "name": "@vitejs/test-alias",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "aliased-module": "file:./dir/module",
    "vue": "^3.5.18",
    "@vue/shared": "^3.5.18"
  },
  "devDependencies": {
    "@vitejs/test-resolve-linked": "workspace:*"
  }
}



================================================
FILE: playground/alias/test.js
================================================
export const msg = `[success] alias to fs path`



================================================
FILE: playground/alias/vite.config.js
================================================
import path from 'node:path'
import module from 'node:module'
import { defineConfig } from 'vite'

const require = module.createRequire(import.meta.url)

export default defineConfig({
  resolve: {
    alias: [
      { find: 'fs', replacement: path.resolve(__dirname, 'test.js') },
      { find: 'fs-dir', replacement: path.resolve(__dirname, 'dir') },
      { find: 'dep', replacement: '@vitejs/test-resolve-linked' },
      {
        find: /^regex\/(.*)/,
        replacement: `${path.resolve(__dirname, 'dir')}/$1`,
      },
      { find: '/@', replacement: path.resolve(__dirname, 'dir') },
      // aliasing an optimized dep
      { find: 'vue', replacement: 'vue/dist/vue.esm-bundler.js' },
      // aliasing an optimized dep to absolute URL
      {
        find: '@vue/shared',
        replacement: require.resolve('@vue/shared/dist/shared.cjs.prod.js'),
      },
      // aliasing one unoptimized dep to an optimized dep
      { find: 'foo', replacement: 'vue' },
      {
        find: 'custom-resolver',
        replacement: path.resolve(__dirname, 'test.js'),
        customResolver(id) {
          return id.replace('test.js', 'customResolver.js')
        },
      },
    ],
  },
  build: {
    minify: false,
  },
  define: {
    __VUE_OPTIONS_API__: true,
    __VUE_PROD_DEVTOOLS__: true,
    __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false,
  },
})



================================================
FILE: playground/alias/__tests__/alias.spec.ts
================================================
import { expect, test } from 'vitest'
import { editFile, getColor, isBuild, page } from '~utils'

test('fs', async () => {
  expect(await page.textContent('.fs')).toMatch('[success] alias to fs path')
})

test('fs directory', async () => {
  expect(await page.textContent('.fs-dir')).toMatch(
    '[success] alias to directory',
  )
})

test('regex', async () => {
  expect(await page.textContent('.regex')).toMatch(
    '[success] alias to directory via regex',
  )
})

test('dependency', async () => {
  expect(await page.textContent('.dep')).toMatch('[success] out of root')
})

test('js via script src', async () => {
  expect(await page.textContent('.from-script-src')).toMatch(
    '[success] from script src',
  )
})

test('css via link', async () => {
  expect(await getColor('body')).toBe('grey')
  if (isBuild) return
  editFile('dir/test.css', (code) => code.replace('grey', 'red'))
  await expect.poll(() => getColor('body')).toBe('red')
})

test('optimized dep', async () => {
  expect(await page.textContent('.optimized')).toMatch(
    '[success] alias optimized',
  )
})

test('aliased module', async () => {
  expect(await page.textContent('.aliased-module')).toMatch(
    '[success] aliased module',
  )
})

test('custom resolver', async () => {
  expect(await page.textContent('.custom-resolver')).toMatch(
    '[success] alias to custom-resolver path',
  )
})



================================================
FILE: playground/alias/dir/from-script-src.js
================================================
document.querySelector('.from-script-src').textContent =
  '[success] from script src'



================================================
FILE: playground/alias/dir/test.css
================================================
body {
  color: grey;
}



================================================
FILE: playground/alias/dir/test.js
================================================
export const msg = `[success] alias to directory`



================================================
FILE: playground/alias/dir/module/index.js
================================================
export const msg = `[success] aliased module`



================================================
FILE: playground/alias/dir/module/package.json
================================================
{
  "name": "@vitejs/test-aliased-module",
  "private": true,
  "type": "module",
  "version": "0.0.0"
}



================================================
FILE: playground/assets/foo.js
================================================
console.log('hi')



================================================
FILE: playground/assets/index.html
================================================
<!doctype html>

<head>
  <meta charset="UTF-8" />
  <link class="ico" rel="icon" type="image/svg+xml" href="favicon.ico" />
  <link rel="manifest" href="manifest.json" />
  <meta
    class="meta-og-image"
    property="og:image"
    content="./nested/asset.png"
  />
</head>

<link class="data-href" rel="icon" href="data:," />
<link rel="stylesheet" href="/raw.css" />

<h1>Assets</h1>

<p class="base"></p>

<h2>Raw References from publicDir</h2>
<ul>
  <li class="raw-js"></li>
  <script src="/raw.js"></script>
  <li class="raw-css">
    Raw CSS from publicDir should load (this should be red)
  </li>
</ul>

<h2>Asset Imports from JS</h2>
<ul>
  <li>Relative: <code class="asset-import-relative"></code></li>
  <li>Absolute: <code class="asset-import-absolute"></code></li>
  <li>From publicDir: <code class="public-import"></code></li>
  <li>
    From publicDir (json): <code class="public-json-import"></code> Content:
    <code class="public-json-import-content"></code>
  </li>
  <li>
    From publicDir (js): <code class="public-js-import"></code> Content:
    <code class="public-js-import-content"></code> Content-Type:
    <code class="public-js-import-content-type"></code>
  </li>
  <li>
    From publicDir (ts): <code class="public-ts-import"></code> Content:
    <code class="public-ts-import-content"></code> Content-Type:
    <code class="public-ts-import-content-type"></code>
  </li>
  <li>
    From publicDir (mts): <code class="public-mts-import"></code> Content:
    <code class="public-mts-import-content"></code> Content-Type:
    <code class="public-mts-import-content-type"></code>
  </li>
</ul>

<h2>CSS url references</h2>
<div>Font should be loaded (all text should be italic)</div>
<div class="css-url-absolute">
  <span style="background: #fff">CSS background (absolute)</span>
</div>
<div class="css-url-relative">
  <span style="background: #fff">CSS background (relative)</span>
</div>
<div class="css-url-encoded">
  <span style="background: #fff">CSS background (encoded)</span>
</div>
<div class="css-image-set-relative">
  <span style="background: #fff"
    >CSS background with image-set() (relative)</span
  >
</div>
<div class="css-image-set-without-url-call">
  <span style="background: #fff"
    >CSS background with image-set() (relative)</span
  >
</div>
<div class="css-image-set-with-var">
  <span style="background: #fff">
    CSS background image-set() (relative in var)
  </span>
</div>
<div class="css-image-set-mix-url-var">
  <span style="background: #fff">
    CSS background image-set() (mix var and url)
  </span>
</div>
<div class="css-image-set-base64">
  <span style="background: #fff">
    CSS background image-set() (with base64)
  </span>
</div>
<div class="css-image-set-gradient">
  <span style="background: #fff">
    CSS background image-set() (with gradient)
  </span>
</div>
<div class="css-image-set-multiple-descriptor">
  <span style="background: #fff">
    CSS background image-set() (with multiple descriptor)
  </span>
</div>
<div
  class="css-image-set-multiple-descriptor-inline-style"
  style="
    background-image: -webkit-image-set(
      './nested/asset.png' type('image/png') 1x,
      './nested/asset.png' type('image/png') 2x
    );
    background-size: 10px;
  "
>
  <span style="background: #fff">
    CSS background image-set() inline style (with multiple descriptor)
  </span>
</div>
<div
  class="image-set-and-url-exsiting-at-same-time"
  style="
    background-image:
      image-set(url('./nested/asset.png')), url('./nested/asset.png');
    background-size: 10px 10px;
  "
>
  <span style="background: #fff"
    >CSS background image-set() and url existing at the same time</span
  >
</div>
<div class="css-url-relative-at-imported">
  <span style="background: #fff"
    >CSS background (relative from @imported file in different dir)</span
  >
</div>
<div class="css-url-public">
  <span style="background: #fff">CSS background (public)</span>
</div>
<div class="css-url-data-uri">
  <span style="background: #fff">CSS background (data URI)</span>
</div>
<div class="css-url-base64-inline">
  <span style="background: #fff">CSS background (base64 inline in prod)</span>
</div>
<div class="css-url-quotes-base64-inline">
  <span style="background: #fff">CSS background (base64 inline in prod)</span>
</div>
<div class="css-url-same-line">
  <span style="background: #fff"
    >CSS background (multiple urls on same line)</span
  >
</div>
<div class="css-url-aliased">
  <span style="background: #fff">CSS background (aliased)</span>
</div>
<div class="css-url-preinlined-svg">
  <span style="background: #fff">CSS background (pre inlined SVG)</span>
</div>
<div class="css-manual-chunks-relative">
  <span style="background: #fff"
    >CSS nested manual chunks relative base background</span
  >
</div>

<div class="css-url-svg">
  <span style="background: #fff">CSS SVG background</span>
</div>
<div class="css-url-svg-in-url">
  <span style="background: #fff">CSS (?url) SVG background</span>
</div>

<div class="css-image-set-svg">
  <span style="background: #fff">CSS SVG background with image-set</span>
</div>

<div class="css-url-non-inline-hmr">
  <span style="background: #fff">CSS non-inlined background HMR</span>
</div>

<h2>Unicode URL</h2>
<div>
  <code class="unicode-url"></code>
  <img src="./nested/テスト-測試-white space.png" />
</div>

<h2>Filename including single quote</h2>
<div>
  <code class="filename-including-single-quote"></code>
</div>

<h2>Filename including percent</h2>
<div>
  <code class="percent-url"></code>
  <img src="./asset/percent%25.png" />
</div>

<h2>encodeURI for the address</h2>
<div>
  <img
    class="encodeURI"
    src="./nested/%E3%83%86%E3%82%B9%E3%83%88-%E6%B8%AC%E8%A9%A6-white%20space.png"
  />
</div>

<h2>Image Src Set</h2>
<div>
  <img
    class="img-src-set"
    src="./nested/asset.png"
    srcset="./nested/asset.png 1x, ./nested/asset.png 2x"
    alt=""
  />
  <img
    class="img-src-set-public"
    src="/icon space.png"
    srcset="/icon.png 1x, /icon.png 2x"
    alt=""
  />
  <img
    class="img-src-set-mixed"
    src="/icon.png"
    srcset="https://vite.dev/logo-with-shadow.png 1x, ./nested/asset.png 2x"
    alt=""
  />
</div>

<h2>HTML only asset</h2>
<div>
  <img class="img-src" src="./nested/html-only-asset.jpg" alt="" />
</div>

<h2>HTML inline asset</h2>
<div>
  <img class="img-src-inline" src="./nested/inlined.svg" alt="" />
</div>

<h2>SVG Fragments</h2>
<div>
  <img
    class="svg-frag-img"
    src="./nested/fragment.svg#icon-clock-view"
    alt=""
  />
  <img
    class="svg-frag-img"
    src="./nested/fragment.svg#icon-heart-view"
    alt=""
  />
  <img
    class="svg-frag-img"
    src="./nested/fragment.svg#icon-arrow-right-view"
    alt=""
  />
</div>

<h2>SVG Fragments via CSS background url</h2>
<div>
  <span class="icon icon-clock"></span>
  <span class="icon icon-heart"></span>
  <span class="icon icon-arrow-right"></span>
  <span class="icon icon-clock-alias"></span>
</div>

<h2>SVG Fragments via JS Import</h2>
<div>
  <p>Imported path: <code class="svg-frag-import-path"></code></p>
  <img class="svg-frag-import" alt="" />
</div>

<h2>Unknown extension assets import</h2>
<code class="unknown-ext"></code>

<h2>?raw import</h2>
<code class="raw"></code>
<code class="raw-html"></code>

<h2>?no-inline svg import</h2>
<code class="no-inline-svg"></code>

<h2>?no-inline svg import -- multiple postfix</h2>
<code class="no-inline-svg-mp"></code>

<h2>?inline png import</h2>
<code class="inline-png"></code>

<h2>?inline public png import</h2>
<code class="inline-public-png"></code>

<h2>?url&inline public json import</h2>
<code class="inline-public-json"></code>

<h2>?url import</h2>
<code class="url"></code>

<h2>?url import with css</h2>
<code class="url-css"></code>

<h2>new URL('...', import.meta.url)</h2>
<img class="import-meta-url-img" />
<code class="import-meta-url"></code>

<h2>new URL('@/...', import.meta.url)</h2>
<img class="import-meta-url-dep-img" />
<code class="import-meta-url-dep"></code>

<h2>new URL('/...', import.meta.url)</h2>
<img class="import-meta-url-base-path-img" />
<code class="import-meta-url-base-path"></code>

<h2>new URL('data:...', import.meta.url)</h2>
<img class="import-meta-url-data-uri-img" />
<code class="import-meta-url-data-uri"></code>

<h2>new URL('...', import.meta.url (without extension))</h2>
<p>
  <code class="import-meta-url-content-without-extension"></code>
</p>
<p>
  <code class="import-meta-url-without-extension"></code>
</p>

<h2>new URL('...', import.meta.url,) (with comma)</h2>
<img class="import-meta-url-img-comma" />
<code class="import-meta-url-comma"></code>

<h2>new URL('...', import.meta.url,) (with comma + new line)</h2>
<img class="import-meta-url-img-comma-nl" />
<code class="import-meta-url-comma-nl"></code>

<h2>new URL(`./${dynamic}`, import.meta.url)</h2>
<p>
  <img class="dynamic-import-meta-url-img-1" />
  <code class="dynamic-import-meta-url-1"></code>
</p>
<p>
  <img class="dynamic-import-meta-url-img-2" />
  <code class="dynamic-import-meta-url-2"></code>
</p>
<p>
  <code class="dynamic-import-meta-url-js"></code>
</p>

<h2>new URL(`./${dynamic}`, import.meta.url,) (with comma)</h2>
<p>
  <img class="dynamic-import-meta-url-img-1-comma" />
  <code class="dynamic-import-meta-url-1-comma"></code>
</p>
<p>
  <img class="dynamic-import-meta-url-img-2-comma" />
  <code class="dynamic-import-meta-url-2-comma"></code>
</p>

<h2>new URL(`./${dynamic}?abc`, import.meta.url)</h2>
<p>
  <img class="dynamic-import-meta-url-img-1-query" />
  <code class="dynamic-import-meta-url-1-query"></code>
</p>
<p>
  <img class="dynamic-import-meta-url-img-2-query" />
  <code class="dynamic-import-meta-url-2-query"></code>
</p>

<h2>new URL(`./${1 === 0 ? static : dynamic}?abc`, import.meta.url)</h2>
<p>
  <img class="dynamic-import-meta-url-img-1-ternary" />
  <code class="dynamic-import-meta-url-1-ternary"></code>
</p>
<p>
  <img class="dynamic-import-meta-url-img-2-ternary" />
  <code class="dynamic-import-meta-url-2-ternary"></code>
</p>

<h2>new URL(/* @vite-ignore */ 'non-existent', import.meta.url)</h2>
<p>
  <code class="non-existent-import-meta-url"></code>
</p>

<h2>new URL(`${dynamic}`, import.meta.url)</h2>
<p>
  <code class="dynamic-import-meta-url-all"></code>
</p>

<h2>simple script tag import-expression</h2>
<code class="import-expression"></code>
<code class="obj-import-express"></code>
<code class="string-import-express"></code>
<script>
  const obj = {
    import(t) {
      text('.obj-import-express', t)
    },
  }
  const stringImport = "const t = import('package')"
  function text(el, text) {
    document.querySelector(el).textContent = text
  }
  import('./static/import-expression.js')
  import('/import-expression.js')
  // import('./static/raw.js')
  /* import('./static/raw.js') */
  obj.import('ignore object import prop')
  try {
    text('.string-import-express', t)
  } catch {
    text('.string-import-express', 'no load')
  }
</script>
<h2>url in style tag</h2>
<h3>url</h3>
<style class="style-url">
  .style-url-assets {
    background: url('./nested/asset.png');
    background-size: 10px 10px;
  }
</style>
<div
  class="inline-style"
  style="background: url('./nested/asset.png'); background-size: 10px 10px"
>
  inline style
</div>
<div class="style-url-assets">use style class</div>

<h3>base64</h3>
<style class="style-base64">
  .style-base64-assets {
    background: url('./static/icon.png');
  }
</style>
<p class="inline-style-base64" style="background: url(./static/icon.png)">
  inline style
</p>
<p class="style-base64-assets">use style class</p>
<h3>from publicDir</h3>
<style>
  .style-public-assets {
    background: url('/icon.png');
  }
</style>
<p class="inline-style-public" style="background: url(/icon.png)">
  inline style
</p>
<p class="style-public-assets">use style class</p>

<h3 class="import-css">@import</h3>
<style class="style-import">
  @import url('./css/import.css');
</style>

<h3 class="foo-public">
  @import CSS from publicDir should load (this should be red)
</h3>
<h3 id="foo">import module css</h3>

<h3 class="raw-query"></h3>

<h3>style in svg</h3>
<svg viewBox="0 0 512 512" width="21" height="21" class="style-insvg">
  <style>
    .style-insvg-color {
      fill: #0088ff;
    }
  </style>
  <g class="style-insvg-color">
    <rect x="224" y="352" width="64" height="64" />
    <path
      d="M128 128v96h64v-96h96v96h-32v32h-32v64h64v-64h64V128h-32V96H160v32h-32z"
    />
  </g>
</svg>

<h3>assets in noscript</h3>
<noscript>
  <img class="noscript" src="./nested/asset.png" />
</noscript>

<h3>assets in template</h3>
<template>
  <img class="template" src="./nested/asset.png" />
</template>

<link rel="stylesheet" href="asset/style.css" />
<div class="relative-css">link style</div>
<div class="relative-js"></div>
<script src="asset/main.js" type="module"></script>
<style>
  @import '/foo.css';
</style>

<script type="module">
  import './css/fonts.css'
  import './css/css-url.css'
  import './css/icons.css'
  import './css/manual-chunks.css'

  text('.base', `import.meta.${``}env.BASE_URL: ${import.meta.env.BASE_URL}`)

  import url from './nested/asset.png'
  text('.asset-import-relative', url)

  import absoluteUrl from '/nested/asset.png'
  text('.asset-import-absolute', absoluteUrl)

  import publicUrl from '/icon.png'
  text('.public-import', publicUrl)

  import publicJsonUrl from '/foo.json?url'
  text('.public-json-import', publicJsonUrl)
  ;(async () => {
    const res = await fetch(publicJsonUrl)
    text('.public-json-import-content', await res.text())
  })()

  import publicJsUrl from '/raw.js?url'
  text('.public-js-import', publicJsUrl)
  ;(async () => {
    const res = await fetch(publicJsUrl)
    text('.public-js-import-content', await res.text())
    text(
      '.public-js-import-content-type',
      await res.headers.get('Content-Type'),
    )
  })()

  import publicTsUrl from '/raw.ts?url'
  text('.public-ts-import', publicTsUrl)
  ;(async () => {
    const res = await fetch(publicTsUrl)
    text('.public-ts-import-content', await res.text())
    text(
      '.public-ts-import-content-type',
      await res.headers.get('Content-Type'),
    )
  })()

  import publicMtsUrl from '/raw.mts?url'
  text('.public-mts-import', publicMtsUrl)
  ;(async () => {
    const res = await fetch(publicMtsUrl)
    text('.public-mts-import-content', await res.text())
    text(
      '.public-mts-import-content-type',
      await res.headers.get('Content-Type'),
    )
  })()

  import svgFrag from './nested/fragment.svg'
  text('.svg-frag-import-path', svgFrag)
  document.querySelector('.svg-frag-import').src = svgFrag + '#icon-heart-view'

  import unknownExtUrl from './nested/foo.unknown'
  text('.unknown-ext', unknownExtUrl)

  import rawSvg from './nested/fragment.svg?raw'
  text('.raw', rawSvg)

  import rawHtml from './nested/partial.html?raw'
  text('.raw-html', rawHtml)
  import.meta.hot?.accept('./nested/partial.html?raw', (m) => {
    text('.raw-html', m.default)
  })

  import noInlineSvg from './nested/fragment.svg?no-inline'
  text('.no-inline-svg', noInlineSvg)

  import noInlineSvgMP from './nested/fragment.svg?no-inline&foo=bar'
  text('.no-inline-svg-mp', noInlineSvgMP)

  import inlinePng from './nested/asset.png?inline'
  text('.inline-png', inlinePng)

  import inlinePublicPng from '/icon.png?inline'
  text('.inline-public-png', inlinePublicPng)

  import inlinePublicJson from '/foo.json?url&inline'
  text('.inline-public-json', inlinePublicJson)

  import fooUrl from './foo.js?url'
  text('.url', fooUrl)

  import unicodeUrl from './テスト-測試-white space.js?url'
  text('.unicode-url', unicodeUrl)

  import filenameIncludingSingleQuoteUrl from "./nested/with-single'quote.png"
  text('.filename-including-single-quote', filenameIncludingSingleQuoteUrl)

  // TODO: is not supported yet (https://github.com/vitejs/vite/pull/16243)
  // import percentUrl from './asset/percent%25.png?url'
  // text('.percent-url', percentUrl)

  import cssUrl from './css/icons.css?url'
  text('.url-css', cssUrl)

  import cssUrlUrl from './css/css-url-url.css?url'
  const linkTag = document.createElement('link')
  linkTag.href = cssUrlUrl
  linkTag.rel = 'stylesheet'
  document.body.appendChild(linkTag)

  // const url = new URL('non_existent_file.png', import.meta.url)
  const metaUrl = new URL('./import-meta-url/img.png', import.meta.url)
  text('.import-meta-url', metaUrl)
  document.querySelector('.import-meta-url-img').src = metaUrl

  const metaUrlDep = new URL('@/asset.png', import.meta.url)
  text('.import-meta-url-dep', metaUrlDep)
  document.querySelector('.import-meta-url-dep-img').src = metaUrlDep

  // testing URLs for public assets served at the public base path
  // equivalent to `new URL(`${import.meta.env.BASE_URL}/icon.png`, import.meta.url)
  const metaUrlBasePath = new URL('/icon.png', import.meta.url)
  text('.import-meta-url-base-path', metaUrlBasePath)
  document.querySelector('.import-meta-url-base-path-img').src = metaUrlBasePath

  const metaUrlDataUri = new URL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0CAYAAADWr1sfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTAyNkI1RkE4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTAyNkI1Rjk4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTc3NzA2Q0Y4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTc3NzA2RDA4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6nwnGxAAAJtklEQVR42txZ6W9c1RU/970373nsJHgZ27FThahSV8BCqGQTlIQ2EiUBReqHVpT8Af0r+NA/ogpqqWiDKrZuKYQPLGEpAlEFiqOgICSUBOKQhDjxeGY885bb37n3TGKPZ+4bx0uWK53Ec+cu53fPfkbtfu13B4noF6AQVAEpah0ak3cUSBU8qh46RfWj50ltKJDXXyBKdMtibI+TXlLqm2C87y/+eO/vlVIVnWbUcShFyld8T19ypvLbZKpyALOjVPCqrUcT1mWXYtIzMUV7Rqn315tJJyk+J51OZwb7QA3QkQD/fAL6JWiIXKMOhkOPwp1DFE/OkJ6NAQxn+fhuPhaFOc8DE9loern+hD9SfJVCdaLdOy5gif9rpHfyHp3pCX5cs6X1PfnORkr+SA9FO4bsgkZm1ykngm8ZK06ll0EvgWY6SwDn1fGKcykVfriewh2D5oKskhhw5KmFzLO0MJdO1yfS87UD2Uxc0tXErM+qLYQ5XUspK8el9JvagXSmPmH2W4lfG3wHNMHciXnmIfj+OvCVga8sD+yMYHyZAZ8H/Qk06dySaiNljf/DB0vklWAB1RQqnS0WA18eQE0Dz0++rjyRluOJDHuzWkwZNAPgLPHfPIeHTK/EEzHWKt/zDdh2asBmUUnJg3TDB0rQIuYptby5x6RgPO/JxIes304p44V1DMAzKQUbe4xqa62h2vbFyWuxeUie1RKqvVmXG/sxOaYKPqliQKp3HmEOB43pWaxJaTPvUV6rdK3Z6FloGUt35yD54EGXEwvaU3nSPSIYF7D5T/mio1rzS7Jaa1we4YWDzb1GUpptqJ1OGUl7BJX+jS7HP/OKEPlgRH5/SP5AZMjrCTz+jtdQQckxauEZ/IZ4bKyhYEsv7h6GpmGuhnsznafORwQbtQKGY6F/gy64pMxPnF2JSQ33UM/ecWNX/PJG3RbYsn15qCiYTQdhr49j9m4jQd8zXlkFZv3d/B087SBM4OodC+5kJYIX5r09+8ZIDYYAn4gqOdFeEEwn2gFmMb0BesEpZeOxARAOJ4SXjLbDlljKcbaQ0ebwrRNLy409oH1Xz1H2xrRc3wfaYx1dm/sgQTyYMZ1wZ4nC+4es76gnC3lqP14QTFk7wDymQH8DnXKCZibKiQHY89gY+aUeGwcT66xaw40JMUnWn52t7NWVeKt5GNaUarw1naruxXn9Rrrz9jRjLsd5PtsfZY3aaBZo9tT5qnxKsExRizto59EOccRzJQomHAC0DzsOHxwy3lvXk8VxU1u1VJFPaSW5B177SRtfNaVnq08izNyjQl9UefFe4zNwdoTI4I8XTfznu3NUORYMiyKP10HvD4neZy7VzqBaHEOjnw5TsKnXfgaDRjKqxWuzzRKtTy/Wt2W1ZAukuyX9tr4Ns+vZpheAVfKoOCuDKrNzDB8Ysp9Znd2qnAnvh9r5I8+hDs86HRhfCIlyQqGgbuHDI0Sz9gHaZj0sQXhhpJhbktOVp5Kvak/x31Sg9rarRXVxXvjwKJxk0Z7N/sOjPEf1bCez7LS1Ji/0iduBAUAD6JDpRFsHqfDjDZRdTqyU26gn2ykkXUovzf2KCV66ZGxXL9YeVtsMMb9w1x0U/WTAADWqnGO4wvMhwdA14PmqfbLjClZdTkaqCFPrAor2byIvUsZrd5Syp4BaFYW8RUmDeG8+wwsVRY+Pk7c+MJpkChXfCfhkJ1XuBjCPV0Bvt0nhFwoPiQfbVjixgaKHho3qGSlbgIu9ti/VEdHifJkdVc2aRoizwnv7kT+nNuy5hxZeX3EtygM8DfoX6FPnCcxL1Yap6NGNCCFFk5x0ETra2i7v9TcWqbh3zIbASmzvcHP7qfA6vRzAJIH7JWeYktRPz2a2bHuoZKpEdjgWdBeoWboMTpwea4o3GiF1lXzZPWLh8Y3ca7oAPAd6E/RubjLCkgBz4fYhCu6cl2d73UmX13KSUcDecNugqX2Np9a5mvKu8Di3EoB5HAP9WboGnZMRFiiXb0MhhYjNOrbeVsc5DPPexEqXz+C9HufLHHPT3PyxIbwd6wZIt4DnxCG81lG1JT9miZiaGeVj8L0+m3I2UrdaezY/z65Auj9ab0vPNLOlp+fEGwtPb3cj3aUA5nEWdDA3GTGMpqT6AupFmLLpYWaL9Hag2XZZdVHqcR1cfGzchDhdyWwFpnKTjIPCG600YFad96S+rHeOzZ5tB7Et3jeItLNk8+Fa2j6jYnU2YSyhaNcwFe4dMHv5DD7L1WUTXt5zmtoyADe7Bwfn15cdHZix3cxIzB+ObC+q2Z1Q6pq0E6gynF0A715ErasbqQWbH9JOCC8zSwGwVMA8Phb3X3a2g5BnZ5cRT78Dj7trxMRR7liY+lhdu5ntVnFDFLm4N1a0nr2e5rVtysLDx0tl/noAc9X7TLNH5KxZuC1Tg6puH0SYKtoaumFrYWPbsS0xg+/2UbjVVkNXW67u8aHwkKwFYB6fgQ47nYXXBBSbEBPtGjUtnWy6YcEm/F1q5sLdkO5AQTonuap8Vu7+7HoYv17APF4Fve6KrabEkzhcuH+AAuTFGmmjkeScbdsU7hswxGtMkqJzM7PX5W5aa8BfSDdwyt30I9Nw44qn+MgYef1IKC42SLN9D4TU8+iYCWGmKSfdEceYkju/uBGAebwvDW53KcOeFxlYcBeqqd3DBiznyCHCUPCDdUTsweM0765M7np/OQwvF/A5aYOedDcKmo23zP5qsalovTfny9wL4xQyP18+KXedu5GAmx0G9pizrsrAJCOQsuovUPTIKIU/HzG/SPKczks97dnPODswXY5gBQDXxK72g3a0fURT5yoTY7nw5w6ksVcAzZq/C7mbcv+TO2rLZXYlJMzjtNjXBedN7IlBXuibtq3ph8W5vw1dkLNPrwSjKwWY89oXQf9xNgqaXruaWLulXK8cy5kvOvP3GwC4mWc/50wImj+xaLrmpFRugvPcUvPltQJMUr0cXcHzjpLrF82bAHBN1O+dFTjrHTmrdjMD5vER6B/LZLQmZ3y00sytBuC65LtvLeOMt+SM+q0AmMekNNbK17G3LHsnV4Ox1QLM4wNRy3gJe2LZ88FqMbWagL8CPe2sptpXQ0/L3lsOMGcW3Cv+O+hyF+svy9pjsveWA9z0tn8Afd7F2s9lbW01GVptwJxTHZfE3/Uj17SsOU7ddLRuYsDN8decDOyorFn1sVaAvyT7k8iZNt+dke++vJ0A8+CfMw+3mT8s39HtBviSgDs+b+64zF26HQHz+C/o+Xmfn5c5ul0BXyT7w/U5oTdlbs1GQGs/vgb9cd7fazr+L8AAD0zRYMSYHQAAAAAASUVORK5CYII=',
    import.meta.url,
  )
  text('.import-meta-url-data-uri', metaUrlDataUri)
  document.querySelector('.import-meta-url-data-uri-img').src = metaUrlDataUri

  const metaUrlWithoutExtension = new URL('./nested/test', import.meta.url)
  text('.import-meta-url-without-extension', metaUrlWithoutExtension)
  ;(async () => {
    const res = await fetch(metaUrlWithoutExtension)
    text('.import-meta-url-content-without-extension', await res.text())
  })()

  // prettier-ignore
  const metaUrlWithComma = new URL('./nested/asset.png', import.meta.url,)
  text('.import-meta-url-comma', metaUrlWithComma)
  document.querySelector('.import-meta-url-img-comma').src = metaUrlWithComma

  // testing trailing comma and new line
  // prettier-ignore
  const metaUrlWithCommaNL = new URL(
    './nested/asset.png',
    import.meta.url,
  )
  text('.import-meta-url-comma-nl', metaUrlWithCommaNL)
  document.querySelector('.import-meta-url-img-comma-nl').src =
    metaUrlWithCommaNL

  import classNames from './css/foo.module.css'
  document.querySelector('#foo').className = classNames['foo-module']

  import someString from './static/foo.txt?raw'
  document.querySelector('.raw-query').textContent = someString

  const metaUrlNonExistent = new URL(
    /* @vite-ignore */ 'non-existent',
    import.meta.url,
  ).pathname
  text('.non-existent-import-meta-url', metaUrlNonExistent)

  /**
   * don't process the code in the comment
   * const url = new URL('non_existent_file.png', import.meta.url)
   */

  function testDynamicImportMetaUrl(name, i) {
    const metaUrl = new URL(`./nested/${name}.png`, import.meta.url)
    text(`.dynamic-import-meta-url-${i}`, metaUrl)
    document.querySelector(`.dynamic-import-meta-url-img-${i}`).src = metaUrl
  }

  testDynamicImportMetaUrl('icon', 1)
  testDynamicImportMetaUrl('asset', 2)

  function testDynamicImportMetaUrlWithComma(name, i) {
    // prettier-ignore
    const metaUrl = new URL(`./nested/${name}.png`, import.meta.url,)
    text(`.dynamic-import-meta-url-${i}-comma`, metaUrl)
    document.querySelector(`.dynamic-import-meta-url-img-${i}-comma`).src =
      metaUrl
  }

  testDynamicImportMetaUrlWithComma('icon', 1)
  testDynamicImportMetaUrlWithComma('asset', 2)

  function testDynamicImportMetaUrlWithQuery(name, i) {
    // prettier-ignore
    const metaUrl = new URL(`./nested/${name}.png?abc`, import.meta.url,)
    text(`.dynamic-import-meta-url-${i}-query`, metaUrl)
    document.querySelector(`.dynamic-import-meta-url-img-${i}-query`).src =
      metaUrl
  }

  testDynamicImportMetaUrlWithQuery('icon', 1)
  testDynamicImportMetaUrlWithQuery('asset', 2)

  function testDynamicImportMetaUrlWithTernaryOperator(name, i) {
    // prettier-ignore
    const metaUrl = new URL(`./nested/${1 === 0 ? 'failed' : name}.png?abc`, import.meta.url,)
    text(`.dynamic-import-meta-url-${i}-ternary`, metaUrl)
    document.querySelector(`.dynamic-import-meta-url-img-${i}-ternary`).src =
      metaUrl
  }

  testDynamicImportMetaUrlWithTernaryOperator('icon', 1)
  testDynamicImportMetaUrlWithTernaryOperator('asset', 2)

  {
    const name = 'test'
    const js = new URL(`./nested/${name}.js`, import.meta.url).href
    text('.dynamic-import-meta-url-js', js)
  }

  {
    const name = './nested/icon'
    const metaUrl = new URL(`${name}.png`, import.meta.url)
    text(`.dynamic-import-meta-url-all`, metaUrl)
  }

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/assets/manifest.json
================================================
{}



================================================
FILE: playground/assets/package.json
================================================
{
  "name": "@vitejs/test-assets",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "dev:encoded-base": "vite --config ./vite.config-encoded-base.js dev",
    "build:encoded-base": "vite --config ./vite.config-encoded-base.js build",
    "preview:encoded-base": "vite --config ./vite.config-encoded-base.js preview",
    "dev:relative-base": "vite --config ./vite.config-relative-base.js dev",
    "build:relative-base": "vite --config ./vite.config-relative-base.js build",
    "preview:relative-base": "vite --config ./vite.config-relative-base.js preview",
    "dev:runtime-base": "vite --config ./vite.config-runtime-base.js dev",
    "build:runtime-base": "vite --config ./vite.config-runtime-base.js build",
    "preview:runtime-base": "vite --config ./vite.config-runtime-base.js preview",
    "dev:url-base": "vite --config ./vite.config-url-base.js dev",
    "build:url-base": "vite --config ./vite.config-url-base.js build",
    "preview:url-base": "vite --config ./vite.config-url-base.js preview"
  }
}



================================================
FILE: playground/assets/vite.config-encoded-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

/** see `ports` variable in test-utils.ts */
const port = 9524

export default defineConfig({
  ...baseConfig,
  // Vite should auto-encode  this as `/foo%20bar/` internally
  base: '/foo bar/',
  server: {
    port,
    strictPort: true,
  },
  build: {
    ...baseConfig.build,
    outDir: 'dist/encoded-base',
    watch: null,
    minify: false,
    assetsInlineLimit: 0,
    rollupOptions: {
      output: {
        entryFileNames: 'entries/[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        assetFileNames: 'other-assets/[name]-[hash][extname]',
      },
    },
  },
  preview: {
    port,
    strictPort: true,
  },
  cacheDir: 'node_modules/.vite-encoded-base',
})



================================================
FILE: playground/assets/vite.config-relative-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

export default defineConfig(({ isPreview }) => ({
  ...baseConfig,
  base: !isPreview ? './' : '/relative-base/', // relative base to make dist portable
  build: {
    ...baseConfig.build,
    outDir: 'dist/relative-base',
    watch: null,
    minify: false,
    assetsInlineLimit: 0,
    rollupOptions: {
      output: {
        entryFileNames: 'entries/[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        assetFileNames: 'other-assets/[name]-[hash][extname]',
        manualChunks(id) {
          if (id.includes('css/manual-chunks.css')) {
            return 'css/manual-chunks'
          }
        },
      },
    },
  },
  cacheDir: 'node_modules/.vite-relative-base',
}))



================================================
FILE: playground/assets/vite.config-runtime-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

const dynamicBaseAssetsCode = `
globalThis.__toAssetUrl = url => '/' + url
globalThis.__publicBase = '/'
`

export default defineConfig({
  ...baseConfig,
  base: './', // overwrite the original base: '/foo/'
  build: {
    ...baseConfig.build,
    outDir: 'dist/runtime-base',
    watch: null,
    minify: false,
    assetsInlineLimit: 0,
    rollupOptions: {
      output: {
        entryFileNames: 'entries/[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        assetFileNames: 'other-assets/[name]-[hash][extname]',
      },
    },
  },
  plugins: [
    {
      name: 'dynamic-base-assets-globals',
      transformIndexHtml(_, ctx) {
        if (ctx.bundle) {
          // Only inject during build
          return [
            {
              tag: 'script',
              attrs: { type: 'module' },
              children: dynamicBaseAssetsCode,
            },
          ]
        }
      },
    },
  ],
  experimental: {
    renderBuiltUrl(filename, { hostType, type }) {
      if (type === 'asset') {
        if (hostType === 'js') {
          return {
            runtime: `globalThis.__toAssetUrl(${JSON.stringify(filename)})`,
          }
        }
      } else if (type === 'public') {
        if (hostType === 'js') {
          return {
            runtime: `globalThis.__publicBase+${JSON.stringify(filename)}`,
          }
        }
      }
    },
  },
  cacheDir: 'node_modules/.vite-runtime-base',
})



================================================
FILE: playground/assets/vite.config-url-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

/** see `ports` variable in test-utils.ts */
const port = 9525

export default defineConfig({
  ...baseConfig,
  base: `http://localhost:${port}/`,
  server: {
    port,
    strictPort: true,
  },
  build: {
    ...baseConfig.build,
    outDir: 'dist/url-base',
    watch: null,
    minify: false,
    assetsInlineLimit: 0,
    rollupOptions: {
      output: {
        entryFileNames: 'entries/[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        assetFileNames: 'other-assets/[name]-[hash][extname]',
      },
    },
  },
  preview: {
    port,
    strictPort: true,
  },
  cacheDir: 'node_modules/.vite-url-base',
})



================================================
FILE: playground/assets/vite.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  base: '/foo/bar',
  publicDir: 'static',
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'nested'),
      fragment: path.resolve(__dirname, 'nested/fragment-bg.svg'),
    },
  },
  assetsInclude: ['**/*.unknown'],
  build: {
    outDir: 'dist/foo',
    assetsInlineLimit: 8000, // 8 kB
    manifest: true,
    watch: {},
  },
})



================================================
FILE: playground/assets/テスト-測試-white space.js
================================================
console.log('test Unicode')



================================================
FILE: playground/assets/__tests__/assets.spec.ts
================================================
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import {
  browserLogs,
  editFile,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  isServe,
  listAssets,
  notifyRebuildComplete,
  page,
  readFile,
  readManifest,
  serverLogs,
  viteTestUrl,
  watcher,
} from '~utils'

const assetMatch = isBuild
  ? /\/foo\/bar\/assets\/asset-[-\w]{8}\.png/
  : '/foo/bar/nested/asset.png'

const encodedAssetMatch = isBuild
  ? /\/foo\/bar\/assets\/asset_small_-[-\w]{8}\.png/
  : '/foo/bar/nested/asset[small].png'

const iconMatch = `/foo/bar/icon.png`

const fetchPath = (p: string) => {
  return fetch(path.posix.join(viteTestUrl, p), {
    headers: { Accept: 'text/html,*/*' },
  })
}

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

test.runIf(isBuild)(
  'should not warn about VITE_ASSET tokens in image-set',
  async () => {
    expect(serverLogs).toStrictEqual(
      expect.not.arrayContaining([
        expect.stringMatching(/VITE_ASSET__.*?didn't resolve at build time/),
      ]),
    )
  },
)

test('should get a 404 when using incorrect case', async () => {
  expect((await fetchPath('icon.png')).headers.get('Content-Type')).toBe(
    'image/png',
  )
  // fallback to index.html
  const iconPngResult = await fetchPath('ICON.png')
  expect(iconPngResult.headers.get('Content-Type')).toBe('text/html')
  expect(iconPngResult.status).toBe(200)

  expect((await fetchPath('bar')).headers.get('Content-Type')).toBe('')
  // fallback to index.html
  const barResult = await fetchPath('BAR')
  expect(barResult.headers.get('Content-Type')).toContain('text/html')
  expect(barResult.status).toBe(200)
})

test('should fallback to index.html when accessing non-existant html file', async () => {
  expect((await fetchPath('doesnt-exist.html')).status).toBe(200)
})

describe.runIf(isServe)('outside base', () => {
  test('should get a 404 with html', async () => {
    const res = await fetch(new URL('/baz', viteTestUrl), {
      headers: { Accept: 'text/html,*/*' },
    })
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Type')).toBe('text/html')
  })

  test('should get a 404 with text', async () => {
    const res = await fetch(new URL('/baz', viteTestUrl))
    expect(res.status).toBe(404)
    expect(res.headers.get('Content-Type')).toBe('text/plain')
  })
})

describe('injected scripts', () => {
  test('@vite/client', async () => {
    const hasClient = await page.$(
      'script[type="module"][src="/foo/bar/@vite/client"]',
    )
    if (isBuild) {
      expect(hasClient).toBeFalsy()
    } else {
      expect(hasClient).toBeTruthy()
    }
  })

  test('html-proxy', async () => {
    const hasHtmlProxy = await page.$(
      'script[type="module"][src^="/foo/bar/index.html?html-proxy"]',
    )
    if (isBuild) {
      expect(hasHtmlProxy).toBeFalsy()
    } else {
      expect(hasHtmlProxy).toBeTruthy()
    }
  })
})

describe('raw references from /public', () => {
  test('load raw js from /public', async () => {
    expect(await page.textContent('.raw-js')).toMatch('[success]')
  })

  test('load raw css from /public', async () => {
    expect(await getColor('.raw-css')).toBe('red')
  })
})

test('import-expression from simple script', async () => {
  expect(await page.textContent('.import-expression')).toMatch(
    '[success][success]',
  )
})

describe('asset imports from js', () => {
  test('relative', async () => {
    expect(await page.textContent('.asset-import-relative')).toMatch(assetMatch)
  })

  test('absolute', async () => {
    expect(await page.textContent('.asset-import-absolute')).toMatch(assetMatch)
  })

  test('from /public', async () => {
    expect(await page.textContent('.public-import')).toMatch(iconMatch)
  })

  test('from /public (json)', async () => {
    expect(await page.textContent('.public-json-import')).toMatch(
      '/foo/bar/foo.json',
    )
    expect(await page.textContent('.public-json-import-content'))
      .toMatchInlineSnapshot(`
        "{
          "foo": "bar"
        }
        "
      `)
  })

  test('from /public (js)', async () => {
    expect(await page.textContent('.public-js-import')).toMatch(
      '/foo/bar/raw.js',
    )
    expect(await page.textContent('.public-js-import-content'))
      .toMatchInlineSnapshot(`
        "document.querySelector('.raw-js').textContent =
          '[success] Raw js from /public loaded'
        "
      `)
    expect(await page.textContent('.public-js-import-content-type')).toMatch(
      'text/javascript',
    )
  })

  test('from /public (ts)', async () => {
    expect(await page.textContent('.public-ts-import')).toMatch(
      '/foo/bar/raw.ts',
    )
    expect(await page.textContent('.public-ts-import-content'))
      .toMatchInlineSnapshot(`
      "export default function other() {
        return 1 + 2
      }
      "
    `)
    // NOTE: users should configure the mime type for .ts files for preview server
    if (isServe) {
      expect(await page.textContent('.public-ts-import-content-type')).toMatch(
        'text/javascript',
      )
    }
  })

  test('from /public (mts)', async () => {
    expect(await page.textContent('.public-mts-import')).toMatch(
      '/foo/bar/raw.mts',
    )
    expect(await page.textContent('.public-mts-import-content'))
      .toMatchInlineSnapshot(`
      "export default function foobar() {
        return 1 + 2
      }
      "
    `)
    // NOTE: users should configure the mime type for .ts files for preview server
    if (isServe) {
      expect(await page.textContent('.public-mts-import-content-type')).toMatch(
        'text/javascript',
      )
    }
  })
})

describe('css url() references', () => {
  test('fonts', async () => {
    expect(
      await page.evaluate(() => {
        return (document as any).fonts.check('700 32px Inter')
      }),
    ).toBe(true)
  })

  test('relative', async () => {
    expect(await getBg('.css-url-relative')).toMatch(assetMatch)
  })

  test('encoded', async () => {
    expect(await getBg('.css-url-encoded')).toMatch(encodedAssetMatch)
  })

  test('image-set relative', async () => {
    const imageSet = await getBg('.css-image-set-relative')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set without the url() call', async () => {
    const imageSet = await getBg('.css-image-set-without-url-call')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set with var', async () => {
    const imageSet = await getBg('.css-image-set-with-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set with mix', async () => {
    const imageSet = await getBg('.css-image-set-mix-url-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set with base64', async () => {
    const imageSet = await getBg('.css-image-set-base64')
    expect(imageSet).toContain('image-set(url("data:image/png;base64,')
  })

  test('image-set with gradient', async () => {
    const imageSet = await getBg('.css-image-set-gradient')
    expect(imageSet).toContain('image-set(url("data:image/png;base64,')
  })

  test('image-set with multiple descriptor', async () => {
    const imageSet = await getBg('.css-image-set-multiple-descriptor')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set with multiple descriptor as inline style', async () => {
    const imageSet = await getBg(
      '.css-image-set-multiple-descriptor-inline-style',
    )
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(assetMatch)
    })
  })

  test('image-set and url exist at the same time.', async () => {
    const imageSet = await getBg('.image-set-and-url-exsiting-at-same-time')
    expect(imageSet).toMatch(assetMatch)
  })

  test('relative in @import', async () => {
    expect(await getBg('.css-url-relative-at-imported')).toMatch(assetMatch)
  })

  test('absolute', async () => {
    expect(await getBg('.css-url-absolute')).toMatch(assetMatch)
  })

  test('from /public', async () => {
    expect(await getBg('.css-url-public')).toMatch(iconMatch)
  })

  test('base64 inline', async () => {
    const match = isBuild ? `data:image/png;base64` : `/foo/bar/nested/icon.png`
    expect(await getBg('.css-url-base64-inline')).toMatch(match)
    expect(await getBg('.css-url-quotes-base64-inline')).toMatch(match)
  })

  test('no base64 inline for icon and manifest links', async () => {
    const iconEl = await page.$(`link.ico`)
    const href = await iconEl.getAttribute('href')
    expect(href).toMatch(
      isBuild ? /\/foo\/bar\/assets\/favicon-[-\w]{8}\.ico/ : 'favicon.ico',
    )

    const manifestEl = await page.$(`link[rel="manifest"]`)
    const manifestHref = await manifestEl.getAttribute('href')
    expect(manifestHref).toMatch(
      isBuild ? /\/foo\/bar\/assets\/manifest-[-\w]{8}\.json/ : 'manifest.json',
    )
  })

  test('multiple urls on the same line', async () => {
    const bg = await getBg('.css-url-same-line')
    expect(bg).toMatch(assetMatch)
    expect(bg).toMatch(iconMatch)
  })

  test('aliased', async () => {
    const bg = await getBg('.css-url-aliased')
    expect(bg).toMatch(assetMatch)
  })

  test('preinlined SVG', async () => {
    expect(await getBg('.css-url-preinlined-svg')).toMatch(
      /data:image\/svg\+xml,.+/,
    )
  })

  test.runIf(isBuild)('generated paths in CSS', () => {
    const css = findAssetFile(/index-[-\w]{8}\.css$/, 'foo')

    // preserve postfix query/hash
    expect(css).toMatch(`woff2?#iefix`)

    // generate non-relative base for public path in CSS
    expect(css).not.toMatch(`../icon.png`)
  })

  test('url() with svg', async () => {
    const bg = await getBg('.css-url-svg')
    expect(bg).toMatch(/data:image\/svg\+xml,.+/)
    expect(bg).toContain('blue')
    expect(bg).not.toContain('red')

    if (isServe) {
      editFile('nested/fragment-bg-hmr.svg', (code) =>
        code.replace('fill="blue"', 'fill="red"'),
      )
      await expect.poll(() => getBg('.css-url-svg')).toMatch('red')
    }
  })

  test('image-set() with svg', async () => {
    expect(await getBg('.css-image-set-svg')).toMatch(/data:image\/svg\+xml,.+/)
  })

  test('url() with svg in .css?url', async () => {
    const bg = await getBg('.css-url-svg-in-url')
    expect(bg).toMatch(/data:image\/svg\+xml,.+/)
    expect(bg).toContain('blue')
    expect(bg).not.toContain('red')

    if (isServe) {
      editFile('nested/fragment-bg-hmr2.svg', (code) =>
        code.replace('fill="blue"', 'fill="red"'),
      )
      await expect.poll(() => getBg('.css-url-svg')).toMatch('red')
    }
  })

  test.runIf(isServe)('non inlined url() HMR', async () => {
    const bg = await getBg('.css-url-non-inline-hmr')
    editFile('nested/donuts-large.svg', (code) =>
      code.replace('fill="blue"', 'fill="red"'),
    )
    await expect.poll(() => getBg('.css-url-non-inline-hmr')).not.toBe(bg)
  })
})

describe('image', () => {
  test('src', async () => {
    const img = await page.$('.img-src')
    const src = await img.getAttribute('src')
    expect(src).toMatch(
      isBuild
        ? /\/foo\/bar\/assets\/html-only-asset-[-\w]{8}\.jpg/
        : /\/foo\/bar\/nested\/html-only-asset.jpg/,
    )
  })

  test('src inline', async () => {
    const img = await page.$('.img-src-inline')
    const src = await img.getAttribute('src')
    expect(src).toMatch(
      isBuild
        ? /^data:image\/svg\+xml,%3csvg/
        : /\/foo\/bar\/nested\/inlined.svg/,
    )
  })

  test('srcset', async () => {
    const img = await page.$('.img-src-set')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(
        isBuild
          ? /\/foo\/bar\/assets\/asset-[-\w]{8}\.png \dx/
          : /\/foo\/bar\/nested\/asset.png \dx/,
      )
    })
  })

  test('srcset (public)', async () => {
    const img = await page.$('.img-src-set-public')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(/\/foo\/bar\/icon\.png \dx/)
    })
  })

  test('srcset (mixed)', async () => {
    const img = await page.$('.img-src-set-mixed')
    const srcset = await img.getAttribute('srcset')
    const srcs = srcset.split(', ')
    expect(srcs[1]).toMatch(
      isBuild
        ? /\/foo\/bar\/assets\/asset-[-\w]{8}\.png \dx/
        : /\/foo\/bar\/nested\/asset.png \dx/,
    )
  })
})

describe('meta', () => {
  test('og image', async () => {
    const meta = await page.$('.meta-og-image')
    const content = await meta.getAttribute('content')
    expect(content).toMatch(
      isBuild
        ? /\/foo\/bar\/assets\/asset-\w{8}\.png/
        : /\/foo\/bar\/nested\/asset.png/,
    )
  })
})

describe('svg fragments', () => {
  // 404 is checked already, so here we just ensure the urls end with #fragment
  test('img url', async () => {
    const img = await page.$('.svg-frag-img')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-clock-view$/)
  })

  test('via css url()', async () => {
    expect(await getBg('.icon')).toMatch(/svg#icon-clock-view"\)$/)
  })

  test('from js import', async () => {
    const img = await page.$('.svg-frag-import')
    expect(await img.getAttribute('src')).toMatch(
      // Assert trimmed (data URI starts with < and ends with >)
      /^data:image\/svg\+xml,%3c.*%3e#icon-heart-view$/,
    )
  })

  test('url with an alias', async () => {
    expect(await getBg('.icon-clock-alias')).toMatch(
      /\.svg#icon-clock-view"\)$/,
    )
  })
})

test('Unknown extension assets import', async () => {
  expect(await page.textContent('.unknown-ext')).toMatch(
    isBuild ? 'data:application/octet-stream;' : '/nested/foo.unknown',
  )
})

test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
  expect(await page.textContent('.raw-html')).toBe('<div>partial</div>\n')

  if (isBuild) return
  editFile('nested/partial.html', (code) =>
    code.replace('<div>partial</div>', '<div>partial updated</div>'),
  )
  await expect
    .poll(() => page.textContent('.raw-html'))
    .toBe('<div>partial updated</div>\n')
  expect(browserLogs).toStrictEqual(
    expect.arrayContaining([
      expect.stringContaining('hot updated: /nested/partial.html?raw via'),
    ]),
  )
})

test('?no-inline svg import', async () => {
  expect(await page.textContent('.no-inline-svg')).toMatch(
    isBuild
      ? /\/foo\/bar\/assets\/fragment-[-\w]{8}\.svg/
      : '/foo/bar/nested/fragment.svg?no-inline',
  )
})

test('?no-inline svg import -- multiple postfix', async () => {
  expect(await page.textContent('.no-inline-svg-mp')).toMatch(
    isBuild
      ? /\/foo\/bar\/assets\/fragment-[-\w]{8}\.svg\?foo=bar/
      : '/foo/bar/nested/fragment.svg?no-inline&foo=bar',
  )
})

test('?inline png import', async () => {
  expect(await page.textContent('.inline-png')).toMatch(
    /^data:image\/png;base64,/,
  )
})

test('?inline public png import', async () => {
  expect(await page.textContent('.inline-public-png')).toMatch(
    /^data:image\/png;base64,/,
  )
})

test('?inline public json import', async () => {
  expect(await page.textContent('.inline-public-json')).toMatch(
    /^data:application\/json;base64,/,
  )
})

test('?url import', async () => {
  const src = readFile('foo.js')
  expect(await page.textContent('.url')).toMatch(
    isBuild
      ? `data:text/javascript;base64,${Buffer.from(src).toString('base64')}`
      : `/foo/bar/foo.js`,
  )
})

test('?url import on css', async () => {
  const txt = await page.textContent('.url-css')
  expect(txt).toMatch(
    isBuild
      ? /\/foo\/bar\/assets\/icons-[-\w]{8}\.css/
      : '/foo/bar/css/icons.css',
  )
})

describe('unicode url', () => {
  test('from js import', async () => {
    const src = readFile('テスト-測試-white space.js')
    expect(await page.textContent('.unicode-url')).toMatch(
      isBuild
        ? `data:text/javascript;base64,${Buffer.from(src).toString('base64')}`
        : encodeURI(`/foo/bar/テスト-測試-white space.js`),
    )
  })
})

describe.runIf(isBuild)('encodeURI', () => {
  test('img src with encodeURI', async () => {
    const img = await page.$('.encodeURI')
    expect(await img.getAttribute('src')).toMatch(/^data:image\/png;base64,/)
  })
})

test('new URL(..., import.meta.url)', async () => {
  const imgMatch = isBuild
    ? /\/foo\/bar\/assets\/img-[-\w]{8}\.png/
    : '/foo/bar/import-meta-url/img.png'

  expect(await page.textContent('.import-meta-url')).toMatch(imgMatch)
  if (isServe) {
    const loadPromise = page.waitForEvent('load')
    const newContent = readFile('import-meta-url/img-update.png', null)
    let oldContent: Buffer
    editFile('import-meta-url/img.png', null, (_oldContent) => {
      oldContent = _oldContent
      return newContent
    })
    await loadPromise // expect reload
    await expect
      .poll(() => page.textContent('.import-meta-url'))
      .toMatch(imgMatch)

    const loadPromise2 = page.waitForEvent('load')
    editFile('import-meta-url/img.png', null, (_) => oldContent)
    await loadPromise2 // expect reload
    await expect
      .poll(() => page.textContent('.import-meta-url'))
      .toMatch(imgMatch)
  }
})

test('new URL("@/...", import.meta.url)', async () => {
  expect(await page.textContent('.import-meta-url-dep')).toMatch(assetMatch)
})

test('new URL("/...", import.meta.url)', async () => {
  expect(await page.textContent('.import-meta-url-base-path')).toMatch(
    iconMatch,
  )
})

test('new URL("data:...", import.meta.url)', async () => {
  const img = await page.$('.import-meta-url-data-uri-img')
  expect(await img.getAttribute('src')).toMatch(/^data:image\/png;base64,/)
  expect(await page.textContent('.import-meta-url-data-uri')).toMatch(
    /^data:image\/png;base64,/,
  )
})

test('new URL(..., import.meta.url) without extension', async () => {
  expect(await page.textContent('.import-meta-url-without-extension')).toMatch(
    isBuild ? 'data:text/javascript' : 'nested/test.js',
  )
  expect(
    await page.textContent('.import-meta-url-content-without-extension'),
  ).toContain('export default class')
})

test('new URL(`${dynamic}`, import.meta.url)', async () => {
  expect(await page.textContent('.dynamic-import-meta-url-1')).toMatch(
    isBuild ? 'data:image/png;base64' : '/foo/bar/nested/icon.png',
  )
  expect(await page.textContent('.dynamic-import-meta-url-2')).toMatch(
    assetMatch,
  )
  expect(await page.textContent('.dynamic-import-meta-url-js')).toMatch(
    isBuild ? 'data:text/javascript;base64' : '/foo/bar/nested/test.js',
  )
})

test('new URL(`./${dynamic}?abc`, import.meta.url)', async () => {
  expect(await page.textContent('.dynamic-import-meta-url-1-query')).toMatch(
    isBuild ? 'data:image/png;base64' : '/foo/bar/nested/icon.png?abc',
  )
  expect(await page.textContent('.dynamic-import-meta-url-2-query')).toMatch(
    isBuild
      ? /\/foo\/bar\/assets\/asset-[-\w]{8}\.png\?abc/
      : '/foo/bar/nested/asset.png?abc',
  )
})

test('new URL(`./${1 === 0 ? static : dynamic}?abc`, import.meta.url)', async () => {
  expect(await page.textContent('.dynamic-import-meta-url-1-ternary')).toMatch(
    isBuild ? 'data:image/png;base64' : '/foo/bar/nested/icon.png?abc',
  )
  expect(await page.textContent('.dynamic-import-meta-url-2-ternary')).toMatch(
    isBuild
      ? /\/foo\/bar\/assets\/asset-[-\w]{8}\.png\?abc/
      : '/foo/bar/nested/asset.png?abc',
  )
})

test("new URL(/* @vite-ignore */ 'non-existent', import.meta.url)", async () => {
  // the inlined script tag is extracted in a separate file
  const importMetaUrl = new URL(
    isBuild ? '/foo/bar/assets/index.js' : '/foo/bar/index.html',
    page.url(),
  )
  expect(await page.textContent('.non-existent-import-meta-url')).toMatch(
    new URL('non-existent', importMetaUrl).pathname,
  )
  expect(serverLogs).not.toContainEqual(
    expect.stringContaining("doesn't exist at build time"),
  )
})

test.runIf(isBuild)('manifest', async () => {
  const manifest = readManifest('foo')
  const entry = manifest['index.html']

  for (const file of listAssets('foo')) {
    if (file.endsWith('.css')) {
      // ignore icons-*.css and css-url-url-*.css as it's imported with ?url
      if (file.includes('icons-') || file.includes('css-url-url-')) continue
      expect(entry.css).toContain(`assets/${file}`)
    } else if (!file.endsWith('.js')) {
      expect(entry.assets).toContain(`assets/${file}`)
    }
  }
})

describe.runIf(isBuild)('css and assets in css in build watch', () => {
  test('css will not be lost and css does not contain undefined', async () => {
    editFile('index.html', (code) => code.replace('Assets', 'assets'))
    await notifyRebuildComplete(watcher)
    const cssFile = findAssetFile(/index-[-\w]+\.css$/, 'foo')
    expect(cssFile).not.toBe('')
    expect(cssFile).not.toMatch(/undefined/)
  })

  test('import module.css', async () => {
    expect(await getColor('#foo')).toBe('red')
    editFile('css/foo.module.css', (code) => code.replace('red', 'blue'))
    await notifyRebuildComplete(watcher)
    await page.reload()
    expect(await getColor('#foo')).toBe('blue')
  })

  test('import with raw query', async () => {
    expect(await page.textContent('.raw-query')).toBe('foo')
    editFile('static/foo.txt', (code) => code.replace('foo', 'zoo'))
    await notifyRebuildComplete(watcher)
    await page.reload()
    expect(await page.textContent('.raw-query')).toBe('zoo')
  })
})

test('inline style test', async () => {
  expect(await getBg('.inline-style')).toMatch(assetMatch)
  expect(await getBg('.style-url-assets')).toMatch(assetMatch)
})

if (!isBuild) {
  test('@import in html style tag hmr', async () => {
    await expect.poll(() => getColor('.import-css')).toBe('rgb(0, 136, 255)')
    const loadPromise = page.waitForEvent('load')
    editFile('./css/import.css', (code) => code.replace('#0088ff', '#00ff88'))
    await loadPromise
    await expect.poll(() => getColor('.import-css')).toBe('rgb(0, 255, 136)')
  })
}

test('html import word boundary', async () => {
  expect(await page.textContent('.obj-import-express')).toMatch(
    'ignore object import prop',
  )
  expect(await page.textContent('.string-import-express')).toMatch('no load')
})

test('relative path in html asset', async () => {
  expect(await page.textContent('.relative-js')).toMatch('hello')
  expect(await getColor('.relative-css')).toMatch('red')
})

test('url() contains file in publicDir, in <style> tag', async () => {
  expect(await getBg('.style-public-assets')).toContain(iconMatch)
})

test('url() contains file in publicDir, as inline style', async () => {
  expect(await getBg('.inline-style-public')).toContain(iconMatch)
})

test('should not rewrite non-relative urls in html', async () => {
  const link = page.locator('.data-href')
  expect(await link.getAttribute('href')).toBe('data:,')
})

test.runIf(isBuild)('assets inside <noscript> is rewrote', async () => {
  const indexHtml = readFile('./dist/foo/index.html')
  expect(indexHtml).toMatch(
    /<img class="noscript" src="\/foo\/bar\/assets\/asset-[-\w]+\.png" \/>/,
  )
})

test.runIf(isBuild)('assets inside <template> is rewrote', async () => {
  const indexHtml = readFile('./dist/foo/index.html')
  expect(indexHtml).toMatch(
    /<img class="template" src="\/foo\/bar\/assets\/asset-[-\w]+\.png" \/>/,
  )
})



================================================
FILE: playground/assets/__tests__/encoded-base/assets-encoded-base.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import {
  browserLogs,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  page,
} from '~utils'

const urlAssetMatch = isBuild
  ? /\/foo%20bar\/other-assets\/asset-[-\w]{8}\.png/
  : '/nested/asset.png'

const iconMatch = '/icon.png'

const absoluteIconMatch = isBuild
  ? /\/foo%20bar\/.*\/icon-[-\w]{8}\.png/
  : '/nested/icon.png'

const absolutePublicIconMatch = isBuild ? /\/foo%20bar\/icon\.png/ : '/icon.png'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe('raw references from /public', () => {
  test('load raw js from /public', async () => {
    expect(await page.textContent('.raw-js')).toMatch('[success]')
  })

  test('load raw css from /public', async () => {
    expect(await getColor('.raw-css')).toBe('red')
  })
})

test('import-expression from simple script', async () => {
  expect(await page.textContent('.import-expression')).toMatch(
    '[success][success]',
  )
})

describe('asset imports from js', () => {
  test('relative', async () => {
    expect(await page.textContent('.asset-import-relative')).toMatch(
      urlAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await page.textContent('.asset-import-absolute')).toMatch(
      urlAssetMatch,
    )
  })

  test('from /public', async () => {
    expect(await page.textContent('.public-import')).toMatch(
      absolutePublicIconMatch,
    )
  })
})

describe('css url() references', () => {
  test('fonts', async () => {
    expect(
      await page.evaluate(() => document.fonts.check('700 32px Inter')),
    ).toBe(true)
  })

  test('relative', async () => {
    const bg = await getBg('.css-url-relative')
    expect(bg).toMatch(urlAssetMatch)
  })

  test('image-set relative', async () => {
    const imageSet = await getBg('.css-image-set-relative')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set without the url() call', async () => {
    const imageSet = await getBg('.css-image-set-without-url-call')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set with var', async () => {
    const imageSet = await getBg('.css-image-set-with-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set with mix', async () => {
    const imageSet = await getBg('.css-image-set-mix-url-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('relative in @import', async () => {
    expect(await getBg('.css-url-relative-at-imported')).toMatch(urlAssetMatch)
  })

  test('absolute', async () => {
    expect(await getBg('.css-url-absolute')).toMatch(urlAssetMatch)
  })

  test('from /public', async () => {
    expect(await getBg('.css-url-public')).toMatch(iconMatch)
  })

  test('multiple urls on the same line', async () => {
    const bg = await getBg('.css-url-same-line')
    expect(bg).toMatch(urlAssetMatch)
    expect(bg).toMatch(iconMatch)
  })

  test('aliased', async () => {
    const bg = await getBg('.css-url-aliased')
    expect(bg).toMatch(urlAssetMatch)
  })
})

describe.runIf(isBuild)('index.css URLs', () => {
  let css: string
  beforeAll(() => {
    css = findAssetFile(/index.*\.css$/, 'encoded-base', 'other-assets')
  })

  test('use base URL for asset URL', () => {
    expect(css).toMatch(urlAssetMatch)
  })

  test('preserve postfix query/hash', () => {
    expect(css).toMatch('woff2?#iefix')
  })
})

describe('image', () => {
  test('srcset', async () => {
    const img = await page.$('.img-src-set')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(
        isBuild
          ? /\/foo%20bar\/other-assets\/asset-[-\w]{8}\.png \dx/
          : /\/foo%20bar\/nested\/asset\.png \dx/,
      )
    })
  })
})

describe('svg fragments', () => {
  // 404 is checked already, so here we just ensure the urls end with #fragment
  test('img url', async () => {
    const img = await page.$('.svg-frag-img')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-clock-view$/)
  })

  test('via css url()', async () => {
    expect(await getBg('.icon')).toMatch(/svg#icon-clock-view"\)$/)
  })

  test('from js import', async () => {
    const img = await page.$('.svg-frag-import')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-heart-view$/)
  })
})

test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
})

test('?url import', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild ? /\/foo%20bar\/other-assets\/foo-[-\w]{8}\.js/ : '/foo.js',
  )
})

test('?url import on css', async () => {
  const txt = await page.textContent('.url-css')
  expect(txt).toMatch(
    isBuild
      ? /\/foo%20bar\/other-assets\/icons-[-\w]{8}\.css/
      : '/css/icons.css',
  )
})

test('new URL(..., import.meta.url)', async () => {
  const urlImgMatch = isBuild
    ? /\/foo%20bar\/other-assets\/img-[-\w]{8}\.png/
    : '/import-meta-url/img.png'
  expect(await page.textContent('.import-meta-url')).toMatch(urlImgMatch)
})

test('new URL(`${dynamic}`, import.meta.url)', async () => {
  const dynamic1 = await page.textContent('.dynamic-import-meta-url-1')
  expect(dynamic1).toMatch(absoluteIconMatch)
  const dynamic2 = await page.textContent('.dynamic-import-meta-url-2')
  expect(dynamic2).toMatch(urlAssetMatch)
})

test('new URL(`non-existent`, import.meta.url)', async () => {
  expect(await page.textContent('.non-existent-import-meta-url')).toMatch(
    '/non-existent',
  )
})

test('inline style test', async () => {
  expect(await getBg('.inline-style')).toMatch(urlAssetMatch)
  expect(await getBg('.style-url-assets')).toMatch(urlAssetMatch)
})

test('html import word boundary', async () => {
  expect(await page.textContent('.obj-import-express')).toMatch(
    'ignore object import prop',
  )
  expect(await page.textContent('.string-import-express')).toMatch('no load')
})

test('relative path in html asset', async () => {
  expect(await page.textContent('.relative-js')).toMatch('hello')
  expect(await getColor('.relative-css')).toMatch('red')
})



================================================
FILE: playground/assets/__tests__/relative-base/assets-relative-base.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import {
  browserLogs,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  page,
} from '~utils'

const absoluteAssetMatch = isBuild
  ? /http.*\/other-assets\/asset-[-\w]{8}\.png/
  : '/nested/asset.png'

// Asset URLs in CSS are relative to the same dir, the computed
// style returns the absolute URL in the test
const cssBgAssetMatch = absoluteAssetMatch

const iconMatch = `/icon.png`

const absoluteIconMatch = isBuild
  ? /http.*\/icon-[-\w]{8}\.png/
  : '/nested/icon.png'

const absolutePublicIconMatch = isBuild ? /http.*\/icon\.png/ : '/icon.png'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe('raw references from /public', () => {
  test('load raw js from /public', async () => {
    expect(await page.textContent('.raw-js')).toMatch('[success]')
  })

  test('load raw css from /public', async () => {
    expect(await getColor('.raw-css')).toBe('red')
  })
})

test('import-expression from simple script', async () => {
  expect(await page.textContent('.import-expression')).toMatch(
    '[success][success]',
  )
})

describe('asset imports from js', () => {
  test('relative', async () => {
    expect(await page.textContent('.asset-import-relative')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await page.textContent('.asset-import-absolute')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('from /public', async () => {
    expect(await page.textContent('.public-import')).toMatch(
      absolutePublicIconMatch,
    )
  })
})

describe('css url() references', () => {
  test('fonts', async () => {
    expect(
      await page.evaluate(() => {
        return (document as any).fonts.check('700 32px Inter')
      }),
    ).toBe(true)
  })

  test('relative', async () => {
    const bg = await getBg('.css-url-relative')
    expect(bg).toMatch(cssBgAssetMatch)
  })

  test('image-set relative', async () => {
    const imageSet = await getBg('.css-image-set-relative')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set without the url() call', async () => {
    const imageSet = await getBg('.css-image-set-without-url-call')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set with var', async () => {
    const imageSet = await getBg('.css-image-set-with-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set with mix', async () => {
    const imageSet = await getBg('.css-image-set-mix-url-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('relative in @import', async () => {
    expect(await getBg('.css-url-relative-at-imported')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await getBg('.css-url-absolute')).toMatch(cssBgAssetMatch)
  })

  test('from /public', async () => {
    expect(await getBg('.css-url-public')).toMatch(iconMatch)
  })

  test('multiple urls on the same line', async () => {
    const bg = await getBg('.css-url-same-line')
    expect(bg).toMatch(cssBgAssetMatch)
    expect(bg).toMatch(iconMatch)
  })

  test('aliased', async () => {
    const bg = await getBg('.css-url-aliased')
    expect(bg).toMatch(cssBgAssetMatch)
  })

  test('nested manual chunks', async () => {
    const bg = await getBg('.css-manual-chunks-relative')
    expect(bg).toMatch(cssBgAssetMatch)
  })
})

describe.runIf(isBuild)('index.css URLs', () => {
  let css: string
  beforeAll(() => {
    css = findAssetFile(/index.*\.css$/, 'relative-base', 'other-assets')
  })

  test('relative asset URL', () => {
    expect(css).toMatch(`./asset-`)
  })

  test('preserve postfix query/hash', () => {
    expect(css).toMatch(`woff2?#iefix`)
  })
})

describe('image', () => {
  test('srcset', async () => {
    const img = await page.$('.img-src-set')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(
        isBuild
          ? /other-assets\/asset-[-\w]{8}\.png \dx/
          : /\.\/nested\/asset\.png \dx/,
      )
    })
  })
})

describe('svg fragments', () => {
  // 404 is checked already, so here we just ensure the urls end with #fragment
  test('img url', async () => {
    const img = await page.$('.svg-frag-img')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-clock-view$/)
  })

  test('via css url()', async () => {
    expect(await getBg('.icon')).toMatch(/svg#icon-clock-view"\)$/)
  })

  test('from js import', async () => {
    const img = await page.$('.svg-frag-import')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-heart-view$/)
  })
})

test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
})

test('?url import', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild ? /http.*\/other-assets\/foo-[-\w]{8}\.js/ : `/foo.js`,
  )
})

test('?url import on css', async () => {
  const txt = await page.textContent('.url-css')
  expect(txt).toMatch(
    isBuild ? /http.*\/other-assets\/icons-[-\w]{8}\.css/ : '/css/icons.css',
  )
  isBuild &&
    expect(findAssetFile(/index.*\.js$/, 'relative-base', 'entries')).toMatch(
      /icons-.+\.css(?!\?used)/,
    )
})

test('new URL(..., import.meta.url)', async () => {
  const absoluteImgMatch = isBuild
    ? /http.*\/other-assets\/img-[-\w]{8}\.png/
    : '/import-meta-url/img.png'
  expect(await page.textContent('.import-meta-url')).toMatch(absoluteImgMatch)
})

test('new URL(`${dynamic}`, import.meta.url)', async () => {
  const dynamic1 = await page.textContent('.dynamic-import-meta-url-1')
  expect(dynamic1).toMatch(absoluteIconMatch)
  const dynamic2 = await page.textContent('.dynamic-import-meta-url-2')
  expect(dynamic2).toMatch(absoluteAssetMatch)
})

test('new URL(`non-existent`, import.meta.url)', async () => {
  expect(await page.textContent('.non-existent-import-meta-url')).toMatch(
    '/non-existent',
  )
})

test('inline style test', async () => {
  expect(await getBg('.inline-style')).toMatch(cssBgAssetMatch)
  expect(await getBg('.style-url-assets')).toMatch(cssBgAssetMatch)
})

test('html import word boundary', async () => {
  expect(await page.textContent('.obj-import-express')).toMatch(
    'ignore object import prop',
  )
  expect(await page.textContent('.string-import-express')).toMatch('no load')
})

test('relative path in html asset', async () => {
  expect(await page.textContent('.relative-js')).toMatch('hello')
  expect(await getColor('.relative-css')).toMatch('red')
})



================================================
FILE: playground/assets/__tests__/runtime-base/assets-runtime-base.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import {
  browserLogs,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  page,
} from '~utils'

const absoluteAssetMatch = isBuild
  ? /\/other-assets\/asset-[-\w]{8}\.png/
  : '/nested/asset.png'

// Asset URLs in CSS are relative to the same dir, the computed
// style returns the absolute URL in the test
const cssBgAssetMatch = absoluteAssetMatch

const iconMatch = `/icon.png`

const absoluteIconMatch = isBuild
  ? /\/other-assets\/icon-[-\w]{8}\.png/
  : '/nested/icon.png'

const absolutePublicIconMatch = isBuild ? /\/icon\.png/ : '/icon.png'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe('raw references from /public', () => {
  test('load raw js from /public', async () => {
    expect(await page.textContent('.raw-js')).toMatch('[success]')
  })

  test('load raw css from /public', async () => {
    expect(await getColor('.raw-css')).toBe('red')
  })
})

test('import-expression from simple script', async () => {
  expect(await page.textContent('.import-expression')).toMatch(
    '[success][success]',
  )
})

describe('asset imports from js', () => {
  test('relative', async () => {
    expect(await page.textContent('.asset-import-relative')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await page.textContent('.asset-import-absolute')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('from /public', async () => {
    expect(await page.textContent('.public-import')).toMatch(
      absolutePublicIconMatch,
    )
  })
})

describe('css url() references', () => {
  test('fonts', async () => {
    expect(
      await page.evaluate(() => {
        return (document as any).fonts.check('700 32px Inter')
      }),
    ).toBe(true)
  })

  test('relative', async () => {
    const bg = await getBg('.css-url-relative')
    expect(bg).toMatch(cssBgAssetMatch)
  })

  test('image-set relative', async () => {
    const imageSet = await getBg('.css-image-set-relative')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set without the url() call', async () => {
    const imageSet = await getBg('.css-image-set-without-url-call')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set with var', async () => {
    const imageSet = await getBg('.css-image-set-with-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('image-set with mix', async () => {
    const imageSet = await getBg('.css-image-set-mix-url-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(cssBgAssetMatch)
    })
  })

  test('relative in @import', async () => {
    expect(await getBg('.css-url-relative-at-imported')).toMatch(
      cssBgAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await getBg('.css-url-absolute')).toMatch(cssBgAssetMatch)
  })

  test('from /public', async () => {
    expect(await getBg('.css-url-public')).toMatch(iconMatch)
  })

  test('multiple urls on the same line', async () => {
    const bg = await getBg('.css-url-same-line')
    expect(bg).toMatch(cssBgAssetMatch)
    expect(bg).toMatch(iconMatch)
  })

  test('aliased', async () => {
    const bg = await getBg('.css-url-aliased')
    expect(bg).toMatch(cssBgAssetMatch)
  })
})

describe.runIf(isBuild)('index.css URLs', () => {
  let css: string
  beforeAll(() => {
    css = findAssetFile(/index-[-\w]{8}\.css$/, 'runtime-base', 'other-assets')
  })

  test('relative asset URL', () => {
    expect(css).toMatch(`./asset-`)
  })

  test('preserve postfix query/hash', () => {
    expect(css).toMatch(`woff2?#iefix`)
  })
})

describe('image', () => {
  test('srcset', async () => {
    const img = await page.$('.img-src-set')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(
        isBuild
          ? /other-assets\/asset-[-\w]{8}\.png \dx/
          : /\.\/nested\/asset\.png \dx/,
      )
    })
  })
})

describe('svg fragments', () => {
  // 404 is checked already, so here we just ensure the urls end with #fragment
  test('img url', async () => {
    const img = await page.$('.svg-frag-img')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-clock-view$/)
  })

  test('via css url()', async () => {
    expect(await getBg('.icon')).toMatch(/svg#icon-clock-view"\)$/)
  })

  test('from js import', async () => {
    const img = await page.$('.svg-frag-import')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-heart-view$/)
  })
})

test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
})

test('?url import', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild ? /\/other-assets\/foo-[-\w]{8}\.js/ : `/foo.js`,
  )
})

test('?url import on css', async () => {
  const txt = await page.textContent('.url-css')
  expect(txt).toMatch(
    isBuild ? /\/other-assets\/icons-[-\w]{8}\.css/ : '/css/icons.css',
  )
})

test('new URL(..., import.meta.url)', async () => {
  const absoluteImgMatch = isBuild
    ? /http.*\/other-assets\/img-[-\w]{8}\.png/
    : '/import-meta-url/img.png'
  expect(await page.textContent('.import-meta-url')).toMatch(absoluteImgMatch)
})

test('new URL(`${dynamic}`, import.meta.url)', async () => {
  const dynamic1 = await page.textContent('.dynamic-import-meta-url-1')
  expect(dynamic1).toMatch(absoluteIconMatch)
  const dynamic2 = await page.textContent('.dynamic-import-meta-url-2')
  expect(dynamic2).toMatch(absoluteAssetMatch)
})

test('new URL(`non-existent`, import.meta.url)', async () => {
  expect(await page.textContent('.non-existent-import-meta-url')).toMatch(
    '/non-existent',
  )
})

test('inline style test', async () => {
  expect(await getBg('.inline-style')).toMatch(cssBgAssetMatch)
  expect(await getBg('.style-url-assets')).toMatch(cssBgAssetMatch)
})

test('html import word boundary', async () => {
  expect(await page.textContent('.obj-import-express')).toMatch(
    'ignore object import prop',
  )
  expect(await page.textContent('.string-import-express')).toMatch('no load')
})

test('relative path in html asset', async () => {
  expect(await page.textContent('.relative-js')).toMatch('hello')
  expect(await getColor('.relative-css')).toMatch('red')
})



================================================
FILE: playground/assets/__tests__/url-base/assets-url-base.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import {
  browserLogs,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  page,
} from '~utils'

const urlAssetMatch = isBuild
  ? /http:\/\/localhost:\d+\/other-assets\/asset-[-\w]{8}\.png/
  : '/nested/asset.png'

const iconMatch = '/icon.png'

const absoluteIconMatch = isBuild
  ? /http:\/\/localhost:\d+\/.*\/icon-[-\w]{8}\.png/
  : '/nested/icon.png'

const absolutePublicIconMatch = isBuild
  ? /http:\/\/localhost:\d+\/icon\.png/
  : '/icon.png'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe('raw references from /public', () => {
  test('load raw js from /public', async () => {
    expect(await page.textContent('.raw-js')).toMatch('[success]')
  })

  test('load raw css from /public', async () => {
    expect(await getColor('.raw-css')).toBe('red')
  })
})

test('import-expression from simple script', async () => {
  expect(await page.textContent('.import-expression')).toMatch(
    '[success][success]',
  )
})

describe('asset imports from js', () => {
  test('relative', async () => {
    expect(await page.textContent('.asset-import-relative')).toMatch(
      urlAssetMatch,
    )
  })

  test('absolute', async () => {
    expect(await page.textContent('.asset-import-absolute')).toMatch(
      urlAssetMatch,
    )
  })

  test('from /public', async () => {
    expect(await page.textContent('.public-import')).toMatch(
      absolutePublicIconMatch,
    )
  })
})

describe('css url() references', () => {
  test('fonts', async () => {
    expect(
      await page.evaluate(() => document.fonts.check('700 32px Inter')),
    ).toBe(true)
  })

  test('relative', async () => {
    const bg = await getBg('.css-url-relative')
    expect(bg).toMatch(urlAssetMatch)
  })

  test('image-set relative', async () => {
    const imageSet = await getBg('.css-image-set-relative')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set without the url() call', async () => {
    const imageSet = await getBg('.css-image-set-without-url-call')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set with var', async () => {
    const imageSet = await getBg('.css-image-set-with-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('image-set with mix', async () => {
    const imageSet = await getBg('.css-image-set-mix-url-var')
    imageSet.split(', ').forEach((s) => {
      expect(s).toMatch(urlAssetMatch)
    })
  })

  test('relative in @import', async () => {
    expect(await getBg('.css-url-relative-at-imported')).toMatch(urlAssetMatch)
  })

  test('absolute', async () => {
    expect(await getBg('.css-url-absolute')).toMatch(urlAssetMatch)
  })

  test('from /public', async () => {
    expect(await getBg('.css-url-public')).toMatch(iconMatch)
  })

  test('multiple urls on the same line', async () => {
    const bg = await getBg('.css-url-same-line')
    expect(bg).toMatch(urlAssetMatch)
    expect(bg).toMatch(iconMatch)
  })

  test('aliased', async () => {
    const bg = await getBg('.css-url-aliased')
    expect(bg).toMatch(urlAssetMatch)
  })
})

describe.runIf(isBuild)('index.css URLs', () => {
  let css: string
  beforeAll(() => {
    css = findAssetFile(/index.*\.css$/, 'url-base', 'other-assets')
  })

  test('use base URL for asset URL', () => {
    expect(css).toMatch(urlAssetMatch)
  })

  test('preserve postfix query/hash', () => {
    expect(css).toMatch('woff2?#iefix')
  })
})

describe('image', () => {
  test('srcset', async () => {
    const img = await page.$('.img-src-set')
    const srcset = await img.getAttribute('srcset')
    srcset.split(', ').forEach((s) => {
      expect(s).toMatch(
        isBuild
          ? /other-assets\/asset-[-\w]{8}\.png \dx/
          : /\.\/nested\/asset\.png \dx/,
      )
    })
  })
})

describe('svg fragments', () => {
  // 404 is checked already, so here we just ensure the urls end with #fragment
  test('img url', async () => {
    const img = await page.$('.svg-frag-img')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-clock-view$/)
  })

  test('via css url()', async () => {
    expect(await getBg('.icon')).toMatch(/svg#icon-clock-view"\)$/)
  })

  test('from js import', async () => {
    const img = await page.$('.svg-frag-import')
    expect(await img.getAttribute('src')).toMatch(/svg#icon-heart-view$/)
  })
})

test('?raw import', async () => {
  expect(await page.textContent('.raw')).toMatch('SVG')
})

test('?url import', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild
      ? /http:\/\/localhost:\d+\/other-assets\/foo-[-\w]{8}\.js/
      : '/foo.js',
  )
})

test('?url import on css', async () => {
  const txt = await page.textContent('.url-css')
  expect(txt).toMatch(
    isBuild
      ? /http:\/\/localhost:\d+\/other-assets\/icons-[-\w]{8}\.css/
      : '/css/icons.css',
  )
})

test('new URL(..., import.meta.url)', async () => {
  const urlImgMatch = isBuild
    ? /http:\/\/localhost:\d+\/other-assets\/img-[-\w]{8}\.png/
    : '/import-meta-url/img.png'
  expect(await page.textContent('.import-meta-url')).toMatch(urlImgMatch)
})

test('new URL(`${dynamic}`, import.meta.url)', async () => {
  const dynamic1 = await page.textContent('.dynamic-import-meta-url-1')
  expect(dynamic1).toMatch(absoluteIconMatch)
  const dynamic2 = await page.textContent('.dynamic-import-meta-url-2')
  expect(dynamic2).toMatch(urlAssetMatch)
})

test('new URL(`non-existent`, import.meta.url)', async () => {
  expect(await page.textContent('.non-existent-import-meta-url')).toMatch(
    '/non-existent',
  )
})

test('inline style test', async () => {
  expect(await getBg('.inline-style')).toMatch(urlAssetMatch)
  expect(await getBg('.style-url-assets')).toMatch(urlAssetMatch)
})

test('html import word boundary', async () => {
  expect(await page.textContent('.obj-import-express')).toMatch(
    'ignore object import prop',
  )
  expect(await page.textContent('.string-import-express')).toMatch('no load')
})

test('relative path in html asset', async () => {
  expect(await page.textContent('.relative-js')).toMatch('hello')
  expect(await getColor('.relative-css')).toMatch('red')
})



================================================
FILE: playground/assets/asset/main.js
================================================
function text(el, text) {
  document.querySelector(el).textContent = text
}
text('.relative-js', 'hello')



================================================
FILE: playground/assets/asset/style.css
================================================
.relative-css {
  color: red;
}



================================================
FILE: playground/assets/css/css-url-url.css
================================================
.css-url-svg-in-url {
  background: url(../nested/fragment-bg-hmr2.svg);
  background-size: 10px;
}



================================================
FILE: playground/assets/css/css-url.css
================================================
@import './nested/at-imported-css-url.css';

.css-url-absolute {
  background: url(/nested/asset.png);
  background-size: 10px;
}

.css-url-relative {
  background: url(../nested/asset.png);
  background-size: 10px;
}

.css-url-encoded {
  background: url('/nested/asset%5Bsmall%5D.png');
  background-size: 10px;
}

.css-image-set-relative {
  background-image: -webkit-image-set(
    url('../nested/asset.png') 1x,
    url('../nested/asset.png') 2x
  );
  background-size: 10px;
}

.css-image-set-without-url-call {
  background-image: -webkit-image-set(
    '../nested/asset.png' 1x,
    '../nested/asset.png' 2x
  );
  background-size: 10px;
}

.css-image-set-with-var {
  --bg-img: url('../nested/asset.png');
  background-image: -webkit-image-set(var(--bg-img) 1x, var(--bg-img) 2x);
  background-size: 10px;
}

.css-image-set-mix-url-var {
  --bg-img: url('../nested/asset.png');
  background-image: -webkit-image-set(
    var(--bg-img) 1x,
    url('../nested/asset.png') 2x
  );
  background-size: 10px;
}

.css-image-set-base64 {
  background-image: -webkit-image-set(
    url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0AgMAAACrwbOMAAADI2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1MDI2QjVGQTg3RUIxMUVBQUFDMkQ3NTM0MUZGNzU3RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MDI2QjVGOTg3RUIxMUVBQUFDMkQ3NTM0MUZGNzU3RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBNzc3MDZDRjg3QUIxMUUzQjcwREVFMDM3NzA2QzEyMyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBNzc3MDZEMDg3QUIxMUUzQjcwREVFMDM3NzA2QzEyMyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqfCcbEAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAADFBMVEVBuoQ0R10/qn8/qX7FyuqbAAAABHRSTlP9/QGEiU0+GwAAAPtJREFUGBkFwbFNXEEUBdDD/QSWmE7YYAogWNeAaMfaEuiD5HfAk9yIAwqYwIGRRvt8zkNdvckrzzcfjqDccdPIYnH1AJ4ywLs7m53Fhkcw0+DLDxZn0PCHQrrg2xWOCpS7m6bFAj/ZDLFY/AJbDDZ/WUzR4B84BRoURBeAo4Si0CBMFvBEGMBmExYbi0loACcBjQKhC3AUQVGaRjBhMxAsFlwQDLYFBA04EaAVEHSBoxAoPmkITBYDAovNhsAAEwINTggAINCFoyCg0CBgYoCAjQsIACCgcYKABhCgHAUClAYCTAMIsF2AAAACtBMIQAEB+jcggE9AAC+A/zyyZDSXstCbAAAAAElFTkSuQmCC)
      1x,
    url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0CAYAAADWr1sfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTAyNkI1RkE4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTAyNkI1Rjk4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTc3NzA2Q0Y4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTc3NzA2RDA4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6nwnGxAAAJtklEQVR42txZ6W9c1RU/970373nsJHgZ27FThahSV8BCqGQTlIQ2EiUBReqHVpT8Af0r+NA/ogpqqWiDKrZuKYQPLGEpAlEFiqOgICSUBOKQhDjxeGY885bb37n3TGKPZ+4bx0uWK53Ec+cu53fPfkbtfu13B4noF6AQVAEpah0ak3cUSBU8qh46RfWj50ltKJDXXyBKdMtibI+TXlLqm2C87y/+eO/vlVIVnWbUcShFyld8T19ypvLbZKpyALOjVPCqrUcT1mWXYtIzMUV7Rqn315tJJyk+J51OZwb7QA3QkQD/fAL6JWiIXKMOhkOPwp1DFE/OkJ6NAQxn+fhuPhaFOc8DE9loern+hD9SfJVCdaLdOy5gif9rpHfyHp3pCX5cs6X1PfnORkr+SA9FO4bsgkZm1ykngm8ZK06ll0EvgWY6SwDn1fGKcykVfriewh2D5oKskhhw5KmFzLO0MJdO1yfS87UD2Uxc0tXErM+qLYQ5XUspK8el9JvagXSmPmH2W4lfG3wHNMHciXnmIfj+OvCVga8sD+yMYHyZAZ8H/Qk06dySaiNljf/DB0vklWAB1RQqnS0WA18eQE0Dz0++rjyRluOJDHuzWkwZNAPgLPHfPIeHTK/EEzHWKt/zDdh2asBmUUnJg3TDB0rQIuYptby5x6RgPO/JxIes304p44V1DMAzKQUbe4xqa62h2vbFyWuxeUie1RKqvVmXG/sxOaYKPqliQKp3HmEOB43pWaxJaTPvUV6rdK3Z6FloGUt35yD54EGXEwvaU3nSPSIYF7D5T/mio1rzS7Jaa1we4YWDzb1GUpptqJ1OGUl7BJX+jS7HP/OKEPlgRH5/SP5AZMjrCTz+jtdQQckxauEZ/IZ4bKyhYEsv7h6GpmGuhnsznafORwQbtQKGY6F/gy64pMxPnF2JSQ33UM/ecWNX/PJG3RbYsn15qCiYTQdhr49j9m4jQd8zXlkFZv3d/B087SBM4OodC+5kJYIX5r09+8ZIDYYAn4gqOdFeEEwn2gFmMb0BesEpZeOxARAOJ4SXjLbDlljKcbaQ0ebwrRNLy409oH1Xz1H2xrRc3wfaYx1dm/sgQTyYMZ1wZ4nC+4es76gnC3lqP14QTFk7wDymQH8DnXKCZibKiQHY89gY+aUeGwcT66xaw40JMUnWn52t7NWVeKt5GNaUarw1naruxXn9Rrrz9jRjLsd5PtsfZY3aaBZo9tT5qnxKsExRizto59EOccRzJQomHAC0DzsOHxwy3lvXk8VxU1u1VJFPaSW5B177SRtfNaVnq08izNyjQl9UefFe4zNwdoTI4I8XTfznu3NUORYMiyKP10HvD4neZy7VzqBaHEOjnw5TsKnXfgaDRjKqxWuzzRKtTy/Wt2W1ZAukuyX9tr4Ns+vZpheAVfKoOCuDKrNzDB8Ysp9Znd2qnAnvh9r5I8+hDs86HRhfCIlyQqGgbuHDI0Sz9gHaZj0sQXhhpJhbktOVp5Kvak/x31Sg9rarRXVxXvjwKJxk0Z7N/sOjPEf1bCez7LS1Ji/0iduBAUAD6JDpRFsHqfDjDZRdTqyU26gn2ykkXUovzf2KCV66ZGxXL9YeVtsMMb9w1x0U/WTAADWqnGO4wvMhwdA14PmqfbLjClZdTkaqCFPrAor2byIvUsZrd5Syp4BaFYW8RUmDeG8+wwsVRY+Pk7c+MJpkChXfCfhkJ1XuBjCPV0Bvt0nhFwoPiQfbVjixgaKHho3qGSlbgIu9ti/VEdHifJkdVc2aRoizwnv7kT+nNuy5hxZeX3EtygM8DfoX6FPnCcxL1Yap6NGNCCFFk5x0ETra2i7v9TcWqbh3zIbASmzvcHP7qfA6vRzAJIH7JWeYktRPz2a2bHuoZKpEdjgWdBeoWboMTpwea4o3GiF1lXzZPWLh8Y3ca7oAPAd6E/RubjLCkgBz4fYhCu6cl2d73UmX13KSUcDecNugqX2Np9a5mvKu8Di3EoB5HAP9WboGnZMRFiiXb0MhhYjNOrbeVsc5DPPexEqXz+C9HufLHHPT3PyxIbwd6wZIt4DnxCG81lG1JT9miZiaGeVj8L0+m3I2UrdaezY/z65Auj9ab0vPNLOlp+fEGwtPb3cj3aUA5nEWdDA3GTGMpqT6AupFmLLpYWaL9Hag2XZZdVHqcR1cfGzchDhdyWwFpnKTjIPCG600YFad96S+rHeOzZ5tB7Et3jeItLNk8+Fa2j6jYnU2YSyhaNcwFe4dMHv5DD7L1WUTXt5zmtoyADe7Bwfn15cdHZix3cxIzB+ObC+q2Z1Q6pq0E6gynF0A715ErasbqQWbH9JOCC8zSwGwVMA8Phb3X3a2g5BnZ5cRT78Dj7trxMRR7liY+lhdu5ntVnFDFLm4N1a0nr2e5rVtysLDx0tl/noAc9X7TLNH5KxZuC1Tg6puH0SYKtoaumFrYWPbsS0xg+/2UbjVVkNXW67u8aHwkKwFYB6fgQ47nYXXBBSbEBPtGjUtnWy6YcEm/F1q5sLdkO5AQTonuap8Vu7+7HoYv17APF4Fve6KrabEkzhcuH+AAuTFGmmjkeScbdsU7hswxGtMkqJzM7PX5W5aa8BfSDdwyt30I9Nw44qn+MgYef1IKC42SLN9D4TU8+iYCWGmKSfdEceYkju/uBGAebwvDW53KcOeFxlYcBeqqd3DBiznyCHCUPCDdUTsweM0765M7np/OQwvF/A5aYOedDcKmo23zP5qsalovTfny9wL4xQyP18+KXedu5GAmx0G9pizrsrAJCOQsuovUPTIKIU/HzG/SPKczks97dnPODswXY5gBQDXxK72g3a0fURT5yoTY7nw5w6ksVcAzZq/C7mbcv+TO2rLZXYlJMzjtNjXBedN7IlBXuibtq3ph8W5vw1dkLNPrwSjKwWY89oXQf9xNgqaXruaWLulXK8cy5kvOvP3GwC4mWc/50wImj+xaLrmpFRugvPcUvPltQJMUr0cXcHzjpLrF82bAHBN1O+dFTjrHTmrdjMD5vER6B/LZLQmZ3y00sytBuC65LtvLeOMt+SM+q0AmMekNNbK17G3LHsnV4Ox1QLM4wNRy3gJe2LZ88FqMbWagL8CPe2sptpXQ0/L3lsOMGcW3Cv+O+hyF+svy9pjsveWA9z0tn8Afd7F2s9lbW01GVptwJxTHZfE3/Uj17SsOU7ddLRuYsDN8decDOyorFn1sVaAvyT7k8iZNt+dke++vJ0A8+CfMw+3mT8s39HtBviSgDs+b+64zF26HQHz+C/o+Xmfn5c5ul0BXyT7w/U5oTdlbs1GQGs/vgb9cd7fazr+L8AAD0zRYMSYHQAAAAAASUVORK5CYII=)
      2x
  );
  background-size: 10px;
}

.css-image-set-gradient {
  background-image: -webkit-image-set(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0AgMAAACrwbOMAAADI2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1MDI2QjVGQTg3RUIxMUVBQUFDMkQ3NTM0MUZGNzU3RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MDI2QjVGOTg3RUIxMUVBQUFDMkQ3NTM0MUZGNzU3RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBNzc3MDZDRjg3QUIxMUUzQjcwREVFMDM3NzA2QzEyMyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBNzc3MDZEMDg3QUIxMUUzQjcwREVFMDM3NzA2QzEyMyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqfCcbEAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAADFBMVEVBuoQ0R10/qn8/qX7FyuqbAAAABHRSTlP9/QGEiU0+GwAAAPtJREFUGBkFwbFNXEEUBdDD/QSWmE7YYAogWNeAaMfaEuiD5HfAk9yIAwqYwIGRRvt8zkNdvckrzzcfjqDccdPIYnH1AJ4ywLs7m53Fhkcw0+DLDxZn0PCHQrrg2xWOCpS7m6bFAj/ZDLFY/AJbDDZ/WUzR4B84BRoURBeAo4Si0CBMFvBEGMBmExYbi0loACcBjQKhC3AUQVGaRjBhMxAsFlwQDLYFBA04EaAVEHSBoxAoPmkITBYDAovNhsAAEwINTggAINCFoyCg0CBgYoCAjQsIACCgcYKABhCgHAUClAYCTAMIsF2AAAACtBMIQAEB+jcggE9AAC+A/zyyZDSXstCbAAAAAElFTkSuQmCC'
      1x,
    linear-gradient(#e66465, #9198e5) 2x
  );
  background-size: 10px;
}

.css-image-set-multiple-descriptor {
  background-image: -webkit-image-set(
    '../nested/asset.png' type('image/png') 1x,
    '../nested/asset.png' type('image/png') 2x
  );
  background-size: 10px;
}

.css-url-public {
  background: url('/icon.png');
  background-size: 10px;
}

.css-url-data-uri {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0CAYAAADWr1sfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTAyNkI1RkE4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTAyNkI1Rjk4N0VCMTFFQUFBQzJENzUzNDFGRjc1N0UiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTc3NzA2Q0Y4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTc3NzA2RDA4N0FCMTFFM0I3MERFRTAzNzcwNkMxMjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6nwnGxAAAJtklEQVR42txZ6W9c1RU/970373nsJHgZ27FThahSV8BCqGQTlIQ2EiUBReqHVpT8Af0r+NA/ogpqqWiDKrZuKYQPLGEpAlEFiqOgICSUBOKQhDjxeGY885bb37n3TGKPZ+4bx0uWK53Ec+cu53fPfkbtfu13B4noF6AQVAEpah0ak3cUSBU8qh46RfWj50ltKJDXXyBKdMtibI+TXlLqm2C87y/+eO/vlVIVnWbUcShFyld8T19ypvLbZKpyALOjVPCqrUcT1mWXYtIzMUV7Rqn315tJJyk+J51OZwb7QA3QkQD/fAL6JWiIXKMOhkOPwp1DFE/OkJ6NAQxn+fhuPhaFOc8DE9loern+hD9SfJVCdaLdOy5gif9rpHfyHp3pCX5cs6X1PfnORkr+SA9FO4bsgkZm1ykngm8ZK06ll0EvgWY6SwDn1fGKcykVfriewh2D5oKskhhw5KmFzLO0MJdO1yfS87UD2Uxc0tXErM+qLYQ5XUspK8el9JvagXSmPmH2W4lfG3wHNMHciXnmIfj+OvCVga8sD+yMYHyZAZ8H/Qk06dySaiNljf/DB0vklWAB1RQqnS0WA18eQE0Dz0++rjyRluOJDHuzWkwZNAPgLPHfPIeHTK/EEzHWKt/zDdh2asBmUUnJg3TDB0rQIuYptby5x6RgPO/JxIes304p44V1DMAzKQUbe4xqa62h2vbFyWuxeUie1RKqvVmXG/sxOaYKPqliQKp3HmEOB43pWaxJaTPvUV6rdK3Z6FloGUt35yD54EGXEwvaU3nSPSIYF7D5T/mio1rzS7Jaa1we4YWDzb1GUpptqJ1OGUl7BJX+jS7HP/OKEPlgRH5/SP5AZMjrCTz+jtdQQckxauEZ/IZ4bKyhYEsv7h6GpmGuhnsznafORwQbtQKGY6F/gy64pMxPnF2JSQ33UM/ecWNX/PJG3RbYsn15qCiYTQdhr49j9m4jQd8zXlkFZv3d/B087SBM4OodC+5kJYIX5r09+8ZIDYYAn4gqOdFeEEwn2gFmMb0BesEpZeOxARAOJ4SXjLbDlljKcbaQ0ebwrRNLy409oH1Xz1H2xrRc3wfaYx1dm/sgQTyYMZ1wZ4nC+4es76gnC3lqP14QTFk7wDymQH8DnXKCZibKiQHY89gY+aUeGwcT66xaw40JMUnWn52t7NWVeKt5GNaUarw1naruxXn9Rrrz9jRjLsd5PtsfZY3aaBZo9tT5qnxKsExRizto59EOccRzJQomHAC0DzsOHxwy3lvXk8VxU1u1VJFPaSW5B177SRtfNaVnq08izNyjQl9UefFe4zNwdoTI4I8XTfznu3NUORYMiyKP10HvD4neZy7VzqBaHEOjnw5TsKnXfgaDRjKqxWuzzRKtTy/Wt2W1ZAukuyX9tr4Ns+vZpheAVfKoOCuDKrNzDB8Ysp9Znd2qnAnvh9r5I8+hDs86HRhfCIlyQqGgbuHDI0Sz9gHaZj0sQXhhpJhbktOVp5Kvak/x31Sg9rarRXVxXvjwKJxk0Z7N/sOjPEf1bCez7LS1Ji/0iduBAUAD6JDpRFsHqfDjDZRdTqyU26gn2ykkXUovzf2KCV66ZGxXL9YeVtsMMb9w1x0U/WTAADWqnGO4wvMhwdA14PmqfbLjClZdTkaqCFPrAor2byIvUsZrd5Syp4BaFYW8RUmDeG8+wwsVRY+Pk7c+MJpkChXfCfhkJ1XuBjCPV0Bvt0nhFwoPiQfbVjixgaKHho3qGSlbgIu9ti/VEdHifJkdVc2aRoizwnv7kT+nNuy5hxZeX3EtygM8DfoX6FPnCcxL1Yap6NGNCCFFk5x0ETra2i7v9TcWqbh3zIbASmzvcHP7qfA6vRzAJIH7JWeYktRPz2a2bHuoZKpEdjgWdBeoWboMTpwea4o3GiF1lXzZPWLh8Y3ca7oAPAd6E/RubjLCkgBz4fYhCu6cl2d73UmX13KSUcDecNugqX2Np9a5mvKu8Di3EoB5HAP9WboGnZMRFiiXb0MhhYjNOrbeVsc5DPPexEqXz+C9HufLHHPT3PyxIbwd6wZIt4DnxCG81lG1JT9miZiaGeVj8L0+m3I2UrdaezY/z65Auj9ab0vPNLOlp+fEGwtPb3cj3aUA5nEWdDA3GTGMpqT6AupFmLLpYWaL9Hag2XZZdVHqcR1cfGzchDhdyWwFpnKTjIPCG600YFad96S+rHeOzZ5tB7Et3jeItLNk8+Fa2j6jYnU2YSyhaNcwFe4dMHv5DD7L1WUTXt5zmtoyADe7Bwfn15cdHZix3cxIzB+ObC+q2Z1Q6pq0E6gynF0A715ErasbqQWbH9JOCC8zSwGwVMA8Phb3X3a2g5BnZ5cRT78Dj7trxMRR7liY+lhdu5ntVnFDFLm4N1a0nr2e5rVtysLDx0tl/noAc9X7TLNH5KxZuC1Tg6puH0SYKtoaumFrYWPbsS0xg+/2UbjVVkNXW67u8aHwkKwFYB6fgQ47nYXXBBSbEBPtGjUtnWy6YcEm/F1q5sLdkO5AQTonuap8Vu7+7HoYv17APF4Fve6KrabEkzhcuH+AAuTFGmmjkeScbdsU7hswxGtMkqJzM7PX5W5aa8BfSDdwyt30I9Nw44qn+MgYef1IKC42SLN9D4TU8+iYCWGmKSfdEceYkju/uBGAebwvDW53KcOeFxlYcBeqqd3DBiznyCHCUPCDdUTsweM0765M7np/OQwvF/A5aYOedDcKmo23zP5qsalovTfny9wL4xQyP18+KXedu5GAmx0G9pizrsrAJCOQsuovUPTIKIU/HzG/SPKczks97dnPODswXY5gBQDXxK72g3a0fURT5yoTY7nw5w6ksVcAzZq/C7mbcv+TO2rLZXYlJMzjtNjXBedN7IlBXuibtq3ph8W5vw1dkLNPrwSjKwWY89oXQf9xNgqaXruaWLulXK8cy5kvOvP3GwC4mWc/50wImj+xaLrmpFRugvPcUvPltQJMUr0cXcHzjpLrF82bAHBN1O+dFTjrHTmrdjMD5vER6B/LZLQmZ3y00sytBuC65LtvLeOMt+SM+q0AmMekNNbK17G3LHsnV4Ox1QLM4wNRy3gJe2LZ88FqMbWagL8CPe2sptpXQ0/L3lsOMGcW3Cv+O+hyF+svy9pjsveWA9z0tn8Afd7F2s9lbW01GVptwJxTHZfE3/Uj17SsOU7ddLRuYsDN8decDOyorFn1sVaAvyT7k8iZNt+dke++vJ0A8+CfMw+3mT8s39HtBviSgDs+b+64zF26HQHz+C/o+Xmfn5c5ul0BXyT7w/U5oTdlbs1GQGs/vgb9cd7fazr+L8AAD0zRYMSYHQAAAAAASUVORK5CYII=);
  background-size: 10px;
}

.css-url-base64-inline {
  background: url(../nested/icon.png);
  background-size: 10px;
}

.css-url-quotes-base64-inline {
  background: url('../nested/icon.png');
  background-size: 10px;
}

.css-url-same-line {
  background:
    url('/nested/asset.png') top right / 10px no-repeat,
    url('/icon.png') bottom right / 10px no-repeat;
}

.css-url-aliased {
  background: url('@/asset.png');
  background-size: 10px;
}

.css-url-preinlined-svg {
  background: url('data:image/svg+xml,<svg fill="black" width="48" height="48" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30.74,15.95c-.01-.1-.04-.2-.09-.28,0-.01,0-.03-.01-.05l-5.57-8.6c-.19-.29-.56-.42-.89-.3C8.21,12.62,3.37,14.48,1.9,15.3c-.27,.04-.5,.21-.59,.46-.05,.09-.05,.17-.05,.26v8.38c0,.41,.34,.75,.75,.75H30c.41,0,.75-.34,.75-.75v-8.38s0-.01,0-.02c0-.02,0-.04-.01-.06Zm-6.61-7.62l4.49,6.94H5.7c4.42-1.73,12.41-4.72,18.43-6.94Zm5.12,15.32H2.75v-6.88H29.25v6.88Z"/><path d="M6.16,21.34c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M15.15,23.04c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M24.28,20.73c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M22.78,10.16c-.99,0-1.79,.8-1.79,1.79s.8,1.79,1.79,1.79,1.79-.8,1.79-1.79-.8-1.79-1.79-1.79Zm0,2.08c-.16,0-.29-.13-.29-.29s.13-.29,.29-.29,.29,.13,.29,.29-.13,.29-.29,.29Z"/></svg>');
  background-size: 20px;
}

/*
urls inside comments should be ignored

.css-url-relative {
  background: url(../nested/non-existent.png);
  background-size: 10px;
}
*/

.css-url-svg {
  background: url(../nested/fragment-bg-hmr.svg);
  background-size: 10px;
}

.css-image-set-svg {
  background: -webkit-image-set(
    url('../nested/fragment-bg.svg') 1x,
    url('../nested/fragment-bg.svg') 2x
  );
  background-size: 10px;
}

.css-url-non-inline-hmr {
  background: url(../nested/donuts-large.svg);
  background-size: 20px;
}



================================================
FILE: playground/assets/css/fonts.css
================================================
@font-face {
  font-family: 'Inter';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src:
    url('../fonts/Inter-Italic.woff2?#iefix') format('woff2'),
    url('/fonts/Inter-Italic.woff') format('woff');
}

body {
  font-family: 'Inter';
}



================================================
FILE: playground/assets/css/foo.module.css
================================================
.foo-module {
  color: red;
}



================================================
FILE: playground/assets/css/icons.css
================================================
img {
  width: 32px;
  height: 32px;
}

.icon {
  display: inline-block;
  width: 32px;
  height: 32px;
}

.icon-clock {
  background: url(../nested/fragment-bg.svg#icon-clock-view) no-repeat;
}

.icon-heart {
  background: url(../nested/fragment-bg.svg#icon-heart-view) no-repeat;
}

.icon-arrow-right {
  background: url(../nested/fragment-bg.svg#icon-arrow-right-view) no-repeat;
}

.icon-clock-alias {
  background: url('fragment#icon-clock-view') no-repeat;
}



================================================
FILE: playground/assets/css/import.css
================================================
.import-css {
  color: #0088ff;
}



================================================
FILE: playground/assets/css/manual-chunks.css
================================================
.css-manual-chunks-relative {
  background: url(../nested/asset.png);
  background-size: 10px;
}



================================================
FILE: playground/assets/css/nested/at-imported-css-url.css
================================================
.css-url-relative-at-imported {
  background: url(../../nested/asset.png);
  background-size: 10px;
}



================================================
FILE: playground/assets/nested/foo.unknown
================================================
custom file



================================================
FILE: playground/assets/nested/partial.html
================================================
<div>partial</div>



================================================
FILE: playground/assets/nested/test.js
================================================
export default class a {
  name = 'a'
}



================================================
FILE: playground/assets/static/bar
================================================
bar



================================================
FILE: playground/assets/static/foo.css
================================================
.foo-public {
  color: red;
}



================================================
FILE: playground/assets/static/foo.json
================================================
{
  "foo": "bar"
}



================================================
FILE: playground/assets/static/foo.txt
================================================
foo


================================================
FILE: playground/assets/static/import-expression.js
================================================
document.querySelector('.import-expression').textContent += '[success]'



================================================
FILE: playground/assets/static/raw.css
================================================
.raw-css {
  color: red;
}



================================================
FILE: playground/assets/static/raw.js
================================================
document.querySelector('.raw-js').textContent =
  '[success] Raw js from /public loaded'



================================================
FILE: playground/assets/static/raw.mts
================================================
export default function foobar() {
  return 1 + 2
}



================================================
FILE: playground/assets/static/raw.ts
================================================
export default function other() {
  return 1 + 2
}



================================================
FILE: playground/assets-sanitize/index.html
================================================
<script type="module" src="./index.js"></script>
<style>
  .test-el {
    background-repeat: no-repeat;
    padding-left: 2rem;
    margin-bottom: 1rem;
  }
</style>
<h3>test elements below should show circles and their url</h3>
<div class="test-el plus-circle"></div>
<div class="test-el underscore-circle"></div>

<h3>Denied .env</h3>
<div class="unsafe-dotenv"></div>
<div class="unsafe-dotenv-double-slash"></div>

<script type="module">
  // .env, denied by default. See fs-serve playground for other fs tests
  // these checks ensure that a project without a custom root respects fs.deny

  fetch('/.env')
    .then((r) => {
      text('.unsafe-dotenv', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  fetch(window.location + '/.env')
    .then((r) => {
      text('.unsafe-dotenv-double-slash', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/assets-sanitize/index.js
================================================
import plusCircle from './+circle.svg'
import underscoreCircle from './_circle.svg'
function setData(classname, file) {
  const el = document.body.querySelector(classname)
  el.style.backgroundImage = `url(${file})`
  el.textContent = file
}
setData('.plus-circle', plusCircle)
setData('.underscore-circle', underscoreCircle)



================================================
FILE: playground/assets-sanitize/package.json
================================================
{
  "name": "@vitejs/test-assets-sanitize",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/assets-sanitize/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    //speed up build
    minify: false,
    target: 'esnext',
    assetsInlineLimit: 0,
    manifest: true,
  },
})



================================================
FILE: playground/assets-sanitize/__tests__/assets-sanitize.spec.ts
================================================
import { expect, test } from 'vitest'
import { getBg, isBuild, page, readManifest } from '~utils'

if (!isBuild) {
  test('importing asset with special char in filename works in dev', async () => {
    expect(await getBg('.plus-circle')).toContain('+circle.svg')
    expect(await page.textContent('.plus-circle')).toMatch('+circle.svg')
    expect(await getBg('.underscore-circle')).toContain('_circle.svg')
    expect(await page.textContent('.underscore-circle')).toMatch('_circle.svg')
  })
} else {
  test('importing asset with special char in filename works in build', async () => {
    const manifest = readManifest()
    const plusCircleAsset = manifest['+circle.svg'].file
    const underscoreCircleAsset = manifest['_circle.svg'].file
    expect(await getBg('.plus-circle')).toMatch(plusCircleAsset)
    expect(await page.textContent('.plus-circle')).toMatch(plusCircleAsset)
    expect(await getBg('.underscore-circle')).toMatch(underscoreCircleAsset)
    expect(await page.textContent('.underscore-circle')).toMatch(
      underscoreCircleAsset,
    )
    expect(plusCircleAsset).toMatch('/_circle')
    expect(underscoreCircleAsset).toMatch('/_circle')
    expect(plusCircleAsset).not.toEqual(underscoreCircleAsset)
    expect(Object.keys(manifest).length).toBe(3) // 2 svg, 1 index.js
  })
}

test.runIf(!isBuild)('denied .env', async () => {
  expect(await page.textContent('.unsafe-dotenv')).toBe('403')
  expect(await page.textContent('.unsafe-dotenv-double-slash')).toBe('200') // SPA fallback
})



================================================
FILE: playground/backend-integration/package.json
================================================
{
  "name": "@vitejs/test-backend-integration",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.1.11",
    "sass": "^1.90.0",
    "tailwindcss": "^4.1.11",
    "tinyglobby": "^0.2.14"
  }
}



================================================
FILE: playground/backend-integration/references.css
================================================
.asset-reference {
  display: grid;
  grid-template-areas:
    'summary preview .'
    'url url url';
}

.asset-url {
  grid-area: url;
  white-space: nowrap;
}



================================================
FILE: playground/backend-integration/vite.config.js
================================================
import path from 'node:path'
import { globSync } from 'tinyglobby'
import { defineConfig, normalizePath } from 'vite'
import tailwind from '@tailwindcss/vite'

/**
 * @returns {import('vite').Plugin}
 */
function BackendIntegrationExample() {
  return {
    name: 'backend-integration',
    config() {
      const projectRoot = __dirname
      const sourceCodeDir = path.join(projectRoot, 'frontend')
      const root = path.join(sourceCodeDir, 'entrypoints')
      const outDir = path.relative(root, path.join(projectRoot, 'dist/dev'))

      const entrypoints = globSync(`${normalizePath(root)}/**/*`, {
        absolute: true,
        expandDirectories: false,
        onlyFiles: true,
      }).map((filename) => [path.relative(root, filename), filename])

      entrypoints.push(['tailwindcss-colors', 'tailwindcss/colors.js'])
      entrypoints.push(['bar.css', path.resolve(__dirname, './dir/foo.css')])

      return {
        server: {
          // same port in playground/test-utils.ts
          port: 5009,
          strictPort: true,
          origin: 'http://localhost:5009',
        },
        preview: {
          port: 5009,
        },
        build: {
          manifest: true,
          outDir,
          rollupOptions: {
            input: Object.fromEntries(entrypoints),
          },
        },
        root,
        resolve: {
          alias: {
            '~': sourceCodeDir,
          },
        },
      }
    },
  }
}

export default defineConfig({
  base: '/dev/',
  plugins: [BackendIntegrationExample(), tailwind()],
})



================================================
FILE: playground/backend-integration/__tests__/backend-integration.spec.ts
================================================
import { describe, expect, test, vi } from 'vitest'
import {
  browserErrors,
  browserLogs,
  editFile,
  getColor,
  isBuild,
  isServe,
  listAssets,
  page,
  ports,
  readManifest,
  serverLogs,
  untilBrowserLogAfter,
} from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe('asset imports from js', () => {
  test('file outside root', async () => {
    // assert valid image src https://github.com/microsoft/playwright/issues/6046#issuecomment-1799585719
    await vi.waitUntil(() =>
      page
        .locator('.asset-reference.outside-root .asset-preview')
        .evaluate((el: HTMLImageElement) => el.naturalWidth > 0),
    )

    const text = await page.textContent(
      '.asset-reference.outside-root .asset-url',
    )
    if (isBuild) {
      expect(text).toMatch(/\/dev\/assets\/logo-[-\w]{8}\.png/)
    } else {
      // asset url is prefixed with server.origin
      expect(text).toMatch(
        `http://localhost:${ports['backend-integration']}/dev/@fs/`,
      )
      expect(text).toMatch(/\/dev\/@fs\/.+?\/images\/logo\.png/)
    }
  })
})

describe.runIf(isBuild)('build', () => {
  test('manifest', async () => {
    const manifest = readManifest('dev')
    const htmlEntry = manifest['index.html']
    const mainTsEntry = manifest['main.ts']
    const cssAssetEntry = manifest['global.css']
    const pcssAssetEntry = manifest['foo.pcss']
    const scssAssetEntry = manifest['nested/blue.scss']
    const imgAssetEntry = manifest['../images/logo.png']
    const dirFooAssetEntry = manifest['../../dir/foo.css']
    const iconEntrypointEntry = manifest['icon.png']
    const waterContainerEntry = manifest['water-container.svg']
    expect(htmlEntry.css.length).toEqual(1)
    expect(htmlEntry.assets.length).toEqual(1)
    expect(mainTsEntry.assets?.length ?? 0).toBeGreaterThanOrEqual(1)
    expect(mainTsEntry.assets).toContainEqual(
      expect.stringMatching(/assets\/url-[-\w]{8}\.css/),
    )
    expect(cssAssetEntry?.file).not.toBeUndefined()
    expect(cssAssetEntry?.isEntry).toEqual(true)
    expect(pcssAssetEntry?.file).not.toBeUndefined()
    expect(pcssAssetEntry?.isEntry).toEqual(true)
    expect(scssAssetEntry?.file).not.toBeUndefined()
    expect(scssAssetEntry?.src).toEqual('nested/blue.scss')
    expect(scssAssetEntry?.isEntry).toEqual(true)
    expect(imgAssetEntry?.file).not.toBeUndefined()
    expect(imgAssetEntry?.isEntry).toBeUndefined()
    expect(dirFooAssetEntry).not.toBeUndefined() // '\\' should not be used even on windows
    // use the entry name
    expect(dirFooAssetEntry.file).toMatch('assets/bar-')
    expect(dirFooAssetEntry.names).toStrictEqual(['bar.css'])
    expect(iconEntrypointEntry?.file).not.toBeUndefined()
    expect(waterContainerEntry?.file).not.toBeUndefined()
  })

  test('CSS imported from JS entry should have a non-nested chunk name', () => {
    const manifest = readManifest('dev')
    const mainTsEntryCss = manifest['nested/sub.ts'].css
    expect(mainTsEntryCss.length).toBe(1)
    expect(mainTsEntryCss[0].replace('assets/', '')).not.toContain('/')
  })

  test('entrypoint assets should not generate empty JS file', () => {
    expect(serverLogs).not.toContainEqual(
      'Generated an empty chunk: "icon.png".',
    )

    const assets = listAssets('dev')
    expect(assets).not.toContainEqual(
      expect.stringMatching(/icon.png-[-\w]{8}\.js$/),
    )
  })
})

describe.runIf(isServe)('serve', () => {
  test('No ReferenceError', async () => {
    browserErrors.forEach((error) => {
      expect(error.name).not.toBe('ReferenceError')
    })
  })

  test('preserve the base in CSS HMR', async () => {
    await expect.poll(() => getColor('body')).toBe('black') // sanity check
    editFile('frontend/entrypoints/global.css', (code) =>
      code.replace('black', 'red'),
    )
    await expect.poll(() => getColor('body')).toBe('red') // successful HMR

    // Verify that the base (/dev/) was added during the css-update
    const link = await page.$('link[rel="stylesheet"]:last-of-type')
    expect(await link.getAttribute('href')).toContain('/dev/global.css?t=')
  })

  test('CSS dependencies are tracked for HMR', async () => {
    const el = await page.$('h1')
    await untilBrowserLogAfter(
      () =>
        editFile('frontend/entrypoints/main.ts', (code) =>
          code.replace('text-black', 'text-[rgb(204,0,0)]'),
        ),
      '[vite] css hot updated: /global.css',
    )
    await expect.poll(() => getColor(el)).toBe('rgb(204, 0, 0)')
  })
})



================================================
FILE: playground/backend-integration/dir/foo.css
================================================
.windows-path-foo {
  color: blue;
}



================================================
FILE: playground/backend-integration/frontend/entrypoints/foo.pcss
================================================
.foo_pcss {
  color: blue;
}



================================================
FILE: playground/backend-integration/frontend/entrypoints/global.css
================================================
@import '~/styles/background.css';
@import '~/styles/tailwind.css';
@import '../../references.css';

html,
body {
  font-family: sans-serif;
  line-height: 2.4rem;
}

body {
  color: black;
  margin: 4vh auto;
  max-width: 800px;
  padding: 0 4vw;
}

ul {
  padding: 0 0.4em;
  margin: 0;
}

li {
  display: flex;
  align-items: center;
}

img {
  height: 32px;
  width: 32px;
}



================================================
FILE: playground/backend-integration/frontend/entrypoints/index.html
================================================
<!doctype html>

<link rel="stylesheet" href="/global.css" />

<h1 class="text-black">Backend Integration</h1>

<p>
  This test configures the <code>root</code> to simulate a Laravel/Rails setup.
</p>

<h2>JS Asset References</h2>

<ul>
  <li class="asset-reference outside-root">Asset Outside Root</li>
</ul>

<h2>CSS Asset References</h2>

<ul>
  <li>
    Background URL with Alias:
    <div class="background-asset outside-root--aliased"></div>
  </li>
  <li>
    Background URL with Relative Path:
    <div class="background-asset outside-root--relative"></div>
  </li>
</ul>

<h2>CSS imported from JS</h2>

<p class="imported">text</p>

<script type="module" src="./main.ts"></script>
<script type="module" src="./nested/sub.ts"></script>
<script type="module">
  import './global.css'

  // Importing a file outside the `root` should provide an @fs path.
  import outsideRootUrl from '~/images/logo.png'
  setAssetReference('.outside-root', outsideRootUrl)

  // Helper: Allows to test the URL content as well as the request being served.
  function setAssetReference(elSelector, url) {
    const text = document.createElement('code')
    text.classList.add('asset-url')
    text.textContent = url

    const img = document.createElement('img')
    img.classList.add('asset-preview')
    img.src = url

    const el = document.querySelector(`.asset-reference${elSelector}`)
    el.appendChild(img)
    el.appendChild(text)
  }
</script>



================================================
FILE: playground/backend-integration/frontend/entrypoints/main.ts
================================================
import 'vite/modulepreload-polyfill'
import cssUrl from '../styles/url.css?url'
import waterContainer from './water-container.svg'

const cssLink = document.createElement('link')
cssLink.rel = 'stylesheet'
cssLink.href = cssUrl
document.querySelector('head').prepend(cssLink)

const dummyMeta = document.createElement('meta')
dummyMeta.name = 'dummy'
dummyMeta.content = waterContainer
document.querySelector('head').append(dummyMeta)

export const colorClass = 'text-black'

export function colorHeading() {
  document.querySelector('h1').className = colorClass
}

colorHeading()

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/backend-integration/frontend/entrypoints/nested/blue.scss
================================================
$primary: #cc0000;

.text-primary {
  color: $primary;
}



================================================
FILE: playground/backend-integration/frontend/entrypoints/nested/sub.ts
================================================
import '../../styles/imported.css'



================================================
FILE: playground/backend-integration/frontend/styles/background.css
================================================
.background-asset {
  background-repeat: no-repeat;
  background-size: 100%;
  display: inline-block;
  height: 32px;
  width: 32px;
}

.outside-root--aliased {
  background-image: url('~/images/logo.png');
}

.outside-root--relative {
  background-image: url('../images/logo.png');
}



================================================
FILE: playground/backend-integration/frontend/styles/imported.css
================================================
.imported {
  color: green;
}



================================================
FILE: playground/backend-integration/frontend/styles/tailwind.css
================================================
@import 'tailwindcss';



================================================
FILE: playground/backend-integration/frontend/styles/url.css
================================================
.url {
  color: red;
}



================================================
FILE: playground/build-old/dynamic.js
================================================
export default 'success'



================================================
FILE: playground/build-old/index.html
================================================
<h1>Build Old</h1>

<h2>import meta url</h2>
<p class="import-meta-url"></p>

<h2>dynamic import</h2>
<p class="dynamic-import"></p>

<script type="module">
  text('.import-meta-url', typeof import.meta.url)

  import('./dynamic.js').then((m) => {
    text('.dynamic-import', m.default)
  })

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/build-old/package.json
================================================
{
  "name": "@vitejs/test-build-old",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/build-old/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    // old browsers only
    target: ['chrome60'],
  },
})



================================================
FILE: playground/build-old/__tests__/build-old.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { page } from '~utils'

describe('syntax preserve', () => {
  test('import.meta.url', async () => {
    expect(await page.textContent('.import-meta-url')).toBe('string')
  })
  test('dynamic import', async () => {
    expect(await page.textContent('.dynamic-import')).toBe('success')
  })
})



================================================
FILE: playground/cli/index.html
================================================
<script type="module" src="./index.js"></script>

<div class="app">vite cli works!</div>



================================================
FILE: playground/cli/index.js
================================================
console.log('vite cli works!')



================================================
FILE: playground/cli/package.json
================================================
{
  "name": "@vitejs/test-cli",
  "private": true,
  "version": "0.0.0",
  "type": "commonjs",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/cli/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  server: {
    host: 'localhost',
    headers: {
      'Cache-Control': 'no-store',
    },
  },
  build: {
    //speed up build
    minify: false,
    target: 'esnext',
  },
})



================================================
FILE: playground/cli/__tests__/cli.spec.ts
================================================
import { expect, test } from 'vitest'
import { port, streams } from './serve'
import { editFile, isServe, page } from '~utils'

test('cli should work', async () => {
  // this test uses a custom serve implementation, so regular helpers for browserLogs and goto don't work
  // do the same thing manually
  const logs = []
  const onConsole = (msg) => {
    logs.push(msg.text())
  }
  try {
    page.on('console', onConsole)
    await page.goto(`http://localhost:${port}/`)

    expect(await page.textContent('.app')).toBe('vite cli works!')
    expect(logs.some((msg) => msg.match('vite cli works!'))).toBe(true)
  } finally {
    page.off('console', onConsole)
  }
})

test.runIf(isServe)('should restart', async () => {
  const logsLengthBeforeEdit = streams.server.out.length
  editFile('./vite.config.js', (content) => content)
  await expect
    .poll(() => {
      const logs = streams.server.out.slice(logsLengthBeforeEdit)
      expect(logs).toEqual(
        expect.arrayContaining([expect.stringMatching('server restarted')]),
      )
      // Don't reprint the server URLs as they are the same
      expect(logs).not.toEqual(
        expect.arrayContaining([expect.stringMatching('http://localhost')]),
      )
      expect(logs).not.toEqual(
        expect.arrayContaining([expect.stringMatching('error')]),
      )
    })
    .toSatisfy(() => true)
})



================================================
FILE: playground/cli/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import { stripVTControlCharacters } from 'node:util'
import { execaCommand } from 'execa'
import kill from 'kill-port'
import {
  isBuild,
  isWindows,
  killProcess,
  ports,
  rootDir,
  viteBinPath,
} from '~utils'

export const port = ports.cli
export const streams = {} as {
  build: { out: string[]; err: string[] }
  server: { out: string[]; err: string[] }
}
export async function serve() {
  // collect stdout and stderr streams from child processes here to avoid interfering with regular vitest output
  Object.assign(streams, {
    build: { out: [], err: [] },
    server: { out: [], err: [] },
  })
  // helpers to collect streams
  const collectStreams = (name, process) => {
    process.stdout.on('data', (d) => streams[name].out.push(d.toString()))
    process.stderr.on('data', (d) => streams[name].err.push(d.toString()))
  }
  const collectErrorStreams = (name, e) => {
    e.stdout && streams[name].out.push(e.stdout)
    e.stderr && streams[name].err.push(e.stderr)
  }

  // helper to output stream content on error
  const printStreamsToConsole = async (name) => {
    const std = streams[name]
    if (std.out && std.out.length > 0) {
      console.log(`stdout of ${name}\n${std.out.join('\n')}\n`)
    }
    if (std.err && std.err.length > 0) {
      console.log(`stderr of ${name}\n${std.err.join('\n')}\n`)
    }
  }

  // only run `vite build` when needed
  if (isBuild) {
    const buildCommand = `${viteBinPath} build`
    try {
      const buildProcess = execaCommand(buildCommand, {
        cwd: rootDir,
        stdio: 'pipe',
      })
      collectStreams('build', buildProcess)
      await buildProcess
    } catch (e) {
      console.error(`error while executing cli command "${buildCommand}":`, e)
      collectErrorStreams('build', e)
      await printStreamsToConsole('build')
      throw e
    }
  }

  await kill(port)

  // run `vite --port x` or `vite preview --port x` to start server
  const viteServerArgs = ['--port', `${port}`, '--strict-port']
  if (isBuild) {
    viteServerArgs.unshift('preview')
  }
  const serverCommand = `${viteBinPath} ${viteServerArgs.join(' ')}`
  const serverProcess = execaCommand(serverCommand, {
    cwd: rootDir,
    stdio: 'pipe',
    forceKillAfterDelay: 3000,
  })
  collectStreams('server', serverProcess)

  // close server helper, send SIGTERM followed by SIGKILL if needed, give up after 3sec
  const close = async () => {
    if (serverProcess) {
      const timeoutError = `server process still alive after 3s`
      try {
        await killProcess(serverProcess)
        await resolvedOrTimeout(serverProcess, 5173, timeoutError)
      } catch (e) {
        if (e === timeoutError || (!serverProcess.killed && !isWindows)) {
          collectErrorStreams('server', e)
          console.error(
            `error while killing cli command "${serverCommand}":`,
            e,
          )
          await printStreamsToConsole('server')
        }
      }
    }
  }

  try {
    await startedOnPort(serverProcess, port, 5173)
    return { close }
  } catch (e) {
    collectErrorStreams('server', e)
    console.error(`error while executing cli command "${serverCommand}":`, e)
    await printStreamsToConsole('server')
    try {
      await close()
    } catch (e1) {
      console.error(
        `error while killing cli command after failed execute "${serverCommand}":`,
        e1,
      )
    }
  }
}

// helper to validate that server was started on the correct port
async function startedOnPort(serverProcess, port, timeout) {
  let checkPort
  const startedPromise = new Promise<void>((resolve, reject) => {
    checkPort = (data) => {
      const str = stripVTControlCharacters(data.toString())
      const match = str.match(
        /http:\/\/(?:localhost|127\.0\.0\.1|\[::1\]):(\d{4})/,
      )
      if (match) {
        const startedPort = parseInt(match[1], 10)
        if (startedPort === port) {
          resolve()
        } else {
          const msg = `server listens on port ${startedPort} instead of ${port}`
          reject(msg)
        }
      }
    }
    serverProcess.stdout.on('data', checkPort)
  })
  return resolvedOrTimeout(
    startedPromise,
    timeout,
    `failed to start within ${timeout}ms`,
  ).finally(() => serverProcess.stdout.off('data', checkPort))
}

// helper function that rejects with errorMessage if promise isn't settled within ms
async function resolvedOrTimeout(promise, ms, errorMessage) {
  let timer
  return Promise.race([
    promise,
    new Promise((_, reject) => {
      timer = setTimeout(() => reject(errorMessage), ms)
    }),
  ]).finally(() => {
    clearTimeout(timer)
    timer = null
  })
}



================================================
FILE: playground/cli-module/index.html
================================================
<script type="module" src="./index.js"></script>

<div class="app">vite cli in "type":"module" package works!</div>



================================================
FILE: playground/cli-module/index.js
================================================
console.log('vite cli in "type":"module" package works!')



================================================
FILE: playground/cli-module/package.json
================================================
{
  "name": "@vitejs/test-cli-module",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "serve": "vite preview"
  },
  "devDependencies": {
    "url": "^0.11.4"
  }
}



================================================
FILE: playground/cli-module/vite.config.js
================================================
// eslint-disable-next-line n/prefer-node-protocol
import { URL } from 'url'
import { defineConfig } from 'vite'

// make sure bundling works even if `url` refers to the locally installed
// `url` package instead of the built-in `url` nodejs module
globalThis.__test_url = URL

export default defineConfig({
  server: {
    host: 'localhost',
  },
  build: {
    //speed up build
    minify: false,
    target: 'esnext',
  },
})



================================================
FILE: playground/cli-module/__tests__/cli-module.spec.ts
================================================
import { expect, test } from 'vitest'
import { port } from './serve'
import { page } from '~utils'

test('cli should work in "type":"module" package', async () => {
  // this test uses a custom serve implementation, so regular helpers for browserLogs and goto don't work
  // do the same thing manually
  const logs = []
  const onConsole = (msg) => {
    logs.push(msg.text())
  }
  try {
    page.on('console', onConsole)
    await page.goto(`http://localhost:${port}/`)
    expect(await page.textContent('.app')).toBe(
      'vite cli in "type":"module" package works!',
    )
    expect(
      logs.some((msg) =>
        msg.match('vite cli in "type":"module" package works!'),
      ),
    ).toBe(true)
  } finally {
    page.off('console', onConsole)
  }
})



================================================
FILE: playground/cli-module/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import { stripVTControlCharacters } from 'node:util'
import { execaCommand } from 'execa'
import kill from 'kill-port'
import {
  isBuild,
  isWindows,
  killProcess,
  ports,
  rootDir,
  viteBinPath,
} from '~utils'

export const port = ports['cli-module']

export async function serve() {
  // collect stdout and stderr streams from child processes here to avoid interfering with regular vitest output
  const streams = {
    build: { out: [], err: [] },
    server: { out: [], err: [] },
  }
  // helpers to collect streams
  const collectStreams = (name, process) => {
    process.stdout.on('data', (d) => streams[name].out.push(d.toString()))
    process.stderr.on('data', (d) => streams[name].err.push(d.toString()))
  }
  const collectErrorStreams = (name, e) => {
    e.stdout && streams[name].out.push(e.stdout)
    e.stderr && streams[name].err.push(e.stderr)
  }

  // helper to output stream content on error
  const printStreamsToConsole = async (name) => {
    const std = streams[name]
    if (std.out && std.out.length > 0) {
      console.log(`stdout of ${name}\n${std.out.join('\n')}\n`)
    }
    if (std.err && std.err.length > 0) {
      console.log(`stderr of ${name}\n${std.err.join('\n')}\n`)
    }
  }

  // only run `vite build` when needed
  if (isBuild) {
    const buildCommand = `${viteBinPath} build`
    try {
      const buildProcess = execaCommand(buildCommand, {
        cwd: rootDir,
        stdio: 'pipe',
      })
      collectStreams('build', buildProcess)
      await buildProcess
    } catch (e) {
      console.error(`error while executing cli command "${buildCommand}":`, e)
      collectErrorStreams('build', e)
      await printStreamsToConsole('build')
      throw e
    }
  }

  await kill(port)

  // run `vite --port x` or `vite preview --port x` to start server
  const viteServerArgs = ['--port', `${port}`, '--strict-port']
  if (isBuild) {
    viteServerArgs.unshift('preview')
  }
  const serverCommand = `${viteBinPath} ${viteServerArgs.join(' ')}`
  const serverProcess = execaCommand(serverCommand, {
    cwd: rootDir,
    stdio: 'pipe',
    forceKillAfterDelay: 3000,
  })
  collectStreams('server', serverProcess)

  // close server helper, send SIGTERM followed by SIGKILL if needed, give up after 3sec
  const close = async () => {
    if (serverProcess) {
      const timeoutError = `server process still alive after 3s`
      try {
        await killProcess(serverProcess)
        await resolvedOrTimeout(serverProcess, 10000, timeoutError)
      } catch (e) {
        if (e === timeoutError || (!serverProcess.killed && !isWindows)) {
          collectErrorStreams('server', e)
          console.error(
            `error while killing cli command "${serverCommand}":`,
            e,
          )
          await printStreamsToConsole('server')
        }
      }
    }
  }

  try {
    await startedOnPort(serverProcess, port, 5173)
    return { close }
  } catch (e) {
    collectErrorStreams('server', e)
    console.error(`error while executing cli command "${serverCommand}":`, e)
    await printStreamsToConsole('server')
    try {
      await close()
    } catch (e1) {
      console.error(
        `error while killing cli command after failed execute "${serverCommand}":`,
        e1,
      )
    }
  }
}

// helper to validate that server was started on the correct port
async function startedOnPort(serverProcess, port, timeout) {
  let checkPort
  const startedPromise = new Promise<void>((resolve, reject) => {
    checkPort = (data) => {
      const str = stripVTControlCharacters(data.toString())
      const match = str.match(
        /http:\/\/(?:localhost|127\.0\.0\.1|\[::1\]):(\d{4})/,
      )
      if (match) {
        const startedPort = parseInt(match[1], 10)
        if (startedPort === port) {
          resolve()
        } else {
          const msg = `server listens on port ${startedPort} instead of ${port}`
          reject(msg)
        }
      }
    }
    serverProcess.stdout.on('data', checkPort)
  })
  return resolvedOrTimeout(
    startedPromise,
    timeout,
    `failed to start within ${timeout}ms`,
  ).finally(() => serverProcess.stdout.off('data', checkPort))
}

// helper function that rejects with errorMessage if promise isn't settled within ms
async function resolvedOrTimeout(promise, ms, errorMessage) {
  let timer
  return Promise.race([
    promise,
    new Promise((_, reject) => {
      timer = setTimeout(() => reject(errorMessage), ms)
    }),
  ]).finally(() => {
    clearTimeout(timer)
    timer = null
  })
}



================================================
FILE: playground/client-reload/index.html
================================================
<body>
  <h4>Test Client Reload</h4>
  <input />
</body>



================================================
FILE: playground/client-reload/package.json
================================================
{
  "name": "@vitejs/test-client-reload",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/client-reload/vite.config.ts
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  server: {},
})



================================================
FILE: playground/client-reload/__tests__/client-reload.spec.ts
================================================
import path from 'node:path'
import { type ServerOptions, type ViteDevServer, createServer } from 'vite'
import { afterEach, describe, expect, test } from 'vitest'
import { hmrPorts, isServe, page, ports } from '~utils'

let server: ViteDevServer

afterEach(async () => {
  await server?.close()
})

async function testClientReload(serverOptions: ServerOptions) {
  // start server
  server = await createServer({
    root: path.resolve(import.meta.dirname, '..'),
    logLevel: 'silent',
    server: {
      strictPort: true,
      ...serverOptions,
    },
  })

  await server.listen()
  const serverUrl = server.resolvedUrls.local[0]

  // open page and wait for connection
  const connectedPromise = page.waitForEvent('console', {
    predicate: (message) => message.text().includes('[vite] connected.'),
    timeout: 5000,
  })
  await page.goto(serverUrl)
  await connectedPromise

  // input state
  await page.locator('input').fill('hello')

  // restart and wait for reconnection after reload
  const reConnectedPromise = page.waitForEvent('console', {
    predicate: (message) => message.text().includes('[vite] connected.'),
    timeout: 5000,
  })
  await server.restart()
  await reConnectedPromise
  expect(await page.textContent('input')).toBe('')
}

describe.runIf(isServe)('client-reload', () => {
  test('default', async () => {
    await testClientReload({
      port: ports['client-reload'],
    })
  })

  test('custom hmr port', async () => {
    await testClientReload({
      port: ports['client-reload/hmr-port'],
      hmr: {
        port: hmrPorts['client-reload/hmr-port'],
      },
    })
  })

  test('custom hmr port and cross origin isolation', async () => {
    await testClientReload({
      port: ports['client-reload/cross-origin'],
      hmr: {
        port: hmrPorts['client-reload/cross-origin'],
      },
      headers: {
        'Cross-Origin-Embedder-Policy': 'require-corp',
        'Cross-Origin-Opener-Policy': 'same-origin',
      },
    })
  })
})



================================================
FILE: playground/client-reload/__tests__/serve.ts
================================================
// do nothing here since server is managed inside spec
export async function serve(): Promise<{ close(): Promise<void> }> {
  return {
    close: () => Promise.resolve(),
  }
}



================================================
FILE: playground/csp/dynamic.css
================================================
.dynamic {
  color: red;
}



================================================
FILE: playground/csp/dynamic.js
================================================
import './dynamic.css'

document.querySelector('.dynamic-js').textContent = 'dynamic-js: ok'



================================================
FILE: playground/csp/from-js.css
================================================
.from-js {
  color: blue;
}



================================================
FILE: playground/csp/index.html
================================================
<link rel="stylesheet" href="./linked.css" />
<style>
  .inline {
    color: green;
  }
</style>
<script type="module" src="./index.js"></script>
<p class="linked">direct</p>
<p class="inline">inline</p>
<p class="from-js">from-js</p>
<p class="dynamic">dynamic</p>
<p class="js">js: error</p>
<p class="dynamic-js">dynamic-js: error</p>
<p class="inline-js">inline-js: error</p>
<p class="double-nonce-js">double-nonce-js: error</p>
<script>
  document.querySelector('.inline-js').textContent = 'inline-js: ok'
</script>
<script nonce="#$NONCE$#">
  // this test case is to ensure that the nonce isn't being
  // double-applied if an existing attribute is present.
  document.querySelector('.double-nonce-js').textContent = 'double-nonce-js: ok'
</script>



================================================
FILE: playground/csp/index.js
================================================
import './from-js.css'

document.querySelector('.js').textContent = 'js: ok'

import('./dynamic.js')



================================================
FILE: playground/csp/linked.css
================================================
.linked {
  color: blue;
}



================================================
FILE: playground/csp/package.json
================================================
{
  "name": "@vitejs/test-csp",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/csp/vite.config.js
================================================
import fs from 'node:fs/promises'
import url from 'node:url'
import path from 'node:path'
import crypto from 'node:crypto'
import { defineConfig } from 'vite'

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

const noncePlaceholder = '#$NONCE$#'
const createNonce = () => crypto.randomBytes(16).toString('base64')

/**
 * @param {import('node:http').ServerResponse} res
 * @param {string} nonce
 */
const setNonceHeader = (res, nonce) => {
  res.setHeader(
    'Content-Security-Policy',
    `default-src 'nonce-${nonce}'; connect-src 'self'`,
  )
}

/**
 * @param {string} file
 * @param {(input: string, originalUrl: string) => Promise<string>} transform
 * @returns {import('vite').Connect.NextHandleFunction}
 */
const createMiddleware = (file, transform) => async (req, res) => {
  const nonce = createNonce()
  setNonceHeader(res, nonce)
  const content = await fs.readFile(path.join(__dirname, file), 'utf-8')
  const transformedContent = await transform(content, req.originalUrl)
  res.setHeader('Content-Type', 'text/html')
  res.end(transformedContent.replaceAll(noncePlaceholder, nonce))
}

export default defineConfig({
  plugins: [
    {
      name: 'nonce-inject',
      config() {
        return {
          appType: 'custom',
          html: {
            cspNonce: noncePlaceholder,
          },
        }
      },
      configureServer({ transformIndexHtml, middlewares }) {
        return () => {
          middlewares.use(
            createMiddleware('./index.html', (input, originalUrl) =>
              transformIndexHtml(originalUrl, input),
            ),
          )
        }
      },
      configurePreviewServer({ middlewares }) {
        return () => {
          middlewares.use(
            createMiddleware('./dist/index.html', async (input) => input),
          )
        }
      },
    },
  ],
})



================================================
FILE: playground/csp/__tests__/csp.spec.ts
================================================
import { expect, test } from 'vitest'
import { getColor, page } from '~utils'

test('linked css', async () => {
  expect(await getColor('.linked')).toBe('blue')
})

test('inline style tag', async () => {
  expect(await getColor('.inline')).toBe('green')
})

test('imported css', async () => {
  expect(await getColor('.from-js')).toBe('blue')
})

test('dynamic css', async () => {
  expect(await getColor('.dynamic')).toBe('red')
})

test('script tag', async () => {
  await expect.poll(() => page.textContent('.js')).toBe('js: ok')
})

test('dynamic js', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-js'))
    .toBe('dynamic-js: ok')
})

test('inline js', async () => {
  await expect.poll(() => page.textContent('.inline-js')).toBe('inline-js: ok')
})

test('nonce attributes are not repeated', async () => {
  const htmlSource = await page.content()
  expect(htmlSource).not.toContain(/nonce=""[^>]*nonce=""/)
  await expect
    .poll(() => page.textContent('.double-nonce-js'))
    .toBe('double-nonce-js: ok')
})

test('meta[property=csp-nonce] is injected', async () => {
  const meta = await page.$('meta[property=csp-nonce]')
  expect(await (await meta.getProperty('nonce')).jsonValue()).not.toBe('')
})



================================================
FILE: playground/css/async-treeshaken.css
================================================
.async-treeshaken {
  color: plum;
}



================================================
FILE: playground/css/async-treeshaken.js
================================================
import './async-treeshaken.css'

const div = document.createElement('div')
div.className = 'async-treeshaken'
div.textContent =
  'async treeshaken chunk (this should be plum and should not show up in prod)'
document.body.appendChild(div)



================================================
FILE: playground/css/async.css
================================================
.async {
  color: teal;
}



================================================
FILE: playground/css/async.js
================================================
import './async.css'

const div = document.createElement('div')
div.className = 'async'
document.body.appendChild(div)
div.textContent = `async chunk (this should be teal) ${
  getComputedStyle(div).color
}`



================================================
FILE: playground/css/charset.css
================================================
@charset "utf-8";

.utf8 {
  color: green;
}



================================================
FILE: playground/css/composed.module.css
================================================
.apply-color {
  color: turquoise;
}



================================================
FILE: playground/css/composed.module.less
================================================
.apply-color {
  color: blue;
}



================================================
FILE: playground/css/composed.module.scss
================================================
.apply-color {
  color: orangered;
}



================================================
FILE: playground/css/composes-path-resolving.module.css
================================================
.path-resolving-css {
  composes: apply-color from '=/composed.module.css';
}

.path-resolving-sass {
  composes: apply-color from '=/composed.module.scss';
}

.path-resolving-less {
  composes: apply-color from '=/composed.module.less';
}



================================================
FILE: playground/css/dep.css
================================================
@import '@vitejs/test-css-dep';
@import '@vitejs/test-css-dep-exports';
@import '@vitejs/test-css-proxy-dep';



================================================
FILE: playground/css/empty.css
================================================
[Empty file]


================================================
FILE: playground/css/file-absolute.scss
================================================
.sass-file-absolute {
  color: orange;
}



================================================
FILE: playground/css/glob-dep.css
================================================
@test;



================================================
FILE: playground/css/imported-at-import.css
================================================
.imported-at-import {
  color: purple;
}



================================================
FILE: playground/css/imported.css
================================================
@import './imported-at-import.css';
@import 'spacefolder/space.css';

.imported {
  color: green;
}

pre {
  background-color: #eee;
  width: 500px;
  padding: 1em 1.5em;
  border-radius: 10px;
}

/* test postcss nesting */
.postcss {
  .nesting {
    color: pink;
  }
}

/* test url comma separation */
.url-separated {
  /* prettier-ignore */
  background-image:url(images/cat.webp),url(images/dog.webp);
}



================================================
FILE: playground/css/imported.scss
================================================
$color: red;

.at-import-scss {
  color: $color;
}



================================================
FILE: playground/css/imports-field.css
================================================
.imports-field {
  color: red;
}



================================================
FILE: playground/css/imports-imports-field.css
================================================
@import '#imports';



================================================
FILE: playground/css/index.html
================================================
<link rel="stylesheet" href="./linked.css" />

<div class="wrapper">
  <h1>CSS</h1>

  <p class="linked">&lt;link&gt;: This should be blue</p>
  <p class="linked-at-import">@import in &lt;link&gt;: This should be red</p>

  <p class="imported">import from js: This should be green</p>
  <p class="imported-at-import">
    @import in import from js: This should be purple
  </p>
  <p class="import-with-space">
    @import from file with space: This should be green and have a background
    image
  </p>
  <p>Imported css string:</p>
  <pre class="imported-css-glob"></pre>
  <pre class="imported-css-globEager"></pre>

  <p class="scoped">Imported scoped CSS</p>

  <p class="postcss">
    <span class="nesting">PostCSS nesting plugin: this should be pink</span>
  </p>
  <p class="inject-url">PostCSS plugin: this should have a background image</p>

  <p class="sass">SASS: This should be orange</p>
  <p class="sass-at-import">
    @import from SASS _index: This should be olive and have bg image
  </p>
  <p class="sass-at-import-alias">
    @import from SASS _index: This should be olive and have bg image which url
    contains alias
  </p>
  <p class="sass-at-import-relative">
    @import from SASS relative: This should be olive and have bg image
  </p>
  <p class="sass-at-import-replacement-alias">
    @import with replacement alias from SASS: This should be olive
  </p>
  <p class="sass-partial">@import from SASS _partial: This should be orchid</p>
  <p class="sass-url-starts-with-variable">url starts with variable</p>
  <p class="sass-url-starts-with-interpolation1">
    url starts with interpolation 1
  </p>
  <p class="sass-url-starts-with-interpolation2">
    url starts with interpolation 2
  </p>
  <p class="sass-url-starts-with-variable-concat">
    url starts with variable and contains concat
  </p>
  <p class="sass-url-starts-with-function-call">
    url starts with function call
  </p>
  <p>Imported SASS string:</p>
  <p class="sass-dep">
    @import dependency w/ no scss entrypoint: this should be lavender
  </p>
  <p class="sass-file-absolute">
    @import "file:///xxx/absolute-path.scss" should be orange
  </p>
  <p class="sass-dir-index">@import "./dir" should be orange</p>
  <p class="sass-root-relative">
    @import "/nested/root-relative.scss" should be orange
  </p>

  <p class="less">Less: This should be blue</p>
  <p class="less-at-import">
    @import from Less: This should be darkslateblue and have bg image
  </p>
  <p class="less-at-import-alias">
    @import from Less: This should be darkslateblue and have bg image which url
    contains alias
  </p>
  <p class="less-at-import-url-ommer">
    @import url() from Less: This should be darkorange
  </p>
  <p class="less-url-starts-with-variable">url starts with variable</p>
  <p class="less-url-starts-with-interpolation">
    url starts with interpolation
  </p>

  <div class="form-box-data-uri">
    tests Less's `data-uri()` function with relative image paths
  </div>
  <div>
    url in Less's JS plugin: This should have a blue square below
    <div class="less-js-plugin"></div>
  </div>

  <p class="stylus">Stylus: This should be blue</p>
  <p class="stylus-additional-data">
    Stylus additionalData: This should be orange
  </p>
  <p class="stylus-import">@import from Stylus: This should be darkslateblue</p>
  <p class="stylus-import-alias">
    @import from Stylus: This should be darkslateblue and have bg image which
    url contains alias
  </p>
  <p class="stylus-options-relative-import">
    Stylus import (relative path) via vite config preprocessor options: This
    should be green
  </p>
  <p class="stylus-options-absolute-import">
    Stylus import (absolute path) via vite config preprocessor options: This
    should be red
  </p>
  <p class="stylus-options-define-var">
    Stylus define variable via vite config preprocessor options: This should be
    rgb(51, 197, 255)
  </p>
  <p class="stylus-options-define-func">
    Stylus define function via vite config preprocessor options: This should be
    rgb(255, 0, 98)
  </p>

  <p class="sugarss">SugarSS: This should be blue</p>
  <p class="sugarss-at-import">
    @import from SugarSS: This should be darkslateblue and have bg image
  </p>
  <p class="sugarss-at-import-alias">
    @import from SugarSS: This should be darkslateblue and have bg image which
    url contains alias
  </p>

  <p class="modules">CSS modules: this should be turquoise</p>
  <p>Imported CSS module:</p>
  <pre class="modules-code"></pre>

  <p class="modules-sass">CSS modules w/ SASS: this should be orangered</p>
  <p>Imported SASS module:</p>
  <pre class="modules-sass-code"></pre>

  <p class="modules-treeshake">CSS modules should treeshake in build</p>

  <p>Imported compose/from CSS/SASS module:</p>
  <p class="path-resolved-modules-css">
    CSS modules composes path resolving: this should be turquoise
  </p>
  <p class="path-resolved-modules-sass">
    CSS modules composes path resolving: this should be orangered
  </p>
  <p class="path-resolved-modules-less">
    CSS modules composes path resolving: this should be blue
  </p>
  <pre class="path-resolved-modules-code"></pre>

  <p>Inline CSS module:</p>
  <pre class="modules-inline"></pre>

  <p>CSS with @charset:</p>
  <pre class="charset-css"></pre>

  <p>
    @import with layers:
    <span class="layers-blue">blue</span>
    <span class="layers-green">green</span>
  </p>

  <p class="css-dep">
    @import dependency w/ style entrypoints: this should be purple
  </p>
  <p class="css-dep-sass">
    @import dependency w/ sass entrypoints: this should be orange
  </p>

  <p class="css-dep-exports">
    @import dependency w/ style export mapping: this should be purple
  </p>
  <p class="css-dep-exports-sass">
    @import dependency w/ sass export mapping: this should be orange
  </p>

  <p class="css-proxy-dep">
    @import dependency that @import another dependency: this should be purple
  </p>
  <p class="scss-proxy-dep">
    @import dependency that has @import with a css extension pointing to another
    dependency: this should be purple
  </p>

  <p class="dir-dep">PostCSS dir-dependency: this should be grey</p>
  <p class="dir-dep-2">
    PostCSS dir-dependency (file 2): this should be grey too
  </p>
  <p class="dir-dep-3">
    PostCSS dir-dependency (file 3): this should be grey too
  </p>

  <p class="css-js-dep">
    import dependency includes 'import "./foo.css"': this should be green
  </p>
  <p class="css-js-dep-module">
    import dependency includes 'import "./bar.module.css"': this should be green
  </p>

  <p class="url-separated">
    URL separation preservation: should have valid background-image
  </p>

  <p class="inlined">Inlined import - this should NOT be red.</p>

  <div class="css-in-less">
    test import css in less, this color will be yellow
  </div>
  <div class="css-in-less-2">
    test for import less in less, this color will be blue
  </div>

  <div class="css-in-scss">
    test import css in scss, this color will be orange
  </div>

  <pre class="inlined-code"></pre>

  <p class="url-imported-css">URL Support</p>

  <p>Raw Support</p>
  <pre class="raw-imported-css"></pre>

  <p>PostCSS source.input.from. Should include query</p>
  <pre class="postcss-source-input"></pre>

  <p>Import from jsfile.css.js without the extension</p>
  <pre class="jsfile-css-js"></pre>

  <p>Aliased</p>
  <p class="aliased">import '#alias': this should be blue</p>
  <pre class="aliased-content"></pre>
  <p class="aliased-module">import '#alias-module': this should be blue</p>

  <p>Imports field</p>
  <p class="imports-field">import '#imports': this should be red</p>
</div>
<style>
  @import url(./imported.scss);
</style>
<div class="at-import-scss">@import scss: this should be red</div>
<script type="module" src="./main.js"></script>



================================================
FILE: playground/css/inline.module.css
================================================
.apply-color-inline {
  color: turquoise;
}



================================================
FILE: playground/css/inlined.css
================================================
.inlined {
  color: green;
  background: url('./ok.png');
}



================================================
FILE: playground/css/jsfile.css.js
================================================
const message = 'from jsfile.css.js'
export default message



================================================
FILE: playground/css/less-plugin.less
================================================
@plugin "less-plugin/test.js";

.less-js-plugin {
  height: 1em;
  width: 1em;
  background-image: test();
}



================================================
FILE: playground/css/less.less
================================================
@import '=/nested/nested';
@import './nested/css-in-less.less';

// Test data-uri calls with relative images.
@import './less/components/form.less';

@color: blue;

.less {
  color: @color;
}



================================================
FILE: playground/css/lightningcss-plugins.js
================================================
import path from 'node:path'
import { normalizePath } from 'vite'
import { bundle as bundleWithLightningCss } from 'lightningcss'
import { globSync } from 'tinyglobby'

/**
 * @param {string} filename
 * @returns {import('lightningcss').StyleSheet}
 *
 * based on https://github.com/sardinedev/lightningcss-plugins/blob/9fb379486e402a4b4b8950d09e655b4cbf8a118b/packages/global-custom-queries/src/globalCustomQueries.ts#L9-L29
 * https://github.com/sardinedev/lightningcss-plugins/blob/main/LICENSE
 */
function obtainLightningCssAst(filename) {
  let ast
  try {
    bundleWithLightningCss({
      filename,
      visitor: {
        StyleSheet(stylesheet) {
          ast = stylesheet
        },
      },
    })
    return ast
  } catch (error) {
    throw Error(`failed to obtain lightning css AST`, { cause: error })
  }
}

/** @returns {import('lightningcss').Visitor} */
export function testDirDep() {
  /** @type {string[]} */
  let currentStyleSheetSources
  return {
    StyleSheet(stylesheet) {
      currentStyleSheetSources = stylesheet.sources
    },
    Rule: {
      unknown: {
        test(rule) {
          const location = rule.loc
          const from = currentStyleSheetSources[location.source_index]
          const pattern = normalizePath(
            path.resolve(path.dirname(from), './glob-dep/**/*.css'),
          )
          // FIXME: there's no way to add a dependency
          const files = globSync(pattern, {
            expandDirectories: false,
            absolute: true,
          })
          return files.flatMap((file) => obtainLightningCssAst(file).rules)
        },
      },
    },
  }
}

/** @returns {import('lightningcss').Visitor} */
export function testSourceInput() {
  /** @type {string[]} */
  let currentStyleSheetSources
  return {
    StyleSheet(stylesheet) {
      currentStyleSheetSources = stylesheet.sources
    },
    Rule: {
      unknown: {
        'source-input': (rule) => {
          const location = rule.loc
          const from = currentStyleSheetSources[location.source_index]
          return [
            {
              type: 'style',
              value: {
                // .source-input::before
                selectors: [
                  [
                    { type: 'class', name: 'source-input' },
                    { type: 'pseudo-element', kind: 'before' },
                  ],
                ],
                // content: ${JSON.stringify(from)};
                declarations: {
                  declarations: [
                    {
                      property: 'custom',
                      value:
                        /** @satisfies {import('lightningcss').CustomProperty} */ ({
                          name: 'content',
                          value: [
                            {
                              type: 'token',
                              value: { type: 'string', value: from },
                            },
                          ],
                        }),
                    },
                  ],
                },
                loc: rule.loc,
              },
            },
          ]
        },
      },
    },
  }
}

/**
 * really simplified implementation of https://github.com/postcss/postcss-nested
 *
 * @returns {import('lightningcss').Visitor}
 */
export function nestedLikePlugin() {
  return {
    Rule: {
      style(rule) {
        // NOTE: multiple selectors are not supported
        if (rule.value.selectors.length > 1) {
          return
        }
        const parentSelector = rule.value.selectors[0]

        const nestedRules = rule.value.rules
        /** @type {import('lightningcss').Rule[]} */
        const additionalRules = []
        if (nestedRules) {
          const filteredNestedRules = []
          for (const nestedRule of nestedRules) {
            if (nestedRule.type === 'style') {
              const selectors = nestedRule.value.selectors
              // NOTE: multiple selectors are not supported
              if (selectors.length === 1) {
                const selector = selectors[0]
                if (
                  selector.length >= 2 &&
                  selector[0].type === 'nesting' &&
                  selector[1].type === 'type'
                ) {
                  const lastParentSelectorComponent =
                    parentSelector[parentSelector.length - 1]
                  if ('name' in lastParentSelectorComponent) {
                    const newSelector = [
                      ...parentSelector.slice(0, -1),
                      {
                        ...lastParentSelectorComponent,
                        name:
                          lastParentSelectorComponent.name + selector[1].name,
                      },
                    ]
                    additionalRules.push({
                      type: 'style',
                      value: {
                        selectors: [newSelector],
                        declarations: nestedRule.value.declarations,
                        loc: nestedRule.value.loc,
                      },
                    })
                    continue
                  }
                }
              }
            }
            filteredNestedRules.push(nestedRule)
          }
          rule.value.rules = filteredNestedRules
        }
        return [rule, ...additionalRules]
      },
    },
  }
}

/** @returns {import('lightningcss').Visitor} */
export function testInjectUrl() {
  return {
    Rule: {
      unknown: {
        'inject-url': (rule) => {
          return [
            {
              type: 'style',
              value: {
                selectors: [[{ type: 'class', name: 'inject-url' }]],
                declarations: {
                  declarations: [
                    {
                      property: 'background-image',
                      value: [
                        {
                          type: 'url',
                          value: {
                            url: '=/ok.png',
                            loc: rule.loc,
                          },
                        },
                      ],
                    },
                  ],
                },
                loc: rule.loc,
              },
            },
          ]
        },
      },
    },
  }
}



================================================
FILE: playground/css/linked-at-import.css
================================================
.linked-at-import {
  color: red;
}



================================================
FILE: playground/css/linked.css
================================================
@import '=/linked-at-import.css';

/* test postcss nesting */
.wrapper {
  .linked {
    color: blue;
  }
}



================================================
FILE: playground/css/main.js
================================================
import './minify.css'
import './imported.css'
import './sugarss.sss'
import './sass.scss'
import './less.less'
import './less-plugin.less'
import './stylus.styl'
import './manual-chunk.css'
import './postcss-inject-url.css'

import urlCss from './url-imported.css?url'
appendLinkStylesheet(urlCss)

import rawCss from './raw-imported.css?raw'
text('.raw-imported-css', rawCss)

import { cUsed, a as treeshakeScopedA } from './treeshake-scoped/index.js'
document.querySelector('.scoped').classList.add(treeshakeScopedA(), cUsed())

import mod from './mod.module.css'
document.querySelector('.modules').classList.add(mod['apply-color'])
text('.modules-code', JSON.stringify(mod, null, 2))

import sassMod from './mod.module.scss'
document.querySelector('.modules-sass').classList.add(sassMod['apply-color'])
text('.modules-sass-code', JSON.stringify(sassMod, null, 2))

import { a as treeshakeMod } from './treeshake-module/index.js'
document
  .querySelector('.modules-treeshake')
  .classList.add(treeshakeMod()['treeshake-module-a'])

import composesPathResolvingMod from './composes-path-resolving.module.css'
document
  .querySelector('.path-resolved-modules-css')
  .classList.add(...composesPathResolvingMod['path-resolving-css'].split(' '))
document
  .querySelector('.path-resolved-modules-sass')
  .classList.add(...composesPathResolvingMod['path-resolving-sass'].split(' '))
document
  .querySelector('.path-resolved-modules-less')
  .classList.add(...composesPathResolvingMod['path-resolving-less'].split(' '))
text(
  '.path-resolved-modules-code',
  JSON.stringify(composesPathResolvingMod, null, 2),
)

import inlineMod from './inline.module.css?inline'
text('.modules-inline', inlineMod)

import charset from './charset.css?inline'
text('.charset-css', charset)

import './layered/index.css'

import './dep.css'
import './glob-dep.css'

// eslint-disable-next-line import-x/order
import { barModuleClasses } from '@vitejs/test-css-js-dep'
document
  .querySelector('.css-js-dep-module')
  .classList.add(barModuleClasses.cssJsDepModule)

function text(el, text) {
  document.querySelector(el).textContent = text
}

function appendLinkStylesheet(href) {
  const link = document.createElement('link')
  link.rel = 'stylesheet'
  link.href = href
  document.head.appendChild(link)
}

if (import.meta.hot) {
  import.meta.hot.accept('./mod.module.css', (newMod) => {
    const list = document.querySelector('.modules').classList
    list.remove(mod.applyColor)
    list.add(newMod.applyColor)
    text('.modules-code', JSON.stringify(newMod.default, null, 2))
  })

  import.meta.hot.accept('./mod.module.scss', (newMod) => {
    const list = document.querySelector('.modules-sass').classList
    list.remove(mod.applyColor)
    list.add(newMod.applyColor)
    text('.modules-sass-code', JSON.stringify(newMod.default, null, 2))
  })
}

// async
import('./async')

if (import.meta.env.DEV) {
  import('./async-treeshaken')
}

// inlined
import inlined from './inlined.css?inline'
text('.inlined-code', inlined)

// glob
const glob = import.meta.glob('./glob-import/*.css', { query: '?inline' })
Promise.all(
  Object.keys(glob).map((key) => glob[key]().then((i) => i.default)),
).then((res) => {
  text('.imported-css-glob', JSON.stringify(res, null, 2))
})

// globEager
const globEager = import.meta.glob('./glob-import/*.css', {
  eager: true,
  query: '?inline',
})
text('.imported-css-globEager', JSON.stringify(globEager, null, 2))

import postcssSourceInput from './postcss-source-input.css?inline&query=foo'
text('.postcss-source-input', postcssSourceInput)

// The file is jsfile.css.js, and we should be able to import it without extension
import jsFileMessage from './jsfile.css'
text('.jsfile-css-js', jsFileMessage)

import '#alias'
import aliasContent from '#alias?inline'
text('.aliased-content', aliasContent)
import aliasModule from '#alias-module'
document
  .querySelector('.aliased-module')
  .classList.add(aliasModule.aliasedModule)

import './unsupported.css'

import './async/index'

import('./same-name/sub1/sub')
import('./same-name/sub2/sub')

import './imports-imports-field.css'



================================================
FILE: playground/css/manual-chunk.css
================================================
.manual-chunk {
  color: blue;
}



================================================
FILE: playground/css/minify.css
================================================
.test-minify {
  color: rgba(255, 255, 0, 0.7);
}



================================================
FILE: playground/css/mod.module.css
================================================
.apply-color {
  color: turquoise;
}



================================================
FILE: playground/css/mod.module.scss
================================================
.apply-color {
  color: orangered;
}



================================================
FILE: playground/css/package.json
================================================
{
  "name": "@vitejs/test-css",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview",
    "dev:relative-base": "vite --config ./vite.config-relative-base.js dev",
    "build:relative-base": "vite --config ./vite.config-relative-base.js build",
    "preview:relative-base": "vite --config ./vite.config-relative-base.js preview",
    "dev:no-css-minify": "vite --config ./vite.config-no-css-minify.js dev",
    "build:no-css-minify": "vite --config ./vite.config-no-css-minify.js build",
    "preview:no-css-minify": "vite --config ./vite.config-no-css-minify.js preview"
  },
  "devDependencies": {
    "@vitejs/test-css-dep": "link:./css-dep",
    "@vitejs/test-css-dep-exports": "link:./css-dep-exports",
    "@vitejs/test-css-js-dep": "file:./css-js-dep",
    "@vitejs/test-css-proxy-dep": "file:./css-proxy-dep",
    "@vitejs/test-scss-proxy-dep": "file:./scss-proxy-dep",
    "less": "^4.4.0",
    "lightningcss": "^1.30.1",
    "postcss-nested": "^7.0.2",
    "sass": "^1.90.0",
    "stylus": "^0.64.0",
    "sugarss": "^5.0.1",
    "tinyglobby": "^0.2.14"
  },
  "imports": {
    "#imports": "./imports-field.css"
  }
}



================================================
FILE: playground/css/postcss-inject-url.css
================================================
@inject-url;



================================================
FILE: playground/css/postcss-source-input.css
================================================
@source-input;



================================================
FILE: playground/css/postcss.config.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { globSync } from 'tinyglobby'
import { normalizePath } from 'vite'
import postcssNested from 'postcss-nested'

export default {
  plugins: [postcssNested, testDirDep, testSourceInput, testInjectUrl],
}

/**
 * A plugin for testing the `dir-dependency` message handling.
 */
function testDirDep() {
  return {
    postcssPlugin: 'dir-dep',
    AtRule(atRule, { result, Comment }) {
      if (atRule.name === 'test') {
        const pattern = normalizePath(
          path.resolve(path.dirname(result.opts.from), './glob-dep/**/*.css'),
        )
        const files = globSync(pattern, { expandDirectories: false })
        const text = files.map((f) => fs.readFileSync(f, 'utf-8')).join('\n')
        atRule.parent.insertAfter(atRule, text)
        atRule.remove()

        result.messages.push({
          type: 'dir-dependency',
          plugin: 'dir-dep',
          dir: './glob-dep',
          glob: '*.css',
          parent: result.opts.from,
        })

        result.messages.push({
          type: 'dir-dependency',
          plugin: 'dir-dep',
          dir: './glob-dep/nested (dir)', // includes special characters in glob
          glob: '*.css',
          parent: result.opts.from,
        })
      }
    },
  }
}
testDirDep.postcss = true

function testSourceInput() {
  return {
    postcssPlugin: 'source-input',
    AtRule(atRule) {
      if (atRule.name === 'source-input') {
        atRule.after(
          `.source-input::before { content: ${JSON.stringify(
            atRule.source.input.from,
          )}; }`,
        )
        atRule.remove()
      }
    },
  }
}
testSourceInput.postcss = true

function testInjectUrl() {
  return {
    postcssPlugin: 'inject-url',
    Once(root, { Rule }) {
      root.walkAtRules('inject-url', (atRule) => {
        const rule = new Rule({
          selector: '.inject-url',
          source: atRule.source,
        })
        rule.append({
          prop: 'background',
          value: "url('=/ok.png')",
          source: atRule.source,
        })
        atRule.after(rule)
        atRule.remove()
      })
    },
  }
}
testInjectUrl.postcss = true



================================================
FILE: playground/css/raw-imported.css
================================================
.raw {
  /* should not be transformed by postcss */
  &-imported {
    color: yellow;
  }
}



================================================
FILE: playground/css/sass.scss
================================================
@use '=/nested'; // alias + custom index resolving -> /nested/_index.scss
@use '=/nested/partial'; // sass convention: omitting leading _ for partials
@use './nested/relative'; // relative path
@use '@vitejs/test-css-dep'; // package w/ sass entry points
@use '@vitejs/test-css-dep-exports'; // package with a sass export mapping
@use '@vitejs/test-scss-proxy-dep'; // package with a sass proxy import
@use 'virtual-dep'; // virtual file added through importer
@use '=/pkg-dep'; // package w/out sass field
@use '=/weapp.wxss'; // wxss file
@use 'virtual-file-absolute';
@use '=/scss-dir/main.scss'; // "./dir" reference from vite custom importer
@use '=replace/nested/replacement-alias.scss';

.sass {
  /* injected via vite.config.js */
  color: $injectedColor;
}



================================================
FILE: playground/css/stylus.styl
================================================
@import './nested/nested'

$color ?= blue

.stylus
  color $color

.stylus-additional-data
  /* injected via vite.config.js */
  color $injectedColor

.stylus-options-define-var
  /* defined in vite.config.js */
  color $definedColor

.stylus-options-define-func
  /* defined in vite.config.js */
  color definedFunction()



================================================
FILE: playground/css/sugarss.sss
================================================
@import '=/nested/nested.sss'

.sugarss
  color: blue



================================================
FILE: playground/css/unsupported.css
================================================
.unsupported {
  overflow-x: hidden;
}



================================================
FILE: playground/css/url-imported.css
================================================
.url {
  /* should be transformed by postcss */
  &-imported-css {
    color: yellow;
  }
}



================================================
FILE: playground/css/vite.config-lightningcss.js
================================================
import { defineConfig } from 'vite'
import { composeVisitors } from 'lightningcss'
import baseConfig from './vite.config.js'
import {
  nestedLikePlugin,
  testDirDep,
  testInjectUrl,
  testSourceInput,
} from './lightningcss-plugins'

export default defineConfig({
  ...baseConfig,
  css: {
    ...baseConfig.css,
    transformer: 'lightningcss',
    lightningcss: {
      cssModules: {
        pattern: '[name]__[local]___[hash]',
      },
      visitor: composeVisitors([
        nestedLikePlugin(),
        testDirDep(),
        testSourceInput(),
        testInjectUrl(),
      ]),
    },
  },
  cacheDir: 'node_modules/.vite-no-css-minify',
})



================================================
FILE: playground/css/vite.config-no-css-minify.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

export default defineConfig({
  ...baseConfig,
  build: {
    ...baseConfig.build,
    outDir: 'dist/no-css-minify',
    minify: true,
    cssMinify: false,
  },
  cacheDir: 'node_modules/.vite-no-css-minify',
})



================================================
FILE: playground/css/vite.config-relative-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

export default defineConfig(({ isPreview }) => ({
  ...baseConfig,
  base: !isPreview ? './' : '/relative-base/', // relative base to make dist portable
  build: {
    ...baseConfig.build,
    outDir: 'dist/relative-base',
    watch: null,
    minify: false,
    assetsInlineLimit: 0,
    rollupOptions: {
      output: {
        entryFileNames: 'entries/[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        assetFileNames: 'other-assets/[name]-[hash][extname]',
      },
    },
  },
  cacheDir: 'node_modules/.vite-relative-base',
}))



================================================
FILE: playground/css/vite.config-same-file-name.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

export default defineConfig({
  ...baseConfig,
  build: {
    ...baseConfig.build,
    outDir: 'dist/same-file-name',
    rollupOptions: {
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].[hash].js',
        assetFileNames: '[name].[ext]',
      },
    },
  },
})



================================================
FILE: playground/css/vite.config-sass-modern-compiler-build.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: 'dist/sass-modern-compiler-build',
    rollupOptions: {
      input: {
        entry1: path.join(
          import.meta.dirname,
          'sass-modern-compiler-build/entry1.scss',
        ),
        entry2: path.join(
          import.meta.dirname,
          'sass-modern-compiler-build/entry2.scss',
        ),
      },
    },
  },
})



================================================
FILE: playground/css/vite.config.js
================================================
import path from 'node:path'
import { pathToFileURL } from 'node:url'
import stylus from 'stylus'
import { defineConfig } from 'vite'

// trigger scss bug: https://github.com/sass/dart-sass/issues/710
// make sure Vite handles safely
// @ts-expect-error refer to https://github.com/vitejs/vite/pull/11079
globalThis.window = {}
// @ts-expect-error refer to https://github.com/vitejs/vite/pull/11079
globalThis.location = new URL('http://localhost/')

export default defineConfig({
  plugins: [
    {
      // Emulate a UI framework component where a framework module would import
      // scoped CSS files that should treeshake if the default export is not used.
      name: 'treeshake-scoped-css',
      enforce: 'pre',
      async resolveId(id, importer) {
        if (!importer || !id.endsWith('-scoped.css')) return

        const resolved = await this.resolve(id, importer)
        if (!resolved) return

        return {
          ...resolved,
          meta: {
            vite: {
              cssScopeTo: [
                importer,
                resolved.id.includes('barrel') ? undefined : 'default',
              ],
            },
          },
        }
      },
    },
  ],
  build: {
    cssTarget: 'chrome61',
    rollupOptions: {
      input: {
        index: path.resolve(__dirname, './index.html'),
        treeshakeScoped: path.resolve(
          __dirname,
          './treeshake-scoped/index.html',
        ),
        empty: path.resolve(__dirname, './empty.css'),
      },
      output: {
        manualChunks(id) {
          if (id.includes('manual-chunk.css')) {
            return 'dir/dir2/manual-chunk'
          }
        },
      },
    },
  },
  esbuild: {
    logOverride: {
      'unsupported-css-property': 'silent',
    },
  },
  resolve: {
    alias: [
      { find: '=', replacement: __dirname },
      { find: /^=replace\/(.*)/, replacement: `${__dirname}/$1` },
      { find: 'spacefolder', replacement: __dirname + '/folder with space' },
      { find: '#alias', replacement: __dirname + '/aliased/foo.css' },
      {
        find: '#alias?inline',
        replacement: __dirname + '/aliased/foo.css?inline',
      },
      {
        find: '#alias-module',
        replacement: __dirname + '/aliased/bar.module.css',
      },
    ],
  },
  css: {
    modules: {
      generateScopedName: '[name]__[local]___[hash:base64:5]',

      // example of how getJSON can be used to generate
      // typescript typings for css modules class names

      // getJSON(cssFileName, json, _outputFileName) {
      //   let typings = 'declare const classNames: {\n'
      //   for (let className in json) {
      //     typings += `    "${className}": string;\n`
      //   }
      //   typings += '};\n'
      //   typings += 'export default classNames;\n'
      //   const { join, dirname, basename } = require('path')
      //   const typingsFile = join(
      //     dirname(cssFileName),
      //     basename(cssFileName) + '.d.ts'
      //   )
      //   require('fs').writeFileSync(typingsFile, typings)
      // },
    },
    preprocessorOptions: {
      scss: {
        additionalData: `$injectedColor: orange;`,
        importers: [
          {
            canonicalize(url) {
              return url === 'virtual-dep' || url.endsWith('.wxss')
                ? new URL('custom-importer:virtual-dep')
                : null
            },
            load() {
              return {
                contents: ``,
                syntax: 'scss',
              }
            },
          },
          {
            canonicalize(url) {
              return url === 'virtual-file-absolute'
                ? new URL('custom-importer:virtual-file-absolute')
                : null
            },
            load() {
              return {
                contents: `@use "${pathToFileURL(path.join(import.meta.dirname, 'file-absolute.scss')).href}"`,
                syntax: 'scss',
              }
            },
          },
        ],
      },
      styl: {
        additionalData: `$injectedColor ?= orange`,
        imports: [
          './options/relative-import.styl',
          path.join(__dirname, 'options/absolute-import.styl'),
        ],
        define: {
          $definedColor: new stylus.nodes.RGBA(51, 197, 255, 1),
          definedFunction: () => new stylus.nodes.RGBA(255, 0, 98, 1),
        },
      },
    },
    preprocessorMaxWorkers: true,
  },
})



================================================
FILE: playground/css/weapp.wxss
================================================
this is not css



================================================
FILE: playground/css/__tests__/css.spec.ts
================================================
import { tests } from './tests'

tests(false)



================================================
FILE: playground/css/__tests__/sass-tests.ts
================================================
import { expect, test } from 'vitest'
import { editFile, getBg, getColor, isBuild, page, viteTestUrl } from '~utils'

export const sassTest = () => {
  test('sass', async () => {
    const imported = await page.$('.sass')
    const atImport = await page.$('.sass-at-import')
    const atImportAlias = await page.$('.sass-at-import-alias')
    const atImportRelative = await page.$('.sass-at-import-relative')
    const atImportReplacementAlias = await page.$(
      '.sass-at-import-replacement-alias',
    )
    const urlStartsWithVariable = await page.$('.sass-url-starts-with-variable')
    const urlStartsWithVariableInterpolation1 = await page.$(
      '.sass-url-starts-with-interpolation1',
    )
    const urlStartsWithVariableInterpolation2 = await page.$(
      '.sass-url-starts-with-interpolation2',
    )
    const urlStartsWithVariableConcat = await page.$(
      '.sass-url-starts-with-variable-concat',
    )
    const urlStartsWithFunctionCall = await page.$(
      '.sass-url-starts-with-function-call',
    )
    const partialImport = await page.$('.sass-partial')

    expect(await getColor(imported)).toBe('orange')
    expect(await getColor(atImport)).toBe('olive')
    expect(await getBg(atImport)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportAlias)).toBe('olive')
    expect(await getBg(atImportAlias)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportRelative)).toBe('olive')
    expect(await getBg(atImportRelative)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportReplacementAlias)).toBe('olive')
    expect(await getBg(urlStartsWithVariable)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getBg(urlStartsWithVariableInterpolation1)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getBg(urlStartsWithVariableInterpolation2)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getBg(urlStartsWithVariableConcat)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getBg(urlStartsWithFunctionCall)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getColor(partialImport)).toBe('orchid')
    expect(await getColor(await page.$('.sass-file-absolute'))).toBe('orange')
    expect(await getColor(await page.$('.sass-dir-index'))).toBe('orange')
    expect(await getColor(await page.$('.sass-root-relative'))).toBe('orange')

    if (isBuild) return

    editFile('sass.scss', (code) =>
      code.replace('color: $injectedColor', 'color: red'),
    )
    await expect.poll(() => getColor(imported)).toBe('red')

    editFile('nested/_index.scss', (code) =>
      code.replace('color: olive', 'color: blue'),
    )
    await expect.poll(() => getColor(atImport)).toBe('blue')

    editFile('nested/_partial.scss', (code) =>
      code.replace('color: orchid', 'color: green'),
    )
    await expect.poll(() => getColor(partialImport)).toBe('green')
  })
}

export const sassModuleTests = (enableHmrTests = false) => {
  test('sass modules composes/from path resolving', async () => {
    const imported = await page.$('.path-resolved-modules-sass')
    expect(await getColor(imported)).toBe('orangered')

    // check if the generated CSS module class name is indeed using the
    // format specified in vite.config.js
    expect(await imported.getAttribute('class')).toMatch(
      /.composed-module__apply-color___[\w-]{5}/,
    )

    expect(await imported.getAttribute('class')).toMatch(
      /.composes-path-resolving-module__path-resolving-sass___[\w-]{5}/,
    )

    // @todo HMR is not working on this situation.
    // editFile('composed.module.scss', (code) =>
    //   code.replace('color: orangered', 'color: red')
    // )
    // await expect.poll(() => getColor(imported)).toMatch('red')
  })

  test('css modules w/ sass', async () => {
    const imported = await page.$('.modules-sass')
    expect(await getColor(imported)).toBe('orangered')
    expect(await imported.getAttribute('class')).toMatch(
      /.mod-module__apply-color___[\w-]{5}/,
    )

    if (isBuild) return

    editFile('mod.module.scss', (code) =>
      code.replace('color: orangered', 'color: blue'),
    )
    await expect.poll(() => getColor(imported)).toBe('blue')
  })
}

export const sassOtherTests = () => {
  test('@import dependency w/ sass entry', async () => {
    expect(await getColor('.css-dep-sass')).toBe('orange')
  })

  test('@import dependency w/ sass export mapping', async () => {
    expect(await getColor('.css-dep-exports-sass')).toBe('orange')
  })

  test('@import dependency w/out package scss', async () => {
    expect(await getColor('.sass-dep')).toBe('lavender')
  })
}



================================================
FILE: playground/css/__tests__/tests.ts
================================================
import { readFileSync } from 'node:fs'
import { expect, test } from 'vitest'
import { sassModuleTests, sassOtherTests, sassTest } from './sass-tests'
import {
  editFile,
  findAssetFile,
  getBg,
  getBgColor,
  getColor,
  isBuild,
  page,
  removeFile,
  serverLogs,
  viteTestUrl,
} from '~utils'

export const tests = (isLightningCSS: boolean) => {
  // note: tests should retrieve the element at the beginning of test and reuse it
  // in later assertions to ensure CSS HMR doesn't reload the page
  test('imported css', async () => {
    const glob = await page.textContent('.imported-css-glob')
    expect(glob).toContain('.dir-import')
    const globEager = await page.textContent('.imported-css-globEager')
    expect(globEager).toContain('.dir-import')
  })

  test('linked css', async () => {
    const linked = await page.$('.linked')
    const atImport = await page.$('.linked-at-import')

    expect(await getColor(linked)).toBe('blue')
    expect(await getColor(atImport)).toBe('red')

    if (isBuild) return

    editFile('linked.css', (code) => code.replace('color: blue', 'color: red'))
    await expect.poll(() => getColor(linked)).toBe('red')

    editFile('linked-at-import.css', (code) =>
      code.replace('color: red', 'color: blue'),
    )
    await expect.poll(() => getColor(atImport)).toBe('blue')
  })

  test('css import from js', async () => {
    const imported = await page.$('.imported')
    const atImport = await page.$('.imported-at-import')

    expect(await getColor(imported)).toBe('green')
    expect(await getColor(atImport)).toBe('purple')

    if (isBuild) return

    editFile('imported.css', (code) =>
      code.replace('color: green', 'color: red'),
    )
    await expect.poll(() => getColor(imported)).toBe('red')

    editFile('imported-at-import.css', (code) =>
      code.replace('color: purple', 'color: blue'),
    )
    await expect.poll(() => getColor(atImport)).toBe('blue')
  })

  test('css import asset with space', async () => {
    const importedWithSpace = await page.$('.import-with-space')

    expect(await getBg(importedWithSpace)).toMatch(/.*\/ok.*\.png/)
  })

  test('postcss config', async () => {
    const imported = await page.$('.postcss .nesting')
    expect(await getColor(imported)).toBe('pink')

    if (isBuild) return

    editFile('imported.css', (code) =>
      code.replace('color: pink', 'color: red'),
    )
    await expect.poll(() => getColor(imported)).toBe('red')
  })

  test('postcss plugin that injects url()', async () => {
    const imported = await page.$('.inject-url')
    // alias should be resolved
    expect(await getBg(imported)).toMatch(
      /localhost(?::\d+)?\/(?:assets\/)?ok.*\.png/,
    )
  })

  sassTest()

  test('less', async () => {
    const imported = await page.$('.less')
    const atImport = await page.$('.less-at-import')
    const atImportAlias = await page.$('.less-at-import-alias')
    const atImportUrlOmmer = await page.$('.less-at-import-url-ommer')
    const urlStartsWithVariable = await page.$('.less-url-starts-with-variable')
    const urlStartsWithInterpolation = await page.$(
      '.less-url-starts-with-interpolation',
    )

    expect(await getColor(imported)).toBe('blue')
    expect(await getColor(atImport)).toBe('darkslateblue')
    expect(await getBg(atImport)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportAlias)).toBe('darkslateblue')
    expect(await getBg(atImportAlias)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportUrlOmmer)).toBe('darkorange')
    expect(await getBg(urlStartsWithVariable)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )
    expect(await getBg(urlStartsWithInterpolation)).toMatch(
      isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
    )

    if (isBuild) return

    editFile('less.less', (code) => code.replace('@color: blue', '@color: red'))
    await expect.poll(() => getColor(imported)).toBe('red')

    editFile('nested/nested.less', (code) =>
      code.replace('color: darkslateblue', 'color: blue'),
    )
    await expect.poll(() => getColor(atImport)).toBe('blue')
  })

  test('less-plugin', async () => {
    const body = await page.$('.less-js-plugin')
    expect(await getBg(body)).toBe(
      'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjYGD4/x8AAwIB/8myre4AAAAASUVORK5CYII=")',
    )
  })

  test('stylus', async () => {
    const imported = await page.$('.stylus')
    const additionalData = await page.$('.stylus-additional-data')
    const relativeImport = await page.$('.stylus-import')
    const relativeImportAlias = await page.$('.stylus-import-alias')
    const optionsRelativeImport = await page.$(
      '.stylus-options-relative-import',
    )
    const optionsAbsoluteImport = await page.$(
      '.stylus-options-absolute-import',
    )
    const optionsDefineVar = await page.$('.stylus-options-define-var')
    const optionsDefineFunc = await page.$('.stylus-options-define-func')

    expect(await getColor(imported)).toBe('blue')
    expect(await getColor(additionalData)).toBe('orange')
    expect(await getColor(relativeImport)).toBe('darkslateblue')
    expect(await getColor(relativeImportAlias)).toBe('darkslateblue')
    expect(await getBg(relativeImportAlias)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(optionsRelativeImport)).toBe('green')
    expect(await getColor(optionsAbsoluteImport)).toBe('red')
    expect(await getColor(optionsDefineVar)).toBe('rgb(51, 197, 255)')
    expect(await getColor(optionsDefineFunc)).toBe('rgb(255, 0, 98)')

    if (isBuild) return

    editFile('stylus.styl', (code) =>
      code.replace('$color ?= blue', '$color ?= red'),
    )
    await expect.poll(() => getColor(imported)).toBe('red')

    editFile('nested/nested.styl', (code) =>
      code.replace('color darkslateblue', 'color blue'),
    )
    await expect.poll(() => getColor(relativeImport)).toBe('blue')
  })

  test('css modules', async () => {
    const imported = await page.$('.modules')
    expect(await getColor(imported)).toBe('turquoise')

    // check if the generated CSS module class name is indeed using the
    // format specified in vite.config.js
    expect(await imported.getAttribute('class')).toMatch(
      /.mod-module__apply-color___[\w-]{5}/,
    )

    if (isBuild) return

    editFile('mod.module.css', (code) =>
      code.replace('color: turquoise', 'color: red'),
    )
    await expect.poll(() => getColor(imported)).toBe('red')
  })

  test('css modules composes/from path resolving', async () => {
    const imported = await page.$('.path-resolved-modules-css')
    expect(await getColor(imported)).toBe('turquoise')

    // check if the generated CSS module class name is indeed using the
    // format specified in vite.config.js
    expect(await imported.getAttribute('class')).toMatch(
      /.composed-module__apply-color___[\w-]{5}/,
    )

    expect(await imported.getAttribute('class')).toMatch(
      /.composes-path-resolving-module__path-resolving-css___[\w-]{5}/,
    )

    // @todo HMR is not working on this situation.
    // editFile('composed.module.css', (code) =>
    //   code.replace('color: turquoise', 'color: red')
    // )
    // await expect.poll(() => getColor(imported)).toBe('red')
  })

  sassModuleTests()

  test('less modules composes/from path resolving', async () => {
    const imported = await page.$('.path-resolved-modules-less')
    expect(await getColor(imported)).toBe('blue')

    // check if the generated CSS module class name is indeed using the
    // format specified in vite.config.js
    expect(await imported.getAttribute('class')).toMatch(
      /.composed-module__apply-color___[\w-]{5}/,
    )

    expect(await imported.getAttribute('class')).toMatch(
      /.composes-path-resolving-module__path-resolving-less___[\w-]{5}/,
    )

    // @todo HMR is not working on this situation.
    // editFile('composed.module.scss', (code) =>
    //   code.replace('color: orangered', 'color: red')
    // )
    // await expect.poll(() => getColor(imported)).toBe('red')
  })

  test('inline css modules', async () => {
    const css = await page.textContent('.modules-inline')
    expect(css).toMatch(/\.inline-module__apply-color-inline___[\w-]{5}/)
  })

  test.runIf(isBuild)('@charset hoist', async () => {
    serverLogs.forEach((log) => {
      // no warning from esbuild css minifier
      expect(log).not.toMatch('"@charset" must be the first rule in the file')
    })
  })

  test('layers', async () => {
    expect(await getColor('.layers-blue')).toMatch('blue')
    expect(await getColor('.layers-green')).toMatch('green')
  })

  test('@import dependency w/ style entry', async () => {
    expect(await getColor('.css-dep')).toBe('purple')
  })

  test('@import dependency w/ style export mapping', async () => {
    expect(await getColor('.css-dep-exports')).toBe('purple')
  })

  test('@import dependency that @import another dependency', async () => {
    expect(await getColor('.css-proxy-dep')).toBe('purple')
  })

  test('@import scss dependency that has @import with a css extension pointing to another dependency', async () => {
    expect(await getColor('.scss-proxy-dep')).toBe('purple')
  })

  sassOtherTests()

  test('async chunk', async () => {
    const el = await page.$('.async')
    expect(await getColor(el)).toBe('teal')

    if (isBuild) {
      // assert that the css is extracted into its own file instead of in the
      // main css file
      expect(findAssetFile(/index-[-\w]{8}\.css$/)).not.toMatch('teal')
      expect(findAssetFile(/async-[-\w]{8}\.css$/)).toMatch(
        '.async{color:teal}',
      )
    } else {
      // test hmr
      editFile('async.css', (code) =>
        code.replace('color: teal', 'color: blue'),
      )
      await expect.poll(() => getColor(el)).toBe('blue')
    }
  })

  test('treeshaken async chunk', async () => {
    if (isBuild) {
      // should be absent in prod
      expect(
        await page.evaluate(() => {
          return document.querySelector('.async-treeshaken')
        }),
      ).toBeNull()
      // assert that the css is not present anywhere
      expect(findAssetFile(/\.css$/)).not.toMatch('plum')
      expect(findAssetFile(/index-[-\w]+\.js$/)).not.toMatch(
        '.async{color:plum}',
      )
      expect(findAssetFile(/async-[-\w]+\.js$/)).not.toMatch(
        '.async{color:plum}',
      )
      // should have no chunk!
      expect(findAssetFile(/async-treeshaken/)).toBeUndefined()
    } else {
      // should be present in dev
      const el = await page.$('.async-treeshaken')
      editFile('async-treeshaken.css', (code) =>
        code.replace('color: plum', 'color: blue'),
      )
      await expect.poll(() => getColor(el)).toBe('blue')
    }
  })

  test('PostCSS dir-dependency', async () => {
    const el1 = await page.$('.dir-dep')
    const el2 = await page.$('.dir-dep-2')
    const el3 = await page.$('.dir-dep-3')

    expect(await getColor(el1)).toBe('grey')
    expect(await getColor(el2)).toBe('grey')
    expect(await getColor(el3)).toBe('grey')

    // NOTE: lightningcss does not support registering dependencies in plugins
    if (!isBuild && !isLightningCSS) {
      editFile('glob-dep/foo.css', (code) =>
        code.replace('color: grey', 'color: blue'),
      )
      await expect.poll(() => getColor(el1)).toBe('blue')
      expect(await getColor(el2)).toBe('grey')

      editFile('glob-dep/bar.css', (code) =>
        code.replace('color: grey', 'color: red'),
      )
      await expect.poll(() => getColor(el2)).toBe('red')
      expect(await getColor(el1)).toBe('blue')

      editFile('glob-dep/nested (dir)/baz.css', (code) =>
        code.replace('color: grey', 'color: green'),
      )
      await expect.poll(() => getColor(el3)).toBe('green')
      expect(await getColor(el1)).toBe('blue')
      expect(await getColor(el2)).toBe('red')

      // test add/remove
      removeFile('glob-dep/bar.css')
      await expect.poll(() => getColor(el2)).toBe('black')
    }
  })

  test('import dependency includes css import', async () => {
    expect(await getColor('.css-js-dep')).toBe('green')
    expect(await getColor('.css-js-dep-module')).toBe('green')
  })

  test('URL separation', async () => {
    const urlSeparated = await page.$('.url-separated')
    const baseUrl = 'url(images/dog.webp)'
    const cases = new Array(5)
      .fill('')
      .flatMap((_, i) =>
        [',', ' ,', ', ', ' , '].map(
          (sep) =>
            `background-image:${new Array(i + 1).fill(baseUrl).join(sep)};`,
        ),
      )

    // Insert the base case
    cases.unshift('background-image:url(images/cat.webp),url(images/dog.webp)')

    for (const [c, i] of cases.map((c, i) => [c, i]) as [string, number][]) {
      // Replace the previous case
      if (i > 0)
        editFile('imported.css', (code) => code.replace(cases[i - 1], c))

      expect(await getBg(urlSeparated)).toMatch(
        /^url\(.+\)(?:\s*,\s*url\(.+\))*$/,
      )
    }
  })

  test('inlined', async () => {
    // should not insert css
    expect(await getColor('.inlined')).toBe('black')
  })

  test('inlined-code', async () => {
    const code = await page.textContent('.inlined-code')
    // should resolve assets
    expect(code).toContain('background:')
    expect(code).not.toContain('__VITE_ASSET__')

    if (isBuild) {
      expect(code.trim()).not.toContain('\n') // check minified
    }
  })

  test('minify css', async () => {
    if (!isBuild) {
      return
    }

    // should keep the rgba() syntax
    const cssFile = findAssetFile(/index-[-\w]+\.css$/)
    expect(cssFile).toMatch('rgba(')
    expect(cssFile).not.toMatch('#ffff00b3')
  })

  test('?url', async () => {
    expect(await getColor('.url-imported-css')).toBe('yellow')
  })

  test('?raw', async () => {
    const rawImportCss = await page.$('.raw-imported-css')

    expect(await rawImportCss.textContent()).toBe(
      readFileSync(require.resolve('../raw-imported.css'), 'utf-8'),
    )

    if (!isBuild) {
      editFile('raw-imported.css', (code) =>
        code.replace('color: yellow', 'color: blue'),
      )
      await expect
        .poll(() => page.textContent('.raw-imported-css'))
        .toMatch('color: blue')
    }
  })

  test('import css in less', async () => {
    expect(await getColor('.css-in-less')).toBe('yellow')
    expect(await getColor('.css-in-less-2')).toBe('blue')
  })

  test("relative path rewritten in Less's data-uri", async () => {
    // relative path passed to Less's data-uri is rewritten to absolute,
    // the Less inlines it
    expect(await getBg('.form-box-data-uri')).toMatch(
      /^url\("data:image\/svg\+xml,%3Csvg/,
    )
  })

  test('PostCSS source.input.from includes query', async () => {
    const code = await page.textContent('.postcss-source-input')
    // should resolve assets
    expect(code).toContain('/postcss-source-input.css?inline&query=foo')
  })

  test('aliased css has content', async () => {
    expect(await getColor('.aliased')).toBe('blue')
    // skipped: currently not supported see #8936
    // expect(await page.textContent('.aliased-content')).toMatch('.aliased')
    expect(await getColor('.aliased-module')).toBe('blue')
  })

  test('resolve imports field in CSS', async () => {
    expect(await getColor('.imports-field')).toBe('red')
  })

  test.runIf(isBuild)(
    'warning can be suppressed by esbuild.logOverride',
    () => {
      serverLogs.forEach((log) => {
        // no warning from esbuild css minifier
        expect(log).not.toMatch('unsupported-css-property')
      })
    },
  )

  test('sugarss', async () => {
    const imported = await page.$('.sugarss')
    const atImport = await page.$('.sugarss-at-import')
    const atImportAlias = await page.$('.sugarss-at-import-alias')

    expect(await getColor(imported)).toBe('blue')
    expect(await getColor(atImport)).toBe('darkslateblue')
    expect(await getBg(atImport)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )
    expect(await getColor(atImportAlias)).toBe('darkslateblue')
    expect(await getBg(atImportAlias)).toMatch(
      isBuild ? /base64/ : '/nested/icon.png',
    )

    if (isBuild) return

    editFile('sugarss.sss', (code) =>
      code.replace('color: blue', 'color: coral'),
    )
    await expect.poll(() => getColor(imported)).toBe('coral')

    editFile('nested/nested.sss', (code) =>
      code.replace('color: darkslateblue', 'color: blue'),
    )
    await expect.poll(() => getColor(atImport)).toBe('blue')
  })

  // NOTE: the match inline snapshot should generate by build mode
  test('async css order', async () => {
    await expect.poll(() => getColor('.async-green')).toBe('green')
    await expect.poll(() => getColor('.async-blue')).toBe('blue')
  })

  test('async css order with css modules', async () => {
    await expect.poll(() => getColor('.modules-pink')).toBe('pink')
  })

  test('@import scss', async () => {
    expect(await getColor('.at-import-scss')).toBe('red')
  })

  test.runIf(isBuild)('manual chunk path', async () => {
    // assert that the manual-chunk css is output in the directory specified in manualChunk (#12072)
    expect(
      findAssetFile(
        /manual-chunk-[-\w]{8}\.css$/,
        undefined,
        'assets/dir/dir2',
      ),
    ).not.toBeUndefined()
  })

  test.runIf(isBuild)('CSS modules should be treeshaken if not used', () => {
    const css = findAssetFile(/\.css$/, undefined, undefined, true)
    expect(css).not.toContain('treeshake-module-b')
  })

  test.runIf(isBuild)('Scoped CSS via cssScopeTo should be treeshaken', () => {
    const css = findAssetFile(/\.css$/, undefined, undefined, true)
    expect(css).not.toMatch(/\btreeshake-scoped-b\b/)
    expect(css).not.toMatch(/\btreeshake-scoped-c\b/)
  })

  test('Scoped CSS should have a correct order', async () => {
    await page.goto(viteTestUrl + '/treeshake-scoped/')
    expect(await getColor('.treeshake-scoped-order')).toBe('red')
    expect(await getBgColor('.treeshake-scoped-order')).toBe('blue')
  })

  test.runIf(isBuild)(
    'empty CSS files should generate .css assets, not .js assets',
    () => {
      // Check that empty CSS entry point generates a .css file, not a .js file
      expect(findAssetFile(/empty-[-\w]{8}\.css$/)).not.toBeUndefined()
      expect(findAssetFile(/empty-[-\w]{8}\.js$/)).toBeUndefined()
    },
  )
}



================================================
FILE: playground/css/__tests__/lightningcss/lightningcss.spec.ts
================================================
// NOTE: a separate directory from `playground/css` is created by playground/vitestGlobalSetup.ts
import { tests } from '../tests'

tests(true)



================================================
FILE: playground/css/__tests__/no-css-minify/css-no-css-minify.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { findAssetFile, isBuild } from '~utils'

describe.runIf(isBuild)('no css minify', () => {
  test('js minified but css not minified', () => {
    expect(findAssetFile(/index-[-\w]+\.js$/, 'no-css-minify')).not.toMatch(
      '(function polyfill() {',
    )
    expect(findAssetFile(/index-[-\w]+\.css$/, 'no-css-minify')).toMatch(`\
.test-minify {
  color: rgba(255, 255, 0, 0.7);
}`)
  })
})



================================================
FILE: playground/css/__tests__/postcss-plugins-different-dir/css-postcss-plugins-different-dir.spec.ts
================================================
import path from 'node:path'
import { createServer } from 'vite'
import { expect, test } from 'vitest'
import { getBgColor, getColor, isServe, page, ports } from '~utils'

// Regression test for https://github.com/vitejs/vite/issues/4000
test.runIf(isServe)('postcss plugins in different dir', async () => {
  const port = ports['css/postcss-plugins-different-dir']
  const server = await createServer({
    root: path.join(__dirname, '..', '..', '..', 'tailwind'),
    logLevel: 'silent',
    server: {
      port,
      strictPort: true,
    },
    build: {
      // skip transpilation during tests to make it faster
      target: 'esnext',
    },
  })
  await server.listen()
  try {
    await page.goto(`http://localhost:${port}`)
    const tailwindStyle = page.locator('#tailwind-style')
    expect(await getBgColor(tailwindStyle)).toBe('oklch(0.936 0.032 17.717)')
    expect(await getColor(tailwindStyle)).toBe('rgb(136, 136, 136)')
  } finally {
    await server.close()
  }
})



================================================
FILE: playground/css/__tests__/postcss-plugins-different-dir/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

// The server is started in the test, so we need to have a custom serve
// function or a default server will be created
export async function serve(): Promise<{ close(): Promise<void> }> {
  return {
    close: () => Promise.resolve(),
  }
}



================================================
FILE: playground/css/__tests__/same-file-name/css-same-file-name.spec.ts
================================================
import { beforeEach, describe, expect, test } from 'vitest'
import { findAssetFile, isBuild, startDefaultServe } from '~utils'

beforeEach(async () => {
  await startDefaultServe()
})

for (let i = 0; i < 5; i++) {
  describe.runIf(isBuild)('css files has same basename', () => {
    test('emit file name should consistent', () => {
      expect(findAssetFile('sub.css', 'same-file-name', '.')).toMatch(
        '.sub1-sub',
      )
      expect(findAssetFile('sub2.css', 'same-file-name', '.')).toMatch(
        '.sub2-sub',
      )
    })
  })
}



================================================
FILE: playground/css/__tests__/sass-modern-compiler-build/sass-modern-compiler.spec.ts
================================================
import { expect, test } from 'vitest'
import { findAssetFile, isBuild } from '~utils'

test.runIf(isBuild)('sass modern compiler build multiple entries', () => {
  expect(findAssetFile(/entry1/, 'sass-modern-compiler-build'))
    .toMatchInlineSnapshot(`
    ".entry1{color:red}
    "
  `)
  expect(findAssetFile(/entry2/, 'sass-modern-compiler-build'))
    .toMatchInlineSnapshot(`
    ".entry2{color:#00f}
    "
  `)
})



================================================
FILE: playground/css/aliased/bar.module.css
================================================
.aliasedModule {
  color: blue;
}



================================================
FILE: playground/css/aliased/foo.css
================================================
.aliased {
  color: blue;
}



================================================
FILE: playground/css/async/async-1.css
================================================
.async-blue {
  color: blue;
}



================================================
FILE: playground/css/async/async-1.js
================================================
import { createButton } from './base'
import './async-1.css'

createButton('async-blue')



================================================
FILE: playground/css/async/async-2.css
================================================
.async-green {
  color: green;
}



================================================
FILE: playground/css/async/async-2.js
================================================
import { createButton } from './base'
import './async-2.css'

createButton('async-green')



================================================
FILE: playground/css/async/async-3.js
================================================
import { createButton } from './base'
import styles from './async-3.module.css'

createButton(`${styles['async-pink']} modules-pink`)



================================================
FILE: playground/css/async/async-3.module.css
================================================
.async-pink {
  color: pink;
}



================================================
FILE: playground/css/async/base.css
================================================
.btn {
  color: black;
}



================================================
FILE: playground/css/async/base.js
================================================
import './base.css'

export function createButton(className) {
  const button = document.createElement('button')
  button.className = `btn ${className}`
  document.body.appendChild(button)
  button.textContent = `button ${getComputedStyle(button).color}`
}



================================================
FILE: playground/css/async/index.js
================================================
import('./async-1.js')
import('./async-2.js')
import('./async-3.js')



================================================
FILE: playground/css/css-dep/index.css
================================================
.css-dep {
  color: purple;
}



================================================
FILE: playground/css/css-dep/index.js
================================================
throw new Error('should not be imported')



================================================
FILE: playground/css/css-dep/index.scss
================================================
.css-dep-sass {
  color: orange;
}



================================================
FILE: playground/css/css-dep/index.styl
================================================
.css-dep-stylus
  color red



================================================
FILE: playground/css/css-dep/package.json
================================================
{
  "name": "@vitejs/test-css-dep",
  "private": true,
  "version": "1.0.0",
  "main": "index.js",
  "style": "index.css",
  "sass": "index.scss"
}



================================================
FILE: playground/css/css-dep-exports/index.js
================================================
throw new Error('should not be imported')



================================================
FILE: playground/css/css-dep-exports/package.json
================================================
{
  "name": "@vitejs/test-css-dep-exports",
  "private": true,
  "version": "1.0.0",
  "exports": {
    ".": {
      "sass": "./style.scss",
      "style": "./style.css",
      "import": "./index.js"
    }
  }
}



================================================
FILE: playground/css/css-dep-exports/style.css
================================================
.css-dep-exports {
  color: purple;
}



================================================
FILE: playground/css/css-dep-exports/style.scss
================================================
.css-dep-exports-sass {
  color: orange;
}



================================================
FILE: playground/css/css-js-dep/bar.module.css
================================================
.cssJsDepModule {
  color: green;
}



================================================
FILE: playground/css/css-js-dep/foo.css
================================================
.css-js-dep {
  color: green;
}



================================================
FILE: playground/css/css-js-dep/index.js
================================================
import './foo.css'
import barModuleClasses from './bar.module.css'

export { barModuleClasses }



================================================
FILE: playground/css/css-js-dep/package.json
================================================
{
  "name": "@vitejs/test-css-js-dep",
  "private": true,
  "type": "module",
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/css/css-proxy-dep/index.css
================================================
@import '@vitejs/test-css-proxy-dep-nested';



================================================
FILE: playground/css/css-proxy-dep/package.json
================================================
{
  "name": "@vitejs/test-css-proxy-dep",
  "private": true,
  "version": "1.0.0",
  "style": "index.css",
  "dependencies": {
    "@vitejs/test-css-proxy-dep-nested": "file:../css-proxy-dep-nested"
  }
}



================================================
FILE: playground/css/css-proxy-dep-nested/index.css
================================================
.css-proxy-dep {
  color: purple;
}



================================================
FILE: playground/css/css-proxy-dep-nested/package.json
================================================
{
  "name": "@vitejs/test-css-proxy-dep-nested",
  "private": true,
  "version": "1.0.0",
  "style": "index.css"
}



================================================
FILE: playground/css/folder with space/space.css
================================================
.import-with-space {
  color: green;
  background: url(spacefolder/ok.png);
  background-position: center;
}



================================================
FILE: playground/css/glob-dep/bar.css
================================================
.dir-dep-2 {
  color: grey;
}



================================================
FILE: playground/css/glob-dep/foo.css
================================================
.dir-dep {
  color: grey;
}



================================================
FILE: playground/css/glob-dep/nested (dir)/baz.css
================================================
.dir-dep-3 {
  color: grey;
}



================================================
FILE: playground/css/glob-import/bar.css
================================================
.dir-import-2 {
  color: grey;
}



================================================
FILE: playground/css/glob-import/foo.css
================================================
.dir-import {
  color: grey;
}



================================================
FILE: playground/css/layered/blue.css
================================================
@media screen {
  .layers-blue {
    color: blue;
  }
}



================================================
FILE: playground/css/layered/green.css
================================================
@media screen {
  .layers-green {
    color: green;
  }
}



================================================
FILE: playground/css/layered/index.css
================================================
@layer base;

@import './blue.css' layer;
@import './green.css' layer;

@layer base {
  .layers-blue {
    color: black;
  }
  .layers-green {
    color: black;
  }
}



================================================
FILE: playground/css/less/ommer.less
================================================
.less-at-import-url-ommer {
  color: darkorange;
}



================================================
FILE: playground/css/less/components/form.less
================================================
@import url('../../less/ommer.less');

.form-box-data-uri {
  // data-uri() calls with relative paths should be replaced just like urls.
  background-image: data-uri('../images/backgrounds/form-select.svg');
}



================================================
FILE: playground/css/less-plugin/test.js
================================================
functions.add('test', function test() {
  const transparentPng =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjYGD4/x8AAwIB/8myre4AAAAASUVORK5CYII='
  return `url(${transparentPng})`
})



================================================
FILE: playground/css/nested/_index.scss
================================================
@use 'sass:string';
@use '/nested/root-relative'; // root relative path
@use '../weapp.wxss'; // test user's custom importer in a file loaded by vite's custom importer

@import './css-in-scss.css';

.sass-at-import {
  color: olive;
  background: url(./icon.png) 10px no-repeat;
}

.sass-at-import-alias {
  color: olive;
  background: url(=/nested/icon.png) 10px no-repeat;
}

$var: '/ok.png';
.sass-url-starts-with-variable {
  background: url($var);
  background-position: center;
}

.sass-url-starts-with-interpolation1 {
  background: url(#{$var});
  background-position: center;
}

.sass-url-starts-with-interpolation2 {
  background: url('#{$var}');
  background-position: center;
}

$var-c1: '/ok';
$var-c2: '.png';
.sass-url-starts-with-variable-concat {
  background: url($var-c1 + $var-c2);
  background-position: center;
}

$var2: '/OK.PNG';
.sass-url-starts-with-function-call {
  background: url(string.to-lower-case($var2));
  background-position: center;
}



================================================
FILE: playground/css/nested/_partial.scss
================================================
.sass-partial {
  color: orchid;
}



================================================
FILE: playground/css/nested/css-in-less-2.less
================================================
.css-in-less-2 {
  color: blue;
}



================================================
FILE: playground/css/nested/css-in-less.css
================================================
.css-in-less {
  color: yellow;
}



================================================
FILE: playground/css/nested/css-in-less.less
================================================
@import url('./css-in-less.css');
@import './css-in-less.css';

@import './css-in-less-2.less';



================================================
FILE: playground/css/nested/css-in-scss.css
================================================
.css-in-scss {
  color: orange;
}



================================================
FILE: playground/css/nested/nested.less
================================================
.less-at-import {
  color: darkslateblue;
  background: url(./icon.png) 10px no-repeat;
}

.less-at-import-alias {
  color: darkslateblue;
  background: url(=/nested/icon.png) 10px no-repeat;
}

@var: '/ok.png';
.less-url-starts-with-variable {
  background: url(@var);
  background-position: center;
}

.less-url-starts-with-interpolation {
  background: url('@{var}');
  background-position: center;
}



================================================
FILE: playground/css/nested/nested.sss
================================================
.sugarss-at-import
  color: darkslateblue
  background: url(./icon.png) 10px no-repeat


.sugarss-at-import-alias
  color: darkslateblue
  background: url(=/nested/icon.png) 10px no-repeat



================================================
FILE: playground/css/nested/nested.styl
================================================
.stylus-import
  color darkslateblue

.stylus-import-alias
  color darkslateblue
  background url('=/nested/icon.png') 10px no-repeat



================================================
FILE: playground/css/nested/relative.scss
================================================
.sass-at-import-relative {
  color: olive;
  background: url(./icon.png) 10px no-repeat;
}



================================================
FILE: playground/css/nested/replacement-alias.scss
================================================
.sass-at-import-replacement-alias {
  color: olive;
}



================================================
FILE: playground/css/nested/root-relative.scss
================================================
.sass-root-relative {
  color: orange;
}



================================================
FILE: playground/css/options/absolute-import.styl
================================================
.stylus-options-absolute-import
  /* imported via vite.config.js */
  color red



================================================
FILE: playground/css/options/relative-import.styl
================================================
.stylus-options-relative-import
  /* imported via vite.config.js */
  color green



================================================
FILE: playground/css/pkg-dep/_index.scss
================================================
.sass-dep {
  color: lavender;
}



================================================
FILE: playground/css/pkg-dep/index.js
================================================
[Empty file]


================================================
FILE: playground/css/pkg-dep/package.json
================================================
{
  "name": "dep",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/css/postcss-caching/css.spec.ts
================================================
import path from 'node:path'
import { createServer } from 'vite'
import { expect, test } from 'vitest'
import { getColor, isServe, page, ports } from '~utils'

test.runIf(isServe)('postcss config', async () => {
  const port = ports['css/postcss-caching']
  const startServer = async (root) => {
    const server = await createServer({
      root,
      logLevel: 'silent',
      server: {
        port,
        strictPort: true,
      },
      build: {
        // skip transpilation during tests to make it faster
        target: 'esnext',
      },
    })
    await server.listen()
    return server
  }

  const blueAppDir = path.join(__dirname, 'blue-app')
  const greenAppDir = path.join(__dirname, 'green-app')
  let blueApp
  let greenApp
  try {
    const hmrConnectionPromise = page.waitForEvent('console', (msg) =>
      msg.text().includes('connected'),
    )

    blueApp = await startServer(blueAppDir)

    await page.goto(`http://localhost:${port}`, { waitUntil: 'load' })
    const blueA = await page.$('.postcss-a')
    expect(await getColor(blueA)).toBe('blue')
    const blueB = await page.$('.postcss-b')
    expect(await getColor(blueB)).toBe('black')

    // wait for hmr connection because: if server stops before connection, auto reload does not happen
    await hmrConnectionPromise
    await blueApp.close()
    blueApp = null

    const loadPromise = page.waitForEvent('load') // wait for server restart auto reload
    greenApp = await startServer(greenAppDir)
    await loadPromise

    const greenA = await page.$('.postcss-a')
    expect(await getColor(greenA)).toBe('black')
    const greenB = await page.$('.postcss-b')
    expect(await getColor(greenB)).toBe('green')
    await greenApp.close()
    greenApp = null
  } finally {
    if (blueApp) {
      await blueApp.close()
    }
    if (greenApp) {
      await greenApp.close()
    }
  }
})



================================================
FILE: playground/css/postcss-caching/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

// The server is started in the test, so we need to have a custom serve
// function or a default server will be created
export async function serve(): Promise<{ close(): Promise<void> }> {
  return {
    close: () => Promise.resolve(),
  }
}



================================================
FILE: playground/css/postcss-caching/blue-app/imported.css
================================================
.postcss-a {
  color: pink;
}



================================================
FILE: playground/css/postcss-caching/blue-app/index.html
================================================
<div class="wrapper">
  <h1>CSS</h1>

  <p>Imported css string:</p>
  <pre class="imported-css"></pre>

  <p class="postcss-a">This should be blue</p>

  <p class="postcss-b">This should be black</p>
</div>

<script type="module" src="./main.js"></script>



================================================
FILE: playground/css/postcss-caching/blue-app/main.js
================================================
import './imported.css'
import css from './imported.css?inline'
text('.imported-css', css)

function text(el, text) {
  document.querySelector(el).textContent = text
}



================================================
FILE: playground/css/postcss-caching/blue-app/package.json
================================================
{
  "name": "blue-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/css/postcss-caching/blue-app/postcss.config.js
================================================
export default {
  plugins: [replacePinkWithBlue],
}

function replacePinkWithBlue() {
  return {
    postcssPlugin: 'replace-pink-with-blue',
    Declaration(decl) {
      if (decl.value === 'pink') {
        decl.value = 'blue'
      }
    },
  }
}
replacePinkWithBlue.postcss = true



================================================
FILE: playground/css/postcss-caching/green-app/imported.css
================================================
.postcss-b {
  color: pink;
}



================================================
FILE: playground/css/postcss-caching/green-app/index.html
================================================
<div class="wrapper">
  <h1>CSS</h1>

  <p>Imported css string:</p>
  <pre class="imported-css"></pre>

  <p class="postcss-a">This should be black</p>

  <p class="postcss-b">This should be green</p>
</div>

<script type="module" src="./main.js"></script>



================================================
FILE: playground/css/postcss-caching/green-app/main.js
================================================
import './imported.css'
import css from './imported.css?inline'
text('.imported-css', css)

function text(el, text) {
  document.querySelector(el).textContent = text
}



================================================
FILE: playground/css/postcss-caching/green-app/package.json
================================================
{
  "name": "green-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/css/postcss-caching/green-app/postcss.config.js
================================================
export default {
  plugins: [replacePinkWithGreen],
}

function replacePinkWithGreen() {
  return {
    postcssPlugin: 'replace-pink-with-green',
    Declaration(decl) {
      if (decl.value === 'pink') {
        decl.value = 'green'
      }
    },
  }
}
replacePinkWithGreen.postcss = true



================================================
FILE: playground/css/same-name/sub1/sub.css
================================================
.sub1-sub {
  color: red;
}



================================================
FILE: playground/css/same-name/sub1/sub.js
================================================
import './sub.css'

export default 'sub1-name'



================================================
FILE: playground/css/same-name/sub2/sub.css
================================================
.sub2-sub {
  color: blue;
}



================================================
FILE: playground/css/same-name/sub2/sub.js
================================================
import './sub.css'

export default 'sub2-name'



================================================
FILE: playground/css/sass-modern-compiler-build/entry1.scss
================================================
.entry1 {
  color: red;
}



================================================
FILE: playground/css/sass-modern-compiler-build/entry2.scss
================================================
.entry2 {
  color: blue;
}



================================================
FILE: playground/css/scss-dir/main.scss
================================================
@use './dir';



================================================
FILE: playground/css/scss-dir/dir/index.scss
================================================
.sass-dir-index {
  color: orange;
}



================================================
FILE: playground/css/scss-proxy-dep/index.scss
================================================
@use '@vitejs/test-scss-proxy-dep-nested/index.css';



================================================
FILE: playground/css/scss-proxy-dep/package.json
================================================
{
  "name": "@vitejs/test-scss-proxy-dep",
  "private": true,
  "version": "1.0.0",
  "sass": "index.scss",
  "dependencies": {
    "@vitejs/test-scss-proxy-dep-nested": "file:../scss-proxy-dep-nested"
  }
}



================================================
FILE: playground/css/scss-proxy-dep-nested/index.css
================================================
.scss-proxy-dep {
  color: purple;
}



================================================
FILE: playground/css/scss-proxy-dep-nested/package.json
================================================
{
  "name": "@vitejs/test-scss-proxy-dep-nested",
  "private": true,
  "version": "1.0.0"
}



================================================
FILE: playground/css/treeshake-module/a.js
================================================
import style from './a.module.css'

export function a() {
  return style
}



================================================
FILE: playground/css/treeshake-module/a.module.css
================================================
.treeshake-module-a {
  color: red;
}



================================================
FILE: playground/css/treeshake-module/b.js
================================================
import style from './b.module.css'

export function b() {
  return style
}



================================================
FILE: playground/css/treeshake-module/b.module.css
================================================
.treeshake-module-b {
  color: red;
}



================================================
FILE: playground/css/treeshake-module/index.js
================================================
export { a } from './a.js'
export { b } from './b.js'



================================================
FILE: playground/css/treeshake-scoped/a-scoped.css
================================================
.treeshake-scoped-a {
  color: red;
}



================================================
FILE: playground/css/treeshake-scoped/a.js
================================================
import './a-scoped.css' // should be treeshaken away if `a` is not used

export default function a() {
  return 'treeshake-scoped-a'
}



================================================
FILE: playground/css/treeshake-scoped/b-scoped.css
================================================
.treeshake-scoped-b {
  color: red;
}



================================================
FILE: playground/css/treeshake-scoped/b.js
================================================
import './b-scoped.css' // should be treeshaken away if `b` is not used

export default function b() {
  return 'treeshake-scoped-b'
}



================================================
FILE: playground/css/treeshake-scoped/c-scoped.css
================================================
.treeshake-scoped-c {
  color: red;
}



================================================
FILE: playground/css/treeshake-scoped/c.js
================================================
import './c-scoped.css' // should be treeshaken away if `b` is not used

export default function c() {
  return 'treeshake-scoped-c'
}

export function cUsed() {
  // used but does not depend on scoped css
  return 'c-used'
}



================================================
FILE: playground/css/treeshake-scoped/d-scoped.css
================================================
.treeshake-scoped-d {
  color: red;
}



================================================
FILE: playground/css/treeshake-scoped/d.js
================================================
import './d-scoped.css' // should be treeshaken away if `d` is not used

export default function d() {
  return 'treeshake-scoped-d'
}



================================================
FILE: playground/css/treeshake-scoped/index.html
================================================
<h1>treeshake-scoped</h1>
<p class="scoped-index">Imported scoped CSS</p>
<p class="treeshake-scoped-order">
  scoped CSS order (this should be red text with blue background)
</p>

<script type="module">
  import { d } from './index.js'
  import order from './order/a.js'
  document.querySelector('.scoped-index').classList.add(d())
  document.querySelector('.treeshake-scoped-order').classList.add(order())
</script>



================================================
FILE: playground/css/treeshake-scoped/index.js
================================================
export { default as a } from './a.js'
export { default as b } from './b.js'
export { default as c, cUsed } from './c.js'
export { default as d } from './d.js'



================================================
FILE: playground/css/treeshake-scoped/order/a-scoped.css
================================================
.treeshake-scoped-order {
  color: red;
  background: red;
}



================================================
FILE: playground/css/treeshake-scoped/order/a.js
================================================
import './before.css'
import './a-scoped.css'
import './after.css'

export default function a() {
  return 'treeshake-scoped-order-a'
}



================================================
FILE: playground/css/treeshake-scoped/order/after.css
================================================
.treeshake-scoped-order {
  color: red;
  background: blue;
}



================================================
FILE: playground/css/treeshake-scoped/order/before.css
================================================
.treeshake-scoped-order {
  color: blue;
}



================================================
FILE: playground/css-codesplit/async-js.css
================================================
.async-js {
  color: blue;
}



================================================
FILE: playground/css-codesplit/async-js.js
================================================
// a JS file that becomes an empty file but imports CSS files
import './async-js.css'



================================================
FILE: playground/css-codesplit/async.css
================================================
.dynamic {
  color: green;
}



================================================
FILE: playground/css-codesplit/chunk.css
================================================
.chunk {
  color: magenta;
}



================================================
FILE: playground/css-codesplit/index.html
================================================
<h1>This should be red</h1>
<h2>This should be blue</h2>

<p class="dynamic">This should be green</p>
<p class="async-js">This should be blue</p>
<p class="inline">This should not be yellow</p>
<p class="dynamic-inline"></p>
<p class="mod">This should be yellow</p>
<p class="dynamic-module"></p>

<p class="order-bulk">
  This should be orange
  <button class="order-bulk-update">change to green</button>
</p>

<p class="chunk">This should be magenta</p>

<script type="module" src="/main.js"></script>
<div id="app"></div>



================================================
FILE: playground/css-codesplit/inline.css
================================================
.inline {
  color: yellow;
}



================================================
FILE: playground/css-codesplit/main.css
================================================
h1 {
  color: red;
}



================================================
FILE: playground/css-codesplit/main.js
================================================
import './style.css'
import './main.css'
import './order'

import './chunk.css'
import chunkCssUrl from './chunk.css?url'

// use this to not treeshake
globalThis.__test_chunkCssUrl = chunkCssUrl

import('./async.css')
import('./async-js')

import('./inline.css?inline').then((css) => {
  document.querySelector('.dynamic-inline').textContent = css.default
})

import('./mod.module.css').then((css) => {
  document.querySelector('.dynamic-module').textContent = JSON.stringify(
    css.default,
  )
  document.querySelector('.mod').classList.add(css.default.mod)
})



================================================
FILE: playground/css-codesplit/mod.module.css
================================================
.mod {
  color: yellow;
}



================================================
FILE: playground/css-codesplit/other.js
================================================
import './style.css'
import './chunk.css'
import chunkCssUrl from './chunk.css?url'

// use this to not treeshake
globalThis.__test_chunkCssUrl = chunkCssUrl



================================================
FILE: playground/css-codesplit/package.json
================================================
{
  "name": "@vitejs/test-css-codesplit",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/css-codesplit/shared-css-empty-1.js
================================================
function shouldBeTreeshaken_1() {
  // This function should be treeshaken, even if { moduleSideEffects: 'no-treeshake' }
  // was used in the JS corresponding to the HTML entrypoint.
}



================================================
FILE: playground/css-codesplit/shared-css-empty-2.js
================================================
export default function shouldBeTreeshaken_2() {
  // This function should be treeshaken, even if { moduleSideEffects: 'no-treeshake' }
  // was used in the JS corresponding to the HTML entrypoint.
}



================================================
FILE: playground/css-codesplit/shared-css-main.js
================================================
import shouldTreeshake from './shared-css-empty-2.js'
document.querySelector('#app').innerHTML = `
  <div>
    <h1>Shared CSS, with JS</h1>
  </div>
`
function shouldBeTreeshaken_0() {
  // This function should be treeshaken, even if { moduleSideEffects: 'no-treeshake' }
  // was used in the JS corresponding to the HTML entrypoint.
}



================================================
FILE: playground/css-codesplit/shared-css-no-js.html
================================================
<link rel="stylesheet" type="text/css" href="./shared-css-theme.css" />
<body>
  <h1>Share CSS, no JS</h1>
</body>



================================================
FILE: playground/css-codesplit/shared-css-theme.css
================================================
h1 {
  color: red;
}



================================================
FILE: playground/css-codesplit/shared-css-with-js.html
================================================
<link rel="stylesheet" type="text/css" href="./shared-css-theme.css" />
<script type="module" src="./shared-css-main.js"></script>
<script type="module" src="./shared-css-empty-1.js"></script>
<body>
  <h1>Replaced by shared-css-main.js</h1>
</body>



================================================
FILE: playground/css-codesplit/style.css
================================================
h2 {
  color: blue;
}



================================================
FILE: playground/css-codesplit/style2.css
================================================
h2 {
  color: blue;
}



================================================
FILE: playground/css-codesplit/style2.js
================================================
import './style2.css'



================================================
FILE: playground/css-codesplit/vite.config.js
================================================
import { resolve } from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    manifest: true,
    rollupOptions: {
      input: {
        main: resolve(__dirname, './index.html'),
        other: resolve(__dirname, './other.js'),
        style2: resolve(__dirname, './style2.js'),
        'shared-css-with-js': resolve(__dirname, 'shared-css-with-js.html'),
        'shared-css-no-js': resolve(__dirname, 'shared-css-no-js.html'),
      },
      output: {
        manualChunks(id) {
          // make `chunk.css` it's own chunk for easier testing of pure css chunks
          if (id.includes('chunk.css')) {
            return 'chunk'
          }
        },
      },
    },
  },
})



================================================
FILE: playground/css-codesplit/__tests__/css-codesplit-consistent.spec.ts
================================================
import { beforeEach, describe, expect, test } from 'vitest'
import { findAssetFile, isBuild, startDefaultServe } from '~utils'

beforeEach(async () => {
  await startDefaultServe()
})

for (let i = 0; i < 5; i++) {
  describe.runIf(isBuild)('css-codesplit build', () => {
    test('should be consistent with same content', () => {
      expect(findAssetFile(/style-.+\.css/)).toMatch('h2{color:#00f}')
      expect(findAssetFile(/style2-.+\.css/)).toBeUndefined()
    })
  })
}



================================================
FILE: playground/css-codesplit/__tests__/css-codesplit.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import {
  findAssetFile,
  getColor,
  isBuild,
  listAssets,
  page,
  readManifest,
} from '~utils'

test('should load all stylesheets', async () => {
  expect(await getColor('h1')).toBe('red')
  expect(await getColor('h2')).toBe('blue')
  expect(await getColor('.dynamic')).toBe('green')
  expect(await getColor('.async-js')).toBe('blue')
  expect(await getColor('.chunk')).toBe('magenta')
})

test('should load dynamic import with inline', async () => {
  const css = await page.textContent('.dynamic-inline')
  expect(css).toMatch('.inline')

  expect(await getColor('.inline')).not.toBe('yellow')
})

test('should load dynamic import with module', async () => {
  const css = await page.textContent('.dynamic-module')
  expect(css).toMatch('_mod_')

  expect(await getColor('.mod')).toBe('yellow')
})

test('style order should be consistent when style tag is inserted by JS', async () => {
  expect(await getColor('.order-bulk')).toBe('orange')
  await page.click('.order-bulk-update')
  await expect.poll(() => getColor('.order-bulk')).toBe('green')
})

describe.runIf(isBuild)('build', () => {
  test('should remove empty chunk', async () => {
    expect(findAssetFile(/style-.*\.js$/)).toBeUndefined()
    expect(findAssetFile('main.*.js$')).toMatch(`/* empty css`)
    expect(findAssetFile('other.*.js$')).toMatch(`/* empty css`)
    expect(findAssetFile(/async-[-\w]{8}\.js$/)).toBeUndefined()

    const assets = listAssets()
    expect(assets).not.toContainEqual(
      expect.stringMatching(/async-js-[-\w]{8}\.js$/),
    )
  })

  test('should remove empty chunk, HTML without JS', async () => {
    const sharedCSSWithJSChunk = findAssetFile('shared-css-with-js.*.js$')
    expect(sharedCSSWithJSChunk).toMatch(`/* empty css`)
    // there are functions and modules in the src code that should be tree-shaken
    expect(sharedCSSWithJSChunk).not.toMatch('function')
    expect(sharedCSSWithJSChunk).not.toMatch(/import(?!".\/modulepreload)/)
  })

  test('should generate correct manifest', async () => {
    const manifest = readManifest()
    expect(manifest['index.html'].css.length).toBe(2)
    expect(manifest['other.js'].css.length).toBe(1)
  })

  test('should not mark a css chunk with ?url and normal import as pure css chunk', () => {
    expect(findAssetFile(/chunk-.*\.js$/)).toBeTruthy()
  })
})



================================================
FILE: playground/css-codesplit/order/base.css
================================================
.order-bulk {
  color: blue;
}



================================================
FILE: playground/css-codesplit/order/dynamic.css
================================================
.order-bulk {
  color: green;
}



================================================
FILE: playground/css-codesplit/order/index.js
================================================
import './insert' // inserts "color: orange"
import './base.css' // includes "color: blue"

document.querySelector('.order-bulk-update').addEventListener('click', () => {
  import('./dynamic.css') // includes "color: green"
})



================================================
FILE: playground/css-codesplit/order/insert.js
================================================
const style = document.createElement('style')
style.textContent = '.order-bulk { color: orange; }'
document.head.appendChild(style)



================================================
FILE: playground/css-codesplit-cjs/index.html
================================================
<script type="module" src="/main.js"></script>
<div id="app"></div>



================================================
FILE: playground/css-codesplit-cjs/main.css
================================================
h1 {
  color: red;
}



================================================
FILE: playground/css-codesplit-cjs/main.js
================================================
import './style.css'
import './main.css'

document.getElementById('app').innerHTML =
  `<h1>This should be red</h1><h2>This should be blue</h2>`



================================================
FILE: playground/css-codesplit-cjs/other.js
================================================
import './style.css'



================================================
FILE: playground/css-codesplit-cjs/package.json
================================================
{
  "name": "@vitejs/test-css-codesplit-cjs",
  "private": true,
  "version": "0.0.0",
  "type": "commonjs",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/css-codesplit-cjs/style.css
================================================
h2 {
  color: blue;
}



================================================
FILE: playground/css-codesplit-cjs/vite.config.js
================================================
import { resolve } from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: './dist',
    manifest: true,
    rollupOptions: {
      input: {
        main: resolve(__dirname, './index.html'),
        other: resolve(__dirname, './other.js'),
      },
      treeshake: false,
      output: {
        format: 'cjs',
        freeze: false,
        externalLiveBindings: false,
      },
    },
  },
})



================================================
FILE: playground/css-codesplit-cjs/__tests__/css-codesplit-cjs.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { findAssetFile, getColor, isBuild, readManifest } from '~utils'

test('should load both stylesheets', async () => {
  expect(await getColor('h1')).toBe('red')
  expect(await getColor('h2')).toBe('blue')
})

describe.runIf(isBuild)('build', () => {
  test('should remove empty chunk', async () => {
    expect(findAssetFile(/style.*\.js$/)).toBeUndefined()
    expect(findAssetFile('main.*.js$')).toMatch(`/* empty css`)
    expect(findAssetFile('other.*.js$')).toMatch(`/* empty css`)
  })

  test('should generate correct manifest', async () => {
    const manifest = readManifest()
    expect(manifest['index.html'].css.length).toBe(2)
    expect(manifest['other.js'].css.length).toBe(1)
  })
})



================================================
FILE: playground/css-dynamic-import/dynamic.css
================================================
.css-dynamic-import {
  color: green;
}



================================================
FILE: playground/css-dynamic-import/dynamic.js
================================================
import './dynamic.css'

export const lazyLoad = async () => {
  await import('./static.js')
  document.body.classList.add('loaded')
}



================================================
FILE: playground/css-dynamic-import/index.html
================================================
<p class="css-dynamic-import">This should be green</p>

<script type="module" src="./index.js"></script>



================================================
FILE: playground/css-dynamic-import/index.js
================================================
import './static.js'

const link = document.head.appendChild(document.createElement('link'))
link.rel = 'preload'
link.as = 'style'
link.href = new URL('./dynamic.css', import.meta.url).href

import('./dynamic.js').then(async ({ lazyLoad }) => {
  await lazyLoad()
})



================================================
FILE: playground/css-dynamic-import/package.json
================================================
{
  "name": "@vitejs/test-css-dynamic-import",
  "private": true,
  "type": "module",
  "version": "0.0.0"
}



================================================
FILE: playground/css-dynamic-import/static.css
================================================
.css-dynamic-import {
  color: red;
}



================================================
FILE: playground/css-dynamic-import/static.js
================================================
import './static.css'

export const foo = 'foo'



================================================
FILE: playground/css-dynamic-import/__tests__/css-dynamic-import.spec.ts
================================================
import type { InlineConfig } from 'vite'
import { build, createServer, preview } from 'vite'
import { expect, test } from 'vitest'
import { getColor, isBuild, isServe, page, ports, rootDir } from '~utils'

const baseOptions = [
  { base: '', label: 'relative' },
  { base: '/', label: 'absolute' },
]

const getConfig = (base: string): InlineConfig => ({
  base,
  root: rootDir,
  logLevel: 'silent',
  server: { port: ports['css/dynamic-import'] },
  preview: { port: ports['css/dynamic-import'] },
  build: { assetsInlineLimit: 0 },
})

async function withBuild(base: string, fn: () => Promise<void>) {
  const config = getConfig(base)
  await build(config)
  const server = await preview(config)

  try {
    await page.goto(server.resolvedUrls.local[0])
    await fn()
  } finally {
    server.httpServer.close()
  }
}

async function withServe(base: string, fn: () => Promise<void>) {
  const config = getConfig(base)
  const server = await createServer(config)
  await server.listen()

  try {
    await page.goto(server.resolvedUrls.local[0])
    await fn()
  } finally {
    await page.goto('about:blank') // move to a different page to avoid auto-refresh after server start
    await server.close()
  }
}

async function getLinks() {
  const links = await page.$$('link')
  return await Promise.all(
    links.map((handle) => {
      return handle.evaluate((link) => ({
        pathname: new URL(link.href).pathname,
        rel: link.rel,
        as: link.as,
      }))
    }),
  )
}

baseOptions.forEach(({ base, label }) => {
  test.runIf(isBuild)(
    `doesn't duplicate dynamically imported css files when built with ${label} base`,
    async () => {
      await withBuild(base, async () => {
        await page.waitForSelector('.loaded', { state: 'attached' })

        expect(await getColor('.css-dynamic-import')).toBe('green')
        const linkUrls = (await getLinks()).map((link) => link.pathname)
        const uniqueLinkUrls = [...new Set(linkUrls)]
        expect(linkUrls).toStrictEqual(uniqueLinkUrls)
      })
    },
  )

  test.runIf(isServe)(
    `doesn't duplicate dynamically imported css files when served with ${label} base`,
    async () => {
      await withServe(base, async () => {
        await page.waitForSelector('.loaded', { state: 'attached' })

        expect(await getColor('.css-dynamic-import')).toBe('green')
        // in serve there is no preloading
        expect(await getLinks()).toEqual([
          {
            pathname: '/dynamic.css',
            rel: 'preload',
            as: 'style',
          },
        ])
      })
    },
  )
})



================================================
FILE: playground/css-dynamic-import/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

// The server is started in the test, so we need to have a custom serve
// function or a default server will be created
export async function serve() {
  return {
    close: () => Promise.resolve(),
  }
}



================================================
FILE: playground/css-lightningcss/composed.module.css
================================================
.apply-color {
  color: turquoise;
}



================================================
FILE: playground/css-lightningcss/composes-path-resolving.module.css
================================================
.path-resolving-css {
  composes: apply-color from './composed.module.css';
}



================================================
FILE: playground/css-lightningcss/css-url.css
================================================
.css-url-aliased {
  background: url('@/fragment.svg');
  background-size: 10px;
}

.css-url-preinlined-svg {
  background: url('data:image/svg+xml,<svg fill="black" width="48" height="48" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30.74,15.95c-.01-.1-.04-.2-.09-.28,0-.01,0-.03-.01-.05l-5.57-8.6c-.19-.29-.56-.42-.89-.3C8.21,12.62,3.37,14.48,1.9,15.3c-.27,.04-.5,.21-.59,.46-.05,.09-.05,.17-.05,.26v8.38c0,.41,.34,.75,.75,.75H30c.41,0,.75-.34,.75-.75v-8.38s0-.01,0-.02c0-.02,0-.04-.01-.06Zm-6.61-7.62l4.49,6.94H5.7c4.42-1.73,12.41-4.72,18.43-6.94Zm5.12,15.32H2.75v-6.88H29.25v6.88Z"/><path d="M6.16,21.34c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M15.15,23.04c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M24.28,20.73c.99,0,1.79-.8,1.79-1.79s-.8-1.79-1.79-1.79-1.79,.8-1.79,1.79,.8,1.79,1.79,1.79Zm0-2.08c.16,0,.29,.13,.29,.29s-.13,.29-.29,.29-.29-.13-.29-.29,.13-.29,.29-.29Z"/><path d="M22.78,10.16c-.99,0-1.79,.8-1.79,1.79s.8,1.79,1.79,1.79,1.79-.8,1.79-1.79-.8-1.79-1.79-1.79Zm0,2.08c-.16,0-.29-.13-.29-.29s.13-.29,.29-.29,.29,.13,.29,.29-.13,.29-.29,.29Z"/></svg>');
  background-size: 20px;
}



================================================
FILE: playground/css-lightningcss/external-url.css
================================================
.external {
  background-image: url('https://vite.dev/logo.svg');
  background-size: 100%;
  width: 200px;
  height: 200px;
  background-color: #bed;
}



================================================
FILE: playground/css-lightningcss/imported-at-import.css
================================================
.imported-at-import {
  color: purple;
}



================================================
FILE: playground/css-lightningcss/imported.css
================================================
@import url('./nested/nested.css');
@import './imported-at-import.css';

.imported {
  color: green;
}

pre {
  background-color: #eee;
  width: 500px;
  padding: 1em 1.5em;
  border-radius: 10px;
}



================================================
FILE: playground/css-lightningcss/index.html
================================================
<link rel="stylesheet" href="./linked.css" />

<div class="wrapper">
  <h1>Lightning CSS</h1>

  <p class="linked">&lt;link&gt;: This should be blue</p>
  <p class="linked-at-import">@import in &lt;link&gt;: This should be red</p>

  <p class="imported">import from js: This should be green</p>
  <p class="imported-at-import">
    @import in import from js: This should be purple
  </p>

  <p class="modules">CSS modules: this should be turquoise</p>
  <p>Imported CSS module:</p>
  <pre class="modules-code"></pre>

  <p>Imported compose/from CSS module:</p>
  <p class="path-resolved-modules-css">
    CSS modules composes path resolving: this should be turquoise
  </p>
  <pre class="path-resolved-modules-code"></pre>

  <p>Inline CSS module:</p>
  <pre class="modules-inline"></pre>

  <p>External URL</p>
  <div class="external"></div>

  <p>Assets relative to nested CSS</p>
  <div class="nested-css-relative-asset"></div>

  <div class="css-url-aliased">
    <span style="background: #fff">CSS background (aliased)</span>
  </div>
  <div class="css-url-preinlined-svg">
    <span style="background: #fff">CSS background (pre inlined SVG)</span>
  </div>
</div>

<script type="module" src="./main.js"></script>



================================================
FILE: playground/css-lightningcss/inline.module.css
================================================
.apply-color-inline {
  color: turquoise;
}



================================================
FILE: playground/css-lightningcss/inlined.css
================================================
.inlined {
  color: green;
  background: url('./ok.png');
}



================================================
FILE: playground/css-lightningcss/linked-at-import.css
================================================
.linked-at-import {
  color: red;
}



================================================
FILE: playground/css-lightningcss/linked.css
================================================
@import './linked-at-import.css';

/* test nesting */
.wrapper {
  .linked {
    color: blue;
  }
}



================================================
FILE: playground/css-lightningcss/main.js
================================================
import './minify.css'
import './imported.css'
import mod from './mod.module.css'
import './external-url.css'
import './css-url.css'

document.querySelector('.modules').classList.add(mod['apply-color'])
text('.modules-code', JSON.stringify(mod, null, 2))

import composesPathResolvingMod from './composes-path-resolving.module.css'
document
  .querySelector('.path-resolved-modules-css')
  .classList.add(...composesPathResolvingMod['path-resolving-css'].split(' '))
text(
  '.path-resolved-modules-code',
  JSON.stringify(composesPathResolvingMod, null, 2),
)

import inlineMod from './inline.module.css?inline'
text('.modules-inline', inlineMod)

function text(el, text) {
  document.querySelector(el).textContent = text
}

if (import.meta.hot) {
  import.meta.hot.accept('./mod.module.css', (newMod) => {
    const list = document.querySelector('.modules').classList
    list.remove(mod.applyColor)
    list.add(newMod.applyColor)
    text('.modules-code', JSON.stringify(newMod.default, null, 2))
  })
}



================================================
FILE: playground/css-lightningcss/minify.css
================================================
.test-minify {
  color: rgba(255, 255, 0, 0.7);
}



================================================
FILE: playground/css-lightningcss/mod.module.css
================================================
.apply-color {
  color: turquoise;
}



================================================
FILE: playground/css-lightningcss/package.json
================================================
{
  "name": "@vitejs/test-css-lightningcss",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "lightningcss": "^1.30.1"
  }
}



================================================
FILE: playground/css-lightningcss/vite.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  css: {
    transformer: 'lightningcss',
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'nested'),
    },
  },
  build: {
    cssTarget: ['chrome61'],
    cssMinify: 'lightningcss',
  },
})



================================================
FILE: playground/css-lightningcss/__tests__/css-lightningcss.spec.ts
================================================
import { expect, test } from 'vitest'
import {
  editFile,
  findAssetFile,
  getBg,
  getColor,
  isBuild,
  page,
  viteTestUrl,
} from '~utils'

// note: tests should retrieve the element at the beginning of test and reuse it
// in later assertions to ensure CSS HMR doesn't reload the page
test('linked css', async () => {
  const linked = await page.$('.linked')
  const atImport = await page.$('.linked-at-import')

  expect(await getColor(linked)).toBe('blue')
  expect(await getColor(atImport)).toBe('red')

  if (isBuild) return
  editFile('linked.css', (code) => code.replace('color: blue', 'color: red'))
  await expect.poll(() => getColor(linked)).toBe('red')

  editFile('linked-at-import.css', (code) =>
    code.replace('color: red', 'color: blue'),
  )
  await expect.poll(() => getColor(atImport)).toBe('blue')
})

test('css import from js', async () => {
  const imported = await page.$('.imported')
  const atImport = await page.$('.imported-at-import')

  expect(await getColor(imported)).toBe('green')
  expect(await getColor(atImport)).toBe('purple')

  if (isBuild) return
  editFile('imported.css', (code) => code.replace('color: green', 'color: red'))
  await expect.poll(() => getColor(imported)).toBe('red')

  editFile('imported-at-import.css', (code) =>
    code.replace('color: purple', 'color: blue'),
  )
  await expect.poll(() => getColor(atImport)).toBe('blue')
})

test('css modules', async () => {
  const imported = await page.$('.modules')
  expect(await getColor(imported)).toBe('turquoise')

  expect(await imported.getAttribute('class')).toMatch(/\w{6}_apply-color/)

  if (isBuild) return
  editFile('mod.module.css', (code) =>
    code.replace('color: turquoise', 'color: red'),
  )
  await expect.poll(() => getColor(imported)).toBe('red')
})

test('inline css modules', async () => {
  const css = await page.textContent('.modules-inline')
  expect(css).toMatch(/\._?\w{6}_apply-color-inline/)
})

test.runIf(isBuild)('minify css', async () => {
  // should keep the rgba() syntax
  const cssFile = findAssetFile(/index-[-\w]+\.css$/)
  expect(cssFile).toMatch('rgba(')
  expect(cssFile).not.toMatch('#ffff00b3')
})

test('css with external url', async () => {
  const css = await page.$('.external')
  expect(await getBg(css)).toMatch('url("https://vite.dev/logo.svg")')
})

test('nested css with relative asset', async () => {
  const css = await page.$('.nested-css-relative-asset')
  expect(await getBg(css)).toMatch(
    isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
  )
})

test('aliased asset', async () => {
  const bg = await getBg('.css-url-aliased')
  expect(bg).toMatch('data:image/svg+xml,')
})

test('preinlined SVG', async () => {
  expect(await getBg('.css-url-preinlined-svg')).toMatch(
    /data:image\/svg\+xml,.+/,
  )
})



================================================
FILE: playground/css-lightningcss/nested/nested.css
================================================
.nested-css-relative-asset {
  background-image: url('../ok.png');
  width: 50px;
  height: 50px;
}



================================================
FILE: playground/css-lightningcss-proxy/index.html
================================================
<!--[inline-css]-->
<div class="wrapper">
  <p>Injected inline style with SSR Proxy</p>
  <p class="ssr-proxy">This should be coral</p>
</div>



================================================
FILE: playground/css-lightningcss-proxy/package.json
================================================
{
  "name": "@vitejs/test-css-lightningcss-proxy",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server",
    "preview": "vite preview"
  },
  "devDependencies": {
    "lightningcss": "^1.30.1",
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/css-lightningcss-proxy/server.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const isTest = process.env.VITEST

const DYNAMIC_STYLES = `
  <style>
  .ssr-proxy {
    color: coral;
  }
  </style>
`

export async function createServer(root = process.cwd(), hmrPort) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    css: {
      transformer: 'lightningcss',
    },
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
  })
  // use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*all', async (req, res, next) => {
    try {
      let [url] = req.originalUrl.split('?')
      if (url.endsWith('/')) url += 'index.html'

      if (url.startsWith('/favicon.ico')) {
        return res.status(404).end('404')
      }

      const htmlLoc = resolve(`.${url}`)
      let template = fs.readFileSync(htmlLoc, 'utf-8')

      template = template.replace('<!--[inline-css]-->', DYNAMIC_STYLES)

      // Force calling transformIndexHtml with url === '/', to simulate
      // usage by ecosystem that was recommended in the SSR documentation
      // as `const url = req.originalUrl`
      const html = await vite.transformIndexHtml('/', template)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/css-lightningcss-proxy/__tests__/css-lightningcss-proxy.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { getColor, isServe, page } from '~utils'

const url = `http://localhost:${port}`

describe.runIf(isServe)('injected inline style', () => {
  test('injected inline style is present', async () => {
    await page.goto(url)
    const el = await page.$('.ssr-proxy')
    expect(await getColor(el)).toBe('coral')
  })
})



================================================
FILE: playground/css-lightningcss-proxy/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, ports, rootDir } from '~utils'

export const port = ports['css/lightningcss-proxy']

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(
    rootDir,
    hmrPorts['css/lightningcss-proxy'],
  )

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/css-lightningcss-root/package.json
================================================
{
  "name": "@vitejs/test-css-lightningcss-root",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "lightningcss": "^1.30.1"
  }
}



================================================
FILE: playground/css-lightningcss-root/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  root: 'root',
  css: {
    transformer: 'lightningcss',
  },
})



================================================
FILE: playground/css-lightningcss-root/__tests__/css-lightningcss-root.spec.ts
================================================
import { expect, test } from 'vitest'
import { getBg, isBuild, page, viteTestUrl } from '~utils'

test('url dependency', async () => {
  const css = await page.$('.url-dep')
  expect(await getBg(css)).toMatch(
    isBuild ? /ok-[-\w]+\.png/ : `${viteTestUrl}/ok.png`,
  )
})



================================================
FILE: playground/css-lightningcss-root/root/index.html
================================================
<p>url() dependency</p>
<div class="url-dep"></div>
<script type="module" src="./main.js"></script>



================================================
FILE: playground/css-lightningcss-root/root/main.js
================================================
import './url-dep.css'



================================================
FILE: playground/css-lightningcss-root/root/url-dep.css
================================================
.url-dep {
  background-image: url('./ok.png');
  background-size: cover;
  width: 50px;
  height: 50px;
  border: 1px solid black;
}



================================================
FILE: playground/css-no-codesplit/async-js.css
================================================
.async-js {
  color: blue;
}



================================================
FILE: playground/css-no-codesplit/async-js.js
================================================
// a JS file that becomes an empty file but imports CSS files
import './async-js.css'



================================================
FILE: playground/css-no-codesplit/index.html
================================================
<link rel="stylesheet" href="./shared-linked.css" />
<script type="module" src="./index.js"></script>

<p class="shared-linked">shared linked: this should be blue</p>
<p class="async-js">async JS importing CSS: this should be blue</p>



================================================
FILE: playground/css-no-codesplit/index.js
================================================
import('./async-js')



================================================
FILE: playground/css-no-codesplit/package.json
================================================
{
  "name": "@vitejs/test-css-no-codesplit",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/css-no-codesplit/shared-linked.css
================================================
.shared-linked {
  color: blue;
}



================================================
FILE: playground/css-no-codesplit/sub.html
================================================
<link rel="stylesheet" href="./shared-linked.css" />



================================================
FILE: playground/css-no-codesplit/vite.config.js
================================================
import { resolve } from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    cssCodeSplit: false,
    rollupOptions: {
      input: {
        index: resolve(__dirname, './index.html'),
        sub: resolve(__dirname, './sub.html'),
      },
    },
  },
})



================================================
FILE: playground/css-no-codesplit/__tests__/css-no-codesplit.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { getColor, isBuild, listAssets } from '~utils'

test('should load all stylesheets', async () => {
  expect(await getColor('.shared-linked')).toBe('blue')
  await expect.poll(() => getColor('.async-js')).toBe('blue')
})

describe.runIf(isBuild)('build', () => {
  test('should remove empty chunk', async () => {
    const assets = listAssets()
    expect(assets).not.toContainEqual(
      expect.stringMatching(/shared-linked-.*\.js$/),
    )
    expect(assets).not.toContainEqual(expect.stringMatching(/async-js-.*\.js$/))
  })
})



================================================
FILE: playground/css-sourcemap/be-imported.css
================================================
.be-imported {
  color: red;
}



================================================
FILE: playground/css-sourcemap/imported-nested.sass
================================================
$primary: red



================================================
FILE: playground/css-sourcemap/imported-with-import.css
================================================
@import '@/be-imported.css';

.imported-with-import {
  color: red;
}



================================================
FILE: playground/css-sourcemap/imported.css
================================================
.imported {
  color: red;
}



================================================
FILE: playground/css-sourcemap/imported.less
================================================
.imported {
  &-less {
    color: @color;
  }
}



================================================
FILE: playground/css-sourcemap/imported.module.sass
================================================
.imported
  &-sass-module
    color: red



================================================
FILE: playground/css-sourcemap/imported.sass
================================================
@use "/imported-nested.sass"

.imported
  &-sass
    color: imported-nested.$primary



================================================
FILE: playground/css-sourcemap/imported.sss
================================================
.imported-sugarss
  color: red



================================================
FILE: playground/css-sourcemap/imported.styl
================================================
.imported
  &-stylus
    color blue-red-mixed



================================================
FILE: playground/css-sourcemap/index.html
================================================
<link rel="stylesheet" href="./linked.css" />
<link rel="stylesheet" href="./linked-with-import.css" />

<style>
  .inline {
    color: red;
  }
</style>

<div class="wrapper">
  <h1>CSS Sourcemap</h1>

  <p class="inline">&lt;inline&gt;</p>

  <p class="linked">&lt;linked&gt;: no import</p>
  <p class="linked-with-import">&lt;linked&gt;: with import</p>

  <p class="imported">&lt;imported&gt;: no import</p>
  <p class="imported-with-import">&lt;imported&gt;: with import</p>

  <p class="imported-sass">&lt;imported sass&gt;</p>
  <p class="imported-sass-module">&lt;imported sass&gt; with module</p>

  <p class="imported-less">&lt;imported less&gt; with string additionalData</p>

  <p class="imported-stylus">&lt;imported stylus&gt;</p>

  <p class="imported-sugarss">&lt;imported sugarss&gt;</p>

  <p class="input-map">&lt;input source-map&gt;</p>
</div>

<script type="module">
  import './imported.css'
  import './imported-with-import.css'

  import './imported.sass'
  import sassModule from './imported.module.sass'

  document
    .querySelector('.imported-sass-module')
    .classList.add(sassModule['imported-sass-module'])

  import './imported.less'

  import './imported.styl'

  import './imported.sss'

  import './input-map.css'
</script>

<iframe src="virtual.html"></iframe>



================================================
FILE: playground/css-sourcemap/index.js
================================================
export default 'hello'



================================================
FILE: playground/css-sourcemap/input-map.css
================================================
.input-map {
  color: #00f;
}
/*# sourceMappingURL=input-map.css.map */



================================================
FILE: playground/css-sourcemap/input-map.src.css
================================================
.input-map {
  color: blue;
}



================================================
FILE: playground/css-sourcemap/linked-with-import.css
================================================
@import '@/be-imported.css';

.linked-with-import {
  color: red;
}



================================================
FILE: playground/css-sourcemap/linked.css
================================================
.linked {
  color: red;
}



================================================
FILE: playground/css-sourcemap/package.json
================================================
{
  "name": "@vitejs/test-css-sourcemap",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "less": "^4.4.0",
    "lightningcss": "^1.30.1",
    "magic-string": "^0.30.17",
    "sass": "^1.90.0",
    "stylus": "^0.64.0",
    "sugarss": "^5.0.1"
  }
}



================================================
FILE: playground/css-sourcemap/vite.config-lib-entry.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    cssCodeSplit: true,
    sourcemap: true,
    outDir: 'dist/lib-entry',
    lib: {
      entry: ['./index.js', './linked.css'],
      formats: ['es'],
    },
  },
})



================================================
FILE: playground/css-sourcemap/vite.config-lightningcss.js
================================================
import { defineConfig, mergeConfig } from 'vite'
import baseConfig from './vite.config.js'

export default mergeConfig(
  baseConfig,
  defineConfig({
    css: {
      transformer: 'lightningcss',
    },
  }),
)



================================================
FILE: playground/css-sourcemap/vite.config.js
================================================
import { defineConfig } from 'vite'
import MagicString from 'magic-string'

export default defineConfig({
  resolve: {
    alias: {
      '@': __dirname,
    },
  },
  css: {
    devSourcemap: true,
    preprocessorOptions: {
      less: {
        additionalData: '@color: red;',
      },
      styl: {
        additionalData: (content, filename) => {
          const ms = new MagicString(content, { filename })

          const willBeReplaced = 'blue-red-mixed'
          const start = content.indexOf(willBeReplaced)
          ms.overwrite(start, start + willBeReplaced.length, 'purple')

          const map = ms.generateMap({ hires: 'boundary' })
          map.file = filename
          map.sources = [filename]

          return {
            content: ms.toString(),
            map,
          }
        },
      },
    },
  },
  build: {
    sourcemap: true,
  },
  plugins: [
    {
      name: 'virtual-html',
      configureServer(server) {
        server.middlewares.use(async (req, res, next) => {
          if (req.url === '/virtual.html') {
            const t = await server.transformIndexHtml(
              '/virtual.html',
              '<style> .foo { color: red; } </style> <p class="foo">virtual html</p>',
            )
            res.setHeader('Content-Type', 'text/html')
            res.statusCode = 200
            res.end(t)
            return
          }
          next()
        })
      },
    },
  ],
})



================================================
FILE: playground/css-sourcemap/__tests__/css-sourcemap.spec.ts
================================================
import { URL } from 'node:url'
import { describe, expect, test } from 'vitest'
import {
  extractSourcemap,
  formatSourcemapForSnapshot,
  isBuild,
  isServe,
  page,
  serverLogs,
} from '~utils'

test.runIf(isBuild)('should not output sourcemap warning (#4939)', () => {
  serverLogs.forEach((log) => {
    expect(log).not.toMatch('Sourcemap is likely to be incorrect')
  })
})

describe.runIf(isServe)('serve', () => {
  const getStyleTagContentIncluding = async (content: string) => {
    const styles = await page.$$('style')
    for (const style of styles) {
      const text = await style.textContent()
      if (text.includes(content)) {
        return text
      }
    }
    throw new Error('Not found')
  }

  test('linked css', async () => {
    const res = await page.request.get(
      new URL('./linked.css', page.url()).href,
      {
        headers: {
          accept: 'text/css',
        },
      },
    )
    const css = await res.text()
    expect(css).not.toContain('sourceMappingURL')
  })

  test('linked css with import', async () => {
    const res = await page.request.get(
      new URL('./linked-with-import.css', page.url()).href,
      {
        headers: {
          accept: 'text/css',
        },
      },
    )
    const css = await res.text()
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA;EACE,UAAU;AACZ;;ACAA;EACE,UAAU;AACZ",
        "sources": [
          "be-imported.css",
          "linked-with-import.css",
        ],
        "sourcesContent": [
          ".be-imported {
        color: red;
      }
      ",
          "@import '@/be-imported.css';

      .linked-with-import {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test.runIf(isServe)(
    'js .css request does not include sourcemap',
    async () => {
      const res = await page.request.get(
        new URL('./linked-with-import.css', page.url()).href,
      )
      const content = await res.text()
      expect(content).not.toMatch('//#s*sourceMappingURL')
    },
  )

  test('imported css', async () => {
    const css = await getStyleTagContentIncluding('.imported ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA,CAAC,QAAQ,CAAC;AACV,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;AACZ;",
        "sources": [
          "/root/imported.css",
        ],
        "sourcesContent": [
          ".imported {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported css with import', async () => {
    const css = await getStyleTagContentIncluding('.imported-with-import ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA;EACE,UAAU;AACZ;;ACAA;EACE,UAAU;AACZ",
        "sources": [
          "/root/be-imported.css",
          "/root/imported-with-import.css",
        ],
        "sourcesContent": [
          ".be-imported {
        color: red;
      }
      ",
          "@import '@/be-imported.css';

      .imported-with-import {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sass', async () => {
    const css = await getStyleTagContentIncluding('.imported-sass ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAGE;EACE,OCJM",
        "sourceRoot": "",
        "sources": [
          "/root/imported.sass",
          "/root/imported-nested.sass",
        ],
        "sourcesContent": [
          "@use "/imported-nested.sass"

      .imported
        &-sass
          color: imported-nested.$primary
      ",
          "$primary: red
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sass module', async () => {
    const css = await getStyleTagContentIncluding('._imported-sass-module_')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE;EACE",
        "sources": [
          "/root/imported.module.sass",
        ],
        "sourcesContent": [
          ".imported
        &-sass-module
          color: red
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported less', async () => {
    const css = await getStyleTagContentIncluding('.imported-less ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE,SAAC;EACC",
        "sources": [
          "/root/imported.less",
        ],
        "sourcesContent": [
          ".imported {
        &-less {
          color: @color;
        }
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported stylus', async () => {
    const css = await getStyleTagContentIncluding('.imported-stylus ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE;EACE,OAAM,QAAN",
        "sources": [
          "/root/imported.styl",
        ],
        "sourcesContent": [
          ".imported
        &-stylus
          color blue-red-mixed
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sugarss', async () => {
    const css = await getStyleTagContentIncluding('.imported-sugarss ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA;EACE;AADe",
        "sources": [
          "/root/imported.sss",
        ],
        "sourcesContent": [
          ".imported-sugarss
        color: red
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('should not output missing source file warning', () => {
    serverLogs.forEach((log) => {
      expect(log).not.toMatch(/Sourcemap for .+ points to missing source files/)
    })
  })
})



================================================
FILE: playground/css-sourcemap/__tests__/lib-entry/css-sourcemap-lib-entry.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { findAssetFile, isBuild } from '~utils'

describe.runIf(isBuild)('css lib entry', () => {
  test('remove useless js sourcemap', async () => {
    expect(findAssetFile('linked.js.map', 'lib-entry', './')).toBeUndefined()
  })
})



================================================
FILE: playground/css-sourcemap/__tests__/lightningcss/lightningcss.spec.ts
================================================
import { URL } from 'node:url'
import { describe, expect, test } from 'vitest'
import {
  extractSourcemap,
  formatSourcemapForSnapshot,
  isBuild,
  isServe,
  page,
  serverLogs,
} from '~utils'

test.runIf(isBuild)('should not output sourcemap warning (#4939)', () => {
  serverLogs.forEach((log) => {
    expect(log).not.toMatch('Sourcemap is likely to be incorrect')
  })
})

describe.runIf(isServe)('serve', () => {
  const getStyleTagContentIncluding = async (content: string) => {
    const styles = await page.$$('style')
    for (const style of styles) {
      const text = await style.textContent()
      if (text.includes(content)) {
        return text
      }
    }
    throw new Error('Not found')
  }

  test('linked css', async () => {
    const res = await page.request.get(
      new URL('./linked.css', page.url()).href,
      {
        headers: {
          accept: 'text/css',
        },
      },
    )
    const css = await res.text()
    expect(css).not.toContain('sourceMappingURL')
  })

  test('linked css with import', async () => {
    const res = await page.request.get(
      new URL('./linked-with-import.css', page.url()).href,
      {
        headers: {
          accept: 'text/css',
        },
      },
    )
    const css = await res.text()
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "ACAA;;;;ADEA",
        "sourceRoot": null,
        "sources": [
          "linked-with-import.css",
          "be-imported.css",
        ],
        "sourcesContent": [
          "@import '@/be-imported.css';

      .linked-with-import {
        color: red;
      }
      ",
          ".be-imported {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test.runIf(isServe)(
    'js .css request does not include sourcemap',
    async () => {
      const res = await page.request.get(
        new URL('./linked-with-import.css', page.url()).href,
      )
      const content = await res.text()
      expect(content).not.toMatch('//#s*sourceMappingURL')
    },
  )

  test('imported css', async () => {
    const css = await getStyleTagContentIncluding('.imported ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA",
        "sourceRoot": null,
        "sources": [
          "imported.css",
        ],
        "sourcesContent": [
          ".imported {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported css with import', async () => {
    const css = await getStyleTagContentIncluding('.imported-with-import ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "ACAA;;;;ADEA",
        "sourceRoot": null,
        "sources": [
          "imported-with-import.css",
          "be-imported.css",
        ],
        "sourcesContent": [
          "@import '@/be-imported.css';

      .imported-with-import {
        color: red;
      }
      ",
          ".be-imported {
        color: red;
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sass', async () => {
    const css = await getStyleTagContentIncluding('.imported-sass ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AAGE",
        "sources": [
          "/root/imported.sass",
        ],
        "sourcesContent": [
          "@use "/imported-nested.sass"

      .imported
        &-sass
          color: imported-nested.$primary
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sass module', async () => {
    const css = await getStyleTagContentIncluding('_imported-sass-module')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE",
        "sources": [
          "/root/imported.module.sass",
        ],
        "sourcesContent": [
          ".imported
        &-sass-module
          color: red
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported less', async () => {
    const css = await getStyleTagContentIncluding('.imported-less ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE",
        "sources": [
          "/root/imported.less",
        ],
        "sourcesContent": [
          ".imported {
        &-less {
          color: @color;
        }
      }
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported stylus', async () => {
    const css = await getStyleTagContentIncluding('.imported-stylus ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AACE",
        "sources": [
          "/root/imported.styl",
        ],
        "sourcesContent": [
          ".imported
        &-stylus
          color blue-red-mixed
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('imported sugarss', async () => {
    const css = await getStyleTagContentIncluding('.imported-sugarss ')
    const map = extractSourcemap(css)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "ignoreList": [],
        "mappings": "AAAA",
        "sources": [
          "/root/imported.sss",
        ],
        "sourcesContent": [
          ".imported-sugarss
        color: red
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('should not output missing source file warning', () => {
    serverLogs.forEach((log) => {
      expect(log).not.toMatch(/Sourcemap for .+ points to missing source files/)
    })
  })
})



================================================
FILE: playground/data-uri/index.html
================================================
<div class="plain"></div>
<div class="base64"></div>
<div class="comma"></div>

<script type="module">
  import msg from "data:text/javascript, export default 'hi'"
  text('.plain', msg)

  import base64Msg from 'data:text/javascript;base64, ZXhwb3J0IGRlZmF1bHQgJ2hpJw=='
  text('.base64', base64Msg)

  import { comma } from 'comma/foo?number=1,2,3'
  text('.comma', comma)

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>

<script type="module" src="./main.js"></script>

<div id="sqdqs"></div>
<div id="sqsdqs"></div>
<div id="dqsqs"></div>
<div id="dqssqs"></div>



================================================
FILE: playground/data-uri/main.js
================================================
import sqdqs from './single-quote-in-double-quotes.svg'
import sqsdqs from './single-quotes-in-double-quotes.svg'
import dqsqs from './double-quote-in-single-quotes.svg'
import dqssqs from './double-quotes-in-single-quotes.svg'

document.querySelector('#sqdqs').innerHTML = `
  <img data-testid="sqdqs" src="${sqdqs}" class="sqdqs" alt="load failed" />
`
document.querySelector('#sqsdqs').innerHTML = `
  <img data-testid="sqsdqs" src="${sqsdqs}" class="sqsdqs" alt="load failed" />
`

document.querySelector('#dqsqs').innerHTML = `
  <img data-testid="dqsqs" src="${dqsqs}" class="dqsqs" alt="load failed" />
`
document.querySelector('#dqssqs').innerHTML = `
  <img data-testid="dqssqs" src="${dqssqs}" class="dqssqs" alt="load failed" />
`



================================================
FILE: playground/data-uri/package.json
================================================
{
  "name": "@vitejs/test-data-uri",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/data-uri/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      name: 'post-plugin',
      enforce: 'post',
      resolveId(id) {
        if (id.replace(/\?.*$/, '') === 'comma/foo') {
          return id
        }
      },
      load(id) {
        if (id.replace(/\?.*$/, '') === 'comma/foo') {
          return `export const comma = 'hi'`
        }
      },
    },
  ],
})



================================================
FILE: playground/data-uri/__tests__/data-uri.spec.ts
================================================
import { expect, test } from 'vitest'
import { findAssetFile, isBuild, page } from '~utils'

test('plain', async () => {
  expect(await page.textContent('.plain')).toBe('hi')
})

test('base64', async () => {
  expect(await page.textContent('.base64')).toBe('hi')
})

test('svg data uri minify', async () => {
  const sqdqs = await page.getByTestId('sqdqs').boundingBox()
  const sqsdqs = await page.getByTestId('sqsdqs').boundingBox()
  const dqsqs = await page.getByTestId('dqsqs').boundingBox()
  const dqssqs = await page.getByTestId('dqssqs').boundingBox()

  expect(sqdqs.height).toBe(100)
  expect(sqsdqs.height).toBe(100)
  expect(dqsqs.height).toBe(100)
  expect(dqssqs.height).toBe(100)
})

test.runIf(isBuild)('should compile away the import for build', async () => {
  const file = findAssetFile('index')
  expect(file).not.toMatch('import')
})



================================================
FILE: playground/define/data.json
================================================
{
  "foo": "__EXP__"
}



================================================
FILE: playground/define/index.html
================================================
<meta charset="utf-8" />

<h1>Define</h1>

<p>Raw Expression <code class="exp"></code></p>
<p>String <code class="string"></code></p>
<p>Number <code class="number"></code></p>
<p>Boolean <code class="boolean"></code></p>
<p>Undefined <code class="undefined"></code></p>
<p>Object <span class="pre object"></span></p>
<p>Env Var <code class="env-var"></code></p>
<p>process node env: <code class="process-node-env"></code></p>
<p>process env: <code class="process-env"></code></p>
<p>process as property: <code class="process-as-property"></code></p>
<p>spread object: <code class="spread-object"></code></p>
<p>spread array: <code class="spread-array"></code></p>
<p>dollar identifier: <code class="dollar-identifier"></code></p>
<p>unicode identifier: <code class="unicode-identifier"></code></p>
<p>no property: <code class="no-property"></code></p>
<p>no identifier substring: <span class="no-identifier-substring"></span></p>
<p>define variable in html: <code class="exp-define">__EXP__</code></p>
<p>import json: <code class="import-json"></code></p>
<p>define in dep: <code class="define-in-dep"></code></p>
<p>define in environment: <code class="define-in-environment"></code></p>

<h2>Define ignores string literals</h2>
<section class="ignores-string-literals">
  <p>process.env. <code class="process-env-dot"></code></p>
  <p>global.process.env. <code class="global-process-env-dot"></code></p>
  <p>
    globalThis.process.env. <code class="globalThis-process-env-dot"></code>
  </p>
  <p>process.env.NODE_ENV <code class="process-env-NODE_ENV"></code></p>
  <p>
    global.process.env.NODE_ENV
    <code class="global-process-env-NODE_ENV"></code>
  </p>
  <p>
    globalThis.process.env.NODE_ENV
    <code class="globalThis-process-env-NODE_ENV"></code>
  </p>
  <p>import.meta.hot <code class="import-meta-hot"></code></p>
</section>

<h2>Define replaces constants in template literal expressions</h2>
<section class="replaces-constants-in-template-literal-expressions">
  <p>process.env. <code class="process-env-dot"></code></p>
  <p>global.process.env. <code class="global-process-env-dot"></code></p>
  <p>
    globalThis.process.env. <code class="globalThis-process-env-dot"></code>
  </p>
  <p>process.env.NODE_ENV <code class="process-env-NODE_ENV"></code></p>
  <p>
    global.process.env.NODE_ENV
    <code class="global-process-env-NODE_ENV"></code>
  </p>
  <p>
    globalThis.process.env.NODE_ENV
    <code class="globalThis-process-env-NODE_ENV"></code>
  </p>
  <p>import.meta.hot <code class="import-meta-hot"></code></p>
</section>

<h2>Define undefined constants on import.meta.env when it's a invalid json</h2>
<section class="replace-undefined-constants-on-import-meta-env">
  <p>
    import.meta.env.UNDEFINED <code class="import-meta-env-UNDEFINED"></code>
  </p>
  <p>
    import.meta.env.SOME_IDENTIFIER
    <code class="import-meta-env-SOME_IDENTIFIER"></code>
  </p>
</section>

<h2>Optional values are detected by pattern properly</h2>
<p>
  process?.env?.SOMEVAR
  <code class="optional-env"></code>
</p>

<script>
  // inject __VITE_SOME_IDENTIFIER__ to test if it's replaced
  window.__VITE_SOME_IDENTIFIER__ = true
</script>
<script type="module">
  const __VAR_NAME__ = true // ensure define doesn't replace var name
  text('.exp', typeof __EXP__) // typeof __EXP__ would be `boolean` instead of `string`
  text('.string', __STRING__)
  text('.number', __NUMBER__)
  text('.boolean', __BOOLEAN__)
  text('.undefined', __UNDEFINED__)
  text('.object', JSON.stringify(__OBJ__, null, 2))
  text('.process-node-env', process.env.NODE_ENV)
  text('.process-env', JSON.stringify(process.env, null, 2))
  text('.env-var', process.env.SOMEVAR)
  text('.process-as-property', __OBJ__.process.env.SOMEVAR)
  text(
    '.spread-object',
    JSON.stringify({
      ...(process.env.SOMEVAR ? { SOMEVAR: `"${process.env.SOMEVAR}"` } : {}),
    }),
  )
  text('.spread-array', JSON.stringify([...`"${__STRING__}"`]))
  text('.dollar-identifier', $DOLLAR)
  text('.unicode-identifier', ÖUNICODE_LETTERɵ)

  // make sure these kinds of use are NOT replaced:
  const obj = { [`${'_'}_EXP__`]: true }
  text('.no-property', obj.__EXP__)

  window[`${'_'}_EXP__SUBSTR__`] = true
  text('.no-identifier-substring', __EXP__SUBSTR__)

  import dataJson from './data.json'
  text('.import-json', dataJson.foo)

  function text(el, text) {
    document.querySelector(el).textContent = text
  }

  import { defined } from '@vitejs/test-commonjs-dep'
  text('.define-in-dep', JSON.stringify(defined))

  text('.define-in-environment', JSON.stringify(__DEFINE_IN_ENVIRONMENT__))

  text('.ignores-string-literals .process-env-dot', 'process.env.')
  text(
    '.ignores-string-literals .global-process-env-dot',
    'global.process.env.',
  )
  text(
    '.ignores-string-literals .globalThis-process-env-dot',
    'globalThis.process.env.',
  )
  text('.ignores-string-literals .process-env-NODE_ENV', 'process.env.NODE_ENV')
  text(
    '.ignores-string-literals .global-process-env-NODE_ENV',
    'global.process.env.NODE_ENV',
  )
  text(
    '.ignores-string-literals .globalThis-process-env-NODE_ENV',
    'globalThis.process.env.NODE_ENV',
  )
  text('.ignores-string-literals .import-meta-hot', 'import.meta.hot')

  text(
    '.replaces-constants-in-template-literal-expressions .process-env-dot',
    `${process.env.SOMEVAR}`,
  )
  text(
    '.replaces-constants-in-template-literal-expressions .process-env-NODE_ENV',
    `${process.env.NODE_ENV}`,
  )

  text(
    '.replace-undefined-constants-on-import-meta-env .import-meta-env-UNDEFINED',
    `${import.meta.env.UNDEFINED}`,
  )
  text(
    '.replace-undefined-constants-on-import-meta-env .import-meta-env-SOME_IDENTIFIER',
    `${import.meta.env.SOME_IDENTIFIER}`,
  )

  import optionalEnv from './optional-env.js'
  text('.optional-env', optionalEnv)
</script>

<style>
  .pre {
    display: block;
    unicode-bidi: embed;
    font-family: monospace;
    white-space: pre;
  }
</style>



================================================
FILE: playground/define/optional-env.js
================================================
// separate file to test pattern filter
export default process?.env?.SOMEVAR



================================================
FILE: playground/define/package.json
================================================
{
  "name": "@vitejs/test-define",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-commonjs-dep": "file:./commonjs-dep"
  }
}



================================================
FILE: playground/define/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  define: {
    __EXP__: 'false',
    __STRING__: '"hello"',
    __NUMBER__: 123,
    __BOOLEAN__: true,
    __UNDEFINED__: undefined,
    __OBJ__: {
      foo: 1,
      bar: {
        baz: 2,
      },
      process: {
        env: {
          SOMEVAR: '"PROCESS MAY BE PROPERTY"',
        },
      },
    },
    'process.env.NODE_ENV': '"dev"',
    'process.env.SOMEVAR': '"SOMEVAR"',
    'process.env': {
      NODE_ENV: 'dev',
      SOMEVAR: 'SOMEVAR',
      OTHER: 'works',
    },
    $DOLLAR: 456,
    ÖUNICODE_LETTERɵ: 789,
    __VAR_NAME__: false,
    __STRINGIFIED_OBJ__: JSON.stringify({ foo: true }),
    'import.meta.env.SOME_IDENTIFIER': '__VITE_SOME_IDENTIFIER__',
  },
  environments: {
    client: {
      define: {
        __DEFINE_IN_ENVIRONMENT__: '"defined only in client"',
      },
    },
  },
})



================================================
FILE: playground/define/__tests__/define.spec.ts
================================================
import { expect, test } from 'vitest'
import viteConfig from '../vite.config'
import { page } from '~utils'

const defines = viteConfig.define
const envDefines = viteConfig.environments.client.define

test('string', async () => {
  expect(await page.textContent('.exp')).toBe(
    String(typeof eval(defines.__EXP__)),
  )
  expect(await page.textContent('.string')).toBe(JSON.parse(defines.__STRING__))
  expect(await page.textContent('.number')).toBe(String(defines.__NUMBER__))
  expect(await page.textContent('.boolean')).toBe(String(defines.__BOOLEAN__))
  expect(await page.textContent('.undefined')).toBe('')

  expect(await page.textContent('.object')).toBe(
    JSON.stringify(defines.__OBJ__, null, 2),
  )
  expect(await page.textContent('.process-node-env')).toBe(
    JSON.parse(defines['process.env.NODE_ENV']),
  )
  expect(await page.textContent('.process-env')).toBe(
    JSON.stringify(defines['process.env'], null, 2),
  )
  expect(await page.textContent('.env-var')).toBe(
    JSON.parse(defines['process.env.SOMEVAR']),
  )
  expect(await page.textContent('.process-as-property')).toBe(
    defines.__OBJ__.process.env.SOMEVAR,
  )
  expect(await page.textContent('.spread-object')).toBe(
    JSON.stringify({ SOMEVAR: defines['process.env.SOMEVAR'] }),
  )
  expect(await page.textContent('.spread-array')).toBe(
    JSON.stringify([...defines.__STRING__]),
  )
  expect(await page.textContent('.dollar-identifier')).toBe(
    String(defines.$DOLLAR),
  )
  expect(await page.textContent('.unicode-identifier')).toBe(
    String(defines.ÖUNICODE_LETTERɵ),
  )
  expect(await page.textContent('.no-identifier-substring')).toBe(String(true))
  expect(await page.textContent('.no-property')).toBe(String(true))
  // html wouldn't need to define replacement
  expect(await page.textContent('.exp-define')).toBe('__EXP__')
  expect(await page.textContent('.import-json')).toBe('__EXP__')
  expect(await page.textContent('.define-in-dep')).toBe(
    defines.__STRINGIFIED_OBJ__,
  )
  expect(await page.textContent('.define-in-environment')).toBe(
    envDefines.__DEFINE_IN_ENVIRONMENT__,
  )
})

test('ignores constants in string literals', async () => {
  expect(
    await page.textContent('.ignores-string-literals .process-env-dot'),
  ).toBe('process.env.')
  expect(
    await page.textContent('.ignores-string-literals .global-process-env-dot'),
  ).toBe('global.process.env.')
  expect(
    await page.textContent(
      '.ignores-string-literals .globalThis-process-env-dot',
    ),
  ).toBe('globalThis.process.env.')
  expect(
    await page.textContent('.ignores-string-literals .process-env-NODE_ENV'),
  ).toBe('process.env.NODE_ENV')
  expect(
    await page.textContent(
      '.ignores-string-literals .global-process-env-NODE_ENV',
    ),
  ).toBe('global.process.env.NODE_ENV')
  expect(
    await page.textContent(
      '.ignores-string-literals .globalThis-process-env-NODE_ENV',
    ),
  ).toBe('globalThis.process.env.NODE_ENV')
  expect(
    await page.textContent('.ignores-string-literals .import-meta-hot'),
  ).toBe('import' + '.meta.hot')
})

test('replaces constants in template literal expressions', async () => {
  expect(
    await page.textContent(
      '.replaces-constants-in-template-literal-expressions .process-env-dot',
    ),
  ).toBe(JSON.parse(defines['process.env.SOMEVAR']))
  expect(
    await page.textContent(
      '.replaces-constants-in-template-literal-expressions .process-env-NODE_ENV',
    ),
  ).toBe('dev')
})

test('replace constants on import.meta.env when it is a invalid json', async () => {
  expect(
    await page.textContent(
      '.replace-undefined-constants-on-import-meta-env .import-meta-env-UNDEFINED',
    ),
  ).toBe('undefined')
  expect(
    await page.textContent(
      '.replace-undefined-constants-on-import-meta-env .import-meta-env-SOME_IDENTIFIER',
    ),
  ).toBe('true')
})

test('optional values are detected by pattern properly', async () => {
  expect(await page.textContent('.optional-env')).toBe(
    JSON.parse(defines['process.env.SOMEVAR']),
  )
})



================================================
FILE: playground/define/commonjs-dep/index.js
================================================
module.exports = {
  defined: __STRINGIFIED_OBJ__,
}



================================================
FILE: playground/define/commonjs-dep/package.json
================================================
{
  "name": "@vitejs/test-commonjs-dep",
  "private": true,
  "version": "1.0.0",
  "type": "commonjs"
}



================================================
FILE: playground/dynamic-import/index.html
================================================
<button class="foo">Foo</button>
<button class="bar">Bar</button>
<button class="baz">Baz</button>
<button class="qux">Qux</button>
<button class="mxd">Mxd</button>
<button class="mxd2">Mxd2</button>
<button class="mxdjson">Mxdjson</button>
<button class="issue-2658-1">Issue 2658 - 1</button>
<button class="issue-2658-2">Issue 2658 - 2</button>
<button class="css">css</button>
<button class="pkg-css">pkg-css</button>

<p>dynamic-import-with-vars</p>
<div class="dynamic-import-with-vars">todo</div>

<p>dynamic-import-with-vars-ignored</p>
<div class="dynamic-import-with-vars-ignored">todo</div>

<p>dynamic-import-with-double-slash-ignored</p>
<div class="dynamic-import-with-double-slash-ignored">todo</div>

<p>dynamic-import-with-vars-multiline</p>
<div class="dynamic-import-with-vars-multiline">todo</div>

<p>dynamic-import-with-vars-alias</p>
<div class="dynamic-import-with-vars-alias">todo</div>

<p>dynamic-import-with-vars-raw</p>
<div class="dynamic-import-with-vars-raw">todo</div>

<p>dynamic-import-with-vars-url</p>
<div class="dynamic-import-with-vars-url">todo</div>

<p>dynamic-import-with-vars-worker</p>
<div class="dynamic-import-with-vars-worker">todo</div>

<p>dynamic-import-with-vars-contains-parenthesis</p>
<div class="dynamic-import-with-vars-contains-parenthesis">todo</div>

<div class="view"></div>

<div class="dynamic-import-self"></div>

<div class="dynamic-import-static"></div>

<div class="dynamic-import-nested-self"></div>

<script type="module" src="./nested/index.js"></script>
<script type="module" src="./(app)/nest/index.js"></script>
<style>
  p {
    color: #0088ff;
  }
</style>



================================================
FILE: playground/dynamic-import/package.json
================================================
{
  "name": "@vitejs/test-dynamic-import",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-pkg": "file:./pkg"
  }
}



================================================
FILE: playground/dynamic-import/vite.config.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      name: 'copy',
      writeBundle() {
        fs.mkdirSync(path.resolve(__dirname, 'dist/views'))
        fs.mkdirSync(path.resolve(__dirname, 'dist/files'))
        fs.copyFileSync(
          path.resolve(__dirname, 'views/qux.js'),
          path.resolve(__dirname, 'dist/views/qux.js'),
        )
        fs.copyFileSync(
          path.resolve(__dirname, 'files/mxd.js'),
          path.resolve(__dirname, 'dist/files/mxd.js'),
        )
        fs.copyFileSync(
          path.resolve(__dirname, 'files/mxd.json'),
          path.resolve(__dirname, 'dist/files/mxd.json'),
        )
      },
    },
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'alias'),
    },
  },
  build: {
    sourcemap: true,
  },
})



================================================
FILE: playground/dynamic-import/(app)/main.js
================================================
export function hello() {
  return 'dynamic-import-with-vars-contains-parenthesis'
}



================================================
FILE: playground/dynamic-import/(app)/nest/index.js
================================================
const base = 'main'
import(`../${base}.js`).then((mod) => {
  document.querySelector(
    '.dynamic-import-with-vars-contains-parenthesis',
  ).textContent = mod.hello()
})



================================================
FILE: playground/dynamic-import/__tests__/dynamic-import.spec.ts
================================================
import { expect, test } from 'vitest'
import {
  browserLogs,
  findAssetFile,
  getColor,
  isBuild,
  page,
  serverLogs,
} from '~utils'

test('should load literal dynamic import', async () => {
  await page.click('.baz')
  await expect.poll(() => page.textContent('.view')).toMatch('Baz view')
})

test('should load full dynamic import from public', async () => {
  await page.click('.qux')
  await expect.poll(() => page.textContent('.view')).toMatch('Qux view')
  // No warning should be logged as we are using @vite-ignore
  expect(
    serverLogs.some((log) => log.includes('cannot be analyzed by vite')),
  ).toBe(false)
})

test('should load data URL of `blob:`', async () => {
  await page.click('.issue-2658-1')
  await expect.poll(() => page.textContent('.view')).toMatch('blob')
})

test('should load data URL of `data:`', async () => {
  await page.click('.issue-2658-2')
  await expect.poll(() => page.textContent('.view')).toMatch('data')
})

test('should have same reference on static and dynamic js import, .mxd', async () => {
  await page.click('.mxd')
  await expect.poll(() => page.textContent('.view')).toMatch('true')
})

// in this case, it is not possible to detect the correct module
test('should have same reference on static and dynamic js import, .mxd2', async () => {
  await page.click('.mxd2')
  await expect.poll(() => page.textContent('.view')).toMatch('false')
})

test('should have same reference on static and dynamic js import, .mxdjson', async () => {
  await page.click('.mxdjson')
  await expect.poll(() => page.textContent('.view')).toMatch('true')
})

// since this test has a timeout, it should be put last so that it
// does not bleed on the last
test('should load dynamic import with vars', async () => {
  await page.click('.foo')
  await expect.poll(() => page.textContent('.view')).toMatch('Foo view')

  await page.click('.bar')
  await expect.poll(() => page.textContent('.view')).toMatch('Bar view')
})

// dynamic import css
test('should load dynamic import with css', async () => {
  await page.click('.css')
  await expect.poll(() => getColor('.view')).toBe('red')
})

test('should load dynamic import with vars', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars'))
    .toMatch('hello')
})

test('should load dynamic import with vars ignored', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-ignored'))
    .toMatch('hello')
  // No warning should be logged as we are using @vite-ignore
  expect(
    serverLogs.some((log) =>
      log.includes('"https" has been externalized for browser compatibility'),
    ),
  ).toBe(false)
})

test('should load dynamic import with double slash ignored', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-double-slash-ignored'))
    .toMatch('hello')
})

test('should load dynamic import with vars multiline', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-multiline'))
    .toMatch('hello')
})

test('should load dynamic import with vars alias', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-alias'))
    .toMatch('hi')
})

test('should load dynamic import with vars raw', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-raw'))
    .toMatch('export function hello()')
})

test('should load dynamic import with vars url', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-url'))
    .toMatch(isBuild ? 'data:text/javascript' : '/alias/url.js')
})

test('should load dynamic import with vars worker', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-with-vars-worker'))
    .toMatch('load worker')
})

test('should load dynamic import with css in package', async () => {
  await page.click('.pkg-css')
  await expect.poll(() => getColor('.pkg-css')).toBe('blue')
})

test('should work with load ../ and itself directory', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-self'))
    .toMatch('dynamic-import-self-content')
})

test('should work with load ../ and contain itself directory', async () => {
  await expect
    .poll(() => page.textContent('.dynamic-import-nested-self'))
    .toMatch('dynamic-import-nested-self-content')
})

test('should work a load path that contains parentheses.', async () => {
  await expect
    .poll(() =>
      page.textContent('.dynamic-import-with-vars-contains-parenthesis'),
    )
    .toMatch('dynamic-import-with-vars-contains-parenthesis')
})

test.runIf(isBuild)(
  'should rollup warn when static and dynamic import a module in same chunk',
  async () => {
    const log = serverLogs.join('\n')
    expect(log).toContain(
      'dynamic import will not move module into another chunk',
    )
    expect(log).toMatch(
      /\(!\).*\/dynamic-import\/files\/mxd\.js is dynamically imported by/,
    )
    expect(log).toMatch(
      /\(!\).*\/dynamic-import\/files\/mxd\.json is dynamically imported by/,
    )
    expect(log).not.toMatch(
      /\(!\).*\/dynamic-import\/nested\/shared\.js is dynamically imported by/,
    )
  },
)

test('dynamic import treeshaken log', async () => {
  const log = browserLogs.join('\n')
  expect(log).toContain('treeshaken foo')
  expect(log).toContain('treeshaken bar')
  expect(log).toContain('treeshaken baz1')
  expect(log).toContain('treeshaken baz2')
  expect(log).toContain('treeshaken baz3')
  expect(log).toContain('treeshaken baz4')
  expect(log).toContain('treeshaken baz5')
  expect(log).toContain('treeshaken baz6')
  expect(log).toContain('treeshaken default')

  expect(log).not.toContain('treeshaken removed')
})

test('dynamic import syntax parsing', async () => {
  const log = browserLogs.join('\n')
  expect(log).toContain('treeshaken syntax foo')
  expect(log).toContain('treeshaken syntax default')
})

test.runIf(isBuild)('dynamic import treeshaken file', async () => {
  expect(findAssetFile(/treeshaken.+\.js$/)).not.toContain('treeshaken removed')
})

test.runIf(isBuild)('should not preload for non-analyzable urls', () => {
  const js = findAssetFile(/index-[-\w]{8}\.js$/)
  // should match e.g. await import(e.jss);o(".view",p===i)
  expect(js).to.match(/\.jss\);/)
})



================================================
FILE: playground/dynamic-import/alias/hello.js
================================================
export function hello() {
  return 'hello'
}
console.log('hello.js')



================================================
FILE: playground/dynamic-import/alias/hi.js
================================================
export function hi() {
  return 'hi'
}
console.log('hi.js')



================================================
FILE: playground/dynamic-import/alias/url.js
================================================
export const url = 'load url'



================================================
FILE: playground/dynamic-import/alias/worker.js
================================================
self.onmessage = (event) => {
  self.postMessage({
    msg: 'load worker',
  })
}



================================================
FILE: playground/dynamic-import/css/index.css
================================================
.css {
  box-sizing: border-box;
}
.view {
  color: red;
}



================================================
FILE: playground/dynamic-import/files/mxd.js
================================================
export default function () {}



================================================
FILE: playground/dynamic-import/files/mxd.json
================================================
{}



================================================
FILE: playground/dynamic-import/nested/deps.js
================================================
/* don't include dynamic import inside this file */

import '@vitejs/test-pkg'



================================================
FILE: playground/dynamic-import/nested/hello.js
================================================
export function hello() {
  return 'hello'
}



================================================
FILE: playground/dynamic-import/nested/index.js
================================================
import mxdStatic from '../files/mxd'
import mxdStaticJSON from '../files/mxd.json'

async function setView(view) {
  const { msg } = await import(`../views/${view}.js`)
  text('.view', msg)
}

;['foo', 'bar'].forEach((id) => {
  document.querySelector(`.${id}`).addEventListener('click', () => setView(id))
})

// literal dynamic
document.querySelector('.baz').addEventListener('click', async () => {
  const { msg } = await import('../views/baz.js')
  text('.view', msg)
})

// full dynamic
const arr = ['qux.js']
const view = `/views/${arr[0]}`
document.querySelector('.qux').addEventListener('click', async () => {
  const { msg } = await import(/*@vite-ignore*/ view)
  text('.view', msg)
})

// mixed static and dynamic
document.querySelector('.mxd').addEventListener('click', async () => {
  const view = 'mxd'
  const { default: mxdDynamic } = await import(`../files/${view}.js`)
  text('.view', mxdStatic === mxdDynamic)
})

document.querySelector('.mxd2').addEventListener('click', async () => {
  const test = { jss: '../files/mxd.js' }
  const ttest = test
  const view = 'mxd'
  const { default: mxdDynamic } = await import(/*@vite-ignore*/ test.jss)
  text('.view', mxdStatic === mxdDynamic)
})

document.querySelector('.mxdjson').addEventListener('click', async () => {
  const view = 'mxd'
  const { default: mxdDynamicJSON } = await import(`../files/${view}.json`)
  text('.view', mxdStaticJSON === mxdDynamicJSON)
})

// data URLs (`blob:`)
const code1 = 'export const msg = "blob"'
const blob = new Blob([code1], { type: 'text/javascript;charset=UTF-8' })
const blobURL = URL.createObjectURL(blob)
document.querySelector('.issue-2658-1').addEventListener('click', async () => {
  const { msg } = await import(/*@vite-ignore*/ blobURL)
  text('.view', msg)
})

// data URLs (`data:`)
const code2 = 'export const msg = "data";'
const dataURL = `data:text/javascript;charset=utf-8,${encodeURIComponent(
  code2,
)}`
document.querySelector('.issue-2658-2').addEventListener('click', async () => {
  const { msg } = await import(/*@vite-ignore*/ dataURL)
  text('.view', msg)
})

document.querySelector('.css').addEventListener('click', async () => {
  await import('../css/index.css')
  text('.view', 'dynamic import css')
})

document.querySelector('.pkg-css').addEventListener('click', async () => {
  await import('./deps')
  text('.view', 'dynamic import css in package')
})

function text(el, text) {
  document.querySelector(el).textContent = text
}

let base = 'hello'

import(`../alias/${base}.js`).then((mod) => {
  text('.dynamic-import-with-vars', mod.hello())
})

import(/*@vite-ignore*/ `https://localhost`).catch((mod) => {
  console.log(mod)
  text('.dynamic-import-with-vars-ignored', 'hello')
})

import(/*@vite-ignore*/ `https://localhost//${'test'}`).catch((mod) => {
  console.log(mod)
  text('.dynamic-import-with-double-slash-ignored', 'hello')
})

// prettier-ignore
import(
  /* this messes with */
  `../alias/${base}.js`
  /* es-module-lexer */
).then((mod) => {
  text('.dynamic-import-with-vars-multiline', mod.hello())
})

import(`../alias/${base}.js?raw`).then((mod) => {
  text('.dynamic-import-with-vars-raw', JSON.stringify(mod))
})

base = 'url'
import(`../alias/${base}.js?url`).then((mod) => {
  text('.dynamic-import-with-vars-url', JSON.stringify(mod))
})

base = 'worker'
import(`../alias/${base}.js?worker`).then((workerMod) => {
  const worker = new workerMod.default()
  worker.postMessage('1')
  worker.addEventListener('message', (ev) => {
    console.log(ev)
    text('.dynamic-import-with-vars-worker', JSON.stringify(ev.data))
  })
})

base = 'hi'
import(`@/${base}.js`).then((mod) => {
  text('.dynamic-import-with-vars-alias', mod.hi())
})

base = 'self'
import(`../nested/${base}.js`).then((mod) => {
  text('.dynamic-import-self', mod.self)
})

import(`../nested/nested/${base}.js`).then((mod) => {
  text('.dynamic-import-nested-self', mod.self)
})
;(async function () {
  const { foo } = await import('./treeshaken/treeshaken.js')
  const { bar, default: tree } = await import('./treeshaken/treeshaken.js')
  const default2 = (await import('./treeshaken/treeshaken.js')).default
  const baz1 = (await import('./treeshaken/treeshaken.js')).baz1
  const baz2 = (await import('./treeshaken/treeshaken.js')).baz2.log
  const baz3 = (await import('./treeshaken/treeshaken.js')).baz3?.log
  const baz4 = await import('./treeshaken/treeshaken.js').then(
    ({ baz4 }) => baz4,
  )
  const baz5 = await import('./treeshaken/treeshaken.js').then(function ({
      baz5,
    }) {
      return baz5
    }),
    { baz6 } = await import('./treeshaken/treeshaken.js')
  foo()
  bar()
  tree()
  ;(await import('./treeshaken/treeshaken.js')).default()
  default2()
  baz1()
  baz2()
  baz3()
  baz4()
  baz5()
  baz6()
})()
// Test syntax parsing only
;(async function () {
  const default1 = await import('./treeshaken/syntax.js').then(
    (mod) => mod.default,
  )
  const default2 = (await import('./treeshaken/syntax.js')).default,
    other = () => {}
  const foo = await import('./treeshaken/syntax.js').then((mod) => mod.foo)
  const foo2 = await import('./treeshaken/syntax.js').then(
    ({ foo = {} }) => foo,
  )
  const foo3 = await import('./treeshaken/syntax.js').then((m) => m.foo)
  const e = ('' + window.doesntExist)[3] // to disallow minifier to constant fold
  const foo4 = await import('./treeshaken/syntax.js')[`th${e}n`]((m) => m.foo)
  await import('./treeshaken/syntax.js').then((mod) => mod.foo({ foo }))
  const obj = [
    '',
    {
      async lazy() {
        const { foo } = await import('./treeshaken/treeshaken.js')
        return { foo: aaa(foo) }
      },
    },
  ]
  default1()
  default2()
  other()
  foo()
  foo2()
  foo3()
  foo4()
  obj[1].lazy()
})()

import(`../nested/static.js`).then((mod) => {
  text('.dynamic-import-static', mod.self)
})

console.log('index.js')



================================================
FILE: playground/dynamic-import/nested/self.js
================================================
export const self = 'dynamic-import-self-content'



================================================
FILE: playground/dynamic-import/nested/shared.js
================================================
export const n = 1



================================================
FILE: playground/dynamic-import/nested/static.js
================================================
export const self = 'dynamic-import-static'



================================================
FILE: playground/dynamic-import/nested/nested/self.js
================================================
export const self = 'dynamic-import-nested-self-content'



================================================
FILE: playground/dynamic-import/nested/treeshaken/syntax.js
================================================
export const foo = () => {
  console.log('treeshaken syntax foo')
}
export default () => {
  console.log('treeshaken syntax default')
}



================================================
FILE: playground/dynamic-import/nested/treeshaken/treeshaken.js
================================================
export const foo = () => {
  console.log('treeshaken foo')
}
export const bar = () => {
  console.log('treeshaken bar')
}
export const baz1 = () => {
  console.log('treeshaken baz1')
}
export const baz2 = {
  log: () => {
    console.log('treeshaken baz2')
  },
}
export const baz3 = {
  log: () => {
    console.log('treeshaken baz3')
  },
}
export const baz4 = () => {
  console.log('treeshaken baz4')
}
export const baz5 = () => {
  console.log('treeshaken baz5')
}
export const baz6 = () => {
  console.log('treeshaken baz6')
}
export const removed = () => {
  console.log('treeshaken removed')
}
export default () => {
  console.log('treeshaken default')
}



================================================
FILE: playground/dynamic-import/views/bar.js
================================================
export const msg = 'Bar view'



================================================
FILE: playground/dynamic-import/views/baz.js
================================================
import { n } from '../nested/shared'
console.log('baz' + n)

export const msg = 'Baz view'



================================================
FILE: playground/dynamic-import/views/foo.js
================================================
import { n } from '../nested/shared'
console.log('foo' + n)

export const msg = 'Foo view'



================================================
FILE: playground/dynamic-import/views/qux.js
================================================
export const msg = 'Qux view'



================================================
FILE: playground/dynamic-import-inline/index.html
================================================
<script type="module" src="./src/index.js"></script>



================================================
FILE: playground/dynamic-import-inline/package.json
================================================
{
  "name": "@vitejs/test-dynamic-import-inline",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/dynamic-import-inline/vite.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'alias'),
    },
  },
  build: {
    sourcemap: true,
    rollupOptions: {
      output: {
        inlineDynamicImports: true,
      },
    },
  },
})



================================================
FILE: playground/dynamic-import-inline/__tests__/dynamic-import-inline.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, serverLogs } from '~utils'

test.runIf(isBuild)(
  "don't warn when inlineDynamicImports is set to true",
  async () => {
    const log = serverLogs.join('\n')
    expect(log).not.toContain(
      'dynamic import will not move module into another chunk',
    )
  },
)



================================================
FILE: playground/dynamic-import-inline/src/foo.js
================================================
export default function foo() {
  return 'foo'
}



================================================
FILE: playground/dynamic-import-inline/src/index.js
================================================
import foo from './foo'

const asyncImport = async () => {
  const { foo } = await import('./foo.js')
  foo()
}

foo()
asyncImport()



================================================
FILE: playground/env-nested/index.html
================================================
<h1>Nested Environment Variables</h1>
<p>import.meta.env.MODE: <code class="mode"></code></p>
<p>
  import.meta.env.VITE_EFFECTIVE_MODE_FILE_NAME: <code class="mode-file"></code>
</p>
<p>Empty import.meta.env.VITE_PARENT_ENV: <code class="parent-env"></code></p>

<script type="module">
  text('.mode', import.meta.env.MODE)
  text('.mode-file', import.meta.env.VITE_EFFECTIVE_MODE_FILE_NAME)
  text('.parent-env', import.meta.env.VITE_PARENT_ENV)

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/env-nested/package.json
================================================
{
  "name": "@vitejs/test-env-nested",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/env-nested/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  envDir: './envs',
})



================================================
FILE: playground/env-nested/__tests__/env-nested.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page } from '~utils'

const mode = isBuild ? `production` : `development`

test('mode', async () => {
  expect(await page.textContent('.mode')).toBe(mode)
})

test('mode file override', async () => {
  expect(await page.textContent('.mode-file')).toBe(`.env.${mode}`)
})

test('should not load parent .env file', async () => {
  expect(await page.textContent('.parent-env')).not.toBe('dont_load_me')
})



================================================
FILE: playground/env-nested/envs/.env.development
================================================
VITE_EFFECTIVE_MODE_FILE_NAME=.env.development



================================================
FILE: playground/env-nested/envs/.env.production
================================================
VITE_EFFECTIVE_MODE_FILE_NAME=.env.production



================================================
FILE: playground/environment-react-ssr/index.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>environment-react-ssr</title>
    <meta
      name="viewport"
      content="width=device-width, height=device-height, initial-scale=1.0"
    />
  </head>
  <body>
    <script src="/src/entry-client" type="module"></script>
  </body>
</html>



================================================
FILE: playground/environment-react-ssr/package.json
================================================
{
  "name": "@vitejs/test-environment-react-ssr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build --app",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "react": "^19.1.1",
    "react-fake-client": "npm:react@^19.1.1",
    "react-fake-server": "npm:react@^19.1.1",
    "react-dom": "^19.1.1"
  }
}



================================================
FILE: playground/environment-react-ssr/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "include": ["src"],
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}



================================================
FILE: playground/environment-react-ssr/vite.config.ts
================================================
import {
  type Connect,
  type Plugin,
  type PluginOption,
  createServerModuleRunner,
  defineConfig,
} from 'vite'

export default defineConfig((env) => ({
  clearScreen: false,
  appType: 'custom',
  plugins: [
    vitePluginSsrMiddleware({
      entry: '/src/entry-server',
      preview: new URL('./dist/server/index.js', import.meta.url).toString(),
    }),
    {
      name: 'global-server',
      configureServer(server) {
        Object.assign(globalThis, { __globalServer: server })
      },
    },
    {
      name: 'build-client',
      async buildApp(builder) {
        await builder.build(builder.environments.client)
      },
    },
  ],
  resolve: {
    noExternal: true,
  },
  environments: {
    client: {
      build: {
        minify: false,
        sourcemap: true,
        outDir: 'dist/client',
      },
    },
    ssr: {
      optimizeDeps: {
        noDiscovery: false,
      },
      build: {
        outDir: 'dist/server',
        // [feedback]
        // is this still meant to be used?
        // for example, `ssr: true` seems to make `minify: false` automatically
        // and also externalization.
        ssr: true,
        rollupOptions: {
          input: {
            index: '/src/entry-server',
          },
        },
      },
    },
  },

  builder: {
    async buildApp(builder) {
      if (!builder.environments.client.isBuilt) {
        throw new Error('Client environment should be built first')
      }
      await builder.build(builder.environments.ssr)
    },
  },
}))

// vavite-style ssr middleware plugin
export function vitePluginSsrMiddleware({
  entry,
  preview,
}: {
  entry: string
  preview?: string
}): PluginOption {
  const plugin: Plugin = {
    name: vitePluginSsrMiddleware.name,

    configureServer(server) {
      const runner = createServerModuleRunner(server.environments.ssr, {
        hmr: { logger: false },
      })
      const importWithRetry = async () => {
        try {
          return await runner.import(entry)
        } catch (e) {
          if (
            e instanceof Error &&
            (e as any).code === 'ERR_OUTDATED_OPTIMIZED_DEP'
          ) {
            runner.clearCache()
            return await importWithRetry()
          }
          throw e
        }
      }
      const handler: Connect.NextHandleFunction = async (req, res, next) => {
        try {
          const mod = await importWithRetry()
          await mod['default'](req, res, next)
        } catch (e) {
          next(e)
        }
      }
      return () => server.middlewares.use(handler)
    },

    async configurePreviewServer(server) {
      if (preview) {
        const mod = await import(preview)
        return () => server.middlewares.use(mod.default)
      }
      return
    },
  }
  return [plugin]
}



================================================
FILE: playground/environment-react-ssr/__tests__/environment-react-ssr.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { stripVTControlCharacters } from 'node:util'
import { describe, expect, onTestFinished, test } from 'vitest'
import {
  isBuild,
  page,
  readDepOptimizationMetadata,
  readFile,
  serverLogs,
  testDir,
} from '~utils'

test('basic', async () => {
  await page.getByText('hydrated: true').isVisible()
  await page.getByText('Count: 0').isVisible()
  await page.getByRole('button', { name: '+' }).click()
  await page.getByText('Count: 1').isVisible()
})

describe.runIf(!isBuild)('pre-bundling', () => {
  test('client', async () => {
    const metaJson = readDepOptimizationMetadata()

    expect(metaJson.optimized['react']).toBeTruthy()
    expect(metaJson.optimized['react-dom/client']).toBeTruthy()
    expect(metaJson.optimized['react/jsx-dev-runtime']).toBeTruthy()

    expect(metaJson.optimized['react-dom/server']).toBeFalsy()
  })

  test('ssr', async () => {
    const metaJson = readDepOptimizationMetadata('ssr')

    expect(metaJson.optimized['react']).toBeTruthy()
    expect(metaJson.optimized['react-dom/server']).toBeTruthy()
    expect(metaJson.optimized['react/jsx-dev-runtime']).toBeTruthy()

    expect(metaJson.optimized['react-dom/client']).toBeFalsy()

    // process.env.NODE_ENV should be kept as keepProcessEnv is true
    const depsFiles = fs
      .readdirSync(path.resolve(testDir, 'node_modules/.vite/deps_ssr'), {
        withFileTypes: true,
      })
      .filter((file) => file.isFile() && file.name.endsWith('.js'))
      .map((file) => path.join(file.parentPath, file.name))
    const depsFilesWithProcessEnvNodeEnv = depsFiles.filter((file) =>
      fs.readFileSync(file, 'utf-8').includes('process.env.NODE_ENV'),
    )

    expect(depsFilesWithProcessEnvNodeEnv.length).toBeGreaterThan(0)
  })

  test('deps reload', async () => {
    const envs = ['client', 'server'] as const

    const clientMeta = readDepOptimizationMetadata('client')
    const ssrMeta = readDepOptimizationMetadata('ssr')
    expect(clientMeta.optimized['react-fake-client']).toBeFalsy()
    expect(clientMeta.optimized['react-fake-server']).toBeFalsy()
    expect(ssrMeta.optimized['react-fake-server']).toBeFalsy()
    expect(ssrMeta.optimized['react-fake-client']).toBeFalsy()

    envs.forEach((env) => {
      const filePath = path.resolve(testDir, `src/entry-${env}.tsx`)
      const originalContent = readFile(filePath)
      fs.writeFileSync(
        filePath,
        `import 'react-fake-${env}'\n${originalContent}`,
        'utf-8',
      )
      onTestFinished(() => {
        fs.writeFileSync(filePath, originalContent, 'utf-8')
      })
    })

    await expect
      .poll(() =>
        serverLogs
          .map(
            (log) =>
              stripVTControlCharacters(log).match(
                /new dependencies optimized: (react-fake-.*)/,
              )?.[1],
          )
          .filter(Boolean),
      )
      .toStrictEqual(['react-fake-server', 'react-fake-client'])

    const clientMetaNew = readDepOptimizationMetadata('client')
    const ssrMetaNew = readDepOptimizationMetadata('ssr')
    expect(clientMetaNew.optimized['react-fake-client']).toBeTruthy()
    expect(clientMetaNew.optimized['react-fake-server']).toBeFalsy()
    expect(ssrMetaNew.optimized['react-fake-server']).toBeTruthy()
    expect(ssrMetaNew.optimized['react-fake-client']).toBeFalsy()
  })
})



================================================
FILE: playground/environment-react-ssr/src/entry-client.tsx
================================================
import ReactDomClient from 'react-dom/client'
import React from 'react'
import Root from './root'

async function main() {
  const el = document.getElementById('root')
  React.startTransition(() => {
    ReactDomClient.hydrateRoot(el!, <Root />)
  })
}

main()



================================================
FILE: playground/environment-react-ssr/src/entry-server.tsx
================================================
import ReactDomServer from 'react-dom/server'
import type { Connect, ViteDevServer } from 'vite'
import Root from './root'

const handler: Connect.NextHandleFunction = async (_req, res) => {
  const ssrHtml = ReactDomServer.renderToString(<Root />)
  let html = await importHtml()
  html = html.replace(/<body>/, `<body><div id="root">${ssrHtml}</div>`)
  res.setHeader('content-type', 'text/html').end(html)
}

export default handler

declare let __globalServer: ViteDevServer

async function importHtml() {
  if (import.meta.env.DEV) {
    const mod = await import('/index.html?raw')
    return __globalServer.transformIndexHtml('/', mod.default)
  } else {
    const mod = await import('/dist/client/index.html?raw')
    return mod.default
  }
}



================================================
FILE: playground/environment-react-ssr/src/root.tsx
================================================
import React from 'react'

export default function Root() {
  const [count, setCount] = React.useState(0)

  const [hydrated, setHydrated] = React.useState(false)
  React.useEffect(() => {
    setHydrated(true)
  }, [])

  return (
    <div>
      <div>hydrated: {String(hydrated)}</div>
      <div>Count: {count}</div>
      <button onClick={() => setCount((v) => v - 1)}>-1</button>
      <button onClick={() => setCount((v) => v + 1)}>+1</button>
    </div>
  )
}



================================================
FILE: playground/extensions/index.html
================================================
<div id="app">Hello Vite!</div>

<script type="module">
  import { createApp } from 'vue'
  createApp({ template: 'Hello Vite!' }).mount('#app')
</script>



================================================
FILE: playground/extensions/package.json
================================================
{
  "name": "@vitejs/test-extensions",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.5.18"
  }
}



================================================
FILE: playground/extensions/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  resolve: {
    alias: [{ find: 'vue', replacement: 'vue/dist/vue.esm-bundler.js' }],
    extensions: ['.js'],
  },
})



================================================
FILE: playground/extensions/__tests__/extensions.spec.ts
================================================
import { expect, test } from 'vitest'
import { browserLogs, page } from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

test('not contain `.mjs`', async () => {
  const appHtml = await page.content()
  expect(appHtml).toMatch('Hello Vite!')
})



================================================
FILE: playground/external/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
    <script type="importmap">
      {
        "imports": {
          "vue": "/vue@3.4.38.js",
          "slash5": "/slash@5.js",
          "slash3": "/slash@3.0.0.js"
        }
      }
    </script>
  </head>
  <body>
    <p>Imported Vue version: <span id="imported-vue-version"></span></p>
    <p>Required Vue version: <span id="required-vue-version"></span></p>
    <p>Imported slash5 exists: <span id="imported-slash5-exists"></span></p>
    <p>Imported slash3 exists: <span id="imported-slash3-exists"></span></p>
    <p>Required slash3 exists: <span id="required-slash3-exists"></span></p>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: playground/external/package.json
================================================
{
  "name": "@vitejs/test-external",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-dep-that-imports": "file:./dep-that-imports",
    "@vitejs/test-dep-that-requires": "file:./dep-that-requires"
  },
  "devDependencies": {
    "slash3": "npm:slash@^3.0.0",
    "slash5": "npm:slash@^5.1.0",
    "vite": "workspace:*",
    "vue": "^3.5.18",
    "vue34": "npm:vue@~3.4.38"
  }
}



================================================
FILE: playground/external/vite.config.js
================================================
import fs from 'node:fs/promises'
import { defineConfig } from 'vite'

const npmDirectServeConfig = {
  '/vue@3.4.38.js': 'vue34/dist/vue.runtime.esm-browser.js',
  '/slash@5.js': 'slash5/index.js',
}
/** @type {import('vite').Connect.NextHandleFunction} */
const serveNpmCodeDirectlyMiddleware = async (req, res, next) => {
  for (const [url, file] of Object.entries(npmDirectServeConfig)) {
    if (req.originalUrl === url) {
      const code = await fs.readFile(
        new URL(`./node_modules/${file}`, import.meta.url),
      )
      res.setHeader('Content-Type', 'text/javascript')
      res.end(code)
      return
    }
  }
  next()
}

export default defineConfig({
  optimizeDeps: {
    include: ['dep-that-imports', 'dep-that-requires'],
    exclude: ['vue', 'slash5'],
  },
  build: {
    minify: false,
    rollupOptions: {
      external: ['vue', 'slash3', 'slash5'],
    },
    commonjsOptions: {
      esmExternals: ['vue', 'slash5'],
      dynamicRequireTargets: ['test-no-op-fdir-glob'],
    },
  },
  plugins: [
    {
      name: 'serve-npm-code-directly',
      configureServer({ middlewares }) {
        middlewares.use(serveNpmCodeDirectlyMiddleware)
      },
      configurePreviewServer({ middlewares }) {
        middlewares.use(serveNpmCodeDirectlyMiddleware)
      },
    },
  ],
})



================================================
FILE: playground/external/__tests__/external.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { browserLogs, isBuild, page } from '~utils'

test('importmap', () => {
  expect(browserLogs).not.toContain(
    'An import map is added after module script load was triggered.',
  )
})

test('should have default exports', async () => {
  expect(await page.textContent('#imported-slash5-exists')).toBe('true')
  expect(await page.textContent('#imported-slash3-exists')).toBe('true')
  expect(await page.textContent('#required-slash3-exists')).toBe('true')
})

describe.runIf(isBuild)('build', () => {
  test('should externalize imported packages', async () => {
    // If `vue` is successfully externalized, the page should use the version from the import map
    expect(await page.textContent('#imported-vue-version')).toBe('3.4.38')
  })

  test('should externalize required packages', async () => {
    // If `vue` is successfully externalized, the page should use the version from the import map
    expect(await page.textContent('#required-vue-version')).toBe('3.4.38')
  })
})



================================================
FILE: playground/external/dep-that-imports/index.js
================================================
import { version } from 'vue'
import slash5 from 'slash5'
import slash3 from 'slash3'

document.querySelector('#imported-vue-version').textContent = version
document.querySelector('#imported-slash5-exists').textContent =
  !!slash5('foo/bar')
document.querySelector('#imported-slash3-exists').textContent =
  !!slash3('foo/bar')



================================================
FILE: playground/external/dep-that-imports/package.json
================================================
{
  "name": "@vitejs/test-dep-that-imports",
  "private": true,
  "version": "0.0.0",
  "dependencies": {
    "slash3": "npm:slash@^3.0.0",
    "slash5": "npm:slash@^5.1.0",
    "vue": "^3.5.18"
  }
}



================================================
FILE: playground/external/dep-that-requires/index.js
================================================
const { version } = require('vue')
// require('slash5') // cannot require ESM
const slash3 = require('slash3')

document.querySelector('#required-vue-version').textContent = version
document.querySelector('#required-slash3-exists').textContent =
  !!slash3('foo/bar')



================================================
FILE: playground/external/dep-that-requires/package.json
================================================
{
  "name": "@vitejs/test-dep-that-requires",
  "private": true,
  "version": "0.0.0",
  "dependencies": {
    "slash3": "npm:slash@^3.0.0",
    "slash5": "npm:slash@^5.1.0",
    "vue": "^3.5.18"
  }
}



================================================
FILE: playground/external/public/slash@3.0.0.js
================================================
/* eslint-disable */
// copied from https://esm.sh/v133/slash@3.0.0/es2022/slash.mjs to reduce network issues in CI

/* esm.sh - esbuild bundle(slash@3.0.0) es2022 production */
var a=Object.create;var d=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var A=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),E=(e,t)=>{for(var r in t)d(e,r,{get:t[r],enumerable:!0})},u=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of x(t))!p.call(e,n)&&n!==r&&d(e,n,{get:()=>t[n],enumerable:!(i=m(t,n))||i.enumerable});return e},o=(e,t,r)=>(u(e,t,"default"),r&&u(r,t,"default")),c=(e,t,r)=>(r=e!=null?a(g(e)):{},u(t||!e||!e.__esModule?d(r,"default",{value:e,enumerable:!0}):r,e));var f=A((h,_)=>{"use strict";_.exports=e=>{let t=/^\\\\\?\\/.test(e),r=/[^\u0000-\u0080]+/.test(e);return t||r?e:e.replace(/\\/g,"/")}});var s={};E(s,{default:()=>P});var L=c(f());o(s,c(f()));var{default:l,...N}=L,P=l!==void 0?l:N;export{P as default};



================================================
FILE: playground/external/src/main.js
================================================
import '@vitejs/test-dep-that-imports'
import '@vitejs/test-dep-that-requires'



================================================
FILE: playground/fs-serve/entry.js
================================================
import { msg } from './nested/foo'

export const fullmsg = msg + 'bar'

document.querySelector('.nested-entry').textContent = fullmsg



================================================
FILE: playground/fs-serve/package.json
================================================
{
  "name": "@vitejs/test-fs-serve",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite root",
    "build": "vite build root",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview root",
    "dev:base": "vite root --config ./root/vite.config-base.js",
    "build:base": "vite build root --config ./root/vite.config-base.js",
    "preview:base": "vite preview root --config ./root/vite.config-base.js",
    "dev:deny": "vite root --config ./root/vite.config-deny.js",
    "build:deny": "vite build root --config ./root/vite.config-deny.js",
    "preview:deny": "vite preview root --config ./root/vite.config-deny.js"
  },
  "devDependencies": {
    "ws": "^8.18.3"
  }
}



================================================
FILE: playground/fs-serve/safe.json
================================================
{
  "msg": "safe"
}



================================================
FILE: playground/fs-serve/unsafe.json
================================================
{
  "msg": "unsafe"
}



================================================
FILE: playground/fs-serve/__tests__/fs-serve.spec.ts
================================================
import net from 'node:net'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import http from 'node:http'
import {
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  test,
} from 'vitest'
import type { Page } from 'playwright-chromium'
import WebSocket from 'ws'
import testJSON from '../safe.json'
import { browser, isServe, page, viteServer, viteTestUrl } from '~utils'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const getViteTestIndexHtmlUrl = () => {
  const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'
  // NOTE: viteTestUrl is set lazily
  return viteTestUrl + srcPrefix + 'src/'
}

const stringified = JSON.stringify(testJSON)

describe.runIf(isServe)('main', () => {
  beforeAll(async () => {
    await page.goto(getViteTestIndexHtmlUrl())
  })

  test('default import', async () => {
    await expect.poll(() => page.textContent('.full')).toBe(stringified)
  })

  test('named import', async () => {
    await expect.poll(() => page.textContent('.named')).toBe(testJSON.msg)
  })

  test('virtual svg module', async () => {
    await expect.poll(() => page.textContent('.virtual-svg')).toMatch('<svg')
  })

  test('safe fetch', async () => {
    await expect.poll(() => page.textContent('.safe-fetch')).toMatch('KEY=safe')
    await expect.poll(() => page.textContent('.safe-fetch-status')).toBe('200')
  })

  test('safe fetch with query', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-query'))
      .toMatch('KEY=safe')
    await expect
      .poll(() => page.textContent('.safe-fetch-query-status'))
      .toBe('200')
  })

  test('safe fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-subdir-special-characters'))
      .toMatch('KEY=safe')
    await expect
      .poll(() =>
        page.textContent('.safe-fetch-subdir-special-characters-status'),
      )
      .toBe('200')
  })

  test('unsafe fetch', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch'))
      .toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-status'))
      .toBe('403')
  })

  test('unsafe fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fetch with special characters 2 (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498-2')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fetch raw query import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-raw-query-import-status'))
      .toBe('403')
  })

  test('unsafe fetch ?.svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-query-dot-svg-import-status'))
      .toBe('403')
  })

  test('unsafe fetch .svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-svg-status'))
      .toBe('403')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-status'))
      .toBe('200')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query-status'))
      .toBe('200')
  })

  test('safe fs fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters-status'))
      .toBe('200')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-status'))
      .toBe('403')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-raw')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 1', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 2', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2-status'))
      .toBe('403')
  })

  test('unsafe fs fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fs fetch with special characters 2 (#8498)', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fs fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fs fetch import inline wasm init', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-import-inline-wasm-init-status'),
      )
      .toBe('403')
  })

  test('unsafe fs fetch with relative path after query status', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-relative-path-after-query-status'),
      )
      .toBe('404')
  })

  test('nested entry', async () => {
    await expect.poll(() => page.textContent('.nested-entry')).toBe('foobar')
  })

  test('denied', async () => {
    await expect.poll(() => page.textContent('.unsafe-dotenv')).toBe('403')
  })

  test('denied EnV casing', async () => {
    // It is 403 in case insensitive system, 404 in others
    await expect
      .poll(() => page.textContent('.unsafe-dotEnV-casing'))
      .toStrictEqual(expect.toBeOneOf(['403', '404']))
  })

  test('denied env with ?.svg?.wasm?init', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-dotenv-query-dot-svg-wasm-init'))
      .toBe('403')
  })
})

describe('fetch', () => {
  test('serve with configured headers', async () => {
    const res = await fetch(viteTestUrl + '/src/')
    expect(res.headers.get('x-served-by')).toBe('vite')
  })
})

describe('cross origin', () => {
  const fetchStatusFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const res = await globalThis.fetch(url)
        return res.status
      } catch {
        return -1
      }
    }, url)
  }

  const connectWebSocketFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const ws = new globalThis.WebSocket(url, ['vite-hmr'])
        await new Promise<void>((resolve, reject) => {
          ws.addEventListener('open', () => {
            resolve()
            ws.close()
          })
          ws.addEventListener('error', () => {
            reject()
          })
        })
        return true
      } catch {
        return false
      }
    }, url)
  }

  const connectWebSocketFromServer = async (
    url: string,
    host: string,
    origin: string | undefined,
  ) => {
    try {
      const ws = new WebSocket(url, ['vite-hmr'], {
        headers: {
          Host: host,
          ...(origin ? { Origin: origin } : undefined),
        },
      })
      await new Promise<void>((resolve, reject) => {
        ws.addEventListener('open', () => {
          resolve()
          ws.close()
        })
        ws.addEventListener('error', () => {
          reject()
        })
      })
      return true
    } catch {
      return false
    }
  }

  describe('allowed for same origin', () => {
    beforeEach(async () => {
      await page.goto(getViteTestIndexHtmlUrl())
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page, viteTestUrl + '/src/')
      expect(status).toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page,
        viteTestUrl + '/src/code.js',
      )
      expect(status).toBe(200)
    })

    test.runIf(isServe)('connect WebSocket with valid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${token}`,
      )
      expect(result).toBe(true)
    })

    test('fetch with allowed hosts', async () => {
      const viteTestUrlUrl = new URL(viteTestUrl)
      const res = await fetch(viteTestUrl + '/src/index.html', {
        headers: { Host: viteTestUrlUrl.host },
      })
      expect(res.status).toBe(200)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with allowed hosts',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          viteTestUrlUrl.host,
          viteTestUrlUrl.origin,
        )
        expect(result).toBe(true)
      },
    )

    test.runIf(isServe)(
      'connect WebSocket without a token without the origin header',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const result = await connectWebSocketFromServer(
          viteTestUrl,
          viteTestUrlUrl.host,
          undefined,
        )
        expect(result).toBe(true)
      },
    )
  })

  describe('denied for different origin', async () => {
    let page2: Page
    beforeEach(async () => {
      page2 = await browser.newPage()
      await page2.goto('http://vite.dev/404')
    })
    afterEach(async () => {
      await page2.close()
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page2, viteTestUrl + '/src/')
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page2,
        viteTestUrl + '/src/code.js',
      )
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('connect WebSocket without token', async () => {
      const result = await connectWebSocketFromPage(page, viteTestUrl)
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=`,
      )
      expect(result2).toBe(false)
    })

    test.runIf(isServe)('connect WebSocket with invalid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}`,
      )
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}t`, // different length
      )
      expect(result2).toBe(false)
    })

    test('fetch with non-allowed hosts', async () => {
      // NOTE: fetch cannot be used here as `fetch` sets the correct `Host` header
      const res = await new Promise<http.IncomingMessage>((resolve, reject) => {
        http
          .get(
            viteTestUrl + '/src/index.html',
            {
              headers: {
                Host: 'vite.dev',
              },
            },
            (res) => {
              resolve(res)
            },
          )
          .on('error', (e) => {
            reject(e)
          })
      })
      expect(res.statusCode).toBe(403)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with non-allowed hosts',
      async () => {
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          'http://vite.dev',
        )
        expect(result).toBe(false)

        const result2 = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          undefined,
        )
        expect(result2).toBe(false)
      },
    )
  })
})

describe.runIf(isServe)('invalid request', () => {
  const sendRawRequest = async (baseUrl: string, requestTarget: string) => {
    return new Promise<string>((resolve, reject) => {
      const parsedUrl = new URL(baseUrl)

      const buf: Buffer[] = []
      const client = net.createConnection(
        { port: +parsedUrl.port, host: parsedUrl.hostname },
        () => {
          client.write(
            [
              `GET ${encodeURI(requestTarget)} HTTP/1.1`,
              `Host: ${parsedUrl.host}`,
              'Connection: Close',
              '\r\n',
            ].join('\r\n'),
          )
        },
      )
      client.on('data', (data) => {
        buf.push(data)
      })
      client.on('end', (hadError) => {
        if (!hadError) {
          resolve(Buffer.concat(buf).toString())
        }
      })
      client.on('error', (err) => {
        reject(err)
      })
    })
  }

  const root = path
    .resolve(__dirname.replace('playground', 'playground-temp'), '..')
    .replace(/\\/g, '/')

  test('request with sendRawRequest should work', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/safe.txt')
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('request with sendRawRequest should work with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt'),
    )
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('should reject request that has # in request-target', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      '/src/safe.txt#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should reject request that has # in request-target with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt') +
        '#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should deny request to denied file when a request has /.', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/dummy.crt/.')
    expect(response).toContain('HTTP/1.1 403 Forbidden')
  })

  test('should deny request with /@fs/ to denied file when a request has /.', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/dummy.crt/') + '.',
    )
    expect(response).toContain('HTTP/1.1 403 Forbidden')
  })
})



================================================
FILE: playground/fs-serve/__tests__/base/fs-serve-base.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import testJSON from '../../safe.json'
import { isServe, page, viteTestUrl } from '~utils'

const stringified = JSON.stringify(testJSON)

describe.runIf(isServe)('main', () => {
  beforeAll(async () => {
    const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'
    await page.goto(viteTestUrl + srcPrefix + 'src/', {
      // while networkidle is discouraged, we use here because we're not using playwright's retry-able assertions,
      // and refactoring the code below to manually retry would be harder to read.
      waitUntil: 'networkidle',
    })
  })

  test('default import', async () => {
    await expect.poll(() => page.textContent('.full')).toBe(stringified)
  })

  test('named import', async () => {
    await expect.poll(() => page.textContent('.named')).toBe(testJSON.msg)
  })

  test('safe fetch', async () => {
    expect(await page.textContent('.safe-fetch')).toMatch('KEY=safe')
    await expect.poll(() => page.textContent('.safe-fetch-status')).toBe('200')
  })

  test('safe fetch with query', async () => {
    expect(await page.textContent('.safe-fetch-query')).toMatch('KEY=safe')
    await expect
      .poll(() => page.textContent('.safe-fetch-query-status'))
      .toBe('200')
  })

  test('safe fetch with special characters', async () => {
    expect(
      await page.textContent('.safe-fetch-subdir-special-characters'),
    ).toMatch('KEY=safe')
    await expect
      .poll(() =>
        page.textContent('.safe-fetch-subdir-special-characters-status'),
      )
      .toBe('200')
  })

  test('unsafe fetch', async () => {
    expect(await page.textContent('.unsafe-fetch')).toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-status'))
      .toBe('403')
  })

  test('unsafe fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fetch with special characters 2 (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498-2')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-2-status'))
      .toBe('404')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-status'))
      .toBe('200')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query-status'))
      .toBe('200')
  })

  test('safe fs fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters-status'))
      .toBe('200')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-status'))
      .toBe('403')
  })

  test('unsafe fs fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fs fetch with special characters 2 (#8498)', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2-status'))
      .toBe('404')
  })

  test('nested entry', async () => {
    await expect.poll(() => page.textContent('.nested-entry')).toBe('foobar')
  })

  test('denied', async () => {
    await expect.poll(() => page.textContent('.unsafe-dotenv')).toBe('403')
  })

  test('denied EnV casing', async () => {
    // It is 403 in case insensitive system, 404 in others
    await expect
      .poll(() => page.textContent('.unsafe-dotEnV-casing'))
      .toStrictEqual(expect.toBeOneOf(['403', '404']))
  })
})

describe('fetch', () => {
  test('serve with configured headers', async () => {
    const res = await fetch(viteTestUrl + '/src/')
    expect(res.headers.get('x-served-by')).toBe('vite')
  })
})



================================================
FILE: playground/fs-serve/__tests__/deny/fs-serve-deny.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { isServe, page, viteTestUrl } from '~utils'

describe.runIf(isServe)('main', () => {
  test('**/deny/** should deny src/deny/deny.txt', async () => {
    const res = await page.request.fetch(
      new URL('/src/deny/deny.txt', viteTestUrl).href,
    )
    expect(res.status()).toBe(403)
  })
  test('**/deny/** should deny src/deny/.deny', async () => {
    const res = await page.request.fetch(
      new URL('/src/deny/.deny', viteTestUrl).href,
    )
    expect(res.status()).toBe(403)
  })
})



================================================
FILE: playground/fs-serve/nested/foo.js
================================================
export const msg = 'foo'



================================================
FILE: playground/fs-serve/root/svgVirtualModulePlugin.ts
================================================
import type { Plugin } from 'vite'
const svgVirtualModuleId = 'virtual:foo.svg'
const resolvedSvgVirtualModuleId = '\0' + svgVirtualModuleId

export default function svgVirtualModulePlugin(): Plugin {
  return {
    name: 'svg-virtual-module',
    resolveId(id) {
      if (id === svgVirtualModuleId) {
        return resolvedSvgVirtualModuleId
      }
    },
    async load(id, _options) {
      if (id === resolvedSvgVirtualModuleId) {
        return `export default '<svg><rect width="100" height="100"></svg>'`
      }
    },
    enforce: 'pre',
  }
}



================================================
FILE: playground/fs-serve/root/unsafe.txt
================================================
KEY=unsafe



================================================
FILE: playground/fs-serve/root/vite.config-base.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'
import svgVirtualModulePlugin from './svgVirtualModulePlugin'

const BASE = '/base/'

export default defineConfig({
  base: BASE,
  build: {
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'src/index.html'),
      },
    },
  },
  server: {
    fs: {
      strict: true,
      allow: [path.resolve(__dirname, 'src')],
    },
    hmr: {
      overlay: false,
    },
    headers: {
      'x-served-by': 'vite',
    },
  },
  preview: {
    headers: {
      'x-served-by': 'vite',
    },
  },
  define: {
    ROOT: JSON.stringify(path.dirname(__dirname).replace(/\\/g, '/')),
    BASE: JSON.stringify(BASE),
  },
  plugins: [svgVirtualModulePlugin()],
})



================================================
FILE: playground/fs-serve/root/vite.config-deny.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'
import svgVirtualModulePlugin from './svgVirtualModulePlugin'

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'src/index.html'),
      },
    },
  },
  server: {
    fs: {
      strict: true,
      allow: [path.resolve(__dirname, 'src')],
      deny: ['**/deny/**'],
    },
  },
  define: {
    ROOT: JSON.stringify(path.dirname(__dirname).replace(/\\/g, '/')),
  },
  plugins: [svgVirtualModulePlugin()],
})



================================================
FILE: playground/fs-serve/root/vite.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'
import svgVirtualModulePlugin from './svgVirtualModulePlugin'

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'src/index.html'),
      },
    },
  },
  server: {
    fs: {
      strict: true,
      allow: [path.resolve(__dirname, 'src')],
    },
    hmr: {
      overlay: false,
    },
    headers: {
      'x-served-by': 'vite',
    },
  },
  preview: {
    headers: {
      'x-served-by': 'vite',
    },
  },
  define: {
    ROOT: JSON.stringify(path.dirname(__dirname).replace(/\\/g, '/')),
  },
  plugins: [svgVirtualModulePlugin()],
})



================================================
FILE: playground/fs-serve/root/src/code.js
================================================
// code.js



================================================
FILE: playground/fs-serve/root/src/dummy.crt
================================================
secret



================================================
FILE: playground/fs-serve/root/src/index.html
================================================
<link rel="icon" href="/src/favicon.ico" />

<h2>Normal Import</h2>
<pre class="full"></pre>
<pre class="named"></pre>

<h2>Safe Fetch</h2>
<pre class="safe-fetch-status"></pre>
<pre class="safe-fetch"></pre>
<pre class="safe-fetch-query-status"></pre>
<pre class="safe-fetch-query"></pre>

<h2>Safe Fetch Subdirectory</h2>
<pre class="safe-fetch-subdir-status"></pre>
<pre class="safe-fetch-subdir"></pre>
<pre class="safe-fetch-subdir-special-characters-status"></pre>
<pre class="safe-fetch-subdir-special-characters"></pre>

<h2>Unsafe Fetch</h2>
<pre class="unsafe-fetch-status"></pre>
<pre class="unsafe-fetch"></pre>
<pre class="unsafe-fetch-8498-status"></pre>
<pre class="unsafe-fetch-8498"></pre>
<pre class="unsafe-fetch-8498-2-status"></pre>
<pre class="unsafe-fetch-8498-2"></pre>
<pre class="unsafe-fetch-import-inline-status"></pre>
<pre class="unsafe-fetch-raw-query-import-status"></pre>
<pre class="unsafe-fetch-query-dot-svg-import-status"></pre>
<pre class="unsafe-fetch-svg-status"></pre>

<h2>Safe /@fs/ Fetch</h2>
<pre class="safe-fs-fetch-status"></pre>
<pre class="safe-fs-fetch"></pre>
<pre class="safe-fs-fetch-query-status"></pre>
<pre class="safe-fs-fetch-query"></pre>
<pre class="safe-fs-fetch-special-characters-status"></pre>
<pre class="safe-fs-fetch-special-characters"></pre>

<h2>Unsafe /@fs/ Fetch</h2>
<pre class="unsafe-fs-fetch-status"></pre>
<pre class="unsafe-fs-fetch"></pre>
<pre class="unsafe-fs-fetch-raw-status"></pre>
<pre class="unsafe-fs-fetch-raw"></pre>
<pre class="unsafe-fs-fetch-raw-query1-status"></pre>
<pre class="unsafe-fs-fetch-raw-query1"></pre>
<pre class="unsafe-fs-fetch-raw-query2-status"></pre>
<pre class="unsafe-fs-fetch-raw-query2"></pre>
<pre class="unsafe-fs-fetch-8498-status"></pre>
<pre class="unsafe-fs-fetch-8498"></pre>
<pre class="unsafe-fs-fetch-8498-2-status"></pre>
<pre class="unsafe-fs-fetch-8498-2"></pre>
<pre class="unsafe-fs-fetch-import-inline-status"></pre>
<pre class="unsafe-fs-fetch-import-inline-wasm-init-status"></pre>
<pre class="unsafe-fs-fetch-relative-path-after-query-status"></pre>

<h2>Nested Entry</h2>
<pre class="nested-entry"></pre>

<h2>Denied</h2>
<pre class="unsafe-dotenv"></pre>
<pre class="unsafe-dotEnV-casing"></pre>
<pre class="unsafe-dotenv-query-dot-svg-wasm-init"></pre>

<d2>Virtual SVG module</d2>
<pre class="virtual-svg"></pre>

<script type="module">
  import '../../entry'
  import json, { msg } from '../../safe.json'
  import './code.js'

  // Check virtual svg module still works
  import fooSvg from 'virtual:foo.svg'

  function joinUrlSegments(a, b) {
    if (!a || !b) {
      return a || b || ''
    }
    if (a.endsWith('/')) {
      a = a.substring(0, a.length - 1)
    }
    if (b[0] !== '/') {
      b = '/' + b
    }
    return a + b
  }

  text('.full', JSON.stringify(json))
  text('.named', msg)
  text('.virtual-svg', fooSvg)

  const base = typeof BASE !== 'undefined' ? BASE : ''

  // inside allowed dir, safe fetch
  fetch(joinUrlSegments(base, '/src/safe.txt'))
    .then((r) => {
      text('.safe-fetch-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.safe-fetch', JSON.stringify(data))
    })

  // inside allowed dir with query, safe fetch
  fetch(joinUrlSegments(base, '/src/safe.txt?query'))
    .then((r) => {
      text('.safe-fetch-query-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.safe-fetch-query', JSON.stringify(data))
    })

  // inside allowed dir, safe fetch
  fetch(joinUrlSegments(base, '/src/subdir/safe.txt'))
    .then((r) => {
      text('.safe-fetch-subdir-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.safe-fetch-subdir', JSON.stringify(data))
    })

  // inside allowed dir, with special characters, safe fetch
  fetch(
    joinUrlSegments(
      base,
      '/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.txt',
    ),
  )
    .then((r) => {
      text('.safe-fetch-subdir-special-characters-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.safe-fetch-subdir-special-characters', JSON.stringify(data))
    })

  // outside of allowed dir, treated as unsafe
  fetch(joinUrlSegments(base, '/unsafe.txt'))
    .then((r) => {
      text('.unsafe-fetch-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.unsafe-fetch', data)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of allowed dir with special characters #8498
  fetch(joinUrlSegments(base, '/src/%2e%2e%2funsafe%2etxt'))
    .then((r) => {
      text('.unsafe-fetch-8498-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.unsafe-fetch-8498', data)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of allowed dir with special characters 2 #8498
  fetch(joinUrlSegments(base, '/src/%252e%252e%252funsafe%252etxt'))
    .then((r) => {
      text('.unsafe-fetch-8498-2-status', r.status)
      return r.text()
    })
    .then((data) => {
      text('.unsafe-fetch-8498-2', data)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of allowed dir with import inline
  fetch(joinUrlSegments(base, '/unsafe.txt?import&inline'))
    .then((r) => {
      text('.unsafe-fetch-import-inline-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of allowed dir with raw query import
  fetch(joinUrlSegments(base, '/unsafe.txt?raw?import'))
    .then((r) => {
      text('.unsafe-fetch-raw-query-import-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of allowed dir with .svg query import
  fetch(joinUrlSegments(base, '/unsafe.txt?.svg?import'))
    .then((r) => {
      text('.unsafe-fetch-query-dot-svg-import-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // svg outside of allowed dir, treated as unsafe
  fetch(joinUrlSegments(base, '/unsafe.svg?import'))
    .then((r) => {
      text('.unsafe-fetch-svg-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // imported before, should be treated as safe
  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json'))
    .then((r) => {
      text('.safe-fs-fetch-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.safe-fs-fetch', JSON.stringify(data))
    })

  // imported before with query, should be treated as safe
  fetch(
    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json?query'),
  )
    .then((r) => {
      text('.safe-fs-fetch-query-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.safe-fs-fetch-query', JSON.stringify(data))
    })

  // not imported before, outside of root, treated as unsafe
  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/unsafe.json'))
    .then((r) => {
      text('.unsafe-fs-fetch-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch', JSON.stringify(data))
    })
    .catch((e) => {
      console.error(e)
    })

  // not imported before, outside of root, treated as unsafe
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-raw-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch-raw', JSON.stringify(data))
    })
    .catch((e) => {
      console.error(e)
    })

  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-raw-query1-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))
    })
    .catch((e) => {
      console.error(e)
    })

  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-raw-query2-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of root inline
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) + '/root/unsafe.txt?import&inline',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-import-inline-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of root inline, faux wasm?init
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) +
        '/root/unsafe.txt?import&?inline=1.wasm?init',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-import-inline-wasm-init-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside of root with relative path after query
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) +
        '/root/src/?/../../unsafe.txt?import&raw',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-relative-path-after-query-status', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // outside root with special characters #8498
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) +
        '/root/src/%2e%2e%2f%2e%2e%2funsafe%2ejson',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-8498-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch-8498', JSON.stringify(data))
    })

  // outside root with special characters 2 #8498
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) +
        '/root/src/%252e%252e%252f%252e%252e%252funsafe%252ejson',
    ),
  )
    .then((r) => {
      text('.unsafe-fs-fetch-8498-2-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.unsafe-fs-fetch-8498-2', JSON.stringify(data))
    })

  // not imported before, inside root with special characters, treated as safe
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) +
        '/root/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.json',
    ),
  )
    .then((r) => {
      text('.safe-fs-fetch-special-characters-status', r.status)
      return r.json()
    })
    .then((data) => {
      text('.safe-fs-fetch-special-characters', JSON.stringify(data))
    })

  // .env, denied by default
  fetch(
    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/root/src/.env'),
  )
    .then((r) => {
      text('.unsafe-dotenv', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // .env, for case insensitive file systems
  fetch(
    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/root/src/.EnV'),
  )
    .then((r) => {
      text('.unsafe-dotEnV-casing', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  // .env with .svg?.wasm?init
  fetch(
    joinUrlSegments(
      base,
      joinUrlSegments('/@fs/', ROOT) + '/root/src/.env?.svg?.wasm?init',
    ),
  )
    .then((r) => {
      text('.unsafe-dotenv-query-dot-svg-wasm-init', r.status)
    })
    .catch((e) => {
      console.error(e)
    })

  function text(sel, text) {
    document.querySelector(sel).textContent = text
  }
</script>



================================================
FILE: playground/fs-serve/root/src/safe.txt
================================================
KEY=safe



================================================
FILE: playground/fs-serve/root/src/deny/deny.txt
================================================
deny



================================================
FILE: playground/fs-serve/root/src/deny/.deny
================================================
.deny



================================================
FILE: playground/fs-serve/root/src/special characters åäö/safe.json
================================================
{
  "msg": "safe"
}



================================================
FILE: playground/fs-serve/root/src/special characters åäö/safe.txt
================================================
KEY=safe



================================================
FILE: playground/fs-serve/root/src/subdir/safe.txt
================================================
KEY=safe



================================================
FILE: playground/glob-import/index.html
================================================
<h1>Glob import</h1>
<h2>Normal</h2>
<pre class="result"></pre>
<h2>Eager</h2>
<pre class="result-eager"></pre>
<h2>node_modules</h2>
<pre class="result-node_modules"></pre>
<h2>Raw</h2>
<pre class="globraw"></pre>
<h2>Property access</h2>
<pre class="property-access"></pre>
<h2>Relative raw</h2>
<pre class="relative-glob-raw"></pre>
<h2>Side effect</h2>
<pre class="side-effect-result"></pre>
<h2>Tree shake Eager CSS</h2>
<p class="tree-shake-eager-css">Should be orange</p>
<p class="no-tree-shake-eager-css">Should be orange</p>
<pre class="no-tree-shake-eager-css-result"></pre>
<h2>Escape relative glob</h2>
<pre class="escape-relative"></pre>
<h2>Escape alias glob</h2>
<pre class="escape-alias"></pre>
<h2>Subpath imports</h2>
<pre class="subpath-imports"></pre>
<h2>#alias imports</h2>
<pre class="hash-alias-imports"></pre>
<h2>In package</h2>
<pre class="in-package"></pre>
<h2>Base</h2>
<pre class="result-base"></pre>

<script type="module" src="./dir/index.js"></script>
<script type="module">
  function useImports(modules, selector) {
    const keys = Object.keys(modules)
    Promise.all(keys.map((key) => modules[key]())).then((mods) => {
      const res = {}
      mods.forEach((m, i) => {
        res[keys[i]] = m
      })
      document.querySelector(selector).textContent = JSON.stringify(
        res,
        null,
        2,
      )
    })
  }

  const modules = import.meta.glob(
    '/dir/**',
    // for test: annotation contain ")"
    /*
     * for test: annotation contain ")"
     * */
  )
  useImports(modules, '.result')
  const eagerModules = import.meta.glob('/dir/**', { eager: true })
  document.querySelector('.result-eager').textContent = JSON.stringify(
    eagerModules,
    null,
    2,
  )

  const nodeModules = import.meta.glob('/dir/node_modules/**')
  useImports(nodeModules, '.result-node_modules')
</script>

<script type="module">
  const rawModules = import.meta.glob('/dir/*.json', {
    query: '?raw',
    eager: true,
    import: 'default',
  })
  const globraw = {}
  Object.keys(rawModules).forEach((key) => {
    globraw[key] = JSON.parse(rawModules[key])
  })
  document.querySelector('.globraw').textContent = JSON.stringify(
    globraw,
    null,
    2,
  )
</script>

<script type="module">
  const bazJson = import.meta.glob('/dir/*.json', {
    query: '?raw',
    eager: true,
    import: 'default',
  })['/dir/baz.json']
  document.querySelector('.property-access').textContent = JSON.stringify(
    JSON.parse(bazJson),
    null,
    2,
  )
</script>

<script type="module">
  const relativeRawModules = import.meta.glob('../glob-import/dir/*.json', {
    query: '?raw',
    eager: true,
    import: 'default',
  })
  const relativeGlobRaw = {}
  Object.keys(relativeRawModules).forEach((key) => {
    relativeGlobRaw[key] = JSON.parse(relativeRawModules[key])
  })
  document.querySelector('.relative-glob-raw').textContent = JSON.stringify(
    relativeGlobRaw,
    null,
    2,
  )
</script>

<script type="module">
  const neverInvoke = () =>
    (document.querySelector('.side-effect-result').textContent =
      "Syntax generated from 'import.meta.glob' must do ASI.")
  const notInvocation = neverInvoke
  import.meta.glob('/side-effect/**', { eager: true })
</script>

<script type="module">
  import.meta.glob('/tree-shake.css', { eager: true, query: { inline: true } })
  const results = import.meta.glob('/no-tree-shake.css', {
    eager: true,
    query: { inline: true },
  })
  document.querySelector('.no-tree-shake-eager-css-result').textContent =
    results['/no-tree-shake.css'].default
</script>

<script type="module">
  const globs = import.meta.glob('/escape/**/glob.js', {
    eager: true,
  })
  globalThis.globs = globs
  const relative = Object.entries(globs)
    .filter(([_, mod]) => Object.keys(mod?.relative ?? {}).length === 1)
    .map(([glob]) => glob)
  document.querySelector('.escape-relative').textContent = relative
    .sort()
    .join('\n')
  const alias = Object.entries(globs)
    .filter(([_, mod]) => Object.keys(mod?.alias ?? {}).length === 1)
    .map(([glob]) => glob)
  document.querySelector('.escape-alias').textContent = alias.sort().join('\n')
</script>

<script type="module">
  const subpathImports = import.meta.glob('#imports/*', { eager: true })
  document.querySelector('.subpath-imports').textContent = Object.values(
    subpathImports,
  )
    .map((mod) => mod.default)
    .join(' ')
</script>

<script type="module">
  const hashAliasImports = import.meta.glob('#alias/*', { eager: true })
  document.querySelector('.hash-alias-imports').textContent = Object.values(
    hashAliasImports,
  )
    .map((mod) => mod.default)
    .join(' ')
</script>

<script type="module">
  import '@vitejs/test-import-meta-glob-pkg'
</script>

<script type="module">
  const baseModules = import.meta.glob('./*.json', {
    query: '?raw',
    eager: true,
    import: 'default',
    base: './dir',
  })
  const globBase = {}
  Object.keys(baseModules).forEach((key) => {
    globBase[key] = JSON.parse(baseModules[key])
  })
  document.querySelector('.result-base').textContent = JSON.stringify(
    globBase,
    null,
    2,
  )
</script>



================================================
FILE: playground/glob-import/no-tree-shake.css
================================================
.no-tree-shake-eager-css {
  color: orange;
}



================================================
FILE: playground/glob-import/package.json
================================================
{
  "name": "@vitejs/test-import-context",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "imports": {
    "#imports/*": "./imports-path/*"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-import-meta-glob-pkg": "file:./import-meta-glob-pkg"
  }
}



================================================
FILE: playground/glob-import/tree-shake.css
================================================
.tree-shake-eager-css {
  color: orange;
}



================================================
FILE: playground/glob-import/vite.config.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { defineConfig } from 'vite'

const escapeAliases = fs
  .readdirSync(path.join(__dirname, 'escape'), { withFileTypes: true })
  .filter((f) => f.isDirectory())
  .map((f) => f.name)
  .reduce((aliases: Record<string, string>, dir) => {
    aliases[`@escape_${dir}_mod`] = path.resolve(
      __dirname,
      `./escape/${dir}/mod`,
    )
    return aliases
  }, {})

export default defineConfig({
  resolve: {
    alias: {
      ...escapeAliases,
      '@dir': path.resolve(__dirname, './dir/'),
      '#alias': path.resolve(__dirname, './imports-path/'),
    },
  },
  build: {
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('foo.css')) {
            return 'foo_css'
          }
        },
      },
    },
  },
})



================================================
FILE: playground/glob-import/__tests__/glob-import.spec.ts
================================================
import path from 'node:path'
import { readdir } from 'node:fs/promises'
import { expect, test } from 'vitest'
import {
  addFile,
  editFile,
  findAssetFile,
  isBuild,
  page,
  removeFile,
} from '~utils'

const filteredResult = {
  './alias.js': {
    default: 'hi',
  },
  './foo.js': {
    msg: 'foo',
  },
  "./quote'.js": {
    msg: 'single-quote',
  },
}

const json = {
  msg: 'baz',
  default: {
    msg: 'baz',
  },
}

const globWithAlias = {
  '/dir/alias.js': {
    default: 'hi',
  },
}

const allResult = {
  // JSON file should be properly transformed
  '/dir/alias.js': {
    default: 'hi',
  },
  '/dir/baz.json': json,
  '/dir/foo.css': {},
  '/dir/foo.js': {
    msg: 'foo',
  },
  '/dir/index.js': isBuild
    ? {
        modules: filteredResult,
        globWithAlias,
      }
    : {
        globWithAlias,
        modules: filteredResult,
      },
  '/dir/nested/bar.js': {
    modules: {
      '../baz.json': json,
    },
    msg: 'bar',
  },
  "/dir/quote'.js": {
    msg: 'single-quote',
  },
}

const nodeModulesResult = {
  '/dir/node_modules/hoge.js': { msg: 'hoge' },
}

const rawResult = {
  '/dir/baz.json': {
    msg: 'baz',
  },
}

const relativeRawResult = {
  './dir/baz.json': {
    msg: 'baz',
  },
}

const baseRawResult = {
  './baz.json': {
    msg: 'baz',
  },
}

test('should work', async () => {
  await expect
    .poll(async () => JSON.parse(await page.textContent('.result')))
    .toStrictEqual(allResult)
  await expect
    .poll(async () => JSON.parse(await page.textContent('.result-eager')))
    .toStrictEqual(allResult)
  await expect
    .poll(async () =>
      JSON.parse(await page.textContent('.result-node_modules')),
    )
    .toStrictEqual(nodeModulesResult)
})

test('import glob raw', async () => {
  expect(await page.textContent('.globraw')).toBe(
    JSON.stringify(rawResult, null, 2),
  )
})

test('import property access', async () => {
  expect(await page.textContent('.property-access')).toBe(
    JSON.stringify(rawResult['/dir/baz.json'], null, 2),
  )
})

test('import relative glob raw', async () => {
  expect(await page.textContent('.relative-glob-raw')).toBe(
    JSON.stringify(relativeRawResult, null, 2),
  )
})

test('unassigned import processes', async () => {
  expect(await page.textContent('.side-effect-result')).toBe(
    'Hello from side effect',
  )
})

test('import glob in package', async () => {
  expect(await page.textContent('.in-package')).toBe(
    JSON.stringify(['/pkg-pages/foo.js']),
  )
})

if (!isBuild) {
  test('hmr for adding/removing files', async () => {
    const resultElement = page.locator('.result')

    addFile('dir/a.js', '')
    await expect
      .poll(async () => {
        const actualAdd = await resultElement.textContent()
        return JSON.parse(actualAdd)
      })
      .toStrictEqual({
        '/dir/a.js': {},
        ...allResult,
        '/dir/index.js': {
          ...allResult['/dir/index.js'],
          modules: {
            './a.js': {},
            ...allResult['/dir/index.js'].modules,
          },
        },
      })

    // edit the added file
    editFile('dir/a.js', () => 'export const msg ="a"')
    await expect
      .poll(async () => {
        const actualEdit = await resultElement.textContent()
        return JSON.parse(actualEdit)
      })
      .toStrictEqual({
        '/dir/a.js': {
          msg: 'a',
        },
        ...allResult,
        '/dir/index.js': {
          ...allResult['/dir/index.js'],
          modules: {
            './a.js': {
              msg: 'a',
            },
            ...allResult['/dir/index.js'].modules,
          },
        },
      })

    removeFile('dir/a.js')
    await expect
      .poll(async () => {
        const actualRemove = await resultElement.textContent()
        return JSON.parse(actualRemove)
      })
      .toStrictEqual(allResult)
  })

  test('no hmr for adding/removing files', async () => {
    let request = page.waitForResponse(/dir\/index\.js$/, { timeout: 200 })
    addFile('nohmr.js', '')
    let response = await request.catch(() => ({ status: () => -1 }))
    expect(response.status()).toBe(-1)

    request = page.waitForResponse(/dir\/index\.js$/, { timeout: 200 })
    removeFile('nohmr.js')
    response = await request.catch(() => ({ status: () => -1 }))
    expect(response.status()).toBe(-1)
  })

  test('hmr for adding/removing files in package', async () => {
    const resultElement = page.locator('.in-package')

    addFile('pkg-pages/bar.js', '// empty')
    await expect
      .poll(async () => JSON.parse(await resultElement.textContent()))
      .toStrictEqual(['/pkg-pages/foo.js', '/pkg-pages/bar.js'].sort())

    removeFile('pkg-pages/bar.js')
    await expect
      .poll(async () => JSON.parse(await resultElement.textContent()))
      .toStrictEqual(['/pkg-pages/foo.js'])
  })
}

test('tree-shake eager css', async () => {
  expect(await page.textContent('.no-tree-shake-eager-css-result')).toMatch(
    '.no-tree-shake-eager-css',
  )

  if (isBuild) {
    const content = findAssetFile(/index-[-\w]+\.js/)
    expect(content).not.toMatch('.tree-shake-eager-css')
  }
})

test('escapes special chars in globs without mangling user supplied glob suffix', async () => {
  // the escape dir contains subdirectories where each has a name that needs escaping for glob safety
  // inside each of them is a glob.js that exports the result of a relative glob `./**/*.js`
  // and an alias glob `@escape_<dirname>_mod/**/*.js`. The matching aliases are generated in vite.config.ts
  // index.html has a script that loads all these glob.js files and prints the globs that returned the expected result
  // this test finally compares the printed output of index.js with the list of directories with special chars,
  // expecting that they all work
  const files = await readdir(path.join(__dirname, '..', 'escape'), {
    withFileTypes: true,
  })
  const expectedNames = files
    .filter((f) => f.isDirectory())
    .map((f) => `/escape/${f.name}/glob.js`)
    .sort()
  const foundRelativeNames = (await page.textContent('.escape-relative'))
    .split('\n')
    .sort()
  expect(expectedNames).toEqual(foundRelativeNames)
  const foundAliasNames = (await page.textContent('.escape-alias'))
    .split('\n')
    .sort()
  expect(expectedNames).toEqual(foundAliasNames)
})

test('subpath imports', async () => {
  expect(await page.textContent('.subpath-imports')).toMatch('bar foo')
})

test('#alias imports', async () => {
  expect(await page.textContent('.hash-alias-imports')).toMatch('bar foo')
})

test('import base glob raw', async () => {
  expect(await page.textContent('.result-base')).toBe(
    JSON.stringify(baseRawResult, null, 2),
  )
})



================================================
FILE: playground/glob-import/dir/alias.js
================================================
export default 'hi'



================================================
FILE: playground/glob-import/dir/baz.json
================================================
{
  "msg": "baz"
}



================================================
FILE: playground/glob-import/dir/foo.css
================================================
.foo {
  color: blue;
}



================================================
FILE: playground/glob-import/dir/foo.js
================================================
export const msg = 'foo'



================================================
FILE: playground/glob-import/dir/index.js
================================================
const modules = import.meta.glob('./*.(js|ts)', { eager: true })
const globWithAlias = import.meta.glob('@dir/al*.js', { eager: true })

// test negative glob
import.meta.glob(['@dir/*.js', '!@dir/x.js'])
import.meta.glob(['!@dir/x.js', '@dir/*.js'])

// test for sourcemap
console.log('hello')

export { modules, globWithAlias }



================================================
FILE: playground/glob-import/dir/quote'.js
================================================
export const msg = 'single-quote'



================================================
FILE: playground/glob-import/dir/nested/bar.js
================================================
const modules = import.meta.glob('../*.json', { eager: true })

export const msg = 'bar'
export { modules }



================================================
FILE: playground/glob-import/dir/node_modules/hoge.js
================================================
export const msg = 'hoge'



================================================
FILE: playground/glob-import/escape/(parenthesis)/glob.js
================================================
const relative = import.meta.glob('./**/*.js', { eager: true })
const alias = import.meta.glob('@escape_(parenthesis)_mod/**/*.js', {
  eager: true,
})
export { relative, alias }



================================================
FILE: playground/glob-import/escape/(parenthesis)/mod/index.js
================================================
export const msg = 'foo'



================================================
FILE: playground/glob-import/escape/[brackets]/glob.js
================================================
const relative = import.meta.glob('./**/*.js', { eager: true })
const alias = import.meta.glob('@escape_[brackets]_mod/**/*.js', {
  eager: true,
})
export { relative, alias }



================================================
FILE: playground/glob-import/escape/[brackets]/mod/index.js
================================================
export const msg = 'foo'



================================================
FILE: playground/glob-import/escape/{curlies}/glob.js
================================================
const relative = import.meta.glob('./**/*.js', { eager: true })
const alias = import.meta.glob('@escape_{curlies}_mod/**/*.js', { eager: true })
export { relative, alias }



================================================
FILE: playground/glob-import/escape/{curlies}/mod/index.js
================================================
export const msg = 'foo'



================================================
FILE: playground/glob-import/import-meta-glob-pkg/index.js
================================================
export const g = import.meta.glob('/pkg-pages/*.js')
document.querySelector('.in-package').textContent = JSON.stringify(
  Object.keys(g).sort(),
)



================================================
FILE: playground/glob-import/import-meta-glob-pkg/package.json
================================================
{
  "name": "@vitejs/test-import-meta-glob-pkg",
  "type": "module",
  "main": "./index.js"
}



================================================
FILE: playground/glob-import/imports-path/bar.js
================================================
export default 'bar'



================================================
FILE: playground/glob-import/imports-path/foo.js
================================================
export default 'foo'



================================================
FILE: playground/glob-import/pkg-pages/foo.js
================================================
// empty



================================================
FILE: playground/glob-import/side-effect/writedom.js
================================================
/* global document */
document &&
  (document.querySelector('.side-effect-result').textContent =
    'Hello from side effect')



================================================
FILE: playground/glob-import/side-effect/writetodom.js
================================================
/* global document */
document &&
  (document.querySelector('.side-effect-result').textContent =
    'Hello from side effect')



================================================
FILE: playground/hmr/customFile.js
================================================
export const msg = 'custom'



================================================
FILE: playground/hmr/event.d.ts
================================================
import 'vite/types/customEvent'

declare module 'vite/types/customEvent' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
    'custom:remote-add': { a: number; b: number }
    'custom:remote-add-result': { result: string }
  }
}



================================================
FILE: playground/hmr/global.css
================================================
body {
  background: white;
}



================================================
FILE: playground/hmr/hmr.ts
================================================
import { virtual } from 'virtual:file'
import { virtual as virtualDep } from 'virtual:file-dep'
import { foo as depFoo, nestedFoo } from './hmrDep'
import './importing-updated'
import './invalidation-circular-deps'
import './file-delete-restore'
import './optional-chaining/parent'
import './intermediate-file-delete'
import './circular'
import logo from './logo.svg'
import logoNoInline from './logo-no-inline.svg'
import { msg as softInvalidationMsg } from './soft-invalidation'

export const foo = 1
text('.app', foo)
text('.dep', depFoo)
text('.nested', nestedFoo)
text('.virtual', virtual)
text('.virtual-dep', virtualDep)
text('.soft-invalidation', softInvalidationMsg)
setImgSrc('#logo', logo)
setImgSrc('#logo-no-inline', logoNoInline)

text('.virtual-dep', 0)

const btn = document.querySelector('.virtual-update') as HTMLButtonElement
btn.onclick = () => {
  if (import.meta.hot) {
    import.meta.hot.send('virtual:increment')
  }
}

const btnDep = document.querySelector(
  '.virtual-update-dep',
) as HTMLButtonElement
btnDep.onclick = () => {
  if (import.meta.hot) {
    import.meta.hot.send('virtual:increment', '-dep')
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ foo }) => {
    console.log('(self-accepting 1) foo is now:', foo)
  })

  import.meta.hot.accept(({ foo }) => {
    console.log('(self-accepting 2) foo is now:', foo)
  })

  const handleDep = (type, newFoo, newNestedFoo) => {
    console.log(`(${type}) foo is now: ${newFoo}`)
    console.log(`(${type}) nested foo is now: ${newNestedFoo}`)
    text('.dep', newFoo)
    text('.nested', newNestedFoo)
  }

  import.meta.hot.accept('./logo.svg', (newUrl) => {
    setImgSrc('#logo', newUrl.default)
    console.log('Logo updated', newUrl.default)
  })

  import.meta.hot.accept('./logo-no-inline.svg', (newUrl) => {
    setImgSrc('#logo-no-inline', newUrl.default)
    console.log('Logo-no-inline updated', newUrl.default)
  })

  import.meta.hot.accept('./hmrDep', ({ foo, nestedFoo }) => {
    handleDep('single dep', foo, nestedFoo)
  })

  import.meta.hot.accept('virtual:file-dep', ({ virtual }) => {
    text('.virtual-dep', virtual)
  })

  import.meta.hot.accept(['./hmrDep'], ([{ foo, nestedFoo }]) => {
    handleDep('multi deps', foo, nestedFoo)
  })

  import.meta.hot.dispose(() => {
    console.log(`foo was:`, foo)
  })

  import.meta.hot.on('vite:afterUpdate', (event) => {
    console.log(`>>> vite:afterUpdate -- ${event.type}`)
  })

  import.meta.hot.on('vite:beforeUpdate', (event) => {
    console.log(`>>> vite:beforeUpdate -- ${event.type}`)

    const cssUpdate = event.updates.find(
      (update) =>
        update.type === 'css-update' && update.path.includes('global.css'),
    )
    if (cssUpdate) {
      text(
        '.css-prev',
        (document.querySelector('.global-css') as HTMLLinkElement).href,
      )

      // Wait until the tag has been swapped out, which includes the time taken
      // to download and parse the new stylesheet. Assert the swapped link.
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (
              node.nodeType === Node.ELEMENT_NODE &&
              (node as Element).tagName === 'LINK'
            ) {
              text('.link-tag-added', 'yes')
            }
          })
          mutation.removedNodes.forEach((node) => {
            if (
              node.nodeType === Node.ELEMENT_NODE &&
              (node as Element).tagName === 'LINK'
            ) {
              text('.link-tag-removed', 'yes')
              text(
                '.css-post',
                (document.querySelector('.global-css') as HTMLLinkElement).href,
              )
            }
          })
        })
      })

      observer.observe(document.querySelector('#style-tags-wrapper'), {
        childList: true,
      })
    }
  })

  import.meta.hot.on('vite:error', (event) => {
    console.log(`>>> vite:error -- ${event.err.message}`)
  })

  import.meta.hot.on('vite:invalidate', ({ path }) => {
    console.log(`>>> vite:invalidate -- ${path}`)
  })

  import.meta.hot.on('custom:foo', ({ msg }) => {
    text('.custom', msg)
  })

  import.meta.hot.on('custom:remove', removeCb)

  // send custom event to server to calculate 1 + 2
  import.meta.hot.send('custom:remote-add', { a: 1, b: 2 })
  import.meta.hot.on('custom:remote-add-result', ({ result }) => {
    text('.custom-communication', result)
  })
}

function text(el, text) {
  document.querySelector(el).textContent = text
}

function setImgSrc(el, src) {
  ;(document.querySelector(el) as HTMLImageElement).src = src
}

function removeCb({ msg }) {
  text('.toRemove', msg)
  import.meta.hot.off('custom:remove', removeCb)
}



================================================
FILE: playground/hmr/hmrDep.js
================================================
export const foo = 1
export { foo as nestedFoo } from './hmrNestedDep'

if (import.meta.hot) {
  const data = import.meta.hot.data
  if ('fromDispose' in data) {
    console.log(`(dep) foo from dispose: ${data.fromDispose}`)
  }

  import.meta.hot.dispose((data) => {
    console.log(`(dep) foo was: ${foo}`)
    data.fromDispose = foo
  })
}



================================================
FILE: playground/hmr/hmrNestedDep.js
================================================
export const foo = 1



================================================
FILE: playground/hmr/importedVirtual.js
================================================
export const virtual = '[success]'



================================================
FILE: playground/hmr/index.html
================================================
<div id="style-tags-wrapper">
  <link
    class="global-css"
    rel="stylesheet"
    href="./global.css?param=required"
  />
</div>
<button class="virtual-update">update virtual module</button>
<button class="virtual-update-dep">update virtual module via accept</button>

<script type="module" src="./invalidation/root.js"></script>
<script type="module" src="./hmr.ts"></script>
<style>
  .import-image {
    width: 30px;
    height: 30px;
    background: url('./icon.png') no-repeat;
    background-size: contain;
  }
</style>

<div class="app"></div>
<div class="dep"></div>
<div class="nested"></div>
<div class="custom"></div>
<div class="toRemove"></div>
<div class="virtual"></div>
<div class="virtual-dep"></div>
<div class="soft-invalidation"></div>
<div class="invalidation-parent"></div>
<div class="invalidation-root"></div>
<div class="invalidation-circular-deps"></div>
<div class="invalidation-circular-deps-handled"></div>
<div class="custom-communication"></div>
<div class="css-prev"></div>
<div class="css-post"></div>
<div class="link-tag-added">no</div>
<div class="link-tag-removed">no</div>
<div class="import-image"></div>
<div class="importing-reloaded"></div>
<div class="file-delete-restore"></div>
<div class="optional-chaining"></div>
<button class="intermediate-file-delete-increment">1</button>
<div class="intermediate-file-delete-display"></div>
<img id="logo" />
<img id="logo-no-inline" />
<div class="circular"></div>



================================================
FILE: playground/hmr/modules.d.ts
================================================
declare module 'virtual:file' {
  export const virtual: string
}

declare module 'virtual:file-dep' {
  export const virtual: string
}



================================================
FILE: playground/hmr/package.json
================================================
{
  "name": "@vitejs/test-hmr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/hmr/vite.config.ts
================================================
import fs from 'node:fs/promises'
import path from 'node:path'
import { defineConfig } from 'vite'
import type { Plugin } from 'vite'

export default defineConfig({
  experimental: {
    hmrPartialAccept: true,
  },
  build: {
    assetsInlineLimit(filePath) {
      if (filePath.endsWith('logo-no-inline.svg')) {
        return false
      }
    },
  },
  plugins: [
    {
      name: 'mock-custom',
      async hotUpdate({ file, read }) {
        if (file.endsWith('customFile.js')) {
          const content = await read()
          const msg = content.match(/export const msg = '(\w+)'/)[1]
          this.environment.hot.send('custom:foo', { msg })
          this.environment.hot.send('custom:remove', { msg })
        }
      },
      configureServer(server) {
        server.environments.client.hot.on(
          'custom:remote-add',
          ({ a, b }, client) => {
            client.send('custom:remote-add-result', { result: a + b })
          },
        )
      },
    },
    virtualPlugin(),
    transformCountPlugin(),
    watchCssDepsPlugin(),
  ],
})

function virtualPlugin(): Plugin {
  let num = 0
  return {
    name: 'virtual-file',
    resolveId(id) {
      if (id.startsWith('virtual:file')) {
        return '\0' + id
      }
    },
    load(id) {
      if (id.startsWith('\0virtual:file')) {
        return `\
import { virtual as _virtual } from "/importedVirtual.js";
export const virtual = _virtual + '${num}';`
      }
    },
    configureServer(server) {
      server.environments.client.hot.on('virtual:increment', async (suffix) => {
        const mod = await server.environments.client.moduleGraph.getModuleById(
          '\0virtual:file' + (suffix || ''),
        )
        if (mod) {
          num++
          server.environments.client.reloadModule(mod)
        }
      })
    },
  }
}

function transformCountPlugin(): Plugin {
  let num = 0
  return {
    name: 'transform-count',
    transform(code) {
      if (code.includes('__TRANSFORM_COUNT__')) {
        return code.replace('__TRANSFORM_COUNT__', String(++num))
      }
    },
  }
}

function watchCssDepsPlugin(): Plugin {
  return {
    name: 'watch-css-deps',
    async transform(code, id) {
      // replace the `replaced` identifier in the CSS file with the adjacent
      // `dep.js` file's `color` variable.
      if (id.includes('css-deps/main.css')) {
        const depPath = path.resolve(__dirname, './css-deps/dep.js')
        const dep = await fs.readFile(depPath, 'utf-8')
        const color = dep.match(/color = '(.+?)'/)[1]
        this.addWatchFile(depPath)
        return code.replace('replaced', color)
      }
    },
  }
}



================================================
FILE: playground/hmr/__tests__/hmr.spec.ts
================================================
import { beforeAll, describe, expect, it, test } from 'vitest'
import type { Page } from 'playwright-chromium'
import {
  addFile,
  browser,
  browserLogs,
  editFile,
  getBg,
  getColor,
  isBuild,
  page,
  readFile,
  removeFile,
  serverLogs,
  untilBrowserLogAfter,
  viteTestUrl,
} from '~utils'

test('should render', async () => {
  expect(await page.textContent('.app')).toBe('1')
  expect(await page.textContent('.dep')).toBe('1')
  expect(await page.textContent('.nested')).toBe('1')
})

if (!isBuild) {
  test('should connect', async () => {
    expect(browserLogs.length).toBe(5)
    expect(browserLogs.some((msg) => msg.includes('connected'))).toBe(true)
    browserLogs.length = 0
  })

  test('self accept', async () => {
    const el = await page.$('.app')
    await untilBrowserLogAfter(
      () =>
        editFile('hmr.ts', (code) =>
          code.replace('const foo = 1', 'const foo = 2'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        'foo was: 1',
        '(self-accepting 1) foo is now: 2',
        '(self-accepting 2) foo is now: 2',
        '[vite] hot updated: /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('2')

    await untilBrowserLogAfter(
      () =>
        editFile('hmr.ts', (code) =>
          code.replace('const foo = 2', 'const foo = 3'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        'foo was: 2',
        '(self-accepting 1) foo is now: 3',
        '(self-accepting 2) foo is now: 3',
        '[vite] hot updated: /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('3')
  })

  test('accept dep', async () => {
    const el = await page.$('.dep')
    await untilBrowserLogAfter(
      () =>
        editFile('hmrDep.js', (code) =>
          code.replace('const foo = 1', 'const foo = 2'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        '(dep) foo was: 1',
        '(dep) foo from dispose: 1',
        '(single dep) foo is now: 2',
        '(single dep) nested foo is now: 1',
        '(multi deps) foo is now: 2',
        '(multi deps) nested foo is now: 1',
        '[vite] hot updated: /hmrDep.js via /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('2')

    await untilBrowserLogAfter(
      () =>
        editFile('hmrDep.js', (code) =>
          code.replace('const foo = 2', 'const foo = 3'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        '(dep) foo was: 2',
        '(dep) foo from dispose: 2',
        '(single dep) foo is now: 3',
        '(single dep) nested foo is now: 1',
        '(multi deps) foo is now: 3',
        '(multi deps) nested foo is now: 1',
        '[vite] hot updated: /hmrDep.js via /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('3')
  })

  test('nested dep propagation', async () => {
    const el = await page.$('.nested')
    await untilBrowserLogAfter(
      () =>
        editFile('hmrNestedDep.js', (code) =>
          code.replace('const foo = 1', 'const foo = 2'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        '(dep) foo was: 3',
        '(dep) foo from dispose: 3',
        '(single dep) foo is now: 3',
        '(single dep) nested foo is now: 2',
        '(multi deps) foo is now: 3',
        '(multi deps) nested foo is now: 2',
        '[vite] hot updated: /hmrDep.js via /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('2')

    await untilBrowserLogAfter(
      () =>
        editFile('hmrNestedDep.js', (code) =>
          code.replace('const foo = 2', 'const foo = 3'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        '(dep) foo was: 3',
        '(dep) foo from dispose: 3',
        '(single dep) foo is now: 3',
        '(single dep) nested foo is now: 3',
        '(multi deps) foo is now: 3',
        '(multi deps) nested foo is now: 3',
        '[vite] hot updated: /hmrDep.js via /hmr.ts',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('3')
  })

  test('invalidate', async () => {
    const el = await page.$('.invalidation-parent')
    await untilBrowserLogAfter(
      () =>
        editFile('invalidation/child.js', (code) =>
          code.replace('child', 'child updated'),
        ),
      [
        '>>> vite:beforeUpdate -- update',
        '>>> vite:invalidate -- /invalidation/child.js',
        '[vite] invalidate /invalidation/child.js',
        '[vite] hot updated: /invalidation/child.js',
        '>>> vite:afterUpdate -- update',
        '>>> vite:beforeUpdate -- update',
        '(invalidation) parent is executing',
        '[vite] hot updated: /invalidation/parent.js',
        '>>> vite:afterUpdate -- update',
      ],
      true,
    )
    await expect.poll(() => el.textContent()).toMatch('child updated')
  })

  test('invalidate works with multiple tabs', async () => {
    let page2: Page
    try {
      page2 = await browser.newPage()
      await page2.goto(viteTestUrl)

      const el = await page.$('.invalidation-parent')
      await untilBrowserLogAfter(
        () =>
          editFile('invalidation/child.js', (code) =>
            code.replace('child', 'child updated'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          '>>> vite:invalidate -- /invalidation/child.js',
          '[vite] invalidate /invalidation/child.js',
          '[vite] hot updated: /invalidation/child.js',
          '>>> vite:afterUpdate -- update',
          // if invalidate dedupe doesn't work correctly, this beforeUpdate will be called twice
          '>>> vite:beforeUpdate -- update',
          '(invalidation) parent is executing',
          '[vite] hot updated: /invalidation/parent.js',
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el.textContent()).toMatch('child updated')
    } finally {
      await page2.close()
    }
  })

  test('invalidate on root triggers page reload', async () => {
    editFile('invalidation/root.js', (code) => code.replace('Init', 'Updated'))
    await page.waitForEvent('load')
    await expect
      .poll(async () => (await page.$('.invalidation-root')).textContent())
      .toMatch('Updated')
  })

  test('soft invalidate', async () => {
    const el = await page.$('.soft-invalidation')
    expect(await el.textContent()).toBe(
      'soft-invalidation/index.js is transformed 1 times. child is bar',
    )
    editFile('soft-invalidation/child.js', (code) =>
      code.replace('bar', 'updated'),
    )
    await expect
      .poll(() => el.textContent())
      .toBe(
        'soft-invalidation/index.js is transformed 1 times. child is updated',
      )

    editFile('soft-invalidation/index.js', (code) =>
      code.replace('child is', 'child is now'),
    )
    editFile('soft-invalidation/child.js', (code) =>
      code.replace('updated', 'updated?'),
    )
    await expect
      .poll(() => el.textContent())
      .toBe(
        'soft-invalidation/index.js is transformed 2 times. child is now updated?',
      )
  })

  test('invalidate in circular dep should not trigger infinite HMR', async () => {
    const el = await page.$('.invalidation-circular-deps')
    await expect.poll(() => el.textContent()).toMatch('child')
    editFile(
      'invalidation-circular-deps/circular-invalidate/child.js',
      (code) => code.replace('child', 'child updated'),
    )
    await page.waitForEvent('load')
    await expect
      .poll(() => page.textContent('.invalidation-circular-deps'))
      .toMatch('child updated')
  })

  test('invalidate in circular dep should be hot updated if possible', async () => {
    const el = await page.$('.invalidation-circular-deps-handled')
    await expect.poll(() => el.textContent()).toMatch('child')
    editFile(
      'invalidation-circular-deps/invalidate-handled-in-circle/child.js',
      (code) => code.replace('child', 'child updated'),
    )
    await expect.poll(() => el.textContent()).toMatch('child updated')
  })

  test('plugin hmr handler + custom event', async () => {
    const el = await page.$('.custom')
    editFile('customFile.js', (code) => code.replace('custom', 'edited'))
    await expect.poll(() => el.textContent()).toMatch('edited')
  })

  test('plugin hmr remove custom events', async () => {
    const el = await page.$('.toRemove')
    editFile('customFile.js', (code) => code.replace('custom', 'edited'))
    await expect.poll(() => el.textContent()).toMatch('edited')
    editFile('customFile.js', (code) => code.replace('edited', 'custom'))
    await expect.poll(() => el.textContent()).toMatch('edited')
  })

  test('plugin client-server communication', async () => {
    const el = await page.$('.custom-communication')
    await expect.poll(() => el.textContent()).toMatch('3')
  })

  test('full-reload encodeURI path', async () => {
    await page.goto(
      viteTestUrl + '/unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html',
    )
    const el = await page.$('#app')
    expect(await el.textContent()).toBe('title')
    editFile('unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html', (code) =>
      code.replace('title', 'title2'),
    )
    await page.waitForEvent('load')
    await expect
      .poll(async () => (await page.$('#app')).textContent())
      .toBe('title2')
  })

  test('CSS update preserves query params', async () => {
    await page.goto(viteTestUrl)

    editFile('global.css', (code) => code.replace('white', 'tomato'))

    const elprev = await page.$('.css-prev')
    const elpost = await page.$('.css-post')
    await expect.poll(() => elprev.textContent()).toMatch('param=required')
    await expect.poll(() => elpost.textContent()).toMatch('param=required')
    const textprev = await elprev.textContent()
    const textpost = await elpost.textContent()
    expect(textprev).not.toBe(textpost)
    expect(textprev).not.toMatch('direct')
    expect(textpost).not.toMatch('direct')
  })

  test('it swaps out link tags', async () => {
    await page.goto(viteTestUrl)

    editFile('global.css', (code) => code.replace('white', 'tomato'))

    let el = await page.$('.link-tag-added')
    await expect.poll(() => el.textContent()).toMatch('yes')

    el = await page.$('.link-tag-removed')
    await expect.poll(() => el.textContent()).toMatch('yes')

    expect((await page.$$('link')).length).toBe(1)
  })

  test('not loaded dynamic import', async () => {
    await page.goto(viteTestUrl + '/counter/index.html', { waitUntil: 'load' })

    let btn = await page.$('button')
    expect(await btn.textContent()).toBe('Counter 0')
    await btn.click()
    expect(await btn.textContent()).toBe('Counter 1')

    // Modifying `index.ts` triggers a page reload, as expected
    const indexTsLoadPromise = page.waitForEvent('load')
    editFile('counter/index.ts', (code) => code)
    await indexTsLoadPromise
    btn = await page.$('button')
    expect(await btn.textContent()).toBe('Counter 0')

    await btn.click()
    expect(await btn.textContent()).toBe('Counter 1')

    // #7561
    // `dep.ts` defines `import.module.hot.accept` and has not been loaded.
    // Therefore, modifying it has no effect (doesn't trigger a page reload).
    // (Note that, a dynamic import that is never loaded and that does not
    // define `accept.module.hot.accept` may wrongfully trigger a full page
    // reload, see discussion at #7561.)
    const depTsLoadPromise = page.waitForEvent('load', { timeout: 1000 })
    editFile('counter/dep.ts', (code) => code)
    await expect(depTsLoadPromise).rejects.toThrow(
      /page\.waitForEvent: Timeout \d+ms exceeded while waiting for event "load"/,
    )

    btn = await page.$('button')
    expect(await btn.textContent()).toBe('Counter 1')
  })

  // #2255
  test('importing reloaded', async () => {
    await page.goto(viteTestUrl)
    const outputEle = await page.$('.importing-reloaded')
    const getOutput = () => {
      return outputEle.innerHTML()
    }

    await expect
      .poll(getOutput)
      .toMatch(['a.js: a0', 'b.js: b0,a0'].join('<br>'))

    editFile('importing-updated/a.js', (code) => code.replace("'a0'", "'a1'"))
    await expect
      .poll(getOutput)
      .toMatch(['a.js: a0', 'b.js: b0,a0', 'a.js: a1'].join('<br>'))

    editFile('importing-updated/b.js', (code) =>
      code.replace('`b0,${a}`', '`b1,${a}`'),
    )
    // note that "a.js: a1" should not happen twice after "b.js: b0,a0'"
    await expect
      .poll(getOutput)
      .toMatch(
        ['a.js: a0', 'b.js: b0,a0', 'a.js: a1', 'b.js: b1,a1'].join('<br>'),
      )
  })

  describe('acceptExports', () => {
    const HOT_UPDATED = /hot updated/
    const CONNECTED = /connected/

    const baseDir = 'accept-exports'

    describe('when all used exports are accepted', () => {
      const testDir = baseDir + '/main-accepted'

      const fileName = 'target.ts'
      const file = `${testDir}/${fileName}`
      const url = '/' + file

      let dep = 'dep0'

      beforeAll(async () => {
        await untilBrowserLogAfter(
          () => page.goto(`${viteTestUrl}/${testDir}/`),
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<<<<< A0 B0 D0 ; ${dep}`)
            expect(logs).toContain('>>>>>> A0 D0')
          },
        )
      })

      it('the callback is called with the new version the module', async () => {
        const callbackFile = `${testDir}/callback.ts`
        const callbackUrl = '/' + callbackFile

        await untilBrowserLogAfter(
          () => {
            editFile(callbackFile, (code) =>
              code
                .replace("x = 'X'", "x = 'Y'")
                .replace('reloaded >>>', 'reloaded (2) >>>'),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              'reloaded >>> Y',
              `[vite] hot updated: ${callbackUrl}`,
            ])
          },
        )

        await untilBrowserLogAfter(
          () => {
            editFile(callbackFile, (code) => code.replace("x = 'Y'", "x = 'Z'"))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              'reloaded (2) >>> Z',
              `[vite] hot updated: ${callbackUrl}`,
            ])
          },
        )
      })

      it('stops HMR bubble on dependency change', async () => {
        const depFileName = 'dep.ts'
        const depFile = `${testDir}/${depFileName}`

        await untilBrowserLogAfter(
          () => {
            editFile(depFile, (code) => code.replace('dep0', (dep = 'dep1')))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A0 B0 D0 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      it('accepts itself and refreshes on change', async () => {
        await untilBrowserLogAfter(
          () => {
            editFile(file, (code) => code.replace(/(\b[A-Z])0/g, '$11'))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A1 B1 D1 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      it('accepts itself and refreshes on 2nd change', async () => {
        await untilBrowserLogAfter(
          () => {
            editFile(file, (code) =>
              code
                .replace(/(\b[A-Z])1/g, '$12')
                .replace(
                  "acceptExports(['a', 'default']",
                  "acceptExports(['b', 'default']",
                ),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A2 B2 D2 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      it('does not accept itself anymore after acceptedExports change', async () => {
        await untilBrowserLogAfter(
          async () => {
            editFile(file, (code) => code.replace(/(\b[A-Z])2/g, '$13'))
            await page.waitForEvent('load')
          },
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<<<<< A3 B3 D3 ; ${dep}`)
            expect(logs).toContain('>>>>>> A3 D3')
          },
        )
      })
    })

    describe('when some used exports are not accepted', () => {
      const testDir = baseDir + '/main-non-accepted'

      const namedFileName = 'named.ts'
      const namedFile = `${testDir}/${namedFileName}`
      const defaultFileName = 'default.ts'
      const defaultFile = `${testDir}/${defaultFileName}`
      const depFileName = 'dep.ts'
      const depFile = `${testDir}/${depFileName}`

      const a = 'A0'
      let dep = 'dep0'

      beforeAll(async () => {
        await untilBrowserLogAfter(
          () => page.goto(`${viteTestUrl}/${testDir}/`),
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<< named: ${a} ; ${dep}`)
            expect(logs).toContain(`<<< default: def0`)
            expect(logs).toContain(`>>>>>> ${a} def0`)
          },
        )
      })

      it('does not stop the HMR bubble on change to dep', async () => {
        await untilBrowserLogAfter(
          async () => {
            editFile(depFile, (code) => code.replace('dep0', (dep = 'dep1')))
            await page.waitForEvent('load')
          },
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<< named: ${a} ; ${dep}`)
          },
        )
      })

      describe('does not stop the HMR bubble on change to self', () => {
        it('with named exports', async () => {
          await untilBrowserLogAfter(
            async () => {
              editFile(namedFile, (code) => code.replace(a, 'A1'))
              await page.waitForEvent('load')
            },
            [CONNECTED, />>>>>>/],
            (logs) => {
              expect(logs).toContain(`<<< named: A1 ; ${dep}`)
            },
          )
        })

        it('with default export', async () => {
          await untilBrowserLogAfter(
            async () => {
              editFile(defaultFile, (code) => code.replace('def0', 'def1'))
              await page.waitForEvent('load')
            },
            [CONNECTED, />>>>>>/],
            (logs) => {
              expect(logs).toContain(`<<< default: def1`)
            },
          )
        })
      })
    })

    test('accepts itself when imported for side effects only (no bindings imported)', async () => {
      const testDir = baseDir + '/side-effects'
      const file = 'side-effects.ts'

      await untilBrowserLogAfter(
        () => page.goto(`${viteTestUrl}/${testDir}/`),
        [CONNECTED, />>>/],
        (logs) => {
          expect(logs).toContain('>>> side FX')
        },
      )

      await untilBrowserLogAfter(
        () => {
          editFile(`${testDir}/${file}`, (code) =>
            code.replace('>>> side FX', '>>> side FX !!'),
          )
        },
        HOT_UPDATED,
        (logs) => {
          expect(logs).toEqual([
            '>>> side FX !!',
            `[vite] hot updated: /${testDir}/${file}`,
          ])
        },
      )
    })

    describe('acceptExports([])', () => {
      const testDir = baseDir + '/unused-exports'

      test('accepts itself if no exports are imported', async () => {
        const fileName = 'unused.ts'
        const file = `${testDir}/${fileName}`
        const url = '/' + file

        await untilBrowserLogAfter(
          () => page.goto(`${viteTestUrl}/${testDir}/`),
          [CONNECTED, '-- unused --'],
          (logs) => {
            expect(logs).toContain('-- unused --')
          },
        )

        await untilBrowserLogAfter(
          () => {
            editFile(file, (code) =>
              code.replace('-- unused --', '-> unused <-'),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual(['-> unused <-', `[vite] hot updated: ${url}`])
          },
        )
      })

      test("doesn't accept itself if any of its exports is imported", async () => {
        const fileName = 'used.ts'
        const file = `${testDir}/${fileName}`

        await untilBrowserLogAfter(
          () => page.goto(`${viteTestUrl}/${testDir}/`),
          [CONNECTED, '-- used --'],
          (logs) => {
            expect(logs).toContain('-- used --')
            expect(logs).toContain('used:foo0')
          },
        )

        await untilBrowserLogAfter(
          async () => {
            editFile(file, (code) =>
              code.replace('foo0', 'foo1').replace('-- used --', '-> used <-'),
            )
            await page.waitForEvent('load')
          },
          [CONNECTED, /used:foo/],
          (logs) => {
            expect(logs).toContain('-> used <-')
            expect(logs).toContain('used:foo1')
          },
        )
      })
    })

    describe('indiscriminate imports: import *', () => {
      const testStarExports = (testDirName: string) => {
        const testDir = `${baseDir}/${testDirName}`

        it('accepts itself if all its exports are accepted', async () => {
          const fileName = 'deps-all-accepted.ts'
          const file = `${testDir}/${fileName}`
          const url = '/' + file

          await untilBrowserLogAfter(
            () => page.goto(`${viteTestUrl}/${testDir}/`),
            [CONNECTED, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:all:a0b0c0default0')
              expect(logs).toContain('all >>>>>> a0, b0, c0')
            },
          )

          await untilBrowserLogAfter(
            () => {
              editFile(file, (code) => code.replace(/([abc])0/g, '$11'))
            },
            HOT_UPDATED,
            (logs) => {
              expect(logs).toEqual([
                'all >>>>>> a1, b1, c1',
                `[vite] hot updated: ${url}`,
              ])
            },
          )

          await untilBrowserLogAfter(
            () => {
              editFile(file, (code) => code.replace(/([abc])1/g, '$12'))
            },
            HOT_UPDATED,
            (logs) => {
              expect(logs).toEqual([
                'all >>>>>> a2, b2, c2',
                `[vite] hot updated: ${url}`,
              ])
            },
          )
        })

        it("doesn't accept itself if one export is not accepted", async () => {
          const fileName = 'deps-some-accepted.ts'
          const file = `${testDir}/${fileName}`

          await untilBrowserLogAfter(
            () => page.goto(`${viteTestUrl}/${testDir}/`),
            [CONNECTED, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:some:a0b0c0default0')
              expect(logs).toContain('some >>>>>> a0, b0, c0')
            },
          )

          await untilBrowserLogAfter(
            async () => {
              const loadPromise = page.waitForEvent('load')
              editFile(file, (code) => code.replace(/([abc])0/g, '$11'))
              await loadPromise
            },
            [CONNECTED, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:some:a1b1c1default0')
              expect(logs).toContain('some >>>>>> a1, b1, c1')
            },
          )
        })
      }

      describe('import * from ...', () => testStarExports('star-imports'))

      describe('dynamic import(...)', () => testStarExports('dynamic-imports'))
    })
  })

  test('css in html hmr', async () => {
    await page.goto(viteTestUrl)
    expect(await getBg('.import-image')).toMatch('icon')
    await page.goto(viteTestUrl + '/foo/', { waitUntil: 'load' })
    expect(await getBg('.import-image')).toMatch('icon')

    const loadPromise = page.waitForEvent('load')
    editFile('index.html', (code) => code.replace('url("./icon.png")', ''))
    await loadPromise
    expect(await getBg('.import-image')).toMatch('')
  })

  test('HTML', async () => {
    await page.goto(viteTestUrl + '/counter/index.html')
    let btn = await page.$('button')
    expect(await btn.textContent()).toBe('Counter 0')

    const loadPromise = page.waitForEvent('load')
    editFile('counter/index.html', (code) =>
      code.replace('Counter', 'Compteur'),
    )
    await loadPromise
    btn = await page.$('button')
    expect(await btn.textContent()).toBe('Compteur 0')
  })

  test('handle virtual module updates', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('.virtual')
    expect(await el.textContent()).toBe('[success]0')
    editFile('importedVirtual.js', (code) => code.replace('[success]', '[wow]'))
    await expect
      .poll(async () => {
        const el = await page.$('.virtual')
        return await el.textContent()
      })
      .toBe('[wow]0')
  })

  test('invalidate virtual module', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('.virtual')
    expect(await el.textContent()).toBe('[wow]0')
    const btn = await page.$('.virtual-update')
    btn.click()
    await expect
      .poll(async () => {
        const el = await page.$('.virtual')
        return await el.textContent()
      })
      .toBe('[wow]1')
  })

  test('handle virtual module accept updates', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('.virtual-dep')
    expect(await el.textContent()).toBe('0')
    editFile('importedVirtual.js', (code) => code.replace('[success]', '[wow]'))
    await expect
      .poll(async () => {
        const el = await page.$('.virtual-dep')
        return await el.textContent()
      })
      .toBe('[wow]0')
  })

  test('invalidate virtual module and accept', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('.virtual-dep')
    expect(await el.textContent()).toBe('0')
    const btn = await page.$('.virtual-update-dep')
    btn.click()
    await expect
      .poll(async () => {
        const el = await page.$('.virtual-dep')
        return await el.textContent()
      })
      .toBe('[wow]2')
  })

  test('keep hmr reload after missing import on server startup', async () => {
    const file = 'missing-import/a.js'
    const importCode = "import 'missing-modules'"
    const unImportCode = `// ${importCode}`

    await untilBrowserLogAfter(
      () =>
        page.goto(viteTestUrl + '/missing-import/index.html', {
          waitUntil: 'load',
        }),
      /connected/, // wait for HMR connection
    )

    await untilBrowserLogAfter(async () => {
      const loadPromise = page.waitForEvent('load')
      editFile(file, (code) => code.replace(importCode, unImportCode))
      await loadPromise
    }, ['missing test', /connected/])

    await untilBrowserLogAfter(async () => {
      const loadPromise = page.waitForEvent('load')
      editFile(file, (code) => code.replace(unImportCode, importCode))
      await loadPromise
    }, [/500/, /connected/])
  })

  test('should hmr when file is deleted and restored', async () => {
    await page.goto(viteTestUrl)

    const parentFile = 'file-delete-restore/parent.js'
    const childFile = 'file-delete-restore/child.js'

    await expect
      .poll(() => page.textContent('.file-delete-restore'))
      .toMatch('parent:child')

    editFile(childFile, (code) =>
      code.replace("value = 'child'", "value = 'child1'"),
    )
    await expect
      .poll(() => page.textContent('.file-delete-restore'))
      .toMatch('parent:child1')

    // delete the file
    editFile(parentFile, (code) =>
      code.replace(
        "export { value as childValue } from './child'",
        "export const childValue = 'not-child'",
      ),
    )
    const originalChildFileCode = readFile(childFile)
    await Promise.all([
      untilBrowserLogAfter(
        () => removeFile(childFile),
        `${childFile} is disposed`,
      ),
      expect
        .poll(() => page.textContent('.file-delete-restore'))
        .toMatch('parent:not-child'),
    ])

    await untilBrowserLogAfter(async () => {
      const loadPromise = page.waitForEvent('load')
      addFile(childFile, originalChildFileCode)
      editFile(parentFile, (code) =>
        code.replace(
          "export const childValue = 'not-child'",
          "export { value as childValue } from './child'",
        ),
      )
      await loadPromise
    }, [/connected/])
    await expect
      .poll(() => page.textContent('.file-delete-restore'))
      .toMatch('parent:child')
  })

  test('delete file should not break hmr', async () => {
    await page.goto(viteTestUrl)

    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 1')

    // add state
    await page.click('.intermediate-file-delete-increment')
    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 2')

    // update import, hmr works
    editFile('intermediate-file-delete/index.js', (code) =>
      code.replace("from './re-export.js'", "from './display.js'"),
    )
    editFile('intermediate-file-delete/display.js', (code) =>
      code.replace('count is ${count}', 'count is ${count}!'),
    )
    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 2!')

    // remove unused file, page reload because it's considered entry point now
    removeFile('intermediate-file-delete/re-export.js')
    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 1!')

    // re-add state
    await page.click('.intermediate-file-delete-increment')
    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 2!')

    // hmr works after file deletion
    editFile('intermediate-file-delete/display.js', (code) =>
      code.replace('count is ${count}!', 'count is ${count}'),
    )
    await expect
      .poll(() => page.textContent('.intermediate-file-delete-display'))
      .toMatch('count is 2')
  })

  test('deleted file should trigger dispose and prune callbacks', async () => {
    await page.goto(viteTestUrl)

    const parentFile = 'file-delete-restore/parent.js'
    const childFile = 'file-delete-restore/child.js'
    const originalChildFileCode = readFile(childFile)

    await untilBrowserLogAfter(
      () => {
        // delete the file
        editFile(parentFile, (code) =>
          code.replace(
            "export { value as childValue } from './child'",
            "export const childValue = 'not-child'",
          ),
        )
        removeFile(childFile)
      },
      [
        'file-delete-restore/child.js is disposed',
        'file-delete-restore/child.js is pruned',
      ],
      false,
    )
    await expect
      .poll(() => page.textContent('.file-delete-restore'))
      .toMatch('parent:not-child')

    // restore the file
    addFile(childFile, originalChildFileCode)
    editFile(parentFile, (code) =>
      code.replace(
        "export const childValue = 'not-child'",
        "export { value as childValue } from './child'",
      ),
    )
    await expect
      .poll(() => page.textContent('.file-delete-restore'))
      .toMatch('parent:child')
  })

  test('import.meta.hot?.accept', async () => {
    await page.goto(viteTestUrl)

    const el = await page.$('.optional-chaining')
    await untilBrowserLogAfter(
      () =>
        editFile('optional-chaining/child.js', (code) =>
          code.replace('const foo = 1', 'const foo = 2'),
        ),
      '(optional-chaining) child update',
    )
    await expect.poll(() => el.textContent()).toMatch('2')
  })

  test('hmr works for self-accepted module within circular imported files', async () => {
    await page.goto(viteTestUrl + '/self-accept-within-circular/index.html')
    const el = await page.$('.self-accept-within-circular')
    expect(await el.textContent()).toBe('c')
    editFile('self-accept-within-circular/c.js', (code) =>
      code.replace(`export const c = 'c'`, `export const c = 'cc'`),
    )
    await expect
      .poll(() => page.textContent('.self-accept-within-circular'))
      .toBe('cc')
    expect(serverLogs.length).greaterThanOrEqual(1)
    // Should still keep hmr update, but it'll error on the browser-side and will refresh itself.
    // Match on full log not possible because of color markers
    expect(serverLogs.at(-1)!).toContain('hmr update')
  })

  test('hmr should not reload if no accepted within circular imported files', async () => {
    await page.goto(viteTestUrl + '/circular/index.html')
    const el = await page.$('.circular')
    expect(await el.textContent()).toBe(
      'mod-a -> mod-b -> mod-c -> mod-a (expected error)',
    )
    editFile('circular/mod-b.js', (code) =>
      code.replace(`mod-b ->`, `mod-b (edited) ->`),
    )
    await expect
      .poll(() => el.textContent())
      .toBe('mod-a -> mod-b (edited) -> mod-c -> mod-a (expected error)')
  })

  test('not inlined assets HMR', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('#logo-no-inline')
    await untilBrowserLogAfter(
      () =>
        editFile('logo-no-inline.svg', (code) =>
          code.replace('height="30px"', 'height="40px"'),
        ),
      /Logo-no-inline updated/,
    )
    await expect
      .poll(() => el.evaluate((it) => `${it.clientHeight}`))
      .toMatch('40')
  })

  test('inlined assets HMR', async () => {
    await page.goto(viteTestUrl)
    const el = await page.$('#logo')
    await untilBrowserLogAfter(
      () =>
        editFile('logo.svg', (code) =>
          code.replace('height="30px"', 'height="40px"'),
        ),
      /Logo updated/,
    )
    await expect
      .poll(() => el.evaluate((it) => `${it.clientHeight}`))
      .toMatch('40')
  })

  test('CSS HMR with this.addWatchFile', async () => {
    await page.goto(viteTestUrl + '/css-deps/index.html')
    expect(await getColor('.css-deps')).toBe('red')
    editFile('css-deps/dep.js', (code) => code.replace(`red`, `green`))
    await expect.poll(() => getColor('.css-deps')).toBe('green')
  })

  test('hmr should happen after missing file is created', async () => {
    const file = 'missing-file/a.js'
    const code = 'console.log("a.js")'

    await untilBrowserLogAfter(
      () =>
        page.goto(viteTestUrl + '/missing-file/index.html', {
          waitUntil: 'load',
        }),
      /connected/, // wait for HMR connection
    )

    await untilBrowserLogAfter(async () => {
      const loadPromise = page.waitForEvent('load')
      addFile(file, code)
      await loadPromise
    }, [/connected/, 'a.js'])
  })
}



================================================
FILE: playground/hmr/accept-exports/dynamic-imports/deps-all-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

console.log(`all >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'c', 'default'])
}



================================================
FILE: playground/hmr/accept-exports/dynamic-imports/deps-some-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

console.log(`some >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'default'])
}



================================================
FILE: playground/hmr/accept-exports/dynamic-imports/dynamic-imports.ts
================================================
Promise.all([import('./deps-all-accepted'), import('./deps-some-accepted')])
  .then(([all, some]) => {
    console.log('loaded:all:' + all.a + all.b + all.c + all.default)
    console.log('loaded:some:' + some.a + some.b + some.c + some.default)
    console.log('>>> ready <<<')
  })
  .catch((err) => {
    console.error(err)
  })



================================================
FILE: playground/hmr/accept-exports/dynamic-imports/index.html
================================================
<script type="module" src="./dynamic-imports.ts"></script>

<div class="app"></div>



================================================
FILE: playground/hmr/accept-exports/export-from/depA.ts
================================================
export const a = 'Ax'



================================================
FILE: playground/hmr/accept-exports/export-from/export-from.ts
================================================
import { a } from './hub'

console.log(a)

if (import.meta.hot) {
  import.meta.hot.accept()
} else {
}



================================================
FILE: playground/hmr/accept-exports/export-from/hub.ts
================================================
export * from './depA'



================================================
FILE: playground/hmr/accept-exports/export-from/index.html
================================================
<script type="module" src="./export-from.ts"></script>

<div class="app"></div>



================================================
FILE: playground/hmr/accept-exports/main-accepted/callback.ts
================================================
export const x = 'X'

if (import.meta.hot) {
  import.meta.hot.acceptExports(['x'], (m) => {
    console.log(`reloaded >>> ${m.x}`)
  })
}



================================================
FILE: playground/hmr/accept-exports/main-accepted/dep.ts
================================================
export default 'dep0'



================================================
FILE: playground/hmr/accept-exports/main-accepted/index.html
================================================
<script type="module" src="./main-accepted.ts"></script>



================================================
FILE: playground/hmr/accept-exports/main-accepted/main-accepted.ts
================================================
import def, { a } from './target'
import { x } from './callback'

// we don't want to pollute other checks' logs...
if (0 > 1) console.log(x)

console.log(`>>>>>> ${a} ${def}`)



================================================
FILE: playground/hmr/accept-exports/main-accepted/target.ts
================================================
import dep from './dep'

export const a = 'A0'

const bValue = 'B0'
export { bValue as b }

const def = 'D0'

export default def

console.log(`<<<<<< ${a} ${bValue} ${def} ; ${dep}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'default'])
}



================================================
FILE: playground/hmr/accept-exports/main-non-accepted/default.ts
================================================
export const x = 'y'

const def = 'def0'

export default def

console.log(`<<< default: ${def}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['x'])
}



================================================
FILE: playground/hmr/accept-exports/main-non-accepted/dep.ts
================================================
export default 'dep0'



================================================
FILE: playground/hmr/accept-exports/main-non-accepted/index.html
================================================
<script type="module" src="./main-non-accepted.ts"></script>



================================================
FILE: playground/hmr/accept-exports/main-non-accepted/main-non-accepted.ts
================================================
import { a } from './named'
import def from './default'

console.log(`>>>>>> ${a} ${def}`)



================================================
FILE: playground/hmr/accept-exports/main-non-accepted/named.ts
================================================
import dep from './dep'

export const a = 'A0'

export const b = 'B0'

console.log(`<<< named: ${a} ; ${dep}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['b'])
}



================================================
FILE: playground/hmr/accept-exports/side-effects/index.html
================================================
<script type="module" src="./side-effects.ts"></script>

<div class="app"></div>



================================================
FILE: playground/hmr/accept-exports/side-effects/side-effects.ts
================================================
export const x = 'x'

export const y = 'y'

export default 'z'

console.log('>>> side FX')

document.querySelector('.app').textContent = 'hey'

if (import.meta.hot) {
  import.meta.hot.acceptExports(['default'])
}



================================================
FILE: playground/hmr/accept-exports/star-imports/deps-all-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

console.log(`all >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'c', 'default'])
}



================================================
FILE: playground/hmr/accept-exports/star-imports/deps-some-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

console.log(`some >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'default'])
}



================================================
FILE: playground/hmr/accept-exports/star-imports/index.html
================================================
<script type="module" src="./star-imports.ts"></script>



================================================
FILE: playground/hmr/accept-exports/star-imports/star-imports.ts
================================================
import * as all from './deps-all-accepted'
import * as some from './deps-some-accepted'

console.log('loaded:all:' + all.a + all.b + all.c + all.default)
console.log('loaded:some:' + some.a + some.b + some.c + some.default)
console.log('>>> ready <<<')



================================================
FILE: playground/hmr/accept-exports/unused-exports/index.html
================================================
<script type="module" src="./index.ts"></script>



================================================
FILE: playground/hmr/accept-exports/unused-exports/index.ts
================================================
import './unused'
import { foo } from './used'

console.log('used:' + foo)



================================================
FILE: playground/hmr/accept-exports/unused-exports/unused.ts
================================================
export const x = 'x'

export const y = 'y'

export default 'z'

console.log('-- unused --')

if (import.meta.hot) {
  import.meta.hot.acceptExports([])
}



================================================
FILE: playground/hmr/accept-exports/unused-exports/used.ts
================================================
export const foo = 'foo0'

export const bar = 'bar0'

console.log('-- used --')

if (import.meta.hot) {
  import.meta.hot.acceptExports([])
}



================================================
FILE: playground/hmr/circular/index.js
================================================
import { msg } from './mod-a'

document.querySelector('.circular').textContent = msg

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr/circular/mod-a.js
================================================
export const value = 'mod-a'

import { value as _value } from './mod-b'

export const msg = `mod-a -> ${_value}`



================================================
FILE: playground/hmr/circular/mod-b.js
================================================
import { value as _value } from './mod-c'

export const value = `mod-b -> ${_value}`



================================================
FILE: playground/hmr/circular/mod-c.js
================================================
import { value as _value } from './mod-a'

// Should error as `_value` is not defined yet within the circular imports
let __value
try {
  __value = `${_value} (unexpected no error)`
} catch {
  __value = 'mod-a (expected error)'
}

export const value = `mod-c -> ${__value}`



================================================
FILE: playground/hmr/counter/dep.ts
================================================
// This file is never loaded
if (import.meta.hot) {
  import.meta.hot.accept(() => {})
}



================================================
FILE: playground/hmr/counter/index.html
================================================
<button>Counter 0</button>
<script type="module" src="./index.ts"></script>



================================================
FILE: playground/hmr/counter/index.ts
================================================
const btn = document.querySelector('button')
let count = 0
const update = () => {
  btn.textContent = `Counter ${count}`
}
btn.onclick = () => {
  count++
  update()
}
function neverCalled() {
  import('./dep')
}



================================================
FILE: playground/hmr/css-deps/dep.js
================================================
// This file is depended by main.css via this.addWatchFile
export const color = 'red'

// Self-accept so that updating this file would not trigger a page reload.
// We only want to observe main.css updating itself.
if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr/css-deps/index.html
================================================
<div class="css-deps">should be red</div>

<script type="module">
  import './main.css'
  // Import dep.js so that not only the CSS depends on dep.js, as Vite will do
  // a full page reload if the only importers are CSS files.
  import './dep.js'
</script>



================================================
FILE: playground/hmr/css-deps/main.css
================================================
.css-deps {
  color: replaced;
}



================================================
FILE: playground/hmr/file-delete-restore/child.js
================================================
import { rerender } from './runtime'

export const value = 'child'

if (import.meta.hot) {
  import.meta.hot.accept((newMod) => {
    if (!newMod) return

    rerender({ child: newMod.value })
  })

  import.meta.hot.dispose(() => {
    console.log('file-delete-restore/child.js is disposed')
  })

  import.meta.hot.prune(() => {
    console.log('file-delete-restore/child.js is pruned')
  })
}



================================================
FILE: playground/hmr/file-delete-restore/index.js
================================================
import { render } from './runtime'
import { childValue, parentValue } from './parent'

render({ parent: parentValue, child: childValue })



================================================
FILE: playground/hmr/file-delete-restore/parent.js
================================================
import { rerender } from './runtime'

export const parentValue = 'parent'
export { value as childValue } from './child'

if (import.meta.hot) {
  import.meta.hot.accept((newMod) => {
    if (!newMod) return

    rerender({ child: newMod.childValue, parent: newMod.parentValue })
  })
}



================================================
FILE: playground/hmr/file-delete-restore/runtime.js
================================================
let state = {}

export const render = (newState) => {
  state = newState
  apply()
}

export const rerender = (updates) => {
  state = { ...state, ...updates }
  apply()
}

const apply = () => {
  document.querySelector('.file-delete-restore').textContent =
    Object.values(state).join(':')
}



================================================
FILE: playground/hmr/importing-updated/a.js
================================================
const val = 'a0'
document.querySelector('.importing-reloaded').innerHTML += `a.js: ${val}<br>`

export default val

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr/importing-updated/b.js
================================================
import a from './a.js'

const val = `b0,${a}`
document.querySelector('.importing-reloaded').innerHTML += `b.js: ${val}<br>`

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr/importing-updated/index.js
================================================
import './a'
import './b'



================================================
FILE: playground/hmr/intermediate-file-delete/display.js
================================================
export const displayCount = (count) => `count is ${count}`



================================================
FILE: playground/hmr/intermediate-file-delete/index.js
================================================
import { displayCount } from './re-export.js'

const button = document.querySelector('.intermediate-file-delete-increment')

const render = () => {
  document.querySelector('.intermediate-file-delete-display').textContent =
    displayCount(Number(button.textContent))
}

render()

button.addEventListener('click', () => {
  button.textContent = `${Number(button.textContent) + 1}`
  render()
})

if (import.meta.hot) import.meta.hot.accept()



================================================
FILE: playground/hmr/intermediate-file-delete/re-export.js
================================================
export * from './display.js'



================================================
FILE: playground/hmr/invalidation/child.js
================================================
if (import.meta.hot) {
  // Need to accept, to register a callback for HMR
  import.meta.hot.accept(() => {
    // Trigger HMR in importers
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr/invalidation/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept()
}

console.log('(invalidation) parent is executing')

document.querySelector('.invalidation-parent').innerHTML = value



================================================
FILE: playground/hmr/invalidation/root.js
================================================
import './parent.js'

if (import.meta.hot) {
  // Need to accept, to register a callback for HMR
  import.meta.hot.accept(() => {
    // Triggers full page reload because no importers
    import.meta.hot.invalidate()
  })
}

const root = document.querySelector('.invalidation-root')

// Non HMR-able behaviour
if (!root.innerHTML) {
  root.innerHTML = 'Init'
}



================================================
FILE: playground/hmr/invalidation-circular-deps/index.js
================================================
import './circular-invalidate/parent'
import './invalidate-handled-in-circle/parent'



================================================
FILE: playground/hmr/invalidation-circular-deps/circular-invalidate/child.js
================================================
import './parent'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr/invalidation-circular-deps/circular-invalidate/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

console.log('(invalidation circular deps) parent is executing')
setTimeout(() => {
  document.querySelector('.invalidation-circular-deps').innerHTML = value
})



================================================
FILE: playground/hmr/invalidation-circular-deps/invalidate-handled-in-circle/child.js
================================================
import './parent'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr/invalidation-circular-deps/invalidate-handled-in-circle/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept(() => {})
}

console.log('(invalidation circular deps handled) parent is executing')
setTimeout(() => {
  document.querySelector('.invalidation-circular-deps-handled').innerHTML =
    value
})



================================================
FILE: playground/hmr/missing-file/index.html
================================================
<div>Page</div>
<script type="module" src="main.js"></script>



================================================
FILE: playground/hmr/missing-file/main.js
================================================
import './a.js'



================================================
FILE: playground/hmr/missing-import/a.js
================================================
import 'missing-modules'

console.log('missing test')



================================================
FILE: playground/hmr/missing-import/index.html
================================================
<div>Page</div>
<script type="module" src="main.js"></script>



================================================
FILE: playground/hmr/missing-import/main.js
================================================
import './a.js'



================================================
FILE: playground/hmr/optional-chaining/child.js
================================================
export const foo = 1



================================================
FILE: playground/hmr/optional-chaining/parent.js
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { foo } from './child'

import.meta.hot?.accept('./child', ({ foo }) => {
  console.log('(optional-chaining) child update')
  document.querySelector('.optional-chaining').textContent = foo
})



================================================
FILE: playground/hmr/self-accept-within-circular/a.js
================================================
import { b } from './b'

export const a = {
  b,
}



================================================
FILE: playground/hmr/self-accept-within-circular/b.js
================================================
import { c } from './c'

const b = {
  c,
}

export { b }



================================================
FILE: playground/hmr/self-accept-within-circular/c.js
================================================
import './b'

export const c = 'c'

function render(content) {
  document.querySelector('.self-accept-within-circular').textContent = content
}
render(c)

import.meta.hot?.accept((nextExports) => {
  render(nextExports.c)
})



================================================
FILE: playground/hmr/self-accept-within-circular/index.html
================================================
<script type="module" src="index.js"></script>
<div class="self-accept-within-circular"></div>



================================================
FILE: playground/hmr/self-accept-within-circular/index.js
================================================
import { a } from './a'

console.log(a)



================================================
FILE: playground/hmr/soft-invalidation/child.js
================================================
export const foo = 'bar'



================================================
FILE: playground/hmr/soft-invalidation/index.js
================================================
import { foo } from './child'

// @ts-expect-error global
export const msg = `soft-invalidation/index.js is transformed ${__TRANSFORM_COUNT__} times. child is ${foo}`



================================================
FILE: playground/hmr/unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html
================================================
<div id="app">title</div>



================================================
FILE: playground/hmr-root/foo.js
================================================
export const foo = 'foo'



================================================
FILE: playground/hmr-root/vite.config.ts
================================================
import path from 'node:path'
import url from 'node:url'
import { defineConfig } from 'vite'

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

export default defineConfig({
  root: path.join(__dirname, './root'),
})



================================================
FILE: playground/hmr-root/__tests__/hmr-root.spec.ts
================================================
import { expect, test } from 'vitest'

import { editFile, isServe, page } from '~utils'

test.runIf(isServe)('should watch files outside root', async () => {
  expect(await page.textContent('#foo')).toBe('foo')
  editFile('foo.js', (code) => code.replace("'foo'", "'foobar'"))
  await page.waitForEvent('load')
  await expect.poll(() => page.textContent('#foo')).toBe('foobar')
})



================================================
FILE: playground/hmr-root/root/index.html
================================================
<div id="foo"></div>

<script type="module">
  import { foo } from '../foo.js'

  document.querySelector('#foo').textContent = foo
</script>



================================================
FILE: playground/hmr-ssr/customFile.js
================================================
export const msg = 'custom'



================================================
FILE: playground/hmr-ssr/event.d.ts
================================================
import 'vite/types/customEvent'

declare module 'vite/types/customEvent' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
    'custom:remote-add': { a: number; b: number }
    'custom:remote-add-result': { result: string }
  }
}

declare global {
  let log: (...msg: unknown[]) => void
  let logger: {
    error: (msg: string | Error) => void
    debug: (...msg: unknown[]) => void
  }
}



================================================
FILE: playground/hmr-ssr/hmr.ts
================================================
import { virtual } from 'virtual:file'
import { foo as depFoo, nestedFoo } from './hmrDep'
import './importing-updated'
import './invalidation-circular-deps'
import './invalidation/parent'
import './file-delete-restore'
import './optional-chaining/parent'
import './intermediate-file-delete'
import './circular'
import './queries'
import logo from './logo.svg'
import logoNoInline from './logo-no-inline.svg'
import { msg as softInvalidationMsg } from './soft-invalidation'

export const foo = 1
text('.app', foo)
text('.dep', depFoo)
text('.nested', nestedFoo)
text('.virtual', virtual)
text('.soft-invalidation', softInvalidationMsg)
setImgSrc('#logo', logo)
setImgSrc('#logo-no-inline', logoNoInline)

globalThis.__HMR__['virtual:increment'] = () => {
  if (import.meta.hot) {
    import.meta.hot.send('virtual:increment')
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ foo }) => {
    log('(self-accepting 1) foo is now:', foo)
  })

  import.meta.hot.accept(({ foo }) => {
    log('(self-accepting 2) foo is now:', foo)
  })

  const handleDep = (type, newFoo, newNestedFoo) => {
    log(`(${type}) foo is now: ${newFoo}`)
    log(`(${type}) nested foo is now: ${newNestedFoo}`)
    text('.dep', newFoo)
    text('.nested', newNestedFoo)
  }

  import.meta.hot.accept('./logo.svg', (newUrl) => {
    setImgSrc('#logo', newUrl.default)
    log('Logo updated', newUrl.default)
  })

  import.meta.hot.accept('./logo-no-inline.svg', (newUrl) => {
    setImgSrc('#logo-no-inline', newUrl.default)
    log('Logo-no-inline updated', newUrl.default)
  })

  import.meta.hot.accept('./hmrDep', ({ foo, nestedFoo }) => {
    handleDep('single dep', foo, nestedFoo)
  })

  import.meta.hot.accept(['./hmrDep'], ([{ foo, nestedFoo }]) => {
    handleDep('multi deps', foo, nestedFoo)
  })

  import.meta.hot.dispose(() => {
    log(`foo was:`, foo)
  })

  import.meta.hot.on('vite:afterUpdate', (event) => {
    log(`>>> vite:afterUpdate -- ${event.type}`)
  })

  import.meta.hot.on('vite:beforeUpdate', (event) => {
    log(`>>> vite:beforeUpdate -- ${event.type}`)

    const cssUpdate = event.updates.find(
      (update) =>
        update.type === 'css-update' && update.path.includes('global.css'),
    )
    if (cssUpdate) {
      log('CSS updates are not supported in SSR')
    }
  })

  import.meta.hot.on('vite:error', (event) => {
    log(`>>> vite:error -- ${event.err.message}`)
  })

  import.meta.hot.on('vite:invalidate', ({ path }) => {
    log(`>>> vite:invalidate -- ${path}`)
  })

  import.meta.hot.on('custom:foo', ({ msg }) => {
    text('.custom', msg)
  })

  import.meta.hot.on('custom:remove', removeCb)

  // send custom event to server to calculate 1 + 2
  import.meta.hot.send('custom:remote-add', { a: 1, b: 2 })
  import.meta.hot.on('custom:remote-add-result', ({ result }) => {
    text('.custom-communication', result)
  })
}

function text(el, text) {
  hmr(el, text)
}

function setImgSrc(el, src) {
  hmr(el, src)
}

function removeCb({ msg }) {
  text('.toRemove', msg)
  import.meta.hot.off('custom:remove', removeCb)
}

function hmr(key: string, value: unknown) {
  ;(globalThis.__HMR__ as any)[key] = String(value)
}



================================================
FILE: playground/hmr-ssr/hmrDep.js
================================================
export const foo = 1
export { foo as nestedFoo } from './hmrNestedDep'

if (import.meta.hot) {
  const data = import.meta.hot.data
  if ('fromDispose' in data) {
    log(`(dep) foo from dispose: ${data.fromDispose}`)
  }

  import.meta.hot.dispose((data) => {
    log(`(dep) foo was: ${foo}`)
    data.fromDispose = foo
  })
}



================================================
FILE: playground/hmr-ssr/hmrNestedDep.js
================================================
export const foo = 1



================================================
FILE: playground/hmr-ssr/importedVirtual.js
================================================
export const virtual = '[success]'



================================================
FILE: playground/hmr-ssr/modules.d.ts
================================================
declare module 'virtual:file' {
  export const virtual: string
}
declare module '*?query1' {
  const string: string
  export default string
}
declare module '*?query2' {
  const string: string
  export default string
}



================================================
FILE: playground/hmr-ssr/package.json
================================================
{
  "name": "@vitejs/test-hmr-ssr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/hmr-ssr/unresolved.ts
================================================
export const foo = 1
hmr('.app', foo)

if (import.meta.hot) {
  import.meta.hot.accept(({ foo }) => {
    log('(self-accepting 1) foo is now:', foo)
  })

  import.meta.hot.accept(({ foo }) => {
    log('(self-accepting 2) foo is now:', foo)
  })

  import.meta.hot.dispose(() => {
    log(`foo was:`, foo)
  })
}

function hmr(key: string, value: unknown) {
  ;(globalThis.__HMR__ as any)[key] = String(value)
}



================================================
FILE: playground/hmr-ssr/vite.config.ts
================================================
import { defineConfig } from 'vite'
import type { Plugin } from 'vite'

export default defineConfig({
  experimental: {
    hmrPartialAccept: true,
  },
  build: {
    assetsInlineLimit(filePath) {
      if (filePath.endsWith('logo-no-inline.svg')) {
        return false
      }
    },
  },
  plugins: [
    {
      name: 'mock-custom',
      async hotUpdate({ file, read, server }) {
        if (file.endsWith('customFile.js')) {
          const content = await read()
          const msg = content.match(/export const msg = '(\w+)'/)[1]
          this.environment.hot.send('custom:foo', { msg })
          this.environment.hot.send('custom:remove', { msg })
        }
      },
      configureServer(server) {
        server.environments.ssr.hot.on(
          'custom:remote-add',
          ({ a, b }, client) => {
            client.send('custom:remote-add-result', { result: a + b })
          },
        )
      },
    },
    virtualPlugin(),
    transformCountPlugin(),
    queryPlugin(),
  ],
})

function virtualPlugin(): Plugin {
  let num = 0
  return {
    name: 'virtual-file',
    resolveId(id, importer) {
      if (id === 'virtual:file' || id === '\0virtual:file') {
        return '\0virtual:file'
      }
    },
    load(id) {
      if (id === '\0virtual:file') {
        return `\
import { virtual as _virtual } from "/importedVirtual.js";
export const virtual = _virtual + '${num}';`
      }
    },
    configureServer(server) {
      server.environments.ssr.hot.on('virtual:increment', async () => {
        const mod =
          await server.environments.ssr.moduleGraph.getModuleByUrl(
            '\0virtual:file',
          )
        if (mod) {
          num++
          server.environments.ssr.reloadModule(mod)
        }
      })
    },
  }
}

function queryPlugin(): Plugin {
  return {
    name: 'query-resolver',
    transform(code, id) {
      if (id.includes('?query1')) {
        return `export default ${JSON.stringify(code + 'query1')}`
      }

      if (id.includes('?query2')) {
        return `export default ${JSON.stringify(code + 'query2')}`
      }
    },
  }
}

function transformCountPlugin(): Plugin {
  let num = 0
  return {
    name: 'transform-count',
    transform(code) {
      if (code.includes('__TRANSFORM_COUNT__')) {
        return code.replace('__TRANSFORM_COUNT__', String(++num))
      }
    },
  }
}



================================================
FILE: playground/hmr-ssr/__tests__/hmr-ssr.spec.ts
================================================
import fs from 'node:fs'
import { posix, resolve } from 'node:path'
import EventEmitter from 'node:events'
import {
  afterAll,
  beforeAll,
  describe,
  expect,
  onTestFinished,
  test,
  vi,
} from 'vitest'
import type { InlineConfig, RunnableDevEnvironment, ViteDevServer } from 'vite'
import { createRunnableDevEnvironment, createServer } from 'vite'
import type { ModuleRunner } from 'vite/module-runner'
import {
  addFile,
  createInMemoryLogger,
  editFile,
  isBuild,
  promiseWithResolvers,
  readFile,
  removeFile,
  slash,
  testDir,
} from '~utils'

let server: ViteDevServer
const clientLogs: string[] = []
const serverLogs: string[] = []
let runner: ModuleRunner

const logsEmitter = new EventEmitter()

afterAll(async () => {
  await server?.close()
})

const hmr = (key: string) => (globalThis.__HMR__[key] as string) || ''

const updated = (file: string, via?: string) => {
  if (via) {
    return `[vite] hot updated: ${file} via ${via}`
  }
  return `[vite] hot updated: ${file}`
}

if (!isBuild) {
  describe('hmr works correctly', () => {
    beforeAll(async () => {
      await setupModuleRunner('/hmr.ts')
    })

    test('should connect', async () => {
      expect(clientLogs).toContain('[vite] connected.')
    })

    test('self accept', async () => {
      const el = () => hmr('.app')
      await untilConsoleLogAfter(
        () =>
          editFile('hmr.ts', (code) =>
            code.replace('const foo = 1', 'const foo = 2'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          'foo was: 1',
          '(self-accepting 1) foo is now: 2',
          '(self-accepting 2) foo is now: 2',
          updated('/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('2')

      await untilConsoleLogAfter(
        () =>
          editFile('hmr.ts', (code) =>
            code.replace('const foo = 2', 'const foo = 3'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          'foo was: 2',
          '(self-accepting 1) foo is now: 3',
          '(self-accepting 2) foo is now: 3',
          updated('/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('3')
    })

    test('accept dep', async () => {
      const el = () => hmr('.dep')
      await untilConsoleLogAfter(
        () =>
          editFile('hmrDep.js', (code) =>
            code.replace('const foo = 1', 'const foo = 2'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          '(dep) foo was: 1',
          '(dep) foo from dispose: 1',
          '(single dep) foo is now: 2',
          '(single dep) nested foo is now: 1',
          '(multi deps) foo is now: 2',
          '(multi deps) nested foo is now: 1',
          updated('/hmrDep.js', '/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('2')

      await untilConsoleLogAfter(
        () =>
          editFile('hmrDep.js', (code) =>
            code.replace('const foo = 2', 'const foo = 3'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          '(dep) foo was: 2',
          '(dep) foo from dispose: 2',
          '(single dep) foo is now: 3',
          '(single dep) nested foo is now: 1',
          '(multi deps) foo is now: 3',
          '(multi deps) nested foo is now: 1',
          updated('/hmrDep.js', '/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('3')
    })

    test('nested dep propagation', async () => {
      const el = () => hmr('.nested')
      await untilConsoleLogAfter(
        () =>
          editFile('hmrNestedDep.js', (code) =>
            code.replace('const foo = 1', 'const foo = 2'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          '(dep) foo was: 3',
          '(dep) foo from dispose: 3',
          '(single dep) foo is now: 3',
          '(single dep) nested foo is now: 2',
          '(multi deps) foo is now: 3',
          '(multi deps) nested foo is now: 2',
          updated('/hmrDep.js', '/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('2')

      await untilConsoleLogAfter(
        () =>
          editFile('hmrNestedDep.js', (code) =>
            code.replace('const foo = 2', 'const foo = 3'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          '(dep) foo was: 3',
          '(dep) foo from dispose: 3',
          '(single dep) foo is now: 3',
          '(single dep) nested foo is now: 3',
          '(multi deps) foo is now: 3',
          '(multi deps) nested foo is now: 3',
          updated('/hmrDep.js', '/hmr.ts'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('3')
    })

    test('invalidate', async () => {
      const el = () => hmr('.invalidation')
      await untilConsoleLogAfter(
        () =>
          editFile('invalidation/child.js', (code) =>
            code.replace('child', 'child updated'),
          ),
        [
          '>>> vite:beforeUpdate -- update',
          `>>> vite:invalidate -- /invalidation/child.js`,
          '[vite] invalidate /invalidation/child.js',
          updated('/invalidation/child.js'),
          '>>> vite:afterUpdate -- update',
          '>>> vite:beforeUpdate -- update',
          '(invalidation) parent is executing',
          updated('/invalidation/parent.js'),
          '>>> vite:afterUpdate -- update',
        ],
        true,
      )
      await expect.poll(() => el()).toMatch('child updated')
    })

    test('soft invalidate', async () => {
      const el = () => hmr('.soft-invalidation')
      expect(el()).toBe(
        'soft-invalidation/index.js is transformed 1 times. child is bar',
      )
      editFile('soft-invalidation/child.js', (code) =>
        code.replace('bar', 'updated'),
      )
      await expect
        .poll(() => el())
        .toBe(
          'soft-invalidation/index.js is transformed 1 times. child is updated',
        )
    })

    test('invalidate in circular dep should not trigger infinite HMR', async () => {
      const el = () => hmr('.invalidation-circular-deps')
      await expect.poll(() => el()).toMatch('child')
      editFile(
        'invalidation-circular-deps/circular-invalidate/child.js',
        (code) => code.replace('child', 'child updated'),
      )
      await expect.poll(() => el()).toMatch('child updated')
    })

    test('invalidate in circular dep should be hot updated if possible', async () => {
      const el = () => hmr('.invalidation-circular-deps-handled')
      await expect.poll(() => el()).toMatch('child')
      editFile(
        'invalidation-circular-deps/invalidate-handled-in-circle/child.js',
        (code) => code.replace('child', 'child updated'),
      )
      await expect.poll(() => el()).toMatch('child updated')
    })

    test('plugin hmr handler + custom event', async () => {
      const el = () => hmr('.custom')
      editFile('customFile.js', (code) => code.replace('custom', 'edited'))
      await expect.poll(() => el()).toMatch('edited')
    })

    test('plugin hmr remove custom events', async () => {
      const el = () => hmr('.toRemove')
      editFile('customFile.js', (code) => code.replace('custom', 'edited'))
      await expect.poll(() => el()).toMatch('edited')
      editFile('customFile.js', (code) => code.replace('edited', 'custom'))
      await expect.poll(() => el()).toMatch('edited')
    })

    test('plugin client-server communication', async () => {
      const el = () => hmr('.custom-communication')
      await expect.poll(() => el()).toMatch('3')
    })

    test('queries are correctly resolved', async () => {
      const query1 = () => hmr('query1')
      const query2 = () => hmr('query2')

      expect(query1()).toBe('query1')
      expect(query2()).toBe('query2')

      editFile('queries/multi-query.js', (code) => code + '//comment')
      await expect.poll(() => query1()).toBe('//commentquery1')
      await expect.poll(() => query2()).toBe('//commentquery2')
    })
  })

  describe('self accept with different entry point formats', () => {
    test.each(['./unresolved.ts', './unresolved', '/unresolved'])(
      'accepts if entry point is relative to root %s',
      async (entrypoint) => {
        await setupModuleRunner(entrypoint, {}, '/unresolved.ts')

        const originalUnresolvedFile = readFile('unresolved.ts')
        onTestFinished(() => {
          const filepath = resolve(testDir, 'unresolved.ts')
          fs.writeFileSync(filepath, originalUnresolvedFile, 'utf-8')
        })

        const el = () => hmr('.app')
        await untilConsoleLogAfter(
          () =>
            editFile('unresolved.ts', (code) =>
              code.replace('const foo = 1', 'const foo = 2'),
            ),
          [
            'foo was: 1',
            '(self-accepting 1) foo is now: 2',
            '(self-accepting 2) foo is now: 2',
            updated(entrypoint),
          ],
          true,
        )
        await expect.poll(() => el()).toMatch('2')

        await untilConsoleLogAfter(
          () =>
            editFile('unresolved.ts', (code) =>
              code.replace('const foo = 2', 'const foo = 3'),
            ),
          [
            'foo was: 2',
            '(self-accepting 1) foo is now: 3',
            '(self-accepting 2) foo is now: 3',
            updated(entrypoint),
          ],
          true,
        )
        await expect.poll(() => el()).toMatch('3')
      },
    )
  })

  describe('acceptExports', () => {
    const HOT_UPDATED = /hot updated/
    const CONNECTED = /connected/
    const PROGRAM_RELOAD = /program reload/

    const baseDir = 'accept-exports'

    describe('when all used exports are accepted', () => {
      const testDir = baseDir + '/main-accepted'

      const fileName = 'target.ts'
      const file = `${testDir}/${fileName}`
      const url = `/${file}`

      let dep = 'dep0'

      beforeAll(async () => {
        await untilConsoleLogAfter(
          () => setupModuleRunner(`/${testDir}/index`),
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<<<<< A0 B0 D0 ; ${dep}`)
            expect(logs).toContain('>>>>>> A0 D0')
          },
        )
      })

      test('the callback is called with the new version the module', async () => {
        const callbackFile = `${testDir}/callback.ts`
        const callbackUrl = `/${callbackFile}`

        await untilConsoleLogAfter(
          () => {
            editFile(callbackFile, (code) =>
              code
                .replace("x = 'X'", "x = 'Y'")
                .replace('reloaded >>>', 'reloaded (2) >>>'),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              'reloaded >>> Y',
              `[vite] hot updated: ${callbackUrl}`,
            ])
          },
        )

        await untilConsoleLogAfter(
          () => {
            editFile(callbackFile, (code) => code.replace("x = 'Y'", "x = 'Z'"))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              'reloaded (2) >>> Z',
              `[vite] hot updated: ${callbackUrl}`,
            ])
          },
        )
      })

      test('stops HMR bubble on dependency change', async () => {
        const depFileName = 'dep.ts'
        const depFile = `${testDir}/${depFileName}`

        await untilConsoleLogAfter(
          () => {
            editFile(depFile, (code) => code.replace('dep0', (dep = 'dep1')))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A0 B0 D0 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      test('accepts itself and refreshes on change', async () => {
        await untilConsoleLogAfter(
          () => {
            editFile(file, (code) => code.replace(/(\b[A-Z])0/g, '$11'))
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A1 B1 D1 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      test('accepts itself and refreshes on 2nd change', async () => {
        await untilConsoleLogAfter(
          () => {
            editFile(file, (code) =>
              code
                .replace(/(\b[A-Z])1/g, '$12')
                .replace(
                  "acceptExports(['a', 'default']",
                  "acceptExports(['b', 'default']",
                ),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual([
              `<<<<<< A2 B2 D2 ; ${dep}`,
              `[vite] hot updated: ${url}`,
            ])
          },
        )
      })

      test('does not accept itself anymore after acceptedExports change', async () => {
        await untilConsoleLogAfter(
          async () => {
            editFile(file, (code) => code.replace(/(\b[A-Z])2/g, '$13'))
          },
          [PROGRAM_RELOAD, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<<<<< A3 B3 D3 ; ${dep}`)
            expect(logs).toContain('>>>>>> A3 D3')
          },
        )
      })
    })

    describe('when some used exports are not accepted', () => {
      const testDir = baseDir + '/main-non-accepted'

      const namedFileName = 'named.ts'
      const namedFile = `${testDir}/${namedFileName}`
      const defaultFileName = 'default.ts'
      const defaultFile = `${testDir}/${defaultFileName}`
      const depFileName = 'dep.ts'
      const depFile = `${testDir}/${depFileName}`

      const a = 'A0'
      let dep = 'dep0'

      beforeAll(async () => {
        await untilConsoleLogAfter(
          () => setupModuleRunner(`/${testDir}/index`),
          [CONNECTED, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<< named: ${a} ; ${dep}`)
            expect(logs).toContain(`<<< default: def0`)
            expect(logs).toContain(`>>>>>> ${a} def0`)
          },
        )
      })

      test('does not stop the HMR bubble on change to dep', async () => {
        await untilConsoleLogAfter(
          async () => {
            editFile(depFile, (code) => code.replace('dep0', (dep = 'dep1')))
          },
          [PROGRAM_RELOAD, />>>>>>/],
          (logs) => {
            expect(logs).toContain(`<<< named: ${a} ; ${dep}`)
          },
        )
      })

      describe('does not stop the HMR bubble on change to self', () => {
        test('with named exports', async () => {
          await untilConsoleLogAfter(
            async () => {
              editFile(namedFile, (code) => code.replace(a, 'A1'))
            },
            [PROGRAM_RELOAD, />>>>>>/],
            (logs) => {
              expect(logs).toContain(`<<< named: A1 ; ${dep}`)
            },
          )
        })

        test('with default export', async () => {
          await untilConsoleLogAfter(
            async () => {
              editFile(defaultFile, (code) => code.replace('def0', 'def1'))
            },
            [PROGRAM_RELOAD, />>>>>>/],
            (logs) => {
              expect(logs).toContain(`<<< default: def1`)
            },
          )
        })
      })

      describe("doesn't reload if files not in the entrypoint importers chain is changed", async () => {
        const testFile = 'non-tested/index.js'

        beforeAll(async () => {
          clientLogs.length = 0
          // so it's in the module graph
          const ssrEnvironment = server.environments.ssr
          await ssrEnvironment.transformRequest(testFile)
          await ssrEnvironment.transformRequest('non-tested/dep.js')
        })

        test('does not full reload', async () => {
          editFile(
            testFile,
            (code) => code + '\n\nexport const query5 = "query5"',
          )
          const start = Date.now()
          // for 2 seconds check that there is no log about the file being reloaded
          while (Date.now() - start < 2000) {
            if (
              clientLogs.some(
                (log) =>
                  log.match(PROGRAM_RELOAD) ||
                  log.includes('non-tested/index.js'),
              )
            ) {
              throw new Error('File was reloaded')
            }
            await new Promise((r) => setTimeout(r, 100))
          }
        }, 5_000)

        test('does not update', async () => {
          editFile('non-tested/dep.js', (code) => code + '//comment')
          const start = Date.now()
          // for 2 seconds check that there is no log about the file being reloaded
          while (Date.now() - start < 2000) {
            if (
              clientLogs.some(
                (log) =>
                  log.match(PROGRAM_RELOAD) ||
                  log.includes('non-tested/dep.js'),
              )
            ) {
              throw new Error('File was updated')
            }
            await new Promise((r) => setTimeout(r, 100))
          }
        }, 5_000)
      })
    })

    test('accepts itself when imported for side effects only (no bindings imported)', async () => {
      const testDir = baseDir + '/side-effects'
      const file = 'side-effects.ts'

      await untilConsoleLogAfter(
        () => setupModuleRunner(`/${testDir}/index`),
        [CONNECTED, />>>/],
        (logs) => {
          expect(logs).toContain('>>> side FX')
        },
      )

      await untilConsoleLogAfter(
        () => {
          editFile(`${testDir}/${file}`, (code) =>
            code.replace('>>> side FX', '>>> side FX !!'),
          )
        },
        HOT_UPDATED,
        (logs) => {
          expect(logs).toEqual([
            '>>> side FX !!',
            updated(`/${testDir}/${file}`),
          ])
        },
      )
    })

    describe('acceptExports([])', () => {
      const testDir = baseDir + '/unused-exports'

      test('accepts itself if no exports are imported', async () => {
        const fileName = 'unused.ts'
        const file = `${testDir}/${fileName}`
        const url = '/' + file

        await untilConsoleLogAfter(
          () => setupModuleRunner(`/${testDir}/index`),
          [CONNECTED, '-- unused --'],
          (logs) => {
            expect(logs).toContain('-- unused --')
          },
        )

        await untilConsoleLogAfter(
          () => {
            editFile(file, (code) =>
              code.replace('-- unused --', '-> unused <-'),
            )
          },
          HOT_UPDATED,
          (logs) => {
            expect(logs).toEqual(['-> unused <-', updated(url)])
          },
        )
      })

      test("doesn't accept itself if any of its exports is imported", async () => {
        const fileName = 'used.ts'
        const file = `${testDir}/${fileName}`

        await untilConsoleLogAfter(
          () => setupModuleRunner(`/${testDir}/index`),
          [CONNECTED, '-- used --', 'used:foo0'],
          (logs) => {
            expect(logs).toContain('-- used --')
            expect(logs).toContain('used:foo0')
          },
        )

        await untilConsoleLogAfter(
          async () => {
            editFile(file, (code) =>
              code.replace('foo0', 'foo1').replace('-- used --', '-> used <-'),
            )
          },
          [PROGRAM_RELOAD, /used:foo/],
          (logs) => {
            expect(logs).toContain('-> used <-')
            expect(logs).toContain('used:foo1')
          },
        )
      })
    })

    describe('indiscriminate imports: import *', () => {
      const testStarExports = (testDirName: string) => {
        const testDir = `${baseDir}/${testDirName}`

        test('accepts itself if all its exports are accepted', async () => {
          const fileName = 'deps-all-accepted.ts'
          const file = `${testDir}/${fileName}`
          const url = '/' + file

          await untilConsoleLogAfter(
            () => setupModuleRunner(`/${testDir}/index`),
            [CONNECTED, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:all:a0b0c0default0')
              expect(logs).toContain('all >>>>>> a0, b0, c0')
            },
          )

          await untilConsoleLogAfter(
            () => {
              editFile(file, (code) => code.replace(/([abc])0/g, '$11'))
            },
            HOT_UPDATED,
            (logs) => {
              expect(logs).toEqual(['all >>>>>> a1, b1, c1', updated(url)])
            },
          )

          await untilConsoleLogAfter(
            () => {
              editFile(file, (code) => code.replace(/([abc])1/g, '$12'))
            },
            HOT_UPDATED,
            (logs) => {
              expect(logs).toEqual(['all >>>>>> a2, b2, c2', updated(url)])
            },
          )
        })

        test("doesn't accept itself if one export is not accepted", async () => {
          const fileName = 'deps-some-accepted.ts'
          const file = `${testDir}/${fileName}`

          await untilConsoleLogAfter(
            () => setupModuleRunner(`/${testDir}/index`),
            [CONNECTED, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:some:a0b0c0default0')
              expect(logs).toContain('some >>>>>> a0, b0, c0')
            },
          )

          await untilConsoleLogAfter(
            async () => {
              editFile(file, (code) => code.replace(/([abc])0/g, '$11'))
            },
            [PROGRAM_RELOAD, '>>> ready <<<'],
            (logs) => {
              expect(logs).toContain('loaded:some:a1b1c1default0')
              expect(logs).toContain('some >>>>>> a1, b1, c1')
            },
          )
        })
      }

      describe('import * from ...', () => testStarExports('star-imports'))

      describe('dynamic import(...)', () => testStarExports('dynamic-imports'))
    })
  })

  test('handle virtual module updates', async () => {
    await setupModuleRunner('/hmr.ts')
    const el = () => hmr('.virtual')
    expect(el()).toBe('[success]0')
    editFile('importedVirtual.js', (code) => code.replace('[success]', '[wow]'))
    await expect.poll(el).toBe('[wow]0')
  })

  test('invalidate virtual module', async () => {
    await setupModuleRunner('/hmr.ts')
    const el = () => hmr('.virtual')
    expect(el()).toBe('[wow]0')
    globalThis.__HMR__['virtual:increment']()
    await expect.poll(el).toBe('[wow]1')
  })

  test('should hmr when file is deleted and restored', async () => {
    await setupModuleRunner('/hmr.ts')

    const parentFile = 'file-delete-restore/parent.js'
    const childFile = 'file-delete-restore/child.js'

    await expect.poll(() => hmr('.file-delete-restore')).toMatch('parent:child')

    editFile(childFile, (code) =>
      code.replace("value = 'child'", "value = 'child1'"),
    )
    await expect
      .poll(() => hmr('.file-delete-restore'))
      .toMatch('parent:child1')

    // delete the file
    editFile(parentFile, (code) =>
      code.replace(
        "export { value as childValue } from './child'",
        "export const childValue = 'not-child'",
      ),
    )
    const originalChildFileCode = readFile(childFile)
    removeFile(childFile)
    await expect
      .poll(() => hmr('.file-delete-restore'))
      .toMatch('parent:not-child')

    // restore the file
    addFile(childFile, originalChildFileCode)
    editFile(parentFile, (code) =>
      code.replace(
        "export const childValue = 'not-child'",
        "export { value as childValue } from './child'",
      ),
    )
    await expect.poll(() => hmr('.file-delete-restore')).toMatch('parent:child')
  })

  test('delete file should not break hmr', async () => {
    await setupModuleRunner('/hmr.ts', undefined, undefined, {
      '.intermediate-file-delete-increment': '1',
    })

    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 1')

    // add state
    globalThis.__HMR__['.delete-intermediate-file']()
    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 2')

    // update import, hmr works
    editFile('intermediate-file-delete/index.js', (code) =>
      code.replace("from './re-export.js'", "from './display.js'"),
    )
    editFile('intermediate-file-delete/display.js', (code) =>
      code.replace('count is ${count}', 'count is ${count}!'),
    )
    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 2!')

    // remove unused file
    removeFile('intermediate-file-delete/re-export.js')
    __HMR__['.intermediate-file-delete-increment'] = '1' // reset state
    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 1!')

    // re-add state
    globalThis.__HMR__['.delete-intermediate-file']()
    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 2!')

    // hmr works after file deletion
    editFile('intermediate-file-delete/display.js', (code) =>
      code.replace('count is ${count}!', 'count is ${count}'),
    )
    await expect
      .poll(() => hmr('.intermediate-file-delete-display'))
      .toMatch('count is 2')
  })

  test('deleted file should trigger dispose and prune callbacks', async () => {
    await setupModuleRunner('/hmr.ts')

    const parentFile = 'file-delete-restore/parent.js'
    const childFile = 'file-delete-restore/child.js'
    const originalChildFileCode = readFile(childFile)

    await untilConsoleLogAfter(
      () => {
        // delete the file
        editFile(parentFile, (code) =>
          code.replace(
            "export { value as childValue } from './child'",
            "export const childValue = 'not-child'",
          ),
        )
        removeFile(childFile)
      },
      [
        'file-delete-restore/child.js is disposed',
        'file-delete-restore/child.js is pruned',
      ],
      false,
    )

    await expect
      .poll(() => hmr('.file-delete-restore'))
      .toMatch('parent:not-child')

    // restore the file
    addFile(childFile, originalChildFileCode)
    editFile(parentFile, (code) =>
      code.replace(
        "export const childValue = 'not-child'",
        "export { value as childValue } from './child'",
      ),
    )
    await expect.poll(() => hmr('.file-delete-restore')).toMatch('parent:child')
  })

  test('import.meta.hot?.accept', async () => {
    await setupModuleRunner('/hmr.ts')
    await untilConsoleLogAfter(
      () =>
        editFile('optional-chaining/child.js', (code) =>
          code.replace('const foo = 1', 'const foo = 2'),
        ),
      '(optional-chaining) child update',
    )
    await expect.poll(() => hmr('.optional-chaining')?.toString()).toMatch('2')
  })

  test('hmr works for self-accepted module within circular imported files', async () => {
    await setupModuleRunner('/self-accept-within-circular/index')
    const el = () => hmr('.self-accept-within-circular')
    expect(el()).toBe('c')
    editFile('self-accept-within-circular/c.js', (code) =>
      code.replace(`export const c = 'c'`, `export const c = 'cc'`),
    )
    // it throws a same error as browser case,
    // but it doesn't auto reload and it calls `hot.accept(nextExports)` with `nextExports = undefined`

    // test reloading manually for now
    server.moduleGraph.invalidateAll() // TODO: why is `runner.clearCache()` not enough?
    await runner.import('/self-accept-within-circular/index')
    await expect.poll(() => el()).toBe('cc')
  })

  test('hmr should not reload if no accepted within circular imported files', async () => {
    await setupModuleRunner('/circular/index')
    const el = () => hmr('.circular')
    expect(el()).toBe(
      // tests in the browser check that there is an error, but vite runtime just returns undefined in those cases
      'mod-a -> mod-b -> mod-c -> undefined (expected no error)',
    )
    editFile('circular/mod-b.js', (code) =>
      code.replace(`mod-b ->`, `mod-b (edited) ->`),
    )
    await expect
      .poll(() => el())
      .toBe('mod-a -> mod-b (edited) -> mod-c -> undefined (expected no error)')
  })

  test('not inlined assets HMR', async () => {
    await setupModuleRunner('/hmr.ts')
    const el = () => hmr('#logo-no-inline')
    await untilConsoleLogAfter(
      () =>
        editFile('logo-no-inline.svg', (code) =>
          code.replace('height="30px"', 'height="40px"'),
        ),
      /Logo-no-inline updated/,
    )
    await vi.waitUntil(() => el().includes('logo-no-inline.svg?t='))
  })

  test('inlined assets HMR', async () => {
    await setupModuleRunner('/hmr.ts')
    const el = () => hmr('#logo')
    const initialLogoUrl = el()
    expect(initialLogoUrl).toMatch(/^data:image\/svg\+xml/)
    await untilConsoleLogAfter(
      () =>
        editFile('logo.svg', (code) =>
          code.replace('height="30px"', 'height="40px"'),
        ),
      /Logo updated/,
    )
    // Should be updated with new data url
    const updatedLogoUrl = el()
    expect(updatedLogoUrl).toMatch(/^data:image\/svg\+xml/)
    expect(updatedLogoUrl).not.toEqual(initialLogoUrl)
  })
} else {
  test('this file only includes test for serve', () => {
    expect(true).toBe(true)
  })
}

type UntilBrowserLogAfterCallback = (logs: string[]) => PromiseLike<void> | void

export async function untilConsoleLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  expectOrder?: boolean,
  callback?: UntilBrowserLogAfterCallback,
): Promise<string[]>
export async function untilConsoleLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  callback?: UntilBrowserLogAfterCallback,
): Promise<string[]>
export async function untilConsoleLogAfter(
  operation: () => any,
  target: string | RegExp | Array<string | RegExp>,
  arg3?: boolean | UntilBrowserLogAfterCallback,
  arg4?: UntilBrowserLogAfterCallback,
): Promise<string[]> {
  const expectOrder = typeof arg3 === 'boolean' ? arg3 : false
  const callback = typeof arg3 === 'boolean' ? arg4 : arg3

  const promise = untilConsoleLog(target, expectOrder)
  await operation()
  const logs = await promise
  if (callback) {
    await callback(logs)
  }
  return logs
}

async function untilConsoleLog(
  target?: string | RegExp | Array<string | RegExp>,
  expectOrder = true,
): Promise<string[]> {
  const { promise, resolve, reject } = promiseWithResolvers<void>()

  const logsMessages = []

  try {
    const isMatch = (matcher: string | RegExp) => (text: string) =>
      typeof matcher === 'string' ? text === matcher : matcher.test(text)

    let processMsg: (text: string) => boolean

    if (!target) {
      processMsg = () => true
    } else if (Array.isArray(target)) {
      if (expectOrder) {
        const remainingTargets = [...target]
        processMsg = (text: string) => {
          const nextTarget = remainingTargets.shift()
          expect(text).toMatch(nextTarget)
          return remainingTargets.length === 0
        }
      } else {
        const remainingMatchers = target.map(isMatch)
        processMsg = (text: string) => {
          const nextIndex = remainingMatchers.findIndex((matcher) =>
            matcher(text),
          )
          if (nextIndex >= 0) {
            remainingMatchers.splice(nextIndex, 1)
          }
          return remainingMatchers.length === 0
        }
      }
    } else {
      processMsg = isMatch(target)
    }

    const handleMsg = (text: string) => {
      try {
        text = text.replace(/\n$/, '')
        logsMessages.push(text)
        const done = processMsg(text)
        if (done) {
          resolve()
          logsEmitter.off('log', handleMsg)
        }
      } catch (err) {
        reject(err)
        logsEmitter.off('log', handleMsg)
      }
    }

    logsEmitter.on('log', handleMsg)
  } catch (err) {
    reject(err)
  }

  await promise

  return logsMessages
}

function isWatched(server: ViteDevServer, watchedFile: string) {
  const watched = server.watcher.getWatched()
  for (const [dir, files] of Object.entries(watched)) {
    const unixDir = slash(dir)
    for (const file of files) {
      const filePath = posix.join(unixDir, file)
      if (filePath.includes(watchedFile)) {
        return true
      }
    }
  }
  return false
}

function waitForWatcher(server: ViteDevServer, watched: string) {
  return new Promise<void>((resolve) => {
    function checkWatched() {
      if (isWatched(server, watched)) {
        resolve()
      } else {
        setTimeout(checkWatched, 20)
      }
    }
    checkWatched()
  })
}

async function setupModuleRunner(
  entrypoint: string,
  serverOptions: InlineConfig = {},
  waitForFile: string = entrypoint,
  initHmrState: Record<string, string> = {},
) {
  if (server) {
    await server.close()
    clientLogs.length = 0
    serverLogs.length = 0
    runner.clearCache()
  }

  globalThis.__HMR__ = initHmrState as any

  const logger = new HMRMockLogger()
  // @ts-expect-error not typed for HMR
  globalThis.log = (...msg) => logger.log(...msg)

  server = await createServer({
    configFile: resolve(testDir, 'vite.config.ts'),
    root: testDir,
    customLogger: createInMemoryLogger(serverLogs),
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: 9609,
      },
      preTransformRequests: false,
    },
    environments: {
      ssr: {
        dev: {
          createEnvironment(name, config) {
            return createRunnableDevEnvironment(name, config, {
              runnerOptions: { hmr: { logger } },
            })
          },
        },
      },
    },
    optimizeDeps: {
      disabled: true,
      noDiscovery: true,
      include: [],
    },
    ...serverOptions,
  })

  runner = (server.environments.ssr as RunnableDevEnvironment).runner

  await waitForWatcher(server, waitForFile)

  await runner.import(entrypoint)

  return {
    runtime: runner,
    server,
  }
}

class HMRMockLogger {
  log(...msg: unknown[]) {
    const log = msg.join(' ')
    clientLogs.push(log)
    logsEmitter.emit('log', log)
  }

  debug(...msg: unknown[]) {
    const log = ['[vite]', ...msg].join(' ')
    clientLogs.push(log)
    logsEmitter.emit('log', log)
  }
  error(msg: string) {
    const log = ['[vite]', msg].join(' ')
    clientLogs.push(log)
    logsEmitter.emit('log', log)
  }
}



================================================
FILE: playground/hmr-ssr/accept-exports/dynamic-imports/deps-all-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

log(`all >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'c', 'default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/dynamic-imports/deps-some-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

log(`some >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/dynamic-imports/dynamic-imports.ts
================================================
Promise.all([import('./deps-all-accepted'), import('./deps-some-accepted')])
  .then(([all, some]) => {
    log('loaded:all:' + all.a + all.b + all.c + all.default)
    log('loaded:some:' + some.a + some.b + some.c + some.default)
    log('>>> ready <<<')
  })
  .catch((err) => {
    log(err)
  })



================================================
FILE: playground/hmr-ssr/accept-exports/dynamic-imports/index.ts
================================================
import './dynamic-imports.ts'



================================================
FILE: playground/hmr-ssr/accept-exports/export-from/depA.ts
================================================
export const a = 'Ax'



================================================
FILE: playground/hmr-ssr/accept-exports/export-from/export-from.ts
================================================
import { a } from './hub'

log(a)

if (import.meta.hot) {
  import.meta.hot.accept()
} else {
}



================================================
FILE: playground/hmr-ssr/accept-exports/export-from/hub.ts
================================================
export * from './depA'



================================================
FILE: playground/hmr-ssr/accept-exports/export-from/index.html
================================================
<script type="module" src="./export-from.ts"></script>

<div class="app"></div>



================================================
FILE: playground/hmr-ssr/accept-exports/main-accepted/callback.ts
================================================
export const x = 'X'

if (import.meta.hot) {
  import.meta.hot.acceptExports(['x'], (m) => {
    log(`reloaded >>> ${m.x}`)
  })
}



================================================
FILE: playground/hmr-ssr/accept-exports/main-accepted/dep.ts
================================================
export default 'dep0'



================================================
FILE: playground/hmr-ssr/accept-exports/main-accepted/index.ts
================================================
import './main-accepted'



================================================
FILE: playground/hmr-ssr/accept-exports/main-accepted/main-accepted.ts
================================================
import def, { a } from './target'
import { x } from './callback'

// we don't want to pollute other checks' logs...
if (0 > 1) log(x)

log(`>>>>>> ${a} ${def}`)



================================================
FILE: playground/hmr-ssr/accept-exports/main-accepted/target.ts
================================================
import dep from './dep'

export const a = 'A0'

const bValue = 'B0'
export { bValue as b }

const def = 'D0'

export default def

log(`<<<<<< ${a} ${bValue} ${def} ; ${dep}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/main-non-accepted/default.ts
================================================
export const x = 'y'

const def = 'def0'

export default def

log(`<<< default: ${def}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['x'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/main-non-accepted/dep.ts
================================================
export default 'dep0'



================================================
FILE: playground/hmr-ssr/accept-exports/main-non-accepted/index.ts
================================================
import './main-non-accepted.ts'



================================================
FILE: playground/hmr-ssr/accept-exports/main-non-accepted/main-non-accepted.ts
================================================
import { a } from './named'
import def from './default'

log(`>>>>>> ${a} ${def}`)



================================================
FILE: playground/hmr-ssr/accept-exports/main-non-accepted/named.ts
================================================
import dep from './dep'

export const a = 'A0'

export const b = 'B0'

log(`<<< named: ${a} ; ${dep}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['b'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/side-effects/index.ts
================================================
import './side-effects.ts'



================================================
FILE: playground/hmr-ssr/accept-exports/side-effects/side-effects.ts
================================================
export const x = 'x'

export const y = 'y'

export default 'z'

log('>>> side FX')

globalThis.__HMR__['.app'] = 'hey'

if (import.meta.hot) {
  import.meta.hot.acceptExports(['default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/star-imports/deps-all-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

log(`all >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'c', 'default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/star-imports/deps-some-accepted.ts
================================================
export const a = 'a0'

export const b = 'b0'

const aliased = 'c0'
export { aliased as c }

export default 'default0'

log(`some >>>>>> ${a}, ${b}, ${aliased}`)

if (import.meta.hot) {
  import.meta.hot.acceptExports(['a', 'b', 'default'])
}



================================================
FILE: playground/hmr-ssr/accept-exports/star-imports/index.ts
================================================
import './star-imports.ts'



================================================
FILE: playground/hmr-ssr/accept-exports/star-imports/star-imports.ts
================================================
import * as all from './deps-all-accepted'
import * as some from './deps-some-accepted'

log('loaded:all:' + all.a + all.b + all.c + all.default)
log('loaded:some:' + some.a + some.b + some.c + some.default)
log('>>> ready <<<')



================================================
FILE: playground/hmr-ssr/accept-exports/unused-exports/index.html
================================================
<script type="module" src="./index.ts"></script>



================================================
FILE: playground/hmr-ssr/accept-exports/unused-exports/index.ts
================================================
import './unused'
import { foo } from './used'

log('used:' + foo)



================================================
FILE: playground/hmr-ssr/accept-exports/unused-exports/unused.ts
================================================
export const x = 'x'

export const y = 'y'

export default 'z'

log('-- unused --')

if (import.meta.hot) {
  import.meta.hot.acceptExports([])
}



================================================
FILE: playground/hmr-ssr/accept-exports/unused-exports/used.ts
================================================
export const foo = 'foo0'

export const bar = 'bar0'

log('-- used --')

if (import.meta.hot) {
  import.meta.hot.acceptExports([])
}



================================================
FILE: playground/hmr-ssr/circular/index.js
================================================
import { msg } from './mod-a'

globalThis.__HMR__['.circular'] = msg

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr-ssr/circular/mod-a.js
================================================
export const value = 'mod-a'

import { value as _value } from './mod-b'

export const msg = `mod-a -> ${_value}`



================================================
FILE: playground/hmr-ssr/circular/mod-b.js
================================================
import { value as _value } from './mod-c'

export const value = `mod-b -> ${_value}`



================================================
FILE: playground/hmr-ssr/circular/mod-c.js
================================================
import { value as _value } from './mod-a'

// Should error as `_value` is not defined yet within the circular imports
let __value
try {
  __value = `${_value} (expected no error)`
} catch {
  __value = 'mod-a (unexpected error)'
}

export const value = `mod-c -> ${__value}`



================================================
FILE: playground/hmr-ssr/counter/dep.ts
================================================
// This file is never loaded
if (import.meta.hot) {
  import.meta.hot.accept(() => {})
}



================================================
FILE: playground/hmr-ssr/counter/index.ts
================================================
let count = 0
export function increment() {
  count++
}
export function getCount() {
  return count
}
// @ts-expect-error not used but this is to test that it works
function neverCalled() {
  import('./dep')
}



================================================
FILE: playground/hmr-ssr/file-delete-restore/child.js
================================================
import { rerender } from './runtime'

export const value = 'child'

if (import.meta.hot) {
  import.meta.hot.accept((newMod) => {
    if (!newMod) return

    rerender({ child: newMod.value })
  })

  import.meta.hot.dispose(() => {
    log('file-delete-restore/child.js is disposed')
  })

  import.meta.hot.prune(() => {
    log('file-delete-restore/child.js is pruned')
  })
}



================================================
FILE: playground/hmr-ssr/file-delete-restore/index.js
================================================
import { render } from './runtime'
import { childValue, parentValue } from './parent'

render({ parent: parentValue, child: childValue })



================================================
FILE: playground/hmr-ssr/file-delete-restore/parent.js
================================================
import { rerender } from './runtime'

export const parentValue = 'parent'
export { value as childValue } from './child'

if (import.meta.hot) {
  import.meta.hot.accept((newMod) => {
    if (!newMod) return

    rerender({ child: newMod.childValue, parent: newMod.parentValue })
  })
}



================================================
FILE: playground/hmr-ssr/file-delete-restore/runtime.js
================================================
let state = {}

export const render = (newState) => {
  state = newState
  apply()
}

export const rerender = (updates) => {
  state = { ...state, ...updates }
  apply()
}

const apply = () => {
  globalThis.__HMR__['.file-delete-restore'] = Object.values(state).join(':')
}



================================================
FILE: playground/hmr-ssr/importing-updated/a.js
================================================
const val = 'a0'
globalThis.__HMR__['.importing-reloaded'] ??= ''
globalThis.__HMR__['.importing-reloaded'] += `a.js: ${val}<br>`

export default val

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr-ssr/importing-updated/b.js
================================================
import a from './a.js'

const val = `b0,${a}`

globalThis.__HMR__['.importing-reloaded'] ??= ''
globalThis.__HMR__['.importing-reloaded'] += `b.js: ${val}<br>`

if (import.meta.hot) {
  import.meta.hot.accept()
}



================================================
FILE: playground/hmr-ssr/importing-updated/index.js
================================================
import './a'
import './b'



================================================
FILE: playground/hmr-ssr/intermediate-file-delete/display.js
================================================
export const displayCount = (count) => `count is ${count}`



================================================
FILE: playground/hmr-ssr/intermediate-file-delete/index.js
================================================
import { displayCount } from './re-export.js'

const incrementValue = () =>
  globalThis.__HMR__['.intermediate-file-delete-increment']

const render = () => {
  globalThis.__HMR__['.intermediate-file-delete-display'] = displayCount(
    Number(incrementValue()),
  )
}

render()

globalThis.__HMR__['.delete-intermediate-file'] = () => {
  globalThis.__HMR__['.intermediate-file-delete-increment'] = `${
    Number(incrementValue()) + 1
  }`
  render()
}

if (import.meta.hot) import.meta.hot.accept()



================================================
FILE: playground/hmr-ssr/intermediate-file-delete/re-export.js
================================================
export * from './display.js'



================================================
FILE: playground/hmr-ssr/invalidation/child.js
================================================
if (import.meta.hot) {
  // Need to accept, to register a callback for HMR
  import.meta.hot.accept(() => {
    // Trigger HMR in importers
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr-ssr/invalidation/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept()
}

log('(invalidation) parent is executing')

globalThis.__HMR__['.invalidation'] = value



================================================
FILE: playground/hmr-ssr/invalidation-circular-deps/index.js
================================================
import './circular-invalidate/parent'
import './invalidate-handled-in-circle/parent'



================================================
FILE: playground/hmr-ssr/invalidation-circular-deps/circular-invalidate/child.js
================================================
import './parent'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr-ssr/invalidation-circular-deps/circular-invalidate/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

log('(invalidation circular deps) parent is executing')
setTimeout(() => {
  globalThis.__HMR__['.invalidation-circular-deps'] = value
})



================================================
FILE: playground/hmr-ssr/invalidation-circular-deps/invalidate-handled-in-circle/child.js
================================================
import './parent'

if (import.meta.hot) {
  import.meta.hot.accept(() => {
    import.meta.hot.invalidate()
  })
}

export const value = 'child'



================================================
FILE: playground/hmr-ssr/invalidation-circular-deps/invalidate-handled-in-circle/parent.js
================================================
import { value } from './child'

if (import.meta.hot) {
  import.meta.hot.accept(() => {})
}

log('(invalidation circular deps handled) parent is executing')
setTimeout(() => {
  globalThis.__HMR__['.invalidation-circular-deps-handled'] = value
})



================================================
FILE: playground/hmr-ssr/missing-import/a.js
================================================
import 'missing-modules'

log('missing test')



================================================
FILE: playground/hmr-ssr/missing-import/index.js
================================================
import './main.js'



================================================
FILE: playground/hmr-ssr/missing-import/main.js
================================================
import './a.js'



================================================
FILE: playground/hmr-ssr/non-tested/dep.js
================================================
export const test = 'true'

import.meta.hot.accept()



================================================
FILE: playground/hmr-ssr/non-tested/index.js
================================================
import { test } from './dep.js'

function main() {
  test()
}

main()

import.meta.hot.accept('./dep.js')



================================================
FILE: playground/hmr-ssr/optional-chaining/child.js
================================================
export const foo = 1



================================================
FILE: playground/hmr-ssr/optional-chaining/parent.js
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { foo } from './child'

import.meta.hot?.accept('./child', ({ foo }) => {
  log('(optional-chaining) child update')
  globalThis.__HMR__['.optional-chaining'] = foo
})



================================================
FILE: playground/hmr-ssr/queries/index.js
================================================
import query1 from './multi-query?query1'
import query2 from './multi-query?query2'

hmr('query1', query1)
hmr('query2', query2)

function hmr(key, value) {
  globalThis.__HMR__[key] = String(value)
}



================================================
FILE: playground/hmr-ssr/queries/multi-query.js
================================================
[Empty file]


================================================
FILE: playground/hmr-ssr/self-accept-within-circular/a.js
================================================
import { b } from './b'

export const a = {
  b,
}



================================================
FILE: playground/hmr-ssr/self-accept-within-circular/b.js
================================================
import { c } from './c'

const b = {
  c,
}

export { b }



================================================
FILE: playground/hmr-ssr/self-accept-within-circular/c.js
================================================
import './b'

export const c = 'c'

function render(content) {
  globalThis.__HMR__['.self-accept-within-circular'] = content
}
render(c)

import.meta.hot?.accept((nextExports) => {
  render(nextExports?.c)
})



================================================
FILE: playground/hmr-ssr/self-accept-within-circular/index.js
================================================
import { a } from './a'

log(a)



================================================
FILE: playground/hmr-ssr/soft-invalidation/child.js
================================================
export const foo = 'bar'



================================================
FILE: playground/hmr-ssr/soft-invalidation/index.js
================================================
import { foo } from './child'

// @ts-expect-error global
export const msg = `soft-invalidation/index.js is transformed ${__TRANSFORM_COUNT__} times. child is ${foo}`



================================================
FILE: playground/html/a á.html
================================================
<h1>Special Character</h1>

<script type="module">
  console.log('special character')
</script>



================================================
FILE: playground/html/common.css
================================================
p {
  color: grey;
}



================================================
FILE: playground/html/emptyAttr.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Empty Attr</title>
  </head>
  <body>
    <img src="" alt="" />
  </body>
</html>



================================================
FILE: playground/html/env.html
================================================
<p class="env">%VITE_FOO%</p>
<p class="env-define">%VITE_NUMBER%</p>
<p class="env-define-string">%VITE_STRING%</p>
<p class="env-define-object-string">%VITE_OBJECT_STRING%</p>
<p class="env-define-null-string">%VITE_NULL_STRING%</p>
<p class="env-%VITE_FOO%">class name should be env-bar</p>
<p class="env-prod">%PROD%</p>
<p class="env-dev">%DEV%</p>
<link rel="icon" href="%VITE_FAVICON_URL%" />



================================================
FILE: playground/html/foo.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>About</title>
  </head>
  <body>
    <h1>Foo.html</h1>
    <script type="module" src="/src/about.ts"></script>
  </body>
</html>



================================================
FILE: playground/html/importmapOrder.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <script type="importmap">
      {
        "imports": {
          "some-pkg": "url-of-pkg"
        }
      }
    </script>
    <link rel="modulepreload" href="url-of-pkg" />
    <script type="module" src="/main.js"></script>
  </head>
</html>



================================================
FILE: playground/html/index.html
================================================
<link rel="stylesheet" href="/main.css" />

<!-- comment one -->
<h1>Hello</h1>
<!-- comment two -->
<script type="module"></script>
<script type="module" src="/main.js"></script>
<link rel="icon" href="{{cdn_host}}/cdn/images/favicon.ico" />
<link rel="stylesheet" href="{{cdn_host}}/css.css" type="text/css" />
<script src="{{cdn_host}}/js.js" vite-ignore></script>
<p>index.html (fallback)</p>

<div>External path: <span class="external-path"></span></div>
<script type="module" src="/external-path.js" vite-ignore></script>
<script type="module" vite-ignore></script>
<link rel="stylesheet" href="/external-path.css" vite-ignore />
<div>
  External path by rollupOptions.external (build only):
  <span class="external-path-by-rollup-options"></span>
</div>



================================================
FILE: playground/html/invalid.html
================================================
<div Bad HTML</div>



================================================
FILE: playground/html/invalidClick.html
================================================
<div Bad CLICK HTML</div>



================================================
FILE: playground/html/invalidEscape.html
================================================
<div Bad ESCAPE HTML</div>



================================================
FILE: playground/html/link.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Link to rollup config</title>
  </head>
  <body>
    <a href="/link/target">A Link to a Rollup Import</a>
  </body>
</html>



================================================
FILE: playground/html/main.css
================================================
h1 {
  color: blue;
}



================================================
FILE: playground/html/main.js
================================================
import { msg } from './shared'
import './common.css'

console.log(msg + ' from main')



================================================
FILE: playground/html/noBody.html
================================================
<link rel="stylesheet" href="/main.css" />

<!-- comment one -->
<h1>Hello</h1>
<!-- comment two -->

<script type="module" src="/main.js"></script>



================================================
FILE: playground/html/noHead.html
================================================
<link rel="stylesheet" href="/main.css" />

<!-- comment one -->
<h1>Hello</h1>
<!-- comment two -->

<script type="module" src="/main.js"></script>



================================================
FILE: playground/html/package.json
================================================
{
  "name": "@vitejs/test-html",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/html/relative-input.html
================================================
<script type="module" src="./relative-input/main.js"></script>

<p class="relative-input"></p>



================================================
FILE: playground/html/scriptAsync.html
================================================
<link rel="stylesheet" href="/main.css" />

<h1>scriptAsync.html</h1>

<script async type="module" src="/main.js"></script>
<script async type="module" src="/nested/nested.js"></script>



================================================
FILE: playground/html/scriptMixed.html
================================================
<link rel="stylesheet" href="/main.css" />

<h1>scriptMixed.html</h1>

<script async type="module" src="/main.js"></script>
<script type="module" src="/nested/nested.js"></script>



================================================
FILE: playground/html/shared.js
================================================
export const msg = 'shared'



================================================
FILE: playground/html/transform-inline-js.html
================================================
<div>id: {{ id }}</div>
<div class="test">test: <span id="{{ id }}">???</span></div>
<script type="module">
  document.getElementById('{{ id }}').textContent = 'ok'
</script>



================================================
FILE: playground/html/valid.html
================================================
<!-- accepted HTML parsing errors, browsers accept these -->
<div id="duplicated-attrs" style="color: green;" style="color: red;">Accept duplicated attribute</div>

<!-- accepted HTML constructs -->
<datalist>
  <option value="option-without-closing-tag">    
</datalist>

<div id="no-quotes-on-attr">No quotes on Attr</div>
<script type="module" src=/valid.js></script>

<svg>
  <!-- attr with prefix -->
  <use xlink:href="/sprite.svg#svg"></use>
</svg>

<!-- allow self closing on non-void elements -->
<self-close-non-void />



================================================
FILE: playground/html/valid.js
================================================
document.getElementById(`no-quotes-on-attr`).innerHTML =
  `No quotes on Attr working`



================================================
FILE: playground/html/vite.config.js
================================================
import { relative, resolve } from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  base: './',
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        nested: resolve(__dirname, 'nested/index.html'),
        scriptAsync: resolve(__dirname, 'scriptAsync.html'),
        scriptMixed: resolve(__dirname, 'scriptMixed.html'),
        emptyAttr: resolve(__dirname, 'emptyAttr.html'),
        link: resolve(__dirname, 'link.html'),
        'link/target': resolve(__dirname, 'index.html'),
        zeroJS: resolve(__dirname, 'zeroJS.html'),
        noHead: resolve(__dirname, 'noHead.html'),
        noBody: resolve(__dirname, 'noBody.html'),
        inlinea: resolve(__dirname, 'inline/shared_a.html'),
        inline1: resolve(__dirname, 'inline/shared-1.html'),
        inline2: resolve(__dirname, 'inline/shared-2.html'),
        inline3: resolve(__dirname, 'inline/unique.html'),
        unicodePath: resolve(
          __dirname,
          'unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html',
        ),
        linkProps: resolve(__dirname, 'link-props/index.html'),
        valid: resolve(__dirname, 'valid.html'),
        importmapOrder: resolve(__dirname, 'importmapOrder.html'),
        env: resolve(__dirname, 'env.html'),
        sideEffects: resolve(__dirname, 'side-effects/index.html'),
        'a á': resolve(__dirname, 'a á.html'),
        serveFile: resolve(__dirname, 'serve/file.html'),
        serveFolder: resolve(__dirname, 'serve/folder/index.html'),
        serveBothFile: resolve(__dirname, 'serve/both.html'),
        serveBothFolder: resolve(__dirname, 'serve/both/index.html'),
        write: resolve(__dirname, 'write.html'),
        'transform-inline-js': resolve(__dirname, 'transform-inline-js.html'),
        relativeInput: relative(
          process.cwd(),
          resolve(__dirname, 'relative-input.html'),
        ),
      },
      external: ['/external-path-by-rollup-options.js'],
    },
  },

  server: {
    warmup: {
      clientFiles: ['./warmup/*'],
    },
  },

  define: {
    'import.meta.env.VITE_NUMBER': 5173,
    'import.meta.env.VITE_STRING': JSON.stringify('string'),
    'import.meta.env.VITE_OBJECT_STRING': '{ "foo": "bar" }',
    'import.meta.env.VITE_NULL_STRING': 'null',
  },

  plugins: [
    {
      name: 'pre-transform',
      transformIndexHtml: {
        order: 'pre',
        handler(html, { filename }) {
          if (html.includes('/@vite/client')) {
            throw new Error('pre transform applied at wrong time!')
          }

          const doctypeRE = /<!doctype html>/i
          if (doctypeRE.test(html)) return

          const head = `
  <head lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
  </head>`
          return `<!DOCTYPE html>
<html lang="en">${filename.includes('noHead') ? '' : head}
${
  filename.includes('noBody')
    ? html
    : `<body>
  ${html}
</body>`
}
</html>
  `
        },
      },
    },
    {
      name: 'string-transform',
      transformIndexHtml(html) {
        return html.replace('Hello', 'Transformed')
      },
    },
    {
      name: 'tags-transform',
      transformIndexHtml() {
        return [
          {
            tag: 'meta',
            attrs: { name: 'description', content: 'a vite app' },
            // default injection is head-prepend
          },
          {
            tag: 'meta',
            attrs: { name: 'keywords', content: 'es modules' },
            injectTo: 'head',
          },
        ]
      },
    },
    {
      name: 'combined-transform',
      transformIndexHtml(html) {
        return {
          html: html.replace('{{ title }}', 'Test HTML transforms'),
          tags: [
            {
              tag: 'p',
              attrs: { class: 'inject' },
              children: 'This is injected',
              injectTo: 'body',
            },
          ],
        }
      },
    },
    {
      name: 'serve-only-transform',
      transformIndexHtml(_, ctx) {
        if (ctx.server) {
          return [
            {
              tag: 'p',
              attrs: { class: 'server' },
              children: 'This is injected only during dev',
              injectTo: 'body',
            },
          ]
        }
      },
    },
    {
      name: 'build-only-transform',
      transformIndexHtml(_, ctx) {
        if (ctx.bundle) {
          return [
            {
              tag: 'p',
              attrs: { class: 'build' },
              children: 'This is injected only during build',
              injectTo: 'body',
            },
          ]
        }
      },
    },
    {
      name: 'path-conditional-transform',
      transformIndexHtml(_, ctx) {
        if (ctx.path.includes('nested')) {
          return [
            {
              tag: 'p',
              attrs: { class: 'conditional' },
              children: 'This is injected only for /nested/index.html',
              injectTo: 'body',
            },
          ]
        }
      },
    },
    {
      name: 'body-prepend-transform',
      transformIndexHtml() {
        return [
          {
            tag: 'noscript',
            children: '<!-- this is appended to body -->',
            injectTo: 'body',
          },
          {
            tag: 'noscript',
            children: '<!-- this is prepended to body -->',
            injectTo: 'body-prepend',
          },
        ]
      },
    },
    {
      name: 'head-prepend-importmap',
      transformIndexHtml(_, ctx) {
        if (ctx.path.includes('importmapOrder')) return

        return [
          {
            tag: 'script',
            attrs: { type: 'importmap' },
            children: `
              {
                "imports": {
                  "vue": "https://unpkg.com/vue@3.4.38/dist/vue.runtime.esm-browser.js"
                }
              }
            `,
            injectTo: 'head',
          },
        ]
      },
    },
    {
      name: 'escape-html-attribute',
      transformIndexHtml: {
        order: 'post',
        handler() {
          return [
            {
              tag: 'link',
              attrs: {
                href: `"><div class=unescape-div>extra content</div>`,
              },
              injectTo: 'body',
            },
          ]
        },
      },
    },
    {
      name: 'append-external-path-by-rollup-options',
      apply: 'build', // this does not work in serve
      transformIndexHtml: {
        order: 'pre',
        handler(_, ctx) {
          if (!ctx.filename.endsWith('html/index.html')) return
          return [
            {
              tag: 'script',
              attrs: {
                type: 'module',
                src: '/external-path-by-rollup-options.js',
              },
              injectTo: 'body',
            },
          ]
        },
      },
    },
    {
      name: 'transform-inline-js',
      transformIndexHtml: {
        order: 'pre',
        handler(html, ctx) {
          if (!ctx.filename.endsWith('html/transform-inline-js.html')) return
          return html.replaceAll(
            '{{ id }}',
            Math.random().toString(36).slice(2),
          )
        },
      },
    },
    serveExternalPathPlugin(),
  ],
})

/** @returns {import('vite').Plugin} */
function serveExternalPathPlugin() {
  const handler = (req, res, next) => {
    if (req.url === '/external-path.js') {
      res.setHeader('Content-Type', 'application/javascript')
      res.end('document.querySelector(".external-path").textContent = "works"')
    } else if (req.url === '/external-path.css') {
      res.setHeader('Content-Type', 'text/css')
      res.end('.external-path{color:red}')
    } else if (req.url === '/external-path-by-rollup-options.js') {
      res.setHeader('Content-Type', 'application/javascript')
      res.end(
        'document.querySelector(".external-path-by-rollup-options").textContent = "works"',
      )
    } else {
      next()
    }
  }
  return {
    name: 'serve-external-path',
    configureServer(server) {
      server.middlewares.use(handler)
    },
    configurePreviewServer(server) {
      server.middlewares.use(handler)
    },
  }
}



================================================
FILE: playground/html/write.html
================================================
<!-- prettier-ignore -->
<html><head><style>div {}
</style></head><body><script type="module" src="./shared.js"></script></body></html>



================================================
FILE: playground/html/zeroJS.html
================================================
<link rel="stylesheet" href="/main.css" />

<h1>zeroJS.html</h1>

<style>
  body {
    background-color: linen;
  }
</style>



================================================
FILE: playground/html/__tests__/html.spec.ts
================================================
import { beforeAll, describe, expect, test } from 'vitest'
import {
  browserLogs,
  editFile,
  getColor,
  isBuild,
  isServe,
  page,
  serverLogs,
  untilBrowserLogAfter,
  viteServer,
  viteTestUrl,
} from '~utils'

function fetchHtml(p: string) {
  return fetch(viteTestUrl + p, {
    headers: { Accept: 'text/html,*/*' },
  })
}

function testPage(isNested: boolean) {
  test('pre transform', async () => {
    expect(await page.$('head meta[name=viewport]')).toBeTruthy()
  })

  test('string transform', async () => {
    expect(await page.textContent('h1')).toBe(
      isNested ? 'Nested' : 'Transformed',
    )
  })

  test('tags transform', async () => {
    const el = await page.$('head meta[name=description]')
    expect(await el.getAttribute('content')).toBe('a vite app')

    const kw = await page.$('head meta[name=keywords]')
    expect(await kw.getAttribute('content')).toBe('es modules')
  })

  test('combined transform', async () => {
    expect(await page.title()).toBe('Test HTML transforms')
    // the p should be injected to body
    expect(await page.textContent('body p.inject')).toBe('This is injected')
  })

  test('server only transform', async () => {
    if (!isBuild) {
      expect(await page.textContent('body p.server')).toMatch(
        'injected only during dev',
      )
    } else {
      expect(await page.innerHTML('body')).not.toMatch('p class="server"')
    }
  })

  test('build only transform', async () => {
    if (isBuild) {
      expect(await page.textContent('body p.build')).toMatch(
        'injected only during build',
      )
    } else {
      expect(await page.innerHTML('body')).not.toMatch('p class="build"')
    }
  })

  test('conditional transform', async () => {
    if (isNested) {
      expect(await page.textContent('body p.conditional')).toMatch(
        'injected only for /nested/',
      )
    } else {
      expect(await page.innerHTML('body')).not.toMatch('p class="conditional"')
    }
  })

  test('body prepend/append transform', async () => {
    expect(await page.innerHTML('body')).toMatch(
      /prepended to body(.*)appended to body/s,
    )
  })

  test('css', async () => {
    expect(await getColor('h1')).toBe(isNested ? 'red' : 'blue')
    expect(await getColor('p')).toBe('grey')
  })

  if (isNested) {
    test('relative path in html asset', async () => {
      expect(await page.textContent('.relative-js')).toMatch('hello')
      expect(await getColor('.relative-css')).toMatch('red')
    })
  }
}

describe('main', () => {
  testPage(false)

  test('preserve comments', async () => {
    const html = await page.innerHTML('body')
    expect(html).toMatch(`<!-- comment one -->`)
    expect(html).toMatch(`<!-- comment two -->`)
  })

  test('external paths works with vite-ignore attribute', async () => {
    expect(await page.textContent('.external-path')).toBe('works')
    expect(await page.getAttribute('.external-path', 'vite-ignore')).toBe(null)
    expect(await getColor('.external-path')).toBe('red')
    if (isServe) {
      expect(serverLogs).not.toEqual(
        expect.arrayContaining([
          expect.stringMatching('Failed to load url /external-path.js'),
        ]),
      )
    } else {
      expect(serverLogs).not.toEqual(
        expect.arrayContaining([
          expect.stringMatching(
            /"\/external-path\.js".*can't be bundled without type="module" attribute/,
          ),
        ]),
      )
    }
  })

  test.runIf(isBuild)(
    'external paths by rollupOptions.external works',
    async () => {
      expect(await page.textContent('.external-path-by-rollup-options')).toBe(
        'works',
      )
      expect(serverLogs).not.toEqual(
        expect.arrayContaining([expect.stringContaining('Could not load')]),
      )
    },
  )
})

describe('nested', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/nested/')
  })

  testPage(true)
})

describe('nested w/ query', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/nested/index.html?v=1')
  })

  testPage(true)
})

describe.runIf(isBuild)('build', () => {
  describe('scriptAsync', () => {
    beforeAll(async () => {
      await page.goto(viteTestUrl + '/scriptAsync.html')
    })

    test('script is async', async () => {
      expect(await page.$('head script[type=module][async]')).toBeTruthy()
      expect(await page.$('head script[type=module]:not([async])')).toBeNull()
    })
  })

  describe('scriptMixed', () => {
    beforeAll(async () => {
      await page.goto(viteTestUrl + '/scriptMixed.html')
    })

    test('script is mixed', async () => {
      expect(await page.$('head script[type=module][async]')).toBeNull()
      expect(await page.$('head script[type=module]:not([async])')).toBeTruthy()
    })
  })

  describe('zeroJS', () => {
    // Ensure that the modulePreload polyfill is discarded in this case

    beforeAll(async () => {
      await page.goto(viteTestUrl + '/zeroJS.html')
    })

    test('zeroJS', async () => {
      expect(await page.$('head script[type=module]')).toBeNull()
    })
  })

  describe('inline entry', () => {
    const _countTags = (selector) => page.$$eval(selector, (t) => t.length)
    const countScriptTags = _countTags.bind(this, 'script[type=module]')
    const countPreloadTags = _countTags.bind(this, 'link[rel=modulepreload]')

    test('is inlined', async () => {
      await page.goto(viteTestUrl + '/inline/shared-2.html?v=1')
      expect(await countScriptTags()).toBeGreaterThan(1)
      expect(await countPreloadTags()).toBe(0)
    })

    test('is not inlined', async () => {
      await page.goto(viteTestUrl + '/inline/unique.html?v=1')
      expect(await countScriptTags()).toBe(1)
      expect(await countPreloadTags()).toBeGreaterThan(0)
    })

    test('execution order when inlined', async () => {
      await page.goto(viteTestUrl + '/inline/shared-1.html?v=1')
      expect((await page.textContent('#output')).trim()).toBe(
        'dep1 common dep2 dep3 shared',
      )
      await page.goto(viteTestUrl + '/inline/shared-2.html?v=1')
      expect((await page.textContent('#output')).trim()).toBe(
        'dep1 common dep2 dep3 shared',
      )
    })

    test('execution order when not inlined', async () => {
      await page.goto(viteTestUrl + '/inline/unique.html?v=1')
      expect((await page.textContent('#output')).trim()).toBe(
        'dep1 common dep2 unique',
      )
    })
  })
})

describe('noHead', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/noHead.html')
  })

  test('noHead tags injection', async () => {
    const el = await page.$('html meta[name=description]')
    expect(await el.getAttribute('content')).toBe('a vite app')

    const kw = await page.$('html meta[name=keywords]')
    expect(await kw.getAttribute('content')).toBe('es modules')
  })
})

describe('noBody', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/noBody.html')
  })

  test('noBody tags injection', async () => {
    // this selects the first noscript in body, even without a body tag
    const el = await page.$('body noscript')
    expect(await el.innerHTML()).toMatch(`<!-- this is prepended to body -->`)

    const kw = await page.$('html:last-child')
    expect(await kw.innerHTML()).toMatch(`<!-- this is appended to body -->`)
  })
})

describe('Unicode path', () => {
  test('direct access', async () => {
    await page.goto(
      viteTestUrl + '/unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html',
    )
    expect(await page.textContent('h1')).toBe('Unicode path')
  })

  test('spa fallback', async () => {
    await page.goto(viteTestUrl + '/unicode-path/中文-にほんご-한글-🌕🌖🌗/')
    expect(await page.textContent('h1')).toBe('Unicode path')
  })
})

describe('link with props', () => {
  test('separate links with different media props', async () => {
    await page.goto(viteTestUrl + '/link-props/index.html')
    expect(await getColor('h1')).toBe('red')
  })
})

describe.runIf(isServe)('invalid', () => {
  test('should be 500 with overlay', async () => {
    const response = await page.goto(viteTestUrl + '/invalid.html')
    expect(response.status()).toBe(500)

    const errorOverlay = await page.waitForSelector('vite-error-overlay')
    expect(errorOverlay).toBeTruthy()

    const message = await errorOverlay.$$eval('.message-body', (m) => {
      return m[0].innerHTML
    })
    expect(message).toContain('Unable to parse HTML')
  })

  test('should close overlay when clicked away', async () => {
    await page.goto(viteTestUrl + '/invalidClick.html')
    const errorOverlay = await page.waitForSelector('vite-error-overlay')
    expect(errorOverlay).toBeTruthy()

    await page.click('html')
    const isVisibleOverlay = await errorOverlay.isVisible()
    expect(isVisibleOverlay).toBeFalsy()
  })

  test('should close overlay when escape key is pressed', async () => {
    await page.goto(viteTestUrl + '/invalidEscape.html')
    const errorOverlay = await page.waitForSelector('vite-error-overlay')
    expect(errorOverlay).toBeTruthy()

    await page.keyboard.press('Escape')
    const isVisibleOverlay = await errorOverlay.isVisible()
    expect(isVisibleOverlay).toBeFalsy()
  })

  test('stack is updated', async () => {
    await page.goto(viteTestUrl + '/invalid.html')

    const errorOverlay = await page.waitForSelector('vite-error-overlay')
    const hiddenPromise = errorOverlay.waitForElementState('hidden')
    await page.keyboard.press('Escape')
    await hiddenPromise

    viteServer.environments.client.hot.send({
      type: 'error',
      err: {
        message: 'someError',
        stack: [
          'Error: someError',
          '    at someMethod (/some/file.ts:1:2)',
        ].join('\n'),
      },
    })
    const newErrorOverlay = await page.waitForSelector('vite-error-overlay')
    const stack = await newErrorOverlay.$$eval('.stack', (m) => m[0].innerHTML)
    expect(stack).toMatch(/^Error: someError/)
  })

  test('should reload when fixed', async () => {
    await untilBrowserLogAfter(
      () => page.goto(viteTestUrl + '/invalid.html'),
      /connected/, // wait for HMR connection
    )
    editFile('invalid.html', (content) => {
      return content.replace('<div Bad', '<div> Good')
    })
    const content = await page.waitForSelector('text=Good HTML')
    expect(content).toBeTruthy()
  })
})

describe('Valid HTML', () => {
  test('valid HTML is parsed', async () => {
    await page.goto(viteTestUrl + '/valid.html')
    expect(await page.textContent('#no-quotes-on-attr')).toBe(
      'No quotes on Attr working',
    )

    expect(await getColor('#duplicated-attrs')).toBe('green')
  })
})

describe('env', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/env.html')
  })

  test('env works', async () => {
    expect(await page.textContent('.env')).toBe('bar')
    expect(await page.textContent('.env-define')).toBe('5173')
    expect(await page.textContent('.env-define-string')).toBe('string')
    expect(await page.textContent('.env-define-object-string')).toBe(
      '{ "foo": "bar" }',
    )
    expect(await page.textContent('.env-define-null-string')).toBe('null')
    expect(await page.textContent('.env-bar')).toBeTruthy()
    expect(await page.textContent('.env-prod')).toBe(isBuild + '')
    expect(await page.textContent('.env-dev')).toBe(isServe + '')

    const iconLink = await page.$('link[rel=icon]')
    expect(await iconLink.getAttribute('href')).toBe(
      `${isBuild ? './' : '/'}sprite.svg`,
    )
  })
})

describe('importmap', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/importmapOrder.html')
  })

  // Should put this test at the end to get all browser logs above
  test('importmap should be prepended', async () => {
    expect(browserLogs).not.toContain(
      'An import map is added after module script load was triggered.',
    )
  })
})

describe('side-effects', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/side-effects/')
  })

  test('console.log is not tree-shaken', async () => {
    expect(browserLogs).toContain('message from sideEffects script')
  })
})

describe('special character', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/a á.html')
  })

  test('should fetch html proxy', async () => {
    expect(browserLogs).toContain('special character')
  })
})

describe('relative input', () => {
  beforeAll(async () => {
    await page.goto(viteTestUrl + '/relative-input.html')
  })

  test('passing relative path to rollupOptions.input works', async () => {
    await expect.poll(() => page.textContent('.relative-input')).toBe('OK')
  })
})

describe.runIf(isServe)('warmup', () => {
  test('should warmup /warmup/warm.js', async () => {
    // warmup transform files async during server startup, so the module check
    // here might take a while to load
    await expect
      .poll(() =>
        viteServer.environments.client.moduleGraph.getModuleByUrl(
          '/warmup/warm.js',
        ),
      )
      .toBeTruthy()
  })
})

test('html serve behavior', async () => {
  const [
    file,
    fileSlash,
    fileDotHtml,

    folder,
    folderSlash,
    folderSlashIndexHtml,

    both,
    bothSlash,
    bothDotHtml,
    bothSlashIndexHtml,
  ] = await Promise.all([
    fetchHtml('/serve/file'), // -> serve/file.html
    fetchHtml('/serve/file/'), // -> index.html (404 in mpa)
    fetchHtml('/serve/file.html'), // -> serve/file.html

    fetchHtml('/serve/folder'), // -> index.html (404 in mpa)
    fetchHtml('/serve/folder/'), // -> serve/folder/index.html
    fetchHtml('/serve/folder/index.html'), // -> serve/folder/index.html

    fetchHtml('/serve/both'), // -> serve/both.html
    fetchHtml('/serve/both/'), // -> serve/both/index.html
    fetchHtml('/serve/both.html'), // -> serve/both.html
    fetchHtml('/serve/both/index.html'), // -> serve/both/index.html
  ])

  expect(file.status).toBe(200)
  expect(await file.text()).toContain('file.html')
  expect(fileSlash.status).toBe(200)
  expect(await fileSlash.text()).toContain('index.html (fallback)')
  expect(fileDotHtml.status).toBe(200)
  expect(await fileDotHtml.text()).toContain('file.html')

  expect(folder.status).toBe(200)
  expect(await folder.text()).toContain('index.html (fallback)')
  expect(folderSlash.status).toBe(200)
  expect(await folderSlash.text()).toContain('folder/index.html')
  expect(folderSlashIndexHtml.status).toBe(200)
  expect(await folderSlashIndexHtml.text()).toContain('folder/index.html')

  expect(both.status).toBe(200)
  expect(await both.text()).toContain('both.html')
  expect(bothSlash.status).toBe(200)
  expect(await bothSlash.text()).toContain('both/index.html')
  expect(bothDotHtml.status).toBe(200)
  expect(await bothDotHtml.text()).toContain('both.html')
  expect(bothSlashIndexHtml.status).toBe(200)
  expect(await bothSlashIndexHtml.text()).toContain('both/index.html')
})

test('html fallback works non browser accept header', async () => {
  expect((await fetch(viteTestUrl, { headers: { Accept: '' } })).status).toBe(
    200,
  )
  // defaults to "Accept: */*"
  expect((await fetch(viteTestUrl)).status).toBe(200)
  // wait-on uses axios and axios sends this accept header
  expect(
    (
      await fetch(viteTestUrl, {
        headers: { Accept: 'application/json, text/plain, */*' },
      })
    ).status,
  ).toBe(200)
})

test('escape html attribute', async () => {
  const el = await page.$('.unescape-div')
  expect(el).toBeNull()
})

test('invalidate inline proxy module on reload', async () => {
  await page.goto(`${viteTestUrl}/transform-inline-js`)
  expect(await page.textContent('.test')).toContain('ok')
  await page.reload()
  expect(await page.textContent('.test')).toContain('ok')
  await page.reload()
  expect(await page.textContent('.test')).toContain('ok')
})



================================================
FILE: playground/html/inline/common.js
================================================
import './dep1'
import './dep2'

export function log(name) {
  document.getElementById('output').innerHTML += name + ' '
}

log('common')



================================================
FILE: playground/html/inline/dep1.js
================================================
import { log } from './common'

log('dep1')



================================================
FILE: playground/html/inline/dep2.js
================================================
import { log } from './common'

log('dep2')



================================================
FILE: playground/html/inline/dep3.js
================================================
import './dep2'
import { log } from './common'

log('dep3')



================================================
FILE: playground/html/inline/module-graph.dot
================================================
digraph Module {
    common -> { dep1, dep2 } [style=dashed,color=grey]
    dep1 -> common
    dep2 -> common
    dep3 -> { dep2, common }

    subgraph shared {
        shared [style=filled]
        shared -> { dep3, common }
    }

    subgraph unique {
        unique [style=filled]
        unique -> { common, dep2 }
    }
}



================================================
FILE: playground/html/inline/shared-1.html
================================================
<pre id="output"></pre>
<script type="module" src="./shared.js"></script>



================================================
FILE: playground/html/inline/shared-2.html
================================================
<pre id="output"></pre>
<script type="module" src="./shared.js"></script>



================================================
FILE: playground/html/inline/shared.js
================================================
import './dep3'
import { log } from './common'

log('shared')



================================================
FILE: playground/html/inline/shared_a.html
================================================
<p>inline a</p>



================================================
FILE: playground/html/inline/unique.html
================================================
<pre id="output"></pre>
<script type="module" src="./unique.js"></script>



================================================
FILE: playground/html/inline/unique.js
================================================
import { log } from './common'
import './dep2'

log('unique')



================================================
FILE: playground/html/link-props/index.html
================================================
<link rel="stylesheet" href="./screen.css" media="screen" />
<link rel="stylesheet" href="./print.css" media="print" />

<h1 id="link-props">test color</h1>



================================================
FILE: playground/html/link-props/print.css
================================================
#link-props {
  color: green;
}



================================================
FILE: playground/html/link-props/screen.css
================================================
#link-props {
  color: red;
}



================================================
FILE: playground/html/nested/index.html
================================================
<link rel="stylesheet" href="./nested.css" />
<h1>Nested</h1>
<script type="module" src="./nested.js"></script>

<h1>no base path nested</h1>
<link rel="stylesheet" href="asset/style.css" />
<div class="relative-css">link style</div>
<div class="relative-js"></div>
<script src="asset/main.js" type="module"></script>



================================================
FILE: playground/html/nested/nested.css
================================================
h1 {
  color: red;
}



================================================
FILE: playground/html/nested/nested.js
================================================
import { msg } from '../shared'
import '../common.css'

console.log(msg + ' from nested')



================================================
FILE: playground/html/nested/asset/main.js
================================================
function text(el, text) {
  document.querySelector(el).textContent = text
}
text('.relative-js', 'hello')



================================================
FILE: playground/html/nested/asset/style.css
================================================
.relative-css {
  color: red;
}



================================================
FILE: playground/html/relative-input/main.js
================================================
document.querySelector('.relative-input').textContent = 'OK'



================================================
FILE: playground/html/serve/both.html
================================================
<h1>both.html</h1>



================================================
FILE: playground/html/serve/file.html
================================================
<h1>file.html</h1>



================================================
FILE: playground/html/serve/both/index.html
================================================
<h1>both/index.html</h1>



================================================
FILE: playground/html/serve/folder/index.html
================================================
<h1>folder/index.html</h1>



================================================
FILE: playground/html/side-effects/index.html
================================================
<h1>sideEffects false</h1>
<script type="module" src="./sideEffects.js"></script>



================================================
FILE: playground/html/side-effects/package.json
================================================
{
  "name": "@vitejs/test-html-side-effects",
  "private": true,
  "version": "0.0.0",
  "sideEffects": false
}



================================================
FILE: playground/html/side-effects/sideEffects.js
================================================
console.log('message from sideEffects script')



================================================
FILE: playground/html/unicode-path/中文-にほんご-한글-🌕🌖🌗/index.html
================================================
<h1>Unicode path</h1>



================================================
FILE: playground/html/warmup/warm.js
================================================
console.log('From warm.js')



================================================
FILE: playground/import-assertion/data.json
================================================
{
  "foo": "bar"
}



================================================
FILE: playground/import-assertion/index.html
================================================
<h1>Import assertion</h1>

<h2>From source code</h2>
<p class="src"></p>

<h2>From dependency</h2>
<p class="dep"></p>

<script type="module">
  import * as data from './data.json' assert { type: 'json' }
  text('.src', data.foo)

  import * as depData from '@vitejs/test-import-assertion-dep'
  text('.dep', depData.hello)

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/import-assertion/package.json
================================================
{
  "name": "@vitejs/test-import-assertion",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-import-assertion-dep": "file:./import-assertion-dep"
  }
}



================================================
FILE: playground/import-assertion/__tests__/import-assertion.spec.ts
================================================
import { expect, test } from 'vitest'
import { page } from '~utils'

test('from source code', async () => {
  expect(await page.textContent('.src'), 'bar')
})

test('from dependency', async () => {
  expect(await page.textContent('.dep'), 'world')
})



================================================
FILE: playground/import-assertion/import-assertion-dep/data.json
================================================
{
  "hello": "world"
}



================================================
FILE: playground/import-assertion/import-assertion-dep/index.js
================================================
import json from './data.json' assert { type: 'json' }

export const hello = json.hello



================================================
FILE: playground/import-assertion/import-assertion-dep/package.json
================================================
{
  "name": "@vitejs/test-import-assertion-dep",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "exports": "./index.js"
}



================================================
FILE: playground/js-sourcemap/after-preload-dynamic-hashbang.js
================================================
// hashbang is injected via rollupOptions.output.banner

import('./dynamic/dynamic-foo')

console.log('after preload dynamic hashbang')



================================================
FILE: playground/js-sourcemap/after-preload-dynamic-no-dep.js
================================================
import('./dynamic/dynamic-no-dep')

console.log('after preload dynamic no dep')



================================================
FILE: playground/js-sourcemap/after-preload-dynamic.js
================================================
import('./dynamic/dynamic-foo')

console.log('after preload dynamic')



================================================
FILE: playground/js-sourcemap/bar.ts
================================================
export const bar = 'bar'



================================================
FILE: playground/js-sourcemap/foo-with-sourcemap-plugin.ts
================================================
import type { Plugin } from 'vite'

export const commentSourceMap = [
  '// default boundary sourcemap with magic-string',
  '//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHIn0=',
].join('\n')

export default function transformFooWithInlineSourceMap(): Plugin {
  return {
    name: 'transform-foo-with-inline-sourcemap',
    transform(code, id) {
      if (id.includes('foo-with-sourcemap.js')) {
        return `${code}${commentSourceMap}`
      }
    },
  }
}



================================================
FILE: playground/js-sourcemap/foo-with-sourcemap.js
================================================
export const foo = 'foo'



================================================
FILE: playground/js-sourcemap/foo.js
================================================
export const foo = 'foo'



================================================
FILE: playground/js-sourcemap/index.html
================================================
<div class="wrapper">
  <h1>JS Sourcemap</h1>
  <div class="dynamic-foo">dynamic</div>
</div>

<script type="module" src="./foo.js"></script>
<script type="module" src="./bar.ts"></script>
<script type="module" src="./after-preload-dynamic.js"></script>
<script type="module" src="./after-preload-dynamic-hashbang.js"></script>
<script type="module" src="./after-preload-dynamic-no-dep.js"></script>
<script type="module" src="./with-multiline-import.ts"></script>
<script type="module" src="./zoo.js"></script>
<script type="module" src="./with-define-object.ts"></script>



================================================
FILE: playground/js-sourcemap/package.json
================================================
{
  "name": "@vitejs/test-js-sourcemap",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-importee-pkg": "file:importee-pkg",
    "magic-string": "^0.30.17"
  }
}



================================================
FILE: playground/js-sourcemap/plugin-foo.js
================================================
export const foo = 'foo'



================================================
FILE: playground/js-sourcemap/test-ssr-dev.js
================================================
import assert from 'node:assert'
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

async function runTest() {
  const server = await createServer({
    root: fileURLToPath(new URL('.', import.meta.url)),
    configFile: false,
    optimizeDeps: {
      noDiscovery: true,
    },
    server: {
      middlewareMode: true,
      hmr: false,
      ws: false,
    },
    define: {
      __testDefineObject: '{ "hello": "test" }',
    },
  })
  const mod = await server.ssrLoadModule('/with-define-object-ssr.ts')
  const error = await getError(() => mod.error())
  server.ssrFixStacktrace(error)
  assert.match(error.stack, /at errorInner (.*with-define-object-ssr.ts:7:9)/)
  await server.close()
}

async function getError(f) {
  let error
  try {
    await f()
  } catch (e) {
    error = e
  }
  assert.ok(error)
  return error
}

runTest()



================================================
FILE: playground/js-sourcemap/vite.config.js
================================================
import { defineConfig } from 'vite'
import transformFooWithInlineSourceMap from './foo-with-sourcemap-plugin'
import { transformZooWithSourcemapPlugin } from './zoo-with-sourcemap-plugin'

export default defineConfig({
  plugins: [
    transformFooWithInlineSourceMap(),
    transformZooWithSourcemapPlugin(),
  ],
  build: {
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks(name) {
          if (name.endsWith('after-preload-dynamic.js')) {
            return 'after-preload-dynamic'
          }
          if (name.endsWith('after-preload-dynamic-hashbang.js')) {
            return 'after-preload-dynamic-hashbang'
          }
          if (name.endsWith('after-preload-dynamic-no-dep.js')) {
            return 'after-preload-dynamic-no-dep'
          }
          if (name.includes('with-define-object')) {
            return 'with-define-object'
          }
        },
        banner(chunk) {
          if (chunk.name.endsWith('after-preload-dynamic-hashbang')) {
            return '#!/usr/bin/env node'
          }
        },
        sourcemapDebugIds: true,
      },
    },
  },
  define: {
    __testDefineObject: '{ "hello": "test" }',
  },
})



================================================
FILE: playground/js-sourcemap/with-define-object-ssr.ts
================================================
export function error() {
  errorInner()
}

function errorInner() {
  // @ts-expect-error "define"
  throw new Error('with-define-object: ' + JSON.stringify(__testDefineObject))
}



================================================
FILE: playground/js-sourcemap/with-define-object.ts
================================================
// test complicated stack since broken sourcemap
// might still look correct with a simple case
function main() {
  mainInner()
}

function mainInner() {
  // @ts-expect-error "define"
  console.trace('with-define-object', __testDefineObject)
}

main()



================================================
FILE: playground/js-sourcemap/with-multiline-import.ts
================================================
// prettier-ignore
import {
  foo
} from '@vitejs/test-importee-pkg'

console.log('with-multiline-import', foo)



================================================
FILE: playground/js-sourcemap/zoo-with-sourcemap-plugin.ts
================================================
import MagicString from 'magic-string'
import type { Plugin } from 'vite'

export const transformZooWithSourcemapPlugin: () => Plugin = () => ({
  name: 'sourcemap',
  transform(code, id) {
    if (id.includes('zoo.js')) {
      const ms = new MagicString(code)
      ms.append('// add comment')
      return {
        code: ms.toString(),
        // NOTE: MagicString without `filename` option generates
        //       a sourcemap with `sources: ['']` or `sources: [null]`
        map: ms.generateMap({ hires: true }),
      }
    }
  },
})



================================================
FILE: playground/js-sourcemap/zoo.js
================================================
export const zoo = 'zoo'



================================================
FILE: playground/js-sourcemap/__tests__/js-sourcemap.spec.ts
================================================
import { URL, fileURLToPath } from 'node:url'
import { promisify } from 'node:util'
import { execFile } from 'node:child_process'
import { describe, expect, test } from 'vitest'
import { mapFileCommentRegex } from 'convert-source-map'
import { commentSourceMap } from '../foo-with-sourcemap-plugin'
import {
  extractSourcemap,
  findAssetFile,
  formatSourcemapForSnapshot,
  isBuild,
  listAssets,
  page,
  readFile,
  serverLogs,
} from '~utils'

if (!isBuild) {
  test('js', async () => {
    const res = await page.request.get(new URL('./foo.js', page.url()).href)
    const js = await res.text()
    const map = extractSourcemap(js)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG;",
        "sources": [
          "foo.js",
        ],
        "sourcesContent": [
          "export const foo = 'foo'
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('plugin return sourcemap with `sources: [""]`', async () => {
    const res = await page.request.get(new URL('./zoo.js', page.url()).href)
    const js = await res.text()
    expect(js).toContain('// add comment')

    const map = extractSourcemap(js)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",
        "sources": [
          "zoo.js",
        ],
        "sourcesContent": [
          "export const zoo = 'zoo'
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('js with inline sourcemap injected by a plugin', async () => {
    const res = await page.request.get(
      new URL('./foo-with-sourcemap.js', page.url()).href,
    )
    const js = await res.text()

    expect(js).toContain(commentSourceMap)
    const sourcemapComments = js.match(mapFileCommentRegex).length
    expect(sourcemapComments).toBe(1)

    const map = extractSourcemap(js)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAA,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG",
        "sources": [
          "",
        ],
        "version": 3,
      }
    `)
  })

  test('ts', async () => {
    const res = await page.request.get(new URL('./bar.ts', page.url()).href)
    const js = await res.text()
    const map = extractSourcemap(js)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AAAO,aAAM,MAAM;",
        "sources": [
          "bar.ts",
        ],
        "sourcesContent": [
          "export const bar = 'bar'
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('multiline import', async () => {
    const res = await page.request.get(
      new URL('./with-multiline-import.ts', page.url()).href,
    )
    const multi = await res.text()
    const map = extractSourcemap(multi)
    expect(formatSourcemapForSnapshot(map)).toMatchInlineSnapshot(`
      {
        "mappings": "AACA;AAAA,EACE;AAAA,OACK;AAEP,QAAQ,IAAI,yBAAyB,GAAG;",
        "sources": [
          "with-multiline-import.ts",
        ],
        "sourcesContent": [
          "// prettier-ignore
      import {
        foo
      } from '@vitejs/test-importee-pkg'

      console.log('with-multiline-import', foo)
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('should not output missing source file warning', () => {
    serverLogs.forEach((log) => {
      expect(log).not.toMatch(/Sourcemap for .+ points to missing source files/)
    })
  })
}

describe.runIf(isBuild)('build tests', () => {
  test('should not output sourcemap warning (#4939)', () => {
    serverLogs.forEach((log) => {
      expect(log).not.toMatch('Sourcemap is likely to be incorrect')
    })
  })

  test('sourcemap is correct when preload information is injected', async () => {
    const map = findAssetFile(/after-preload-dynamic-[-\w]{8}\.js\.map/)
    expect(formatSourcemapForSnapshot(JSON.parse(map))).toMatchInlineSnapshot(`
      {
        "debugId": "00000000-0000-0000-0000-000000000000",
        "ignoreList": [],
        "mappings": ";4kCAAA,OAAO,2BAAuB,0BAE9B,QAAQ,IAAI,uBAAuB",
        "sources": [
          "../../after-preload-dynamic.js",
        ],
        "sourcesContent": [
          "import('./dynamic/dynamic-foo')

      console.log('after preload dynamic')
      ",
        ],
        "version": 3,
      }
    `)
    // verify sourcemap comment is preserved at the last line
    const js = findAssetFile(/after-preload-dynamic-[-\w]{8}\.js$/)
    expect(js).toMatch(
      /\n\/\/# sourceMappingURL=after-preload-dynamic-[-\w]{8}\.js\.map\n$/,
    )
  })

  test('__vite__mapDeps injected after banner', async () => {
    const js = findAssetFile(/after-preload-dynamic-hashbang-[-\w]{8}\.js$/)
    expect(js.split('\n').slice(0, 2)).toEqual([
      '#!/usr/bin/env node',
      expect.stringContaining('const __vite__mapDeps=(i'),
    ])
  })

  test('no unused __vite__mapDeps', async () => {
    const js = findAssetFile(/after-preload-dynamic-no-dep-[-\w]{8}\.js$/)
    expect(js).not.toMatch(/__vite__mapDeps/)
  })

  test('sourcemap is correct when using object as "define" value', async () => {
    const map = findAssetFile(/with-define-object.*\.js\.map/)
    expect(formatSourcemapForSnapshot(JSON.parse(map))).toMatchInlineSnapshot(`
      {
        "debugId": "00000000-0000-0000-0000-000000000000",
        "mappings": "qBAEA,SAASA,GAAO,CACJC,EAAA,CACZ,CAEA,SAASA,GAAY,CAEX,QAAA,MAAM,qBAAsBC,CAAkB,CACxD,CAEAF,EAAK",
        "sources": [
          "../../with-define-object.ts",
        ],
        "sourcesContent": [
          "// test complicated stack since broken sourcemap
      // might still look correct with a simple case
      function main() {
        mainInner()
      }

      function mainInner() {
        // @ts-expect-error "define"
        console.trace('with-define-object', __testDefineObject)
      }

      main()
      ",
        ],
        "version": 3,
      }
    `)
  })

  test('correct sourcemap during ssr dev when using object as "define" value', async () => {
    const execFileAsync = promisify(execFile)
    await execFileAsync('node', ['test-ssr-dev.js'], {
      cwd: fileURLToPath(new URL('..', import.meta.url)),
    })
  })

  test('source and sourcemap contain matching debug IDs', () => {
    function getDebugIdFromString(input: string): string | undefined {
      const match = input.match(/\/\/# debugId=([a-fA-F0-9-]+)/)
      return match ? match[1] : undefined
    }

    const assets = listAssets().map((asset) => `dist/assets/${asset}`)
    const jsAssets = assets.filter((asset) => asset.endsWith('.js'))

    for (const jsAsset of jsAssets) {
      const jsContent = readFile(jsAsset)
      const sourceDebugId = getDebugIdFromString(jsContent)
      expect(
        sourceDebugId,
        `Asset '${jsAsset}' did not contain a debug ID`,
      ).toBeDefined()

      const mapFile = jsAsset + '.map'
      const mapContent = readFile(mapFile)

      const mapObj = JSON.parse(mapContent)
      const mapDebugId = mapObj.debugId

      expect(
        sourceDebugId,
        'Debug ID in source didnt match debug ID in sourcemap',
      ).toEqual(mapDebugId)
    }
  })
})



================================================
FILE: playground/js-sourcemap/dynamic/dynamic-foo.css
================================================
.dynamic-foo {
  color: red;
}



================================================
FILE: playground/js-sourcemap/dynamic/dynamic-foo.js
================================================
import './dynamic-foo.css'

console.log('dynamic/dynamic-foo')



================================================
FILE: playground/js-sourcemap/dynamic/dynamic-no-dep.js
================================================
console.log('dynamic/dynamic-no-dep')



================================================
FILE: playground/js-sourcemap/importee-pkg/index.js
================================================
// eslint-disable-next-line import-x/no-commonjs
exports.foo = 'foo'



================================================
FILE: playground/js-sourcemap/importee-pkg/package.json
================================================
{
  "name": "@vitejs/test-importee-pkg",
  "private": true,
  "version": "0.0.0",
  "main": "./index.js"
}



================================================
FILE: playground/json/hmr.json
================================================
{
  "hmr": "this is hmr json"
}



================================================
FILE: playground/json/index.html
================================================
<h2>Normal Import</h2>
<pre class="full"></pre>
<pre class="named"></pre>

<h2>Deep Import</h2>
<pre class="deep-full"></pre>
<pre class="deep-named"></pre>

<h2>Dynamic Import</h2>
<pre class="dynamic"></pre>
<pre class="dynamic-named"></pre>

<h2>fetch</h2>
<pre class="fetch"></pre>

<h2>Importing as URL</h2>
<pre class="url"></pre>

<h2>Raw Import</h2>
<pre class="raw"></pre>

<h2>JSON Module</h2>
<pre class="module"></pre>

<h2>Has BOM Tag</h2>
<pre class="bom"></pre>

<h2>require(json) returns object without default export</h2>
<pre class="require"></pre>

<h2>HMR</h2>
<pre class="hmr"></pre>

<script type="module">
  import json, { hello } from './test.json'
  import deepJson, { name } from 'vue/package.json'

  text('.full', JSON.stringify(json))
  text('.named', hello)

  text('.deep-full', JSON.stringify(deepJson))
  text('.deep-named', name)

  import('/test.json').then((mod) => {
    text('.dynamic', JSON.stringify(mod.default))
    text('.dynamic-named', mod.hello)
  })

  fetch(import.meta.env.DEV ? '/test.json' : '/public.json')
    .then((r) => r.json())
    .then((data) => {
      text('.fetch', JSON.stringify(data))
    })

  import url from './test.json?url'
  text('.url', url)

  import raw from './test.json?raw'
  text('.raw', raw)

  import moduleJSON from '@vitejs/test-json-module'
  text('.module', JSON.stringify(moduleJSON))

  import hasBomJson from './json-bom/has-bom.json'
  text('.bom', JSON.stringify(hasBomJson))

  import requireJson from '@vitejs/test-json-require'
  text('.require', JSON.stringify(requireJson.content))

  import hmrJSON from './hmr.json'
  text('.hmr', JSON.stringify(hmrJSON))

  function text(sel, text) {
    document.querySelector(sel).textContent = text
  }
</script>



================================================
FILE: playground/json/package.json
================================================
{
  "name": "@vitejs/test-json",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@vitejs/test-json-require": "file:./dep-json-require",
    "@vitejs/test-json-module": "file:./json-module",
    "vue": "^3.5.18"
  }
}



================================================
FILE: playground/json/test.json
================================================
{
  "hello": "this is json"
}



================================================
FILE: playground/json/__tests__/csr/json-csr.spec.ts
================================================
import { readFileSync } from 'node:fs'
import { expect, test } from 'vitest'
import deepJson from 'vue/package.json'
import testJson from '../../test.json'
import hmrJson from '../../hmr.json'
import { editFile, isBuild, isServe, page } from '~utils'

const stringified = JSON.stringify(testJson)
const deepStringified = JSON.stringify(deepJson)
const hmrStringified = JSON.stringify(hmrJson)

test('default import', async () => {
  expect(await page.textContent('.full')).toBe(stringified)
})

test('named import', async () => {
  expect(await page.textContent('.named')).toBe(testJson.hello)
})

test('deep import', async () => {
  expect(await page.textContent('.deep-full')).toBe(deepStringified)
})

test('named deep import', async () => {
  expect(await page.textContent('.deep-named')).toBe(deepJson.name)
})

test('dynamic import', async () => {
  expect(await page.textContent('.dynamic')).toBe(stringified)
})

test('dynamic import, named', async () => {
  expect(await page.textContent('.dynamic-named')).toBe(testJson.hello)
})

test('fetch', async () => {
  expect(await page.textContent('.fetch')).toBe(stringified)
})

test('?url', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild ? 'data:application/json' : '/test.json',
  )
})

test('?raw', async () => {
  expect(await page.textContent('.raw')).toBe(
    readFileSync(require.resolve('../../test.json'), 'utf-8'),
  )
})

test('require(json) returns object without default export', async () => {
  expect(await page.textContent('.require')).toBe(JSON.stringify({ 200: 'ok' }))
})

test.runIf(isServe)('should full reload', async () => {
  expect(await page.textContent('.hmr')).toBe(hmrStringified)

  editFile('hmr.json', (code) =>
    code.replace('"this is hmr json"', '"this is hmr update json"'),
  )
  await expect
    .poll(() => page.textContent('.hmr'))
    .toMatch('"this is hmr update json"')
})



================================================
FILE: playground/json/dep-json-require/content.json
================================================
{
  "200": "ok"
}



================================================
FILE: playground/json/dep-json-require/index.js
================================================
const content = require('./content.json')

module.exports = { content }



================================================
FILE: playground/json/dep-json-require/package.json
================================================
{
  "name": "@vitejs/require",
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/json/json-bom/has-bom.json
================================================
﻿{
  "description": "This file is marked with BOM.",
  "message": "If the parsing is successful, the BOM tag has been removed."
}



================================================
FILE: playground/json/json-module/index.json
================================================
{
  "hello": "hi"
}



================================================
FILE: playground/json/json-module/package.json
================================================
{
  "name": "@vitejs/test-json-module",
  "version": "0.0.0"
}



================================================
FILE: playground/json/public/public.json
================================================
{
  "hello": "this is json"
}



================================================
FILE: playground/legacy/async.js
================================================
export function fn() {
  const m = new Map()
  m.set('foo', 'Hello')
  document.querySelector('#app').textContent = m.get('foo')
}



================================================
FILE: playground/legacy/custom0.js
================================================
export const foo = 'bar'



================================================
FILE: playground/legacy/custom1.js
================================================
export const foo = 'bar'



================================================
FILE: playground/legacy/custom2.js
================================================
export const foo = 'bar'



================================================
FILE: playground/legacy/dynamic.css
================================================
#dynamic-css {
  color: red;
}



================================================
FILE: playground/legacy/entry-server-sequential.js
================================================
// This counts as 'server-side' rendering, yes?
export async function render() {
  return /* html */ `
    <div id="app">Hello</div>
    <div id="mode">${import.meta.env.MODE}</div>
  `
}



================================================
FILE: playground/legacy/entry-server.js
================================================
// This counts as 'server-side' rendering, yes?
export async function render() {
  return /* html */ `
    <div id="app">Hello</div>
    <div id="env">${import.meta.env.LEGACY}</div>
  `
}



================================================
FILE: playground/legacy/immutable-chunk.js
================================================
const chunks = [
  'index',
  'index-legacy',
  'chunk-async',
  'chunk-async-legacy',
  'immutable-chunk',
  'immutable-chunk-legacy',
  'polyfills-legacy',
]

export function fn() {
  return Promise.all(
    chunks.map(async (name) => {
      const response = await fetch(`/assets/${name}.js`)
      return `${name}: ${response.headers.get('Content-Type')}`
    }),
  )
}



================================================
FILE: playground/legacy/index.html
================================================
<h1 id="app"></h1>
<div id="env"></div>
<div id="env-equal"></div>
<div id="iterators"></div>
<div id="features-after-corejs-3"></div>
<div id="async-generator"></div>
<div id="babel-helpers"></div>
<div id="assets" style="white-space: break-spaces; background: lightgray"></div>
<button id="dynamic-css-button">dynamic css</button>
<div id="dynamic-css"></div>
<p>## worker message:</p>
<div class="worker-message"></div>
<div id="asset-path"></div>
<script type="module" src="./main.js"></script>



================================================
FILE: playground/legacy/main.js
================================================
import './style.css'
import viteSvgPath from './vite.svg'
import MyWorker from './worker?worker'

async function run() {
  await import('./custom0.js')
  await import('./custom1.js')
  await import('./custom2.js')
  const { fn } = await import('./async.js')
  fn()
}

run()

let isLegacy

// make sure that branching works despite esbuild's constant folding (#1999)
if (import.meta.env.LEGACY) {
  if (import.meta.env.LEGACY === true) isLegacy = true
} else {
  if (import.meta.env.LEGACY === false) isLegacy = false
}

text('#env', `is legacy: ${isLegacy}`)

const metaEnvObj = import.meta.env
text('#env-equal', import.meta.env.LEGACY === metaEnvObj.LEGACY)

// Iterators
text('#iterators', [...new Set(['hello'])].join(''))

// structuredClone is supported core.js v3.20.0+
text(
  '#features-after-corejs-3',
  JSON.stringify(structuredClone({ foo: 'foo' })),
)

// async generator
async function* asyncGenerator() {
  for (let i = 0; i < 3; i++) {
    await new Promise((resolve) => setTimeout(resolve, 10))
    yield i
  }
}
;(async () => {
  const result = []
  for await (const i of asyncGenerator()) {
    result.push(i)
  }
  text('#async-generator', JSON.stringify(result))
})()

// babel-helpers
// Using `String.raw` to inject `@babel/plugin-transform-template-literals`
// helpers.
text(
  '#babel-helpers',
  String.raw`exposed babel helpers: ${window._templateObject != null}`,
)

// dynamic chunk names
import('./immutable-chunk.js')
  .then(({ fn }) => fn())
  .then((assets) => {
    text('#assets', assets.join('\n'))
  })

// dynamic css
document
  .querySelector('#dynamic-css-button')
  .addEventListener('click', async () => {
    await import('./dynamic.css')
    text('#dynamic-css', 'dynamic import css')
  })

text('#asset-path', viteSvgPath)

function text(el, text) {
  document.querySelector(el).textContent = text
}

const worker = new MyWorker()
worker.postMessage('ping')
worker.addEventListener('message', (ev) => {
  text('.worker-message', JSON.stringify(ev.data))
})



================================================
FILE: playground/legacy/module.js
================================================
export const module = 'module'



================================================
FILE: playground/legacy/no-polyfills-no-systemjs.html
================================================
<meta charset="UTF-8" />
<main></main>
<script type="module" src="./no-polyfills-no-systemjs.js"></script>



================================================
FILE: playground/legacy/no-polyfills-no-systemjs.js
================================================
document.querySelector('main').innerHTML = '👋'



================================================
FILE: playground/legacy/no-polyfills.html
================================================
<meta charset="UTF-8" />
<main></main>
<script type="module" src="./no-polyfills.js"></script>



================================================
FILE: playground/legacy/no-polyfills.js
================================================
document.querySelector('main').innerHTML = '👋'



================================================
FILE: playground/legacy/package.json
================================================
{
  "name": "@vitejs/test-legacy",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build --debug legacy",
    "build:custom-filename": "vite --config ./vite.config-custom-filename.js build  --debug legacy",
    "build:multiple-output": "vite --config ./vite.config-multiple-output.js build",
    "build:no-polyfills": "vite --config ./vite.config-no-polyfills.js build",
    "build:no-polyfills-no-systemjs": "vite --config ./vite.config-no-polyfills-no-systemjs.js build",
    "build:watch": "vite --config ./vite.config-watch.js build --debug legacy",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "workspace:*",
    "@vitejs/plugin-legacy": "workspace:*",
    "express": "^5.1.0",
    "terser": "^5.43.1"
  }
}



================================================
FILE: playground/legacy/style-only-entry.css
================================================
:root {
  background: #ff69b4;
}



================================================
FILE: playground/legacy/style.css
================================================
#app {
  color: red;
}



================================================
FILE: playground/legacy/vite.config-custom-filename.js
================================================
import { defineConfig } from 'vite'
import legacy from '@vitejs/plugin-legacy'

export default defineConfig({
  plugins: [legacy({ modernPolyfills: true })],
  build: {
    manifest: true,
    minify: false,
    rollupOptions: {
      output: {
        entryFileNames: `assets/[name].js`,
        chunkFileNames: `assets/[name].js`,
      },
    },
  },
})



================================================
FILE: playground/legacy/vite.config-multiple-output.js
================================================
import { defineConfig } from 'vite'
import legacy from '@vitejs/plugin-legacy'

export default defineConfig({
  plugins: [legacy({ modernPolyfills: true })],
  build: {
    manifest: true,
    minify: false,
    rollupOptions: {
      output: [
        {
          assetFileNames() {
            return 'assets/subdir/[name]-[hash][extname]'
          },
          entryFileNames: `assets/subdir/[name].js`,
          chunkFileNames: `assets/subdir/[name].js`,
        },
        {
          assetFileNames() {
            return 'assets/subdir/[name]-[hash][extname]'
          },
          entryFileNames: `assets/anotherSubdir/[name].js`,
          chunkFileNames: `assets/anotherSubdir/[name].js`,
        },
      ],
    },
  },
})



================================================
FILE: playground/legacy/vite.config-no-polyfills-no-systemjs.js
================================================
import path from 'node:path'
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig(({ isPreview }) => ({
  base: !isPreview ? './' : '/no-polyfills-no-systemjs/',
  plugins: [
    legacy({
      renderModernChunks: false,
      polyfills: false,
      externalSystemJS: true,
    }),
    {
      name: 'remove crossorigin attribute',
      transformIndexHtml: (html) => html.replaceAll('crossorigin', ''),
      enforce: 'post',
    },
  ],

  build: {
    outDir: 'dist/no-polyfills-no-systemjs',
    rollupOptions: {
      input: {
        index: path.resolve(__dirname, 'no-polyfills-no-systemjs.html'),
      },
    },
  },
}))



================================================
FILE: playground/legacy/vite.config-no-polyfills.js
================================================
import path from 'node:path'
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig(({ isPreview }) => ({
  base: !isPreview ? './' : '/no-polyfills/',
  plugins: [
    legacy({
      renderModernChunks: false,
      polyfills: false,
    }),
    {
      name: 'remove crossorigin attribute',
      transformIndexHtml: (html) => html.replaceAll('crossorigin', ''),
      enforce: 'post',
    },
  ],

  build: {
    outDir: 'dist/no-polyfills',
    rollupOptions: {
      input: {
        index: path.resolve(__dirname, 'no-polyfills.html'),
      },
    },
  },
}))



================================================
FILE: playground/legacy/vite.config-watch.js
================================================
import { resolve } from 'node:path'
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [legacy()],
  build: {
    manifest: true,
    rollupOptions: {
      input: {
        'style-only-entry': resolve(__dirname, 'style-only-entry.css'),
      },
    },
    watch: {},
    outDir: 'dist/watch',
  },
})



================================================
FILE: playground/legacy/vite.config.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig({
  base: './',
  plugins: [
    legacy({
      targets: 'IE 11',
      modernPolyfills: true,
    }),
  ],

  build: {
    cssCodeSplit: false,
    manifest: true,
    sourcemap: true,
    assetsInlineLimit: 100, // keep SVG as assets URL
    rollupOptions: {
      input: {
        index: path.resolve(__dirname, 'index.html'),
        nested: path.resolve(__dirname, 'nested/index.html'),
      },
      output: {
        chunkFileNames(chunkInfo) {
          if (chunkInfo.name === 'immutable-chunk') {
            return `assets/${chunkInfo.name}.js`
          } else if (/custom\d/.test(chunkInfo.name)) {
            return `assets/chunk-X${
              ['.', '-', ''][/custom(\d)/.exec(chunkInfo.name)[1]]
            }[hash].js`
          }
          return `assets/chunk-[name].[hash].js`
        },
      },
    },
  },

  // for tests, remove `<script type="module">` tags and remove `nomodule`
  // attrs so that we run the legacy bundle instead.
  __test__() {
    const indexPath = path.resolve(__dirname, './dist/index.html')
    let index = fs.readFileSync(indexPath, 'utf-8')
    index = index
      .replace(/<script type="module".*?<\/script>/g, '')
      .replace(/<script nomodule/g, '<script')
    fs.writeFileSync(indexPath, index)
  },
})



================================================
FILE: playground/legacy/worker.js
================================================
import { module } from './module'

self.onmessage = () => {
  self.postMessage(module)
}



================================================
FILE: playground/legacy/__tests__/legacy.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import {
  findAssetFile,
  getColor,
  isBuild,
  listAssets,
  page,
  readManifest,
} from '~utils'

test('should load the worker', async () => {
  await expect.poll(() => page.textContent('.worker-message')).toMatch('module')
})

test('should work', async () => {
  await expect.poll(() => page.textContent('#app')).toMatch('Hello')
})

test('import.meta.env.LEGACY', async () => {
  await expect
    .poll(() => page.textContent('#env'))
    .toMatch(isBuild ? 'true' : 'false')
  await expect.poll(() => page.textContent('#env-equal')).toMatch('true')
})

// https://github.com/vitejs/vite/issues/3400
test('transpiles down iterators correctly', async () => {
  await expect.poll(() => page.textContent('#iterators')).toMatch('hello')
})

test('async generator', async () => {
  await expect
    .poll(() => page.textContent('#async-generator'))
    .toMatch('[0,1,2]')
})

test('wraps with iife', async () => {
  await expect
    .poll(() => page.textContent('#babel-helpers'))
    .toMatch('exposed babel helpers: false')
})

test('generates assets', async () => {
  await expect
    .poll(() => page.textContent('#assets'))
    .toMatch(
      isBuild
        ? [
            'index: text/html',
            'index-legacy: text/html',
            'chunk-async: text/html',
            'chunk-async-legacy: text/html',
            'immutable-chunk: text/javascript',
            'immutable-chunk-legacy: text/javascript',
            'polyfills-legacy: text/html',
          ].join('\n')
        : [
            'index: text/html',
            'index-legacy: text/html',
            'chunk-async: text/html',
            'chunk-async-legacy: text/html',
            'immutable-chunk: text/html',
            'immutable-chunk-legacy: text/html',
            'polyfills-legacy: text/html',
          ].join('\n'),
    )
})

test('correctly emits styles', async () => {
  expect(await getColor('#app')).toBe('red')
})

// dynamic import css
test('should load dynamic import with css', async () => {
  await page.click('#dynamic-css-button')
  await expect.poll(() => getColor('#dynamic-css')).toBe('red')
})

test('asset url', async () => {
  expect(await page.textContent('#asset-path')).toMatch(
    isBuild ? /\/assets\/vite-[-\w]+\.svg/ : '/vite.svg',
  )
})

describe.runIf(isBuild)('build', () => {
  test('should generate correct manifest', async () => {
    const manifest = readManifest()
    // legacy polyfill
    expect(manifest['../../vite/legacy-polyfills-legacy']).toBeDefined()
    expect(manifest['../../vite/legacy-polyfills-legacy'].src).toBe(
      '../../vite/legacy-polyfills-legacy',
    )
    expect(manifest['custom0-legacy.js'].file).toMatch(
      /chunk-X-legacy\.[-\w]{8}.js/,
    )
    expect(manifest['custom1-legacy.js'].file).toMatch(
      /chunk-X-legacy-[-\w]{8}.js/,
    )
    expect(manifest['custom2-legacy.js'].file).toMatch(
      /chunk-X-legacy[-\w]{8}.js/,
    )
    // modern polyfill
    expect(manifest['../../vite/legacy-polyfills']).toBeDefined()
    expect(manifest['../../vite/legacy-polyfills'].src).toBe(
      '../../vite/legacy-polyfills',
    )
  })

  test('should minify legacy chunks with terser', async () => {
    // This is a ghetto heuristic, but terser output seems to reliably start
    // with one of the following, and non-terser output (including unminified or
    // esbuild-minified) does not!
    const terserPattern = /^(?:!function|System.register)/

    expect(findAssetFile(/chunk-async-legacy/)).toMatch(terserPattern)
    expect(findAssetFile(/chunk-async(?!-legacy)/)).not.toMatch(terserPattern)
    expect(findAssetFile(/immutable-chunk-legacy/)).toMatch(terserPattern)
    expect(findAssetFile(/immutable-chunk(?!-legacy)/)).not.toMatch(
      terserPattern,
    )
    expect(findAssetFile(/index-legacy/)).toMatch(terserPattern)
    expect(findAssetFile(/index(?!-legacy)/)).not.toMatch(terserPattern)
    expect(findAssetFile(/polyfills-legacy/)).toMatch(terserPattern)
  })

  test('should emit css file', async () => {
    expect(
      listAssets().some((filename) => filename.endsWith('.css')),
    ).toBeTruthy()
  })

  test('includes structuredClone polyfill which is supported after core-js v3', () => {
    expect(findAssetFile(/polyfills-legacy/)).toMatch('"structuredClone"')
    expect(findAssetFile(/polyfills-[-\w]{8}\./)).toMatch('"structuredClone"')
  })

  test('should generate legacy sourcemap file', async () => {
    expect(
      listAssets().some((filename) =>
        /index-legacy-[-\w]{8}\.js\.map$/.test(filename),
      ),
    ).toBeTruthy()
    expect(
      listAssets().some((filename) =>
        /polyfills-legacy-[-\w]{8}\.js\.map$/.test(filename),
      ),
    ).toBeTruthy()
    // also for modern polyfills
    expect(
      listAssets().some((filename) =>
        /polyfills-[-\w]{8}\.js\.map$/.test(filename),
      ),
    ).toBeTruthy()
  })

  test('should have only modern entry files guarded', async () => {
    const guard = /(import\s*\()|(import.meta)|(async\s*function\*)/
    expect(findAssetFile(/index(?!-legacy)/)).toMatch(guard)
    expect(findAssetFile(/polyfills(?!-legacy)/)).toMatch(guard)

    expect(findAssetFile(/chunk-async(?!-legacy)/)).not.toMatch(guard)
    expect(findAssetFile(/index-legacy/)).not.toMatch(guard)
  })
})



================================================
FILE: playground/legacy/__tests__/client-and-ssr/legacy-client-legacy-ssr-sequential-builds.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { isBuild, page } from '~utils'

const url = `http://localhost:${port}`

describe.runIf(isBuild)('client-legacy-ssr-sequential-builds', () => {
  test('should work', async () => {
    await page.goto(url)
    expect(await page.textContent('#app')).toMatch('Hello')
  })

  test('import.meta.env.MODE', async () => {
    // SSR build is always modern
    expect(await page.textContent('#mode')).toMatch('test')
  })
})



================================================
FILE: playground/legacy/__tests__/client-and-ssr/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior
import path from 'node:path'
import { ports, rootDir } from '~utils'

export const port = ports['legacy/client-and-ssr']

export async function serve(): Promise<{ close(): Promise<void> }> {
  const { build } = await import('vite')

  await build({
    mode: 'test',
    root: rootDir,
    logLevel: 'silent',
    build: {
      target: 'esnext',
      outDir: 'dist/client',
    },
  })

  await build({
    mode: 'test',
    root: rootDir,
    logLevel: 'silent',
    build: {
      target: 'esnext',
      ssr: 'entry-server-sequential.js',
      outDir: 'dist/server',
    },
  })

  const { default: express } = await import('express')
  const app = express()

  app.use('/', async (_req, res) => {
    const { render } = await import(
      path.resolve(rootDir, './dist/server/entry-server-sequential.js')
    )
    const html = await render()
    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
  })

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/legacy/__tests__/no-polyfills/legacy-no-polyfills.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page, viteTestUrl } from '~utils'

test('should load and execute the JS file', async () => {
  await page.goto(viteTestUrl + '/no-polyfills.html')
  await expect.poll(() => page.textContent('main')).toMatch('👋')
})

test.runIf(isBuild)('includes a script tag for SystemJS', async () => {
  await expect
    .poll(() => page.getAttribute('#vite-legacy-polyfill', 'src'))
    .toMatch(/.\/assets\/polyfills-legacy-(.+)\.js/)
  await expect
    .poll(() => page.getAttribute('#vite-legacy-entry', 'data-src'))
    .toMatch(/.\/assets\/index-legacy-(.+)\.js/)
})



================================================
FILE: playground/legacy/__tests__/no-polyfills-no-systemjs/legacy-no-polyfills-no-systemjs.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page, viteTestUrl } from '~utils'

test.runIf(isBuild)('includes only a single script tag', async () => {
  await page.goto(viteTestUrl + '/no-polyfills-no-systemjs.html')

  await expect
    .poll(() => page.getAttribute('#vite-legacy-entry', 'data-src'))
    .toMatch(/.\/assets\/index-legacy-(.+)\.js/)

  expect(await page.locator('script').count()).toBe(1)
  expect(await page.locator('#vite-legacy-polyfill').count()).toBe(0)
  expect(await page.locator('#vite-legacy-entry').count()).toBe(1)
})



================================================
FILE: playground/legacy/__tests__/ssr/legacy-ssr.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { isBuild, page } from '~utils'

const url = `http://localhost:${port}`

describe.runIf(isBuild)('legacy-ssr', () => {
  test('should work', async () => {
    await page.goto(url)
    expect(await page.textContent('#app')).toMatch('Hello')
  })

  test('import.meta.env.LEGACY', async () => {
    // SSR build is always modern
    expect(await page.textContent('#env')).toMatch('false')
  })
})



================================================
FILE: playground/legacy/__tests__/ssr/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior
import path from 'node:path'
import { ports, rootDir } from '~utils'

export const port = ports['legacy/ssr']

export async function serve(): Promise<{ close(): Promise<void> }> {
  const { build } = await import('vite')
  await build({
    root: rootDir,
    logLevel: 'silent',
    build: {
      target: 'esnext',
      ssr: 'entry-server.js',
      outDir: 'dist/server',
    },
  })

  const { default: express } = await import('express')
  const app = express()

  app.use('/', async (_req, res) => {
    const { render } = await import(
      path.resolve(rootDir, './dist/server/entry-server.js')
    )
    const html = await render()
    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
  })

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/legacy/__tests__/watch/legacy-styles-only-entry-watch.spec.ts
================================================
import { expect, test } from 'vitest'
import {
  editFile,
  findAssetFile,
  isBuild,
  notifyRebuildComplete,
  readManifest,
  watcher,
} from '~utils'

test.runIf(isBuild)('rebuilds styles only entry on change', async () => {
  expect(findAssetFile(/style-only-entry-.+\.css/, 'watch')).toContain(
    '#ff69b4',
  )
  expect(findAssetFile(/style-only-entry-legacy-.+\.js/, 'watch')).toContain(
    '#ff69b4',
  )
  expect(findAssetFile(/polyfills-legacy-.+\.js/, 'watch')).toBeTruthy()
  const numberOfManifestEntries = Object.keys(readManifest('watch')).length
  expect(numberOfManifestEntries).toBe(3)

  editFile('style-only-entry.css', (originalContents) =>
    originalContents.replace('#ff69b4', '#ffb6c1'),
  )
  await notifyRebuildComplete(watcher)

  const updatedManifest = readManifest('watch')
  expect(Object.keys(updatedManifest)).toHaveLength(numberOfManifestEntries)

  // We must use the file referenced in the manifest here,
  // since there'll be different versions of the file with different hashes.
  const reRenderedCssFile = findAssetFile(
    updatedManifest['style-only-entry.css']!.file.substring('assets/'.length),
    'watch',
  )
  expect(reRenderedCssFile).toContain('#ffb6c1')
  const reRenderedCssLegacyFile = findAssetFile(
    updatedManifest['style-only-entry-legacy.css']!.file.substring(
      'assets/'.length,
    ),
    'watch',
  )
  expect(reRenderedCssLegacyFile).toContain('#ffb6c1')
  expect(findAssetFile(/polyfills-legacy-.+\.js/, 'watch')).toBeTruthy()
})



================================================
FILE: playground/legacy/nested/index.html
================================================
<h1 id="nested html"></h1>
<script type="module" src="../main.js"></script>



================================================
FILE: playground/lib/index.dist.html
================================================
<!-- the production demo page, copied into dist/ -->
<div class="es"></div>
<div class="umd"></div>
<div class="iife"></div>
<div class="dynamic-import-message"></div>

<script>
  // shim test preserve process.env.NODE_ENV
  globalThis.process = {
    env: {
      NODE_ENV: 'production',
    },
  }
</script>

<script type="module">
  import myLib from './my-lib-custom-filename.js'

  myLib('.es')
</script>

<script type="module">
  import message from './lib/dynamic-import-message.es.mjs'

  message('.dynamic-import-message')
</script>

<script src="./my-lib-custom-filename.umd.cjs"></script>
<script>
  MyLib('.umd')
  delete window.MyLib // so that it won't affect iife
</script>

<script src="./my-lib-custom-filename.iife.js"></script>
<script>
  MyLib('.iife')
</script>



================================================
FILE: playground/lib/index.html
================================================
<!-- the development demo page -->

<div class="demo"></div>

<script type="module">
  import myLib from './src/main.js'

  myLib('.demo')
</script>



================================================
FILE: playground/lib/package.json
================================================
{
  "name": "@vitejs/test-my-lib",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "sirv": "^3.0.1"
  }
}



================================================
FILE: playground/lib/vite.config.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    supported: {
      // Force esbuild inject helpers to test regex
      'object-rest-spread': false,
      'optional-chain': false,
    },
  },
  build: {
    rollupOptions: {
      output: {
        banner: `/*!\nMayLib\n*/`,
      },
    },
    lib: {
      entry: path.resolve(__dirname, 'src/main.js'),
      name: 'MyLib',
      formats: ['es', 'umd', 'iife'],
      fileName: 'my-lib-custom-filename',
    },
  },
  plugins: [
    {
      name: 'emit-index',
      generateBundle() {
        this.emitFile({
          type: 'asset',
          fileName: 'index.html',
          source: fs.readFileSync(
            path.resolve(__dirname, 'index.dist.html'),
            'utf-8',
          ),
        })
      },
    },
  ],
})



================================================
FILE: playground/lib/vite.css-code-split.config.js
================================================
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    cssCodeSplit: true,
    lib: {
      entry: [
        fileURLToPath(new URL('src/css-entry-1.js', import.meta.url)),
        fileURLToPath(new URL('src/css-entry-2.js', import.meta.url)),
      ],
      name: 'css-code-split',
    },
    outDir: 'dist/css-code-split',
  },
})



================================================
FILE: playground/lib/vite.css-multi-entry.config.js
================================================
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: [
        fileURLToPath(new URL('src/css-entry-1.js', import.meta.url)),
        fileURLToPath(new URL('src/css-entry-2.js', import.meta.url)),
      ],
      name: 'css-multi-entry',
    },
    outDir: 'dist/css-multi-entry',
  },
})



================================================
FILE: playground/lib/vite.css-single-entry.config.js
================================================
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: fileURLToPath(new URL('src/css-entry-1.js', import.meta.url)),
      name: 'css-single-entry',
    },
    outDir: 'dist/css-single-entry',
  },
})



================================================
FILE: playground/lib/vite.dyimport.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/main2.js'),
      formats: ['es', 'iife'],
      name: 'message',
      fileName: (format) => `dynamic-import-message.${format}.mjs`,
    },
    outDir: 'dist/lib',
  },
  cacheDir: 'node_modules/.vite-dyimport',
})



================================================
FILE: playground/lib/vite.helpers-injection.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

// Check that helpers injection is properly constrained

export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/main-helpers-injection.js'),
      name: 'MyLib',
      formats: ['iife'],
      fileName: 'my-lib-custom-filename',
    },
    minify: false,
    outDir: 'dist/helpers-injection',
  },
  plugins: [],
  cacheDir: 'node_modules/.vite-helpers-injection',
})



================================================
FILE: playground/lib/vite.multiple-output.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

const root = process.env.VITEST
  ? path.resolve(__dirname, '../../playground-temp/lib')
  : __dirname

export default defineConfig({
  build: {
    lib: {
      // set multiple entrypoint to trigger css chunking
      entry: {
        main: path.resolve(__dirname, 'src/main-multiple-output.js'),
        sub: path.resolve(__dirname, 'src/sub-multiple-output.js'),
      },
      name: 'MyLib',
    },
    outDir: 'dist/multiple-output',
    rollupOptions: {
      // due to playground-temp, the `dir` needs to be relative to the resolvedRoot
      output: [
        {
          dir: path.resolve(root, 'dist/multiple-output/es'),
          format: 'es',
          entryFileNames: 'index.mjs',
          assetFileNames: 'assets/mylib.css',
        },
        {
          dir: path.resolve(root, 'dist/multiple-output/cjs'),
          format: 'cjs',
          entryFileNames: 'index.cjs',
          assetFileNames: 'assets/mylib.css',
        },
      ],
    },
    cssCodeSplit: true,
  },
  cacheDir: 'node_modules/.vite-multiple-output',
})



================================================
FILE: playground/lib/vite.named-exports.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    supported: {
      // Force esbuild inject helpers to test regex
      'object-rest-spread': false,
    },
  },
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/main-named.js'),
      name: 'MyLibNamed',
      formats: ['umd', 'iife'],
      fileName: 'my-lib-named',
    },
    outDir: 'dist/named',
  },
})



================================================
FILE: playground/lib/vite.nominify.config.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config'

export default defineConfig({
  ...baseConfig,
  build: {
    ...baseConfig.build,
    minify: false,
    outDir: 'dist/nominify',
  },
  plugins: [],
  cacheDir: 'node_modules/.vite-nominify',
})



================================================
FILE: playground/lib/__tests__/lib.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { isBuild, isServe, page, readFile, serverLogs } from '~utils'

describe.runIf(isBuild)('build', () => {
  test('es', async () => {
    expect(await page.textContent('.es')).toBe('It works')
  })

  test('umd', async () => {
    expect(await page.textContent('.umd')).toBe('It works')
    const code = readFile('dist/my-lib-custom-filename.umd.cjs')
    const noMinifyCode = readFile(
      'dist/nominify/my-lib-custom-filename.umd.cjs',
    )
    const namedCode = readFile('dist/named/my-lib-named.umd.cjs')
    // esbuild helpers are injected inside of the UMD wrapper
    expect(code).toMatch(/^\(function\(/)
    expect(noMinifyCode).toMatch(
      /^\(function\(global.+?"use strict";var.+?function\smyLib\(/s,
    )
    expect(namedCode).toMatch(/^\(function\(/)
  })

  test('iife', async () => {
    expect(await page.textContent('.iife')).toBe('It works')
    const code = readFile('dist/my-lib-custom-filename.iife.js')
    const noMinifyCode = readFile(
      'dist/nominify/my-lib-custom-filename.iife.js',
    )
    const namedCode = readFile('dist/named/my-lib-named.iife.js')
    // esbuild helpers are injected inside of the IIFE wrapper
    expect(code).toMatch(/^var MyLib=function\(\)\{\s*"use strict";/)
    expect(noMinifyCode).toMatch(
      /^var MyLib\s*=\s*function\(\)\s*\{\s*"use strict";/,
    )
    expect(namedCode).toMatch(
      /^var MyLibNamed=function\([^()]+\)\{\s*"use strict";/,
    )
  })

  test('restrisct-helpers-injection', async () => {
    const code = readFile(
      'dist/helpers-injection/my-lib-custom-filename.iife.js',
    )
    expect(code).toMatch(
      `'"use strict"; return (' + expressionSyntax + ").constructor;"`,
    )
  })

  test('Library mode does not include `preload`', async () => {
    await expect
      .poll(() => page.textContent('.dynamic-import-message'))
      .toMatch('hello vite')
    const code = readFile('dist/lib/dynamic-import-message.es.mjs')
    expect(code).not.toMatch('__vitePreload')

    // Test that library chunks are hashed
    expect(code).toMatch(/await import\("\.\/message-[-\w]{8}.js"\)/)
  })

  test('Library mode does not have any reference to pure CSS chunks', async () => {
    const code = readFile('dist/lib/dynamic-import-message.es.mjs')

    // Does not import pure CSS chunks and replaced by `Promise.resolve({})` instead
    expect(code).not.toMatch(/await import\("\.\/dynamic-[-\w]{8}.js"\)/)
    expect(code).toMatch(/await Promise.resolve\(\{.*\}\)/)
  })

  test('@import hoist', async () => {
    serverLogs.forEach((log) => {
      // no warning from esbuild css minifier
      expect(log).not.toMatch('All "@import" rules must come first')
    })
  })

  test('preserve process.env', () => {
    const es = readFile('dist/my-lib-custom-filename.js')
    const iife = readFile('dist/my-lib-custom-filename.iife.js')
    const umd = readFile('dist/my-lib-custom-filename.umd.cjs')
    expect(es).toMatch('process.env.NODE_ENV')
    expect(iife).toMatch('process.env.NODE_ENV')
    expect(umd).toMatch('process.env.NODE_ENV')
  })

  test('single entry with css', () => {
    const css = readFile('dist/css-single-entry/test-my-lib.css')
    const js = readFile('dist/css-single-entry/test-my-lib.js')
    const umd = readFile('dist/css-single-entry/test-my-lib.umd.cjs')
    expect(css).toMatch('entry-1.css')
    expect(js).toMatch('css-entry-1')
    expect(umd).toContain('css-entry-1')
  })

  test('multi entry with css', () => {
    const css = readFile('dist/css-multi-entry/test-my-lib.css')
    const js1 = readFile('dist/css-multi-entry/css-entry-1.js')
    const js2 = readFile('dist/css-multi-entry/css-entry-2.js')
    const cjs1 = readFile('dist/css-multi-entry/css-entry-1.cjs')
    const cjs2 = readFile('dist/css-multi-entry/css-entry-2.cjs')
    expect(css).toMatch('entry-1.css')
    expect(css).toMatch('entry-2.css')
    expect(js1).toMatch('css-entry-1')
    expect(js2).toMatch('css-entry-2')
    expect(cjs1).toContain('css-entry-1')
    expect(cjs2).toContain('css-entry-2')
  })

  test('multi entry with css and code split', () => {
    const css1 = readFile('dist/css-code-split/css-entry-1.css')
    const css2 = readFile('dist/css-code-split/css-entry-2.css')
    const js1 = readFile('dist/css-code-split/css-entry-1.js')
    const js2 = readFile('dist/css-code-split/css-entry-2.js')
    const cjs1 = readFile('dist/css-code-split/css-entry-1.cjs')
    const cjs2 = readFile('dist/css-code-split/css-entry-2.cjs')
    expect(css1).toMatch('entry-1.css')
    expect(css2).toMatch('entry-2.css')
    expect(js1).toMatch('css-entry-1')
    expect(js2).toMatch('css-entry-2')
    expect(cjs1).toContain('css-entry-1')
    expect(cjs2).toContain('css-entry-2')
  })
})

test.runIf(isServe)('dev', async () => {
  await expect.poll(() => page.textContent('.demo')).toBe('It works')
})



================================================
FILE: playground/lib/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import http from 'node:http'
import sirv from 'sirv'
import {
  isBuild,
  page,
  ports,
  rootDir,
  serverLogs,
  setViteUrl,
  viteTestUrl,
} from '~utils'

export const port = ports.lib

export async function serve(): Promise<{ close(): Promise<void> }> {
  setupConsoleWarnCollector()

  if (!isBuild) {
    const { createServer } = await import('vite')
    process.env.VITE_INLINE = 'inline-serve'
    const viteServer = await (
      await createServer({
        root: rootDir,
        logLevel: 'silent',
        server: {
          port,
          strictPort: true,
          watch: {
            usePolling: true,
            interval: 100,
          },
          host: true,
          fs: {
            strict: !isBuild,
          },
        },
        build: {
          target: 'esnext',
        },
      })
    ).listen()
    // use resolved port/base from server
    const devBase = viteServer.config.base === '/' ? '' : viteServer.config.base
    setViteUrl(`http://localhost:${port}${devBase}`)
    await page.goto(viteTestUrl)

    return viteServer
  } else {
    const { build } = await import('vite')
    await build({
      root: rootDir,
      logLevel: 'silent',
      configFile: path.resolve(__dirname, '../vite.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.dyimport.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.multiple-output.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.nominify.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(
        __dirname,
        '../vite.helpers-injection.config.js',
      ),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.named-exports.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.css-single-entry.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.css-multi-entry.config.js'),
    })

    await build({
      root: rootDir,
      logLevel: 'warn', // output esbuild warns
      configFile: path.resolve(__dirname, '../vite.css-code-split.config.js'),
    })

    // start static file server
    const serve = sirv(path.resolve(rootDir, 'dist'))
    const httpServer = http.createServer((req, res) => {
      if (req.url === '/ping') {
        res.statusCode = 200
        res.end('pong')
      } else {
        serve(req, res)
      }
    })

    return new Promise((resolve, reject) => {
      try {
        const server = httpServer.listen(port, async () => {
          await page.goto(`http://localhost:${port}`)
          resolve({
            // for test teardown
            async close() {
              await new Promise((resolve) => {
                server.close(resolve)
              })
            },
          })
        })
      } catch (e) {
        reject(e)
      }
    })
  }
}

function setupConsoleWarnCollector() {
  const warn = console.warn
  console.warn = (...args) => {
    serverLogs.push(args.join(' '))
    return warn.call(console, ...args)
  }
}



================================================
FILE: playground/lib/src/css-entry-1.js
================================================
import './entry-1.css'

export default 'css-entry-1'



================================================
FILE: playground/lib/src/css-entry-2.js
================================================
import './entry-2.css'

export default 'css-entry-2'



================================================
FILE: playground/lib/src/dynamic.css
================================================
@import 'https://cdn.jsdelivr.net/npm/@mdi/font@5.9.55/css/materialdesignicons.min.css';
.dynamic {
  color: red;
}



================================================
FILE: playground/lib/src/entry-1.css
================================================
h1 {
  content: 'entry-1.css';
}



================================================
FILE: playground/lib/src/entry-2.css
================================================
h2 {
  content: 'entry-2.css';
}



================================================
FILE: playground/lib/src/index.css
================================================
.index {
  color: blue;
}



================================================
FILE: playground/lib/src/main-helpers-injection.js
================================================
// Trigger wrong helpers injection if not properly constrained
;(function () {
  var getEvalledConstructor = function (expressionSyntax) {
    try {
      return $Function(
        '"use strict"; return (' + expressionSyntax + ').constructor;',
      )()
    } catch (e) {}
  }
  console.log(getEvalledConstructor(0))
})()



================================================
FILE: playground/lib/src/main-multiple-output.js
================================================
// import file to test css build handling
import './index.css'

export default async function message(sel) {
  document.querySelector(sel).textContent = 'success'
}



================================================
FILE: playground/lib/src/main-named.js
================================================
export const foo = 'foo'

// Force esbuild spread helpers
console.log({ ...foo })



================================================
FILE: playground/lib/src/main.js
================================================
export default function myLib(sel) {
  // Force esbuild spread helpers (https://github.com/evanw/esbuild/issues/951)
  console.log({ ...'foo' })

  document.querySelector(sel).textContent = 'It works'

  // Env vars should not be replaced
  console.log(process.env.NODE_ENV)

  // make sure umd helper has been moved to the right position
  console.log(`amd function(){ "use strict"; }`)
}

// For triggering unhandled global esbuild helpers in previous regex-based implementation for injection
;(function () {})()?.foo



================================================
FILE: playground/lib/src/main2.js
================================================
import './index.css'

export default async function message(sel) {
  const message = await import('./message.js')

  await import('./dynamic.css')

  document.querySelector(sel).textContent = message.default
}



================================================
FILE: playground/lib/src/message.js
================================================
export default 'hello vite'



================================================
FILE: playground/lib/src/sub-multiple-output.js
================================================
// import file to test css build handling
import './index.css'

export default async function message(sel) {
  document.querySelector(sel).textContent = 'success'
}



================================================
FILE: playground/minify/index.html
================================================
<h1>Minify</h1>

<script type="module" src="./main.js"></script>



================================================
FILE: playground/minify/main.js
================================================
import './test.css'
import { msg } from 'minified-module'

console.log(msg)

if (window) {
  console.log('hello world')
}



================================================
FILE: playground/minify/package.json
================================================
{
  "name": "@vitejs/test-minify",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "minified-module": "file:./dir/module"
  }
}



================================================
FILE: playground/minify/test.css
================================================
@import 'minified-module/index.css';

h1 {
  /* do not minify as red text */
  color: #ff0000;
}



================================================
FILE: playground/minify/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    legalComments: 'none',
    minifySyntax: false,
  },
})



================================================
FILE: playground/minify/__tests__/minify.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { expect, test } from 'vitest'
import { isBuild, readFile, testDir } from '~utils'

test.runIf(isBuild)('no minifySyntax', () => {
  const assetsDir = path.resolve(testDir, 'dist/assets')
  const files = fs.readdirSync(assetsDir)

  const jsFile = files.find((f) => f.endsWith('.js'))
  const jsContent = readFile(path.resolve(assetsDir, jsFile))

  const cssFile = files.find((f) => f.endsWith('.css'))
  const cssContent = readFile(path.resolve(assetsDir, cssFile))

  expect(jsContent).toContain('{console.log("hello world")}')
  expect(jsContent).not.toContain('/*! explicit comment */')

  expect(cssContent).toContain('color:#ff0000')
  expect(cssContent).not.toContain('/*! explicit comment */')
})



================================================
FILE: playground/minify/dir/module/index.css
================================================
/*! explicit comment */
h2 {
  color: #ff00ff;
}



================================================
FILE: playground/minify/dir/module/index.js
================================================
/*! explicit comment */
export const msg = `[success] minified module`



================================================
FILE: playground/minify/dir/module/package.json
================================================
{
  "name": "@vitejs/test-minify",
  "private": true,
  "type": "module",
  "version": "0.0.0"
}



================================================
FILE: playground/module-graph/empty.js
================================================
[Empty file]


================================================
FILE: playground/module-graph/imported-urls-order.js
================================================
import { msg } from 'virtual:slow-module'
import './empty.js'

export default msg

// This module tests that the import order is preserved in this module's `importedUrls` property
// as the imports can be processed in parallel



================================================
FILE: playground/module-graph/index.html
================================================
<div class="imported-urls-order"></div>

<script type="module">
  import importedUrlsOrderSuccess from './imported-urls-order'
  text('.imported-urls-order', importedUrlsOrderSuccess)

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>



================================================
FILE: playground/module-graph/package.json
================================================
{
  "name": "@vitejs/test-hmr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/module-graph/vite.config.ts
================================================
import { defineConfig } from 'vite'
import type { Plugin } from 'vite'

export default defineConfig({
  plugins: [slowModulePlugin()],
})

function slowModulePlugin(): Plugin {
  return {
    name: 'slow-module',
    resolveId(id) {
      if (id === 'virtual:slow-module') {
        return '\0virtual:slow-module'
      }
    },
    async load(id) {
      if (id === '\0virtual:slow-module') {
        await new Promise((resolve) => setTimeout(resolve, 500))
        return `export const msg = '[success]'`
      }
    },
  }
}



================================================
FILE: playground/module-graph/__tests__/module-graph.spec.ts
================================================
import { expect, test } from 'vitest'
import { isServe, page, viteServer } from '~utils'

test.runIf(isServe)('importedUrls order is preserved', async () => {
  const el = page.locator('.imported-urls-order')
  expect(await el.textContent()).toBe('[success]')
  const mod = await viteServer.environments.client.moduleGraph.getModuleByUrl(
    '/imported-urls-order.js',
  )
  const importedModuleIds = [...mod.importedModules].map((m) => m.url)
  expect(importedModuleIds).toEqual(['\x00virtual:slow-module', '/empty.js'])
})



================================================
FILE: playground/multiple-entrypoints/deps.json
================================================
{
  "a0": "./a0.js",
  "a1": "./a1.js",
  "a2": "./a2.js",
  "a3": "./a3.js",
  "a4": "./a4.js",
  "a5": "./a5.js",
  "a6": "./a6.js",
  "a7": "./a7.js",
  "a8": "./a8.js",
  "a9": "./a9.js",
  "a10": "./a10.js",
  "a11": "./a11.js",
  "a12": "./a12.js",
  "a13": "./a13.js",
  "a14": "./a14.js",
  "a15": "./a15.js",
  "a16": "./a16.js",
  "a17": "./a17.js",
  "a18": "./a18.js",
  "a19": "./a19.js",
  "a20": "./a20.js",
  "a21": "./a21.js",
  "a22": "./a22.js",
  "a23": "./a23.js",
  "a24": "./a24.js"
}



================================================
FILE: playground/multiple-entrypoints/dynamic-a.js
================================================
import './reference'



================================================
FILE: playground/multiple-entrypoints/dynamic-b.js
================================================
import './reference'



================================================
FILE: playground/multiple-entrypoints/index.html
================================================
<script type="module" src="./index.js"></script>

<button class="a">A</button>
<button class="b">B</button>
<div class="content">Initial</div>



================================================
FILE: playground/multiple-entrypoints/index.js
================================================
document
  .querySelector('.a')
  .addEventListener('click', () => import('./dynamic-a'))
document
  .querySelector('.b')
  .addEventListener('click', () => import('./dynamic-b'))



================================================
FILE: playground/multiple-entrypoints/package.json
================================================
{
  "name": "@vitejs/test-multiple-entrypoints",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "devDependencies": {
    "sass": "^1.90.0"
  }
}



================================================
FILE: playground/multiple-entrypoints/reference.js
================================================
import './reference.scss'

document.querySelector('.content').textContent = 'Reference'



================================================
FILE: playground/multiple-entrypoints/reference.scss
================================================
.content {
  color: red;
}



================================================
FILE: playground/multiple-entrypoints/vite.config.js
================================================
import { resolve } from 'node:path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: './dist',
    emptyOutDir: true,
    rollupOptions: {
      preserveEntrySignatures: 'strict',
      input: {
        a0: resolve(__dirname, 'entrypoints/a0.js'),
        a1: resolve(__dirname, 'entrypoints/a1.js'),
        a2: resolve(__dirname, 'entrypoints/a2.js'),
        a3: resolve(__dirname, 'entrypoints/a3.js'),
        a4: resolve(__dirname, 'entrypoints/a4.js'),
        a5: resolve(__dirname, 'entrypoints/a5.js'),
        a6: resolve(__dirname, 'entrypoints/a6.js'),
        a7: resolve(__dirname, 'entrypoints/a7.js'),
        a8: resolve(__dirname, 'entrypoints/a8.js'),
        a9: resolve(__dirname, 'entrypoints/a9.js'),
        a10: resolve(__dirname, 'entrypoints/a10.js'),
        a11: resolve(__dirname, 'entrypoints/a11.js'),
        a12: resolve(__dirname, 'entrypoints/a12.js'),
        a13: resolve(__dirname, 'entrypoints/a13.js'),
        a14: resolve(__dirname, 'entrypoints/a14.js'),
        a15: resolve(__dirname, 'entrypoints/a15.js'),
        a16: resolve(__dirname, 'entrypoints/a16.js'),
        a17: resolve(__dirname, 'entrypoints/a17.js'),
        a18: resolve(__dirname, 'entrypoints/a18.js'),
        a19: resolve(__dirname, 'entrypoints/a19.js'),
        a20: resolve(__dirname, 'entrypoints/a20.js'),
        a21: resolve(__dirname, 'entrypoints/a21.js'),
        a22: resolve(__dirname, 'entrypoints/a22.js'),
        a23: resolve(__dirname, 'entrypoints/a23.js'),
        a24: resolve(__dirname, 'entrypoints/a24.js'),
        index: resolve(__dirname, './index.html'),
      },
    },
  },
})



================================================
FILE: playground/multiple-entrypoints/__tests__/multiple-entrypoints.spec.ts
================================================
import { expect, test } from 'vitest'
import { getColor, page } from '~utils'

test('should have css applied on second dynamic import', async () => {
  await expect.poll(() => page.textContent('.content')).toMatch('Initial')
  await page.click('.b')

  await expect.poll(() => page.textContent('.content')).toMatch('Reference')
  expect(await getColor('.content')).toBe('red')
})



================================================
FILE: playground/multiple-entrypoints/entrypoints/a0.js
================================================
import a1 from './a1'
import a2 from './a2'
import a3 from './a3'
import a4 from './a4'
import a5 from './a5'
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export function other() {
  return (
    a1() +
    a2() +
    a3() +
    a4() +
    a5() +
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a1.js
================================================
import a2 from './a2'
import a3 from './a3'
import a4 from './a4'
import a5 from './a5'
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a0.js')

export function other() {
  return (
    a2() +
    a3() +
    a4() +
    a5() +
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a10.js
================================================
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a9.js')

export function other() {
  return (
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a11.js
================================================
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a10.js')

export function other() {
  return (
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a12.js
================================================
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a11.js')

export function other() {
  return (
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a13.js
================================================
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a12.js')

export function other() {
  return (
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a14.js
================================================
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a13.js')

export function other() {
  return (
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a15.js
================================================
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a14.js')

export function other() {
  return a16() + a17() + a18() + a19() + a20() + a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a16.js
================================================
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a15.js')

export function other() {
  return a17() + a18() + a19() + a20() + a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a17.js
================================================
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a16.js')

export function other() {
  return a18() + a19() + a20() + a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a18.js
================================================
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a17.js')

export function other() {
  return a19() + a20() + a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a19.js
================================================
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a18.js')

export function other() {
  return a20() + a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a2.js
================================================
import a3 from './a3'
import a4 from './a4'
import a5 from './a5'
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a1.js')

export function other() {
  return (
    a3() +
    a4() +
    a5() +
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a20.js
================================================
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a19.js')

export function other() {
  return a21() + a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a21.js
================================================
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a20.js')

export function other() {
  return a22() + a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a22.js
================================================
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a21.js')

export function other() {
  return a23() + a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a23.js
================================================
import a24 from './a24'

export const that = () => import('./a22.js')

export function other() {
  return a24()
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a24.js
================================================
export const that = () => import('./a23.js')

export function other() {
  return
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a3.js
================================================
import a4 from './a4'
import a5 from './a5'
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a2.js')

export function other() {
  return (
    a4() +
    a5() +
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a4.js
================================================
import a5 from './a5'
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a3.js')

export function other() {
  return (
    a5() +
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a5.js
================================================
import a6 from './a6'
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a4.js')

export function other() {
  return (
    a6() +
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a6.js
================================================
import a7 from './a7'
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a5.js')

export function other() {
  return (
    a7() +
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a7.js
================================================
import a8 from './a8'
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a6.js')

export function other() {
  return (
    a8() +
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a8.js
================================================
import a9 from './a9'
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a7.js')

export function other() {
  return (
    a9() +
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/multiple-entrypoints/entrypoints/a9.js
================================================
import a10 from './a10'
import a11 from './a11'
import a12 from './a12'
import a13 from './a13'
import a14 from './a14'
import a15 from './a15'
import a16 from './a16'
import a17 from './a17'
import a18 from './a18'
import a19 from './a19'
import a20 from './a20'
import a21 from './a21'
import a22 from './a22'
import a23 from './a23'
import a24 from './a24'

export const that = () => import('./a8.js')

export function other() {
  return (
    a10() +
    a11() +
    a12() +
    a13() +
    a14() +
    a15() +
    a16() +
    a17() +
    a18() +
    a19() +
    a20() +
    a21() +
    a22() +
    a23() +
    a24()
  )
}

export default function () {
  return 123
}



================================================
FILE: playground/nested-deps/index.html
================================================
<h2>direct dependency A</h2>
<pre class="a"></pre>

<h2>direct dependency B</h2>
<pre class="b"></pre>

<h2>nested dependency A</h2>
<pre class="nested-a"></pre>

<h2>direct dependency C</h2>
<pre class="c"></pre>

<h2>side dependency C</h2>
<pre class="side-c"></pre>

<h2>direct dependency D</h2>
<pre class="d"></pre>

<h2>nested dependency nested-D (dep of D)</h2>
<pre class="nested-d"></pre>

<h2>exclude dependency of pre-bundled dependency</h2>
<div>nested module instance count: <span class="nested-e"></span></div>

<h2>absolute dependency path: <span class="absolute-f"></span></h2>

<h2>self referencing</h2>
<pre class="self-referencing"></pre>

<script type="module">
  import A from '@vitejs/test-package-a'
  import B, { A as nestedA } from '@vitejs/test-package-b'
  import C from '@vitejs/test-package-c'
  import { C as sideC } from '@vitejs/test-package-c/side'
  import D, { nestedD } from '@vitejs/test-package-d'
  import { testExcluded } from '@vitejs/test-package-e'
  import F from '__F_ABSOLUTE_PACKAGE_PATH__'
  import { isSelfReference } from '@vitejs/self-referencing/test'

  text('.a', A)
  text('.b', B)
  text('.nested-a', nestedA)

  text('.c', C)
  text('.side-c', sideC)

  text('.d', D)
  text('.nested-d', nestedD)

  text('.nested-e', testExcluded())

  text('.absolute-f', F)

  text('.self-referencing', isSelfReference)

  function text(sel, text) {
    document.querySelector(sel).textContent = text
  }
</script>



================================================
FILE: playground/nested-deps/package.json
================================================
{
  "name": "@vitejs/test-nested-deps",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-package-a": "link:./test-package-a",
    "@vitejs/test-package-b": "link:./test-package-b",
    "@vitejs/test-package-c": "link:./test-package-c",
    "@vitejs/test-package-d": "link:./test-package-d",
    "@vitejs/test-package-e": "link:./test-package-e",
    "@vitejs/test-package-f": "link:./test-package-f",
    "@vitejs/self-referencing": "link:../self-referencing"
  }
}



================================================
FILE: playground/nested-deps/vite.config.js
================================================
import path from 'node:path'
import { defineConfig } from 'vite'

const packageFPath = path.resolve(__dirname, 'test-package-f')

export default defineConfig({
  resolve: {
    alias: {
      __F_ABSOLUTE_PACKAGE_PATH__: packageFPath,
    },
  },
  optimizeDeps: {
    include: [
      '@vitejs/test-package-a',
      '@vitejs/test-package-b',
      '@vitejs/test-package-c',
      '@vitejs/test-package-c/side',
      '@vitejs/test-package-d    > @vitejs/test-package-d-nested',
      '@vitejs/test-package-e > @vitejs/test-package-e-included',
      '@vitejs/test-package-f',
    ],
    exclude: ['@vitejs/test-package-d', '@vitejs/test-package-e-excluded'],
  },
})



================================================
FILE: playground/nested-deps/__tests__/nested-deps.spec.ts
================================================
import { expect, test } from 'vitest'
import { page } from '~utils'

test('handle nested package', async () => {
  expect(await page.textContent('.a')).toBe('A@2.0.0')
  expect(await page.textContent('.b')).toBe('B@1.0.0')
  expect(await page.textContent('.nested-a')).toBe('A@1.0.0')
  const c = await page.textContent('.c')
  expect(c).toBe('es-C@1.0.0')
  expect(await page.textContent('.side-c')).toBe(c)
  expect(await page.textContent('.d')).toBe('D@1.0.0')
  expect(await page.textContent('.nested-d')).toBe('D-nested@1.0.0')
  expect(await page.textContent('.nested-e')).toBe('1')

  expect(await page.textContent('.absolute-f')).toBe('F@2.0.0')
  expect(await page.textContent('.self-referencing')).toBe('true')
})



================================================
FILE: playground/nested-deps/test-package-a/index.js
================================================
export default 'A@2.0.0'



================================================
FILE: playground/nested-deps/test-package-a/package.json
================================================
{
  "name": "@vitejs/test-package-a",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/nested-deps/test-package-b/index.js
================================================
export { default as A } from 'test-package-a'

export default 'B@1.0.0'



================================================
FILE: playground/nested-deps/test-package-b/package.json
================================================
{
  "name": "@vitejs/test-package-b",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/nested-deps/test-package-c/index-es.js
================================================
export default 'es-C@1.0.0'



================================================
FILE: playground/nested-deps/test-package-c/index.js
================================================
// this module should not be resolved
export default 'C@1.0.0'



================================================
FILE: playground/nested-deps/test-package-c/package.json
================================================
{
  "name": "@vitejs/test-package-c",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "module": "index-es.js"
}



================================================
FILE: playground/nested-deps/test-package-c/side.js
================================================
export { default as C } from '@vitejs/test-package-c'



================================================
FILE: playground/nested-deps/test-package-d/index.js
================================================
export { default as nestedD } from '@vitejs/test-package-d-nested'

export default 'D@1.0.0'



================================================
FILE: playground/nested-deps/test-package-d/package.json
================================================
{
  "name": "@vitejs/test-package-d",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-package-d-nested": "link:./test-package-d-nested"
  }
}



================================================
FILE: playground/nested-deps/test-package-d/test-package-d-nested/index.js
================================================
export default 'D-nested@1.0.0'



================================================
FILE: playground/nested-deps/test-package-d/test-package-d-nested/package.json
================================================
{
  "name": "@vitejs/test-package-d-nested",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/nested-deps/test-package-e/index.js
================================================
export { testIncluded } from '@vitejs/test-package-e-included'
export { testExcluded } from '@vitejs/test-package-e-excluded'



================================================
FILE: playground/nested-deps/test-package-e/package.json
================================================
{
  "name": "@vitejs/test-package-e",
  "private": true,
  "version": "0.1.0",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-package-e-excluded": "link:./test-package-e-excluded",
    "@vitejs/test-package-e-included": "link:./test-package-e-included"
  }
}



================================================
FILE: playground/nested-deps/test-package-e/test-package-e-excluded/index.js
================================================
const key = '$$excludedDependencyInstanceCount'

if (!(key in window)) {
  window[key] = 0
}

++window[key]

export function testExcluded() {
  return window[key]
}



================================================
FILE: playground/nested-deps/test-package-e/test-package-e-excluded/package.json
================================================
{
  "name": "@vitejs/test-package-e-excluded",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/nested-deps/test-package-e/test-package-e-included/index.js
================================================
import { testExcluded } from '@vitejs/test-package-e-excluded'

export function testIncluded() {
  return testExcluded()
}



================================================
FILE: playground/nested-deps/test-package-e/test-package-e-included/package.json
================================================
{
  "name": "@vitejs/test-package-e-included",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-package-e-excluded": "link:../test-package-e-excluded"
  }
}



================================================
FILE: playground/nested-deps/test-package-f/index.js
================================================
export default 'F@2.0.0'



================================================
FILE: playground/nested-deps/test-package-f/package.json
================================================
{
  "name": "@vitejs/test-package-f",
  "private": true,
  "version": "2.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/object-hooks/index.html
================================================
<h3>Transform Hook order</h3>
<div id="transform"></div>

<script type="module" src="./main.ts"></script>



================================================
FILE: playground/object-hooks/main.ts
================================================
const app = document.getElementById('transform')
app.innerText = '__TRANSFORM__'



================================================
FILE: playground/object-hooks/package.json
================================================
{
  "name": "@vitejs/test-object-hooks",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/object-hooks/vite.config.ts
================================================
/* eslint-disable n/prefer-node-protocol */
import assert from 'assert'
import { defineConfig } from 'vite'

let count = 0
export default defineConfig({
  plugins: [
    {
      name: 'plugin1',
      buildStart: {
        async handler() {
          await new Promise((r) => setTimeout(r, 100))
          count += 1
        },
      },
      transform: {
        order: 'post',
        handler(code) {
          return code.replace('__TRANSFORM3__', 'ok')
        },
      },
    },
    {
      name: 'plugin2',
      buildStart: {
        sequential: true,
        async handler() {
          assert(count === 1)
          await new Promise((r) => setTimeout(r, 100))
          count += 1
        },
      },
      transform: {
        handler(code) {
          return code.replace('__TRANSFORM1__', '__TRANSFORM2__')
        },
      },
    },
    {
      name: 'plugin3',
      buildStart: {
        async handler() {
          assert(count === 2)
          await new Promise((r) => setTimeout(r, 100))
          count += 1
        },
      },
      transform: {
        order: 'pre',
        handler(code) {
          return code.replace('__TRANSFORM__', '__TRANSFORM1__')
        },
      },
    },
    {
      name: 'plugin4',
      buildStart: {
        async handler() {
          assert(count === 2)
        },
      },
      transform: {
        handler(code) {
          return code.replace('__TRANSFORM2__', '__TRANSFORM3__')
        },
      },
    },
  ],
})



================================================
FILE: playground/object-hooks/__tests__/object-hooks.spec.ts
================================================
import { expect, test } from 'vitest'
import { page } from '~utils'

test('object hooks', async () => {
  expect(await page.textContent('#transform')).toMatch('ok')
})



================================================
FILE: playground/optimize-deps/cjs-dynamic.js
================================================
// test dynamic import to cjs deps
// mostly ensuring consistency between dev server behavior and build behavior
// of @rollup/plugin-commonjs
;(async () => {
  const { useState } = await import('react')
  const React = (await import('react')).default
  const ReactDOM = await import('react-dom/client')

  const clip = await import('clipboard')
  if (typeof clip.default === 'function') {
    text('.cjs-dynamic-clipboard', 'ok')
  }

  const { Socket } = await import('phoenix')
  if (typeof Socket === 'function') {
    text('.cjs-dynamic-phoenix', 'ok')
  }

  const cjsFromESM = await import('@vitejs/test-dep-cjs-compiled-from-esm')
  if (typeof cjsFromESM.default === 'function') {
    text('.cjs-dynamic-dep-cjs-compiled-from-esm', 'ok')
  }

  const cjsFromCJS = await import('@vitejs/test-dep-cjs-compiled-from-cjs')
  if (
    typeof cjsFromCJS.default === 'function' &&
    typeof cjsFromCJS !== 'function' &&
    cjsFromCJS.bar === 'bar'
  ) {
    text('.cjs-dynamic-dep-cjs-compiled-from-cjs', 'ok')
  }

  function App() {
    const [count, setCount] = useState(0)

    return React.createElement(
      'button',
      {
        onClick() {
          setCount(count + 1)
        },
      },
      `count is ${count}`,
    )
  }

  ReactDOM.createRoot(document.querySelector('.cjs-dynamic')).render(
    React.createElement(App),
  )

  function text(el, text) {
    document.querySelector(el).textContent = text
  }
})()



================================================
FILE: playground/optimize-deps/cjs.js
================================================
// test importing both default and named exports from a CommonJS module
// React is the ultimate test of this because its dynamic exports assignments
// are not statically detectable by @rollup/plugin-commonjs.
import React, { useState } from 'react'
import ReactDOM from 'react-dom/client'
import { Socket } from 'phoenix'
import clip from 'clipboard'
import cjsFromESM from '@vitejs/test-dep-cjs-compiled-from-esm'
import cjsFromCJS from '@vitejs/test-dep-cjs-compiled-from-cjs'
import * as cjsFromCJSNamespace from '@vitejs/test-dep-cjs-compiled-from-cjs'

// Test exporting a name that was already imported
export { useState } from 'react'
export { useState as anotherNameForUseState } from 'react'
export { default as React } from 'react'

if (typeof clip === 'function') {
  text('.cjs-clipboard', 'ok')
}

if (typeof Socket === 'function') {
  text('.cjs-phoenix', 'ok')
}

if (typeof cjsFromESM === 'function') {
  text('.cjs-dep-cjs-compiled-from-esm', 'ok')
}

if (
  typeof cjsFromCJS === 'function' &&
  typeof cjsFromCJSNamespace !== 'function' &&
  cjsFromCJSNamespace.bar === 'bar'
) {
  text('.cjs-dep-cjs-compiled-from-cjs', 'ok')
}

function App() {
  const [count, setCount] = useState(0)

  return React.createElement(
    'button',
    {
      onClick() {
        setCount(count + 1)
      },
    },
    `count is ${count}`,
  )
}

ReactDOM.createRoot(document.querySelector('.cjs')).render(
  React.createElement(App),
)

function text(el, text) {
  document.querySelector(el).textContent = text
}



================================================
FILE: playground/optimize-deps/dedupe.js
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'

// #1302: The linked package has a different version of React in its deps
// and is itself optimized. Without `dedupe`, the linked package is optimized
// with a separate copy of React included, and results in runtime errors.
import { useCount } from '@vitejs/test-dep-linked-include/index.mjs'

function App() {
  const [count, setCount] = useCount()

  return React.createElement(
    'button',
    {
      onClick() {
        setCount(count + 1)
      },
    },
    `count is ${count}`,
  )
}

ReactDOM.createRoot(document.querySelector('.dedupe')).render(
  React.createElement(App),
)



================================================
FILE: playground/optimize-deps/dynamic-use-dep-alias-using-absolute-path.js
================================================
// This is used to setup a test scenario, where dep scanner
// could not determine all of the used dependencies on first
// pass, e.g., a dependency that is aliased using an absolute
// path, in which case it used to trigger unnecessary "full
// reloads" invalidating all modules in a module graph.
export { default } from '@vitejs/test-dep-alias-using-absolute-path'



================================================
FILE: playground/optimize-deps/generics.vue
================================================
<!--
https://github.com/vuejs/core/issues/8171
https://github.com/vitejs/vite-plugin-vue/issues/162
generic attribute includes angle brackets which breaks scanning
This file only verifies that the scanner can work with such usage and nothing
else.
-->

<script lang="ts">
export class Item<TValue> {
  value: TValue
}
</script>

<script setup lang="ts" generic="TItem extends Item<TValue>, TValue">
defineProps<{
  items: TItem[]
  modelValue: TItem[]
}>()
</script>

<template>{{ items }}</template>



================================================
FILE: playground/optimize-deps/index.astro
================================================
<script>
  type Foo = 'bar';
  console.log("stuff");

  import.meta.glob('./dedupe.*', { eager: true })
</script>



================================================
FILE: playground/optimize-deps/index.html
================================================
<h1>Optimize Deps</h1>

<h2>CommonJS w/ named imports (react)</h2>
<div class="cjs"></div>
<h2>CommonJS w/ named imports (phoenix)</h2>
<div class="cjs-phoenix">fail</div>
<h2>CommonJS w/ default export (clipboard)</h2>
<div class="cjs-clipboard">fail</div>
<h2>CommonJS import default (dep-cjs-compiled-from-esm)</h2>
<div class="cjs-dep-cjs-compiled-from-esm"></div>
<h2>CommonJS import default (dep-cjs-compiled-from-cjs)</h2>
<div class="cjs-dep-cjs-compiled-from-cjs"></div>

<script type="module" src="./cjs.js"></script>

<h2>CommonJS dynamic import default + named (react)</h2>
<div class="cjs-dynamic"></div>
<h2>CommonJS dynamic import named (phoenix)</h2>
<div class="cjs-dynamic-phoenix"></div>
<h2>CommonJS dynamic import default (clipboard)</h2>
<div class="cjs-dynamic-clipboard"></div>
<h2>CommonJS dynamic import default (dep-cjs-compiled-from-esm)</h2>
<div class="cjs-dynamic-dep-cjs-compiled-from-esm"></div>
<h2>CommonJS dynamic import default (dep-cjs-compiled-from-cjs)</h2>
<div class="cjs-dynamic-dep-cjs-compiled-from-cjs"></div>

<script type="module" src="./cjs-dynamic.js"></script>

<h2>Dedupe (dep in linked & optimized package)</h2>
<div class="dedupe"></div>
<script type="module" src="./dedupe.js"></script>

<h2>CommonJS w/ browser field mapping (axios)</h2>
<div>This should show pong: <span class="cjs-browser-field"></span></div>

<h2>CommonJS w/ bare id browser field mapping</h2>
<div>This should show pong: <span class="cjs-browser-field-bare"></span></div>

<h2>Detecting linked src package and optimizing its deps (lodash-es)</h2>
<div>This should show fooBarBaz: <span class="deps-linked"></span></div>

<h2>Optimizing force included dep even when it's linked</h2>
<div class="force-include"></div>

<h2>Dep with CSS</h2>
<div class="dep-linked-include">This should be red</div>

<h2>CJS Dep with CSS</h2>
<div class="cjs-with-assets">This should be blue</div>

<h2>import * as ...</h2>
<div class="import-star"></div>

<h2>Import from dependency with process.env.NODE_ENV</h2>
<div class="node-env"></div>

<h2>Import from dependency with .notjs files</h2>
<div class="not-js"></div>

<h2>
  Import from dependency which uses relative path which needs to be resolved by
  main field
</h2>
<div class="relative-to-main"></div>

<h2>Import from dependency with dynamic import</h2>
<div class="dep-with-dynamic-import"></div>

<h2>Import from dependency with optional peer dep</h2>
<div class="dep-with-optional-peer-dep"></div>
<div class="dep-with-optional-peer-dep-error"></div>

<h2>Import from dependency with optional peer dep submodule</h2>
<div class="dep-with-optional-peer-dep-submodule"></div>
<div class="dep-with-optional-peer-dep-submodule-error"></div>

<h2>Import from dependency with optional peer dep (cjs)</h2>
<div class="dep-with-optional-peer-dep-cjs"></div>
<div class="dep-with-optional-peer-dep-cjs-error"></div>

<h2>Externalize known non-js files in optimize included dep</h2>
<div class="externalize-known-non-js"></div>

<h2>Vue & Vuex</h2>
<div class="vue"></div>

<h2>Dep with changes from esbuild plugin</h2>
<div>This should show a greeting: <span class="esbuild-plugin"></span></div>

<h2>Dep from hidden dir</h2>
<div>This should show hello!: <span class="hidden-dir"></span></div>

<h2>Nested include</h2>
<div>Module path: <span class="nested-include"></span></div>

<h2>Alias with colon</h2>
<div>URL: <span class="url"></span></div>

<h2>Alias using absolute path</h2>
<div class="alias-using-absolute-path"></div>

<h2>Reused variable names</h2>
<div>This should show reused: <span class="reused-variable-names"></span></div>

<h2>Flatten Id</h2>
<div class="clonedeep-slash"></div>
<div class="clonedeep-dot"></div>

<h2>Non Optimized Module isn't duplicated</h2>
<div class="non-optimized-module-is-not-duplicated"></div>

<h2>Pre bundle css require</h2>
<div class="css-require">css require</div>

<h2>Pre bundle css modules require</h2>
<div class="css-module-require">This should be red</div>

<h2>Long file name import works</h2>
<div class="long-file-name"></div>

<script type="module" src="./long-file-name.js"></script>

<h2>Import the CommonJS external package that omits the js suffix</h2>
<div class="external-package-js"></div>
<div class="external-package-scss-js"></div>
<div class="external-package-astro-js"></div>
<div class="external-package-tsx-js"></div>
<script type="module">
  import {
    astro,
    okay,
    scss,
    tsx,
  } from '@vitejs/test-dep-cjs-external-package-omit-js-suffix'

  text('.external-package-js', okay())
  text('.external-package-scss-js', scss())
  text('.external-package-astro-js', astro())
  text('.external-package-tsx-js', tsx())
</script>

<script>
  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>

<script type="module">
  // test dep detection in globbed files
  const globbed = import.meta.glob('./glob/*.js', { eager: true })

  import cjsBrowserFieldBare from '@vitejs/test-dep-cjs-browser-field-bare'
  text('.cjs-browser-field-bare', cjsBrowserFieldBare)

  import { camelCase } from '@vitejs/test-dep-linked'
  text('.deps-linked', camelCase('foo-bar-baz'))

  import { msg, VueSFC } from '@vitejs/test-dep-linked-include'
  text('.force-include', msg)
  text('.externalize-known-non-js', VueSFC.render())

  import * as linked from '@vitejs/test-dep-linked-include'
  const keys = Object.keys(linked)
  if (keys.length) {
    text('.import-star', `[success] ${keys.join(', ')}`)
  }

  import '@vitejs/test-dep-cjs-with-assets'
  import '@vitejs/test-dep-css-require'
  import cssModuleRequire from '@vitejs/test-dep-css-require/mod.cjs'
  document
    .querySelector('.css-module-require')
    .classList.add(cssModuleRequire.cssModuleRequire)

  import { env } from '@vitejs/test-dep-node-env'
  text('.node-env', env)

  import { notjsValue } from '@vitejs/test-dep-not-js'
  text('.not-js', notjsValue)

  import foo from '@vitejs/test-dep-relative-to-main/entry'
  text('.relative-to-main', foo)

  import { lazyFoo } from '@vitejs/test-dep-with-dynamic-import'
  lazyFoo().then((foo) => {
    text('.dep-with-dynamic-import', foo)
  })

  import { createApp } from 'vue'
  import { createStore } from 'vuex'
  if (typeof createApp === 'function' && typeof createStore === 'function') {
    text('.vue', '[success]')
  }

  import { hello } from '@vitejs/test-dep-esbuild-plugin-transform'
  text('.esbuild-plugin', hello())

  import { greeting } from './.hidden-dir/foo.js'
  text('.hidden-dir', greeting)

  import { nestedInclude } from '@vitejs/test-nested-exclude'
  text('.nested-include', nestedInclude)

  import { parse } from 'node:url'
  text('.url', parse('https://vite.dev').hostname)

  import('./dynamic-use-dep-alias-using-absolute-path.js').then((mod) =>
    text('.alias-using-absolute-path', mod.default),
  )

  import './index.astro'
  import './generics.vue'

  // All these imports should end up resolved to the same URL (same ?v= injected on them)
  import { add as addFromDirectAbsolutePath } from '/node_modules/@vitejs/test-dep-non-optimized/index.js'
  import { add as addFromDirectRelativePath } from './node_modules/@vitejs/test-dep-non-optimized/index.js'
  import { get as getFromBareImport } from '@vitejs/test-dep-non-optimized'

  addFromDirectAbsolutePath('from-absolute-path')
  addFromDirectRelativePath('from-relative-path')
  text(
    '.non-optimized-module-is-not-duplicated',
    getFromBareImport().join(', '),
  )
</script>

<script type="module">
  const reusedName = 1
</script>
<script type="module">
  const reusedName = 'reused'
  text('.reused-variable-names', reusedName)
</script>

<script type="module">
  import {
    callItself,
    callPeerDep,
  } from '@vitejs/test-dep-with-optional-peer-dep'
  text('.dep-with-optional-peer-dep', callItself())

  // expect error as optional peer dep not installed
  callPeerDep().catch((e) => {
    text(
      '.dep-with-optional-peer-dep-error',
      e &&
        typeof e.message === 'string' &&
        e.message.includes(
          'Could not resolve "foobar" imported by "@vitejs/test-dep-with-optional-peer-dep".',
        )
        ? '[success]'
        : `[failed]: ${e.message}`,
    )
  })
</script>

<script type="module">
  import {
    callItself,
    callPeerDepSubmodule,
  } from '@vitejs/test-dep-with-optional-peer-dep-submodule'
  text('.dep-with-optional-peer-dep-submodule', callItself())

  // expect error as optional peer dep not installed
  callPeerDepSubmodule().catch((e) => {
    text(
      '.dep-with-optional-peer-dep-submodule-error',
      e &&
        typeof e.message === 'string' &&
        e.message.includes(
          'Could not resolve "foobar/baz" imported by "@vitejs/test-dep-with-optional-peer-dep-submodule".',
        )
        ? '[success]'
        : `[failed]: ${e.message}`,
    )
  })
</script>

<script type="module">
  import {
    callItself,
    callPeerDep,
  } from '@vitejs/test-dep-with-optional-peer-dep-cjs'
  text('.dep-with-optional-peer-dep-cjs', callItself())

  // expect fallback as optional peer dep not installed
  text(
    '.dep-with-optional-peer-dep-cjs-error',
    callPeerDep() === 'fallback' ? '[success]' : `[failed]: did not fallback`,
  )
</script>

<script type="module">
  // should error on builtin modules (named import)
  // no node: protocol intentionally
  import { Buffer } from 'buffer'
  // named imports error immediately
</script>

<script type="module">
  // should error on builtin modules (default import)
  // no node: protocol intentionally
  import cp from 'child_process'
  // must access property to error
  if (import.meta.env.DEV) {
    cp.execSync()
  }
</script>

<script type="module">
  // should error on builtin modules from dep
  import { read } from '@vitejs/test-dep-with-builtin-module-esm'
  if (import.meta.env.DEV) {
    read()
  }
</script>

<script type="module">
  // should error on builtin modules from dep
  import { read } from '@vitejs/test-dep-with-builtin-module-cjs'
  if (import.meta.env.DEV) {
    read()
  }
</script>

<script type="module">
  import cloneDeepSlash from 'lodash/cloneDeep'
  import cloneDeepDot from 'lodash.clonedeep'

  text('.clonedeep-slash', cloneDeepSlash({ name: 'clonedeep-slash' }).name)
  text('.clonedeep-dot', cloneDeepDot({ name: 'clonedeep-dot' }).name)
</script>

<script type="module">
  import loadSub from '@vitejs/test-dep-incompatible'
  loadSub() // should show an error that tells there's an incompatible dep
</script>

<h2>Pre-bundle transitive dependency 'some-package.pdf'</h2>
<div>prebundled: <span class="dep-with-asset-ext-prebundled">???</span></div>
<div>
  no dual package: <span class="dep-with-asset-ext-no-dual-package">???</span>
</div>
<script type="module">
  import original, { isPreBundled } from '@vitejs/test-dep-with-asset-ext1.pdf'
  import reexport from '@vitejs/test-dep-with-asset-ext2.pdf'
  text('.dep-with-asset-ext-prebundled', isPreBundled)
  text('.dep-with-asset-ext-no-dual-package', original === reexport)
</script>

<script type="module">
  // manually check Firefox doesn't show warning in devtool debugger
  import * as sub from '@vitejs/test-dep-source-map-no-sources/sub.js'
  import * as all from '@vitejs/test-dep-source-map-no-sources/all.js'
</script>

<h2>Pre-bundle dependency with external sub-dependencies</h2>
<div>
  require('some-external-sub-dependency') returns a plain object rather than a
  module namespace object:
  <span class="dep-cjs-with-external-deps-object">???</span>
</div>
<div>
  require('some-external-sub-dependency') returns the default export if the
  dependency is a Node builtin:
  <span class="dep-cjs-with-external-deps-node-builtin">???</span>
</div>
<script type="module">
  import * as optimized from '@vitejs/test-dep-cjs-with-external-deps'
  text('.dep-cjs-with-external-deps-object', optimized.externalResult)
  text(
    '.dep-cjs-with-external-deps-node-builtin',
    optimized.externalDummyNodeBuiltinResult,
  )
</script>



================================================
FILE: playground/optimize-deps/long-file-name.js
================================================
import test from '@vitejs/longfilename-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/index'

const main = document.querySelector('.long-file-name')
main.innerHTML = test ?? 'failed to import'



================================================
FILE: playground/optimize-deps/package.json
================================================
{
  "name": "@vitejs/test-optimize-deps",
  "private": true,
  "type": "module",
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "clipboard": "^2.0.11",
    "@vitejs/longfilename-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa": "file:./longfilename",
    "@vitejs/test-dep-alias-using-absolute-path": "file:./dep-alias-using-absolute-path",
    "@vitejs/test-dep-cjs-browser-field-bare": "file:./dep-cjs-browser-field-bare",
    "@vitejs/test-dep-cjs-compiled-from-cjs": "file:./dep-cjs-compiled-from-cjs",
    "@vitejs/test-dep-cjs-compiled-from-esm": "file:./dep-cjs-compiled-from-esm",
    "@vitejs/test-dep-cjs-with-assets": "file:./dep-cjs-with-assets",
    "@vitejs/test-dep-cjs-with-external-deps": "file:./dep-cjs-with-external-deps",
    "@vitejs/test-dep-css-require": "file:./dep-css-require",
    "@vitejs/test-dep-esbuild-plugin-transform": "file:./dep-esbuild-plugin-transform",
    "@vitejs/test-dep-incompatible": "file:./dep-incompatible",
    "@vitejs/test-dep-linked": "link:./dep-linked",
    "@vitejs/test-dep-linked-include": "link:./dep-linked-include",
    "@vitejs/test-dep-node-env": "file:./dep-node-env",
    "@vitejs/test-dep-not-js": "file:./dep-not-js",
    "@vitejs/test-dep-optimize-exports-with-glob": "file:./dep-optimize-exports-with-glob",
    "@vitejs/test-dep-optimize-exports-with-root-glob": "file:./dep-optimize-exports-with-root-glob",
    "@vitejs/test-dep-optimize-with-glob": "file:./dep-optimize-with-glob",
    "@vitejs/test-dep-relative-to-main": "file:./dep-relative-to-main",
    "@vitejs/test-dep-source-map-no-sources": "file:./dep-source-map-no-sources",
    "@vitejs/test-dep-with-asset-ext1.pdf": "file:./dep-with-asset-ext/dep1",
    "@vitejs/test-dep-with-asset-ext2.pdf": "file:./dep-with-asset-ext/dep2",
    "@vitejs/test-dep-with-builtin-module-cjs": "file:./dep-with-builtin-module-cjs",
    "@vitejs/test-dep-with-builtin-module-esm": "file:./dep-with-builtin-module-esm",
    "@vitejs/test-dep-with-dynamic-import": "file:./dep-with-dynamic-import",
    "@vitejs/test-dep-with-optional-peer-dep": "file:./dep-with-optional-peer-dep",
    "@vitejs/test-dep-with-optional-peer-dep-cjs": "file:./dep-with-optional-peer-dep-cjs",
    "@vitejs/test-dep-with-optional-peer-dep-submodule": "file:./dep-with-optional-peer-dep-submodule",
    "@vitejs/test-dep-non-optimized": "file:./dep-non-optimized",
    "@vitejs/test-added-in-entries": "file:./added-in-entries",
    "@vitejs/test-dep-cjs-external-package-omit-js-suffix": "file:./dep-cjs-external-package-omit-js-suffix",
    "lodash-es": "^4.17.21",
    "@vitejs/test-nested-exclude": "file:./nested-exclude",
    "phoenix": "^1.8.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "@vitejs/test-resolve-linked": "workspace:0.0.0",
    "url": "^0.11.4",
    "vue": "^3.5.18",
    "vuex": "^4.1.0",
    "lodash": "^4.17.21",
    "lodash.clonedeep": "^4.5.0"
  }
}



================================================
FILE: playground/optimize-deps/unused-split-entry.js
================================================
import msg from '@vitejs/test-added-in-entries'

// This is an entry file that is added to optimizeDeps.entries
// When the deps aren't cached, these entries are also processed
// to discover dependencies in them. This should only be needed
// for code split sections that are commonly visited after
// first load where a full-reload wants to be avoided at the expense
// of extra processing on cold start. Another option is to add
// the missing dependencies to optimizeDeps.include directly

console.log(msg)



================================================
FILE: playground/optimize-deps/vite.config.js
================================================
import fs from 'node:fs'
import module from 'node:module'
import { defineConfig } from 'vite'
const require = module.createRequire(import.meta.url)

export default defineConfig({
  resolve: {
    dedupe: ['react'],
    alias: {
      'node:url': 'url',
      '@vitejs/test-dep-alias-using-absolute-path': require.resolve(
        '@vitejs/test-dep-alias-using-absolute-path',
      ),
    },
  },
  optimizeDeps: {
    include: [
      '@vitejs/test-dep-linked-include',
      '@vitejs/test-nested-exclude > @vitejs/test-nested-include',
      '@vitejs/test-dep-cjs-external-package-omit-js-suffix',
      // will throw if optimized (should log warning instead)
      '@vitejs/test-non-optimizable-include',
      '@vitejs/test-dep-optimize-exports-with-glob/**/*',
      '@vitejs/test-dep-optimize-exports-with-root-glob/**/*.js',
      '@vitejs/test-dep-optimize-with-glob/**/*.js',
      '@vitejs/test-dep-cjs-with-external-deps',
    ],
    exclude: [
      '@vitejs/test-nested-exclude',
      '@vitejs/test-dep-non-optimized',
      '@vitejs/test-dep-esm-external',
      'stream',
    ],
    esbuildOptions: {
      plugins: [
        {
          name: 'replace-a-file',
          setup(build) {
            build.onLoad(
              { filter: /dep-esbuild-plugin-transform(\\|\/)index\.js$/ },
              () => ({
                contents: `export const hello = () => 'Hello from an esbuild plugin'`,
                loader: 'js',
              }),
            )
          },
        },
      ],
    },
    entries: ['index.html', 'unused-split-entry.js'],
  },

  build: {
    // to make tests faster
    minify: false,
    rollupOptions: {
      onwarn(msg, warn) {
        // filter `"Buffer" is not exported by "__vite-browser-external"` warning
        if (msg.message.includes('Buffer')) return
        warn(msg)
      },
    },
  },

  plugins: [
    testVue(),
    notjs(),
    // for axios request test
    {
      name: 'mock',
      configureServer({ middlewares }) {
        middlewares.use('/ping', (_, res) => {
          res.statusCode = 200
          res.end('pong')
        })
      },
      configurePreviewServer({ middlewares }) {
        middlewares.use('/ping', (_, res) => {
          res.statusCode = 200
          res.end('pong')
        })
      },
    },
    {
      name: 'test-astro',
      transform(code, id) {
        if (id.endsWith('.astro')) {
          code = `export default {}`
          return { code }
        }
      },
    },
    // TODO: Remove this one support for prebundling in build lands.
    // It is expected that named importing in build doesn't work
    // as it incurs a lot of overhead in build.
    {
      name: 'polyfill-named-fs-build',
      apply: 'build',
      enforce: 'pre',
      load(id) {
        if (id === '__vite-browser-external') {
          return `export default {}; export function readFileSync() {}`
        }
      },
    },
  ],
})

// Handles Test.vue in dep-linked-include package
function testVue() {
  return {
    name: 'testvue',
    transform(code, id) {
      if (id.includes('dep-linked-include/Test.vue')) {
        return {
          code: `
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'Test',
  render() {
    return '[success] rendered from Vue'
  }
})
`.trim(),
        }
      }

      // fallback to empty module for other vue files
      if (id.endsWith('.vue')) {
        return { code: `export default {}` }
      }
    },
  }
}

// Handles .notjs file, basically remove wrapping <notjs> and </notjs> tags
function notjs() {
  return {
    name: 'notjs',
    config() {
      return {
        optimizeDeps: {
          extensions: ['.notjs'],
          esbuildOptions: {
            plugins: [
              {
                name: 'esbuild-notjs',
                setup(build) {
                  build.onLoad({ filter: /\.notjs$/ }, ({ path }) => {
                    let contents = fs.readFileSync(path, 'utf-8')
                    contents = contents
                      .replace('<notjs>', '')
                      .replace('</notjs>', '')
                    return { contents, loader: 'js' }
                  })
                },
              },
            ],
          },
        },
      }
    },
    transform(code, id) {
      if (id.endsWith('.notjs')) {
        code = code.replace('<notjs>', '').replace('</notjs>', '')
        return { code }
      }
    },
  }
}



================================================
FILE: playground/optimize-deps/__tests__/optimize-deps.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import {
  browserErrors,
  browserLogs,
  getColor,
  isBuild,
  isServe,
  page,
  readDepOptimizationMetadata,
  serverLogs,
  viteTestUrl,
} from '~utils'

test('default + named imports from cjs dep (react)', async () => {
  await expect.poll(() => page.textContent('.cjs button')).toBe('count is 0')
  await page.click('.cjs button')
  await expect.poll(() => page.textContent('.cjs button')).toBe('count is 1')
})

test('named imports from webpacked cjs (phoenix)', async () => {
  await expect.poll(() => page.textContent('.cjs-phoenix')).toBe('ok')
})

test('default import from webpacked cjs (clipboard)', async () => {
  await expect.poll(() => page.textContent('.cjs-clipboard')).toBe('ok')
})

test('default import from cjs (cjs-dep-cjs-compiled-from-esm)', async () => {
  await expect
    .poll(() => page.textContent('.cjs-dep-cjs-compiled-from-esm'))
    .toBe('ok')
})

test('default import from cjs (cjs-dep-cjs-compiled-from-cjs)', async () => {
  await expect
    .poll(() => page.textContent('.cjs-dep-cjs-compiled-from-cjs'))
    .toBe('ok')
})

test('dynamic imports from cjs dep (react)', async () => {
  await expect
    .poll(() => page.textContent('.cjs-dynamic button'))
    .toBe('count is 0')
  await page.click('.cjs-dynamic button')
  await expect
    .poll(() => page.textContent('.cjs-dynamic button'))
    .toBe('count is 1')
})

test('dynamic named imports from webpacked cjs (phoenix)', async () => {
  await expect.poll(() => page.textContent('.cjs-dynamic-phoenix')).toBe('ok')
})

test('dynamic default import from webpacked cjs (clipboard)', async () => {
  await expect.poll(() => page.textContent('.cjs-dynamic-clipboard')).toBe('ok')
})

test('dynamic default import from cjs (cjs-dynamic-dep-cjs-compiled-from-esm)', async () => {
  await expect
    .poll(() => page.textContent('.cjs-dynamic-dep-cjs-compiled-from-esm'))
    .toBe('ok')
})

test('dynamic default import from cjs (cjs-dynamic-dep-cjs-compiled-from-cjs)', async () => {
  await expect
    .poll(() => page.textContent('.cjs-dynamic-dep-cjs-compiled-from-cjs'))
    .toBe('ok')
})

test('dedupe', async () => {
  await expect.poll(() => page.textContent('.dedupe button')).toBe('count is 0')
  await page.click('.dedupe button')
  await expect.poll(() => page.textContent('.dedupe button')).toBe('count is 1')
})

test('cjs browser field (axios)', async () => {
  await expect.poll(() => page.textContent('.cjs-browser-field')).toBe('pong')
})

test('cjs browser field bare', async () => {
  await expect
    .poll(() => page.textContent('.cjs-browser-field-bare'))
    .toBe('pong')
})

test('dep from linked dep (lodash-es)', async () => {
  await expect.poll(() => page.textContent('.deps-linked')).toBe('fooBarBaz')
})

test('forced include', async () => {
  await expect
    .poll(() => page.textContent('.force-include'))
    .toMatch(`[success]`)
})

test('import * from optimized dep', async () => {
  await expect.poll(() => page.textContent('.import-star')).toMatch(`[success]`)
})

test('import from dep with process.env.NODE_ENV', async () => {
  await expect
    .poll(() => page.textContent('.node-env'))
    .toMatch(isBuild ? 'prod' : 'dev')
})

test('import from dep with .notjs files', async () => {
  await expect.poll(() => page.textContent('.not-js')).toMatch(`[success]`)
})

test('Import from dependency which uses relative path which needs to be resolved by main field', async () => {
  await expect
    .poll(() => page.textContent('.relative-to-main'))
    .toMatch(`[success]`)
})

test('dep with dynamic import', async () => {
  await expect
    .poll(() => page.textContent('.dep-with-dynamic-import'))
    .toMatch(`[success]`)
})

test('dep with optional peer dep', async () => {
  await expect
    .poll(() => page.textContent('.dep-with-optional-peer-dep'))
    .toMatch(`[success]`)
  await expect
    .poll(() => page.textContent('.dep-with-optional-peer-dep-error'))
    .toMatch(`[success]`)
})

test('dep with optional peer dep submodule', async () => {
  await expect
    .poll(() => page.textContent('.dep-with-optional-peer-dep-submodule'))
    .toMatch(`[success]`)
  await expect
    .poll(() => page.textContent('.dep-with-optional-peer-dep-submodule-error'))
    .toMatch(`[success]`)
})

test('dep with optional peer dep (cjs)', async () => {
  await expect
    .poll(() => page.textContent('.dep-with-optional-peer-dep-cjs'))
    .toMatch(`[success]`)
  // FIXME
  // await expect
  //   .poll(() => page.textContent('.dep-with-optional-peer-dep-cjs-error'))
  //   .toMatch(`[success]`)
})

test('dep with css import', async () => {
  await expect.poll(() => getColor('.dep-linked-include')).toBe('red')
})

test('CJS dep with css import', async () => {
  await expect.poll(() => getColor('.cjs-with-assets')).toBe('blue')
})

test('externalize known non-js files in optimize included dep', async () => {
  await expect
    .poll(() => page.textContent('.externalize-known-non-js'))
    .toMatch(`[success]`)
})

test('vue + vuex', async () => {
  await expect.poll(() => page.textContent('.vue')).toMatch(`[success]`)
})

// When we use the Rollup CommonJS plugin instead of esbuild prebundling,
// the esbuild plugins won't apply to dependencies
test.runIf(isServe)('esbuild-plugin', async () => {
  await expect
    .poll(() => page.textContent('.esbuild-plugin'))
    .toMatch(`Hello from an esbuild plugin`)
})

test('import from hidden dir', async () => {
  await expect.poll(() => page.textContent('.hidden-dir')).toBe('hello!')
})

test('import optimize-excluded package that imports optimized-included package', async () => {
  await expect
    .poll(() => page.textContent('.nested-include'))
    .toBe('nested-include')
})

test('import aliased package with colon', async () => {
  await expect.poll(() => page.textContent('.url')).toBe('vite.dev')
})

test('import aliased package using absolute path', async () => {
  await expect
    .poll(() => page.textContent('.alias-using-absolute-path'))
    .toBe('From dep-alias-using-absolute-path')
})

test('variable names are reused in different scripts', async () => {
  await expect
    .poll(() => page.textContent('.reused-variable-names'))
    .toBe('reused')
})

test('flatten id should generate correctly', async () => {
  await expect
    .poll(() => page.textContent('.clonedeep-slash'))
    .toBe('clonedeep-slash')
  await expect
    .poll(() => page.textContent('.clonedeep-dot'))
    .toBe('clonedeep-dot')
})

test('non optimized module is not duplicated', async () => {
  await expect
    .poll(() => page.textContent('.non-optimized-module-is-not-duplicated'))
    .toBe('from-absolute-path, from-relative-path')
})

test.runIf(isServe)('error on builtin modules usage', () => {
  expect(browserLogs).toEqual(
    expect.arrayContaining([
      // from dep-with-builtin-module-esm
      expect.stringMatching(/dep-with-builtin-module-esm.*is not a function/),
      // dep-with-builtin-module-esm warnings
      expect.stringContaining(
        'Module "fs" has been externalized for browser compatibility. Cannot access "fs.readFileSync" in client code.',
      ),
      expect.stringContaining(
        'Module "path" has been externalized for browser compatibility. Cannot access "path.join" in client code.',
      ),
      // from dep-with-builtin-module-cjs
      expect.stringMatching(/dep-with-builtin-module-cjs.*is not a function/),
      // dep-with-builtin-module-cjs warnings
      expect.stringContaining(
        'Module "fs" has been externalized for browser compatibility. Cannot access "fs.readFileSync" in client code.',
      ),
      expect.stringContaining(
        'Module "path" has been externalized for browser compatibility. Cannot access "path.join" in client code.',
      ),
    ]),
  )

  expect(browserErrors.map((error) => error.message)).toEqual(
    expect.arrayContaining([
      // from user source code
      expect.stringContaining(
        'Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.Buffer" in client code.',
      ),
      expect.stringContaining(
        'Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.execSync" in client code.',
      ),
    ]),
  )
})

test('pre bundle css require', async () => {
  if (isServe) {
    const response = page.waitForResponse(/@vitejs_test-dep-css-require\.js/)
    await page.goto(viteTestUrl)
    const content = await (await response).text()
    expect(content).toMatch(
      /import\s"\/@fs.+@vitejs\/test-dep-css-require\/style\.css"/,
    )
  }

  await expect.poll(() => getColor('.css-require')).toBe('red')
  await expect.poll(() => getColor('.css-module-require')).toBe('red')
})

test.runIf(isBuild)('no missing deps during build', async () => {
  serverLogs.forEach((log) => {
    // no warning from esbuild css minifier
    expect(log).not.toMatch('Missing dependency found after crawling ended')
  })
})

test('name file limit is 170 characters', async () => {
  if (isServe) {
    const response = page.waitForResponse(
      /@vitejs_longfilename-\w+_[a-zA-Z\d]+\.js\?v=[a-zA-Z\d]+/,
    )
    await page.goto(viteTestUrl)
    const content = await response

    const fromUrl = content.url()
    const stripFolderPart = fromUrl.split('/').at(-1)
    const onlyTheFilePart = stripFolderPart.split('.')[0]
    expect(onlyTheFilePart).toHaveLength(170)
  }
})

describe.runIf(isServe)('optimizeDeps config', () => {
  test('supports include glob syntax', () => {
    const metadata = readDepOptimizationMetadata()
    expect(Object.keys(metadata.optimized)).to.include.members([
      '@vitejs/test-dep-optimize-exports-with-glob',
      '@vitejs/test-dep-optimize-exports-with-glob/named',
      '@vitejs/test-dep-optimize-exports-with-glob/glob-dir/foo',
      '@vitejs/test-dep-optimize-exports-with-glob/glob-dir/bar',
      '@vitejs/test-dep-optimize-exports-with-glob/glob-dir/nested/baz',
      '@vitejs/test-dep-optimize-exports-with-root-glob',
      '@vitejs/test-dep-optimize-exports-with-root-glob/file1.js',
      '@vitejs/test-dep-optimize-exports-with-root-glob/index.js',
      '@vitejs/test-dep-optimize-exports-with-root-glob/dir/file2.js',
      '@vitejs/test-dep-optimize-with-glob',
      '@vitejs/test-dep-optimize-with-glob/index.js',
      '@vitejs/test-dep-optimize-with-glob/named.js',
      '@vitejs/test-dep-optimize-with-glob/glob/foo.js',
      '@vitejs/test-dep-optimize-with-glob/glob/bar.js',
      '@vitejs/test-dep-optimize-with-glob/glob/nested/baz.js',
    ])
  })
})

test('long file name should work', async () => {
  await expect
    .poll(() => page.textContent('.long-file-name'))
    .toMatch(`hello world`)
})

test.runIf(isServe)('warn on incompatible dependency', () => {
  expect(serverLogs).toContainEqual(
    expect.stringContaining(
      'The dependency might be incompatible with the dep optimizer.',
    ),
  )
})

test('import the CommonJS external package that omits the js suffix', async () => {
  await expect.poll(() => page.textContent('.external-package-js')).toBe('okay')
  await expect
    .poll(() => page.textContent('.external-package-scss-js'))
    .toBe('scss')
  await expect
    .poll(() => page.textContent('.external-package-astro-js'))
    .toBe('astro')
  await expect
    .poll(() => page.textContent('.external-package-tsx-js'))
    .toBe('tsx')
})

test('external package name with asset extension', async () => {
  await expect
    .poll(() => page.textContent('.dep-with-asset-ext-no-dual-package'))
    .toBe('true')
  await expect
    .poll(() => page.textContent('.dep-with-asset-ext-prebundled'))
    .toBe(String(isServe))
})

test('dependency with external sub-dependencies', async () => {
  await expect
    .poll(() => page.textContent('.dep-cjs-with-external-deps-object'))
    .toBe('ok')
  await expect
    .poll(() => page.textContent('.dep-cjs-with-external-deps-node-builtin'))
    .toBe('foo bar')
})



================================================
FILE: playground/optimize-deps/added-in-entries/index.js
================================================
// written in cjs, optimization should convert this to esm
module.exports = 'added-in-entries'



================================================
FILE: playground/optimize-deps/added-in-entries/package.json
================================================
{
  "name": "@vitejs/test-added-in-entries",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-alias-using-absolute-path/index.js
================================================
// Importing a shared dependency used by other modules,
// so dependency optimizer creates a common chunk.
// This is used to setup a test scenario, where dep scanner
// could not determine all of the used dependencies on first
// pass, e.g., a dependency that is aliased using an absolute
// path, in which case it used to trigger unnecessary "full
// reloads" invalidating all modules in a module graph.
const cloneDeep = require('lodash/cloneDeep')

// no-op, using imported module for sake of completeness
module.exports = cloneDeep({
  message: 'From dep-alias-using-absolute-path',
}).message



================================================
FILE: playground/optimize-deps/dep-alias-using-absolute-path/package.json
================================================
{
  "name": "@vitejs/test-dep-alias-using-absolute-path",
  "private": true,
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}



================================================
FILE: playground/optimize-deps/dep-cjs-browser-field-bare/events-shim.js
================================================
module.exports = {
  foo: 'foo',
}



================================================
FILE: playground/optimize-deps/dep-cjs-browser-field-bare/index.js
================================================
'use strict'

const internal = require('./internal')

module.exports = internal



================================================
FILE: playground/optimize-deps/dep-cjs-browser-field-bare/internal.js
================================================
'use strict'

// eslint-disable-next-line n/prefer-node-protocol
const events = require('events')

module.exports = 'foo' in events ? 'pong' : ''



================================================
FILE: playground/optimize-deps/dep-cjs-browser-field-bare/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-browser-field-bare",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "browser": {
    "events": "./events-shim.js"
  }
}



================================================
FILE: playground/optimize-deps/dep-cjs-compiled-from-cjs/index.js
================================================
'use strict'
function foo() {
  return 'foo'
}
foo.bar = 'bar'
module.exports = foo



================================================
FILE: playground/optimize-deps/dep-cjs-compiled-from-cjs/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-compiled-from-cjs",
  "private": true,
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-cjs-compiled-from-esm/index.js
================================================
'use strict'
Object.defineProperty(exports, '__esModule', { value: true })
function foo() {
  return 'foo'
}
exports.default = foo



================================================
FILE: playground/optimize-deps/dep-cjs-compiled-from-esm/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-compiled-from-esm",
  "private": true,
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/index.js
================================================
const { okay } = require('./test.okay')
const { scss } = require('./test.scss')
const { astro } = require('./test.astro')
const { tsx } = require('./test.tsx')

module.exports = { okay, scss, astro, tsx }



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-external-package-omit-js-suffix",
  "private": true,
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/test.astro.js
================================================
function astro() {
  return 'astro'
}

module.exports = { astro }



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/test.okay.js
================================================
function okay() {
  return 'okay'
}

module.exports = { okay }



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/test.scss.js
================================================
function scss() {
  return 'scss'
}

module.exports = { scss }



================================================
FILE: playground/optimize-deps/dep-cjs-external-package-omit-js-suffix/test.tsx.js
================================================
function tsx() {
  return 'tsx'
}

module.exports = { tsx }



================================================
FILE: playground/optimize-deps/dep-cjs-with-assets/foo.css
================================================
.cjs-with-assets {
  color: blue;
}



================================================
FILE: playground/optimize-deps/dep-cjs-with-assets/index.js
================================================
require('./foo.css')

exports.a = 11



================================================
FILE: playground/optimize-deps/dep-cjs-with-assets/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-with-assets",
  "private": true,
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-cjs-with-external-deps/index.js
================================================
// `stream` is used as the package name for `@vitejs/test-dep-esm-dummy-node-builtin` so that it is treated like a Node builtin
// eslint-disable-next-line n/prefer-node-protocol
const externalDummyNodeBuiltin = require('stream')
const external = require('@vitejs/test-dep-esm-external')
// eslint-disable-next-line no-prototype-builtins
const externalResult = external.hasOwnProperty('foo') ? 'ok' : 'error'
const externalDummyNodeBuiltinResult = `${externalDummyNodeBuiltin()} ${externalDummyNodeBuiltin.bar}`
module.exports = { externalResult, externalDummyNodeBuiltinResult }



================================================
FILE: playground/optimize-deps/dep-cjs-with-external-deps/package.json
================================================
{
  "name": "@vitejs/test-dep-cjs-with-external-deps",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-dep-esm-external": "file:../dep-esm-external",
    "stream": "file:../dep-esm-dummy-node-builtin"
  }
}



================================================
FILE: playground/optimize-deps/dep-css-require/index.cjs
================================================
require('./style.css')



================================================
FILE: playground/optimize-deps/dep-css-require/mod.cjs
================================================
const style = require('./mod.module.css')
module.exports = style



================================================
FILE: playground/optimize-deps/dep-css-require/mod.module.css
================================================
.cssModuleRequire {
  color: red;
}



================================================
FILE: playground/optimize-deps/dep-css-require/package.json
================================================
{
  "name": "@vitejs/test-dep-css-require",
  "private": true,
  "version": "0.0.0",
  "main": "index.cjs"
}



================================================
FILE: playground/optimize-deps/dep-css-require/style.css
================================================
.css-require {
  color: red;
}



================================================
FILE: playground/optimize-deps/dep-esbuild-plugin-transform/index.js
================================================
// will be replaced by an esbuild plugin

export const hello = () => `Hello from a package`



================================================
FILE: playground/optimize-deps/dep-esbuild-plugin-transform/package.json
================================================
{
  "name": "@vitejs/test-dep-esbuild-plugin-transform",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-esm-dummy-node-builtin/index.js
================================================
function foo() {
  return 'foo'
}

foo.bar = 'bar'

export const bar = 'bar'

export default foo



================================================
FILE: playground/optimize-deps/dep-esm-dummy-node-builtin/package.json
================================================
{
  "name": "@vitejs/test-dep-esm-dummy-node-builtin",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-esm-external/index.js
================================================
export function foo() {
  return 'foo'
}



================================================
FILE: playground/optimize-deps/dep-esm-external/package.json
================================================
{
  "name": "@vitejs/test-dep-esm-external",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-incompatible/index.js
================================================
const subUrl = new URL('./sub.js', import.meta.url)

export default () => import(subUrl)



================================================
FILE: playground/optimize-deps/dep-incompatible/package.json
================================================
{
  "name": "@vitejs/test-dep-incompatible",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-incompatible/sub.js
================================================
export default 'sub'



================================================
FILE: playground/optimize-deps/dep-linked/index.js
================================================
export * from 'lodash-es'



================================================
FILE: playground/optimize-deps/dep-linked/package.json
================================================
{
  "name": "@vitejs/test-dep-linked",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "lodash-es": "^4.17.21"
  }
}



================================================
FILE: playground/optimize-deps/dep-linked-include/foo.js
================================================
export const msg = '[success] linked force include'



================================================
FILE: playground/optimize-deps/dep-linked-include/index.mjs
================================================
export { msg } from './foo.js'

// test importing node built-ins
import fs from 'node:fs'

import { useState } from 'react'

export function useCount() {
  return useState(0)
}

// test dep with css/asset imports
import './test.css'

if (false) {
  fs.readFileSync()
} else {
  console.log('ok')
}

export { default as VueSFC } from './Test.vue'



================================================
FILE: playground/optimize-deps/dep-linked-include/package.json
================================================
{
  "name": "@vitejs/test-dep-linked-include",
  "private": true,
  "version": "0.0.0",
  "main": "index.mjs",
  "dependencies": {
    "react": "19.1.1"
  }
}



================================================
FILE: playground/optimize-deps/dep-linked-include/test.css
================================================
.dep-linked-include {
  color: red;
}



================================================
FILE: playground/optimize-deps/dep-linked-include/Test.vue
================================================
<template>[success] rendered from Vue</template>



================================================
FILE: playground/optimize-deps/dep-node-env/index.js
================================================
export const env = process.env.NODE_ENV === 'production' ? 'prod' : 'dev'



================================================
FILE: playground/optimize-deps/dep-node-env/package.json
================================================
{
  "name": "@vitejs/test-dep-node-env",
  "private": true,
  "version": "1.0.0",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-non-optimized/index.js
================================================
// Scheme check that imports from different paths are resolved to the same module
const messages = []
export const add = (message) => {
  messages.push(message)
}
export const get = () => messages



================================================
FILE: playground/optimize-deps/dep-non-optimized/package.json
================================================
{
  "name": "@vitejs/test-dep-non-optimized",
  "private": true,
  "version": "1.0.0",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-not-js/foo.js
================================================
export const foo = '[success] imported from .notjs file'



================================================
FILE: playground/optimize-deps/dep-not-js/index.notjs
================================================
<notjs>
import { foo } from './foo'
export const notjsValue = foo
</notjs>



================================================
FILE: playground/optimize-deps/dep-not-js/package.json
================================================
{
  "name": "@vitejs/test-dep-not-js",
  "private": true,
  "version": "1.0.0",
  "main": "index.notjs"
}



================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/index.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/named.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/package.json
================================================
{
  "name": "@vitejs/test-dep-optimize-exports-with-glob",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "exports": {
    ".": "./index.js",
    "./named": "./named.js",
    "./glob-dir/*": "./glob/*.js"
  }
}



================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/glob/bar.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/glob/foo.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-glob/glob/nested/baz.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-root-glob/file1.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-root-glob/index.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-root-glob/package.json
================================================
{
  "name": "@vitejs/test-dep-optimize-exports-with-root-glob",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "exports": {
    ".": "./index.js",
    "./*": "./*"
  }
}



================================================
FILE: playground/optimize-deps/dep-optimize-exports-with-root-glob/dir/file2.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/index.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/named.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/package.json
================================================
{
  "name": "@vitejs/test-dep-optimize-with-glob",
  "private": true,
  "version": "1.0.0",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/glob/bar.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/glob/foo.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-optimize-with-glob/glob/nested/baz.js
================================================
[Empty file]


================================================
FILE: playground/optimize-deps/dep-relative-to-main/entry.js
================================================
module.exports = require('./')



================================================
FILE: playground/optimize-deps/dep-relative-to-main/package.json
================================================
{
  "name": "@vitejs/test-dep-relative-to-main",
  "private": true,
  "version": "1.0.0",
  "main": "lib/main.js"
}



================================================
FILE: playground/optimize-deps/dep-relative-to-main/lib/main.js
================================================
module.exports = '[success] imported from main'



================================================
FILE: playground/optimize-deps/dep-source-map-no-sources/all.js
================================================
export const all = 'all'
export { sub } from './sub.js'



================================================
FILE: playground/optimize-deps/dep-source-map-no-sources/package.json
================================================
{
  "name": "@vitejs/test-dep-source-map-no-sources",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "exports": {
    "./*": "./*"
  }
}



================================================
FILE: playground/optimize-deps/dep-source-map-no-sources/sub.js
================================================
export const sub = 'sub'



================================================
FILE: playground/optimize-deps/dep-with-asset-ext/dep1/index.mjs
================================================
export default { random: Math.random() }

export const isPreBundled = import.meta.url.includes('/.vite/deps/')



================================================
FILE: playground/optimize-deps/dep-with-asset-ext/dep1/package.json
================================================
{
  "name": "@vitejs/test-dep-with-asset-ext1.pdf",
  "private": true,
  "type": "module",
  "exports": "./index.mjs"
}



================================================
FILE: playground/optimize-deps/dep-with-asset-ext/dep2/index.js
================================================
export { default } from '@vitejs/test-dep-with-asset-ext1.pdf'



================================================
FILE: playground/optimize-deps/dep-with-asset-ext/dep2/package.json
================================================
{
  "name": "@vitejs/test-dep-with-asset-ext2.pdf",
  "private": true,
  "type": "module",
  "exports": "./index.js",
  "dependencies": {
    "@vitejs/test-dep-with-asset-ext1.pdf": "file:../dep1"
  }
}



================================================
FILE: playground/optimize-deps/dep-with-builtin-module-cjs/index.js
================================================
// no node: protocol intentionally
// eslint-disable-next-line n/prefer-node-protocol
const fs = require('fs')
// eslint-disable-next-line n/prefer-node-protocol
const path = require('path')

// NOTE: require destructure would error immediately because of how esbuild
// compiles it. There's no way around it as it's direct property access, which
// triggers the Proxy get trap.

// access from default import
try {
  path.join()
} catch (e) {
  console.log('dep-with-builtin-module-cjs', e)
}

// access from function
module.exports.read = () => {
  return fs.readFileSync('test')
}



================================================
FILE: playground/optimize-deps/dep-with-builtin-module-cjs/package.json
================================================
{
  "name": "@vitejs/test-dep-with-builtin-module-cjs",
  "private": true,
  "version": "0.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-with-builtin-module-esm/index.js
================================================
// no node: protocol intentionally
// eslint-disable-next-line n/prefer-node-protocol
import { readFileSync } from 'fs'
// eslint-disable-next-line n/prefer-node-protocol
import path from 'path'

// access from named import
try {
  readFileSync()
} catch (e) {
  console.log('dep-with-builtin-module-esm', e)
}

// access from default import
try {
  path.join()
} catch (e) {
  console.log('dep-with-builtin-module-esm', e)
}

// access from function
export function read() {
  return readFileSync('test')
}



================================================
FILE: playground/optimize-deps/dep-with-builtin-module-esm/package.json
================================================
{
  "name": "@vitejs/test-dep-with-builtin-module-esm",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/dep-with-dynamic-import/dynamic.js
================================================
export const foo = '[success] dependency with dynamic import'



================================================
FILE: playground/optimize-deps/dep-with-dynamic-import/index.js
================================================
export const lazyFoo = async function () {
  const { foo } = await import('./dynamic.js')
  return foo
}



================================================
FILE: playground/optimize-deps/dep-with-dynamic-import/package.json
================================================
{
  "name": "@vitejs/test-dep-with-dynamic-import",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep/index.js
================================================
export function callItself() {
  return '[success]'
}

export async function callPeerDep() {
  return await import('foobar')
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep/package.json
================================================
{
  "name": "@vitejs/test-dep-with-optional-peer-dep",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module",
  "peerDependencies": {
    "foobar": "0.0.0"
  },
  "peerDependenciesMeta": {
    "foobar": {
      "optional": true
    }
  }
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep-cjs/index.js
================================================
exports.callItself = function () {
  return '[success]'
}

exports.callPeerDep = function () {
  try {
    return require('foobar')
  } catch {
    return 'fallback'
  }
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep-cjs/package.json
================================================
{
  "name": "@vitejs/test-dep-with-optional-peer-dep-cjs",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "peerDependencies": {
    "foobar": "0.0.0"
  },
  "peerDependenciesMeta": {
    "foobar": {
      "optional": true
    }
  }
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep-submodule/index.js
================================================
export function callItself() {
  return '[success]'
}

export async function callPeerDepSubmodule() {
  return await import('foobar/baz')
}



================================================
FILE: playground/optimize-deps/dep-with-optional-peer-dep-submodule/package.json
================================================
{
  "name": "@vitejs/test-dep-with-optional-peer-dep-submodule",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module",
  "peerDependencies": {
    "foobar": "0.0.0"
  },
  "peerDependenciesMeta": {
    "foobar": {
      "optional": true
    }
  }
}



================================================
FILE: playground/optimize-deps/glob/foo.js
================================================
import axios from 'axios'

axios.get('/ping').then((res) => {
  document.querySelector('.cjs-browser-field').textContent = res.data
})



================================================
FILE: playground/optimize-deps/longfilename/index.js
================================================
const test = 'hello world'

export default test



================================================
FILE: playground/optimize-deps/longfilename/package.json
================================================
{
  "name": "@vitejs/longfilename-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module"
}



================================================
FILE: playground/optimize-deps/nested-exclude/index.js
================================================
export { default as nestedInclude } from '@vitejs/test-nested-include'

export default 'nested-exclude'



================================================
FILE: playground/optimize-deps/nested-exclude/package.json
================================================
{
  "name": "@vitejs/test-nested-exclude",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-nested-include": "file:../nested-include"
  }
}



================================================
FILE: playground/optimize-deps/nested-include/index.js
================================================
// written in cjs, optimization should convert this to esm
module.exports = 'nested-include'



================================================
FILE: playground/optimize-deps/nested-include/package.json
================================================
{
  "name": "@vitejs/test-nested-include",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-deps/non-optimizable-include/index.css
================================================
@font-face {
  font-family: 'Not Real Sans';
  src: url('./i-throw-if-you-optimize-this-file.woff') format('woff');
}



================================================
FILE: playground/optimize-deps/non-optimizable-include/package.json
================================================
{
  "name": "@vitejs/test-non-optimizable-include",
  "private": true,
  "type": "module",
  "version": "0.0.0",
  "exports": {
    ".": "./index.css"
  }
}



================================================
FILE: playground/optimize-deps/.hidden-dir/foo.js
================================================
export const greeting = 'hello!'



================================================
FILE: playground/optimize-deps-no-discovery/index.html
================================================
<h1>Optimize Deps</h1>

<h2>Optimized Dep</h2>
<div class="optimized-dep"></div>

<h2>Vue & Vuex</h2>
<div class="vue"></div>

<script>
  function text(el, text) {
    document.querySelector(el).textContent = text
  }
</script>

<script type="module">
  import msg from '@vitejs/test-dep-no-discovery'
  text('.optimized-dep', msg)

  import { createApp } from 'vue'
  import { createStore } from 'vuex'
  if (typeof createApp === 'function' && typeof createStore === 'function') {
    text('.vue', '[success]')
  }
</script>



================================================
FILE: playground/optimize-deps-no-discovery/package.json
================================================
{
  "name": "@vitejs/test-optimize-deps-no-discovery",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-dep-no-discovery": "file:./dep-no-discovery",
    "vue": "^3.5.18",
    "vuex": "^4.1.0"
  }
}



================================================
FILE: playground/optimize-deps-no-discovery/vite.config.js
================================================
import { defineConfig } from 'vite'

// Overriding the NODE_ENV set by vitest
process.env.NODE_ENV = ''

export default defineConfig({
  optimizeDeps: {
    noDiscovery: true,
    include: ['@vitejs/test-dep-no-discovery'],
  },

  build: {
    // to make tests faster
    minify: false,
  },
})



================================================
FILE: playground/optimize-deps-no-discovery/__tests__/optimize-deps-no-discovery.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page, readDepOptimizationMetadata } from '~utils'

test('optimized dep', async () => {
  expect(await page.textContent('.optimized-dep')).toBe('[success]')
})

test('vue + vuex', async () => {
  expect(await page.textContent('.vue')).toMatch(`[success]`)
})

test.runIf(!isBuild)('metadata', async () => {
  const meta = readDepOptimizationMetadata()
  expect(Object.keys(meta.optimized)).toContain('@vitejs/test-dep-no-discovery')
  expect(Object.keys(meta.optimized)).not.toContain('vue')
  expect(Object.keys(meta.optimized)).not.toContain('vuex')
})



================================================
FILE: playground/optimize-deps-no-discovery/dep-no-discovery/index.js
================================================
// written in cjs, optimization should convert this to esm
module.exports = '[success]'



================================================
FILE: playground/optimize-deps-no-discovery/dep-no-discovery/package.json
================================================
{
  "name": "@vitejs/test-dep-no-discovery",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/optimize-missing-deps/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <!--app-html-->
  </body>
</html>



================================================
FILE: playground/optimize-missing-deps/main.js
================================================
import { sayName } from '@vitejs/test-missing-dep'

export const name = sayName()



================================================
FILE: playground/optimize-missing-deps/package.json
================================================
{
  "name": "@vitejs/test-optimize-missing-deps",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server"
  },
  "dependencies": {
    "@vitejs/test-missing-dep": "file:./missing-dep"
  },
  "devDependencies": {
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/optimize-missing-deps/server.js
================================================
// @ts-check
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const isTest = process.env.VITEST

export async function createServer(root = process.cwd(), hmrPort) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    server: {
      middlewareMode: true,
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
  })
  app.use(vite.middlewares)

  app.use('*all', async (req, res) => {
    try {
      let template = fs.readFileSync(resolve('index.html'), 'utf-8')
      template = await vite.transformIndexHtml(req.originalUrl, template)

      // `main.js` imports dependencies that are yet to be discovered and optimized, aka "missing" deps.
      // Loading `main.js` in SSR should not trigger optimizing the "missing" deps
      const { name } = await vite.ssrLoadModule('./main.js')

      // Loading `main.js` in the client should trigger optimizing the "missing" deps
      const appHtml = `<div id="app">${name}</div>
<script type='module'>
  import { name } from './main.js'
  document.getElementById('app').innerText = name
</script>`

      const html = template.replace(`<!--app-html-->`, appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/optimize-missing-deps/__test__/optimize-missing-deps.spec.ts
================================================
import { expect, test } from 'vitest'
import { port } from './serve'
import { isBuild, page } from '~utils'

const url = `http://localhost:${port}/`

test.runIf(!isBuild)('optimize', async () => {
  await page.goto(url)
  // reload page to get optimized missing deps
  await page.reload()
  await expect.poll(() => page.textContent('div')).toMatch('Client')

  // raw http request
  const aboutHtml = await (await fetch(url)).text()
  expect(aboutHtml).toContain('Server')
})



================================================
FILE: playground/optimize-missing-deps/__test__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import { hmrPorts, ports, rootDir } from '~utils'

export const port = ports['optimize-missing-deps']

export async function serve(): Promise<{ close(): Promise<void> }> {
  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(
    rootDir,
    hmrPorts['optimize-missing-deps'],
  )

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/optimize-missing-deps/missing-dep/index.js
================================================
import { name } from '@vitejs/test-multi-entry-dep'

export function sayName() {
  return name
}



================================================
FILE: playground/optimize-missing-deps/missing-dep/package.json
================================================
{
  "name": "@vitejs/test-missing-dep",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-multi-entry-dep": "file:../multi-entry-dep"
  }
}



================================================
FILE: playground/optimize-missing-deps/multi-entry-dep/index.browser.js
================================================
exports.name = 'Client'



================================================
FILE: playground/optimize-missing-deps/multi-entry-dep/index.js
================================================
const path = require('node:path')

exports.name = path.normalize('./Server')



================================================
FILE: playground/optimize-missing-deps/multi-entry-dep/package.json
================================================
{
  "name": "@vitejs/test-multi-entry-dep",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "browser": {
    "./index.js": "./index.browser.js"
  }
}



================================================
FILE: playground/preload/index.html
================================================
<h1>preload</h1>
<div class="chunk"></div>
<div id="hello">
  <button class="load">Load hello</button>
  <div class="msg"></div>
</div>
<div id="about">
  <button class="load">Load about</button>
  <div class="msg"></div>
</div>

<script type="module">
  import { msgFromA } from '@vitejs/test-dep-a'
  console.log(msgFromA)

  import './src/main.js'
  document
    .querySelector('h1')
    .insertAdjacentHTML('afterEnd', '<div id="done">ran js</div>')
</script>



================================================
FILE: playground/preload/package.json
================================================
{
  "name": "@vitejs/test-preload",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview",
    "dev:resolve-deps": "vite --config vite.config-resolve-deps.js",
    "build:resolve-deps": "vite build --config vite.config-resolve-deps.js",
    "debug:resolve-deps": "node --inspect-brk ../../packages/vite/bin/vite --config vite.config-resolve-deps.js",
    "preview:resolve-deps": "vite preview --config vite.config-resolve-deps.js",
    "dev:preload-disabled": "vite --config vite.config-preload-disabled.js",
    "build:preload-disabled": "vite build --config vite.config-preload-disabled.js",
    "debug:preload-disabled": "node --inspect-brk ../../packages/vite/bin/vite --config vite.config-preload-disabled.js",
    "preview:preload-disabled": "vite preview --config vite.config-preload-disabled.js"
  },
  "devDependencies": {
    "terser": "^5.43.1",
    "@vitejs/test-dep-a": "file:./dep-a",
    "@vitejs/test-dep-including-a": "file:./dep-including-a"
  }
}



================================================
FILE: playground/preload/vite.config-preload-disabled.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: 'dist/preload-disabled',
    minify: 'terser',
    terserOptions: {
      format: {
        beautify: true,
      },
      compress: {
        passes: 3,
      },
    },
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('chunk.js')) {
            return 'chunk'
          }
        },
      },
    },
    modulePreload: false,
  },
  cacheDir: 'node_modules/.vite-preload-disabled',
})



================================================
FILE: playground/preload/vite.config-resolve-deps.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: 'dist/resolve-deps',
    minify: 'terser',
    terserOptions: {
      format: {
        beautify: true,
      },
      compress: {
        passes: 3,
      },
    },
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('chunk.js')) {
            return 'chunk'
          }
        },
      },
    },
    modulePreload: {
      resolveDependencies(filename, deps, { hostId, hostType }) {
        if (filename.includes('hello')) {
          return [...deps, 'preloaded.js']
        }
        return deps
      },
    },
  },
  experimental: {
    renderBuiltUrl(filename, { hostId, hostType }) {
      if (filename.includes('preloaded')) {
        return { runtime: `""+${JSON.stringify('/' + filename)}` }
      }
      return { relative: true }
    },
  },
  cacheDir: 'node_modules/.vite-resolve-deps',
})



================================================
FILE: playground/preload/vite.config.ts
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    outDir: 'dist/normal',
    minify: 'terser',
    terserOptions: {
      format: {
        beautify: true,
      },
      compress: {
        passes: 3,
      },
    },
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('chunk.js')) {
            return 'chunk'
          }
        },
      },
    },
  },
})



================================================
FILE: playground/preload/__tests__/preload.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { browserLogs, isBuild, page } from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe.runIf(isBuild)('build', () => {
  test('dynamic import', async () => {
    await page.waitForSelector('#done')
    expect(await page.textContent('#done')).toBe('ran js')
  })

  test('dynamic import with comments', async () => {
    await page.click('#hello .load')
    await page.waitForSelector('#hello output')

    const html = await page.content()
    expect(html).toMatch(
      /link rel="modulepreload".*?href=".*?\/assets\/hello-[-\w]{8}\.js"/,
    )
    expect(html).toMatch(
      /link rel="stylesheet".*?href=".*?\/assets\/hello-[-\w]{8}\.css"/,
    )
  })
})



================================================
FILE: playground/preload/__tests__/preload-disabled/preload-disabled.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { browserLogs, isBuild, page } from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe.runIf(isBuild)('build', () => {
  test('dynamic import', async () => {
    await page.waitForSelector('#done')
    expect(await page.textContent('#done')).toBe('ran js')
  })

  test('dynamic import with comments', async () => {
    await page.click('#hello .load')
    await page.waitForSelector('#hello output')

    const html = await page.content()
    expect(html).not.toMatch(/link rel="modulepreload"/)

    expect(html).toMatch(
      /link rel="stylesheet".*?href=".*?\/assets\/hello-[-\w]{8}\.css"/,
    )
  })
})



================================================
FILE: playground/preload/__tests__/resolve-deps/preload-resolve-deps.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { browserLogs, isBuild, page } from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

describe.runIf(isBuild)('build', () => {
  test('dynamic import', async () => {
    await page.waitForSelector('#done')
    expect(await page.textContent('#done')).toBe('ran js')
  })

  test('dynamic import with comments', async () => {
    await page.click('#hello .load')
    await page.waitForSelector('#hello output')

    const html = await page.content()
    expect(html).toMatch(
      /link rel="modulepreload".*?href="http.*?\/hello-[-\w]{8}\.js"/,
    )
    expect(html).toMatch(
      /link rel="modulepreload".*?href="http.*?\/preloaded.js"/,
    )
    expect(html).toMatch(
      /link rel="stylesheet".*?href="http.*?\/hello-[-\w]{8}\.css"/,
    )
  })
})



================================================
FILE: playground/preload/dep-a/index.js
================================================
export const msgFromA = 'From dep-a'



================================================
FILE: playground/preload/dep-a/package.json
================================================
{
  "name": "@vitejs/test-dep-a",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/preload/dep-including-a/index.js
================================================
export { msgFromA } from '@vitejs/test-dep-a'

export const msg = 'From dep-including-a'



================================================
FILE: playground/preload/dep-including-a/package.json
================================================
{
  "name": "@vitejs/test-dep-including-a",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-dep-a": "file:../dep-a"
  }
}



================================================
FILE: playground/preload/public/preloaded.js
================================================
console.log('preloaded')



================================================
FILE: playground/preload/src/about.js
================================================
import { msg } from '@vitejs/test-dep-including-a'

document.querySelector('#about .msg').textContent = msg



================================================
FILE: playground/preload/src/chunk.js
================================================
export default '[success] message from chunk.js'



================================================
FILE: playground/preload/src/hello.js
================================================
import style from './hello.module.css'

const msg = document.querySelector('#hello .msg')
msg.textContent = 'hello'
msg.classList.add(style.h1)



================================================
FILE: playground/preload/src/hello.module.css
================================================
.h1 {
  color: red;
}



================================================
FILE: playground/preload/src/main.js
================================================
import chunkMsg from './chunk'

document.querySelector('.chunk').textContent = chunkMsg

const ids = {
  hello: async () => {
    await import(/* a comment */ './hello.js')
  },
  about: async () => {
    await import('./about.js') // lazy load
  },
}

for (const [id, loader] of Object.entries(ids)) {
  const loadButton = document.querySelector(`#${id} .load`)
  loadButton.addEventListener('click', async () => {
    await loader()
    loadButton.insertAdjacentHTML('afterend', '<output>loaded</output>')
  })
}



================================================
FILE: playground/preserve-symlinks/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="src/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: playground/preserve-symlinks/package.json
================================================
{
  "name": "@vitejs/test-preserve-symlinks",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --force",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/test-module-a": "link:./module-a"
  }
}



================================================
FILE: playground/preserve-symlinks/__tests__/preserve-symlinks.spec.ts
================================================
import { expect, test } from 'vitest'
import { browserLogs, page } from '~utils'

test('should have no 404s', () => {
  browserLogs.forEach((msg) => {
    expect(msg).not.toMatch('404')
  })
})

test('not-preserve-symlinks', async () => {
  expect(await page.textContent('#root')).toBe('hello vite')
})



================================================
FILE: playground/preserve-symlinks/module-a/package.json
================================================
{
  "name": "@vitejs/test-module-a",
  "private": true,
  "version": "0.0.0",
  "main": "linked.js"
}



================================================
SYMLINK: playground/preserve-symlinks/module-a/linked.js -> index.js
================================================



================================================
FILE: playground/preserve-symlinks/module-a/src/data.js
================================================
export const data = {
  msg: 'hello vite',
}



================================================
FILE: playground/preserve-symlinks/module-a/src/index.js
================================================
import { data } from './data'

export function sayHi() {
  return data
}



================================================
FILE: playground/preserve-symlinks/src/main.js
================================================
import { sayHi } from '@vitejs/test-module-a'

document.getElementById('root').innerText = sayHi().msg



================================================
FILE: playground/proxy-bypass/index.html
================================================
root app<br />
<iframe src="/nonExistentApp" style="border: 0"></iframe>
<iframe src="/asyncResponse" name="async-response"></iframe>
<iframe src="/asyncThrowingError"></iframe>



================================================
FILE: playground/proxy-bypass/package.json
================================================
{
  "name": "@vitejs/test-proxy-bypass",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/proxy-bypass/vite.config.js
================================================
import { defineConfig } from 'vite'

const timeout = (ms) => new Promise((r) => setTimeout(r, ms))

export default defineConfig({
  server: {
    port: 9606,
    proxy: {
      '/nonExistentApp': {
        target: 'http://localhost:9607',
        bypass: () => {
          return false
        },
      },
      '/asyncResponse': {
        bypass: async (_, res) => {
          await timeout(4)
          res.writeHead(200, {
            'Content-Type': 'text/plain',
          })
          res.end('Hello after 4 ms (async timeout)')
          return '/asyncResponse'
        },
      },
      '/asyncThrowingError': {
        bypass: async () => {
          await timeout(4)
          throw new Error('bypass error')
        },
      },
    },
  },
  plugins: [
    {
      name: 'handle-error-in-preview',
      configurePreviewServer({ config, middlewares }) {
        return () => {
          middlewares.use((err, _req, res, _next) => {
            config.logger.error(err.message, { error: err })
            res.statusCode = 500
            res.end()
          })
        }
      },
    },
  ],
})



================================================
FILE: playground/proxy-bypass/__tests__/proxy-bypass.spec.ts
================================================
import { expect, test, vi } from 'vitest'
import { browserLogs, page, serverLogs } from '~utils'

test('proxy-bypass', async () => {
  await vi.waitFor(() => {
    expect(browserLogs.join('\n')).toContain('status of 404 (Not Found)')
  })
})

test('async-proxy-bypass', async () => {
  const content = await page.frame('async-response').content()
  expect(content).toContain('Hello after 4 ms (async timeout)')
})

test('async-proxy-bypass-with-error', async () => {
  await vi.waitFor(() => {
    expect(serverLogs.join('\n')).toContain('bypass error')
  })
})



================================================
FILE: playground/proxy-hmr/index.html
================================================
root app<br />
<iframe src="/anotherApp" style="border: 0"></iframe>



================================================
FILE: playground/proxy-hmr/package.json
================================================
{
  "name": "@vitejs/test-proxy-hmr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/proxy-hmr/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  server: {
    port: 9616,
    proxy: {
      '/anotherApp': {
        target: 'http://localhost:9617',
        ws: true,
      },
    },
  },
})



================================================
FILE: playground/proxy-hmr/__tests__/proxy-hmr.spec.ts
================================================
import { expect, test } from 'vitest'
import {
  editFile,
  isBuild,
  page,
  untilBrowserLogAfter,
  viteTestUrl,
} from '~utils'

test.runIf(!isBuild)('proxy-hmr', async () => {
  await untilBrowserLogAfter(
    () => page.goto(viteTestUrl),
    // wait for both main and sub app HMR connection
    [/connected/, /connected/],
  )

  const otherAppTextLocator = page.frameLocator('iframe').locator('.content')
  await expect
    .poll(() => otherAppTextLocator.textContent())
    .toMatch('other app')
  editFile('other-app/index.html', (code) =>
    code.replace('app', 'modified app'),
  )
  await expect
    .poll(() => otherAppTextLocator.textContent())
    .toMatch('other modified app')
})



================================================
FILE: playground/proxy-hmr/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import { rootDir, setViteUrl } from '~utils'

export async function serve(): Promise<{ close(): Promise<void> }> {
  const vite = await import('vite')
  const rootServer = await vite.createServer({
    root: rootDir,
    logLevel: 'silent',
  })
  const otherServer = await vite.createServer({
    root: path.join(rootDir, 'other-app'),
    logLevel: 'silent',
  })

  await Promise.all([rootServer.listen(), otherServer.listen()])
  const viteUrl = rootServer.resolvedUrls.local[0]
  setViteUrl(viteUrl)

  return {
    async close() {
      await Promise.all([rootServer.close(), otherServer.close()])
    },
  }
}



================================================
FILE: playground/proxy-hmr/other-app/index.html
================================================
<span class="content">other app</span>



================================================
FILE: playground/proxy-hmr/other-app/package.json
================================================
{
  "name": "@vitejs/test-other-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/proxy-hmr/other-app/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  base: '/anotherApp',
  server: {
    port: 9617,
    strictPort: true,
  },
})



================================================
FILE: playground/resolve/absolute.js
================================================
export default '[success] absolute'



================================================
FILE: playground/resolve/config-dep.cjs
================================================
module.exports = {
  a: 1,
}



================================================
FILE: playground/resolve/custom-ext.es
================================================
export const msg = `[success] custom ext`



================================================
FILE: playground/resolve/dir.js
================================================
export const file = '[success] dir.js'



================================================
FILE: playground/resolve/drive-relative.js
================================================
export default '[success] drive relative'



================================================
FILE: playground/resolve/file-url.js
================================================
export default '[success] file-url'



================================================
FILE: playground/resolve/index.html
================================================
<h1>Resolve</h1>

<h2>Utf8-bom import</h2>
<p class="utf8-bom">fail</p>

<h2>Deep import</h2>
<p>Should show [2,4]:<span class="pre deep-import">fail</span></p>

<h2>Exports and a nested package scope with a different type</h2>
<p class="exports-and-nested-scope">fail</p>

<h2>Entry resolving with exports field</h2>
<p class="exports-entry">fail</p>

<h2>Deep import with exports field</h2>
<p class="exports-deep">fail</p>

<h2>Deep import with query with exports field</h2>
<p class="exports-deep-query">fail</p>

<h2>Deep import with exports field + exposed directory</h2>
<p class="exports-deep-exposed-dir">fail</p>

<h2>Deep import with exports field + mapped directory</h2>
<p class="exports-deep-mapped-dir">fail</p>

<h2>Exports field env priority</h2>
<p class="exports-env">fail</p>

<h2>Exports field read only from the root package.json</h2>
<p class="exports-from-root">fail</p>

<h2>Exports with legacy fallback</h2>
<p class="exports-legacy-fallback">fail</p>

<h2>Exports with module</h2>
<p class="exports-with-module">fail</p>

<h2>
  Both import and require resolve using module condition (avoids dual package
  hazard)
</h2>
<p class="exports-with-module-condition">fail</p>
<p class="exports-with-module-condition-required">fail</p>

<h2>Resolving top level with imports field</h2>
<p class="imports-top-level">fail</p>

<h2>Resolving same level with imports field</h2>
<p class="imports-same-level">fail</p>

<h2>Resolving nested path with imports field</h2>
<p class="imports-nested">fail</p>

<h2>Resolving star with imports filed</h2>
<p class="imports-star">fail</p>

<h2>Resolving slash with imports filed</h2>
<p class="imports-slash">fail</p>

<h2>Resolving from other package with imports field</h2>
<p class="imports-pkg-slash">fail</p>

<h2>Resolving with query with imports field</h2>
<p class="imports-query">fail</p>

<h2>Resolve /index.*</h2>
<p class="index">fail</p>

<h2>Resolve dir and file of the same name (should prioritize file)</h2>
<p class="dir-vs-file">fail</p>

<h2>Resolve to non-duplicated file extension</h2>
<p class="exact-extension">fail</p>

<h2>Resolve nested file extension</h2>
<p class="nested-extension">fail</p>

<h2>Don't add extensions to directory names</h2>
<p class="dir-with-ext">fail</p>

<h2>
  A ts module can import another ts module using its corresponding js file name
</h2>
<p class="ts-extension">fail</p>

<h2>
  A ts module can import another tsx module using its corresponding jsx file
  name
</h2>
<p class="jsx-extension">fail</p>

<h2>
  A ts module can import another tsx module using its corresponding js file name
</h2>
<p class="tsx-extension">fail</p>

<h2>
  A ts module can import another ESM module using its corresponding mjs file
  name
</h2>
<p class="mjs-extension">fail</p>

<h2>
  A ts module can import another ESM module using its corresponding mjs file
  name with query parameters
</h2>
<p class="mjs-extension-with-query">fail</p>

<h2>
  A ts module can import another CommonJS module using its corresponding cjs
  file name
</h2>
<p class="cjs-extension">fail</p>

<h2>A js module can import TS modules using its corresponding js file name</h2>
<p class="js-ts-extension">fail</p>

<h2>Resolve file name containing dot</h2>
<p class="dot">fail</p>

<h2>Resolve drive-relative path (Windows only)</h2>
<p class="drive-relative">fail</p>

<h2>Resolve absolute path</h2>
<p class="absolute">fail</p>

<h2>Resolve file url</h2>
<p class="file-url">fail</p>

<h2>Browser Field</h2>
<p class="browser">fail</p>

<h2>Resolve browser field even if module field exists</h2>
<p class="browser-module1">fail</p>

<h2>Resolve module field if browser field is likely UMD or CJS</h2>
<p class="browser-module2">fail</p>

<h2>Resolve module field if browser field is likely IIFE</h2>
<p class="browser-module3">fail</p>

<h2>Don't resolve to the `module` field if the importer is a `require` call</h2>
<p class="require-pkg-with-module-field">fail</p>

<h2>CSS Entry</h2>
<p class="css"></p>

<h2>Monorepo linked dep</h2>
<p class="monorepo"></p>

<h2>Plugin resolved virtual file</h2>
<p class="virtual"></p>

<h2>Plugin resolved virtual file (#9036)</h2>
<p class="virtual-9036"></p>

<h2>Plugin resolved custom virtual file</h2>
<p class="custom-virtual"></p>

<h2>Inline package</h2>
<p class="inline-pkg"></p>

<h2>resolve.extensions</h2>
<p class="custom-ext"></p>

<h2>resolve.mainFields</h2>
<p class="custom-main-fields"></p>

<h2>resolve.mainFields.custom-browser-main</h2>
<p class="custom-browser-main-field"></p>

<h2>resolve.conditions</h2>
<p class="custom-condition"></p>

<h2>resolve package that contains # in path</h2>
<p class="path-contains-sharp-symbol"></p>

<h2>resolve non normalized absolute path</h2>
<p class="non-normalized"></p>

<h2>utf8-bom-package</h2>
<p class="utf8-bom-package">fail</p>

<script type="module">
  import '@generated-content-virtual-file'
  function text(selector, text) {
    document.querySelector(selector).textContent = text
  }

  // import from a utf-8 bom file
  import { msg as bomMsg } from './utf8-bom/main.js'
  text('.utf8-bom', bomMsg)

  // deep import
  import slicedToArray from '@babel/runtime/helpers/esm/slicedToArray'

  const iterable = (function* () {
    yield 2
    yield 4
    yield 6
    yield 8
  })()

  text('.deep-import', JSON.stringify(slicedToArray(iterable, 2)))

  import exportsAndNestedScopeMsg from '@vitejs/test-resolve-exports-and-nested-scope/nested'
  text('.exports-and-nested-scope', exportsAndNestedScopeMsg)

  // exports field
  import { msg } from '@vitejs/test-resolve-exports-path'
  text('.exports-entry', msg)

  // deep import w/ exports
  import { msg as deepMsg } from '@vitejs/test-resolve-exports-path/deep.js'
  text('.exports-deep', deepMsg)

  // deep import w/ exports w/ query
  import deepPath from '@vitejs/test-resolve-exports-path/deep.json?url'
  text('.exports-deep-query', deepPath)

  // deep import w/ exposed dir
  import { msg as exposedDirMsg } from '@vitejs/test-resolve-exports-path/dir/dir'
  text('.exports-deep-exposed-dir', exposedDirMsg)

  // deep import w/ mapped dir
  import { msg as mappedDirMsg } from '@vitejs/test-resolve-exports-path/dir-mapped/dir'
  text('.exports-deep-mapped-dir', mappedDirMsg)

  import { msg as exportsEnvMsg } from '@vitejs/test-resolve-exports-env'
  text('.exports-env', exportsEnvMsg)

  import { msg as exportsFromRootMsg } from '@vitejs/test-resolve-exports-from-root/nested'
  text('.exports-from-root', exportsFromRootMsg)

  import { msg as exportsLegacyFallbackMsg } from '@vitejs/test-resolve-exports-legacy-fallback/dir'
  text('.exports-legacy-fallback', exportsLegacyFallbackMsg)

  import { msg as exportsWithModule } from '@vitejs/test-resolve-exports-with-module'
  text('.exports-with-module', exportsWithModule)

  import { msg as exportsWithModuleCondition } from '@vitejs/test-resolve-exports-with-module-condition'
  import { msg as exportsWithModuleConditionRequired } from '@vitejs/test-resolve-exports-with-module-condition-required'
  text('.exports-with-module-condition', exportsWithModuleCondition)
  text(
    '.exports-with-module-condition-required',
    exportsWithModuleConditionRequired,
  )

  // imports field
  import { msg as importsTopLevel } from '#top-level'
  text('.imports-top-level', importsTopLevel)

  import { msg as importsSameLevel } from '#same-level'
  text('.imports-same-level', importsSameLevel)

  import { msg as importsNested } from '#nested/path.js'
  text('.imports-nested', importsNested)

  import { msg as importsStar } from '#star/index.js'
  text('.imports-star', importsStar)

  import { msg as importsSlash } from '#slash/index.js'
  text('.imports-slash', importsSlash)

  import { msg as importsPkgSlash } from '#other-pkg-slash/index.js'
  text('.imports-pkg-slash', importsPkgSlash)

  import importsQuery from '#query?url'
  text('.imports-query', importsQuery)

  // implicit index resolving
  import { foo } from './util'
  text('.index', foo())

  // implicit dir index vs. file
  import { file } from './dir'
  text('.dir-vs-file', file)

  // exact extension vs. duplicated (.js.js)
  import { file as exactExtMsg } from './exact-extension/file.js'
  text('.exact-extension', exactExtMsg)

  // nested extension
  import { file as fileJsonMsg } from './exact-extension/file.json'
  text('.nested-extension', fileJsonMsg)

  // don't add extensions to dir name (./dir-with-ext.js/index.js)
  import { file as dirWithExtMsg } from './dir-with-ext'
  text('.dir-with-ext', dirWithExtMsg)

  import { msg as tsExtensionMsg } from './ts-extension'
  text('.ts-extension', tsExtensionMsg)

  import { msgJsx as tsJsxExtensionMsg } from './ts-extension'
  text('.jsx-extension', tsJsxExtensionMsg)

  import { msgTsx as tsTsxExtensionMsg } from './ts-extension'
  text('.tsx-extension', tsTsxExtensionMsg)

  import { msgCjs as tsCjsExtensionMsg } from './ts-extension'
  text('.cjs-extension', tsCjsExtensionMsg)

  import { msgMjs as tsMjsExtensionMsg } from './ts-extension'
  text('.mjs-extension', tsMjsExtensionMsg)

  import { msgMjs as tsMjsExtensionWithQueryMsg } from './ts-extension?query=1'
  text('.mjs-extension-with-query', tsMjsExtensionWithQueryMsg)

  import { msg as jsTsExtensionMsg } from './ts-extension/index-js.js'
  text('.js-ts-extension', jsTsExtensionMsg)

  // filename with dot
  import { bar } from './util/bar.util'
  text('.dot', bar())

  // browser field
  import main from '@vitejs/test-resolve-browser-field'

  import a from '@vitejs/test-resolve-browser-field/no-ext'
  import b from '@vitejs/test-resolve-browser-field/no-ext.js' // no substitution
  import c from '@vitejs/test-resolve-browser-field/ext'
  import d from '@vitejs/test-resolve-browser-field/ext.js'
  import e from '@vitejs/test-resolve-browser-field/ext-index/index.js'
  import f from '@vitejs/test-resolve-browser-field/ext-index'
  import g from '@vitejs/test-resolve-browser-field/no-ext-index/index.js' // no substitution
  import h from '@vitejs/test-resolve-browser-field/no-ext?query'
  import i from '@vitejs/test-resolve-browser-field/bare-import'

  import {
    ra,
    rb,
    rc,
    rd,
    re,
    rf,
    rg,
  } from '@vitejs/test-resolve-browser-field/relative'

  const success = [main, a, c, d, e, f, h, i, ra, rc, rd, re, rf]
  const noSuccess = [b, g, rb, rg]

  if (
    [...success, ...noSuccess].filter((text) => text.includes('[success]'))
      .length === success.length
  ) {
    text('.browser', main)
  }

  import browserModule1 from '@vitejs/test-resolve-browser-module-field1'
  text('.browser-module1', browserModule1)

  import browserModule2 from '@vitejs/test-resolve-browser-module-field2'
  text('.browser-module2', browserModule2)

  import browserModule3 from '@vitejs/test-resolve-browser-module-field3'
  text('.browser-module3', browserModule3)

  import { msg as requireButWithModuleFieldMsg } from '@vitejs/test-require-pkg-with-module-field'
  text('.require-pkg-with-module-field', requireButWithModuleFieldMsg)

  import { msg as customExtMsg } from './custom-ext'
  text('.custom-ext', customExtMsg)

  import { msg as customMainMsg } from '@vitejs/test-resolve-custom-main-field'
  text('.custom-main-fields', customMainMsg)

  import { msg as customBrowserMsg } from '@vitejs/test-resolve-custom-browser-main-field'
  text('.custom-browser-main-field', customBrowserMsg)

  import { msg as customConditionMsg } from '@vitejs/test-resolve-custom-condition'
  text('.custom-condition', customConditionMsg)

  // should be ok to import a file marked with browser: false
  import '@vitejs/test-resolve-browser-field/not-browser'
  import '@vitejs/test-resolve-browser-field/multiple.dot.path'

  // css entry
  import css from 'normalize.css?inline'
  if (typeof css === 'string') {
    text('.css', '[success] resolve package with css entry file')
  }

  // monorepo linked dep w/ upper directory import
  import { msg as linkedMsg } from '@vitejs/test-resolve-linked'
  text('.monorepo', linkedMsg)

  import { msg as virtualMsg } from '@virtual-file'
  text('.virtual', virtualMsg)

  import { msg as virtualMsg9036 } from 'virtual:file-9036.js'
  text('.virtual-9036', virtualMsg9036)

  import { msg as customVirtualMsg } from '@custom-virtual-file'
  text('.custom-virtual', customVirtualMsg)

  import { msg as inlineMsg } from './inline-package'
  text('.inline-pkg', inlineMsg)

  import es5Ext from 'es5-ext'
  import contains from 'es5-ext/string/#/contains'
  import { last } from '@vitejs/test-resolve-sharp-dir'

  text(
    '.path-contains-sharp-symbol',
    `[success] ${contains.call('#', '#')} ${last.call('#')}`,
  )

  import nonNormalizedAbsolute from '@non-normalized'
  text('.non-normalized', nonNormalizedAbsolute)

  import { msg as utf8BomPackage } from '@vitejs/test-utf8-bom-package'
  text('.utf8-bom-package', utf8BomPackage)

  import '@vitejs/test-resolve-side-effects-glob'
</script>

<style>
  .pre {
    display: block;
    unicode-bidi: embed;
    font-family: monospace;
    white-space: pre;
  }
</style>



================================================
FILE: playground/resolve/non-normalized.js
================================================
export default '[success] non normalized absolute path'



================================================
FILE: playground/resolve/package.json
================================================
{
  "name": "@vitejs/test-resolve",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "imports": {
    "#top-level": "./imports-path/top-level.js",
    "#same-level": "./imports-path/same-level.js",
    "#nested/path.js": "./imports-path/nested-path.js",
    "#star/*": "./imports-path/star/*",
    "#slash/": "./imports-path/slash/",
    "#other-pkg-slash/": "@vitejs/test-resolve-imports-pkg/nest/",
    "#query": "./imports-path/query.json"
  },
  "dependencies": {
    "@babel/runtime": "^7.28.2",
    "es5-ext": "0.10.64",
    "normalize.css": "^8.0.1",
    "@vitejs/test-require-pkg-with-module-field": "link:./require-pkg-with-module-field",
    "@vitejs/test-resolve-browser-field": "link:./browser-field",
    "@vitejs/test-resolve-browser-module-field1": "link:./browser-module-field1",
    "@vitejs/test-resolve-browser-module-field2": "link:./browser-module-field2",
    "@vitejs/test-resolve-browser-module-field3": "link:./browser-module-field3",
    "@vitejs/test-resolve-custom-condition": "link:./custom-condition",
    "@vitejs/test-resolve-custom-main-field": "link:./custom-main-field",
    "@vitejs/test-resolve-custom-browser-main-field": "link:./custom-browser-main-field",
    "@vitejs/test-resolve-exports-and-nested-scope": "link:./exports-and-nested-scope",
    "@vitejs/test-resolve-exports-env": "link:./exports-env",
    "@vitejs/test-resolve-exports-from-root": "link:./exports-from-root",
    "@vitejs/test-resolve-exports-legacy-fallback": "link:./exports-legacy-fallback",
    "@vitejs/test-resolve-exports-path": "link:./exports-path",
    "@vitejs/test-resolve-exports-with-module": "link:./exports-with-module",
    "@vitejs/test-resolve-exports-with-module-condition": "link:./exports-with-module-condition",
    "@vitejs/test-resolve-exports-with-module-condition-required": "link:./exports-with-module-condition-required",
    "@vitejs/test-resolve-linked": "workspace:*",
    "@vitejs/test-resolve-imports-pkg": "link:./imports-path/other-pkg",
    "@vitejs/test-resolve-sharp-dir": "link:./sharp-dir",
    "@vitejs/test-resolve-side-effects-glob": "link:./side-effects-glob",
    "@vitejs/test-utf8-bom-package": "link:./utf8-bom-package"
  }
}



================================================
FILE: playground/resolve/style.css
================================================
/* Simple CSS for HEAD request testing */
body {
  margin: 0;
  padding: 0;
}



================================================
FILE: playground/resolve/vite.config-mainfields-custom-first.js
================================================
import config from './vite.config.js'
config.resolve.mainFields = [
  'custom',
  ...config.resolve.mainFields.filter((f) => f !== 'custom'),
]
config.build.outDir = 'dist-mainfields-custom-first'
export default config



================================================
FILE: playground/resolve/vite.config.js
================================================
import path from 'node:path'
import { defaultClientConditions, defineConfig, normalizePath } from 'vite'
import { a } from './config-dep.cjs'

const virtualFile = '@virtual-file'
const virtualId = '\0' + virtualFile

const virtualFile9036 = 'virtual:file-9036.js'
const virtualId9036 = '\0' + virtualFile9036

const customVirtualFile = '@custom-virtual-file'

const generatedContentVirtualFile = '@generated-content-virtual-file'
const generatedContentImports = [
  {
    specifier: normalizePath(
      path.resolve(__dirname, './drive-relative.js').replace(/^[a-zA-Z]:/, ''),
    ),
    elementQuery: '.drive-relative',
  },
  {
    specifier: normalizePath(path.resolve(__dirname, './absolute.js')),
    elementQuery: '.absolute',
  },
  {
    specifier: new URL('file-url.js', import.meta.url),
    elementQuery: '.file-url',
  },
]

export default defineConfig({
  resolve: {
    extensions: ['.mjs', '.js', '.es', '.ts'],
    mainFields: ['browser', 'custom', 'module'],
    conditions: [...defaultClientConditions, 'custom'],
  },
  define: {
    VITE_CONFIG_DEP_TEST: a,
  },
  plugins: [
    {
      name: 'virtual-module',
      resolveId(id) {
        if (id === virtualFile) {
          return virtualId
        }
      },
      load(id) {
        if (id === virtualId) {
          return `export const msg = "[success] from conventional virtual file"`
        }
      },
    },
    {
      name: 'virtual-module-9036',
      resolveId(id) {
        if (id === virtualFile9036) {
          return virtualId9036
        }
      },
      load(id) {
        if (id === virtualId9036) {
          return `export const msg = "[success] from virtual file #9036"`
        }
      },
    },
    {
      name: 'custom-resolve',
      resolveId(id) {
        if (id === customVirtualFile) {
          return id
        }
      },
      load(id) {
        if (id === customVirtualFile) {
          return `export const msg = "[success] from custom virtual file"`
        }
      },
    },
    {
      name: 'generated-content',
      resolveId(id) {
        if (id === generatedContentVirtualFile) {
          return id
        }
      },
      load(id) {
        if (id === generatedContentVirtualFile) {
          const tests = generatedContentImports
            .map(
              ({ specifier, elementQuery }, i) =>
                `import content${i} from ${JSON.stringify(specifier)}\n` +
                `text(${JSON.stringify(elementQuery)}, content${i})`,
            )
            .join('\n')

          return (
            'function text(selector, text) {\n' +
            '  document.querySelector(selector).textContent = text\n' +
            '}\n\n' +
            tests
          )
        }
      },
    },
    {
      name: 'resolve to non normalized absolute',
      async resolveId(id) {
        if (id !== '@non-normalized') return
        return this.resolve(__dirname + '//non-normalized')
      },
    },
  ],
  optimizeDeps: {
    include: [
      '@vitejs/test-resolve-exports-with-module-condition-required',
      '@vitejs/test-require-pkg-with-module-field',
      '@vitejs/test-resolve-sharp-dir',
    ],
  },
  build: {
    copyPublicDir: false,
  },
})



================================================
FILE: playground/resolve/__tests__/resolve.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { isBuild, isServe, isWindows, page, testDir, viteTestUrl } from '~utils'

test('bom import', async () => {
  expect(await page.textContent('.utf8-bom')).toMatch('[success]')
})

test('deep import', async () => {
  expect(await page.textContent('.deep-import')).toMatch('[2,4]')
})

test('exports and a nested package scope with a different type', async () => {
  expect(await page.textContent('.exports-and-nested-scope')).toMatch(
    '[success]',
  )
})

test('entry with exports field', async () => {
  expect(await page.textContent('.exports-entry')).toMatch('[success]')
})

test('deep import with exports field', async () => {
  expect(await page.textContent('.exports-deep')).toMatch('[success]')
})

test('deep import with query with exports field', async () => {
  // since it is imported with `?url` it should return a URL
  expect(await page.textContent('.exports-deep-query')).toMatch(
    isBuild ? /base64/ : '/exports-path/deep.json',
  )
})

test('deep import with exports field + exposed dir', async () => {
  expect(await page.textContent('.exports-deep-exposed-dir')).toMatch(
    '[success]',
  )
})

test('deep import with exports field + mapped dir', async () => {
  expect(await page.textContent('.exports-deep-mapped-dir')).toMatch(
    '[success]',
  )
})

test('exports read from the root package.json', async () => {
  expect(await page.textContent('.exports-from-root')).toMatch('[success]')
})

// this is how Svelte 3 is packaged
test('deep import with exports and legacy fallback', async () => {
  expect(await page.textContent('.exports-legacy-fallback')).toMatch(
    '[success]',
  )
})

test('Respect exports field env key priority', async () => {
  expect(await page.textContent('.exports-env')).toMatch('[success]')
})

test('Respect production/development conditionals', async () => {
  expect(await page.textContent('.exports-env')).toMatch(
    isBuild ? `browser.prod.mjs` : `browser.mjs`,
  )
})

test('Respect exports to take precedence over mainFields', async () => {
  expect(await page.textContent('.exports-with-module')).toMatch('[success]')
})

test('import and require resolve using module condition', async () => {
  expect(await page.textContent('.exports-with-module-condition')).toMatch(
    '[success]',
  )
  expect(
    await page.textContent('.exports-with-module-condition-required'),
  ).toMatch('[success]')
})

test('implicit dir/index.js', async () => {
  expect(await page.textContent('.index')).toMatch('[success]')
})

test('implicit dir/index.js vs explicit file', async () => {
  expect(await page.textContent('.dir-vs-file')).toMatch('[success]')
})

test('nested extension', async () => {
  expect(await page.textContent('.nested-extension')).toMatch(
    '[success] file.json.js',
  )
})

test('exact extension vs. duplicated (.js.js)', async () => {
  expect(await page.textContent('.exact-extension')).toMatch('[success]')
})

test("don't add extension to directory name (./dir-with-ext.js/index.js)", async () => {
  expect(await page.textContent('.dir-with-ext')).toMatch('[success]')
})

test('do not resolve to the `module` field if the importer is a `require` call', async () => {
  expect(await page.textContent('.require-pkg-with-module-field')).toMatch(
    '[success]',
  )
})

test('a ts module can import another ts module using its corresponding js file name', async () => {
  expect(await page.textContent('.ts-extension')).toMatch('[success]')
})

test('a js module can import another ts module using its corresponding js file name', async () => {
  expect(await page.textContent('.js-ts-extension')).toMatch('[success]')
})

test('filename with dot', async () => {
  expect(await page.textContent('.dot')).toMatch('[success]')
})

test.runIf(isWindows)('drive-relative path', async () => {
  expect(await page.textContent('.drive-relative')).toMatch('[success]')
})

test('absolute path', async () => {
  expect(await page.textContent('.absolute')).toMatch('[success]')
})

test('file url', async () => {
  expect(await page.textContent('.file-url')).toMatch('[success]')
})

test('browser field', async () => {
  expect(await page.textContent('.browser')).toMatch('[success]')
})

test('Resolve browser field even if module field exists', async () => {
  expect(await page.textContent('.browser-module1')).toMatch('[success]')
})

test('Resolve module field if browser field is likely UMD or CJS', async () => {
  expect(await page.textContent('.browser-module2')).toMatch('[success]')
})

test('Resolve module field if browser field is likely IIFE', async () => {
  expect(await page.textContent('.browser-module3')).toMatch('[success]')
})

test('css entry', async () => {
  expect(await page.textContent('.css')).toMatch('[success]')
})

test('monorepo linked dep', async () => {
  expect(await page.textContent('.monorepo')).toMatch('[success]')
})

test('plugin resolved virtual file', async () => {
  expect(await page.textContent('.virtual')).toMatch('[success]')
})

test('plugin resolved custom virtual file', async () => {
  expect(await page.textContent('.custom-virtual')).toMatch('[success]')
})

test('resolve inline package', async () => {
  expect(await page.textContent('.inline-pkg')).toMatch('[success]')
})

test('resolve.extensions', async () => {
  expect(await page.textContent('.custom-ext')).toMatch('[success]')
})

test('resolve.mainFields', async () => {
  expect(await page.textContent('.custom-main-fields')).toMatch('[success]')
})

test('resolve.mainFields.browser-first', async () => {
  expect(await page.textContent('.custom-browser-main-field')).toBe(
    'resolved browser field',
  )
})

test('resolve.conditions', async () => {
  expect(await page.textContent('.custom-condition')).toMatch('[success]')
})

test('resolve package that contains # in path', async () => {
  expect(await page.textContent('.path-contains-sharp-symbol')).toMatch(
    '[success] true #',
  )
})

test('Resolving top level with imports field', async () => {
  expect(await page.textContent('.imports-top-level')).toMatch('[success]')
})

test('Resolving same level with imports field', async () => {
  expect(await page.textContent('.imports-same-level')).toMatch(
    await page.textContent('.imports-top-level'),
  )
})

test('Resolving nested path with imports field', async () => {
  expect(await page.textContent('.imports-nested')).toMatch('[success]')
})

test('Resolving star with imports filed', async () => {
  expect(await page.textContent('.imports-star')).toMatch('[success]')
})

test('Resolving slash with imports filed', async () => {
  expect(await page.textContent('.imports-slash')).toMatch('[success]')
})

test('Resolving from other package with imports field', async () => {
  expect(await page.textContent('.imports-pkg-slash')).toMatch('[success]')
})

test('Resolving with query with imports field', async () => {
  // since it is imported with `?url` it should return a URL
  expect(await page.textContent('.imports-query')).toMatch(
    isBuild ? /base64/ : '/imports-path/query.json',
  )
})

test("Resolve doesn't interrupt page request with trailing query and .css", async () => {
  await page.goto(viteTestUrl + '/?test.css')
  expect(await page.locator('vite-error-overlay').count()).toBe(0)
  expect(await page.textContent('h1')).toBe('Resolve')
})

test('resolve non-normalized absolute path', async () => {
  expect(await page.textContent('.non-normalized')).toMatch('[success]')
})

test.runIf(!isWindows)(
  "Resolve doesn't interrupt page request that clashes with local project package.json",
  async () => {
    // Sometimes request path may point to a different project's package.json, but for testing
    // we point to Vite's own monorepo which always exists, and the package.json is not a library
    const pathToViteMonorepoRoot = new URL('../../../', import.meta.url)
    const urlPath = fileURLToPath(pathToViteMonorepoRoot).replace(/\/$/, '')
    await page.goto(viteTestUrl + urlPath)
    expect(await page.locator('vite-error-overlay').count()).toBe(0)
    expect(await page.textContent('h1')).toBe('Resolve')
  },
)

test.runIf(isBuild)('public dir is not copied', async () => {
  expect(
    fs.existsSync(path.resolve(testDir, 'dist/should-not-be-copied')),
  ).toBe(false)
})

test('import utf8-bom package', async () => {
  expect(await page.textContent('.utf8-bom-package')).toMatch('[success]')
})

test.runIf(isBuild)('sideEffects field glob pattern is respected', async () => {
  const sideEffectValues = await page.evaluate(
    () => (window as any).__SIDE_EFFECT,
  )
  expect(sideEffectValues).toStrictEqual(['success'])
})

describe.runIf(isServe)('HEAD request handling', () => {
  test('HEAD request to JS file returns correct Content-Type', async () => {
    const response = await fetch(new URL('/absolute.js', viteTestUrl), {
      method: 'HEAD',
    })
    expect(response.headers.get('content-type')).toBe('text/javascript')
    expect(response.status).toBe(200)
    const text = await response.text()
    expect(text).toBe('')
  })

  test('HEAD request to CSS file returns correct Content-Type', async () => {
    const response = await fetch(new URL('/style.css', viteTestUrl), {
      method: 'HEAD',
      headers: {
        Accept: 'text/css',
      },
    })
    expect(response.headers.get('content-type')).toBe('text/css')
    expect(response.status).toBe(200)
  })
})



================================================
FILE: playground/resolve/__tests__/mainfields-custom-first/resolve-mainfields-custom-first.spec.ts
================================================
import { expect, test } from 'vitest'
import { page } from '~utils'

test('resolve.mainFields.custom-first', async () => {
  expect(await page.textContent('.custom-browser-main-field')).toBe(
    'resolved custom field',
  )
})



================================================
FILE: playground/resolve/browser-field/bare-import.js
================================================
import message from '@vitejs/test-resolve-browser-field-bare-import-fail'
export default message



================================================
FILE: playground/resolve/browser-field/multiple.dot.path.js
================================================
const fs = require('node:fs')
console.log('this should not run in the browser')



================================================
FILE: playground/resolve/browser-field/no-ext.js
================================================
import jsdom from 'jsdom' // should be redirected to empty module
export default ''



================================================
FILE: playground/resolve/browser-field/not-browser.js
================================================
const fs = require('node:fs')
console.log('this should not run in the browser')



================================================
FILE: playground/resolve/browser-field/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-field",
  "private": true,
  "version": "1.0.0",
  "//": "real world example: https://github.com/axios/axios/blob/3f2ef030e001547eb06060499f8a2e3f002b5a14/package.json#L71-L73",
  "main": "out/cjs.node.js",
  "browser": {
    "./out/cjs.node.js": "./out/esm.browser.js",
    "./no-ext": "./out/esm.browser.js",
    "./ext.js": "./out/esm.browser.js",
    "./ext-index/index.js": "./out/esm.browser.js",
    "./no-ext-index": "./out/esm.browser.js",
    "./bare-import": "./bare-import.js",
    "./not-browser.js": false,
    "./multiple.dot.path.js": false,
    "jsdom": false,
    "@vitejs/test-resolve-browser-field-bare-import-fail": "@vitejs/test-resolve-browser-field-bare-import-success"
  },
  "dependencies": {
    "@vitejs/test-resolve-browser-field-bare-import-fail": "link:../browser-field-bare-import-fail",
    "@vitejs/test-resolve-browser-field-bare-import-success": "link:../browser-field-bare-import-success"
  }
}



================================================
FILE: playground/resolve/browser-field/relative.js
================================================
/* eslint-disable import-x/no-duplicates */
import ra from './no-ext'
import rb from './no-ext.js' // no substitution
import rc from './ext'
import rd from './ext.js'
import re from './ext-index/index.js'
import rf from './ext-index'
import rg from './no-ext-index/index.js' // no substitution

export { ra, rb, rc, rd, re, rf, rg }



================================================
FILE: playground/resolve/browser-field/no-ext-index/index.js
================================================
import jsdom from 'jsdom' // should be redirected to empty module
export default ''



================================================
FILE: playground/resolve/browser-field-bare-import-fail/main.js
================================================
export default '[fail]'



================================================
FILE: playground/resolve/browser-field-bare-import-fail/module.js
================================================
export default '[fail]'



================================================
FILE: playground/resolve/browser-field-bare-import-fail/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-field-bare-import-fail",
  "private": true,
  "version": "1.0.0",
  "main": "main.js",
  "module": "module.js",
  "type": "module"
}



================================================
FILE: playground/resolve/browser-field-bare-import-success/main.js
================================================
export default '[fail]'



================================================
FILE: playground/resolve/browser-field-bare-import-success/module.js
================================================
export default '[success]'



================================================
FILE: playground/resolve/browser-field-bare-import-success/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-field-bare-import-success",
  "private": true,
  "version": "1.0.0",
  "main": "main.js",
  "module": "module.js",
  "type": "module"
}



================================================
FILE: playground/resolve/browser-module-field1/index.js
================================================
export default '[fail] this should not run in the browser'



================================================
FILE: playground/resolve/browser-module-field1/index.web.js
================================================
export default '[success] this should run in browser'



================================================
FILE: playground/resolve/browser-module-field1/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-module-field1",
  "private": true,
  "version": "1.0.0",
  "//": "real world example: https://github.com/aws/aws-sdk-js-v3/blob/59cdfd81452bce16bb26d07668e5550ed05d9d06/packages/credential-providers/package.json#L6-L7",
  "module": "index.js",
  "browser": "index.web.js"
}



================================================
FILE: playground/resolve/browser-module-field2/index.js
================================================
export default '[success] this should run in browser'



================================================
FILE: playground/resolve/browser-module-field2/index.web.js
================================================
module.exports = '[fail] this should not run in the browser'



================================================
FILE: playground/resolve/browser-module-field2/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-module-field2",
  "private": true,
  "version": "1.0.0",
  "module": "index.js",
  "browser": "index.web.js"
}



================================================
FILE: playground/resolve/browser-module-field3/index.js
================================================
export default '[success] this should run in browser'



================================================
FILE: playground/resolve/browser-module-field3/index.web.js
================================================
var browserModuleField3 = (function () {
  'use strict'

  var main = '[fail] this should not run in the browser'

  return main
})()



================================================
FILE: playground/resolve/browser-module-field3/package.json
================================================
{
  "name": "@vitejs/test-resolve-browser-module-field3",
  "private": true,
  "version": "1.0.0",
  "module": "index.js",
  "browser": "index.web.js"
}



================================================
FILE: playground/resolve/custom-browser-main-field/index.browser.js
================================================
export const msg = 'resolved browser field'



================================================
FILE: playground/resolve/custom-browser-main-field/index.custom.js
================================================
export const msg = 'resolved custom field'



================================================
FILE: playground/resolve/custom-browser-main-field/index.js
================================================
export const msg = '[fail] resolved main field'



================================================
FILE: playground/resolve/custom-browser-main-field/package.json
================================================
{
  "name": "@vitejs/test-resolve-custom-browser-main-field",
  "private": true,
  "version": "1.0.0",
  "main": "index.js",
  "browser": "index.browser.js",
  "custom": "index.custom.js"
}



================================================
FILE: playground/resolve/custom-condition/index.custom.js
================================================
export const msg = '[success] custom condition'



================================================
FILE: playground/resolve/custom-condition/index.js
================================================
export const msg = '[fail]'



================================================
FILE: playground/resolve/custom-condition/package.json
================================================
{
  "name": "@vitejs/test-resolve-custom-condition",
  "private": true,
  "version": "1.0.0",
  "main": "index.js",
  "exports": {
    ".": {
      "custom": "./index.custom.js",
      "import": "./index.js",
      "require": "./index.js"
    }
  }
}



================================================
FILE: playground/resolve/custom-main-field/index.custom.js
================================================
export const msg = '[success] custom main field'



================================================
FILE: playground/resolve/custom-main-field/index.js
================================================
export const msg = '[fail]'



================================================
FILE: playground/resolve/custom-main-field/package.json
================================================
{
  "name": "@vitejs/test-resolve-custom-main-field",
  "private": true,
  "version": "1.0.0",
  "main": "index.js",
  "custom": "index.custom.js"
}



================================================
FILE: playground/resolve/dir/index.js
================================================
export const file = 'dir/index.js'



================================================
FILE: playground/resolve/dir-with-ext/index.js
================================================
export const file = '[success] ./dir-with-ext/index.js'



================================================
FILE: playground/resolve/dir-with-ext.js/empty
================================================
[Empty file]


================================================
FILE: playground/resolve/exact-extension/file.js
================================================
export const file = '[success] file.js'



================================================
FILE: playground/resolve/exact-extension/file.js.js
================================================
export const file = 'file.js.js'



================================================
FILE: playground/resolve/exact-extension/file.json.js
================================================
export const file = '[success] file.json.js'



================================================
FILE: playground/resolve/exports-and-nested-scope/index.js
================================================
[Empty file]


================================================
FILE: playground/resolve/exports-and-nested-scope/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-and-nested-scope",
  "private": true,
  "version": "1.0.0",
  "type": "commonjs",
  "exports": {
    ".": "./index.js",
    "./nested": "./nested-scope/file.js"
  }
}



================================================
FILE: playground/resolve/exports-and-nested-scope/nested-scope/file.js
================================================
'use strict'

// intentionally use the default export here since default import from CJS has different semantics in node
export default '[success] ES .js file within root that has type: commonjs (thanks to a package scope)'



================================================
FILE: playground/resolve/exports-and-nested-scope/nested-scope/package.json
================================================
{
  "private": true,
  "type": "module"
}



================================================
FILE: playground/resolve/exports-env/browser.js
================================================
export const msg = 'fail (browser.js)'



================================================
FILE: playground/resolve/exports-env/browser.mjs
================================================
export const msg = '[success] exports env (browser.mjs)'



================================================
FILE: playground/resolve/exports-env/browser.prod.mjs
================================================
export const msg = '[success] exports env (browser.prod.mjs)'



================================================
FILE: playground/resolve/exports-env/fallback.umd.js
================================================
export const msg = 'fail (fallback.umd.js)'



================================================
FILE: playground/resolve/exports-env/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-env",
  "private": true,
  "version": "1.0.0",
  "exports": {
    "import": {
      "browser": {
        "production": "./browser.prod.mjs",
        "development": "./browser.mjs"
      }
    },
    "browser": "./browser.js",
    "default": "./fallback.umd.js"
  }
}



================================================
FILE: playground/resolve/exports-from-root/file.js
================================================
export const msg = '[success] exports from root (./file.js)'



================================================
FILE: playground/resolve/exports-from-root/index.js
================================================
[Empty file]


================================================
FILE: playground/resolve/exports-from-root/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-from-root",
  "private": true,
  "version": "1.0.0",
  "exports": {
    ".": "./index.js",
    "./nested": "./file.js"
  }
}



================================================
FILE: playground/resolve/exports-from-root/nested/file.js
================================================
export const msg = 'fail exports from root (./nested/file.js)'



================================================
FILE: playground/resolve/exports-from-root/nested/package.json
================================================
{
  "exports": {
    ".": "./file.js"
  }
}



================================================
FILE: playground/resolve/exports-legacy-fallback/index.js
================================================
export default 5



================================================
FILE: playground/resolve/exports-legacy-fallback/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-legacy-fallback",
  "private": true,
  "version": "1.0.0",
  "exports": {
    "./dir": {
      "import": "./dir/index.mjs",
      "require": "./dir/index.js"
    },
    ".": "index.js"
  }
}



================================================
FILE: playground/resolve/exports-legacy-fallback/dir/index.js
================================================
export const msg = '[fail] mapped js file'



================================================
FILE: playground/resolve/exports-legacy-fallback/dir/index.mjs
================================================
export const msg = '[success] mapped mjs file'



================================================
FILE: playground/resolve/exports-legacy-fallback/dir/package.json
================================================
{
  "main": "index.js",
  "module": "index.mjs"
}



================================================
FILE: playground/resolve/exports-path/cjs.js
================================================
exports.msg = 'from cjs'



================================================
FILE: playground/resolve/exports-path/deep.js
================================================
export const msg = '[success] deep resolve from exports'



================================================
FILE: playground/resolve/exports-path/deep.json
================================================
{
  "foo": "json"
}



================================================
FILE: playground/resolve/exports-path/main.js
================================================
export const msg = '[success] entry resolve from exports'



================================================
FILE: playground/resolve/exports-path/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-path",
  "private": true,
  "version": "1.0.0",
  "exports": {
    ".": {
      "import": "./main.js",
      "require": "./cjs.js"
    },
    "./deep.js": "./deep.js",
    "./deep.json": "./deep.json",
    "./dir/": "./dir/",
    "./dir-mapped/*": {
      "import": "./dir/*",
      "require": "./dir-cjs/*"
    }
  }
}



================================================
FILE: playground/resolve/exports-path/dir/dir.js
================================================
export const msg = '[success] mapped directory from exports'



================================================
FILE: playground/resolve/exports-with-module/import.mjs
================================================
// import.mjs should take precedence
export const msg = '[success] exports with module (import.mjs)'



================================================
FILE: playground/resolve/exports-with-module/module.mjs
================================================
// import.mjs should take precedence
export const msg = '[fail] exports with module (module.mjs)'



================================================
FILE: playground/resolve/exports-with-module/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-with-module",
  "private": true,
  "version": "1.0.0",
  "type": "commonjs",
  "module": "./module.mjs",
  "exports": {
    "import": "./import.mjs"
  }
}



================================================
FILE: playground/resolve/exports-with-module-condition/index.esm.js
================================================
export const msg = '[success] exports with module condition (index.esm.js)'



================================================
FILE: playground/resolve/exports-with-module-condition/index.js
================================================
/* eslint-disable import-x/no-commonjs */
module.exports.msg = '[fail] exports with module condition (index.js)'



================================================
FILE: playground/resolve/exports-with-module-condition/index.mjs
================================================
export const msg = '[fail] exports with module condition (index.mjs)'



================================================
FILE: playground/resolve/exports-with-module-condition/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-with-module-condition",
  "private": true,
  "version": "1.0.0",
  "exports": {
    "module": "./index.esm.js",
    "import": "./index.mjs",
    "require": "./index.js"
  }
}



================================================
FILE: playground/resolve/exports-with-module-condition-required/index.cjs
================================================
const { msg } = require('@vitejs/test-resolve-exports-with-module-condition')
module.exports = { msg }



================================================
FILE: playground/resolve/exports-with-module-condition-required/package.json
================================================
{
  "name": "@vitejs/test-resolve-exports-with-module-condition-required",
  "private": true,
  "version": "1.0.0",
  "main": "index.cjs",
  "dependencies": {
    "@vitejs/test-resolve-exports-with-module-condition": "link:../exports-with-module-condition"
  }
}



================================================
FILE: playground/resolve/imports-path/nested-path.js
================================================
export const msg = '[success] nested path subpath imports'



================================================
FILE: playground/resolve/imports-path/query.json
================================================
{
  "foo": "json"
}



================================================
FILE: playground/resolve/imports-path/same-level.js
================================================
export * from '#top-level'



================================================
FILE: playground/resolve/imports-path/top-level.js
================================================
export const msg = '[success] top level subpath imports'



================================================
FILE: playground/resolve/imports-path/other-pkg/package.json
================================================
{
  "name": "@vitejs/test-resolve-imports-pkg",
  "private": true
}



================================================
FILE: playground/resolve/imports-path/other-pkg/nest/index.js
================================================
export const msg = '[success] subpath imports from other package'



================================================
FILE: playground/resolve/imports-path/slash/index.js
================================================
export const msg = '[success] subpath imports with slash'



================================================
FILE: playground/resolve/imports-path/star/index.js
================================================
export const msg = '[success] subpath imports with star'



================================================
FILE: playground/resolve/inline-package/inline.js
================================================
export const msg = '[success] from inline package'



================================================
FILE: playground/resolve/inline-package/package.json
================================================
{
  "name": "@vitejs/test-inline-package",
  "private": true,
  "version": "0.0.0",
  "sideEffects": false,
  "main": "./inline"
}



================================================
FILE: playground/resolve/public/should-not-be-copied
================================================
[Empty file]


================================================
FILE: playground/resolve/require-pkg-with-module-field/dep.cjs
================================================
const BigNumber = require('bignumber.js')

const x = new BigNumber('1111222233334444555566')

module.exports = x.toString()



================================================
FILE: playground/resolve/require-pkg-with-module-field/index.cjs
================================================
const dep = require('./dep.cjs')

const msg =
  dep === '1.111222233334444555566e+21'
    ? '[success] require-pkg-with-module-field'
    : '[failed] require-pkg-with-module-field'

exports.msg = msg



================================================
FILE: playground/resolve/require-pkg-with-module-field/package.json
================================================
{
  "name": "@vitejs/test-require-pkg-with-module-field",
  "private": true,
  "version": "1.0.0",
  "main": "./index.cjs",
  "dependencies": {
    "bignumber.js": "9.3.1"
  }
}



================================================
FILE: playground/resolve/sharp-dir/index.cjs
================================================
module.exports = {
  last: require('es5-ext/string/#/last.js'),
}



================================================
FILE: playground/resolve/sharp-dir/package.json
================================================
{
  "name": "@vitejs/test-resolve-sharp-dir",
  "private": true,
  "version": "1.0.0",
  "main": "./index.cjs",
  "dependencies": {
    "es5-ext": "0.10.64"
  }
}



================================================
FILE: playground/resolve/side-effects-glob/index.js
================================================
import './effects/file.js'
import './no-effect.js'



================================================
FILE: playground/resolve/side-effects-glob/no-effect.js
================================================
;(window.__SIDE_EFFECT ||= []).push('failure')



================================================
FILE: playground/resolve/side-effects-glob/package.json
================================================
{
  "name": "@vitejs/test-resolve-side-effects-glob",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "sideEffects": [
    "index.js",
    "effects/*"
  ]
}



================================================
FILE: playground/resolve/side-effects-glob/effects/file.js
================================================
;(window.__SIDE_EFFECT ||= []).push('success')



================================================
FILE: playground/resolve/ts-extension/hello.ts
================================================
export const msg = '[success] use .js extension to import a ts module'



================================================
FILE: playground/resolve/ts-extension/hellocjs.cts
================================================
export const msgCjs = '[success] use .cjs extension to import a CommonJS module'



================================================
FILE: playground/resolve/ts-extension/hellojsx.tsx
================================================
export const msgJsx = '[success] use .jsx extension to import a tsx module'



================================================
FILE: playground/resolve/ts-extension/hellomjs.mts
================================================
export const msgMjs = '[success] use .mjs extension to import an ESM module'



================================================
FILE: playground/resolve/ts-extension/hellotsx.tsx
================================================
export const msgTsx = '[success] use .js extension to import a tsx module'



================================================
FILE: playground/resolve/ts-extension/index-js.js
================================================
import { msg as msgJs } from './hello.js'
import { msgJsx } from './hellojsx.jsx'
import { msgTsx } from './hellotsx.js'
import { msgCjs } from './hellocjs.cjs'
import { msgMjs } from './hellomjs.mjs'

export const msg =
  msgJs && msgJsx && msgTsx && msgCjs && msgMjs
    ? '[success] use .js / .jsx / .cjs / .mjs extension to import a TS modules'
    : '[fail]'



================================================
FILE: playground/resolve/ts-extension/index.ts
================================================
import { msg } from './hello.js'
import { msgJsx } from './hellojsx.jsx'
import { msgTsx } from './hellotsx.js'
import { msgCjs } from './hellocjs.cjs'
import { msgMjs } from './hellomjs.mjs'

export { msg, msgJsx, msgTsx, msgCjs, msgMjs }



================================================
FILE: playground/resolve/utf8-bom/main.js
================================================
﻿import '@babel/runtime/helpers/esm/slicedToArray'

export const msg = '[success]'



================================================
FILE: playground/resolve/utf8-bom-package/index.mjs
================================================
﻿export const msg = '[success]'



================================================
FILE: playground/resolve/utf8-bom-package/package.json
================================================
﻿{
  "name": "@vitejs/test-utf8-bom-package",
  "private": true,
  "version": "1.0.0",
  "exports": {
    ".": "./index.mjs"
  }
}



================================================
FILE: playground/resolve/util/bar.util.js
================================================
export function bar() {
  return '[success] resolve filename containing dot and omitting ext'
}



================================================
FILE: playground/resolve/util/index.js
================================================
export function foo() {
  return '[success] resolve omitted /index.*'
}



================================================
FILE: playground/resolve-linked/dep.js
================================================
export const msg = 'dep from upper directory'



================================================
FILE: playground/resolve-linked/package.json
================================================
{
  "name": "@vitejs/test-resolve-linked",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "src/index.js"
}



================================================
FILE: playground/resolve-linked/src/index.js
================================================
import { msg as depMsg } from '../dep'

export const msg = `[success] out of root monorepo dep with ${depMsg}`



================================================
FILE: playground/self-referencing/index.js
================================================
export const isSelfReference = true



================================================
FILE: playground/self-referencing/package.json
================================================
{
  "name": "@vitejs/self-referencing",
  "type": "module",
  "exports": {
    ".": "./index.js",
    "./test": "./test/index.js"
  }
}



================================================
FILE: playground/self-referencing/test/index.js
================================================
export { isSelfReference } from '@vitejs/self-referencing'



================================================
FILE: playground/ssr/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SSR</title>
    <script type="module">
      // Inline script for testing html-proxy encoding
      console.log('from inline script')
    </script>
  </head>
  <body>
    <h1>SSR</h1>
    <div><!--app-html--></div>
  </body>
</html>



================================================
FILE: playground/ssr/package.json
================================================
{
  "name": "@vitejs/test-ssr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server"
  },
  "dependencies": {},
  "devDependencies": {
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/ssr/server.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const isTest = process.env.VITEST

export async function createServer(
  root = process.cwd(),
  hmrPort,
  customLogger,
) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
    customLogger,
  })
  // use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*all', async (req, res, next) => {
    try {
      const url = req.originalUrl

      let template
      template = fs.readFileSync(resolve('index.html'), 'utf-8')
      template = await vite.transformIndexHtml(url, template)
      const render = (await vite.ssrLoadModule('/src/app.js')).render

      const appHtml = await render(url, __dirname)

      const html = template.replace(`<!--app-html-->`, appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      if (isTest) throw e
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr/vite.config.ts
================================================
import { defineConfig } from 'vite'

// in order to trigger ssr server restart
export default defineConfig({})



================================================
FILE: playground/ssr/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { createInMemoryLogger, hmrPorts, ports, rootDir } from '~utils'

export const port = ports.ssr

export const serverLogs = []

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(
    rootDir,
    hmrPorts.ssr,
    createInMemoryLogger(serverLogs),
  )

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr/__tests__/ssr.spec.ts
================================================
import { expect, test } from 'vitest'
import { port, serverLogs } from './serve'
import { browserLogs, editFile, isServe, page } from '~utils'

const url = `http://localhost:${port}`

test(`circular dependencies modules doesn't throw`, async () => {
  await page.goto(`${url}/circular-dep`)

  expect(await page.textContent('.circ-dep-init')).toMatch(
    'circ-dep-init-a circ-dep-init-b',
  )
})

test(`circular import doesn't throw (1)`, async () => {
  await page.goto(`${url}/circular-import`)

  expect(await page.textContent('.circ-import')).toMatchInlineSnapshot(
    '"A is: __A__"',
  )
})

test(`circular import doesn't throw (2)`, async () => {
  await page.goto(`${url}/circular-import2`)

  expect(await page.textContent('.circ-import')).toMatchInlineSnapshot(
    '"A is: __A__"',
  )
})

test(`deadlock doesn't happen for static imports`, async () => {
  await page.goto(`${url}/forked-deadlock-static-imports`)

  expect(await page.textContent('.forked-deadlock-static-imports')).toMatch(
    'rendered',
  )
})

test(`deadlock doesn't happen for dynamic imports`, async () => {
  await page.goto(`${url}/forked-deadlock-dynamic-imports`)

  expect(await page.textContent('.forked-deadlock-dynamic-imports')).toMatch(
    'rendered',
  )
})

test(`import.meta.resolve is supported`, async () => {
  await page.goto(`${url}/import-meta`)

  const metaUrl = await page.textContent('.import-meta-url')
  expect(metaUrl).not.toBe('')
  expect(await page.textContent('.import-meta-resolve')).toBe(metaUrl)
})

test(`import.meta.main is supported`, async () => {
  await page.goto(`${url}/import-meta`)

  expect(await page.textContent('.import-meta-main')).toBe('false')
})

test.runIf(isServe)('html proxy is encoded', async () => {
  await page.goto(
    `${url}?%22%3E%3C/script%3E%3Cscript%3Econsole.log(%27html%20proxy%20is%20not%20encoded%27)%3C/script%3E`,
  )

  expect(browserLogs).not.toContain('html proxy is not encoded')
})

// run this at the end to reduce flakiness
test.runIf(isServe)('should restart ssr', async () => {
  editFile('./vite.config.ts', (content) => content)
  await expect
    .poll(() => {
      expect(serverLogs).toEqual(
        expect.arrayContaining([expect.stringMatching('server restarted')]),
      )
      expect(serverLogs).not.toEqual(
        expect.arrayContaining([expect.stringMatching('error')]),
      )
    })
    .toSatisfy(() => true)
})



================================================
FILE: playground/ssr/src/app.js
================================================
import { escapeHtml } from './utils'

const pathRenderers = {
  '/': renderRoot,
  '/circular-dep': renderCircularDep,
  '/circular-import': renderCircularImport,
  '/circular-import2': renderCircularImport2,
  '/forked-deadlock-static-imports': renderForkedDeadlockStaticImports,
  '/forked-deadlock-dynamic-imports': renderForkedDeadlockDynamicImports,
  '/import-meta': renderImportMeta,
}

export async function render(url, rootDir) {
  const pathname = url.replace(/#[^#]*$/, '').replace(/\?[^?]*$/, '')
  const renderer = pathRenderers[pathname]
  if (renderer) {
    return await renderer(rootDir)
  }
  return '404'
}

async function renderRoot(rootDir) {
  const paths = Object.keys(pathRenderers).filter((key) => key !== '/')
  return `
    <ul>
      ${paths
        .map(
          (path) =>
            `<li><a href="${escapeHtml(path)}">${escapeHtml(path)}</a></li>`,
        )
        .join('\n')}
    </ul>
  `
}

async function renderCircularDep(rootDir) {
  const { getValueAB } = await import('./circular-dep-init/circular-dep-init')
  return `<div class="circ-dep-init">${escapeHtml(getValueAB())}</div>`
}

async function renderCircularImport(rootDir) {
  const { logA } = await import('./circular-import/index.js')
  return `<div class="circ-import">${escapeHtml(logA())}</div>`
}

async function renderCircularImport2(rootDir) {
  const { logA } = await import('./circular-import2/index.js')
  return `<div class="circ-import">${escapeHtml(logA())}</div>`
}

async function renderForkedDeadlockStaticImports(rootDir) {
  const { commonModuleExport } = await import('./forked-deadlock/common-module')
  commonModuleExport()
  return `<div class="forked-deadlock-static-imports">rendered</div>`
}

async function renderForkedDeadlockDynamicImports(rootDir) {
  const { commonModuleExport } = await import(
    './forked-deadlock/dynamic-imports/common-module'
  )
  await commonModuleExport()
  return `<div class="forked-deadlock-dynamic-imports">rendered</div>`
}

async function renderImportMeta(rootDir) {
  const metaUrl = import.meta.url
  const resolveResult = import.meta.resolve('./app.js')
  const metaMain = import.meta.main
  return (
    `<div class="import-meta-url">${escapeHtml(metaUrl)}</div>` +
    `<div class="import-meta-resolve">${escapeHtml(resolveResult)}</div>` +
    `<div class="import-meta-main">${escapeHtml(String(metaMain))}</div>`
  )
}



================================================
FILE: playground/ssr/src/utils.js
================================================
const escapeHtmlReplaceMap = {
  '&': '&amp;',
  "'": '&#x27;',
  '`': '&#x60;',
  '"': '&quot;',
  '<': '&lt;',
  '>': '&gt;',
}

/**
 * @param {string} string
 * @returns {string}
 */
export function escapeHtml(string) {
  return string.replace(/[&'`"<>]/g, (match) => escapeHtmlReplaceMap[match])
}



================================================
FILE: playground/ssr/src/circular-dep-init/README.md
================================================
This test aim to find out wherever the modules with circular dependencies are correctly initialized



================================================
FILE: playground/ssr/src/circular-dep-init/circular-dep-init.js
================================================
export * from './module-a'
export { getValueAB } from './module-b'



================================================
FILE: playground/ssr/src/circular-dep-init/module-a.js
================================================
export const valueA = 'circ-dep-init-a'



================================================
FILE: playground/ssr/src/circular-dep-init/module-b.js
================================================
import { valueA } from './circular-dep-init'

export const valueB = 'circ-dep-init-b'
export const valueAB = valueA.concat(` ${valueB}`)

export function getValueAB() {
  return valueAB
}



================================================
FILE: playground/ssr/src/circular-import/a.js
================================================
import { getB } from './b'

export const A = '__A__'

export const B = getB()



================================================
FILE: playground/ssr/src/circular-import/b.js
================================================
export function getB() {
  return '__B__'
}

export { A } from './a'



================================================
FILE: playground/ssr/src/circular-import/index.js
================================================
import { A } from './b'

export function logA() {
  return `A is: ${A}`
}



================================================
FILE: playground/ssr/src/circular-import2/a.js
================================================
import { getB } from './b'

export const A = '__A__'

export const B = getB()



================================================
FILE: playground/ssr/src/circular-import2/b.js
================================================
export { A } from './a'

export function getB() {
  return '__B__'
}



================================================
FILE: playground/ssr/src/circular-import2/index.js
================================================
import { A } from './b'

export function logA() {
  return `A is: ${A}`
}



================================================
FILE: playground/ssr/src/forked-deadlock/README.md
================================================
This test aims to check for a particular type of circular dependency that causes tricky deadlocks, **deadlocks with forked imports stack**

```
A -> B means: B is imported by A and B has A in its stack
A ... B means: A is waiting for B to ssrLoadModule()

H -> X ... Y
H -> X -> Y ... B
H -> A ... B
H -> A -> B ... X
```

### Forked deadlock description:

```
[X] is waiting for [Y] to resolve
 ↑                  ↳ is waiting for [A] to resolve
 │                                    ↳ is waiting for [B] to resolve
 │                                                      ↳ is waiting for [X] to resolve
 └────────────────────────────────────────────────────────────────────────┘
```

This may seems a traditional deadlock, but the thing that makes this special is the import stack of each module:

```
[X] stack:
	[H]
```

```
[Y] stack:
	[X]
	[H]
```

```
[A] stack:
	[H]
```

```
[B] stack:
	[A]
	[H]
```

Even if `[X]` is imported by `[B]`, `[B]` is not in `[X]`'s stack because it's imported by `[H]` in first place then it's stack is only composed by `[H]`. `[H]` **forks** the imports **stack** and this makes it hard to be found.

### Fix description

Vite, when imports `[X]`, should check whether `[X]` is already pending and if it is, it must check that, when it was imported in first place, the stack of `[X]` doesn't have any module in common with the current module; in this case `[B]` has the module `[H]` is common with `[X]` and i can assume that a deadlock is going to happen.



================================================
FILE: playground/ssr/src/forked-deadlock/common-module.js
================================================
import { stuckModuleExport } from './stuck-module'
import { deadlockfuseModuleExport } from './deadlock-fuse-module'

/**
 * module H
 */
export function commonModuleExport() {
  stuckModuleExport()
  deadlockfuseModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/deadlock-fuse-module.js
================================================
import { fuseStuckBridgeModuleExport } from './fuse-stuck-bridge-module'

/**
 * module A
 */
export function deadlockfuseModuleExport() {
  fuseStuckBridgeModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/fuse-stuck-bridge-module.js
================================================
import { stuckModuleExport } from './stuck-module'

/**
 * module C
 */
export function fuseStuckBridgeModuleExport() {
  stuckModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/middle-module.js
================================================
import { deadlockfuseModuleExport } from './deadlock-fuse-module'

/**
 * module Y
 */
export function middleModuleExport() {
  void deadlockfuseModuleExport
}



================================================
FILE: playground/ssr/src/forked-deadlock/stuck-module.js
================================================
import { middleModuleExport } from './middle-module'

/**
 * module X
 */
export function stuckModuleExport() {
  middleModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/dynamic-imports/common-module.js
================================================
/**
 * module H
 */
export async function commonModuleExport() {
  const [{ stuckModuleExport }, { deadlockfuseModuleExport }] =
    await Promise.all([
      import('./stuck-module'),
      import('./deadlock-fuse-module'),
    ])

  stuckModuleExport()
  deadlockfuseModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/dynamic-imports/deadlock-fuse-module.js
================================================
import { fuseStuckBridgeModuleExport } from './fuse-stuck-bridge-module'

/**
 * module A
 */
export function deadlockfuseModuleExport() {
  fuseStuckBridgeModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/dynamic-imports/fuse-stuck-bridge-module.js
================================================
import { stuckModuleExport } from './stuck-module'

/**
 * module C
 */
export function fuseStuckBridgeModuleExport() {
  stuckModuleExport()
}



================================================
FILE: playground/ssr/src/forked-deadlock/dynamic-imports/middle-module.js
================================================
import { deadlockfuseModuleExport } from './deadlock-fuse-module'

/**
 * module Y
 */
export function middleModuleExport() {
  void deadlockfuseModuleExport
}



================================================
FILE: playground/ssr/src/forked-deadlock/dynamic-imports/stuck-module.js
================================================
import { middleModuleExport } from './middle-module'

/**
 * module X
 */
export function stuckModuleExport() {
  middleModuleExport()
}



================================================
FILE: playground/ssr-alias/package.json
================================================
{
  "name": "@vitejs/test-ssr-html",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "build": "vite build"
  },
  "dependencies": {
    "@vitejs/test-alias-original": "file:./alias-original"
  }
}



================================================
FILE: playground/ssr-alias/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    ssr: './src/main.js',
  },
  resolve: {
    alias: {
      '@vitejs/test-alias-original': '/src/alias-replaced.js',
      '@vitejs/test-alias-non-dep': '/src/alias-replaced.js',
      'node:process': '/src/alias-process.js',
    },
  },
})



================================================
FILE: playground/ssr-alias/__tests__/ssr-alias.spec.ts
================================================
import { expect, test } from 'vitest'
import { isServe, testDir, viteServer } from '~utils'

test.runIf(isServe)('dev', async () => {
  const mod = await viteServer.ssrLoadModule('/src/main.js')
  expect(mod.default).toEqual({
    dep: 'ok',
    nonDep: 'ok',
    builtin: 'ok',
  })
})

test.runIf(!isServe)('build', async () => {
  const mod = await import(`${testDir}/dist/main.js`)
  expect(mod.default).toEqual({
    dep: 'ok',
    nonDep: 'ok',
    builtin: 'ok',
  })
})



================================================
FILE: playground/ssr-alias/alias-original/index.js
================================================
export default 'original'



================================================
FILE: playground/ssr-alias/alias-original/package.json
================================================
{
  "name": "@vitejs/test-alias-original",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": "./index.js"
  }
}



================================================
FILE: playground/ssr-alias/src/alias-process.js
================================================
export default {
  env: { __TEST_ALIAS__: 'ok' },
}



================================================
FILE: playground/ssr-alias/src/alias-replaced.js
================================================
export default 'ok'



================================================
FILE: playground/ssr-alias/src/main.js
================================================
import process from 'node:process'
import dep from '@vitejs/test-alias-original'
import nonDep from '@vitejs/test-alias-non-dep'

export default {
  dep,
  nonDep,
  builtin: process.env['__TEST_ALIAS__'],
}



================================================
FILE: playground/ssr-conditions/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SSR Resolve Conditions</title>
  </head>
  <body>
    <h1>SSR Resolve Conditions</h1>
    <div id="app"><!--app-html--></div>

    <script type="module">
      import('@vitejs/test-ssr-conditions-no-external/server').then(
        ({ default: message }) => {
          document.querySelector(
            '.browser-no-external-react-server',
          ).textContent = message
        },
      )

      import('@vitejs/test-ssr-conditions-external/server').then(
        ({ default: message }) => {
          document.querySelector('.browser-external-react-server').textContent =
            message
        },
      )
    </script>
  </body>
</html>



================================================
FILE: playground/ssr-conditions/package.json
================================================
{
  "name": "@vitejs/test-ssr-conditions",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server",
    "build": "npm run build:client && npm run build:server",
    "build:client": "vite build --outDir dist/client",
    "build:server": "vite build --ssr src/app.js --outDir dist/server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server"
  },
  "dependencies": {
    "@vitejs/test-ssr-conditions-external": "file:./external",
    "@vitejs/test-ssr-conditions-no-external": "file:./no-external"
  },
  "devDependencies": {
    "express": "^5.1.0",
    "sirv": "^3.0.1"
  }
}



================================================
FILE: playground/ssr-conditions/server.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'
import sirv from 'sirv'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const isTest = process.env.VITEST

export async function createServer(
  root = process.cwd(),
  isProd = process.env.NODE_ENV === 'production',
  hmrPort,
) {
  const resolve = (p) => path.resolve(__dirname, p)

  const indexProd = isProd
    ? fs.readFileSync(resolve('dist/client/index.html'), 'utf-8')
    : ''

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  let vite
  if (!isProd) {
    vite = await (
      await import('vite')
    ).createServer({
      root,
      logLevel: isTest ? 'error' : 'info',
      server: {
        middlewareMode: true,
        watch: {
          // During tests we edit the files too fast and sometimes chokidar
          // misses change events, so enforce polling for consistency
          usePolling: true,
          interval: 100,
        },
        hmr: {
          port: hmrPort,
        },
      },
      appType: 'custom',
    })
    app.use(vite.middlewares)
  } else {
    app.use(sirv(resolve('dist/client'), { extensions: [] }))
  }

  app.use('*all', async (req, res) => {
    try {
      const url = req.originalUrl

      let template, render
      if (!isProd) {
        template = fs.readFileSync(resolve('index.html'), 'utf-8')
        template = await vite.transformIndexHtml(url, template)
        render = (await vite.ssrLoadModule('/src/app.js')).render
      } else {
        template = indexProd
        render = (await import('./dist/server/app.js')).render
      }

      const appHtml = await render(url, __dirname)

      const html = template.replace(`<!--app-html-->`, appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr-conditions/vite.config.js
================================================
import { defaultServerConditions, defineConfig } from 'vite'

export default defineConfig({
  ssr: {
    external: ['@vitejs/test-ssr-conditions-external'],
    noExternal: ['@vitejs/test-ssr-conditions-no-external'],
    resolve: {
      conditions: [...defaultServerConditions, 'react-server'],
      externalConditions: ['node', 'workerd', 'react-server'],
    },
  },
})



================================================
FILE: playground/ssr-conditions/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, isBuild, ports, rootDir } from '~utils'

export const port = ports['ssr-conditions']

export async function serve(): Promise<{ close(): Promise<void> }> {
  if (isBuild) {
    // build first
    const { build } = await import('vite')
    // client build
    await build({
      root: rootDir,
      logLevel: 'silent', // exceptions are logged by Vitest
      build: {
        minify: false,
        outDir: 'dist/client',
      },
    })
    // server build
    await build({
      root: rootDir,
      logLevel: 'silent',
      build: {
        ssr: 'src/app.js',
        outDir: 'dist/server',
      },
    })
  }

  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(
    rootDir,
    isBuild,
    hmrPorts['ssr-conditions'],
  )

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr-conditions/__tests__/ssr-conditions.spec.ts
================================================
import { expect, test } from 'vitest'
import { port } from './serve'
import { isServe, page } from '~utils'

const url = `http://localhost:${port}`

test('ssr.resolve.conditions affect non-externalized imports during ssr', async () => {
  await page.goto(url)
  expect(await page.textContent('.no-external-react-server')).toMatch(
    'node.unbundled.js',
  )
})

// externalConditions is only used for dev
test.runIf(isServe)(
  'ssr.resolve.externalConditions affect externalized imports during ssr',
  async () => {
    await page.goto(url)
    expect(await page.textContent('.external-react-server')).toMatch('edge.js')
  },
)

test('ssr.resolve settings do not affect non-ssr imports', async () => {
  await page.goto(url)
  await expect
    .poll(() => page.textContent('.browser-no-external-react-server'))
    .toMatch('default.js')
  await expect
    .poll(() => page.textContent('.browser-external-react-server'))
    .toMatch('default.js')
})



================================================
FILE: playground/ssr-conditions/external/browser.js
================================================
export default 'browser.js'



================================================
FILE: playground/ssr-conditions/external/default.js
================================================
export default 'default.js'



================================================
FILE: playground/ssr-conditions/external/edge.js
================================================
export default 'edge.js'



================================================
FILE: playground/ssr-conditions/external/node.js
================================================
export default 'node.js'



================================================
FILE: playground/ssr-conditions/external/node.unbundled.js
================================================
export default 'node.unbundled.js'



================================================
FILE: playground/ssr-conditions/external/package.json
================================================
{
  "name": "@vitejs/test-ssr-conditions-external",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "exports": {
    "./server": {
      "react-server": {
        "workerd": "./edge.js",
        "deno": "./browser.js",
        "node": {
          "webpack": "./node.js",
          "default": "./node.unbundled.js"
        },
        "edge-light": "./edge.js",
        "browser": "./browser.js"
      },
      "default": "./default.js"
    }
  }
}



================================================
FILE: playground/ssr-conditions/no-external/browser.js
================================================
export default 'browser.js'



================================================
FILE: playground/ssr-conditions/no-external/default.js
================================================
export default 'default.js'



================================================
FILE: playground/ssr-conditions/no-external/edge.js
================================================
export default 'edge.js'



================================================
FILE: playground/ssr-conditions/no-external/node.js
================================================
export default 'node.js'



================================================
FILE: playground/ssr-conditions/no-external/node.unbundled.js
================================================
export default 'node.unbundled.js'



================================================
FILE: playground/ssr-conditions/no-external/package.json
================================================
{
  "name": "@vitejs/test-ssr-conditions-no-external",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "exports": {
    "./server": {
      "react-server": {
        "workerd": "./edge.js",
        "deno": "./browser.js",
        "node": {
          "webpack": "./node.js",
          "default": "./node.unbundled.js"
        },
        "edge-light": "./edge.js",
        "browser": "./browser.js"
      },
      "default": "./default.js"
    }
  }
}



================================================
FILE: playground/ssr-conditions/src/app.js
================================================
import noExternalReactServerMessage from '@vitejs/test-ssr-conditions-no-external/server'
import externalReactServerMessage from '@vitejs/test-ssr-conditions-external/server'

export async function render(url) {
  let html = ''

  html += `\n<p class="no-external-react-server">${noExternalReactServerMessage}</p>`

  html += `\n<p class="browser-no-external-react-server"></p>`

  html += `\n<p class="external-react-server">${externalReactServerMessage}</p>`

  html += `\n<p class="browser-external-react-server"></p>`

  return html + '\n'
}



================================================
FILE: playground/ssr-deps/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SSR Dependencies</title>
  </head>
  <body>
    <h1>SSR Dependencies</h1>
    <div><!--app-html--></div>
    <script type="module">
      // hydration scripts
      import '@vitejs/test-css-lib'
    </script>
    <script type="module">
      // Using dynamic import, so the module is transformed when browser actually
      // requests it. This essentially disables pre-transform optimization that's
      // crucial to trigger a race condition, covered by the test case introduced
      // in https://github.com/vitejs/vite/pull/11973
      import('virtual:isomorphic-module').then(({ default: message }) => {
        document.querySelector('.isomorphic-module-browser').textContent =
          message
      })
    </script>
  </body>
</html>



================================================
FILE: playground/ssr-deps/message
================================================
File Content!



================================================
FILE: playground/ssr-deps/package.json
================================================
{
  "name": "@vitejs/test-ssr-deps",
  "private": true,
  "type": "module",
  "version": "0.0.0",
  "scripts": {
    "dev": "node server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server"
  },
  "dependencies": {
    "@node-rs/bcrypt": "^1.10.7",
    "@vitejs/test-css-lib": "file:./css-lib",
    "@vitejs/test-define-properties-exports": "file:./define-properties-exports",
    "@vitejs/test-define-property-exports": "file:./define-property-exports",
    "@vitejs/test-external-entry": "file:./external-entry",
    "@vitejs/test-external-using-external-entry": "file:./external-using-external-entry",
    "@vitejs/test-forwarded-export": "file:./forwarded-export",
    "@vitejs/test-import-builtin-cjs": "file:./import-builtin-cjs",
    "@vitejs/test-linked-no-external": "link:./linked-no-external",
    "@vitejs/test-module-condition": "file:./module-condition",
    "@vitejs/test-nested-exclude": "file:./nested-exclude",
    "@vitejs/test-no-external-cjs": "file:./no-external-cjs",
    "@vitejs/test-no-external-css": "file:./no-external-css",
    "@vitejs/test-non-optimized-with-nested-external": "workspace:*",
    "@vitejs/test-object-assigned-exports": "file:./object-assigned-exports",
    "@vitejs/test-only-object-assigned-exports": "file:./only-object-assigned-exports",
    "@vitejs/test-optimized-cjs-with-nested-external": "file:./optimized-with-nested-external",
    "@vitejs/test-optimized-with-nested-external": "file:./optimized-with-nested-external",
    "@vitejs/test-pkg-exports": "file:./pkg-exports",
    "@vitejs/test-primitive-export": "file:./primitive-export",
    "@vitejs/test-read-file-content": "file:./read-file-content",
    "@vitejs/test-require-absolute": "file:./require-absolute",
    "@vitejs/test-ts-transpiled-exports": "file:./ts-transpiled-exports"
  },
  "devDependencies": {
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/ssr-deps/server.js
================================================
// @ts-check
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const isTest = process.env.VITEST

const noExternal = [
  '@vitejs/test-no-external-cjs',
  '@vitejs/test-import-builtin-cjs',
  '@vitejs/test-no-external-css',
  '@vitejs/test-external-entry',
]

export async function createServer(root = process.cwd(), hmrPort) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
    ssr: {
      noExternal: [
        ...noExternal,
        '@vitejs/test-nested-exclude',
        '@vitejs/test-nested-include',
      ],
      external: [
        '@vitejs/test-nested-external',
        '@vitejs/test-external-entry/entry',
      ],
      optimizeDeps: {
        include: [
          ...noExternal,
          '@vitejs/test-nested-exclude > @vitejs/test-nested-include',
        ],
      },
    },
    plugins: [
      {
        name: 'dep-virtual',
        enforce: 'pre',
        resolveId(id) {
          if (id === '@vitejs/test-pkg-exports/virtual') {
            return '@vitejs/test-pkg-exports/virtual'
          }
        },
        load(id) {
          if (id === '@vitejs/test-pkg-exports/virtual') {
            return 'export default "[success]"'
          }
        },
      },
      {
        name: 'virtual-isomorphic-module',
        resolveId(id) {
          if (id === 'virtual:isomorphic-module') {
            return '\0virtual:isomorphic-module'
          }
        },
        load(id, { ssr }) {
          if (id === '\0virtual:isomorphic-module') {
            if (ssr) {
              return 'export { default } from "/src/isomorphic-module-server.js";'
            } else {
              return 'export { default } from "/src/isomorphic-module-browser.js";'
            }
          }
        },
      },
    ],
  })
  // use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*all', async (req, res) => {
    try {
      const url = req.originalUrl

      let template
      template = fs.readFileSync(resolve('index.html'), 'utf-8')
      template = await vite.transformIndexHtml(url, template)
      const render = (await vite.ssrLoadModule('/src/app.js')).render

      const appHtml = await render(url, __dirname)

      const html = template.replace(`<!--app-html-->`, appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr-deps/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, ports, rootDir } from '~utils'

export const port = ports['ssr-deps']

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(rootDir, hmrPorts['ssr-deps'])

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr-deps/__tests__/ssr-deps.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { editFile, getColor, isServe, page } from '~utils'

const url = `http://localhost:${port}`

/**
 * test for #5809
 */
test('msg should be encrypted', async () => {
  await page.goto(url)
  expect(await page.textContent('.encrypted-msg')).not.toMatch(
    'Secret Message!',
  )
})

test('msg read by fs/promises', async () => {
  await page.goto(url)
  expect(await page.textContent('.file-message')).toMatch('File Content!')
})

test('msg from primitive export', async () => {
  await page.goto(url)
  expect(await page.textContent('.primitive-export-message')).toMatch(
    'Hello World!',
  )
})

test('msg from TS transpiled exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.ts-default-export-message')).toMatch(
    'Hello World!',
  )
  expect(await page.textContent('.ts-named-export-message')).toMatch(
    'Hello World!',
  )
})

test('msg from Object.assign exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.object-assigned-exports-message')).toMatch(
    'Hello World!',
  )
})

test('msg from forwarded exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.forwarded-export-message')).toMatch(
    'Hello World!',
  )
})

test('msg from define properties exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.define-properties-exports-msg')).toMatch(
    'Hello World!',
  )
})

test('msg from define property exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.define-property-exports-msg')).toMatch(
    'Hello World!',
  )
})

test('msg from only object assigned exports', async () => {
  await page.goto(url)
  expect(await page.textContent('.only-object-assigned-exports-msg')).toMatch(
    'Hello World!',
  )
})

test('msg from no external cjs', async () => {
  await page.goto(url)
  expect(await page.textContent('.no-external-cjs-msg')).toMatch('Hello World!')
})

test('msg from optimized with nested external', async () => {
  await page.goto(url)
  expect(await page.textContent('.optimized-with-nested-external')).toMatch(
    'Hello World!',
  )
})

test('msg from optimized cjs with nested external', async () => {
  await page.goto(url)
  expect(await page.textContent('.optimized-cjs-with-nested-external')).toMatch(
    'Hello World!',
  )
})

test('msg from external using external entry', async () => {
  await page.goto(url)
  expect(await page.textContent('.external-using-external-entry')).toMatch(
    'Hello World!',
  )
})

test('msg from linked no external', async () => {
  await page.goto(url)
  expect(await page.textContent('.linked-no-external')).toMatch(
    `Hello World from ${process.env.NODE_ENV}!`,
  )
})

test('msg from linked no external', async () => {
  await page.goto(url)
  expect(await page.textContent('.dep-virtual')).toMatch('[success]')
})

test('import css library', async () => {
  await page.goto(url)
  expect(await getColor('.css-lib')).toBe('blue')
})

test('import css library', async () => {
  await page.goto(url)
  expect(await page.textContent('.module-condition')).toMatch('[success]')
})

test('optimize-deps-nested-include', async () => {
  await page.goto(url)
  expect(await page.textContent('.optimize-deps-nested-include')).toMatch(
    'nested-include',
  )
})

describe.runIf(isServe)('hmr', () => {
  // TODO: the server file is not imported on the client at all
  // so it's not present in the client moduleGraph anymore
  // we need to decide if we want to support a usecase when ssr change
  // affects the client in any way
  test.skip('handle isomorphic module updates', async () => {
    await page.goto(url)

    expect(await page.textContent('.isomorphic-module-server')).toMatch(
      '[server]',
    )
    // Allowing additional time for this element to be filled in
    // by a client script that is loaded using dynamic import
    await expect
      .poll(async () => {
        return page.textContent('.isomorphic-module-browser')
      })
      .toMatch('[browser]')

    editFile('src/isomorphic-module-browser.js', (code) =>
      code.replace('[browser]', '[browser-hmr]'),
    )
    await page.waitForNavigation()
    await expect
      .poll(async () => {
        return page.textContent('.isomorphic-module-browser')
      })
      .toMatch('[browser-hmr]')

    editFile('src/isomorphic-module-server.js', (code) =>
      code.replace('[server]', '[server-hmr]'),
    )
    await page.waitForNavigation()
    await expect
      .poll(async () => {
        return page.textContent('.isomorphic-module-server')
      })
      .toMatch('[server-hmr]')
  })
})



================================================
FILE: playground/ssr-deps/css-lib/index.css
================================================
.css-lib {
  color: blue;
}



================================================
FILE: playground/ssr-deps/css-lib/package.json
================================================
{
  "name": "@vitejs/test-css-lib",
  "private": true,
  "version": "0.0.0",
  "main": "./index.css"
}



================================================
FILE: playground/ssr-deps/define-properties-exports/index.js
================================================
// prettier-ignore
Object.defineProperties    (    exports    , {
  hello: {
    value() {
      return 'Hello World!'
    }
  }
})



================================================
FILE: playground/ssr-deps/define-properties-exports/package.json
================================================
{
  "name": "@vitejs/test-define-properties-exports",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/define-property-exports/index.js
================================================
Object.defineProperty(exports, 'hello', {
  value() {
    return 'Hello World!'
  },
})



================================================
FILE: playground/ssr-deps/define-property-exports/package.json
================================================
{
  "name": "@vitejs/test-define-property-exports",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/external-entry/entry.js
================================================
// Module with state, to check that it is properly externalized and
// not bundled in the optimized deps
let msg
export function setMessage(externalMsg) {
  msg = externalMsg
}
export default function getMessage() {
  return msg
}



================================================
FILE: playground/ssr-deps/external-entry/index.js
================================================
export default undefined



================================================
FILE: playground/ssr-deps/external-entry/package.json
================================================
{
  "name": "@vitejs/test-external-entry",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": "./index.js",
    "./entry": "./entry.js"
  },
  "type": "module"
}



================================================
FILE: playground/ssr-deps/external-using-external-entry/index.js
================================================
import getMessage from 'external-entry/entry'

export default {
  hello() {
    return getMessage()
  },
}



================================================
FILE: playground/ssr-deps/external-using-external-entry/package.json
================================================
{
  "name": "@vitejs/test-external-using-external-entry",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "external-entry": "file:../external-entry"
  }
}



================================================
FILE: playground/ssr-deps/forwarded-export/index.js
================================================
const original = require('object-assigned-exports')
module.exports = original



================================================
FILE: playground/ssr-deps/forwarded-export/package.json
================================================
{
  "name": "@vitejs/test-forwarded-export",
  "private": true,
  "version": "0.0.0",
  "dependencies": {
    "object-assigned-exports": "file:../object-assigned-exports"
  }
}



================================================
FILE: playground/ssr-deps/import-builtin-cjs/index.js
================================================
exports.stream = require('node:stream')

exports.hello = function () {
  return 'Hello World!'
}



================================================
FILE: playground/ssr-deps/import-builtin-cjs/package.json
================================================
{
  "name": "@vitejs/test-import-builtin",
  "private": true,
  "type": "commonjs",
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/linked-no-external/index.js
================================================
export const hello = function () {
  // make sure linked package is not externalized so Vite features like
  // import.meta.env works (or handling TS files)
  return `Hello World from ${
    import.meta.env.DEV ? 'development' : 'production'
  }!`
}



================================================
FILE: playground/ssr-deps/linked-no-external/package.json
================================================
{
  "name": "@vitejs/test-linked-no-external",
  "private": true,
  "type": "module",
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/module-condition/import.mjs
================================================
export default '[success]'



================================================
FILE: playground/ssr-deps/module-condition/module.js
================================================
// this is written in ESM but the file extension implies this is evaluated as CJS.
// BUT this doesn't matter in practice as the `module` condition is not used in node.
// hence SSR should not load this file.
export default '[fail] should not load me'



================================================
FILE: playground/ssr-deps/module-condition/package.json
================================================
{
  "name": "@vitejs/test-module-condition",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": {
      "module": "./module.js",
      "import": "./import.mjs"
    }
  }
}



================================================
FILE: playground/ssr-deps/nested-exclude/index.js
================================================
export { default as nestedInclude } from '@vitejs/test-nested-include'

export default 'nested-exclude'



================================================
FILE: playground/ssr-deps/nested-exclude/package.json
================================================
{
  "name": "@vitejs/test-nested-exclude",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "@vitejs/test-nested-include": "file:../nested-include"
  }
}



================================================
FILE: playground/ssr-deps/nested-external/index.js
================================================
// Module with state, to check that it is properly externalized and
// not bundled in the optimized deps
let msg
export function setMessage(externalMsg) {
  msg = externalMsg
}
export default function getMessage() {
  return msg
}



================================================
FILE: playground/ssr-deps/nested-external/package.json
================================================
{
  "name": "@vitejs/test-nested-external",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "module"
}



================================================
FILE: playground/ssr-deps/nested-external-cjs/index.js
================================================
// Module with state, to check that it is properly externalized and
// not bundled in the optimized deps
let msg

module.exports = {
  setMessage(externalMsg) {
    msg = externalMsg
  },
  getMessage() {
    return msg
  },
}



================================================
FILE: playground/ssr-deps/nested-external-cjs/package.json
================================================
{
  "name": "nested-external-cjs",
  "private": true,
  "version": "0.0.0",
  "main": "index.js",
  "type": "commonjs"
}



================================================
FILE: playground/ssr-deps/nested-include/index.js
================================================
// written in cjs, optimization should convert this to esm
module.exports = 'nested-include'



================================================
FILE: playground/ssr-deps/nested-include/package.json
================================================
{
  "name": "@vitejs/test-nested-include",
  "private": true,
  "version": "1.0.0",
  "main": "index.js"
}



================================================
FILE: playground/ssr-deps/no-external-cjs/index.js
================================================
exports.hello = function () {
  return 'Hello World!'
}



================================================
FILE: playground/ssr-deps/no-external-cjs/package.json
================================================
{
  "name": "@vitejs/test-no-external-cjs",
  "private": true,
  "type": "commonjs",
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/no-external-css/index.css
================================================
@font-face {
  font-family: 'Not Real Sans';
  src: url('./i-throw-if-you-optimize-this-file.woff') format('woff');
}



================================================
FILE: playground/ssr-deps/no-external-css/package.json
================================================
{
  "name": "@vitejs/test-no-external-css",
  "private": true,
  "type": "module",
  "version": "0.0.0",
  "exports": {
    ".": "./index.css"
  }
}



================================================
FILE: playground/ssr-deps/non-optimized-with-nested-external/index.js
================================================
import { setMessage } from 'nested-external'
import external from 'nested-external-cjs'

setMessage('Hello World!')
external.setMessage('Hello World!')



================================================
FILE: playground/ssr-deps/non-optimized-with-nested-external/package.json
================================================
{
  "name": "@vitejs/test-non-optimized-with-nested-external",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "nested-external": "file:../nested-external",
    "nested-external-cjs": "file:../nested-external-cjs"
  }
}



================================================
FILE: playground/ssr-deps/object-assigned-exports/index.js
================================================
Object.defineProperty(exports, '__esModule', { value: true })

const obj = {
  hello() {
    return 'Hello World!'
  },
}

Object.assign(exports, obj)



================================================
FILE: playground/ssr-deps/object-assigned-exports/package.json
================================================
{
  "name": "@vitejs/test-object-assigned-exports",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/only-object-assigned-exports/index.js
================================================
Object.assign(exports, {
  hello() {
    return 'Hello World!'
  },
})



================================================
FILE: playground/ssr-deps/only-object-assigned-exports/package.json
================================================
{
  "name": "@vitejs/test-only-object-assigned-exports",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/optimized-cjs-with-nested-external/index.js
================================================
const getMessage = require('nested-external')

module.exports = {
  hello: getMessage,
}



================================================
FILE: playground/ssr-deps/optimized-cjs-with-nested-external/package.json
================================================
{
  "name": "@vitejs/test-optimized-cjs-with-nested-external",
  "private": true,
  "version": "0.0.0",
  "dependencies": {
    "nested-external": "file:../nested-external"
  }
}



================================================
FILE: playground/ssr-deps/optimized-with-nested-external/index.js
================================================
import getMessage from 'nested-external'

export function hello() {
  return getMessage()
}



================================================
FILE: playground/ssr-deps/optimized-with-nested-external/package.json
================================================
{
  "name": "@vitejs/test-optimized-with-nested-external",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "nested-external": "file:../nested-external"
  }
}



================================================
FILE: playground/ssr-deps/pkg-exports/index.js
================================================
export default undefined



================================================
FILE: playground/ssr-deps/pkg-exports/package.json
================================================
{
  "name": "@vitejs/test-pkg-exports",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": "./index.js"
  },
  "type": "module"
}



================================================
FILE: playground/ssr-deps/primitive-export/index.js
================================================
module.exports = 'Hello World!'



================================================
FILE: playground/ssr-deps/primitive-export/package.json
================================================
{
  "name": "@vitejs/test-primitive-export",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/read-file-content/index.js
================================================
const path = require('node:path')

module.exports = async function readFileContent(filePath) {
  const fs = require('node:fs/promises')
  return await fs.readFile(path.resolve(filePath), 'utf-8')
}



================================================
FILE: playground/ssr-deps/read-file-content/package.json
================================================
{
  "name": "@vitejs/test-read-file-content",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/require-absolute/foo.js
================================================
module.exports.hello = 'Hello World!'



================================================
FILE: playground/ssr-deps/require-absolute/index.js
================================================
const path = require('node:path')

module.exports.hello = () => require(path.resolve(__dirname, './foo.js')).hello



================================================
FILE: playground/ssr-deps/require-absolute/package.json
================================================
{
  "name": "@vitejs/test-require-absolute",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-deps/src/app.js
================================================
import path from 'node:path'
import readFileContent from '@vitejs/test-read-file-content'
import primitiveExport from '@vitejs/test-primitive-export'
import tsDefaultExport, {
  hello as tsNamedExport,
} from '@vitejs/test-ts-transpiled-exports'
import objectAssignedExports from '@vitejs/test-object-assigned-exports'
import forwardedExport from '@vitejs/test-forwarded-export'
import bcrypt from '@node-rs/bcrypt'
import definePropertiesExports from '@vitejs/test-define-properties-exports'
import definePropertyExports from '@vitejs/test-define-property-exports'
import onlyObjectAssignedExports from '@vitejs/test-only-object-assigned-exports'
import requireAbsolute from '@vitejs/test-require-absolute'
import noExternalCjs from '@vitejs/test-no-external-cjs'
import importBuiltinCjs from '@vitejs/test-import-builtin-cjs'
import { hello as linkedNoExternal } from '@vitejs/test-linked-no-external'
import virtualMessage from '@vitejs/test-pkg-exports/virtual'
import moduleConditionMessage from '@vitejs/test-module-condition'
import '@vitejs/test-css-lib'

// This import will set a 'Hello World!" message in the nested-external non-entry dependency
import '@vitejs/test-non-optimized-with-nested-external'

import * as optimizedWithNestedExternal from '@vitejs/test-optimized-with-nested-external'
import * as optimizedCjsWithNestedExternal from '@vitejs/test-optimized-cjs-with-nested-external'
import * as optimizeDepsNestedInclude from '@vitejs/test-nested-exclude'

import { setMessage } from '@vitejs/test-external-entry/entry'
setMessage('Hello World!')
import externalUsingExternalEntry from '@vitejs/test-external-using-external-entry'
import isomorphicModuleMessage from 'virtual:isomorphic-module'

export async function render(url, rootDir) {
  let html = ''

  const encryptedMsg = await bcrypt.hash('Secret Message!', 10)
  html += `\n<p class="encrypted-msg">encrypted message: ${encryptedMsg}</p>`

  const fileContent = await readFileContent(path.resolve(rootDir, 'message'))
  html += `\n<p class="file-message">msg read via fs/promises: ${fileContent}</p>`

  html += `\n<p class="primitive-export-message">message from primitive export: ${primitiveExport}</p>`

  // `.default()` as incorrectly packaged
  const tsDefaultExportMessage = tsDefaultExport.default()
  html += `\n<p class="ts-default-export-message">message from ts-default-export: ${tsDefaultExportMessage}</p>`

  const tsNamedExportMessage = tsNamedExport()
  html += `\n<p class="ts-named-export-message">message from ts-named-export: ${tsNamedExportMessage}</p>`

  const objectAssignedExportsMessage = objectAssignedExports.hello()
  html += `\n<p class="object-assigned-exports-message">message from object-assigned-exports: ${objectAssignedExportsMessage}</p>`

  const forwardedExportMessage = forwardedExport.hello()
  html += `\n<p class="forwarded-export-message">message from forwarded-export: ${forwardedExportMessage}</p>`

  const definePropertiesExportsMsg = definePropertiesExports.hello()
  html += `\n<p class="define-properties-exports-msg">message from define-properties-exports: ${definePropertiesExportsMsg}</p>`

  const definePropertyExportsMsg = definePropertyExports.hello()
  html += `\n<p class="define-property-exports-msg">message from define-property-exports: ${definePropertyExportsMsg}</p>`

  const onlyObjectAssignedExportsMessage = onlyObjectAssignedExports.hello()
  html += `\n<p class="only-object-assigned-exports-msg">message from only-object-assigned-exports: ${onlyObjectAssignedExportsMessage}</p>`

  const requireAbsoluteMessage = requireAbsolute.hello()
  html += `\n<p class="require-absolute-msg">message from require-absolute: ${requireAbsoluteMessage}</p>`

  const noExternalCjsMessage = noExternalCjs.hello()
  html += `\n<p class="no-external-cjs-msg">message from no-external-cjs: ${noExternalCjsMessage}</p>`

  const importBuiltinCjsMessage = importBuiltinCjs.hello()
  html += `\n<p class="import-builtin-cjs-msg">message from import-builtin-cjs: ${importBuiltinCjsMessage}</p>`

  const optimizedWithNestedExternalMessage = optimizedWithNestedExternal.hello()
  html += `\n<p class="optimized-with-nested-external">message from optimized-with-nested-external: ${optimizedWithNestedExternalMessage}</p>`

  const optimizedCjsWithNestedExternalMessage =
    optimizedCjsWithNestedExternal.hello()
  html += `\n<p class="optimized-cjs-with-nested-external">message from optimized-cjs-with-nested-external: ${optimizedCjsWithNestedExternalMessage}</p>`

  const externalUsingExternalEntryMessage = externalUsingExternalEntry.hello()
  html += `\n<p class="external-using-external-entry">message from external-using-external-entry: ${externalUsingExternalEntryMessage}</p>`

  const linkedNoExternalMessage = linkedNoExternal()
  html += `\n<p class="linked-no-external">linked-no-external msg: ${linkedNoExternalMessage}</p>`

  html += `\n<p class="dep-virtual">message from dep-virtual: ${virtualMessage}</p>`

  html += `\n<p class="css-lib">I should be blue</p>`

  html += `\n<p class="module-condition">${moduleConditionMessage}</p>`

  html += `\n<p class="isomorphic-module-server">${isomorphicModuleMessage}</p>`

  html += `\n<p class="isomorphic-module-browser"></p>`

  html += `\n<p class="optimize-deps-nested-include">message from optimize-deps-nested-include: ${optimizeDepsNestedInclude.nestedInclude}</p>`

  return html + '\n'
}



================================================
FILE: playground/ssr-deps/src/isomorphic-module-browser.js
================================================
const message = 'message from isomorphic-module (browser): [browser]'

export default message



================================================
FILE: playground/ssr-deps/src/isomorphic-module-server.js
================================================
const message = 'message from isomorphic-module (server): [server]'

export default message



================================================
FILE: playground/ssr-deps/ts-transpiled-exports/index.js
================================================
'use strict'
Object.defineProperty(exports, '__esModule', { value: true })
exports.hello = void 0
function hello() {
  return 'Hello World!'
}
exports.hello = hello
exports.default = hello



================================================
FILE: playground/ssr-deps/ts-transpiled-exports/package.json
================================================
{
  "name": "@vitejs/test-ts-transpiled-exports",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-html/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SSR HTML</title>
    <style>
      body {
        background-color: white;
      }
    </style>
  </head>
  <body>
    <h1>SSR Dynamic HTML</h1>
    <div class="virtual"></div>
  </body>
</html>



================================================
FILE: playground/ssr-html/package.json
================================================
{
  "name": "@vitejs/test-ssr-html",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server",
    "test-stacktrace:off": "node test-stacktrace false",
    "test-stacktrace:on": "node test-stacktrace true"
  },
  "dependencies": {},
  "devDependencies": {
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/ssr-html/server.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const isTest = process.env.VITEST

const DYNAMIC_SCRIPTS = `
  <script type="module">
    const p = document.createElement('p');
    p.innerHTML = '✅ Dynamically injected inline script';
    document.body.appendChild(p);
  </script>
  <script type="module" src="/src/app.js"></script>
`

const DYNAMIC_STYLES = `
  <style>
  h1 {
    background-color: blue;
  }
  </style>
`

export async function createServer(root = process.cwd(), hmrPort) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
    plugins: [
      {
        name: 'virtual-file',
        resolveId(id) {
          if (id === 'virtual:file') {
            return '\0virtual:file'
          }
        },
        load(id) {
          if (id === '\0virtual:file') {
            return 'import { virtual } from "/src/importedVirtual.js"; export { virtual };'
          }
        },
      },
    ],
  })
  // use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*all', async (req, res, next) => {
    try {
      let [url] = req.originalUrl.split('?')
      if (url.endsWith('/')) url += 'index.html'

      if (url.startsWith('/favicon.ico')) {
        return res.status(404).end('404')
      }
      if (url.startsWith('/@id/__x00__')) {
        return next()
      }

      const htmlLoc = resolve(`.${url}`)
      let template = fs.readFileSync(htmlLoc, 'utf-8')

      template = template.replace(
        '</body>',
        `${DYNAMIC_SCRIPTS}${DYNAMIC_STYLES}</body>`,
      )

      // Force calling transformIndexHtml with url === '/', to simulate
      // usage by ecosystem that was recommended in the SSR documentation
      // as `const url = req.originalUrl`
      const html = await vite.transformIndexHtml('/', template)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr-html/test-network-imports.js
================================================
import assert from 'node:assert'
import { fileURLToPath } from 'node:url'
import { createServer, createServerModuleRunner } from 'vite'

async function runTest(userRunner) {
  const server = await createServer({
    configFile: false,
    root: fileURLToPath(new URL('.', import.meta.url)),
    server: {
      middlewareMode: true,
      ws: false,
    },
  })
  let mod
  if (userRunner) {
    const runner = await createServerModuleRunner(server.environments.ssr, {
      hmr: false,
    })
    mod = await runner.import('/src/network-imports.js')
  } else {
    mod = await server.ssrLoadModule('/src/network-imports.js')
  }
  assert.equal(mod.slash('foo\\bar'), 'foo/bar')
  await server.close()
}

runTest(process.argv.includes('--module-runner'))



================================================
FILE: playground/ssr-html/test-stacktrace-runtime.js
================================================
import { fileURLToPath } from 'node:url'
import assert from 'node:assert'
import { createServer, createServerModuleRunner } from 'vite'

// same test case as packages/vite/src/node/ssr/runtime/__tests__/server-source-maps.spec.ts
// implemented for e2e to catch build specific behavior

const server = await createServer({
  configFile: false,
  root: fileURLToPath(new URL('.', import.meta.url)),
  server: {
    middlewareMode: true,
    ws: false,
  },
})

const runner = await createServerModuleRunner(server.environments.ssr, {
  sourcemapInterceptor: 'prepareStackTrace',
})

const mod = await runner.import('/src/has-error-deep.ts')
let error
try {
  mod.main()
} catch (e) {
  error = e
} finally {
  await server.close()
}
assert.match(error?.stack, /has-error-deep.ts:6:3/)



================================================
FILE: playground/ssr-html/test-stacktrace.js
================================================
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const isSourceMapEnabled = process.argv[2] === 'true'
const ext = process.argv[3]
process.setSourceMapsEnabled(isSourceMapEnabled)
console.log('# sourcemaps enabled:', isSourceMapEnabled)
console.log('# source file extension:', ext)

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const isTest = process.env.VITEST

const vite = await createServer({
  root: __dirname,
  logLevel: isTest ? 'error' : 'info',
  server: {
    middlewareMode: true,
    ws: false,
  },
  appType: 'custom',
})

const dir = path.dirname(fileURLToPath(import.meta.url))

const abs1 = await vite.ssrLoadModule(`/src/error-${ext}.${ext}`)
const abs2 = await vite.ssrLoadModule(
  path.resolve(dir, `./src/error-${ext}.${ext}`),
)
const relative = await vite.ssrLoadModule(`./src/error-${ext}.${ext}`)

for (const mod of [abs1, abs2, relative]) {
  try {
    mod.error()
  } catch (e) {
    // this should not be called
    // when sourcemap support for `new Function` is supported and sourcemap is enabled
    // because the stacktrace is already rewritten by Node.js
    if (!isSourceMapEnabled) {
      vite.ssrFixStacktrace(e)
    }
    console.log(e)
  }
}

await vite.close()



================================================
FILE: playground/ssr-html/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, ports, rootDir } from '~utils'

export const port = ports['ssr-html']

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(rootDir, hmrPorts['ssr-html'])

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr-html/__tests__/ssr-html.spec.ts
================================================
import { execFile } from 'node:child_process'
import { promisify } from 'node:util'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { editFile, isServe, page } from '~utils'

const url = `http://localhost:${port}`

describe.runIf(isServe)('injected inline scripts', () => {
  test('no injected inline scripts are present', async () => {
    await page.goto(url)
    const inlineScripts = await page.$$eval('script', (nodes) =>
      nodes.filter((n) => !n.getAttribute('src') && n.innerHTML),
    )
    expect(inlineScripts).toHaveLength(0)
  })

  test('injected script proxied correctly', async () => {
    await page.goto(url)
    const proxiedScripts = await page.$$eval('script', (nodes) =>
      nodes
        .filter((n) => {
          const src = n.getAttribute('src')
          if (!src) return false
          return src.includes('?html-proxy&index')
        })
        .map((n) => n.getAttribute('src')),
    )

    // assert at least 1 proxied script exists
    expect(proxiedScripts).not.toHaveLength(0)

    const scriptContents = await Promise.all(
      proxiedScripts.map((src) => fetch(url + src).then((res) => res.text())),
    )

    // all proxied scripts return code
    for (const code of scriptContents) {
      expect(code).toBeTruthy()
    }
  })
})

describe.runIf(isServe)('hmr', () => {
  test('handle virtual module updates', async () => {
    await page.goto(url)
    const el = await page.$('.virtual')
    expect(await el.textContent()).toBe('[success]')

    const loadPromise = page.waitForEvent('load')
    editFile('src/importedVirtual.js', (code) =>
      code.replace('[success]', '[wow]'),
    )
    await loadPromise

    await expect
      .poll(async () => {
        const el = await page.$('.virtual')
        return await el.textContent()
      })
      .toMatch('[wow]')
  })
})

const execFileAsync = promisify(execFile)

describe.runIf(isServe)('stacktrace', () => {
  for (const ext of ['js', 'ts']) {
    for (const sourcemapsEnabled of [false, true]) {
      test(`stacktrace of ${ext} is correct when sourcemaps is${
        sourcemapsEnabled ? '' : ' not'
      } enabled in Node.js`, async () => {
        const testStacktraceFile = path.resolve(
          __dirname,
          '../test-stacktrace.js',
        )

        const p = await execFileAsync('node', [
          testStacktraceFile,
          '' + sourcemapsEnabled,
          ext,
        ])
        const lines = p.stdout
          .split('\n')
          .filter((line) => line.includes('Module.error'))

        const reg = new RegExp(
          path
            .resolve(__dirname, '../src', `error-${ext}.${ext}`)
            .replace(/\\/g, '\\\\') + ':2:9',
          'i',
        )

        lines.forEach((line) => {
          expect(line.trim()).toMatch(reg)
        })
      })
    }
  }

  test('with Vite runtime', async () => {
    await execFileAsync('node', ['test-stacktrace-runtime.js'], {
      cwd: fileURLToPath(new URL('..', import.meta.url)),
    })
  })
})

// --experimental-network-imports is going to be dropped
// https://github.com/nodejs/node/pull/53822
const noNetworkImports = Number(process.version.match(/^v(\d+)\./)[1]) >= 22

describe.runIf(isServe && !noNetworkImports)('network-imports', () => {
  test('with Vite SSR', async () => {
    await execFileAsync(
      'node',
      ['--experimental-network-imports', 'test-network-imports.js'],
      {
        cwd: fileURLToPath(new URL('..', import.meta.url)),
      },
    )
  })

  test('with Vite runtime', async () => {
    await execFileAsync(
      'node',
      [
        '--experimental-network-imports',
        'test-network-imports.js',
        '--module-runner',
      ],
      {
        cwd: fileURLToPath(new URL('..', import.meta.url)),
      },
    )
  })
})



================================================
FILE: playground/ssr-html/public/slash@3.0.0.js
================================================
/* eslint-disable */
// copied from https://esm.sh/v133/slash@3.0.0/es2022/slash.mjs to reduce network issues in CI

/* esm.sh - esbuild bundle(slash@3.0.0) es2022 production */
var a=Object.create;var d=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var A=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),E=(e,t)=>{for(var r in t)d(e,r,{get:t[r],enumerable:!0})},u=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of x(t))!p.call(e,n)&&n!==r&&d(e,n,{get:()=>t[n],enumerable:!(i=m(t,n))||i.enumerable});return e},o=(e,t,r)=>(u(e,t,"default"),r&&u(r,t,"default")),c=(e,t,r)=>(r=e!=null?a(g(e)):{},u(t||!e||!e.__esModule?d(r,"default",{value:e,enumerable:!0}):r,e));var f=A((h,_)=>{"use strict";_.exports=e=>{let t=/^\\\\\?\\/.test(e),r=/[^\u0000-\u0080]+/.test(e);return t||r?e:e.replace(/\\/g,"/")}});var s={};E(s,{default:()=>P});var L=c(f());o(s,c(f()));var{default:l,...N}=L,P=l!==void 0?l:N;export{P as default};



================================================
FILE: playground/ssr-html/src/app.js
================================================
import { virtual } from 'virtual:file'

const p = document.createElement('p')
p.innerHTML = '✅ Dynamically injected script from file'
document.body.appendChild(p)

text('.virtual', virtual)

function text(el, text) {
  document.querySelector(el).textContent = text
}



================================================
FILE: playground/ssr-html/src/error-js.js
================================================
export function error() {
  throw new Error('e')
}



================================================
FILE: playground/ssr-html/src/error-ts.ts
================================================
export function error() {
  throw new Error('e')
}



================================================
FILE: playground/ssr-html/src/has-error-deep.ts
================================================
function crash(message: string) {
  throw new Error(message)
}

export function main(): void {
  crash('crash')
}



================================================
FILE: playground/ssr-html/src/importedVirtual.js
================================================
export const virtual = '[success]'



================================================
FILE: playground/ssr-html/src/network-imports.js
================================================
// same port as `ports["ssr-html"]` in playground/test-utils.ts
import slash from 'http://localhost:9602/slash@3.0.0.js'

// or test without local server
// import slash from 'https://esm.sh/slash@3.0.0'

export { slash }



================================================
FILE: playground/ssr-noexternal/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"><!--app-html--></div>
  </body>
</html>



================================================
FILE: playground/ssr-noexternal/package.json
================================================
{
  "name": "@vitejs/test-ssr-noexternal",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server",
    "build": "vite build --ssr src/entry-server.js",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server"
  },
  "dependencies": {
    "@vitejs/test-external-cjs": "file:./external-cjs",
    "@vitejs/test-require-external-cjs": "file:./require-external-cjs",
    "express": "^5.1.0"
  }
}



================================================
FILE: playground/ssr-noexternal/server.js
================================================
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const isTest = process.env.VITEST

export async function createServer(
  root = process.cwd(),
  isProd = process.env.NODE_ENV === 'production',
  hmrPort,
) {
  const resolve = (p) => path.resolve(__dirname, p)

  const indexProd = isProd
    ? fs.readFileSync(resolve('index.html'), 'utf-8')
    : ''

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  let vite
  if (!isProd) {
    vite = await (
      await import('vite')
    ).createServer({
      root,
      logLevel: isTest ? 'error' : 'info',
      server: {
        middlewareMode: true,
        watch: {
          // During tests we edit the files too fast and sometimes chokidar
          // misses change events, so enforce polling for consistency
          usePolling: true,
          interval: 100,
        },
        hmr: {
          port: hmrPort,
        },
      },
      appType: 'custom',
    })
    app.use(vite.middlewares)
  }

  app.use('*all', async (req, res) => {
    try {
      const url = req.originalUrl

      let template, render
      if (!isProd) {
        // always read fresh template in dev
        template = fs.readFileSync(resolve('index.html'), 'utf-8')
        template = await vite.transformIndexHtml(url, template)
        render = (await vite.ssrLoadModule('/src/entry-server.js')).render
      } else {
        template = indexProd
        render = (await import('./dist/entry-server.js')).render
      }

      const appHtml = await render(url)

      const html = template.replace(`<!--app-html-->`, appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      !isProd && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr-noexternal/vite.config.js
================================================
import { defineConfig } from 'vite'

const noExternal = ['@vitejs/test-require-external-cjs']
export default defineConfig({
  ssr: {
    noExternal,
    external: ['@vitejs/test-external-cjs'],
    optimizeDeps: {
      include: noExternal,
    },
  },
  build: {
    target: 'esnext',
    minify: false,
    rollupOptions: {
      external: ['@vitejs/test-external-cjs'],
    },
  },
})



================================================
FILE: playground/ssr-noexternal/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, isBuild, ports, rootDir } from '~utils'

export const port = ports['ssr-noexternal']

export async function serve(): Promise<{ close(): Promise<void> }> {
  if (isBuild) {
    // build first
    const { build } = await import('vite')
    // server build
    await build({
      root: rootDir,
      logLevel: 'silent',
      build: {
        ssr: 'src/entry-server.js',
      },
    })
  }

  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(
    rootDir,
    isBuild,
    hmrPorts['ssr-noexternal'],
  )

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr-noexternal/__tests__/ssr-noexternal.spec.ts
================================================
import { expect, test } from 'vitest'
import { port } from './serve'
import { isBuild, page } from '~utils'

const url = `http://localhost:${port}`

test.runIf(!isBuild)('message from require-external-cjs', async () => {
  await page.goto(url)
  expect(await page.textContent('.require-external-cjs')).toMatch('foo')
})



================================================
FILE: playground/ssr-noexternal/external-cjs/import.mjs
================================================
throw new Error('shouldnt be loaded')



================================================
FILE: playground/ssr-noexternal/external-cjs/package.json
================================================
{
  "name": "@vitejs/test-external-cjs",
  "private": true,
  "version": "0.0.0",
  "exports": {
    "require": "./require.cjs",
    "import": "./import.mjs"
  }
}



================================================
FILE: playground/ssr-noexternal/external-cjs/require.cjs
================================================
module.exports = 'foo'



================================================
FILE: playground/ssr-noexternal/require-external-cjs/main.js
================================================
module.exports = require('@vitejs/test-external-cjs')



================================================
FILE: playground/ssr-noexternal/require-external-cjs/package.json
================================================
{
  "name": "@vitejs/test-require-external-cjs",
  "type": "commonjs",
  "private": true,
  "version": "0.0.0",
  "main": "main.js",
  "dependencies": {
    "@vitejs/test-external-cjs": "file:../external-cjs"
  }
}



================================================
FILE: playground/ssr-noexternal/src/entry-server.js
================================================
import requireExternalCjs from '@vitejs/test-require-external-cjs'

export async function render(url) {
  let html = ''

  html += `\n<p class="require-external-cjs">message from require-external-cjs: ${requireExternalCjs}</p>`

  return html + '\n'
}



================================================
FILE: playground/ssr-pug/index.pug
================================================
doctype html
html
  head
    meta(charset='UTF-8')
    meta(name='viewport' content='width=device-width, initial-scale=1.0')
    title SSR Pug
  body
    h1 SSR Pug



================================================
FILE: playground/ssr-pug/package.json
================================================
{
  "name": "@vitejs/test-ssr-pug",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "node server",
    "serve": "NODE_ENV=production node server",
    "debug": "node --inspect-brk server"
  },
  "devDependencies": {
    "express": "^5.1.0",
    "pug": "^3.0.3"
  }
}



================================================
FILE: playground/ssr-pug/server.js
================================================
// @ts-check
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import pug from 'pug'
import express from 'express'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const isTest = process.env.VITEST

const DYNAMIC_SCRIPTS = `
  <script type="module">
    const p = document.createElement('p');
    p.innerHTML = '✅ Dynamically injected inline script';
    document.body.appendChild(p);
  </script>
  <script type="module" src="/src/app.js"></script>
`

export async function createServer(root = process.cwd(), hmrPort) {
  const resolve = (p) => path.resolve(__dirname, p)

  const app = express()

  /**
   * @type {import('vite').ViteDevServer}
   */
  const vite = await (
    await import('vite')
  ).createServer({
    root,
    logLevel: isTest ? 'error' : 'info',
    server: {
      middlewareMode: true,
      watch: {
        // During tests we edit the files too fast and sometimes chokidar
        // misses change events, so enforce polling for consistency
        usePolling: true,
        interval: 100,
      },
      hmr: {
        port: hmrPort,
      },
    },
    appType: 'custom',
  })
  // use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*all', async (req, res) => {
    try {
      let [url] = req.originalUrl.split('?')
      url = url.replace(/\.html$/, '.pug')
      if (url.endsWith('/')) url += 'index.pug'

      const htmlLoc = resolve(`.${url}`)
      let html = pug.renderFile(htmlLoc)
      html = html.replace('</body>', `${DYNAMIC_SCRIPTS}</body>`)
      html = await vite.transformIndexHtml(url, html)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  return { app, vite }
}

if (!isTest) {
  createServer().then(({ app }) =>
    app.listen(5173, () => {
      console.log('http://localhost:5173')
    }),
  )
}



================================================
FILE: playground/ssr-pug/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { hmrPorts, ports, rootDir } from '~utils'

export const port = ports['ssr-pug']

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  const { createServer } = await import(path.resolve(rootDir, 'server.js'))
  const { app, vite } = await createServer(rootDir, hmrPorts['ssr-pug'])

  return new Promise((resolve, reject) => {
    try {
      const server = app.listen(port, () => {
        resolve({
          // for test teardown
          async close() {
            await new Promise((resolve) => {
              server.close(resolve)
            })
            if (vite) {
              await vite.close()
            }
          },
        })
      })
    } catch (e) {
      reject(e)
    }
  })
}



================================================
FILE: playground/ssr-pug/__tests__/ssr-pug.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { port } from './serve'
import { page } from '~utils'

const url = `http://localhost:${port}`

describe('injected inline scripts', () => {
  test('no injected inline scripts are present', async () => {
    await page.goto(url)
    const inlineScripts = await page.$$eval('script', (nodes) =>
      nodes.filter((n) => !n.getAttribute('src') && n.innerHTML),
    )
    expect(inlineScripts).toHaveLength(0)
  })

  test('injected script proxied correctly', async () => {
    await page.goto(url)
    const proxiedScripts = await page.$$eval('script', (nodes) =>
      nodes
        .filter((n) => {
          const src = n.getAttribute('src')
          if (!src) return false
          return src.includes('?html-proxy&index')
        })
        .map((n) => n.getAttribute('src')),
    )

    // assert at least 1 proxied script exists
    expect(proxiedScripts).not.toHaveLength(0)

    const scriptContents = await Promise.all(
      proxiedScripts.map((src) => fetch(url + src).then((res) => res.text())),
    )

    // all proxied scripts return code
    for (const code of scriptContents) {
      expect(code).toBeTruthy()
    }
  })
})



================================================
FILE: playground/ssr-pug/src/app.js
================================================
const p = document.createElement('p')
p.innerHTML = '✅ Dynamically injected script from file'
document.body.appendChild(p)



================================================
FILE: playground/ssr-resolve/main.js
================================================
// no `exports` key, should resolve to entries/dir/index.js
import dirEntry from '@vitejs/test-entries/dir'
// no `exports` key, should resolve to entries/file.js
import fileEntry from '@vitejs/test-entries/file'
// has `exports` key, should resolve to pkg-exports/entry
import pkgExportsEntry from '@vitejs/test-resolve-pkg-exports/entry'
import deepFoo from '@vitejs/test-deep-import/foo'
// import deepBar from '@vitejs/test-deep-import/bar'
import moduleSync from '@vitejs/test-module-sync'
import { used } from './util'

export default `
  entries/dir: ${dirEntry}
  entries/file: ${fileEntry}
  pkg-exports/entry: ${pkgExportsEntry}
  deep-import/foo: ${deepFoo}
  ${/* `deep-import/bar: ${deepBar}` */ ''}
  module-sync: ${moduleSync}
  util: ${used(['[success]'])}
`



================================================
FILE: playground/ssr-resolve/package.json
================================================
{
  "name": "@vitejs/test-ssr-resolve",
  "private": true,
  "version": "0.0.0",
  "type": "commonjs",
  "scripts": {
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite build"
  },
  "dependencies": {
    "@vitejs/test-deep-import": "file:./deep-import",
    "@vitejs/test-entries": "file:./entries",
    "@vitejs/test-module-sync": "file:./pkg-module-sync",
    "@vitejs/test-resolve-pkg-exports": "file:./pkg-exports"
  }
}



================================================
FILE: playground/ssr-resolve/util.js
================================================
import { pathToFileURL } from 'node:url'

export function used(s) {
  return s
}

// This is not used, so `node:url` should not be bundled
export function treeshaken(s) {
  return pathToFileURL(s)
}



================================================
FILE: playground/ssr-resolve/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    ssr: './main.js',
  },
})



================================================
FILE: playground/ssr-resolve/__tests__/ssr-resolve.spec.ts
================================================
import { execFile } from 'node:child_process'
import { promisify } from 'node:util'
import { expect, test } from 'vitest'
import { isBuild, readFile, testDir } from '~utils'

const execFileAsync = promisify(execFile)

test.runIf(isBuild)('correctly resolve entrypoints', async () => {
  const contents = readFile('dist/main.mjs')

  const _ = `['"]`
  expect(contents).toMatch(
    new RegExp(`from ${_}@vitejs/test-entries/dir/index.js${_}`),
  )
  expect(contents).toMatch(
    new RegExp(`from ${_}@vitejs/test-entries/file.js${_}`),
  )
  expect(contents).toMatch(
    new RegExp(`from ${_}@vitejs/test-resolve-pkg-exports/entry${_}`),
  )

  expect(contents).toMatch(
    new RegExp(`from ${_}@vitejs/test-deep-import/foo/index.js${_}`),
  )

  // expect(contents).toMatch(
  //   new RegExp(`from ${_}@vitejs/test-deep-import/utils/bar.js${_}`),
  // )

  expect(contents).toMatch(new RegExp(`from ${_}@vitejs/test-module-sync${_}`))

  await execFileAsync('node', [`${testDir}/dist/main.mjs`])
})

test.runIf(isBuild)(
  'node builtins should not be bundled if not used',
  async () => {
    const contents = readFile('dist/main.mjs')
    expect(contents).not.include(`node:url`)
  },
)



================================================
FILE: playground/ssr-resolve/deep-import/index.js
================================================
export { default as foo } from './foo'
export { default as bar } from './bar'
export default 'external-nested'



================================================
FILE: playground/ssr-resolve/deep-import/package.json
================================================
{
  "name": "@vitejs/test-deep-import",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "module": "index.js"
}



================================================
FILE: playground/ssr-resolve/deep-import/bar/package.json
================================================
{
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "../utils/bar.js",
  "module": "../utils/bar.js"
}



================================================
FILE: playground/ssr-resolve/deep-import/foo/index.js
================================================
export default 'foo'



================================================
FILE: playground/ssr-resolve/deep-import/foo/package.json
================================================
{
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "module": "./index.js"
}



================================================
FILE: playground/ssr-resolve/deep-import/utils/bar.js
================================================
export default 'bar'



================================================
FILE: playground/ssr-resolve/entries/file.js
================================================
module.exports = __filename.slice(__filename.lastIndexOf('entries'))



================================================
FILE: playground/ssr-resolve/entries/package.json
================================================
{
  "name": "@vitejs/test-entries",
  "private": true,
  "version": "0.0.0"
}



================================================
FILE: playground/ssr-resolve/entries/dir/index.js
================================================
module.exports = __filename.slice(__filename.lastIndexOf('entries'))



================================================
FILE: playground/ssr-resolve/pkg-exports/entry.js
================================================
module.exports = 'pkg-exports entry'



================================================
FILE: playground/ssr-resolve/pkg-exports/index.js
================================================
module.exports = undefined



================================================
FILE: playground/ssr-resolve/pkg-exports/package.json
================================================
{
  "name": "@vitejs/test-resolve-pkg-exports",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": "./index.js",
    "./entry": "./entry.js"
  }
}



================================================
FILE: playground/ssr-resolve/pkg-module-sync/index.js
================================================
export default 'module-sync'



================================================
FILE: playground/ssr-resolve/pkg-module-sync/package.json
================================================
{
  "name": "@vitejs/test-module-sync",
  "type": "module",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": {
      "module-sync": "./index.js"
    }
  }
}



================================================
FILE: playground/ssr-webworker/package.json
================================================
{
  "name": "@vitejs/test-ssr-webworker",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "DEV=1 node worker",
    "build:worker": "vite build --ssr src/entry-worker.jsx --outDir dist/worker"
  },
  "dependencies": {
    "react": "^19.1.1",
    "@vitejs/test-browser-exports": "file:./browser-exports",
    "@vitejs/test-worker-exports": "file:./worker-exports"
  },
  "devDependencies": {
    "miniflare": "^4.20250803.0",
    "@vitejs/test-resolve-linked": "workspace:*"
  }
}



================================================
FILE: playground/ssr-webworker/vite.config.js
================================================
import { defaultClientConditions, defineConfig } from 'vite'

export default defineConfig({
  build: {
    minify: false,
  },
  resolve: {
    dedupe: ['react'],
  },
  ssr: {
    target: 'webworker',
    noExternal: ['this-should-be-replaced-by-the-boolean'],
    // Some webworker builds may choose to externalize node builtins as they may be implemented
    // in the runtime, and so we can externalize it when bundling.
    external: ['node:assert'],
    resolve: {
      conditions: [...defaultClientConditions, 'worker'],
    },
  },
  plugins: [
    {
      name: '@vitejs/test-ssr-webworker/no-external',
      config() {
        return {
          ssr: {
            noExternal: true,
          },
        }
      },
    },
    {
      name: '@vitejs/test-ssr-webworker/no-external-array',
      config() {
        return {
          ssr: {
            noExternal: ['this-should-not-replace-the-boolean'],
          },
        }
      },
    },
  ],
})



================================================
FILE: playground/ssr-webworker/worker.js
================================================
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import { Miniflare } from 'miniflare'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const isTest = !!process.env.TEST

export async function createServer(port) {
  const mf = new Miniflare({
    scriptPath: path.resolve(__dirname, 'dist/worker/entry-worker.js'),
    port,
    modules: true,
    compatibilityFlags: ['nodejs_compat'],
  })
  await mf.ready
  return { mf }
}

if (!isTest) {
  createServer(5173).then(() => console.log('http://localhost:5173'))
}



================================================
FILE: playground/ssr-webworker/__tests__/serve.ts
================================================
// this is automatically detected by playground/vitestSetup.ts and will replace
// the default e2e test serve behavior

import path from 'node:path'
import kill from 'kill-port'
import { ports, rootDir } from '~utils'

export const port = ports['ssr-webworker']

export async function serve(): Promise<{ close(): Promise<void> }> {
  await kill(port)

  // we build first, regardless of whether it's prod/build mode
  // because Vite doesn't support the concept of a "webworker server"
  const { build } = await import('vite')

  // worker build
  await build({
    root: rootDir,
    logLevel: 'silent',
    build: {
      target: 'esnext',
      ssr: 'src/entry-worker.jsx',
      outDir: 'dist/worker',
    },
  })

  const { createServer } = await import(path.resolve(rootDir, 'worker.js'))
  const { mf } = await createServer(port)

  return {
    // for test teardown
    async close() {
      await mf.dispose()
    },
  }
}



================================================
FILE: playground/ssr-webworker/__tests__/ssr-webworker.spec.ts
================================================
import { expect, test } from 'vitest'
import { port } from './serve'
import { findAssetFile, isBuild, page } from '~utils'

const url = `http://localhost:${port}`

test('/', async () => {
  await page.goto(url + '/')
  expect(await page.textContent('h1')).toMatch('hello from webworker')
  expect(await page.textContent('.linked')).toMatch('dep from upper directory')
  expect(await page.textContent('.external')).toMatch('object')
})

test('supports resolve.conditions', async () => {
  await page.goto(url)
  expect(await page.textContent('.worker-exports')).toMatch('[success] worker')
})

test('respects browser export', async () => {
  await page.goto(url)
  expect(await page.textContent('.browser-exports')).toMatch(
    '[success] browser',
  )
})

test('supports nodejs_compat', async () => {
  await page.goto(url)
  expect(await page.textContent('.nodejs-compat')).toMatch(
    '[success] nodejs compat',
  )
})

test.runIf(isBuild)('inlineDynamicImports', () => {
  const dynamicJsContent = findAssetFile(/dynamic-[-\w]+\.js/, 'worker')
  expect(dynamicJsContent).toBeUndefined()
})



================================================
FILE: playground/ssr-webworker/browser-exports/browser.js
================================================
export default '[success] browser'



================================================
FILE: playground/ssr-webworker/browser-exports/node.js
================================================
export default '[fail] should not load me'



================================================
FILE: playground/ssr-webworker/browser-exports/package.json
================================================
{
  "name": "@vitejs/test-browser-exports",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": {
      "browser": "./browser.js",
      "node": "./node.js",
      "default": "./node.js"
    }
  }
}



================================================
FILE: playground/ssr-webworker/src/dynamic.js
================================================
export const foo = 'foo'



================================================
FILE: playground/ssr-webworker/src/entry-worker.jsx
================================================
import { equal } from 'node:assert'
import { msg as linkedMsg } from '@vitejs/test-resolve-linked'
import browserExportsMessage from '@vitejs/test-browser-exports'
import workerExportsMessage from '@vitejs/test-worker-exports'
import React from 'react'

let loaded = false
import('./dynamic').then(({ foo }) => {
  loaded = !!foo
})

addEventListener('fetch', function (event) {
  return event.respondWith(
    new Response(
      `
    <h1>hello from webworker</h1>
    <p class="linked">${linkedMsg}</p>
    <p class="external">${typeof React}</p>
    <p>dynamic: ${loaded}</p>
    <p class="browser-exports">${browserExportsMessage}</p>
    <p class="worker-exports">${workerExportsMessage}</p>
    <p class="nodejs-compat">${equal('a', 'a') || '[success] nodejs compat'}</p>
    `,
      {
        headers: {
          'content-type': 'text/html',
        },
      },
    ),
  )
})



================================================
FILE: playground/ssr-webworker/worker-exports/browser.js
================================================
// conditions are set to worker, and worker is higher up in the exports object in package.json, so should be preferred
export default '[fail] should not load me'



================================================
FILE: playground/ssr-webworker/worker-exports/node.js
================================================
export default '[fail] should not load me'



================================================
FILE: playground/ssr-webworker/worker-exports/package.json
================================================
{
  "name": "@vitejs/test-worker-exports",
  "private": true,
  "version": "0.0.0",
  "exports": {
    ".": {
      "worker": "./worker.js",
      "browser": "./browser.js",
      "node": "./node.js",
      "default": "./node.js"
    }
  }
}



================================================
FILE: playground/ssr-webworker/worker-exports/worker.js
================================================
export default '[success] worker'



================================================
FILE: playground/tailwind/index.css
================================================
@import 'tailwindcss';
@config './tailwind.config.ts';



================================================
FILE: playground/tailwind/index.html
================================================
<link rel="stylesheet" href="./index.css" />

<div id="app"></div>

<div class="html text-blue-500">html</div>

<script type="module" src="/src/main.js" defer></script>



================================================
FILE: playground/tailwind/package.json
================================================
{
  "name": "@vitejs/test-tailwind",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.11",
    "tailwindcss": "^4.1.11"
  },
  "devDependencies": {
    "tsx": "^4.20.3"
  }
}



================================================
FILE: playground/tailwind/tailwind.config.ts
================================================
import type { Config } from 'tailwindcss'

export default {
  content: [
    // Before editing this section, make sure no paths are matching with `/src/main.js`
    // Look https://github.com/vitejs/vite/pull/6959 for more details
    __dirname + '/src/{components,views}/**/*.js',
    __dirname + '/src/main.js',
    __dirname + '/index.html',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} satisfies Config



================================================
FILE: playground/tailwind/vite.config.ts
================================================
import { defineConfig } from 'vite'
import type { Plugin } from 'vite'
import tailwindcss from '@tailwindcss/vite'

function delayIndexCssPlugin(): Plugin {
  let server
  return {
    name: 'delay-index-css',
    enforce: 'pre',
    configureServer(_server) {
      server = _server
    },
    async load(id) {
      if (server && id.includes('index.css')) {
        await server.waitForRequestsIdle(id)
      }
    },
  }
}

export default defineConfig({
  resolve: {
    alias: {
      '/@': __dirname,
    },
  },
  build: {
    // to make tests faster
    minify: false,
  },
  plugins: [
    {
      name: 'delay view',
      enforce: 'pre',
      async transform(_code, id) {
        if (id.includes('views/view1.js')) {
          await new Promise((resolve) => setTimeout(resolve, 100))
        }
      },
    },
    delayIndexCssPlugin(),
    tailwindcss(),
  ],
})



================================================
FILE: playground/tailwind/__test__/tailwind.spec.ts
================================================
import { expect, test } from 'vitest'
import { editFile, getColor, isServe, page, untilBrowserLogAfter } from '~utils'

test('should render', async () => {
  expect(await page.textContent('#pagetitle')).toBe('Page title')
})

test.runIf(isServe)(
  'full reload happens when the HTML is changed',
  async () => {
    await expect
      .poll(() => getColor('.html'))
      .toBe('oklch(0.623 0.214 259.815)')

    editFile('index.html', (code) =>
      code.replace('"html text-blue-500"', '"html text-green-500"'),
    )
    await expect
      .poll(() => getColor('.html'))
      .toBe('oklch(0.723 0.219 149.579)')
  },
)

test.runIf(isServe)('regenerate CSS and HMR (glob pattern)', async () => {
  const el = page.locator('#view1-text')
  expect(await getColor(el)).toBe('oklch(0.627 0.194 149.214)')

  await untilBrowserLogAfter(
    () =>
      editFile('src/views/view1.js', (code) =>
        code.replace('|view1|', '|view1 updated|'),
      ),
    [
      '[vite] css hot updated: /index.css',
      '[vite] hot updated: /src/views/view1.js via /src/main.js',
    ],
    false,
  )
  await expect.poll(() => el.textContent()).toMatch('|view1 updated|')

  await untilBrowserLogAfter(
    () =>
      editFile('src/views/view1.js', (code) =>
        code.replace('text-green-600', 'text-orange-600'),
      ),
    [
      '[vite] css hot updated: /index.css',
      '[vite] hot updated: /src/views/view1.js via /src/main.js',
    ],
    false,
  )
  await expect.poll(() => getColor(el)).toBe('oklch(0.646 0.222 41.116)')
})

test.runIf(isServe)(
  'same file duplicated in module graph (#4267)',
  async () => {
    const el = page.locator('#component1')
    expect(await getColor(el)).toBe('oklch(0.577 0.245 27.325)')

    // when duplicated, page reload happens
    await untilBrowserLogAfter(
      () =>
        editFile('src/components/component1.js', (code) =>
          code.replace('text-red-600', 'text-blue-600'),
        ),
      [
        '[vite] css hot updated: /index.css',
        '[vite] hot updated: /src/components/component1.js',
      ],
      false,
    )
    await expect.poll(() => getColor(el)).toBe('oklch(0.546 0.245 262.881)')
  },
)

test.runIf(isServe)('regenerate CSS and HMR (relative path)', async () => {
  const el = page.locator('#pagetitle')
  expect(await getColor(el)).toBe('oklch(0.541 0.281 293.009)')

  await untilBrowserLogAfter(
    () =>
      editFile('src/main.js', (code) =>
        code.replace('text-violet-600', 'text-cyan-600'),
      ),
    ['[vite] css hot updated: /index.css', '[vite] hot updated: /src/main.js'],
    false,
  )
  await expect.poll(() => getColor(el)).toBe('oklch(0.609 0.126 221.723)')
})



================================================
FILE: playground/tailwind/src/main.js
================================================
import { view1 } from './views/view1'

export const main = (view1Content) => /* html */ `
  <h1 id="pagetitle" class="text-3xl text-violet-600">Page title</h1>
  ${view1Content}
  <!-- used in postcss-plugins-different-dir -->
  <div id="tailwind-style" class="bg-red-100 text-[#888888]">style</div>
`

document.getElementById('app').innerHTML = main(view1)

import.meta.hot?.accept((mod) => {
  document.getElementById('app').innerHTML = mod.main(view1)
})

import.meta.hot?.accept(['./views/view1'], ([mod]) => {
  document.getElementById('app').innerHTML = main(mod.view1)
})



================================================
FILE: playground/tailwind/src/components/component1.js
================================================
export const component1 = /* html */ `
  <div id="component1" data-id="component1" class="text-red-600">component1</div>
`

import.meta.hot?.accept((mod) => {
  document.querySelectorAll('[data-id="component1"]').forEach((d) => {
    d.outerHTML = mod.component1
  })
})



================================================
FILE: playground/tailwind/src/views/view1.js
================================================
import { component1 } from '../components/component1'

export const view1 = /* html */ `
  <div data-id="view1">
    <div id="view1-text" class="text-green-600">|view1|</div>
    ${component1}
  </div>
`



================================================
FILE: playground/tailwind-sourcemap/index.html
================================================
<div class="wrapper">
  <h1>Tailwind Sourcemap</h1>

  <p class="text-red-400">foo</p>
</div>

<script type="module">
  import './tailwind.css'
</script>



================================================
FILE: playground/tailwind-sourcemap/package.json
================================================
{
  "name": "@vitejs/test-tailwind-sourcemap",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.1.11",
    "tailwindcss": "^4.1.11"
  }
}



================================================
FILE: playground/tailwind-sourcemap/postcss.config.js
================================================
export default {
  plugins: {
    // using postcss tailwind as we want to test postcss integration
    '@tailwindcss/postcss': {},
  },
}



================================================
FILE: playground/tailwind-sourcemap/tailwind.css
================================================
@import 'tailwindcss';



================================================
FILE: playground/tailwind-sourcemap/vite.config.js
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  css: {
    devSourcemap: true,
  },
  build: {
    sourcemap: true,
  },
})



================================================
FILE: playground/tailwind-sourcemap/__tests__/tailwind-sourcemap.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, serverLogs } from '~utils'

test.runIf(!isBuild)('should not output missing source file warning', () => {
  serverLogs.forEach((log) => {
    expect(log).not.toMatch(/Sourcemap for .+ points to missing source files/)
  })
})

test.runIf(isBuild)('should not output sourcemap warning (#4939)', () => {
  serverLogs.forEach((log) => {
    expect(log).not.toMatch('Sourcemap is likely to be incorrect')
  })
})



================================================
FILE: playground/tailwind-v3/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;



================================================
FILE: playground/tailwind-v3/index.html
================================================
<link rel="stylesheet" href="./index.css" />

<div id="app"></div>

<script type="module" src="/src/main.js" defer></script>



================================================
FILE: playground/tailwind-v3/package.json
================================================
{
  "name": "@vitejs/test-tailwind-v3",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  },
  "dependencies": {
    "autoprefixer": "^10.4.21",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "tsx": "^4.20.3"
  }
}



================================================
FILE: playground/tailwind-v3/postcss.config.js
================================================
// postcss.config.ts
import { fileURLToPath } from 'node:url'

export default {
  plugins: {
    tailwindcss: {
      config: fileURLToPath(new URL('./tailwind.config.ts', import.meta.url)),
    },
    autoprefixer: {},
  },
}



================================================
FILE: playground/tailwind-v3/tailwind.config.ts
================================================
import type { Config } from 'tailwindcss'

export default {
  content: [
    // Before editing this section, make sure no paths are matching with `/src/main.js`
    // Look https://github.com/vitejs/vite/pull/6959 for more details
    __dirname + '/src/{components,views}/**/*.js',
    __dirname + '/src/main.js',
  ],
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
} satisfies Config



================================================
FILE: playground/tailwind-v3/vite.config.ts
================================================
import { defineConfig } from 'vite'
import type { Plugin } from 'vite'

function delayIndexCssPlugin(): Plugin {
  let server
  return {
    name: 'delay-index-css',
    enforce: 'pre',
    configureServer(_server) {
      server = _server
    },
    async load(id) {
      if (server && id.includes('index.css')) {
        await server.waitForRequestsIdle(id)
      }
    },
  }
}

export default defineConfig({
  resolve: {
    alias: {
      '/@': __dirname,
    },
  },
  build: {
    // to make tests faster
    minify: false,
  },
  plugins: [
    {
      name: 'delay view',
      enforce: 'pre',
      async transform(_code, id) {
        if (id.includes('views/view1.js')) {
          await new Promise((resolve) => setTimeout(resolve, 100))
        }
      },
    },
    delayIndexCssPlugin(),
  ],
})



================================================
FILE: playground/tailwind-v3/__test__/tailwind-v3.spec.ts
================================================
import { expect, test } from 'vitest'
import { editFile, getColor, isServe, page, untilBrowserLogAfter } from '~utils'

test('should render', async () => {
  expect(await page.textContent('#pagetitle')).toBe('Page title')
})

test.runIf(isServe)('regenerate CSS and HMR (glob pattern)', async () => {
  const el = page.locator('#view1-text')
  expect(await getColor(el)).toBe('rgb(22, 163, 74)')

  await untilBrowserLogAfter(
    () =>
      editFile('src/views/view1.js', (code) =>
        code.replace('|view1|', '|view1 updated|'),
      ),
    [
      '[vite] css hot updated: /index.css',
      '[vite] hot updated: /src/views/view1.js via /src/main.js',
    ],
    false,
  )
  await expect.poll(() => el.textContent()).toMatch('|view1 updated|')

  await untilBrowserLogAfter(
    () =>
      editFile('src/views/view1.js', (code) =>
        code.replace('text-green-600', 'text-orange-600'),
      ),
    [
      '[vite] css hot updated: /index.css',
      '[vite] hot updated: /src/views/view1.js via /src/main.js',
    ],
    false,
  )
  await expect.poll(() => getColor(el)).toBe('rgb(234, 88, 12)')
})

test.runIf(isServe)(
  'same file duplicated in module graph (#4267)',
  async () => {
    const el = page.locator('#component1')
    expect(await getColor(el)).toBe('rgb(220, 38, 38)')

    // when duplicated, page reload happens
    await untilBrowserLogAfter(
      () =>
        editFile('src/components/component1.js', (code) =>
          code.replace('text-red-600', 'text-blue-600'),
        ),
      [
        '[vite] css hot updated: /index.css',
        '[vite] hot updated: /src/components/component1.js',
      ],
      false,
    )
    await expect.poll(() => getColor(el)).toBe('rgb(37, 99, 235)')
  },
)

test.runIf(isServe)('regenerate CSS and HMR (relative path)', async () => {
  const el = page.locator('#pagetitle')
  expect(await getColor(el)).toBe('rgb(124, 58, 237)')

  await untilBrowserLogAfter(
    () =>
      editFile('src/main.js', (code) =>
        code.replace('text-violet-600', 'text-cyan-600'),
      ),
    ['[vite] css hot updated: /index.css', '[vite] hot updated: /src/main.js'],
    false,
  )
  await expect.poll(() => getColor(el)).toBe('rgb(8, 145, 178)')
})



================================================
FILE: playground/tailwind-v3/src/main.js
================================================
import { view1 } from './views/view1'

export const main = (view1Content) => /* html */ `
  <h1 id="pagetitle" class="text-3xl text-violet-600">Page title</h1>
  ${view1Content}
  <!-- used in postcss-plugins-different-dir -->
  <div id="tailwind-style" class="bg-red-100 text-[#888888]">style</div>
`

document.getElementById('app').innerHTML = main(view1)

import.meta.hot?.accept((mod) => {
  document.getElementById('app').innerHTML = mod.main(view1)
})

import.meta.hot?.accept(['./views/view1'], ([mod]) => {
  document.getElementById('app').innerHTML = main(mod.view1)
})



================================================
FILE: playground/tailwind-v3/src/components/component1.js
================================================
export const component1 = /* html */ `
  <div id="component1" data-id="component1" class="text-red-600">component1</div>
`

import.meta.hot?.accept((mod) => {
  document.querySelectorAll('[data-id="component1"]').forEach((d) => {
    d.outerHTML = mod.component1
  })
})



================================================
FILE: playground/tailwind-v3/src/views/view1.js
================================================
import { component1 } from '../components/component1'

export const view1 = /* html */ `
  <div data-id="view1">
    <div id="view1-text" class="text-green-600">|view1|</div>
    ${component1}
  </div>
`



================================================
FILE: playground/transform-plugin/index.html
================================================
<div id="transform-count"></div>

<script type="module" src="./index.js"></script>



================================================
FILE: playground/transform-plugin/index.js
================================================
// 'TRANSFORM_COUNT' is injected by the transform plugin
document.getElementById('transform-count').innerHTML = TRANSFORM_COUNT



================================================
FILE: playground/transform-plugin/package.json
================================================
{
  "name": "@vitejs/test-transform-plugin",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../vite/bin/vite",
    "serve": "vite preview"
  }
}



================================================
FILE: playground/transform-plugin/plugin-dep-load.js
================================================
// Empty file for detecting changes in tests



================================================
FILE: playground/transform-plugin/plugin-dep.js
================================================
// Empty file for detecting changes in tests



================================================
FILE: playground/transform-plugin/vite.config-base.js
================================================
import { defineConfig } from 'vite'
import baseConfig from './vite.config.js'

export default defineConfig({
  ...baseConfig,
  base: '/vite/',
})



================================================
FILE: playground/transform-plugin/vite.config.js
================================================
import { resolve } from 'node:path'
import { defineConfig, normalizePath } from 'vite'

const file = normalizePath(resolve(__dirname, 'index.js'))
let transformCount = 1

const transformPlugin = {
  name: 'transform',
  load(id) {
    if (id === file) {
      // Ensure `index.js` is reloaded if 'plugin-dep-load.js' is changed
      this.addWatchFile('./plugin-dep-load.js')
    }
  },
  transform(code, id) {
    if (id === file) {
      // Ensure `index.js` is reevaluated if 'plugin-dep.js' is changed
      this.addWatchFile('./plugin-dep.js')

      return `
        // Inject TRANSFORM_COUNT
        let TRANSFORM_COUNT = ${transformCount++};

        ${code}
      `
    }
  },
}

export default defineConfig({
  plugins: [transformPlugin],
})



================================================
FILE: playground/transform-plugin/__tests__/tests.ts
================================================
import { expect, test } from 'vitest'
import { editFile, isBuild, page } from '~utils'

export const tests = () => {
  test('should re-run transform when dependencies are edited', async () => {
    expect(await page.textContent('#transform-count')).toBe('1')

    if (isBuild) return
    editFile('plugin-dep.js', (str) => str)
    await expect.poll(() => page.textContent('#transform-count')).toBe('2')

    editFile('plugin-dep-load.js', (str) => str)
    await expect.poll(() => page.textContent('#transform-count')).toBe('3')
  })
}



================================================
FILE: playground/transform-plugin/__tests__/transform-plugin.spec.ts
================================================
import { tests } from './tests'

tests()



================================================
FILE: playground/transform-plugin/__tests__/base/transform-plugin.spec.ts
================================================
// NOTE: a separate directory from `playground/transform-plugin` is created by playground/vitestGlobalSetup.ts
import { tests } from '../tests'

tests()



================================================
FILE: playground/tsconfig-json/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"><!--app-html--></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: playground/tsconfig-json/package.json
================================================
{
  "name": "@vitejs/test-tsconfig-json",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/tsconfig-json/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext", "DOM"],
    "moduleResolution": "bundler",
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,

    "useDefineForClassFields": true,
    "verbatimModuleSyntax": true,
    "experimentalDecorators": true
  },
  "include": ["./src"]
}



================================================
FILE: playground/tsconfig-json/__tests__/tsconfig-json.spec.ts
================================================
import path from 'node:path'
import fs from 'node:fs'
import { transformWithEsbuild } from 'vite'
import { describe, expect, test } from 'vitest'
import { browserLogs, isServe, serverLogs } from '~utils'

test('should respected each `tsconfig.json`s compilerOptions', () => {
  // main side effect should be called (because of `"verbatimModuleSyntax": true`)
  expect(browserLogs).toContain('main side effect')
  // main base setter should not be called (because of `"useDefineForClassFields": true"`)
  expect(browserLogs).not.toContain('data setter in MainBase')

  // nested side effect should not be called (because "verbatimModuleSyntax" is not set, defaults to false)
  expect(browserLogs).not.toContain('nested side effect')
  // nested base setter should be called (because of `"useDefineForClassFields": false"`)
  expect(browserLogs).toContain('data setter in NestedBase')

  // nested-with-extends side effect should be called (because "verbatimModuleSyntax" is extended from the main tsconfig.json, which is true)
  expect(browserLogs).toContain('nested-with-extends side effect')
  // nested-with-extends base setter should be called (because of `"useDefineForClassFields": false"`)
  expect(browserLogs).toContain('data setter in NestedWithExtendsBase')
})

test.runIf(isServe)('scanner should not error with decorators', () => {
  expect(serverLogs).not.toStrictEqual(
    expect.arrayContaining([
      expect.stringContaining(
        'Parameter decorators only work when experimental decorators are enabled',
      ),
    ]),
  )
})

describe('transformWithEsbuild', () => {
  test('merge tsconfigRaw object', async () => {
    const main = path.resolve(__dirname, '../src/main.ts')
    const mainContent = fs.readFileSync(main, 'utf-8')
    const result = await transformWithEsbuild(mainContent, main, {
      tsconfigRaw: {
        compilerOptions: {
          useDefineForClassFields: false,
        },
      },
    })
    // "verbatimModuleSyntax": true from tsconfig.json should still work
    expect(result.code).toMatch(/import.*".\/not-used-type";/)
  })

  test('overwrite tsconfigRaw string', async () => {
    const main = path.resolve(__dirname, '../src/main.ts')
    const mainContent = fs.readFileSync(main, 'utf-8')
    const result = await transformWithEsbuild(mainContent, main, {
      tsconfigRaw: `{
        "compilerOptions": {
          "useDefineForClassFields": false
        }
      }`,
    })
    // "verbatimModuleSyntax": true from tsconfig.json should not be read
    // and defaults to false
    expect(result.code).not.toMatch(/import.*".\/not-used-type";/)
  })

  test('verbatimModuleSyntax', async () => {
    const main = path.resolve(__dirname, '../src/main.ts')
    const mainContent = fs.readFileSync(main, 'utf-8')
    const result = await transformWithEsbuild(mainContent, main, {
      tsconfigRaw: {
        compilerOptions: {
          useDefineForClassFields: false,
          verbatimModuleSyntax: false,
        },
      },
    })
    // "verbatimModuleSyntax": false from tsconfig.json should still work
    expect(result.code).not.toMatch(/import.*".\/not-used-type";/)
  })

  test('experimentalDecorators', async () => {
    const main = path.resolve(__dirname, '../src/decorator.ts')
    const mainContent = fs.readFileSync(main, 'utf-8')
    // Should not error when transpiling decorators as nearest tsconfig.json
    // has "experimentalDecorators": true
    const result = await transformWithEsbuild(mainContent, main, {
      target: 'es2020',
    })
    expect(result.code).toContain('__decorateClass')
  })
})



================================================
FILE: playground/tsconfig-json/nested/main.ts
================================================
// @ts-nocheck
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NestedTypeOnlyClass } from './not-used-type'

class NestedBase {
  set data(value: string) {
    console.log('data setter in NestedBase')
  }
}
class NestedDerived extends NestedBase {
  // No longer triggers a 'console.log'
  // when using 'useDefineForClassFields'.
  data = 10

  foo?: NestedTypeOnlyClass
}

const d = new NestedDerived()



================================================
FILE: playground/tsconfig-json/nested/not-used-type.ts
================================================
console.log('nested side effect')

export class NestedTypeOnlyClass {}



================================================
FILE: playground/tsconfig-json/nested/tsconfig.json
================================================
// prettier-ignore
{
  "include": ["./"],
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext", "DOM"],
    "moduleResolution": "bundler",
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,

    /* tsconfig.json should support comments and trailing comma */
    "useDefineForClassFields": false,
  }
}



================================================
FILE: playground/tsconfig-json/nested-with-extends/main.ts
================================================
// @ts-nocheck
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NestedWithExtendsTypeOnlyClass } from './not-used-type'

class NestedWithExtendsBase {
  set data(value: string) {
    console.log('data setter in NestedWithExtendsBase')
  }
}
class NestedWithExtendsDerived extends NestedWithExtendsBase {
  // No longer triggers a 'console.log'
  // when using 'useDefineForClassFields'.
  data = 10

  foo?: NestedWithExtendsTypeOnlyClass
}

const d = new NestedWithExtendsDerived()



================================================
FILE: playground/tsconfig-json/nested-with-extends/not-used-type.ts
================================================
console.log('nested-with-extends side effect')

export class NestedWithExtendsTypeOnlyClass {}



================================================
FILE: playground/tsconfig-json/nested-with-extends/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "include": ["./"],
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}



================================================
FILE: playground/tsconfig-json/src/decorator.ts
================================================
// @ts-nocheck playground/tsconfig.json does not have decorators enabled
function first() {
  return function (...args: any[]) {}
}

export class Foo {
  @first()
  method(@first() test: string) {
    return test
  }
}



================================================
FILE: playground/tsconfig-json/src/main.ts
================================================
// @ts-nocheck
import '../nested/main'
import '../nested-with-extends/main'
import './decorator'

// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { MainTypeOnlyClass } from './not-used-type'

class MainBase {
  set data(value: string) {
    console.log('data setter in MainBase')
  }
}
class MainDerived extends MainBase {
  // No longer triggers a 'console.log'
  // when using 'useDefineForClassFields'.
  data = 10

  foo?: MainTypeOnlyClass
}

const d = new MainDerived()



================================================
FILE: playground/tsconfig-json/src/not-used-type.ts
================================================
console.log('main side effect')

export class MainTypeOnlyClass {}



================================================
FILE: playground/tsconfig-json-load-error/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"><!--app-html--></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: playground/tsconfig-json-load-error/package.json
================================================
{
  "name": "@vitejs/test-tsconfig-json-load-error",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/tsconfig-json-load-error/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext", "DOM"],
    "moduleResolution": "bundler",
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,

    "useDefineForClassFields": true,
    "verbatimModuleSyntax": true
  },
  "include": ["./src"]
}



================================================
FILE: playground/tsconfig-json-load-error/__tests__/serve.ts
================================================
import { afterAll } from 'vitest'
import { startDefaultServe } from '~utils'

export let serveError: Error | undefined

export async function serve() {
  try {
    await startDefaultServe()
  } catch (e) {
    serveError = e
  }
}

export function clearServeError() {
  serveError = undefined
}

afterAll(() => {
  if (serveError) {
    throw serveError
  }
})



================================================
FILE: playground/tsconfig-json-load-error/__tests__/tsconfig-json-load-error.spec.ts
================================================
import { describe, expect, test } from 'vitest'
import { clearServeError, serveError } from './serve'
import { browserLogs, editFile, isBuild, isServe, page, readFile } from '~utils'

const unexpectedTokenSyntaxErrorRE =
  /(\[vite:esbuild\] )*parsing .* failed: SyntaxError: Unexpected token.*\}.*/

describe.runIf(isBuild)('build', () => {
  test('should throw an error on build', () => {
    expect(serveError).toBeTruthy()
    expect(serveError.message).toMatch(unexpectedTokenSyntaxErrorRE)
    clearServeError() // got expected error, null it here so testsuite does not fail from rethrow in afterAll
  })

  test('should not output files to dist', () => {
    let err
    try {
      readFile('dist/index.html')
    } catch (e) {
      err = e
    }
    expect(err).toBeTruthy()
    expect(err.code).toBe('ENOENT')
  })
})

describe.runIf(isServe)('server', () => {
  test('should log 500 error in browser for malformed tsconfig', () => {
    // don't test for actual complete message as this might be locale dependent. chrome does log 500 consistently though
    expect(browserLogs.find((x) => x.includes('500'))).toBeTruthy()
    expect(browserLogs).not.toContain('tsconfig error fixed, file loaded')
  })

  test('should show error overlay for tsconfig error', async () => {
    const errorOverlay = await page.waitForSelector('vite-error-overlay')
    expect(errorOverlay).toBeTruthy()
    const message = await errorOverlay.$$eval('.message-body', (m) => {
      return m[0].innerHTML
    })
    // use regex with variable filename and position values because they are different on win
    expect(message).toMatch(unexpectedTokenSyntaxErrorRE)
  })

  test('should reload when tsconfig is changed', async () => {
    editFile('has-error/tsconfig.json', (content) => {
      return content.replace('"compilerOptions":', '"compilerOptions":{}')
    })
    await expect
      .poll(() => browserLogs)
      .toContain('tsconfig error fixed, file loaded')
  })
})



================================================
FILE: playground/tsconfig-json-load-error/has-error/main.ts
================================================
console.log('tsconfig error fixed, file loaded')



================================================
FILE: playground/tsconfig-json-load-error/has-error/tsconfig.json
================================================
{
  // this config is deliberately malformed to test how vite handles broken tsconfig
  "compilerOptions":
}


================================================
FILE: playground/tsconfig-json-load-error/src/main.ts
================================================
// @ts-nocheck
import '../has-error/main'



================================================
FILE: playground/wasm/add.wasm
================================================
 asm   `    add  add2 add3 add4 
!    j    j    j    j


================================================
FILE: playground/wasm/heavy.wasm
================================================
[Binary file]


================================================
FILE: playground/wasm/index.html
================================================
<h1>Web Assembly</h1>

<div class="inline-wasm">
  <h3>When wasm is inline, result should be 42</h3>
  <button class="run">Click to run</button>
  <span class="result"></span>
</div>

<div class="output-wasm">
  <h3>When wasm is output, result should be 24</h3>
  <button class="run">Click to run</button>
  <span class="result"></span>
</div>

<div class="init-returns-instance">
  <h3>init function returns WebAssembly.Instance</h3>
  <button class="run">Click to run</button>
  <span class="result"></span>
</div>

<div>
  <h3>Importing as URL</h3>
  <span class="url"></span>
</div>

<div class="worker-wasm">
  <h3>worker wasm</h3>
  <span class="result"></span>
</div>

<script type="module">
  import light from './light.wasm?init'
  import heavy from './heavy.wasm?init'
  import myWorker from './worker?worker'

  const w = new myWorker()
  w.addEventListener('message', (ev) => {
    text('.worker-wasm .result', ev.data.result)
  })

  async function testWasm(init, resultElement) {
    const { exported_func } = await init({
      imports: {
        imported_func: (res) => (resultElement.textContent = res),
      },
    }).then((i) => i.exports)
    exported_func()
  }

  function text(el, text) {
    document.querySelector(el).textContent = text
  }

  document
    .querySelector('.inline-wasm .run')
    .addEventListener('click', async () =>
      testWasm(light, document.querySelector('.inline-wasm .result')),
    )

  document
    .querySelector('.output-wasm .run')
    .addEventListener('click', async () =>
      testWasm(heavy, document.querySelector('.output-wasm .result')),
    )

  document
    .querySelector('.init-returns-instance .run')
    .addEventListener('click', async () => {
      const res = await light({
        imports: {
          imported_func: (res) => (resultElement.textContent = res),
        },
      })
      text(
        '.init-returns-instance .result',
        res instanceof WebAssembly.Instance,
      )
    })

  import lightUrl from './light.wasm?url'
  text('.url', lightUrl)
</script>



================================================
FILE: playground/wasm/light.wasm
================================================
 asm   ` `  imports
imported_func  
exported_func 
 A* 


================================================
FILE: playground/wasm/package.json
================================================
{
  "name": "@vitejs/test-wasm",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite",
    "preview": "vite preview"
  }
}



================================================
FILE: playground/wasm/vite.config.ts
================================================
import { defineConfig } from 'vite'
export default defineConfig({
  build: {
    // make cannot emit light.wasm
    // and emit add.wasm
    assetsInlineLimit: 80,
  },
})



================================================
FILE: playground/wasm/worker.js
================================================
import init from './add.wasm?init'
init().then(({ exports }) => {
  self.postMessage({ result: exports.add(1, 2) })
})



================================================
FILE: playground/wasm/__tests__/wasm.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page } from '~utils'

test('should work when inlined', async () => {
  await page.click('.inline-wasm .run')
  await expect
    .poll(() => page.textContent('.inline-wasm .result'))
    .toMatch('42')
})

test('should work when output', async () => {
  await page.click('.output-wasm .run')
  await expect
    .poll(() => page.textContent('.output-wasm .result'))
    .toMatch('24')
})

test('init function returns WebAssembly.Instance', async () => {
  await page.click('.init-returns-instance .run')
  await expect
    .poll(() => page.textContent('.init-returns-instance .result'))
    .toMatch('true')
})

test('?url', async () => {
  expect(await page.textContent('.url')).toMatch(
    isBuild ? 'data:application/wasm' : '/light.wasm',
  )
})

test('should work when wasm in worker', async () => {
  await expect.poll(() => page.textContent('.worker-wasm .result')).toMatch('3')
})



================================================
FILE: playground/worker/classic-esm.js
================================================
export const msg = '[success] classic-esm'



================================================
FILE: playground/worker/classic-shared-worker.js
================================================
let base = `/${self.location.pathname.split('/')[1]}`
if (base.endsWith('.js') || base === `/worker-entries`) base = '' // for dev

importScripts(`${base}/classic.js`)

self.onconnect = (event) => {
  const port = event.ports[0]
  port.postMessage(self.constant)
}

// for sourcemap
console.log('classic-shared-worker.js')



================================================
FILE: playground/worker/classic-worker.js
================================================
(() => {})() // this is to test `importScripts` injection doesn't break the code

let base = `/${self.location.pathname.split('/')[1]}`
if (base.endsWith('.js') || base === `/worker-entries`) base = '' // for dev

importScripts(`${base}/classic.js`)

self.addEventListener('message', async (e) => {
  switch (e.data) {
    case 'ping': {
      self.postMessage({
        message: e.data,
        result: self.constant,
      })
      break
    }
    case 'test-import': {
      // Vite may inject imports to handle this dynamic import, make sure
      // it still works in classic workers.
      // NOTE: this test only works in dev.
      const importPath = `${base}/classic-esm.js`
      const { msg } = await import(/* @vite-ignore */ importPath)
      self.postMessage({
        message: e.data,
        result: msg,
      })
      break
    }
  }
})

// for sourcemap
console.log('classic-worker.js')



================================================
FILE: playground/worker/deeply-nested-second-worker.js
================================================
self.postMessage({
  type: 'deeplyNestedSecondWorker',
  data: [
    'Hello from second level nested worker',
    import.meta.env.BASE_URL,
    self.location.url,
    import.meta.url,
  ].join(' '),
})

const deeplyNestedThirdWorker = new Worker(
  new URL('deeply-nested-third-worker.js', import.meta.url),
  { type: 'module' },
)
deeplyNestedThirdWorker.addEventListener('message', (ev) => {
  self.postMessage(ev.data)
})

console.log('deeply-nested-second-worker.js')



================================================
FILE: playground/worker/deeply-nested-third-worker.js
================================================
self.postMessage({
  type: 'deeplyNestedThirdWorker',
  data: [
    'Hello from third level nested worker',
    import.meta.env.BASE_URL,
    self.location.url,
    import.meta.url,
  ].join(' '),
})

console.log('deeply-nested-third-worker.js')



================================================
FILE: playground/worker/deeply-nested-worker.js
================================================
self.postMessage({
  type: 'deeplyNestedWorker',
  data: [
    'Hello from root worker',
    import.meta.env.BASE_URL,
    self.location.url,
    import.meta.url,
  ].join(' '),
})

const deeplyNestedSecondWorker = new Worker(
  new URL('deeply-nested-second-worker.js', import.meta.url),
  { type: 'module' },
)
deeplyNestedSecondWorker.addEventListener('message', (ev) => {
  self.postMessage(ev.data)
})

console.log('deeply-nested-worker.js')



================================================
FILE: playground/worker/emit-chunk-dynamic-import-worker.js
================================================
import module1Url from './modules/module1.js?url'

import('./modules/module0').then((module) => {
  import(/* @vite-ignore */ module1Url).then((module1) => {
    self.postMessage(module.default + module1.msg1 + import.meta.env.BASE_URL)
  })
})

// for sourcemap
console.log('emit-chunk-dynamic-import-worker.js')



================================================
FILE: playground/worker/emit-chunk-nested-worker.js
================================================
import SubWorker from './emit-chunk-sub-worker?worker'
const subWorker = new SubWorker()

subWorker.onmessage = (event) => {
  self.postMessage({
    type: 'emit-chunk-sub-worker',
    data: event.data,
  })
}

const moduleWorker = new Worker(
  new URL('./module-and-worker.js', import.meta.url),
  { type: 'module' },
)

moduleWorker.onmessage = (event) => {
  self.postMessage({
    type: 'module-and-worker:worker',
    data: event.data,
  })
}

import('./module-and-worker').then((res) => {
  self.postMessage({
    type: 'module-and-worker:module',
    data: res.module,
  })
})

// for sourcemap
console.log('emit-chunk-nested-worker.js')



================================================
FILE: playground/worker/emit-chunk-sub-worker.js
================================================
Promise.all([
  import('./module-and-worker'),
  import('./modules/module2'),
  import('./modules/module3'),
]).then((data) => {
  const _data = { ...data[0], ...data[1], ...data[2] }
  self.postMessage(_data)
})

// for sourcemap
console.log('emit-chunk-sub-worker.js')



================================================
FILE: playground/worker/importMetaGlob.worker.js
================================================
const modules = import.meta.glob('./modules/*js')

self.onmessage = function (e) {
  self.postMessage(Object.keys(modules))
}

// for sourcemap
console.log('importMetaGlob.worker.js')



================================================
FILE: playground/worker/importMetaGlobEager.worker.js
================================================
const modules = import.meta.glob('./modules/*js', { eager: true })

self.onmessage = function (e) {
  self.postMessage(Object.keys(modules))
}

// for sourcemap
console.log('importMetaGlobEager.worker.js')



================================================
FILE: playground/worker/index.html
================================================
<h2 class="format-iife">format iife:</h2>
<div>Expected values: <span class="mode-true"></span></div>

<p>worker template error match:</p>
<code>
  const worker = new Worker(new URL('./worker.js', import.meta.url))
</code>

<p>
  import myWorker from '../my-worker?worker'
  <span class="classname">.pong</span>
  <span class="classname">.mode</span>
  <span class="classname">.bundle-with-plugin</span>
  <span class="classname">.asset-url</span>
</p>
<div>
  <div>Response from worker: <span class="pong"></span></div>
  <div>mode: <span class="mode"></span></div>
  <div>bundle-with-plugin: <span class="bundle-with-plugin"></span></div>
  <div>asset-url: <span class="asset-url"></span></div>
  <div>dep-cjs: <span class="dep-cjs"></span></div>
</div>

<p>
  import myWorker from '../my-worker?worker'
  <span>new myWorker({ name: "named-worker" })</span>
  <span class="classname">.pong-named</span>
</p>
<div>
  <div>Response from worker: <span class="pong-named"></span></div>
</div>

<p>
  import InlineWorker from '../my-worker?worker&inline'
  <span class="classname">.pong-inline</span>
</p>
<code class="pong-inline"></code>

<p>
  import InlineWorker from '../my-worker?worker&inline'
  <span>new InlineWorker({ name: "named-inline-worker" })</span>
  <span class="classname">.pong-inline-named</span>
</p>
<code class="pong-inline-named"></code>

<p>
  import InlineWorker from '../my-worker?worker&inline'
  <span>new InlineWorker()</span>
  <span>import.meta.url</span>
  <span class="classname">.pong-inline-url</span>
</p>
<code class="pong-inline-url"></code>

<p>
  import InlineWorker from '../my-worker?worker&inline'
  <span class="classname">.pong-inline-unicode</span>
</p>
<code class="pong-inline-unicode"></code>

<p>
  import TSOutputWorker from '../possible-ts-output-worker?worker'
  <span class="classname">.pong-ts-output</span>
</p>
<code class="pong-ts-output"></code>

<p>
  import mySharedWorker from '../my-shared-worker?sharedworker&name=shared'
  <span class="classname">.tick-count</span>
</p>
<code class="tick-count"></code>

<p>
  import mySharedWorker from '../my-shared-worker?sharedworker&name=shared'
  <span>new mySharedWorker({ name: "namedSharedWorker" })</span>
  <span class="classname">.tick-count-named</span>
</p>
<code class="tick-count-named"></code>

<p>
  import InlineSharedWorker from '../my-shared-worker?sharedworker&inline'
  <span class="classname">.pong-shared-inline</span>
</p>
<code class="pong-shared-inline"></code>

<p>
  new Worker(new URL('./url-worker.js', import.meta.url), { type: 'module' })
  <span class="classname">.worker-import-meta-url</span>
</p>
<code class="worker-import-meta-url"></code>

<p>
  new Worker(new URL('@/url-worker', import.meta.url), { type: 'module' })
  <span class="classname">.worker-import-meta-url-resolve</span>
</p>
<code class="worker-import-meta-url-resolve"></code>

<p>
  new Worker(new URL('./url-worker', import.meta.url), { type: 'module' })
  <span class="classname">.worker-import-meta-url-without-extension</span>
</p>
<code class="worker-import-meta-url-without-extension"></code>

<p>
  new SharedWorker(new URL('./url-shared-worker.js', import.meta.url), { type:
  'module' })
  <span class="classname">.shared-worker-import-meta-url</span>
</p>
<code class="shared-worker-import-meta-url"></code>

<p>
  import NestedWorker from './worker-nested-worker?worker' - import.meta.url
  <span class="classname">.nested-worker</span>
</p>
<code class="nested-worker"></code>

<p>
  import NestedWorker from './worker-nested-worker?worker' - nested module
  worker
  <span class="classname">.nested-worker-module</span>
</p>
<code class="nested-worker-module"></code>

<p>
  import NestedWorker from './worker-nested-worker?worker' - nested worker
  constructor
  <span class="classname">.nested-worker-constructor</span>
</p>
<code class="nested-worker-constructor"></code>

<p>
  new Worker(new URL('./classic-worker.js', import.meta.url))
  <span class="classname">.classic-worker</span>
</p>
<code class="classic-worker"></code>
<code class="classic-worker-import"></code>

<p>
  new SharedWorker(new URL('./classic-shared-worker.js', import.meta.url), {
  type: 'classic' })
  <span class="classname">.classic-shared-worker</span>
</p>
<code class="classic-shared-worker"></code>

<p>
  new Worker(new URL('../simple-worker.js', import.meta.url).href)
  <span class="classname">.simple-worker-url</span>
</p>
<code class="simple-worker-url"></code>

<p>
  use import.meta.glob with eager in iife worker
  <span class="classname">.importMetaGlobEager-worker</span>
</p>
<code class="importMetaGlobEager-worker"></code>

<p>
  self reference worker
  <span class="classname">.self-reference-worker</span>
</p>
<code class="self-reference-worker"></code>

<p>
  new Worker(new URL('../self-reference-url-worker.js', import.meta.url))
  <span class="classname">.self-reference-url-worker</span>
</p>
<code class="self-reference-url-worker"></code>

<p>
  <span class="classname">.self-reference-url-worker-dep</span>
</p>
<code class="self-reference-url-worker-dep"></code>

<p>
  new Worker(new URL('../deeply-nested-worker.js', import.meta.url), { type:
  'module' })
  <span class="classname">.deeply-nested-worker</span>
</p>
<code class="deeply-nested-worker"></code>

<p>
  new Worker(new URL('deeply-nested-second-worker.js', import.meta.url), { type:
  'module' })
  <span class="classname">.deeply-nested-second-worker</span>
</p>
<code class="deeply-nested-second-worker"></code>

<p>
  new Worker(new URL('deeply-nested-third-worker.js', import.meta.url), { type:
  'module' })
  <span class="classname">.deeply-nested-third-worker</span>
</p>
<code class="deeply-nested-third-worker"></code>

<hr />

<h2 class="format-es"></h2>

<p>
  use import.meta.glob in es worker
  <span class="classname">.importMetaGlob-worker</span>
</p>
<code class="importMetaGlob-worker"></code>

<p>
  worker emit chunk <br />
  module and worker:worker in worker file <br />
  module and worker:module in worker file <br />
  <span class="classname">.emit-chunk-worker</span>
</p>
<code class="emit-chunk-worker"></code>

<p>
  worker dynamic import to emit chunk
  <span class="classname">.emit-chunk-dynamic-import-worker</span>
</p>
<code class="emit-chunk-dynamic-import-worker"></code>

<p>
  module and worker:worker in simple file
  <span class="classname">.module-and-worker-worker</span>
</p>
<code class="module-and-worker-worker"></code>

<style>
  p {
    background: rgba(0, 0, 0, 0.1);
  }
  .classname {
    color: green;
  }
</style>
<script type="module" src="./worker/main.js"></script>



================================================
FILE: playground/worker/module-and-worker.js
================================================
import constant from './modules/module0'

self.postMessage(constant)

export const module = 'module and worker'

// for sourcemap
console.log('module-and-worker.js')



================================================
FILE: playground/worker/my-inline-shared-worker.ts
================================================
let inlineSharedWorkerCount = 0

// @ts-expect-error onconnect exists in worker
self.onconnect = (event) => {
  inlineSharedWorkerCount++
  const port = event.ports[0]
  if (inlineSharedWorkerCount >= 2) {
    port.postMessage('pong')
  }
}

// for sourcemap
console.log('my-inline-shared-worker.js')



================================================
FILE: playground/worker/my-shared-worker.ts
================================================
let sharedWorkerCount = 0

// @ts-expect-error onconnect exists in worker
self.onconnect = (event) => {
  sharedWorkerCount++
  const port = event.ports[0]
  if (sharedWorkerCount >= 2) {
    port.postMessage('pong')
  }
}

// for sourcemap
console.log('my-shared-worker.js')



================================================
FILE: playground/worker/my-worker.ts
================================================
import { msg as msgFromDep } from '@vitejs/test-dep-to-optimize'
import depCjs from '@vitejs/test-worker-dep-cjs'
import { mode, msg } from './modules/workerImport.js'
import { bundleWithPlugin } from './modules/test-plugin'
import viteSvg from './vite.svg'
const metaUrl = import.meta.url

self.onmessage = (e) => {
  if (e.data === 'ping') {
    self.postMessage({
      msg,
      mode,
      bundleWithPlugin,
      viteSvg,
      metaUrl,
      name,
      depCjs,
    })
  }
  if (e.data === 'ping-unicode') {
    self.postMessage({
      msg: '•pong•',
      mode,
      bundleWithPlugin,
      viteSvg,
      metaUrl,
      name,
      depCjs,
    })
  }
}
self.postMessage({
  msg,
  mode,
  bundleWithPlugin,
  msgFromDep,
  viteSvg,
  metaUrl,
  name,
  depCjs,
})

// for sourcemap
console.log('my-worker.js')



================================================
FILE: playground/worker/package.json
================================================
{
  "name": "@vitejs/test-worker",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --config ./vite.config-iife.js",
    "build": "vite --config ./vite.config-iife.js build",
    "preview": "vite --config ./vite.config-iife.js preview",
    "dev:es": "vite --config ./vite.config-es.js dev",
    "build:es": "vite --config ./vite.config-es.js build",
    "preview:es": "vite --config ./vite.config-es.js preview",
    "dev:sourcemap": "WORKER_MODE=sourcemap vite --config ./vite.config-sourcemap.js dev",
    "build:sourcemap": "WORKER_MODE=sourcemap vite --config ./vite.config-sourcemap.js build",
    "preview:sourcemap": "WORKER_MODE=sourcemap vite --config ./vite.config-sourcemap.js preview",
    "dev:sourcemap-hidden": "WORKER_MODE=hidden vite --config ./vite.config-sourcemap.js dev",
    "build:sourcemap-hidden": "WORKER_MODE=hidden vite --config ./vite.config-sourcemap.js build",
    "preview:sourcemap-hidden": "WORKER_MODE=hidden vite --config ./vite.config-sourcemap.js preview",
    "dev:sourcemap-inline": "WORKER_MODE=inline vite --config ./vite.config-sourcemap.js dev",
    "build:sourcemap-inline": "WORKER_MODE=inline vite --config ./vite.config-sourcemap.js build",
    "preview:sourcemap-inline": "WORKER_MODE=inline vite --config ./vite.config-sourcemap.js preview",
    "dev:relative-base": "WORKER_MODE=inline vite --config ./vite.config-relative-base.js dev",
    "build:relative-base": "WORKER_MODE=inline vite --config ./vite.config-relative-base.js build",
    "preview:relative-base": "WORKER_MODE=inline vite --config ./vite.config-relative-base.js preview",
    "dev:relative-base-iife": "WORKER_MODE=inline vite --config ./vite.config-relative-base-iife.js dev",
    "build:relative-base-iife": "WORKER_MODE=inline vite --config ./vite.config-relative-base-iife.js build",
    "preview:relative-base-iife": "WORKER_MODE=inline vite --config ./vite.config-relative-base-iife.js preview",
    "debug": "node --inspect-brk ../../packages/vite/bin/vite"
  },
  "dependencies": {
    "@vitejs/test-dep-self-reference-url-worker": "file:./dep-self-reference-url-worker",
    "@vitejs/test-dep-to-optimize": "file:./dep-to-optimize",
    "@vitejs/test-worker-dep-cjs": "file:./dep-cjs"
  }
}



================================================
FILE: playground/worker/possible-ts-output-worker.mjs
================================================
import { mode, msg } from './modules/workerImport'

self.onmessage = (e) => {
  self.postMessage({ msg, mode })
}

self.postMessage({ msg, mode })

// for sourcemap
console.log('possible-ts-output-worker.mjs')



================================================
FILE: playground/worker/self-reference-url-worker.js
================================================
self.addEventListener('message', (e) => {
  if (e.data === 'main') {
    const selfWorker = new Worker(
      new URL('./self-reference-url-worker.js', import.meta.url),
      {
        type: 'module',
      },
    )
    selfWorker.postMessage('nested')
    selfWorker.addEventListener('message', (e) => {
      self.postMessage(e.data)
    })
  }

  self.postMessage(`pong: ${e.data}`)
})



================================================
FILE: playground/worker/self-reference-worker.js
================================================
import SelfWorker from './self-reference-worker?worker'

self.addEventListener('message', (e) => {
  if (e.data === 'main') {
    const selfWorker = new SelfWorker()
    selfWorker.postMessage('nested')
    selfWorker.addEventListener('message', (e) => {
      self.postMessage(e.data)
    })
  }

  self.postMessage(`pong: ${e.data}`)
})



================================================
FILE: playground/worker/simple-worker.js
================================================
self.postMessage('Hello from simple worker!')



================================================
FILE: playground/worker/sub-worker.js
================================================
self.onmessage = (event) => {
  if (event.data === 'ping') {
    self.postMessage(`pong ${self.location.href}`)
  }
}

// for sourcemap
console.log('sub-worker.js')



================================================
FILE: playground/worker/url-shared-worker.js
================================================
import constant from './modules/module0.js'

self.onconnect = (event) => {
  const port = event.ports[0]
  port.postMessage(constant)
}

// for sourcemap
console.log('url-shared-worker.js')



================================================
FILE: playground/worker/url-worker.js
================================================
self.postMessage(
  [
    'A string',
    import.meta.env.BASE_URL,
    self.location.url,
    import.meta && import.meta.url,
    import.meta.url,
  ].join(' '),
)

// for sourcemap
console.log('url-worker.js')



================================================
FILE: playground/worker/vite.config-es.js
================================================
import { defineConfig } from 'vite'
import workerPluginTestPlugin from './worker-plugin-test-plugin'

export default defineConfig({
  base: '/es/',
  resolve: {
    alias: {
      '@': __dirname,
    },
  },
  worker: {
    format: 'es',
    plugins: () => [workerPluginTestPlugin()],
    rollupOptions: {
      output: {
        assetFileNames: 'assets/worker_asset-[name]-[hash].[ext]',
        chunkFileNames: 'assets/worker_chunk-[name]-[hash].js',
        entryFileNames: 'assets/worker_entry-[name].js',
      },
    },
  },
  build: {
    outDir: 'dist/es',
    assetsInlineLimit: (filePath) =>
      filePath.endsWith('.svg') ? false : undefined,
    rollupOptions: {
      output: {
        assetFileNames: 'assets/[name]-[hash].[ext]',
        chunkFileNames: 'assets/[name]-[hash].js',
        entryFileNames: 'assets/[name].js',
      },
    },
  },
  plugins: [
    workerPluginTestPlugin(),
    {
      name: 'resolve-format-es',

      transform(code, id) {
        if (id.includes('main.js')) {
          return code.replace(
            `/* flag: will replace in vite config import("./format-es.js") */`,
            `import("./main-format-es")`,
          )
        }
      },
    },
  ],
  cacheDir: 'node_modules/.vite-es',
})



================================================
FILE: playground/worker/vite.config-iife.js
================================================
import { defineConfig } from 'vite'
import workerPluginTestPlugin from './worker-plugin-test-plugin'

export default defineConfig({
  base: '/iife/',
  resolve: {
    alias: {
      '@': __dirname,
    },
  },
  worker: {
    format: 'iife',
    plugins: () => [workerPluginTestPlugin()],
    rollupOptions: {
      output: {
        assetFileNames: 'assets/worker_asset-[name]-[hash].[ext]',
        chunkFileNames: 'assets/worker_chunk-[name]-[hash].js',
        // should be overwritten to worker_entry-[name] by the config-test plugin
        entryFileNames: 'assets/worker_-[name].js',
      },
    },
  },
  build: {
    outDir: 'dist/iife',
    assetsInlineLimit: (filePath) =>
      filePath.endsWith('.svg') ? false : undefined,
    manifest: true,
    rollupOptions: {
      output: {
        assetFileNames: 'assets/[name]-[hash].[ext]',
        chunkFileNames: 'assets/[name]-[hash].js',
        entryFileNames: 'assets/[name].js',
      },
    },
  },
  plugins: [
    workerPluginTestPlugin(),
    {
      name: 'config-test',
      config() {
        return {
          worker: {
            rollupOptions: {
              output: {
                entryFileNames: 'assets/worker_entry-[name].js',
              },
            },
          },
        }
      },
    },
  ],
  cacheDir: 'node_modules/.vite-iife',
  optimizeDeps: {
    exclude: ['@vitejs/test-dep-self-reference-url-worker'],
  },
})



================================================
FILE: playground/worker/vite.config-relative-base-iife.js
================================================
import { defineConfig } from 'vite'
import workerPluginTestPlugin from './worker-plugin-test-plugin'

export default defineConfig(({ isPreview }) => ({
  base: !isPreview ? './' : '/relative-base-iife/',
  resolve: {
    alias: {
      '@': __dirname,
    },
  },
  worker: {
    format: 'iife',
    plugins: () => [workerPluginTestPlugin()],
    rollupOptions: {
      output: {
        assetFileNames: 'worker-assets/worker_asset-[name]-[hash].[ext]',
        chunkFileNames: 'worker-chunks/worker_chunk-[name]-[hash].js',
        entryFileNames: 'worker-entries/worker_entry-[name]-[hash].js',
      },
    },
  },
  build: {
    outDir: 'dist/relative-base-iife',
    assetsInlineLimit: (filePath) =>
      filePath.endsWith('.svg') ? false : undefined,
    rollupOptions: {
      output: {
        assetFileNames: 'other-assets/[name]-[hash].[ext]',
        chunkFileNames: 'chunks/[name]-[hash].js',
        entryFileNames: 'entries/[name]-[hash].js',
      },
    },
  },
  plugins: [workerPluginTestPlugin()],
  cacheDir: 'node_modules/.vite-relative-base-iife',
}))



================================================
FILE: playground/worker/vite.config-relative-base.js
================================================
import { defineConfig } from 'vite'
import workerPluginTestPlugin from './worker-plugin-test-plugin'

export default defineConfig(({ isPreview }) => ({
  base: !isPreview ? './' : '/relative-base/',
  resolve: {
    alias: {
      '@': __dirname,
    },
  },
  worker: {
    format: 'es',
    plugins: () => [workerPluginTestPlugin()],
    rollupOptions: {
      output: {
        assetFileNames: 'worker-assets/worker_asset-[name]-[hash].[ext]',
        chunkFileNames: 'worker-chunks/worker_chunk-[name]-[hash].js',
        entryFileNames: 'worker-entries/worker_entry-[name]-[hash].js',
      },
    },
  },
  build: {
    outDir: 'dist/relative-base',
    assetsInlineLimit: (filePath) =>
      filePath.endsWith('.svg') ? false : undefined,
    rollupOptions: {
      output: {
        assetFileNames: 'other-assets/[name]-[hash].[ext]',
        chunkFileNames: 'chunks/[name]-[hash].js',
        entryFileNames: 'entries/[name]-[hash].js',
      },
    },
  },
  plugins: [
    workerPluginTestPlugin(),
    {
      name: 'resolve-format-es',
      transform(code, id) {
        if (id.includes('main.js')) {
          return code.replace(
            `/* flag: will replace in vite config import("./format-es.js") */`,
            `import("./main-format-es")`,
          )
        }
      },
    },
  ],
  cacheDir: 'node_modules/.vite-relative-base',
}))



================================================
FILE: playground/worker/vite.config-sourcemap-hidden.js
================================================
import sourcemap from './worker-sourcemap-config.js'
export default sourcemap('hidden')



================================================
FILE: playground/worker/vite.config-sourcemap-inline.js
================================================
import sourcemap from './worker-sourcemap-config.js'
export default sourcemap('inline')



================================================
FILE: playground/worker/vite.config-sourcemap.js
================================================
import sourcemap from './worker-sourcemap-config.js'
export default sourcemap(true)



================================================
FILE: playground/worker/worker-nested-worker.js
================================================
import ImportMetaGlobEagerWorker from './importMetaGlobEager.worker?worker'
import SubWorker from './sub-worker?worker'

const subWorker = new SubWorker()

self.onmessage = (event) => {
  if (event.data === 'ping') {
    subWorker.postMessage('ping')
  }
}

self.postMessage(self.location.href)

subWorker.onmessage = (ev) => {
  self.postMessage({
    type: 'module',
    data: ev.data,
  })
}

const classicWorker = new Worker(new URL('./url-worker.js', import.meta.url), {
  type: 'module',
})
classicWorker.addEventListener('message', (ev) => {
  self.postMessage({
    type: 'constructor',
    data: ev.data,
  })
})

const importMetaGlobEagerWorker = new ImportMetaGlobEagerWorker()

importMetaGlobEagerWorker.postMessage('1')

importMetaGlobEagerWorker.addEventListener('message', (ev) => {
  self.postMessage({
    type: 'importMetaGlobEager',
    data: ev.data,
  })
})

// for sourcemap
console.log('worker-nested-worker.js')



================================================
FILE: playground/worker/worker-plugin-test-plugin.js
================================================
export default () => ({
  name: 'plugin-for-worker',
  transform(code, id) {
    if (id.includes('worker/modules/test-plugin.js')) {
      return {
        // keep length for sourcemap
        code: code.replace('plugin fail.   ', 'plugin success!'),
        map: null,
      }
    }
  },
})



================================================
FILE: playground/worker/worker-sourcemap-config.js
================================================
import { defineConfig } from 'vite'
import workerPluginTestPlugin from './worker-plugin-test-plugin'

/** @param {boolean | 'inline' | 'hidden' | 'sourcemap'} sourcemap */
export default (sourcemap) => {
  sourcemap =
    /** @type {'inline' | 'hidden' | 'sourcemap'} */ (
      process.env.WORKER_MODE
    ) || sourcemap

  if (sourcemap === 'sourcemap') {
    sourcemap = true
  }

  const typeName =
    typeof sourcemap === 'boolean' ? 'sourcemap' : 'sourcemap-' + sourcemap

  return defineConfig({
    base: `/iife-${typeName}/`,
    resolve: {
      alias: {
        '@': __dirname,
      },
    },
    worker: {
      format: 'iife',
      plugins: () => [workerPluginTestPlugin()],
      rollupOptions: {
        output: {
          assetFileNames: 'assets/[name]-worker_asset[hash].[ext]',
          chunkFileNames: 'assets/[name]-worker_chunk[hash].js',
          entryFileNames: 'assets/[name]-worker_entry[hash].js',
        },
      },
    },
    build: {
      outDir: `dist/iife-${typeName}/`,
      assetsInlineLimit: (filePath) =>
        filePath.endsWith('.svg') ? false : undefined,
      sourcemap: sourcemap,
      rollupOptions: {
        output: {
          assetFileNames: 'assets/[name]-[hash].[ext]',
          chunkFileNames: 'assets/[name]-[hash].js',
          entryFileNames: 'assets/[name]-[hash].js',
        },
      },
    },
    plugins: [workerPluginTestPlugin()],
    cacheDir: `node_modules/.vite-sourcemap-${typeName}`,
  })
}



================================================
FILE: playground/worker/__tests__/es/worker-es.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { isBuild, page, testDir } from '~utils'

test('normal', async () => {
  await expect.poll(() => page.textContent('.pong')).toMatch('pong')
  await expect
    .poll(() => page.textContent('.mode'))
    .toMatch(process.env.NODE_ENV)
  await expect
    .poll(() => page.textContent('.bundle-with-plugin'))
    .toMatch('worker bundle with plugin success!')
  await expect
    .poll(() => page.textContent('.asset-url'))
    .toMatch(
      isBuild
        ? /\/es\/assets\/worker_asset-vite-[\w-]{8}\.svg/
        : '/es/vite.svg',
    )
  await expect.poll(() => page.textContent('.dep-cjs')).toMatch('[cjs ok]')
})

test('named', async () => {
  await expect
    .poll(() => page.textContent('.pong-named'))
    .toMatch('namedWorker')
})

test('TS output', async () => {
  await expect.poll(() => page.textContent('.pong-ts-output')).toMatch('pong')
})

test('inlined', async () => {
  await expect.poll(() => page.textContent('.pong-inline')).toMatch('pong')
})

test('named inlined', async () => {
  await expect
    .poll(() => page.textContent('.pong-inline-named'))
    .toMatch('namedInlineWorker')
})

test('import meta url', async () => {
  await expect
    .poll(() => page.textContent('.pong-inline-url'))
    .toMatch(/^(blob|http):/)
})

test('unicode inlined', async () => {
  await expect
    .poll(() => page.textContent('.pong-inline-unicode'))
    .toMatch('•pong•')
})

test('shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count')).toMatch('pong')
})

test('named shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count-named')).toMatch('pong')
})

test('inline shared worker', async () => {
  await expect
    .poll(() => page.textContent('.pong-shared-inline'))
    .toMatch('pong')
})

test('worker emitted and import.meta.url in nested worker (serve)', async () => {
  await expect
    .poll(() => page.textContent('.nested-worker'))
    .toMatch('worker-nested-worker')
  await expect
    .poll(() => page.textContent('.nested-worker-module'))
    .toMatch('sub-worker')
  await expect
    .poll(() => page.textContent('.nested-worker-constructor'))
    .toMatch('"type":"constructor"')
})

test('deeply nested workers', async () => {
  await expect
    .poll(() => page.textContent('.deeply-nested-worker'))
    .toMatch(/Hello\sfrom\sroot.*\/es\/.+deeply-nested-worker\.js/)
  await expect
    .poll(() => page.textContent('.deeply-nested-second-worker'))
    .toMatch(/Hello\sfrom\ssecond.*\/es\/.+second-worker\.js/)
  await expect
    .poll(() => page.textContent('.deeply-nested-third-worker'))
    .toMatch(/Hello\sfrom\sthird.*\/es\/.+third-worker\.js/)
})

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('inlined code generation', async () => {
    const assetsDir = path.resolve(testDir, 'dist/es/assets')
    const files = fs.readdirSync(assetsDir)
    expect(files.length).toBe(36)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(assetsDir, index), 'utf-8')
    const worker = files.find((f) => f.includes('my-worker'))
    const workerContent = fs.readFileSync(
      path.resolve(assetsDir, worker),
      'utf-8',
    )

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(/import[^.]/)
    expect(workerContent).not.toMatch(`export`)
    // chunk
    expect(content).toMatch(`new Worker("/es/assets`)
    expect(content).toMatch(`new SharedWorker("/es/assets`)
    // inlined worker
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)
    expect(content).toMatch(
      /try\{if\(\w+=\w+&&\(self\.URL\|\|self\.webkitURL\)\.createObjectURL\(\w+\),!\w+\)throw""/,
    )
    // inlined shared worker
    expect(content).toMatch(
      `return new SharedWorker("data:text/javascript;charset=utf-8,"+`,
    )
  })

  test('worker emitted and import.meta.url in nested worker (build)', async () => {
    await expect
      .poll(() => page.textContent('.nested-worker-module'))
      .toMatch('"type":"module"')
    await expect
      .poll(() => page.textContent('.nested-worker-constructor'))
      .toMatch('"type":"constructor"')
  })
})

test('module worker', async () => {
  await expect
    .poll(() => page.textContent('.worker-import-meta-url'))
    .toMatch('A string')
  await expect
    .poll(() => page.textContent('.worker-import-meta-url-resolve'))
    .toMatch('A string')
  await expect
    .poll(() => page.textContent('.worker-import-meta-url-without-extension'))
    .toMatch('A string')
  await expect
    .poll(() => page.textContent('.shared-worker-import-meta-url'))
    .toMatch('A string')
})

test('classic worker', async () => {
  await expect
    .poll(() => page.textContent('.classic-worker'))
    .toMatch('A classic')
  if (!isBuild) {
    await expect
      .poll(() => page.textContent('.classic-worker-import'))
      .toMatch('[success] classic-esm')
  }
  await expect
    .poll(() => page.textContent('.classic-shared-worker'))
    .toMatch('A classic')
})

test('emit chunk', async () => {
  await expect
    .poll(() => page.textContent('.emit-chunk-worker'))
    .toMatch(
      '["A string",{"type":"emit-chunk-sub-worker","data":"A string"},{"type":"module-and-worker:worker","data":"A string"},{"type":"module-and-worker:module","data":"module and worker"},{"type":"emit-chunk-sub-worker","data":{"module":"module and worker","msg1":"module1","msg2":"module2","msg3":"module3"}}]',
    )
  await expect
    .poll(() => page.textContent('.emit-chunk-dynamic-import-worker'))
    .toMatch('"A stringmodule1/es/"')
})

test('url query worker', async () => {
  await expect
    .poll(() => page.textContent('.simple-worker-url'))
    .toMatch('Hello from simple worker!')
})

test('import.meta.glob in worker', async () => {
  await expect
    .poll(() => page.textContent('.importMetaGlob-worker'))
    .toMatch('["')
})

test('import.meta.glob with eager in worker', async () => {
  await expect
    .poll(() => page.textContent('.importMetaGlobEager-worker'))
    .toMatch('["')
})

test('self reference worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-worker'))
    .toMatch('pong: main\npong: nested\n')
})

test('self reference url worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-url-worker'))
    .toMatch('pong: main\npong: nested\n')
})



================================================
FILE: playground/worker/__tests__/iife/worker-iife.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import {
  isBuild,
  isServe,
  page,
  readManifest,
  testDir,
  viteTestUrl,
} from '~utils'

test('normal', async () => {
  await expect.poll(() => page.textContent('.pong')).toMatch('pong')
  await expect
    .poll(() => page.textContent('.mode'))
    .toMatch(process.env.NODE_ENV)
  await expect
    .poll(() => page.textContent('.bundle-with-plugin'))
    .toMatch('worker bundle with plugin success!')
  await expect
    .poll(() => page.textContent('.asset-url'))
    .toMatch(
      isBuild
        ? /\/iife\/assets\/worker_asset-vite-[\w-]{8}\.svg/
        : '/iife/vite.svg',
    )
})

test('named', async () => {
  await expect
    .poll(() => page.textContent('.pong-named'))
    .toMatch('namedWorker')
})

test('TS output', async () => {
  await expect.poll(() => page.textContent('.pong-ts-output')).toMatch('pong')
})

test('inlined', async () => {
  await expect.poll(() => page.textContent('.pong-inline')).toMatch('pong')
})

test('named inlined', async () => {
  await expect
    .poll(() => page.textContent('.pong-inline-named'))
    .toMatch('namedInlineWorker')
})

test('shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count')).toMatch('pong')
})

test('named shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count-named')).toMatch('pong')
})

test('inline shared worker', async () => {
  await expect
    .poll(() => page.textContent('.pong-shared-inline'))
    .toMatch('pong')
})

test.runIf(!isBuild)(
  'worker emitted and import.meta.url in nested worker (serve)',
  async () => {
    await expect
      .poll(() => page.textContent('.nested-worker'))
      .toMatch('/worker-nested')
    await expect
      .poll(() => page.textContent('.nested-worker-module'))
      .toMatch('/sub-worker')
    await expect
      .poll(() => page.textContent('.nested-worker-constructor'))
      .toMatch('"type":"constructor"')
  },
)

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('inlined code generation', async () => {
    const assetsDir = path.resolve(testDir, 'dist/iife/assets')
    const files = fs.readdirSync(assetsDir)
    expect(files.length).toBe(23)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(assetsDir, index), 'utf-8')
    const worker = files.find((f) => f.includes('worker_entry-my-worker'))
    const workerContent = fs.readFileSync(
      path.resolve(assetsDir, worker),
      'utf-8',
    )

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(`import`)
    expect(workerContent).not.toMatch(`export`)
    // chunk
    expect(content).toMatch(`new Worker("/iife/assets`)
    expect(content).toMatch(`new SharedWorker("/iife/assets`)
    // inlined
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)
  })

  test('worker emitted and import.meta.url in nested worker (build)', async () => {
    await expect
      .poll(() => page.textContent('.nested-worker-module'))
      .toMatch('"type":"module"')
    await expect
      .poll(() => page.textContent('.nested-worker-constructor'))
      .toMatch('"type":"constructor"')
  })

  test('should not emit worker manifest', async () => {
    const manifest = readManifest('iife')
    expect(manifest['index.html']).toBeDefined()
  })
})

test('module worker', async () => {
  await expect
    .poll(async () => page.textContent('.worker-import-meta-url'))
    .toMatch(/A\sstring.*\/iife\/.+url-worker\.js.+url-worker\.js/)
  await expect
    .poll(() => page.textContent('.worker-import-meta-url-resolve'))
    .toMatch(/A\sstring.*\/iife\/.+url-worker\.js.+url-worker\.js/)
  await expect
    .poll(() => page.textContent('.worker-import-meta-url-without-extension'))
    .toMatch(/A\sstring.*\/iife\/.+url-worker\.js.+url-worker\.js/)
  await expect
    .poll(() => page.textContent('.shared-worker-import-meta-url'))
    .toMatch('A string')
})

test('classic worker', async () => {
  await expect
    .poll(() => page.textContent('.classic-worker'))
    .toMatch('A classic')
  if (!isBuild) {
    await expect
      .poll(() => page.textContent('.classic-worker-import'))
      .toMatch('[success] classic-esm')
  }
  await expect
    .poll(() => page.textContent('.classic-shared-worker'))
    .toMatch('A classic')
})

test('url query worker', async () => {
  await expect
    .poll(() => page.textContent('.simple-worker-url'))
    .toMatch('Hello from simple worker!')
})

test('import.meta.glob eager in worker', async () => {
  await expect
    .poll(() => page.textContent('.importMetaGlobEager-worker'))
    .toMatch('["')
})

test('self reference worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-worker'))
    .toBe('pong: main\npong: nested\n')
})

test('self reference url worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-url-worker'))
    .toBe('pong: main\npong: nested\n')
})

test('self reference url worker in dependency', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-url-worker-dep'))
    .toBe('pong: main\npong: nested\n')
})

test.runIf(isServe)('sourcemap is correct after env is injected', async () => {
  const response = page.waitForResponse(
    /my-worker\.ts\?worker_file&type=module/,
  )
  await page.goto(viteTestUrl)
  const content = await (await response).text()
  const { mappings } = decodeSourceMapUrl(content)
  expect(mappings).toMatchInlineSnapshot(
    `";;AAAA,SAAS,OAAO,kBAAkB;AAClC,OAAO,YAAY;AACnB,SAAS,MAAM,WAAW;AAC1B,SAAS,wBAAwB;AACjC,OAAO,aAAa;AACpB,MAAM,UAAU,YAAY;AAE5B,KAAK,YAAY,CAAC,MAAM;AACtB,MAAI,EAAE,SAAS,QAAQ;AACrB,SAAK,YAAY;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AACA,MAAI,EAAE,SAAS,gBAAgB;AAC7B,SAAK,YAAY;AAAA,MACf,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,KAAK,YAAY;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAGD,QAAQ,IAAI,cAAc"`,
  )
})

function decodeSourceMapUrl(content: string) {
  return JSON.parse(
    Buffer.from(
      content.match(
        /\/\/[#@]\ssourceMappingURL=\s*data:application\/json;base64,(\S+)/,
      )?.[1],
      'base64',
    ).toString(),
  )
}



================================================
FILE: playground/worker/__tests__/relative-base/worker-relative-base.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { isBuild, page, testDir } from '~utils'

test('normal', async () => {
  await expect.poll(() => page.textContent('.pong')).toMatch('pong')
  await expect
    .poll(() => page.textContent('.mode'))
    .toMatch(process.env.NODE_ENV)
  await expect
    .poll(() => page.textContent('.bundle-with-plugin'))
    .toMatch('worker bundle with plugin success!')
  await expect
    .poll(() => page.textContent('.asset-url'))
    .toMatch(isBuild ? '/worker-assets/worker_asset-vite' : '/vite.svg')
})

test('named', async () => {
  await expect
    .poll(() => page.textContent('.pong-named'))
    .toMatch('namedWorker')
})

test('TS output', async () => {
  await expect.poll(() => page.textContent('.pong-ts-output')).toMatch('pong')
})

// TODO: inline worker should inline assets
test.skip('inlined', async () => {
  await expect.poll(() => page.textContent('.pong-inline')).toMatch('pong')
})

test('shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count')).toMatch('pong')
})

test('named shared worker', async () => {
  await expect.poll(() => page.textContent('.tick-count-named')).toMatch('pong')
})

test('inline shared worker', async () => {
  await expect
    .poll(() => page.textContent('.pong-shared-inline'))
    .toMatch('pong')
})

test('worker emitted and import.meta.url in nested worker (serve)', async () => {
  await expect
    .poll(() => page.textContent('.nested-worker'))
    .toMatch('worker-nested-worker')
  await expect
    .poll(() => page.textContent('.nested-worker-module'))
    .toMatch('sub-worker')
  await expect
    .poll(() => page.textContent('.nested-worker-constructor'))
    .toMatch('"type":"constructor"')
})

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('inlined code generation', () => {
    const chunksDir = path.resolve(testDir, 'dist/relative-base/chunks')
    const files = fs.readdirSync(chunksDir)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(chunksDir, index), 'utf-8')
    const workerEntriesDir = path.resolve(
      testDir,
      'dist/relative-base/worker-entries',
    )
    const workerFiles = fs.readdirSync(workerEntriesDir)
    const worker = workerFiles.find((f) => f.includes('worker_entry-my-worker'))
    const workerContent = fs.readFileSync(
      path.resolve(workerEntriesDir, worker),
      'utf-8',
    )

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(/import(?!\.)/) // accept import.meta.url
    expect(workerContent).not.toMatch(`export`)
    // chunk
    expect(content).toMatch(`new Worker(""+new URL("../worker-entries/`)
    expect(content).toMatch(`new SharedWorker(""+new URL("../worker-entries/`)
    // inlined
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)
  })

  test('worker emitted and import.meta.url in nested worker (build)', async () => {
    await expect
      .poll(() => page.textContent('.nested-worker-module'))
      .toMatch('"type":"module"')
    await expect
      .poll(() => page.textContent('.nested-worker-constructor'))
      .toMatch('"type":"constructor"')
  })
})

test('module worker', async () => {
  await expect
    .poll(() => page.textContent('.shared-worker-import-meta-url'))
    .toMatch('A string')
})

test('classic worker', async () => {
  await expect
    .poll(() => page.textContent('.classic-worker'))
    .toMatch('A classic')
  if (!isBuild) {
    await expect
      .poll(() => page.textContent('.classic-worker-import'))
      .toMatch('[success] classic-esm')
  }
  await expect
    .poll(() => page.textContent('.classic-shared-worker'))
    .toMatch('A classic')
})

test.runIf(isBuild)('emit chunk', async () => {
  await expect
    .poll(() => page.textContent('.emit-chunk-worker'))
    .toMatch(
      '["A string",{"type":"emit-chunk-sub-worker","data":"A string"},{"type":"module-and-worker:worker","data":"A string"},{"type":"module-and-worker:module","data":"module and worker"},{"type":"emit-chunk-sub-worker","data":{"module":"module and worker","msg1":"module1","msg2":"module2","msg3":"module3"}}]',
    )
  await expect
    .poll(() => page.textContent('.emit-chunk-dynamic-import-worker'))
    .toMatch('"A stringmodule1./"')
})

test('import.meta.glob in worker', async () => {
  await expect
    .poll(() => page.textContent('.importMetaGlob-worker'))
    .toMatch('["')
})

test('import.meta.glob with eager in worker', async () => {
  await expect
    .poll(() => page.textContent('.importMetaGlobEager-worker'))
    .toMatch('["')
})

test('self reference worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-worker'))
    .toBe('pong: main\npong: nested\n')
})

test('self reference url worker', async () => {
  await expect
    .poll(() => page.textContent('.self-reference-url-worker'))
    .toBe('pong: main\npong: nested\n')
})



================================================
FILE: playground/worker/__tests__/relative-base-iife/worker-relative-base-iife.spec.ts
================================================
import { expect, test } from 'vitest'
import { isBuild, page } from '~utils'

test('asset url', async () => {
  await expect
    .poll(() => page.textContent('.asset-url'))
    .toMatch(isBuild ? '/worker-assets/worker_asset-vite' : '/vite.svg')
})



================================================
FILE: playground/worker/__tests__/sourcemap/worker-sourcemap.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { isBuild, testDir } from '~utils'

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('sourcemap generation for web workers', async () => {
    const assetsDir = path.resolve(testDir, 'dist/iife-sourcemap/assets')
    const files = fs.readdirSync(assetsDir)
    // should have 2 worker chunk
    expect(files.length).toBe(46)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(assetsDir, index), 'utf-8')
    const indexSourcemap = getSourceMapUrl(content)
    const worker = files.find((f) => /^my-worker-[-\w]+\.js$/.test(f))
    const workerContent = fs.readFileSync(
      path.resolve(assetsDir, worker),
      'utf-8',
    )
    const workerSourcemap = getSourceMapUrl(workerContent)
    const sharedWorker = files.find((f) =>
      /^my-shared-worker-[-\w]+\.js$/.test(f),
    )
    const sharedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, sharedWorker),
      'utf-8',
    )
    const sharedWorkerSourcemap = getSourceMapUrl(sharedWorkerContent)
    const possibleTsOutputWorker = files.find((f) =>
      /^possible-ts-output-worker-[-\w]+\.js$/.test(f),
    )
    const possibleTsOutputWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, possibleTsOutputWorker),
      'utf-8',
    )
    const possibleTsOutputWorkerSourcemap = getSourceMapUrl(
      possibleTsOutputWorkerContent,
    )
    const workerNestedWorker = files.find((f) =>
      /^worker-nested-worker-[-\w]+\.js$/.test(f),
    )
    const workerNestedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, workerNestedWorker),
      'utf-8',
    )
    const workerNestedWorkerSourcemap = getSourceMapUrl(
      workerNestedWorkerContent,
    )
    const subWorker = files.find((f) => /^sub-worker-[-\w]+\.js$/.test(f))
    const subWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, subWorker),
      'utf-8',
    )
    const subWorkerSourcemap = getSourceMapUrl(subWorkerContent)

    expect(files).toContainEqual(
      expect.stringMatching(/^index-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^my-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^my-shared-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^possible-ts-output-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^worker-nested-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^sub-worker-[-\w]+\.js\.map$/),
    )

    // sourcemap should exist and have a data URL
    expect(indexSourcemap).toMatch(/^main-module-[-\w]+\.js\.map$/)
    expect(workerSourcemap).toMatch(/^my-worker-[-\w]+\.js\.map$/)
    expect(sharedWorkerSourcemap).toMatch(/^my-shared-worker-[-\w]+\.js\.map$/)
    expect(possibleTsOutputWorkerSourcemap).toMatch(
      /^possible-ts-output-worker-[-\w]+\.js\.map$/,
    )
    expect(workerNestedWorkerSourcemap).toMatch(
      /^worker-nested-worker-[-\w]+\.js\.map$/,
    )
    expect(subWorkerSourcemap).toMatch(/^sub-worker-[-\w]+\.js\.map$/)

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(`import`)
    expect(workerContent).not.toMatch(`export`)

    // shared worker should have all imports resolved and no exports
    expect(sharedWorkerContent).not.toMatch(`import`)
    expect(sharedWorkerContent).not.toMatch(`export`)

    // chunk
    expect(content).toMatch(`new Worker("/iife-sourcemap/assets/my-worker`)
    expect(content).toMatch(`new Worker("data:text/javascript;charset=utf-8,"+`)
    expect(content).toMatch(
      `new Worker("/iife-sourcemap/assets/possible-ts-output-worker`,
    )
    expect(content).toMatch(
      `new Worker("/iife-sourcemap/assets/worker-nested-worker`,
    )
    expect(content).toMatch(
      `new SharedWorker("/iife-sourcemap/assets/my-shared-worker`,
    )

    // inlined
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)

    expect(workerNestedWorkerContent).toMatch(
      `new Worker("/iife-sourcemap/assets/sub-worker`,
    )
  })
})

function getSourceMapUrl(code: string): string {
  const regex = /\/\/[#@]\ssource(?:Mapping)?URL=\s*(\S+)/g
  const matches = [...code.matchAll(regex)]
  const results = matches.at(-1)

  if (results && results.length >= 2) {
    return results[1]
  }
  return null
}



================================================
FILE: playground/worker/__tests__/sourcemap-hidden/worker-sourcemap-hidden.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { isBuild, testDir } from '~utils'

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('sourcemap generation for web workers', async () => {
    const assetsDir = path.resolve(testDir, 'dist/iife-sourcemap-hidden/assets')

    const files = fs.readdirSync(assetsDir)
    // should have 2 worker chunk
    expect(files.length).toBe(46)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(assetsDir, index), 'utf-8')
    const indexSourcemap = getSourceMapUrl(content)
    const worker = files.find((f) => /^my-worker-[-\w]+\.js$/.test(f))
    const workerContent = fs.readFileSync(
      path.resolve(assetsDir, worker),
      'utf-8',
    )
    const workerSourcemap = getSourceMapUrl(workerContent)
    const sharedWorker = files.find((f) =>
      /^my-shared-worker-[-\w]+\.js$/.test(f),
    )
    const sharedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, sharedWorker),
      'utf-8',
    )
    const sharedWorkerSourcemap = getSourceMapUrl(sharedWorkerContent)
    const possibleTsOutputWorker = files.find((f) =>
      /^possible-ts-output-worker-[-\w]+\.js$/.test(f),
    )
    const possibleTsOutputWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, possibleTsOutputWorker),
      'utf-8',
    )
    const possibleTsOutputWorkerSourcemap = getSourceMapUrl(
      possibleTsOutputWorkerContent,
    )
    const workerNestedWorker = files.find((f) =>
      /^worker-nested-worker-[-\w]+\.js$/.test(f),
    )
    const workerNestedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, workerNestedWorker),
      'utf-8',
    )
    const workerNestedWorkerSourcemap = getSourceMapUrl(
      workerNestedWorkerContent,
    )
    const subWorker = files.find((f) => /^sub-worker-[-\w]+\.js$/.test(f))
    const subWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, subWorker),
      'utf-8',
    )
    const subWorkerSourcemap = getSourceMapUrl(subWorkerContent)

    expect(files).toContainEqual(
      expect.stringMatching(/^index-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^my-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^my-shared-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^possible-ts-output-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^worker-nested-worker-[-\w]+\.js\.map$/),
    )
    expect(files).toContainEqual(
      expect.stringMatching(/^sub-worker-[-\w]+\.js\.map$/),
    )

    // sourcemap should exist and have a data URL
    expect(indexSourcemap).toBe(null)
    expect(workerSourcemap).toBe(null)
    expect(sharedWorkerSourcemap).toBe(null)
    expect(possibleTsOutputWorkerSourcemap).toBe(null)
    expect(workerNestedWorkerSourcemap).toBe(null)
    expect(subWorkerSourcemap).toBe(null)

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(`import`)
    expect(workerContent).not.toMatch(`export`)

    // shared worker should have all imports resolved and no exports
    expect(sharedWorkerContent).not.toMatch(`import`)
    expect(sharedWorkerContent).not.toMatch(`export`)

    // chunk
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-hidden/assets/my-worker`,
    )
    expect(content).toMatch(`new Worker("data:text/javascript;charset=utf-8,"+`)
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-hidden/assets/possible-ts-output-worker`,
    )
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-hidden/assets/worker-nested-worker`,
    )
    expect(content).toMatch(
      `new SharedWorker("/iife-sourcemap-hidden/assets/my-shared-worker`,
    )

    // inlined
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)

    expect(workerNestedWorkerContent).toMatch(
      `new Worker("/iife-sourcemap-hidden/assets/sub-worker`,
    )
  })
})

function getSourceMapUrl(code: string): string {
  const regex = /\/\/[#@]\ssource(?:Mapping)?URL=\s*(\S+)/
  const results = regex.exec(code)

  if (results && results.length >= 2) {
    return results[1]
  }
  return null
}



================================================
FILE: playground/worker/__tests__/sourcemap-inline/worker-sourcemap-inline.spec.ts
================================================
import fs from 'node:fs'
import path from 'node:path'
import { describe, expect, test } from 'vitest'
import { isBuild, testDir } from '~utils'

describe.runIf(isBuild)('build', () => {
  // assert correct files
  test('sourcemap generation for web workers', async () => {
    const assetsDir = path.resolve(testDir, 'dist/iife-sourcemap-inline/assets')

    const files = fs.readdirSync(assetsDir)
    // should have 2 worker chunk
    expect(files.length).toBe(23)
    const index = files.find((f) => f.includes('main-module'))
    const content = fs.readFileSync(path.resolve(assetsDir, index), 'utf-8')
    const indexSourcemap = getSourceMapUrl(content)
    const worker = files.find((f) => /^my-worker-[-\w]+\.js$/.test(f))
    const workerContent = fs.readFileSync(
      path.resolve(assetsDir, worker),
      'utf-8',
    )
    const workerSourcemap = getSourceMapUrl(workerContent)
    const sharedWorker = files.find((f) =>
      /^my-shared-worker-[-\w]+\.js$/.test(f),
    )
    const sharedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, sharedWorker),
      'utf-8',
    )
    const sharedWorkerSourcemap = getSourceMapUrl(sharedWorkerContent)
    const possibleTsOutputWorker = files.find((f) =>
      /^possible-ts-output-worker-[-\w]+\.js$/.test(f),
    )
    const possibleTsOutputWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, possibleTsOutputWorker),
      'utf-8',
    )
    const possibleTsOutputWorkerSourcemap = getSourceMapUrl(
      possibleTsOutputWorkerContent,
    )
    const workerNestedWorker = files.find((f) =>
      /^worker-nested-worker-[-\w]+\.js$/.test(f),
    )
    const workerNestedWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, workerNestedWorker),
      'utf-8',
    )
    const workerNestedWorkerSourcemap = getSourceMapUrl(
      workerNestedWorkerContent,
    )
    const subWorker = files.find((f) => /^sub-worker-[-\w]+\.js$/.test(f))
    const subWorkerContent = fs.readFileSync(
      path.resolve(assetsDir, subWorker),
      'utf-8',
    )
    const subWorkerSourcemap = getSourceMapUrl(subWorkerContent)

    // sourcemap should exist and have a data URL
    expect(indexSourcemap).toMatch(/^data:/)
    expect(workerSourcemap).toMatch(/^data:/)
    expect(sharedWorkerSourcemap).toMatch(/^data:/)
    expect(possibleTsOutputWorkerSourcemap).toMatch(/^data:/)
    expect(workerNestedWorkerSourcemap).toMatch(/^data:/)
    expect(subWorkerSourcemap).toMatch(/^data:/)

    // worker should have all imports resolved and no exports
    expect(workerContent).not.toMatch(`import`)
    expect(workerContent).not.toMatch(`export`)

    // shared worker should have all imports resolved and no exports
    expect(sharedWorkerContent).not.toMatch(`import`)
    expect(sharedWorkerContent).not.toMatch(`export`)

    // chunk
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-inline/assets/my-worker`,
    )
    expect(content).toMatch(`new Worker("data:text/javascript;charset=utf-8,"+`)
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-inline/assets/possible-ts-output-worker`,
    )
    expect(content).toMatch(
      `new Worker("/iife-sourcemap-inline/assets/worker-nested-worker`,
    )
    expect(content).toMatch(
      `new SharedWorker("/iife-sourcemap-inline/assets/my-shared-worker`,
    )

    // inlined
    expect(content).toMatch(`(self.URL||self.webkitURL).createObjectURL`)
    expect(content).toMatch(`self.Blob`)

    expect(workerNestedWorkerContent).toMatch(
      `new Worker("/iife-sourcemap-inline/assets/sub-worker`,
    )
  })
})

function getSourceMapUrl(code: string): string {
  const regex = /\/\/[#@]\ssource(?:Mapping)?URL=\s*(\S+)/
  const results = regex.exec(code)

  if (results && results.length >= 2) {
    return results[1]
  }
  return null
}



================================================
FILE: playground/worker/dep-cjs/index.cjs
================================================
exports.test = '[cjs ok]'



================================================
FILE: playground/worker/dep-cjs/package.json
================================================
{
  "name": "@vitejs/test-worker-dep-cjs",
  "type": "commonjs",
  "exports": "./index.cjs"
}



================================================
FILE: playground/worker/dep-self-reference-url-worker/index.js
================================================
export function startWorker(handler) {
  const worker = new Worker(new URL('./worker.js', import.meta.url), {
    type: 'module',
  })
  worker.postMessage('main')
  worker.addEventListener('message', (e) => {
    handler(e)
  })
}



================================================
FILE: playground/worker/dep-self-reference-url-worker/package.json
================================================
{
  "name": "@vitejs/test-dep-self-reference-url-worker",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/worker/dep-self-reference-url-worker/worker.js
================================================
// copy of playground/worker/self-reference-url-worker.js
self.addEventListener('message', (e) => {
  if (e.data === 'main') {
    const selfWorker = new Worker(new URL('./worker.js', import.meta.url), {
      type: 'module',
    })
    selfWorker.postMessage('nested')
    selfWorker.addEventListener('message', (e) => {
      self.postMessage(e.data)
    })
  }

  self.postMessage(`pong: ${e.data}`)
})



================================================
FILE: playground/worker/dep-to-optimize/index.js
================================================
export const msg = 'dep-to-optimize'



================================================
FILE: playground/worker/dep-to-optimize/package.json
================================================
{
  "name": "@vitejs/test-dep-to-optimize",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}



================================================
FILE: playground/worker/modules/module0.js
================================================
export default 'A string'



================================================
FILE: playground/worker/modules/module1.js
================================================
export const msg1 = 'module1'



================================================
FILE: playground/worker/modules/module2.js
================================================
export * from './module0'
export * from './module1'
export const msg2 = 'module2'



================================================
FILE: playground/worker/modules/module3.js
================================================
export * from './module0'
export const msg3 = 'module3'



================================================
FILE: playground/worker/modules/test-plugin.js
================================================
export const bundleWithPlugin = 'worker bundle with plugin fail.   '



================================================
FILE: playground/worker/modules/workerImport.ts
================================================
export const msg = 'pong'
export const mode = process.env.NODE_ENV



================================================
FILE: playground/worker/public/classic.js
================================================
self.constant = 'A classic'



================================================
FILE: playground/worker/worker/main-classic.js
================================================
// prettier-ignore
function text(el, text) {
  document.querySelector(el).textContent = text
}

let classicWorker = new Worker(
  new URL('../classic-worker.js', import.meta.url) /* , */,
  // test comment
)

// just test for case: ') ... ,' mean no worker options params
classicWorker = new Worker(new URL('../classic-worker.js', import.meta.url))

classicWorker.addEventListener('message', ({ data }) => {
  switch (data.message) {
    case 'ping': {
      text('.classic-worker', data.result)
      break
    }
    case 'test-import': {
      text('.classic-worker-import', data.result)
      break
    }
  }
})
classicWorker.postMessage('ping')
classicWorker.postMessage('test-import')

// prettier-ignore
// test trailing comma
const classicSharedWorker = new SharedWorker(
  new URL('../classic-shared-worker.js', import.meta.url),
  {
    type: 'classic'
  }, // test comment
)
classicSharedWorker.port.addEventListener('message', (ev) => {
  text('.classic-shared-worker', JSON.stringify(ev.data))
})
classicSharedWorker.port.start()



================================================
FILE: playground/worker/worker/main-deeply-nested.js
================================================
const worker = new Worker(
  new URL('../deeply-nested-worker.js', import.meta.url),
  { type: 'module' },
)

function text(el, text) {
  document.querySelector(el).textContent = text
}

worker.addEventListener('message', (ev) => {
  if (ev.data.type === 'deeplyNestedSecondWorker') {
    text('.deeply-nested-second-worker', JSON.stringify(ev.data.data))
  } else if (ev.data.type === 'deeplyNestedThirdWorker') {
    text('.deeply-nested-third-worker', JSON.stringify(ev.data.data))
  } else {
    text('.deeply-nested-worker', JSON.stringify(ev.data.data))
  }
})



================================================
FILE: playground/worker/worker/main-format-es.js
================================================
// run when format es
import NestedWorker from '../emit-chunk-nested-worker?worker'
import ImportMetaGlobWorker from '../importMetaGlob.worker?worker'

function text(el, text) {
  document.querySelector(el).textContent = text
}

text('.format-es', 'format es:')

const nestedWorker = new NestedWorker()
const dataList = []
nestedWorker.addEventListener('message', (ev) => {
  dataList.push(ev.data)
  text(
    '.emit-chunk-worker',
    JSON.stringify(
      dataList.sort(
        (a, b) => JSON.stringify(a).length - JSON.stringify(b).length,
      ),
    ),
  )
})

const dynamicImportWorker = new Worker(
  new URL('../emit-chunk-dynamic-import-worker.js', import.meta.url),
  {
    type: 'module',
  },
)
dynamicImportWorker.addEventListener('message', (ev) => {
  text('.emit-chunk-dynamic-import-worker', JSON.stringify(ev.data))
})

const moduleWorker = new Worker(
  new URL('../module-and-worker.js', import.meta.url),
  { type: 'module' },
)

moduleWorker.addEventListener('message', (ev) => {
  text('.module-and-worker-worker', JSON.stringify(ev.data))
})

const importMetaGlobWorker = new ImportMetaGlobWorker()

importMetaGlobWorker.postMessage('1')

importMetaGlobWorker.addEventListener('message', (e) => {
  text('.importMetaGlob-worker', JSON.stringify(e.data))
})



================================================
FILE: playground/worker/worker/main-module.js
================================================
import * as depSelfReferenceUrlWorker from '@vitejs/test-dep-self-reference-url-worker'
import myWorker from '../my-worker.ts?worker'
import InlineWorker from '../my-worker.ts?worker&inline'
import InlineSharedWorker from '../my-inline-shared-worker?sharedworker&inline'
import mySharedWorker from '../my-shared-worker?sharedworker&name=shared'
import TSOutputWorker from '../possible-ts-output-worker?worker'
import NestedWorker from '../worker-nested-worker?worker'
import { mode } from '../modules/workerImport'
import SelfReferenceWorker from '../self-reference-worker?worker'

function text(el, text) {
  document.querySelector(el).textContent = text
}

document.querySelector('.mode-true').textContent = mode

const worker = new myWorker()
worker.postMessage('ping')
worker.addEventListener('message', (e) => {
  text('.pong', e.data.msg)
  text('.mode', e.data.mode)
  text('.bundle-with-plugin', e.data.bundleWithPlugin)
  text('.asset-url', e.data.viteSvg)
  text('.dep-cjs', e.data.depCjs.test)
})

const namedWorker = new myWorker({ name: 'namedWorker' })
namedWorker.postMessage('ping')
namedWorker.addEventListener('message', (e) => {
  text('.pong-named', e.data.name)
})

const inlineWorker = new InlineWorker()
inlineWorker.postMessage('ping')
inlineWorker.addEventListener('message', (e) => {
  text('.pong-inline', e.data.msg)
})

const namedInlineWorker = new InlineWorker({ name: 'namedInlineWorker' })
namedInlineWorker.postMessage('ping')
namedInlineWorker.addEventListener('message', (e) => {
  text('.pong-inline-named', e.data.name)
})

const inlineWorkerUrl = new InlineWorker()
inlineWorkerUrl.postMessage('ping')
inlineWorkerUrl.addEventListener('message', (e) => {
  text('.pong-inline-url', e.data.metaUrl)
})

const unicodeInlineWorker = new InlineWorker()
unicodeInlineWorker.postMessage('ping-unicode')
unicodeInlineWorker.addEventListener('message', (e) => {
  text('.pong-inline-unicode', e.data.msg)
})

const startSharedWorker = () => {
  const sharedWorker = new mySharedWorker()
  sharedWorker.port.addEventListener('message', (event) => {
    text('.tick-count', event.data)
  })
  sharedWorker.port.start()
}
startSharedWorker()
startSharedWorker()

const startNamedSharedWorker = () => {
  const sharedWorker = new mySharedWorker({ name: 'namedSharedWorker' })
  sharedWorker.port.addEventListener('message', (event) => {
    text('.tick-count-named', event.data)
  })
  sharedWorker.port.start()
}
startNamedSharedWorker()
startNamedSharedWorker()

const startInlineSharedWorker = () => {
  const inlineSharedWorker = new InlineSharedWorker()
  inlineSharedWorker.port.addEventListener('message', (event) => {
    text('.pong-shared-inline', event.data)
  })
  inlineSharedWorker.port.start()
}

startInlineSharedWorker()
startInlineSharedWorker()

const tsOutputWorker = new TSOutputWorker()
tsOutputWorker.postMessage('ping')
tsOutputWorker.addEventListener('message', (e) => {
  text('.pong-ts-output', e.data.msg)
})

const nestedWorker = new NestedWorker()
nestedWorker.addEventListener('message', (ev) => {
  if (typeof ev.data === 'string') {
    text('.nested-worker', JSON.stringify(ev.data))
  } else if (typeof ev.data === 'object') {
    const data = ev.data
    if (data.type === 'module') {
      text('.nested-worker-module', JSON.stringify(ev.data))
    } else if (data.type === 'constructor') {
      text('.nested-worker-constructor', JSON.stringify(ev.data))
    } else if (data.type === 'importMetaGlobEager') {
      text('.importMetaGlobEager-worker', JSON.stringify(ev.data))
    }
  }
})
nestedWorker.postMessage('ping')

const workerOptions = { type: 'module' }
// url import worker
const w = new Worker(
  new URL('../url-worker.js', import.meta.url),
  /* @vite-ignore */ workerOptions,
)
w.addEventListener('message', (ev) =>
  text('.worker-import-meta-url', JSON.stringify(ev.data)),
)

// url import worker with alias path
const wResolve = new Worker(
  new URL('@/url-worker.js', import.meta.url),
  /* @vite-ignore */ workerOptions,
)
wResolve.addEventListener('message', (ev) =>
  text('.worker-import-meta-url-resolve', JSON.stringify(ev.data)),
)

// url import worker without extension
const wWithoutExt = new Worker(
  new URL('../url-worker', import.meta.url),
  /* @vite-ignore */ workerOptions,
)
wWithoutExt.addEventListener('message', (ev) =>
  text('.worker-import-meta-url-without-extension', JSON.stringify(ev.data)),
)

const genWorkerName = () => 'module'
const w2 = new SharedWorker(
  new URL('../url-shared-worker.js', import.meta.url),
  {
    name: genWorkerName(),
    type: 'module',
  },
)
w2.port.addEventListener('message', (ev) => {
  text('.shared-worker-import-meta-url', JSON.stringify(ev.data))
})
w2.port.start()

const workers = import.meta.glob('../importMetaGlobEager.*.js', {
  query: '?worker',
  eager: true,
})
const importMetaGlobEagerWorker = new workers[
  '../importMetaGlobEager.worker.js'
].default()
importMetaGlobEagerWorker.postMessage('1')
importMetaGlobEagerWorker.addEventListener('message', (e) => {
  text('.importMetaGlobEager-worker', JSON.stringify(e.data))
})

const selfReferenceWorker = new SelfReferenceWorker()
selfReferenceWorker.postMessage('main')
selfReferenceWorker.addEventListener('message', (e) => {
  document.querySelector('.self-reference-worker').textContent += `${e.data}\n`
})

const selfReferenceUrlWorker = new Worker(
  new URL('../self-reference-url-worker.js', import.meta.url),
  {
    type: 'module',
  },
)
selfReferenceUrlWorker.postMessage('main')
selfReferenceUrlWorker.addEventListener('message', (e) => {
  document.querySelector('.self-reference-url-worker').textContent +=
    `${e.data}\n`
})

depSelfReferenceUrlWorker.startWorker((e) => {
  document.querySelector('.self-reference-url-worker-dep').textContent +=
    `${e.data}\n`
})



================================================
FILE: playground/worker/worker/main-url.js
================================================
import workerUrl from '../simple-worker?worker&url'

function text(el, text) {
  document.querySelector(el).textContent = text
}

const worker = new Worker(workerUrl, { type: 'module' })

worker.addEventListener('message', (ev) => {
  text('.simple-worker-url', JSON.stringify(ev.data))
})



================================================
FILE: playground/worker/worker/main.js
================================================
/* flag: will replace in vite config import("./format-es.js") */
import('./main-module')
import('./main-classic')
import('./main-url')
import('./main-deeply-nested')



================================================
FILE: scripts/docs-check.sh
================================================
echo "prev commit: $CACHED_COMMIT_REF"
echo "current commit: $COMMIT_REF"
git diff --quiet $CACHED_COMMIT_REF $COMMIT_REF docs package.json pnpm-lock.yaml netlify.toml scripts/docs-check.sh
status=$?
echo "diff exit code: $status"
exit $status



================================================
FILE: scripts/publishCI.ts
================================================
import { publish } from '@vitejs/release-scripts'

publish({ defaultPackage: 'vite', provenance: true, packageManager: 'pnpm' })



================================================
FILE: scripts/release.ts
================================================
import { generateChangelog, release } from '@vitejs/release-scripts'
import colors from 'picocolors'
import { logRecentCommits, updateTemplateVersions } from './releaseUtils'

release({
  repo: 'vite',
  packages: ['vite', 'create-vite', 'plugin-legacy'],
  toTag: (pkg, version) =>
    pkg === 'vite' ? `v${version}` : `${pkg}@${version}`,
  logChangelog: (pkg) => logRecentCommits(pkg),
  generateChangelog: async (pkgName) => {
    if (pkgName === 'create-vite') await updateTemplateVersions()

    console.log(colors.cyan('\nGenerating changelog...'))

    await generateChangelog({
      getPkgDir: () => `packages/${pkgName}`,
      tagPrefix: pkgName === 'vite' ? undefined : `${pkgName}@`,
    })
  },
})



================================================
FILE: scripts/releaseUtils.ts
================================================
import fs from 'node:fs/promises'
import path from 'node:path'
import colors from 'picocolors'
import type { Options as ExecaOptions, ResultPromise } from 'execa'
import { execa } from 'execa'

function run<EO extends ExecaOptions>(
  bin: string,
  args: string[],
  opts?: EO,
): ResultPromise<
  EO & (keyof EO extends 'stdio' ? object : { stdio: 'inherit' })
> {
  return execa(bin, args, { stdio: 'inherit', ...opts }) as any
}

export async function getLatestTag(pkgName: string): Promise<string> {
  const pkgJson = JSON.parse(
    await fs.readFile(`packages/${pkgName}/package.json`, 'utf-8'),
  )
  const version = pkgJson.version
  return pkgName === 'vite' ? `v${version}` : `${pkgName}@${version}`
}

export async function logRecentCommits(pkgName: string): Promise<void> {
  const tag = await getLatestTag(pkgName)
  if (!tag) return
  const sha = await run('git', ['rev-list', '-n', '1', tag], {
    stdio: 'pipe',
  }).then((res) => res.stdout.trim())
  console.log(
    colors.bold(
      `\n${colors.blue(`i`)} Commits of ${colors.green(
        pkgName,
      )} since ${colors.green(tag)} ${colors.gray(`(${sha.slice(0, 5)})`)}`,
    ),
  )
  await run(
    'git',
    [
      '--no-pager',
      'log',
      `${sha}..HEAD`,
      '--oneline',
      '--',
      `packages/${pkgName}`,
    ],
    { stdio: 'inherit' },
  )
  console.log()
}

export async function updateTemplateVersions(): Promise<void> {
  const vitePkgJson = JSON.parse(
    await fs.readFile('packages/vite/package.json', 'utf-8'),
  )
  const viteVersion = vitePkgJson.version
  if (/beta|alpha|rc/.test(viteVersion)) return

  const dir = 'packages/create-vite'
  const templates = (await fs.readdir(dir)).filter((dir) =>
    dir.startsWith('template-'),
  )
  for (const template of templates) {
    const pkgPath = path.join(dir, template, `package.json`)
    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'))
    pkg.devDependencies.vite = `^` + viteVersion
    await fs.writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\n')
  }
}



================================================
FILE: scripts/tsconfig.json
================================================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "include": ["."],
  "compilerOptions": {
    "module": "Preserve",
    "target": "ES2023",
    "moduleResolution": "bundler",
    "types": ["node"],
    "noEmit": true,
    "strict": true,
    "esModuleInterop": true,
    "erasableSyntaxOnly": true,
    "skipLibCheck": true,
    "noUnusedLocals": true
  }
}



================================================
FILE: .github/commit-convention.md
================================================
## Git Commit Message Convention

> This is adapted from [Angular's commit convention](https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-angular).

#### TL;DR:

Messages must be matched by the following regex:

<!-- prettier-ignore -->
```js
/^(revert: )?(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\(.+\))?!?: .{1,50}/
```

#### Examples

```
feat(dev): add 'comments' option
fix(dev): fix dev error
perf(build)!: remove 'foo' option
revert: feat(compiler): add 'comments' option
```

### Revert

If the PR reverts a previous commit, it should begin with `revert: `, followed by the header of the reverted commit

### Scope

The scope could be anything specifying the place of the commit change. For example `dev`, `build`, `workflow`, `cli` etc...

### Subject

The subject contains a succinct description of the change:

- use the imperative, present tense: "change" not "changed" nor "changes"
- don't capitalize the first letter
- no dot (.) at the end



================================================
FILE: .github/copilot-instructions.md
================================================
This is a TypeScript project that implements a frontend build tooling called Vite. Please follow these guidelines when contributing:

## Code Standards

### Required Before Each Commit

- Run `pnpm run lint` to ensure that your code adheres to the code standards.
- Run `pnpm run format` to format your code.

### Development Flow

- Build: `pnpm run build`
- Test: `pnpm run test` (uses Vitest and Playwright)

## Repository Structure

- `docs/`: Documentation.
- `packages/create-vite`: Contains the source code for the `create-vite` command.
- `packages/plugin-legacy`: Contains the source code for `@vitejs/plugin-legacy`.
- `packages/vite`: Contains the source code for the Vite core.
- `playground/`: E2E tests

## Key Guidelines

1. Follow TypeScript best practices.
2. Maintain existing code structure and organization.
3. Write tests for new functionality. Prefer unit tests if it can be tested without using mocks. E2E tests should be added in the `playground/` directory.
4. Never write comments that explain what the code does. Instead, write comments that explain why the code does what it does.
5. Suggest changes to the documentation if public API changes are made.



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
### Description

<!-- What is this PR solving? Write a clear description or reference the issues it solves (e.g. `fixes #123`). What other alternatives have you explored? Are there any parts you think require more attention from reviewers? -->

<!----------------------------------------------------------------------
Before creating the pull request, please make sure you do the following:

- Read the Contributing Guidelines at https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md.
- Check that there isn't already a PR that solves the problem the same way. If you find a duplicate, please help us reviewing it.
- Update the corresponding documentation if needed.
- Include relevant tests that fail without this PR but pass with it.

Thank you for contributing to Vite!
----------------------------------------------------------------------->



================================================
FILE: .github/renovate.json5
================================================
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:recommended", "schedule:weekly", "group:allNonMajor"],
  "labels": ["dependencies"],
  "ignorePaths": ["**/__tests__/**"],
  "rangeStrategy": "bump",
  "packageRules": [
    {
      "matchDepTypes": ["peerDependencies"],
      "enabled": false,
    },
    {
      "matchDepTypes": ["action"],
      "pinDigests": true,
      "matchPackageNames": ["!actions/{/,}**", "!github/{/,}**"],
    },
    {
      "groupName": "rolldown-related dependencies",
      "matchDepNames": ["rolldown", "rolldown-plugin-dts", "tsdown"],
    },
  ],
  "ignoreDeps": [
    // manually bumping
    "esbuild",
    "rollup",
    "node",
    "typescript",
    "@rollup/plugin-dynamic-import-vars", // prefer version using tinyglobby
    "@oxc-project/types", // align version with rolldown

    // pinned
    "slash3",
    "slash5",
    "vue34",

    // breaking changes
    "kill-port", // `kill-port:^2.0.0 has perf issues (#8392)
  ],
  "github-actions": {
    "managerFilePatterns": [
      // default values
      "/(^|/)(workflow-templates|\\.(?:github|gitea|forgejo)/(?:workflows|actions))/.+\\.ya?ml$/",
      "/(^|/)action\\.ya?ml$/",
      // custom value
      "/(^|/)docs/guide/static-deploy-github-pages\\.yaml$/",
    ],
  },
  "customManagers": [
    {
      "customType": "regex",
      "managerFilePatterns": ["/packages/create-vite/src/index\\.ts$/"],
      "matchStrings": [
        "//\\s*renovate:\\s+datasource=(?<datasource>\\S+)\\s+depName=(?<depName>\\S+)\\s+(?:var|let|const)\\s+\\S+\\s*=\\s*[\"'](?<currentValue>[^\"']+)[\"']",
      ],
    },
  ],
}



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.yml
================================================
name: "\U0001F41E Bug report"
description: Report an issue with Vite
labels: [pending triage]
type: Bug
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: textarea
    id: bug-description
    attributes:
      label: Describe the bug
      description: A clear and concise description of what the bug is. If you intend to submit a PR for this issue, tell us in the description. Thanks!
      placeholder: I am doing ... What I expect is ... What actually happening is ...
    validations:
      required: true
  - type: input
    id: reproduction
    attributes:
      label: Reproduction
      description: Please provide a link via [vite.new](https://vite.new/) or a link to a repo that can reproduce the problem you ran into. `npm create vite@latest` and `npm create vite-extra@latest` (for SSR or library repros) can be used as a starter template. A [minimal reproduction](https://stackoverflow.com/help/minimal-reproducible-example) is required ([Why?](https://antfu.me/posts/why-reproductions-are-required)). If a report is vague (e.g. just a generic error message) and has no reproduction, it will receive a "needs reproduction" label. If no reproduction is provided after 3 days, it will be auto-closed.
      placeholder: Reproduction URL
    validations:
      required: true
  - type: textarea
    id: reproduction-steps
    attributes:
      label: Steps to reproduce
      description: Please provide any reproduction steps that may need to be described. E.g. if it happens only when running the dev or build script make sure it's clear which one to use.
      placeholder: Run `npm install` followed by `npm run dev`
  - type: textarea
    id: system-info
    attributes:
      label: System Info
      description: Output of `npx envinfo --system --npmPackages '{vite,@vitejs/*,rollup}' --binaries --browsers`
      render: shell
      placeholder: System, Binaries, Browsers
    validations:
      required: true
  - type: dropdown
    id: package-manager
    attributes:
      label: Used Package Manager
      description: Select the used package manager
      options:
        - npm
        - yarn
        - pnpm
        - bun
    validations:
      required: true
  - type: textarea
    id: logs
    attributes:
      label: Logs
      description: |
        Optional if provided reproduction. Please try not to insert an image but copy paste the log text.

        1. Run `vite` or `vite build` with the `--debug` flag.
        2. Provide the error log here in the format below.

        ````
        <details>
        <summary>Click to expand!</summary>

        ```shell
        // paste the log text here
        ```
        </details>
        ````
  - type: checkboxes
    id: checkboxes
    attributes:
      label: Validations
      description: Before submitting the issue, please make sure you do the following
      options:
        - label: Follow our [Code of Conduct](https://github.com/vitejs/vite/blob/main/CODE_OF_CONDUCT.md)
          required: true
        - label: Read the [Contributing Guidelines](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md).
          required: true
        - label: Read the [docs](https://vite.dev/guide).
          required: true
        - label: Check that there isn't [already an issue](https://github.com/vitejs/vite/issues) that reports the same bug to avoid creating a duplicate.
          required: true
        - label: Make sure this is a Vite issue and not a framework-specific issue. For example, if it's a Vue SFC related bug, it should likely be reported to [vuejs/core](https://github.com/vuejs/core) instead.
          required: true
        - label: Check that this is a concrete bug. For Q&A open a [GitHub Discussion](https://github.com/vitejs/vite/discussions) or join our [Discord Chat Server](https://chat.vite.dev/).
          required: true
        - label: The provided reproduction is a [minimal reproducible example](https://stackoverflow.com/help/minimal-reproducible-example) of the bug.
          required: true



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false
contact_links:
  - name: Vite Plugin React Issues
    url: https://github.com/vitejs/vite-plugin-react/issues/new/choose
    about: React related issues should be reported on the vite-plugin-react repository.
  - name: Vite Plugin Vue Issues
    url: https://github.com/vitejs/vite-plugin-vue/issues/new/choose
    about: Vue related issues should be reported on the vite-plugin-vue repository.
  - name: Discord Chat
    url: https://chat.vite.dev
    about: Ask questions and discuss with other Vite users in real time.
  - name: Questions & Discussions
    url: https://github.com/vitejs/vite/discussions
    about: Use GitHub discussions for message-board style questions and discussions.



================================================
FILE: .github/ISSUE_TEMPLATE/docs.yml
================================================
name: "\U0001F4DA Documentation"
description: Suggest a change or new page to be added to vite.dev
labels: [documentation]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this issue!
  - type: checkboxes
    id: documentation_is
    attributes:
      label: Documentation is
      options:
        - label: Missing
        - label: Outdated
        - label: Confusing
        - label: Not sure?
  - type: textarea
    id: description
    attributes:
      label: Explain in Detail
      description: A clear and concise description of your suggestion. If you intend to submit a PR for this issue, tell us in the description. Thanks!
      placeholder: The description of ... page is not clear. I thought it meant ... but it wasn't.
    validations:
      required: true
  - type: textarea
    id: suggestion
    attributes:
      label: Your Suggestion for Changes
    validations:
      required: true
  - type: input
    id: reproduction
    attributes:
      label: Reproduction
      description: If you have a reproduction, please provide a link via [vite.new](https://vite.new/) or a link to a repo that can reproduce the problem you ran into. `npm create vite@latest` and `npm create vite-extra@latest` (for SSR or library repros) can be used as a starter template.
      placeholder: Reproduction URL
  - type: textarea
    id: reproduction-steps
    attributes:
      label: Steps to reproduce
      description: Please provide any reproduction steps that may need to be described. E.g. if it happens only when running the dev or build script make sure it's clear which one to use.
      placeholder: Run `npm install` followed by `npm run dev`



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.yml
================================================
name: "\U0001F680 New feature proposal"
description: Propose a new feature to be added to Vite
labels: ["pending triage"]
type: Feature
body:
  - type: markdown
    attributes:
      value: |
        Thanks for your interest in the project and taking the time to fill out this feature report!
  - type: textarea
    id: feature-description
    attributes:
      label: Description
      description: "Clear and concise description of the problem. Please make the reason and usecases as detailed as possible. If you intend to submit a PR for this issue, tell us in the description. Thanks!"
      placeholder: As a developer using Vite I want [goal / wish] so that [benefit].
    validations:
      required: true
  - type: textarea
    id: suggested-solution
    attributes:
      label: Suggested solution
      description: "In module [xy] we could provide following implementation..."
    validations:
      required: true
  - type: textarea
    id: alternative
    attributes:
      label: Alternative
      description: Clear and concise description of any alternative solutions or features you've considered.
  - type: textarea
    id: additional-context
    attributes:
      label: Additional context
      description: Any other context or screenshots about the feature request here.
  - type: checkboxes
    id: checkboxes
    attributes:
      label: Validations
      description: Before submitting the issue, please make sure you do the following
      options:
        - label: Follow our [Code of Conduct](https://github.com/vitejs/vite/blob/main/CODE_OF_CONDUCT.md)
          required: true
        - label: Read the [Contributing Guidelines](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md).
          required: true
        - label: Read the [docs](https://vite.dev/guide).
          required: true
        - label: Check that there isn't already an issue that request the same feature to avoid creating a duplicate.
          required: true



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

env:
  # 7 GiB by default on GitHub, setting to 6 GiB
  # https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources
  NODE_OPTIONS: --max-old-space-size=6144
  # install playwright binary manually (because pnpm only runs install script once)
  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
  # Vitest auto retry on flaky segfault
  VITEST_SEGFAULT_RETRY: 3

# Remove default permissions of GITHUB_TOKEN for security
# https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs
permissions: {}

on:
  push:
    branches:
      - main
      - release/*
      - feat/*
      - fix/*
      - perf/*
      - "v[0-9]+" # v1, v2, ...
      - "v[0-9]+.[0-9]+" # v4.0, v4.1, ...
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.sha }}
  cancel-in-progress: true

jobs:
  changed:
    name: Get changed files
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.changed-files.outputs.only_changed == 'true' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Assume PRs are less than 50 commits
          fetch-depth: 50

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@a284dc1814e3fd07f2e34267fc8f81227ed29fb8 # v45.0.9
        with:
          files: |
            docs/**
            .github/**
            !.github/workflows/ci.yml
            packages/create-vite/template**
            **.md

  test:
    needs: changed
    if: needs.changed.outputs.should_skip != 'true'
    timeout-minutes: 20
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        node_version: [20, 22, 24]
        include:
          # Active LTS + other OS
          - os: macos-latest
            node_version: 22
          - os: windows-latest
            node_version: 22
      fail-fast: false

    name: "Build&Test: node-${{ matrix.node_version }}, ${{ matrix.os }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Set node version to ${{ matrix.node_version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
          cache: "pnpm"

      - name: Install deps
        run: pnpm install

      # Install playwright's binary under custom directory to cache
      - name: (non-windows) Set Playwright path and Get playwright version
        if: runner.os != 'Windows'
        run: |
          echo "PLAYWRIGHT_BROWSERS_PATH=$HOME/.cache/playwright-bin" >> $GITHUB_ENV
          PLAYWRIGHT_VERSION="$(pnpm ls --depth 0 --json -w playwright-chromium | jq --raw-output '.[0].devDependencies["playwright-chromium"].version')"
          echo "PLAYWRIGHT_VERSION=$PLAYWRIGHT_VERSION" >> $GITHUB_ENV
      - name: (windows) Set Playwright path and Get playwright version
        if: runner.os == 'Windows'
        run: |
          echo "PLAYWRIGHT_BROWSERS_PATH=$HOME\.cache\playwright-bin" >> $env:GITHUB_ENV
          $env:PLAYWRIGHT_VERSION="$(pnpm ls --depth 0 --json -w playwright-chromium | jq --raw-output '.[0].devDependencies["playwright-chromium"].version')"
          echo "PLAYWRIGHT_VERSION=$env:PLAYWRIGHT_VERSION" >> $env:GITHUB_ENV

      - name: Cache Playwright's binary
        uses: actions/cache@v4
        with:
          key: ${{ runner.os }}-playwright-bin-v1-${{ env.PLAYWRIGHT_VERSION }}
          path: ${{ env.PLAYWRIGHT_BROWSERS_PATH }}
          restore-keys: |
            ${{ runner.os }}-playwright-bin-v1-

      - name: Install Playwright
        # does not need to explicitly set chromium after https://github.com/microsoft/playwright/issues/14862 is solved
        run: pnpm playwright install chromium

      - name: Build
        run: pnpm run build

      - name: Test unit
        run: pnpm run test-unit

      - name: Test serve
        run: pnpm run test-serve

      - name: Test build
        run: pnpm run test-build

  test-passed:
    if: (!cancelled() && !failure())
    needs: test
    runs-on: ubuntu-latest
    name: Build & Test Passed or Skipped
    steps:
      - run: echo "Build & Test Passed or Skipped"

  test-failed:
    if: (!cancelled() && failure())
    needs: test
    runs-on: ubuntu-latest
    name: Build & Test Failed
    steps:
      - run: echo "Build & Test Failed"

  lint:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    name: "Lint: node-22, ubuntu-latest"
    steps:
      - uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Set node version to 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: "pnpm"

      - name: Install deps
        run: pnpm install

      - name: Build
        run: pnpm run build

      - name: Lint
        run: pnpm run lint

      - name: Check formatting
        run: pnpm prettier --write --log-level=warn . && git diff --exit-code

      - name: Typecheck
        run: pnpm run typecheck

      - name: Test docs
        run: pnpm run test-docs

      # From https://github.com/rhysd/actionlint/blob/main/docs/usage.md#use-actionlint-on-github-actions
      - name: Check workflow files
        run: |
          bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash)
          ./actionlint -color -shellcheck=""



================================================
FILE: .github/workflows/copilot-setup-steps.yml
================================================
on:
  workflow_dispatch:
  push:
    paths:
      - .github/workflows/copilot-setup-steps.yml
  pull_request:
    paths:
      - .github/workflows/copilot-setup-steps.yml

jobs:
  copilot-setup-steps:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Set node version to 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: "pnpm"

      - name: Install deps
        run: pnpm install

      # Install playwright's binary under custom directory to cache
      - name: (non-windows) Set Playwright path and Get playwright version
        if: runner.os != 'Windows'
        run: |
          echo "PLAYWRIGHT_BROWSERS_PATH=$HOME/.cache/playwright-bin" >> $GITHUB_ENV
          PLAYWRIGHT_VERSION="$(pnpm ls --depth 0 --json -w playwright-chromium | jq --raw-output '.[0].devDependencies["playwright-chromium"].version')"
          echo "PLAYWRIGHT_VERSION=$PLAYWRIGHT_VERSION" >> $GITHUB_ENV
      - name: (windows) Set Playwright path and Get playwright version
        if: runner.os == 'Windows'
        run: |
          echo "PLAYWRIGHT_BROWSERS_PATH=$HOME\.cache\playwright-bin" >> $env:GITHUB_ENV
          $env:PLAYWRIGHT_VERSION="$(pnpm ls --depth 0 --json -w playwright-chromium | jq --raw-output '.[0].devDependencies["playwright-chromium"].version')"
          echo "PLAYWRIGHT_VERSION=$env:PLAYWRIGHT_VERSION" >> $env:GITHUB_ENV

      - name: Install Playwright
        # does not need to explicitly set chromium after https://github.com/microsoft/playwright/issues/14862 is solved
        run: pnpm playwright install chromium



================================================
FILE: .github/workflows/ecosystem-ci-trigger.yml
================================================
name: ecosystem-ci trigger

on:
  issue_comment:
    types: [created]

jobs:
  trigger:
    runs-on: ubuntu-latest
    if: github.repository == 'vitejs/vite' && github.event.issue.pull_request && startsWith(github.event.comment.body, '/ecosystem-ci run')
    permissions:
      issues: write # to add / delete reactions
      pull-requests: write # to read PR data, and to add labels
      actions: read # to check workflow status
      contents: read # to clone the repo
    steps:
      - name: Check User Permissions
        uses: actions/github-script@v7
        id: check-permissions
        with:
          script: |
            const user = context.payload.sender.login
            console.log(`Validate user: ${user}`)

            const additionalAllowedUsers = ['lukastaegert']

            let hasTriagePermission = false
            try {
              const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: user,
              });
              hasTriagePermission = data.user.permissions.triage
            } catch (e) {
              console.warn(e)
            }

            if (hasTriagePermission || additionalAllowedUsers.includes(user)) {
              console.log('User is allowed. Adding +1 reaction.')
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: '+1',
              })
            } else {
              console.log('User is not allowed. Adding -1 reaction.')
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: '-1',
              })
              throw new Error('User does not have the necessary permissions.')
            }

      - name: Get PR Data
        uses: actions/github-script@v7
        id: get-pr-data
        with:
          script: |
            console.log(`Get PR info: ${context.repo.owner}/${context.repo.repo}#${context.issue.number}`)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            })
            core.setOutput('head_sha', pr.head.sha)
            return {
              num: context.issue.number,
              branchName: pr.head.ref,
              commit: pr.head.sha,
              repo: pr.head.repo.full_name
            }

      - name: Check Package Existence
        uses: actions/github-script@v7
        id: check-package
        with:
          script: |
            const prData = ${{ steps.get-pr-data.outputs.result }}
            const url = `https://pkg.pr.new/vite@${prData.commit}`
            const response = await fetch(url)
            console.log(`Package check URL: ${url}, Status: ${response.status}`)

            // Add 'rocket' reaction to the issue comment
            if (response.status === 404) {
              const { data: reaction } = await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'rocket',
              })
              return { exists: false, reaction: reaction.id }
            }

            return { exists: true, reaction: null }

      - name: Generate Token
        id: generate-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.ECOSYSTEM_CI_GITHUB_APP_ID }}
          private-key: ${{ secrets.ECOSYSTEM_CI_GITHUB_APP_PRIVATE_KEY }}
          repositories: |
            vite
            vite-ecosystem-ci

      - name: Trigger Preview Release (if Package Not Found)
        if: fromJSON(steps.check-package.outputs.result).exists == false
        uses: actions/github-script@v7
        id: trigger-preview-release
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const prData = ${{ steps.get-pr-data.outputs.result }}
            console.log('Package not found, triggering preview release...')

            // Add label "trigger: preview" to the PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prData.num,
              labels: ['trigger: preview']
            })
            console.log('Added "trigger: preview" label.')

      - name: Wait for Preview Release Completion (if Package Not Found)
        if: fromJSON(steps.check-package.outputs.result).exists == false
        uses: actions/github-script@v7
        id: wait-preview-release
        with:
          script: |
            const prData = ${{ steps.get-pr-data.outputs.result }}
            const reaction = ${{ fromJSON(steps.check-package.outputs.result).reaction }}
            const workflowFileName = 'preview-release.yml'
            const workflow = await github.rest.actions.getWorkflow({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFileName,
            })
            const workflowId = workflow.data.id
            console.log(`Waiting for workflow ID ${workflowId} to complete...`)

            const maxRetries = 60 // Wait up to 10 minutes
            const delay = 10000 // 10 seconds
            let completed = false

            for (let i = 0; i < maxRetries; i++) {
              const runsData = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                head_sha: prData.commit,
                per_page: 100,
                page: 1,
              })

              const runs = runsData.data.workflow_runs

              if (runs.length > 0) {
                const latestRun = runs[0]
                console.log(`Latest run status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`)
                if (latestRun.status === 'completed') {
                  if (latestRun.conclusion === 'success') {
                    console.log('Preview release workflow completed successfully.')
                    completed = true
                    break
                  } else if (latestRun.conclusion === 'skipped') {
                   // noop
                  } else {
                    throw new Error('Preview Release workflow failed.')
                  }
                }
              }

              console.log(`Retrying... (${i + 1}/${maxRetries})`)
              await new Promise(resolve => setTimeout(resolve, delay))
            }

            if (!completed) {
              throw new Error('Preview Release workflow did not complete in time.')
            }

            // Remove the 'rocket' reaction
            if (reaction) {
              await github.rest.reactions.deleteForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                reaction_id: reaction,
              })
              console.log('Removed "rocket" reaction.')
            }

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ fromJSON(steps.get-pr-data.outputs.result).num }}/head
          fetch-depth: 0

      # This step can be removed on May 26 2025
      - name: Check Commit Hash Ambiguity
        id: check_ambiguity
        run: |
          HEAD_SHA=${{ steps.get-pr-data.outputs.head_sha }}
          COMMIT_SHORT=${HEAD_SHA:0:7}

          if git show "$COMMIT_SHORT"; then
            echo "COLLISION=false" >> $GITHUB_ENV
          else
            echo "COLLISION=true" >> $GITHUB_ENV
          fi

      - name: Trigger Downstream Workflow
        uses: actions/github-script@v7
        id: trigger
        env:
          COMMENT: ${{ github.event.comment.body }}
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const comment = process.env.COMMENT.trim()
            const prData = ${{ steps.get-pr-data.outputs.result }}

            const suite = comment.split('\n')[0].replace(/^\/ecosystem-ci run/, '').trim()

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'vite-ecosystem-ci',
              workflow_id: 'ecosystem-ci-from-pr.yml',
              ref: 'main',
              inputs: {
                prNumber: '' + prData.num,
                branchName: prData.branchName,
                repo: prData.repo,
                commit: process.env.COLLISION === 'false' ? prData.commit : '',
                suite: suite === '' ? '-' : suite
              }
            })



================================================
FILE: .github/workflows/issue-close-require.yml
================================================
name: Issue Close Require

on:
  schedule:
    - cron: "0 0 * * *"

jobs:
  close-issues:
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    permissions:
      issues: write # for actions-cool/issues-helper to update issues
      pull-requests: write # for actions-cool/issues-helper to update PRs
    steps:
      - name: needs reproduction
        uses: actions-cool/issues-helper@50068f49b7b2b3857270ead65e2d02e4459b022c # v3
        with:
          actions: "close-issues"
          token: ${{ secrets.GITHUB_TOKEN }}
          labels: "needs reproduction"
          inactive-day: 3



================================================
FILE: .github/workflows/issue-labeled.yml
================================================
name: Issue Labeled

on:
  issues:
    types: [labeled]

jobs:
  reply-labeled:
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    permissions:
      issues: write # for actions-cool/issues-helper to update issues
      pull-requests: write # for actions-cool/issues-helper to update PRs
    steps:
      - name: contribution welcome
        if: github.event.label.name == 'contribution welcome' || github.event.label.name == 'help wanted'
        uses: actions-cool/issues-helper@50068f49b7b2b3857270ead65e2d02e4459b022c # v3
        with:
          actions: "remove-labels"
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          labels: "pending triage, needs reproduction"

      - name: remove pending
        if: (github.event.label.name == 'enhancement' || contains(github.event.label.description, '(priority)')) && contains(github.event.issue.labels.*.name, 'pending triage')
        uses: actions-cool/issues-helper@50068f49b7b2b3857270ead65e2d02e4459b022c # v3
        with:
          actions: "remove-labels"
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          labels: "pending triage"

      - name: needs reproduction
        if: github.event.label.name == 'needs reproduction'
        uses: actions-cool/issues-helper@50068f49b7b2b3857270ead65e2d02e4459b022c # v3
        with:
          actions: "create-comment, remove-labels"
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            Hello @${{ github.event.issue.user.login }}. Please provide a [minimal reproduction](https://stackoverflow.com/help/minimal-reproducible-example) using a GitHub repository or [StackBlitz](https://vite.new). Issues marked with `needs reproduction` will be closed if they have no activity within 3 days.
          labels: "pending triage"



================================================
FILE: .github/workflows/lock-closed-issues.yml
================================================
name: Lock Closed Issues

on:
  schedule:
    - cron: "0 0 * * *"

permissions:
  issues: write

jobs:
  action:
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    steps:
      - uses: dessant/lock-threads@1bf7ec25051fe7c00bdd17e6a7cf3d7bfb7dc771 # v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          issue-inactive-days: "14"
          #issue-comment: |
          #  This issue has been locked since it has been closed for more than 14 days.
          #
          #  If you have found a concrete bug or regression related to it, please open a new [bug report](https://github.com/vitejs/vite/issues/new/choose) with a reproduction against the latest Vite version. If you have any other comments you should join the chat at [Vite Land](https://chat.vite.dev) or create a new [discussion](https://github.com/vitejs/vite/discussions).
          issue-lock-reason: ""
          process-only: "issues"



================================================
FILE: .github/workflows/preview-release.yml
================================================
name: Preview release

env:
  # install playwright binary manually (because pnpm only runs install script once)
  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

permissions:
  pull-requests: write

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, labeled]

jobs:
  preview:
    if: >
      github.repository == 'vitejs/vite' &&
      (github.event_name == 'push' ||
      (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'trigger: preview')))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Install dependencies
        run: pnpm install

      - name: Build
        working-directory: ./packages/vite
        run: pnpm build

      - run: pnpm dlx pkg-pr-new@0.0 publish --compact --pnpm ./packages/vite



================================================
FILE: .github/workflows/publish.yml
================================================
name: Publish Package

on:
  push:
    tags:
      - "v*" # Push events to matching v*, i.e. v1.0, v20.15.10
      - "plugin-*" # Push events to matching plugin-*, i.e. plugin-(vue|vue-jsx|react|legacy)@1.0.0
      - "create-vite*" # # Push events to matching create-vite*, i.e. create-vite@1.0.0

jobs:
  publish:
    # prevents this action from running on forks
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    environment: Release
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Set node version to 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: https://registry.npmjs.org/
          cache: "pnpm"

      - name: Install deps
        run: pnpm install
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"

      - name: Publish package
        run: pnpm run ci-publish ${{ github.ref_name }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}



================================================
FILE: .github/workflows/release-tag.yml
================================================
name: Add GitHub Release Tag

on:
  push:
    tags:
      - "v*" # Push events to matching v*, i.e. v1.0, v20.15.10
      - "plugin-*" # Push events to matching plugin-*, i.e. plugin-(vue|vue-jsx|react|legacy)@1.0.0
      - "create-vite*" # # Push events to matching create-vite*, i.e. create-vite@1.0.0

# $GITHUB_REF_NAME - https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables

jobs:
  release:
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    permissions:
      contents: write # for yyx990803/release-tag to create a release tag
    steps:
      - uses: actions/checkout@v4

      - name: Get pkgName for tag
        id: tag
        run: |
          # skip if alpha
          if [[ $GITHUB_REF_NAME =~ alpha ]]; then
            exit 0
          fi

          # matching v2.0.0 / v2.0.0-beta.8 etc
          if [[ $GITHUB_REF_NAME =~ ^v.+ ]]; then
            pkgName="vite"
          else
            # `%@*` truncates @ and version number from the right side.
            # https://stackoverflow.com/questions/9532654/expression-after-last-specific-character
            pkgName=${GITHUB_REF_NAME%@*}
          fi

          echo "pkgName=$pkgName" >> $GITHUB_OUTPUT

      - name: Create Release for Tag
        # only run if tag is not alpha
        if: steps.tag.outputs.pkgName
        id: release_tag
        uses: yyx990803/release-tag@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          body: |
            Please refer to [CHANGELOG.md](https://github.com/vitejs/vite/blob/${{ github.ref_name }}/packages/${{ steps.tag.outputs.pkgName }}/CHANGELOG.md) for details.



================================================
FILE: .github/workflows/semantic-pull-request.yml
================================================
name: Semantic Pull Request

on:
  pull_request_target:
    types:
      - opened
      - edited
      - synchronize

jobs:
  main:
    if: github.repository == 'vitejs/vite'
    runs-on: ubuntu-latest
    name: Semantic Pull Request
    permissions:
      pull-requests: read
    steps:
      - name: Validate PR title
        uses: amannn/action-semantic-pull-request@0723387faaf9b38adef4775cd42cfd5155ed6017 # v5
        with:
          subjectPattern: ^(?![A-Z]).+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            didn't match the configured pattern. Please ensure that the subject
            doesn't start with an uppercase character.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .stackblitz/codeflow.json
================================================
{
  "pnpm": {
    "overrides": {
      "vite": "./packages/vite",
      "@vitejs/plugin-legacy": "./packages/plugin-legacy"
    }
  }
}


