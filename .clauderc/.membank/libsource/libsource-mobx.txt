Directory structure:
â””â”€â”€ mobxjs-mobx/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CODE_OF_CONDUCT.md
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ jest.base.config.js
    â”œâ”€â”€ jest.config.js
    â”œâ”€â”€ lerna.json
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ package.json
    â”œâ”€â”€ SECURITY.md
    â”œâ”€â”€ sponsors.md
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ tsconfig.test.json
    â”œâ”€â”€ .editorconfig
    â”œâ”€â”€ .eslintrc.js
    â”œâ”€â”€ .prettierignore
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ .watchmanconfig
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ about-this-documentation.md
    â”‚   â”œâ”€â”€ actions.md
    â”‚   â”œâ”€â”€ analyzing-reactivity.md
    â”‚   â”œâ”€â”€ api.md
    â”‚   â”œâ”€â”€ backers-sponsors.md
    â”‚   â”œâ”€â”€ collection-utilities.md
    â”‚   â”œâ”€â”€ computeds-with-args.md
    â”‚   â”œâ”€â”€ computeds.md
    â”‚   â”œâ”€â”€ configuration.md
    â”‚   â”œâ”€â”€ custom-observables.md
    â”‚   â”œâ”€â”€ defining-data-stores.md
    â”‚   â”œâ”€â”€ enabling-decorators.md
    â”‚   â”œâ”€â”€ installation.md
    â”‚   â”œâ”€â”€ intercept-and-observe.md
    â”‚   â”œâ”€â”€ lazy-observables.md
    â”‚   â”œâ”€â”€ LINKS.md
    â”‚   â”œâ”€â”€ migrating-from-4-or-5.md
    â”‚   â”œâ”€â”€ mobx-utils.md
    â”‚   â”œâ”€â”€ observable-state.md
    â”‚   â”œâ”€â”€ react-integration.md
    â”‚   â”œâ”€â”€ react-optimizations.md
    â”‚   â”œâ”€â”€ reactions.md
    â”‚   â”œâ”€â”€ subclassing.md
    â”‚   â”œâ”€â”€ the-gist-of-mobx.md
    â”‚   â”œâ”€â”€ understanding-reactivity.md
    â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â”œâ”€â”€ action-state-view.excalidraw
    â”‚   â”‚   â”œâ”€â”€ flow.excalidraw..excalidraw..excalidraw
    â”‚   â”‚   â””â”€â”€ getting-started-assets/
    â”‚   â”‚       â”œâ”€â”€ script.js
    â”‚   â”‚       â”œâ”€â”€ style.css
    â”‚   â”‚       â”œâ”€â”€ javascripts/
    â”‚   â”‚       â”‚   â”œâ”€â”€ mobx-react.js
    â”‚   â”‚       â”‚   â””â”€â”€ codemirror/
    â”‚   â”‚       â”‚       â”œâ”€â”€ javascript/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ index.html
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ javascript.js
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ json-ld.html
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ test.js
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ typescript.html
    â”‚   â”‚       â”‚       â”œâ”€â”€ lib/
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ codemirror.css
    â”‚   â”‚       â”‚       â””â”€â”€ theme/
    â”‚   â”‚       â”‚           â””â”€â”€ xq-light.css
    â”‚   â”‚       â””â”€â”€ stylesheets/
    â”‚   â”‚           â”œâ”€â”€ github-light.css
    â”‚   â”‚           â””â”€â”€ stylesheet.css
    â”‚   â”œâ”€â”€ best/
    â”‚   â”‚   â”œâ”€â”€ debugging-mobx.md
    â”‚   â”‚   â”œâ”€â”€ decorators.md
    â”‚   â”‚   â”œâ”€â”€ store.md
    â”‚   â”‚   â””â”€â”€ what-does-mobx-react-to.md
    â”‚   â”œâ”€â”€ faq/
    â”‚   â”‚   â””â”€â”€ migrate-to-6.md
    â”‚   â”œâ”€â”€ intro/
    â”‚   â”‚   â”œâ”€â”€ concepts.md
    â”‚   â”‚   â”œâ”€â”€ how-to-read.md
    â”‚   â”‚   â””â”€â”€ installation.md
    â”‚   â”œâ”€â”€ react/
    â”‚   â”‚   â”œâ”€â”€ react-integration.md
    â”‚   â”‚   â””â”€â”€ react-performance.md
    â”‚   â”œâ”€â”€ refguide/
    â”‚   â”‚   â”œâ”€â”€ action.md
    â”‚   â”‚   â”œâ”€â”€ api.md
    â”‚   â”‚   â”œâ”€â”€ autorun.md
    â”‚   â”‚   â”œâ”€â”€ computed-with-args.md
    â”‚   â”‚   â”œâ”€â”€ computed.md
    â”‚   â”‚   â”œâ”€â”€ configure.md
    â”‚   â”‚   â”œâ”€â”€ extending.md
    â”‚   â”‚   â”œâ”€â”€ mobx-utils.md
    â”‚   â”‚   â”œâ”€â”€ modifiers.md
    â”‚   â”‚   â”œâ”€â”€ object-api.md
    â”‚   â”‚   â”œâ”€â”€ object.md
    â”‚   â”‚   â”œâ”€â”€ observable.md
    â”‚   â”‚   â”œâ”€â”€ observe.md
    â”‚   â”‚   â”œâ”€â”€ on-become-observed.md
    â”‚   â”‚   â””â”€â”€ set.md
    â”‚   â””â”€â”€ styles/
    â”‚       â””â”€â”€ website.css
    â”œâ”€â”€ packages/
    â”‚   â”œâ”€â”€ eslint-plugin-mobx/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”‚   â”œâ”€â”€ jest.config-eslint-7.js
    â”‚   â”‚   â”œâ”€â”€ jest.config-eslint-9.js
    â”‚   â”‚   â”œâ”€â”€ jest.setup.js
    â”‚   â”‚   â”œâ”€â”€ LICENSE
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ rollup.config.js
    â”‚   â”‚   â”œâ”€â”€ .babelrc.js
    â”‚   â”‚   â”œâ”€â”€ __tests__/
    â”‚   â”‚   â”‚   â”œâ”€â”€ exhaustive-make-observable.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ missing-make-observable.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ missing-observer.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ no-anonymous-observer.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ unconditional-make-observable.js
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â””â”€â”€ get-rule-tester.js
    â”‚   â”‚   â”œâ”€â”€ preview/
    â”‚   â”‚   â”‚   â”œâ”€â”€ make-observable.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ missing-observer.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ no-anonymous-observer.js
    â”‚   â”‚   â”‚   â””â”€â”€ .eslintrc.js
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ exhaustive-make-observable.js
    â”‚   â”‚       â”œâ”€â”€ index.js
    â”‚   â”‚       â”œâ”€â”€ missing-make-observable.js
    â”‚   â”‚       â”œâ”€â”€ missing-observer.js
    â”‚   â”‚       â”œâ”€â”€ no-anonymous-observer.js
    â”‚   â”‚       â”œâ”€â”€ unconditional-make-observable.js
    â”‚   â”‚       â””â”€â”€ utils.js
    â”‚   â”œâ”€â”€ mobx/
    â”‚   â”‚   â”œâ”€â”€ jest.config-decorators.js
    â”‚   â”‚   â”œâ”€â”€ jest.config.js
    â”‚   â”‚   â”œâ”€â”€ jest.setup.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ tsdx.config.js
    â”‚   â”‚   â”œâ”€â”€ .flowconfig
    â”‚   â”‚   â”œâ”€â”€ __tests__/
    â”‚   â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”‚   â”œâ”€â”€ .babelrc
    â”‚   â”‚   â”‚   â”œâ”€â”€ decorators_20223/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ stage3-decorators.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ tsconfig.json
    â”‚   â”‚   â”‚   â”œâ”€â”€ mixed-versions/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mixed-versions.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ state-sharing.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ perf/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ perf.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ v4/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mobx4.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ base/
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ array.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ autorun.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ cycles.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ extendObservable.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ extras.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ intercept.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ jsconfig.json
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ makereactive.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ nested.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ object-api.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ observables.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ observe.ts
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ spy.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ tojs.js
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ untracked.ts
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ __snapshots__/
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ array.js.snap
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ extras.js.snap
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ makereactive.js.snap
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ object-api.js.snap
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ observables.js.snap
    â”‚   â”‚   â”‚   â”‚           â””â”€â”€ spy.js.snap
    â”‚   â”‚   â”‚   â””â”€â”€ v5/
    â”‚   â”‚   â”‚       â”œâ”€â”€ base/
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ action.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ api.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ array.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ autorun.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ autorunAsync.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ babel-decorators.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ babel-tests.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ become-observed.ts
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ cycles.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ decorate.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ errorhandling.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ extendObservable.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ extras.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ flow.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ intercept.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ make-observable.ts
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ makereactive.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ map.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ nested.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ object-api-proxy.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ object-api.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ observe.ts
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ proxies.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ reaction.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ set.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ spy.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ strict-mode.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ tojs.js
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ trace.ts
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ typescript-decorators.ts
    â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ untracked.ts
    â”‚   â”‚   â”‚       â”‚   â””â”€â”€ __snapshots__/
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ action.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ extras.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ flow.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ makereactive.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ object-api.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ observables.js.snap
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ proxies.js.snap
    â”‚   â”‚   â”‚       â”‚       â””â”€â”€ spy.js.snap
    â”‚   â”‚   â”‚       â”œâ”€â”€ flow/
    â”‚   â”‚   â”‚       â”‚   â””â”€â”€ test.js
    â”‚   â”‚   â”‚       â””â”€â”€ utils/
    â”‚   â”‚   â”‚           â””â”€â”€ test-utils.ts
    â”‚   â”‚   â”œâ”€â”€ flow-typed/
    â”‚   â”‚   â”‚   â””â”€â”€ mobx.js
    â”‚   â”‚   â”œâ”€â”€ scripts/
    â”‚   â”‚   â”‚   â”œâ”€â”€ perf.sh
    â”‚   â”‚   â”‚   â””â”€â”€ prepublish.js
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ errors.ts
    â”‚   â”‚       â”œâ”€â”€ global.d.ts
    â”‚   â”‚       â”œâ”€â”€ internal.ts
    â”‚   â”‚       â”œâ”€â”€ mobx.ts
    â”‚   â”‚       â”œâ”€â”€ api/
    â”‚   â”‚       â”‚   â”œâ”€â”€ action.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ annotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ autorun.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ become-observed.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ computed.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ configure.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ decorators.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ extendobservable.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ extras.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ flow.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ intercept-read.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ intercept.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ iscomputed.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ isobservable.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ makeObservable.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ object-api.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observable.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observe.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ tojs.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ trace.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ transaction.ts
    â”‚   â”‚       â”‚   â””â”€â”€ when.ts
    â”‚   â”‚       â”œâ”€â”€ core/
    â”‚   â”‚       â”‚   â”œâ”€â”€ action.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ atom.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ computedvalue.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ derivation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ globalstate.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observable.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ reaction.ts
    â”‚   â”‚       â”‚   â””â”€â”€ spy.ts
    â”‚   â”‚       â”œâ”€â”€ types/
    â”‚   â”‚       â”‚   â”œâ”€â”€ actionannotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ autoannotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ computedannotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ decorator_fills.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ dynamicobject.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ flowannotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ generic-abort-signal.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ intercept-utils.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ legacyobservablearray.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ listen-utils.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ modifiers.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observableannotation.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observablearray.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observablemap.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observableobject.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observableset.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ observablevalue.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ overrideannotation.ts
    â”‚   â”‚       â”‚   â””â”€â”€ type-utils.ts
    â”‚   â”‚       â””â”€â”€ utils/
    â”‚   â”‚           â”œâ”€â”€ comparer.ts
    â”‚   â”‚           â”œâ”€â”€ eq.ts
    â”‚   â”‚           â”œâ”€â”€ global.ts
    â”‚   â”‚           â”œâ”€â”€ iterable.ts
    â”‚   â”‚           â””â”€â”€ utils.ts
    â”‚   â”œâ”€â”€ mobx-react/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ batchingForReactDom.js
    â”‚   â”‚   â”œâ”€â”€ batchingForReactNative.js
    â”‚   â”‚   â”œâ”€â”€ batchingOptOut.js
    â”‚   â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”‚   â”œâ”€â”€ jest.config.js
    â”‚   â”‚   â”œâ”€â”€ jest.setup.ts
    â”‚   â”‚   â”œâ”€â”€ LICENSE
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.test.json
    â”‚   â”‚   â”œâ”€â”€ tsdx.config.js
    â”‚   â”‚   â”œâ”€â”€ .browserlistrc
    â”‚   â”‚   â”œâ”€â”€ __mocks__/
    â”‚   â”‚   â”‚   â””â”€â”€ react-native.js
    â”‚   â”‚   â”œâ”€â”€ __tests__/
    â”‚   â”‚   â”‚   â”œâ”€â”€ context.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ disposeOnUnmount.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ finalizationRegistry.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ hooks.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ inject.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ issue21.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ issue806.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ misc.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ observer.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ propTypes.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ Provider.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ stateless.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ timerBasedFinalizationRegistry.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ transactions.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”‚   â”œâ”€â”€ .eslintrc.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ __snapshots__/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ hooks.test.tsx.snap
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ observer.test.tsx.snap
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ stateless.test.tsx.snap
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â”œâ”€â”€ compile-ts.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ ErrorCatcher.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ killFinalizationRegistry.ts
    â”‚   â”‚   â”‚       â””â”€â”€ withConsole.ts
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ disposeOnUnmount.ts
    â”‚   â”‚       â”œâ”€â”€ globals.d.ts
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ inject.ts
    â”‚   â”‚       â”œâ”€â”€ observer.tsx
    â”‚   â”‚       â”œâ”€â”€ observerClass.ts
    â”‚   â”‚       â”œâ”€â”€ propTypes.ts
    â”‚   â”‚       â”œâ”€â”€ Provider.tsx
    â”‚   â”‚       â”œâ”€â”€ types/
    â”‚   â”‚       â”‚   â”œâ”€â”€ IReactComponent.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ IStoresToProps.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ IValueMap.ts
    â”‚   â”‚       â”‚   â””â”€â”€ IWrappedComponent.ts
    â”‚   â”‚       â””â”€â”€ utils/
    â”‚   â”‚           â””â”€â”€ utils.ts
    â”‚   â”œâ”€â”€ mobx-react-lite/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ batchingForReactDom.js
    â”‚   â”‚   â”œâ”€â”€ batchingForReactNative.js
    â”‚   â”‚   â”œâ”€â”€ batchingOptOut.js
    â”‚   â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”‚   â”œâ”€â”€ jest.config.js
    â”‚   â”‚   â”œâ”€â”€ jest.setup.ts
    â”‚   â”‚   â”œâ”€â”€ LICENSE
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.build.cjs.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.build.es.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.build.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.test.json
    â”‚   â”‚   â”œâ”€â”€ tsdx.config.js
    â”‚   â”‚   â”œâ”€â”€ .eslintignore
    â”‚   â”‚   â”œâ”€â”€ __tests__/
    â”‚   â”‚   â”‚   â”œâ”€â”€ api.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ assertEnvironment.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ enforceActions.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ observer.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ObserverComponent.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ printDebugValue.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ strictAndConcurrentMode.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ strictAndConcurrentModeUsingFinalizationRegistry.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ strictAndConcurrentModeUsingTimers.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ transactions.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”‚   â”œâ”€â”€ useAsObservableSource.deprecated.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ useAsObservableSource.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ useLocalObservable.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ useLocalStore.deprecated.test.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ utils.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ .eslintrc.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ __snapshots__/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ observer.test.tsx.snap
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ printDebugValue.test.ts.snap
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAsObservableSource.deprecated.test.tsx.snap
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useLocalStore.deprecated.test.tsx.snap
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â””â”€â”€ killFinalizationRegistry.ts
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ observer.ts
    â”‚   â”‚       â”œâ”€â”€ ObserverComponent.ts
    â”‚   â”‚       â”œâ”€â”€ staticRendering.ts
    â”‚   â”‚       â”œâ”€â”€ useAsObservableSource.ts
    â”‚   â”‚       â”œâ”€â”€ useLocalObservable.ts
    â”‚   â”‚       â”œâ”€â”€ useLocalStore.ts
    â”‚   â”‚       â”œâ”€â”€ useObserver.ts
    â”‚   â”‚       â””â”€â”€ utils/
    â”‚   â”‚           â”œâ”€â”€ assertEnvironment.ts
    â”‚   â”‚           â”œâ”€â”€ observerBatching.ts
    â”‚   â”‚           â”œâ”€â”€ observerFinalizationRegistry.ts
    â”‚   â”‚           â”œâ”€â”€ printDebugValue.ts
    â”‚   â”‚           â”œâ”€â”€ reactBatchedUpdates.native.ts
    â”‚   â”‚           â”œâ”€â”€ reactBatchedUpdates.ts
    â”‚   â”‚           â”œâ”€â”€ UniversalFinalizationRegistry.ts
    â”‚   â”‚           â””â”€â”€ utils.ts
    â”‚   â””â”€â”€ mobx-undecorate/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ CHANGELOG.md
    â”‚       â”œâ”€â”€ cli.js
    â”‚       â”œâ”€â”€ jest.config.js
    â”‚       â”œâ”€â”€ LICENSE
    â”‚       â”œâ”€â”€ package.json
    â”‚       â”œâ”€â”€ tsconfig.json
    â”‚       â”œâ”€â”€ __tests__/
    â”‚       â”‚   â”œâ”€â”€ cli.spec.tsx
    â”‚       â”‚   â”œâ”€â”€ tsconfig.json
    â”‚       â”‚   â””â”€â”€ undecorate.spec.ts
    â”‚       â””â”€â”€ src/
    â”‚           â””â”€â”€ undecorate.ts
    â”œâ”€â”€ scripts/
    â”‚   â””â”€â”€ build.js
    â”œâ”€â”€ website/
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ sidebars.json
    â”‚   â”œâ”€â”€ siteConfig.js
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â””â”€â”€ Footer.js
    â”‚   â”œâ”€â”€ i18n/
    â”‚   â”‚   â””â”€â”€ en.json
    â”‚   â””â”€â”€ static/
    â”‚       â”œâ”€â”€ getting-started.html
    â”‚       â”œâ”€â”€ index.html
    â”‚       â”œâ”€â”€ css/
    â”‚       â”‚   â””â”€â”€ custom.css
    â”‚       â””â”€â”€ js/
    â”‚           â””â”€â”€ scripts.js
    â”œâ”€â”€ .changeset/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ config.json
    â”‚   â””â”€â”€ fair-houses-rhyme.md
    â””â”€â”€ .github/
        â”œâ”€â”€ dependabot.yml
        â”œâ”€â”€ FUNDING.yml
        â”œâ”€â”€ lock.yml
        â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md
        â”œâ”€â”€ stale.yml
        â”œâ”€â”€ ISSUE_TEMPLATE/
        â”‚   â”œâ”€â”€ bug.md
        â”‚   â”œâ”€â”€ config.yml
        â”‚   â””â”€â”€ documentation.md
        â””â”€â”€ workflows/
            â”œâ”€â”€ build_and_test.yml
            â”œâ”€â”€ coveralls.yml
            â””â”€â”€ release.yml

================================================
FILE: README.md
================================================
<img src="https://mobx.js.org/assets/mobx.png" alt="logo" height="120" align="right" />

# MobX

_Simple, scalable state management._

[![npm version](https://badge.fury.io/js/mobx.svg)](https://badge.fury.io/js/mobx)
[![OpenCollective](https://opencollective.com/mobx/backers/badge.svg)](docs/backers-sponsors.md#backers)
[![OpenCollective](https://opencollective.com/mobx/sponsors/badge.svg)](docs/backers-sponsors.md#sponsors)
[![Discuss on Github](https://img.shields.io/badge/discuss%20on-GitHub-orange)](https://github.com/mobxjs/mobx/discussions)
[![Coverage Status](https://coveralls.io/repos/github/mobxjs/mobx/badge.svg?branch=main)](https://coveralls.io/github/mobxjs/mobx?branch=main)
[![View changelog](https://img.shields.io/badge/changelogs.xyz-Explore%20Changelog-brightgreen)](https://changelogs.xyz/mobx)

---

## Documentation

Documentation can be found at **[mobx.js.org](https://mobx.js.org/)**.

---

## Sponsors

MobX is made possible by the generosity of the sponsors below, and many other [individual backers](https://github.com/mobxjs/mobx/blob/main/docs/backers-sponsors.md#backers). Sponsoring directly impacts the longevity of this project.

**ğŸ¥‡ğŸ¥‡ Platinum sponsors (\$5000+ total contribution): ğŸ¥‡ğŸ¥‡**

<br/>
<a href="https://www.guilded.gg/"><img src="https://mobx.js.org/assets/guilded.jpg" align="center" width="100" title="Guilded" alt="Guilded" /></a>
<a href="https://www.canva.com/"><img src="https://mobx.js.org/assets/canva.svg" align="center" width="100" title="Canva" alt="Canva" /></a>
<a href="https://www.getparallax.com/"><img src="https://mobx.js.org/assets/parallax.png" align="center" width="100" title="Parallax" alt="Parallax" /></a>

**ğŸ¥‡ Gold sponsors (\$2500+ total contribution):**

<br/>
<a href="https://www.one-beyond.com"><img src="https://mobx.js.org/assets/dcsl.png" align="center" width="100" title="One Beyond" alt="One Beyond"/></a>
<a href="https://frontendmasters.com/"><img src="https://mobx.js.org/assets/frontendmasters.jpg" align="center" width="100" title="Frontend Masters" alt="Frontend Masters"></a>
<a href="http://auctionfrontier.com/"><img src="https://mobx.js.org/assets/auctionfrontier.jpeg" align="center" width="100" title="Auction Frontier" alt="Auction Frontier"></a>
<a href="https://www.codefirst.co.uk/"><img src="https://mobx.js.org/assets/codefirst.png" align="center" width="100" title="CodeFirst" alt="CodeFirst"/></a>
<a href="https://modulz.app/"><img src="https://mobx.js.org/assets/modulz.png" align="center" width="100" title="Modulz" alt="Modulz"/></a>
<a href="https://coinbase.com/"><img src="https://mobx.js.org/assets/coinbase.jpeg" align="center" width="100" title="Coinbase" alt="Coinbase" /></a>
<a href="https://curology.com/blog/tech"><img src="https://mobx.js.org/assets/curology.png" align="center" width="100" title="Curology" alt="Curology"/></a>
<a href="https://mendix.com/"><img src="https://mobx.js.org/assets/mendix-logo.png" align="center" width="100" title="Mendix" alt="Mendix" /></a>
<a href="https://opensource.facebook.com/"><img src="https://mobx.js.org/assets/fbos.jpeg" align="center" width="100" title="Facebook Open Source" alt="Facebook Open Source" /></a>
<a href="https://casinosites.ltd.uk/?utm_source=sponsorship&utm_medium=mobx&utm_campaign=readme"><img src="https://mobx.js.org/assets/casino2.png" align="center" width="100" title="Casino Sites" alt="Casino Sites"/></a>
<a href="https://www.bugsnag.com/platforms/react-error-reporting?utm_source=MobX&utm_medium=Website&utm_content=open-source&utm_campaign=2019-community&utm_term=20190913"><img src="https://mobx.js.org/assets/bugsnag.jpg" align="center" width="100" title="Bugsnag" alt="Bugsnag"/></a>

**ğŸ¥ˆ Silver sponsors (\$500+ total contributions):**<br/>

<a href="https://mantro.net/jobs/warlock"><img src="https://mobx.js.org/assets/mantro.png" align="center" width="100" title="mantro GmbH" alt="mantro GmbH"></a>
<a href="https://www.xh.com/"><img src="https://mobx.js.org/assets/xh.png" align="center" width="100" title="Extremely Heavy" alt="Extremely Heavy" /></a>
<a href="https://www.algolia.com/"><img src="https://mobx.js.org/assets/algolia.jpg" align="center" width="100" title="Algolia" alt="Algolia" /></a>
<a href="https://space307.com/?utm_source=sponsorship&utm_medium=mobx&utm_campaign=readme"><img src="https://mobx.js.org/assets/space307.png" align="center" width="100" title="Space307" alt="Space307"/></a>
<a href="https://blokt.com/"><img src="https://mobx.js.org/assets/blokt.jpg" align="center" width="100" title="Blokt" alt="Blokt"/></a>
<a href="https://upper.co/?utm_source=github_mobxjs_sponsorship&utm_medium=paid_acquisition&utm_campaign=sponsorship"><img src="https://mobx.js.org/assets/upper.png" align="center" width="100" title="UPPER" alt="UPPER"/></a>
<a href="https://careers.dazn.com/"><img src="https://mobx.js.org/assets/dazn.png" align="center" width="100" title="DAZN" alt="DAZN"></a>
<a href="https://talentplot.com/"><img src="https://mobx.js.org/assets/talentplot.png" align="center" width="100" title="talentplot" alt="talentplot"></a>
<a href="https://www.easeus.com/?utm_source=github_mobxjs_sponsorship&utm_medium=readme&utm_campaign=sponsorship"><img src="https://mobx.js.org/assets/easeus.png" align="center" width="100" title="EaseUS" alt="EaseUS"/></a>
<a href="https://route4me.com/"><img src="https://mobx.js.org/assets/route4me.png" align="center" width="100" title="Route Planner and Route Optimizer" alt="Route Planner and Route Optimizer"/></a>
<a href="https://handsontable.com/docs/react-data-grid/?utm_source=Mobx_homepage&utm_medium=sponsorship&utm_campaign=library_sponsorship"><img src="https://mobx.js.org/assets/handsontable.png" align="center" width="100" title="Handsontable" alt="Handsontable"/></a>

## Introduction

_Anything that can be derived from the application state, should be. Automatically._

MobX is a signal based, battle-tested library that makes state management simple and scalable by transparently applying functional reactive programming.
The philosophy behind MobX is simple:

<div class="benefits">
    <div>
        <div class="pic">ğŸ˜™</div>
        <div>
            <h4>Straightforward</h4>
            <p>Write minimalistic, boilerplate-free code that captures your intent.
            Trying to update a record field? Simply use a normal JavaScript assignment â€”
            the reactivity system will detect all your changes and propagate them out to where they are being used.
            No special tools are required when updating data in an asynchronous process.
            </p>
        </div>
    </div>
    <div>
        <div class="pic">ğŸš…</div>
        <div>
            <h4>Effortless optimal rendering</h4>
            <p>
                All changes to and uses of your data are tracked at runtime, building a dependency tree that captures all relations between state and output.
                This guarantees that computations that depend on your state, like React components, run only when strictly needed.
                There is no need to manually optimize components with error-prone and sub-optimal techniques like memoization and selectors.
            </p>
        </div>
    </div>
    <div>
        <div class="pic">ğŸ¤¹ğŸ»â€â™‚ï¸</div>
        <div>
            <h4>Architectural freedom</h4>
            <p>
                MobX is unopinionated and allows you to manage your application state outside of any UI framework.
                This makes your code decoupled, portable, and above all, easily testable.
            </p>
        </div>
    </div>
</div>

---

## A quick example

So what does code that uses MobX look like?

```javascript
import React from "react"
import ReactDOM from "react-dom"
import { makeAutoObservable } from "mobx"
import { observer } from "mobx-react-lite"

// Model the application state.
function createTimer() {
    return makeAutoObservable({
        secondsPassed: 0,
        increase() {
            this.secondsPassed += 1
        },
        reset() {
            this.secondsPassed = 0
        }
    })
}

const myTimer = createTimer()

// Build a "user interface" that uses the observable state.
const TimerView = observer(({ timer }) => (
    <button onClick={() => timer.reset()}>Seconds passed: {timer.secondsPassed}</button>
))

ReactDOM.render(<TimerView timer={myTimer} />, document.body)

// Update the 'Seconds passed: X' text every second.
setInterval(() => {
    myTimer.increase()
}, 1000)
```

The `observer` wrapper around the `TimerView` React component will automatically detect that rendering
depends on the `timer.secondsPassed` observable, even though this relationship is not explicitly defined. The reactivity system will take care of re-rendering the component when _precisely that_ field is updated in the future.

Every event (`onClick` / `setInterval`) invokes an _action_ (`myTimer.increase` / `myTimer.reset`) that updates _observable state_ (`myTimer.secondsPassed`).
Changes in the observable state are propagated precisely to all _computations_ and _side effects_ (`TimerView`) that depend on the changes being made.

<img alt="MobX unidirectional flow" src="https://mobx.js.org/assets/flow2.png" align="center" />

This conceptual picture can be applied to the above example, or any other application using MobX.

## Getting started

To learn about the core concepts of MobX using a larger example, check out **[The gist of MobX](https://mobx.js.org/the-gist-of-mobx.html)** page, or take the **[10 minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)**.
The philosophy and benefits of the mental model provided by MobX are also described in great detail in the blog posts [UI as an afterthought](https://michel.codes/blogs/ui-as-an-afterthought) and [How to decouple state and UI (a.k.a. you donâ€™t need componentWillMount)](https://hackernoon.com/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37).

## Further resources

-   The [MobX cheat sheet](https://gum.co/fSocU) (Â£5) is both useful and sponsors the project
-   [10 minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)
-   [Egghead.io course, based on MobX 3](https://egghead.io/courses/manage-complex-state-in-react-apps-with-mobx)
-   The [MobX awesome list](https://github.com/mobxjs/awesome-mobx#awesome-mobx) â€“ a long list of MobX resources and example projects

### The MobX book

<a href="https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837"><img src="https://mobx.js.org/assets/book.jpg" height="120px" /></a>

The **[MobX Quick Start Guide](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837)** ($24.99) by [Pavan Podila](https://twitter.com/pavanpodila) and [Michel Weststrate](https://twitter.com/mweststrate) is available as an [ebook](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837), [paperback](https://www.amazon.com/MobX-Quick-Start-Guide-Supercharge/dp/1789344832), and on the [O'Reilly platform](https://www.oreilly.com/library/view/mobx-quick-start/9781789344837/) (see [preview](https://books.google.com/books?id=ALFmDwAAQBAJ&printsec=frontcover#v=onepage&q&f=false)).

### Videos

-   [Introduction to MobX & React in 2020](https://www.youtube.com/watch?v=pnhIJA64ByY) by Leigh Halliday, _17 min_.
-   [ReactNext 2016: Real World MobX](https://www.youtube.com/watch?v=Aws40KOx90U) by Michel Weststrate, _40 min_, [slides](https://docs.google.com/presentation/d/1DrI6Hc2xIPTLBkfNH8YczOcPXQTOaCIcDESdyVfG_bE/edit?usp=sharing).
-   [CityJS 2020: MobX, from mutable to immutable, to observable data](https://youtu.be/sP7dtZm_Wx0?t=27050) by Michel Weststrate, _30 min_.
-   [OpenSourceNorth: Practical React with MobX (ES5)](https://www.youtube.com/watch?v=XGwuM_u7UeQ) by Matt Ruby, _42 min_.
-   [HolyJS 2019: MobX and the unique symbiosis of predictability and speed](https://www.youtube.com/watch?v=NBYbBbjZeX4&list=PL8sJahqnzh8JJD7xahG5zXkjfM5GOgcPA&index=21&t=0s) by Michel Weststrate, _59 min_.
-   [React Amsterdam 2016: State Management Is Easy](https://www.youtube.com/watch?v=ApmSsu3qnf0&feature=youtu.be) by Michel Weststrate, _20 min_, [slides](https://speakerdeck.com/mweststrate/state-management-is-easy-introduction-to-mobx).
-   {ğŸš€} [React Live 2019: Reinventing MobX](https://www.youtube.com/watch?v=P_WqKZxpX8g) by Max Gallo, _27 min_.

## Credits

MobX is inspired by reactive programming principles, which are for example used in spreadsheets. It is inspired by modelâ€“viewâ€“viewmodel frameworks like [MeteorJS's Tracker](https://docs.meteor.com/api/tracker.html), [Knockout](https://knockoutjs.com/) and [Vue.js](https://vuejs.org/), but MobX brings _transparent functional reactive programming_ (TFRP, a concept which is further explained in the [MobX book](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837)) to the next level and provides a standalone implementation. It implements TFRP in a glitch-free, synchronous, predictable and efficient manner.

A ton of credit goes to [Mendix](https://github.com/mendix), for providing the flexibility and support to maintain MobX and the chance to prove the philosophy of MobX in a real, complex, performance critical applications.



================================================
FILE: CODE_OF_CONDUCT.md
================================================
Contributor Code of Conduct

As contributors and maintainers of the MobX project, we pledge to respect everyone who contributes by posting issues, updating documentation, submitting pull requests, providing feedback in comments, and any other activities.

Communication through GitHub, Gitter, email or any other channel must be constructive and never resort to personal attacks, trolling, public or private harassment, insults, or other unprofessional conduct.

We promise to extend courtesy and respect to everyone involved in this project regardless of gender, gender identity, sexual orientation, disability, age, race, ethnicity, religion, or level of experience. We expect anyone contributing to the project to do the same.

If any member of the community violates this code of conduct, the maintainers of the MobX project may take action, removing issues, comments, and PRs or blocking accounts as deemed appropriate.

If you are subject to or witness unacceptable behavior, or have any other concerns, please open an issue or send a direct message to [Michel](https://twitter.com/mweststrate) on Twitter.



================================================
FILE: CONTRIBUTING.md
================================================
# MobX Contributor Guide

Welcome to a community of developers just like you, striving to create the best experience around MobX. We welcome anyone who wants to contribute or provide constructive feedback, no matter the age or level of experience.

Here are some ways to contribute to the project, from easiest to most difficult:

-   [Reporting bugs](#reporting-bugs)
-   [Improving the documentation](#improving-the-documentation)
-   [Responding to issues](#responding-to-issues)
-   [Small bug fixes](#small-bug-fixes)

## Issues

### Reporting bugs

If you encounter a bug, please file an issue on GitHub via the repository of the sub-project you think contains the bug. If an issue you have is already reported, please add additional information or add a ğŸ‘ reaction to indicate your agreement.

Include in the issue a link to your reproduction. A couple good options are a small Github repo or a [CodeSandbox](https://codesandbox.io/s/minimal-mobx-react-project-ppgml).

If you have a more complicated issue where it is helpful to run it locally, you can download CodeSandbox template and work on it and then commit into your GitHub repo.

### Improving the documentation

Improving the documentation, examples, and other open source content can be the easiest way to contribute to the library. If you see a piece of content that can be better, open a PR with an improvement, no matter how small! If you would like to suggest a big change or major rewrite, weâ€™d love to hear your ideas but please open an issue for discussion before writing the PR.

### Responding to issues

In addition to reporting issues, a great way to contribute to MobX is to respond to other peoples' issues and try to identify the problem or help them work around it. If youâ€™re interested in taking a more active role in this process, please go ahead and respond to issues.

### Small bug fixes

For a small bug fix change (less than 20 lines of code changed), feel free to open a pull request. Weâ€™ll try to merge it as fast as possible and ideally publish a new release on the same day. The only requirement is, make sure you also add a test that verifies the bug you are trying to fix.

#### Getting things running

```
git clone git@github.com:mobxjs/mobx.git
cd mobx
yarn install
yarn lerna run build
yarn test
```




================================================
FILE: jest.base.config.js
================================================
const fs = require("fs")
const path = require("path")

module.exports = function buildConfig(
    packageDirectory,
    pkgConfig,
    tsConfig = "tsconfig.test.json"
) {
    const packageName = require(`${packageDirectory}/package.json`).name
    const packageTsconfig = path.resolve(packageDirectory, tsConfig)
    return {
        preset: "ts-jest/presets/js-with-ts",
        testEnvironment: "jsdom",
        globals: {
            __DEV__: true
        },
        transform: {
            "^.+\\.[jt]sx?$": [
                "ts-jest",
                {
                    tsconfig: fs.existsSync(packageTsconfig)
                        ? packageTsconfig
                        : path.resolve(__dirname, tsConfig)
                }
            ]
        },
        testRegex: "__tests__/.*\\.(j|t)sx?$",
        coverageDirectory: "<rootDir>/coverage/",
        coverageReporters: ["lcov", "text"],
        collectCoverageFrom: ["<rootDir>/src/**/*.{ts,tsx}", "!**/node_modules/**"],
        displayName: packageName,
        ...pkgConfig
    }
}



================================================
FILE: jest.config.js
================================================
const buildConfig = require("./jest.base.config")

module.exports = buildConfig(__dirname, {
    projects: ["<rootDir>/packages/*/jest.config.js", "<rootDir>/packages/*/jest.config-*.js"]
    // collectCoverageFrom: ["<rootDir>/packages/*/src/**/*.{ts,tsx}"]
})



================================================
FILE: lerna.json
================================================
{
    "packages": ["packages/*"],
    "version": "independent",
    "npmClient": "yarn",
    "useWorkspaces": true
}



================================================
FILE: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 Michel Weststrate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
    "name": "mobx-root",
    "private": true,
    "workspaces": [
        "packages/*"
    ],
    "resolutions": {
        "jest": "^29.5.0",
        "typescript": "^5.6.2",
        "recast": "^0.23.1"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git"
    },
    "scripts": {
        "test": "jest",
        "coverage": "jest --coverage",
        "lint": "eslint packages/*/src/**/* --ext .js,.ts,.tsx",
        "prettier": "prettier --write **/*.{js,ts,md}",
        "release": "yarn lerna run prepublishOnly && yarn changeset publish",
        "mobx": "yarn workspace mobx",
        "mobx-react": "yarn workspace mobx-react",
        "mobx-react-lite": "yarn workspace mobx-react-lite",
        "mobx-undecorate": "yarn workspace mobx-undecorate",
        "eslint-plugin-mobx": "yarn workspace eslint-plugin-mobx",
        "docs:build": "yarn --cwd website build",
        "docs:start": "yarn --cwd website start",
        "docs:publish": "yarn --cwd website publish-gh-pages",
        "prepare": "yarn dedup && yarn --cwd website install",
        "dedup": "npx yarn-deduplicate --strategy fewer yarn.lock"
    },
    "devDependencies": {
        "@changesets/changelog-github": "^0.2.7",
        "@changesets/cli": "^2.11.0",
        "@testing-library/dom": "^10.4.0",
        "@testing-library/jest-dom": "^5.16.4",
        "@testing-library/react": "^16.1.0",
        "@types/jest": "^26.0.15",
        "@types/node": "18",
        "@types/prop-types": "^15.5.2",
        "@types/react": "^18.0.0",
        "@types/react-dom": "^18.0.0",
        "@typescript-eslint/eslint-plugin": "^5.0.0",
        "@typescript-eslint/parser": "^5.0.0",
        "coveralls": "^3.1.0",
        "eslint": "^6.8.0",
        "execa": "^4.1.0",
        "fs-extra": "9.0.1",
        "husky": "^4.2.5",
        "import-size": "^1.0.2",
        "iterall": "^1.3.0",
        "jest": "^29.5.0",
        "jest-environment-jsdom": "^29.5.0",
        "jest-mock-console": "^1.0.1",
        "lerna": "^3.22.1",
        "lint-staged": "^10.1.7",
        "lodash": "^4.17.4",
        "minimist": "^1.2.5",
        "mkdirp": "1.0.4",
        "prettier": "^2.8.4",
        "pretty-quick": "3.1.0",
        "prop-types": "15.6.2",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-test-renderer": "^18.0.0",
        "serializr": "^2.0.3",
        "tape": "^5.0.1",
        "ts-jest": "^29.0.5",
        "tsdx": "^0.14.1",
        "typescript": "^5.6.2"
    },
    "husky": {
        "hooks": {
            "pre-commit": "pretty-quick --staged"
        }
    },
    "packageManager": "yarn@1.22.21+sha1.1959a18351b811cdeedbd484a8f86c3cc3bbaf72"
}



================================================
FILE: SECURITY.md
================================================
# Security Policy

All our packages are provided as-is without guarantees or SLAs.
Security issues will be handled with appropriate urgency but without warranties.

## Supported Versions

Security issues must be reported against latest version of each package (as found on NPM) and will not be back-ported. 

## Reporting a Vulnerability

Security issues can be reported at info@michel.codes. Since this software is provided as-is no follow up, remediation or time lines are guaranteed.



================================================
FILE: sponsors.md
================================================
# MobX Sponsors

This is the list of individual or one time contributions!

Our monthly donors can be found on open collective https://opencollective.com/mobx#contributors!
Monthly donations can be done through https://opencollective.com/mobx.

Want to make a one-time contribution? https://mobxjs.github.io/mobx/donate.html

-   Anders SjÃ¶berg
-   Andrei Zvonimir CrnkoviÄ‡
-   Andy Kogut
-   Anri Asaturov
-   Bayu Fitri Andrianto
-   Benjamin Gruenbaum
-   Chance Snow
-   Chris Richard
-   Code Hat Programming Inc.
-   Constantine Genchevsky
-   Dane Hitchcox
-   Daniel Nakov
-   Darko Kukovec
-   Derek Knox
-   Dominik Nowik
-   Dong Woo Gim
-   Dushko Jordanovski
-   GumoIsland
-   Graham Kaemmer
-   Greg Zapp
-   Ivan Nikitin
-   James Athanassakis
-   James McElwain
-   Jeff Hansen
-   Joinbox
-   Jorge Luis Acosta
-   Juwan Wheatley
-   Karolis Astrauka
-   Kevin Samuel
-   Konrad Mazanowski
-   Marcel Ryser
-   Matt Ruby
-   Matthieu Dumont
-   Mattia Manzati
-   Michael Fisher
-   Michael Mazurczak
-   Michael Tiller
-   Mihail Diordiev
-   Nikolay Ivanov
-   Uncomon
-   Pavel Ravits
-   Pascal Van Hecke
-   Peng Zhenqing
-   Rafal Filipek
-   Rainer Wittmann
-   Raj Sekaran
-   Rob Searle
-   Steven PÃ©rez
-   Surafel D
-   Tanguy Krotoff
-   Taylor Goolsby
-   Thibault Maekelbergh
-   Timor Zhiyentayev
-   Timothy Durant
-   Vojtech Novak
-   Wilfried Reiter
-   Wilson Lee
-   Yousuf Nejati
-   Zheng Renzhe
-   Zhenqing Peng

Or... Become my personal Patreon! https://www.patreon.com/mweststrate

Patrons:

-   Micheal Tiller
-   Goran MandiÄ‡
-   Micheal Hicke
-   @guidojo
-   Ronal Chanou
-   Kim Joar Bekkelund
-   TÅ‘rÃ¶s Egon RichÃ¡rd
-   Lucas Nascimento
-   Jason Hendriksen



================================================
FILE: tsconfig.json
================================================
{
    "compilerOptions": {
        "target": "es6",
        "module": "esnext",
        "moduleResolution": "node",
        "lib": ["esnext"],
        "downlevelIteration": true,
        "alwaysStrict": true,
        "sourceMap": true,
        "declaration": true,
        "removeComments": false,
        "strict": true,
        "noImplicitReturns": true,
        "noUnusedLocals": true,
        "noImplicitAny": false,
        "noImplicitThis": false,
        "noEmit": true,
        "experimentalDecorators": true,
        "useDefineForClassFields": true,
        "jsx": "react",
        "esModuleInterop": true,
        "skipLibCheck": true
    },
    "exclude": ["__tests__"]
}



================================================
FILE: tsconfig.test.json
================================================
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        // "module": "commonjs",
        "allowJs": true,
        "noUnusedLocals": false
    }
}



================================================
FILE: .editorconfig
================================================
root = true

[*]
end_of_line = lf
charset = utf-8
indent_style = space
tab_width = 4

[{package.json}]
indent_style = space
indent_size = 2



================================================
FILE: .eslintrc.js
================================================
module.exports = {
    parser: "@typescript-eslint/parser",
    plugins: ["@typescript-eslint"],
    extends: "eslint:recommended",
    ignorePatterns: ["**/__tests__/**/*"],
    env: {
        browser: true,
        es6: true,
        node: true
    },
    parserOptions: {
        ecmaVersion: 6,
        sourceType: "module"
    },
    rules: {
        "no-fallthrough": "off",
        "no-constant-condition": "off",
        curly: "error",
        "getter-return": "off",
        "no-console": "off",
        "no-var": "error",
        "no-undef": "off",
        "no-extra-semi": "off", // doesn't get along well with prettier
        "no-unused-vars": "off", // got typescript for that,
        "no-redeclare": "off", // No idea what it does, but it dies
        "require-yield": "off" // Doesn't work with TS
    },
    globals: {
        process: "readable",
        global: "readable",
        console: "readable",
        setTimeout: "readable",
        clearTimeout: "readable",
        module: "writable"
    }
}



================================================
FILE: .prettierignore
================================================
/**/package.json
website/**/*
dist/
docs/assets/
*.yml
coverage


================================================
FILE: .prettierrc
================================================
{
    "printWidth": 100,
    "semi": false,
    "tabWidth": 4,
    "singleQuote": false,
    "trailingComma": "none",
    "arrowParens": "avoid",
    "useTabs": false
}



================================================
FILE: .watchmanconfig
================================================
{
  "ignore_dirs": ["node_modules", "_site", "dist", "coverage"]
}



================================================
FILE: docs/README.md
================================================
---
title: About MobX
sidebar_label: About MobX
hide_title: true
---

<img src="https://mobx.js.org/assets/mobx.png" alt="logo" height="120" align="right" />

# MobX

_Simple, scalable state management._

[![Discuss on Github](https://img.shields.io/badge/discuss%20on-GitHub-orange)](https://github.com/mobxjs/mobx/discussions)
[![npm version](https://badge.fury.io/js/mobx.svg)](https://badge.fury.io/js/mobx)
[![OpenCollective](https://opencollective.com/mobx/backers/badge.svg)](backers-sponsors.md#backers)
[![OpenCollective](https://opencollective.com/mobx/sponsors/badge.svg)](backers-sponsors.md#sponsors)
[![View changelog](https://img.shields.io/badge/changelogs.xyz-Explore%20Changelog-brightgreen)](https://changelogs.xyz/mobx)

---

MobX is made possible by the generosity of the sponsors below, and many other [individual backers](backers-sponsors.md#backers). Sponsoring directly impacts the longevity of this project.

**ğŸ¥‡ğŸ¥‡ Platinum sponsors (\$5000+ total contribution): ğŸ¥‡ğŸ¥‡**

<br/>
<a href="https://www.guilded.gg/"><img src="https://mobx.js.org/assets/guilded.jpg" align="center" width="100" title="Guilded" alt="Guilded" /></a>
<a href="https://www.canva.com/"><img src="https://mobx.js.org/assets/canva.svg" align="center" width="100" title="Canva" alt="Canva" /></a>
<a href="https://www.getparallax.com/"><img src="https://mobx.js.org/assets/parallax.png" align="center" width="100" title="Parallax" alt="Parallax" /></a>

**ğŸ¥‡ Gold sponsors (\$2500+ total contribution):**

<br/>
<a href="https://www.one-beyond.com"><img src="https://mobx.js.org/assets/dcsl.png" align="center" width="100" title="One Beyond" alt="One Beyond"/></a>
<a href="https://frontendmasters.com/"><img src="https://mobx.js.org/assets/frontendmasters.jpg" align="center" width="100" title="Frontend Masters" alt="Frontend Masters"></a>
<a href="http://auctionfrontier.com/"><img src="https://mobx.js.org/assets/auctionfrontier.jpeg" align="center" width="100" title="Auction Frontier" alt="Auction Frontier"></a>
<a href="https://www.codefirst.co.uk/"><img src="https://mobx.js.org/assets/codefirst.png" align="center" width="100" title="CodeFirst" alt="CodeFirst"/></a>
<a href="https://modulz.app/"><img src="https://mobx.js.org/assets/modulz.png" align="center" width="100" title="Modulz" alt="Modulz"/></a>
<a href="https://coinbase.com/"><img src="https://mobx.js.org/assets/coinbase.jpeg" align="center" width="100" title="Coinbase" alt="Coinbase" /></a>
<a href="https://curology.com/blog/tech"><img src="https://mobx.js.org/assets/curology.png" align="center" width="100" title="Curology" alt="Curology"/></a>
<a href="https://mendix.com/"><img src="https://mobx.js.org/assets/mendix-logo.png" align="center" width="100" title="Mendix" alt="Mendix" /></a>
<a href="https://opensource.facebook.com/"><img src="https://mobx.js.org/assets/fbos.jpeg" align="center" width="100" title="Facebook Open Source" alt="Facebook Open Source" /></a>
<a href="https://casinosites.ltd.uk/?utm_source=sponsorship&utm_medium=mobx&utm_campaign=readme"><img src="https://mobx.js.org/assets/casino2.png" align="center" width="100" title="Casino Sites" alt="Casino Sites"/></a>
<a href="https://www.bugsnag.com/platforms/react-error-reporting?utm_source=MobX&utm_medium=Website&utm_content=open-source&utm_campaign=2019-community&utm_term=20190913"><img src="https://mobx.js.org/assets/bugsnag.jpg" align="center" width="100" title="Bugsnag" alt="Bugsnag"/></a>

**ğŸ¥ˆ Silver sponsors (\$500+ total contributions):**<br/>

<a href="https://mantro.net/jobs/warlock"><img src="https://mobx.js.org/assets/mantro.png" align="center" width="100" title="mantro GmbH" alt="mantro GmbH"></a>
<a href="https://www.xh.com/"><img src="https://mobx.js.org/assets/xh.png" align="center" width="100" title="Extremely Heavy" alt="Extremely Heavy" /></a>
<a href="https://www.algolia.com/"><img src="https://mobx.js.org/assets/algolia.jpg" align="center" width="100" title="Algolia" alt="Algolia" /></a>
<a href="https://space307.com/?utm_source=sponsorship&utm_medium=mobx&utm_campaign=readme"><img src="https://mobx.js.org/assets/space307.png" align="center" width="100" title="Space307" alt="Space307"/></a>
<a href="https://blokt.com/"><img src="https://mobx.js.org/assets/blokt.jpg" align="center" width="100" title="Blokt" alt="Blokt"/></a>
<a href="https://upper.co/?utm_source=github_mobxjs_sponsorship&utm_medium=paid_acquisition&utm_campaign=sponsorship"><img src="https://mobx.js.org/assets/upper.png" align="center" width="100" title="UPPER" alt="UPPER"/></a>
<a href="https://careers.dazn.com/"><img src="https://mobx.js.org/assets/dazn.png" align="center" width="100" title="DAZN" alt="DAZN"></a>
<a href="https://talentplot.com/"><img src="https://mobx.js.org/assets/talentplot.png" align="center" width="100" title="talentplot" alt="talentplot"></a>
<a href="https://www.easeus.com/?utm_source=github_mobxjs_sponsorship&utm_medium=readme&utm_campaign=sponsorship"><img src="https://mobx.js.org/assets/easeus.png" align="center" width="100" title="EaseUS" alt="EaseUS"/></a>
<a href="https://route4me.com/"><img src="https://mobx.js.org/assets/route4me.png" align="center" width="100" title="Route Planner and Route Optimizer" alt="Route Planner and Route Optimizer"/></a>
<a href="https://handsontable.com/docs/react-data-grid/?utm_source=Mobx_homepage&utm_medium=sponsorship&utm_campaign=library_sponsorship"><img src="https://mobx.js.org/assets/handsontable.png" align="center" width="100" title="Handsontable" alt="Handsontable"/></a>

---

## Introduction

_Anything that can be derived from the application state, should be. Automatically._

MobX is a signal based, battle-tested library that makes state management simple and scalable by transparently applying functional reactive programming.
The philosophy behind MobX is simple:

<div class="benefits">
    <div>
        <div class="pic">ğŸ˜™</div>
        <div>
            <h4>Straightforward</h4>
            <p>Write minimalistic, boilerplate-free code that captures your intent.
            Trying to update a record field? Simply use a normal JavaScript assignment â€”
            the reactivity system will detect all your changes and propagate them out to where they are being used.
            No special tools are required when updating data in an asynchronous process.
            </p>
        </div>
    </div>
    <div>
        <div class="pic">ğŸš…</div>
        <div>
            <h4>Effortless optimal rendering</h4>
            <p>
                All changes to and uses of your data are tracked at runtime, building a dependency tree that captures all relations between state and output.
                This guarantees that computations that depend on your state, like React components, run only when strictly needed.
                There is no need to manually optimize components with error-prone and sub-optimal techniques like memoization and selectors.
            </p>
        </div>
    </div>
    <div>
        <div class="pic">ğŸ¤¹ğŸ»â€â™‚ï¸</div>
        <div>
            <h4>Architectural freedom</h4>
            <p>
                MobX is unopinionated and allows you to manage your application state outside of any UI framework.
                This makes your code decoupled, portable, and above all, easily testable.
            </p>
        </div>
    </div>
</div>

---

## A quick example

So what does code that uses MobX look like?

```javascript
import React from "react"
import ReactDOM from "react-dom"
import { makeAutoObservable } from "mobx"
import { observer } from "mobx-react-lite"

// Model the application state.
function createTimer() {
    return makeAutoObservable({
        secondsPassed: 0,
        increase() {
            this.secondsPassed += 1
        },
        reset() {
            this.secondsPassed = 0
        }
    })
}

const myTimer = createTimer()

// Build a "user interface" that uses the observable state.
const TimerView = observer(({ timer }) => (
    <button onClick={() => timer.reset()}>Seconds passed: {timer.secondsPassed}</button>
))

ReactDOM.render(<TimerView timer={myTimer} />, document.body)

// Update the 'Seconds passed: X' text every second.
setInterval(() => {
    myTimer.increase()
}, 1000)
```

The `observer` wrapper around the `TimerView` React component will automatically detect that rendering
depends on the `timer.secondsPassed` observable, even though this relationship is not explicitly defined. The reactivity system will take care of re-rendering the component when _precisely that_ field is updated in the future.

Every event (`onClick` / `setInterval`) invokes an _action_ (`myTimer.increase` / `myTimer.reset`) that updates _observable state_ (`myTimer.secondsPassed`).
Changes in the observable state are propagated precisely to all _computations_ and _side effects_ (`TimerView`) that depend on the changes being made.

<img alt="MobX unidirectional flow" src="https://mobx.js.org/assets/flow2.png" align="center" />

This conceptual picture can be applied to the above example, or any other application using MobX.

## Getting started

To learn about the core concepts of MobX using a larger example, check out **[The gist of MobX](https://mobx.js.org/the-gist-of-mobx.html)** page, or take the **[10 minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)**.

The philosophy and benefits of the mental model provided by MobX are also described in great detail in the blog posts [UI as an afterthought](https://michel.codes/blogs/ui-as-an-afterthought) and [How to decouple state and UI (a.k.a. you donâ€™t need componentWillMount)](https://hackernoon.com/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37).

## Further resources

-   The [MobX cheat sheet](https://gum.co/fSocU) (Â£5) is both useful and sponsors the project
-   [10 minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)
-   [Egghead.io course, based on MobX 3](https://egghead.io/courses/manage-complex-state-in-react-apps-with-mobx)
-   The [MobX awesome list](https://github.com/mobxjs/awesome-mobx#awesome-mobx) â€“ a long list of MobX resources and example projects

### The MobX book

<a href="https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837"><img src="https://mobx.js.org/assets/book.jpg" height="120px" /></a>

The **[MobX Quick Start Guide](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837)** ($24.99) by [Pavan Podila](https://twitter.com/pavanpodila) and [Michel Weststrate](https://twitter.com/mweststrate) is available as an [ebook](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837), [paperback](https://www.amazon.com/MobX-Quick-Start-Guide-Supercharge/dp/1789344832), and on the [O'Reilly platform](https://www.oreilly.com/library/view/mobx-quick-start/9781789344837/) (see [preview](https://books.google.com/books?id=ALFmDwAAQBAJ&printsec=frontcover#v=onepage&q&f=false)).

### Videos

-   [Introduction to MobX & React in 2020](https://www.youtube.com/watch?v=pnhIJA64ByY) by Leigh Halliday, _17 min_.
-   [ReactNext 2016: Real World MobX](https://www.youtube.com/watch?v=Aws40KOx90U) by Michel Weststrate, _40 min_, [slides](https://docs.google.com/presentation/d/1DrI6Hc2xIPTLBkfNH8YczOcPXQTOaCIcDESdyVfG_bE/edit?usp=sharing).
-   [CityJS 2020: MobX, from mutable to immutable, to observable data](https://youtu.be/sP7dtZm_Wx0?t=27050) by Michel Weststrate, _30 min_.
-   [OpenSourceNorth: Practical React with MobX (ES5)](https://www.youtube.com/watch?v=XGwuM_u7UeQ) by Matt Ruby, _42 min_.
-   [HolyJS 2019: MobX and the unique symbiosis of predictability and speed](https://www.youtube.com/watch?v=NBYbBbjZeX4&list=PL8sJahqnzh8JJD7xahG5zXkjfM5GOgcPA&index=21&t=0s) by Michel Weststrate, _59 min_.
-   [React Amsterdam 2016: State Management Is Easy](https://www.youtube.com/watch?v=ApmSsu3qnf0&feature=youtu.be) by Michel Weststrate, _20 min_, [slides](https://speakerdeck.com/mweststrate/state-management-is-easy-introduction-to-mobx).
-   {ğŸš€} [React Live 2019: Reinventing MobX](https://www.youtube.com/watch?v=P_WqKZxpX8g) by Max Gallo, _27 min_.

## Credits

MobX is inspired by reactive programming principles, which are for example used in spreadsheets. It is inspired by modelâ€“viewâ€“viewmodel frameworks like [MeteorJS's Tracker](https://docs.meteor.com/api/tracker.html), [Knockout](https://knockoutjs.com/) and [Vue.js](https://vuejs.org/), but MobX brings _transparent functional reactive programming_ (TFRP, a concept which is further explained in the [MobX book](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837)) to the next level and provides a standalone implementation. It implements TFRP in a glitch-free, synchronous, predictable and efficient manner.

A ton of credit goes to [Mendix](https://github.com/mendix) for providing the flexibility and support to maintain MobX and the chance to prove the philosophy of MobX in a real, complex, performance critical applications.



================================================
FILE: docs/about-this-documentation.md
================================================
---
title: About this documentation
sidebar_label: About this documentation
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# About this documentation

It follows the principle that the most commonly used concepts are
introduced before specialized information. This applies to the headings in the table
of concepts as well as the pages under those headings.

We've marked the sections and concepts that are more advanced with the {ğŸš€} marker. You likely won't have to understand them until you will have a special use case, and can use MobX very effectively without knowing about them. Feel free to skip them and move on to the next section!

The documentation has been rewritten for MobX 6. For older versions of MobX, it can be found [here](https://github.com/mobxjs/mobx/tree/mobx4and5/docs).
All the principles are the same, and the API is largely the same. The main difference is that before MobX 6, [decorators](https://github.com/mobxjs/mobx/blob/mobx4and5/docs/best/decorators.md) were the recommended syntax to write MobX enhanced classes.

A summary of the documentation can be downloaded as cheat sheet:

<div class="cheat"><a href="https://gum.co/fSocU"><button title="Download the MobX 6 cheat sheet and sponsor the project">Download the MobX 6 cheat sheet</button></a></div>

## Guided tour

To get an overall idea of how to use MobX with React, read through the current _Introduction_ heading, in particular [The gist of MobX](the-gist-of-mobx.md) section.
It will introduce you to the most important principles, APIs and how they relate.
You should be ready to use MobX once you read this!

Here are a few suggestions about the next things to check out:

-   Try the [10 minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)

-   [React integration](react-integration.md)

-   [`makeObservable` / `makeAutoObservable`](observable-state.md)

-   Learn about [actions](actions.md), which includes a discussion on asynchronous actions

-   The basics of [computeds](computeds.md)

-   Read about [`autorun`](reactions.md#autorun), if only because it's used in the examples

-   To get an idea on how to organize your application's data stores, check out [Defining data stores](defining-data-stores.md)

-   If the behavior of MobX confuses you, it's useful to check out [Understanding reactivity](understanding-reactivity.md)

-   Get a [quick overview of the API](api.md), also linked in the top navigation bar

This should give you a good understanding of the day-to-day uses of MobX. There is plenty more available for you to read at your own leisure.



================================================
FILE: docs/actions.md
================================================
---
title: Updating state using actions
sidebar_label: Actions
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Updating state using actions

Usage:

-   `action` _(annotation)_
-   `action(fn)`
-   `action(name, fn)`
-   `@action` _(method / field decorator)_

All applications have actions. An action is any piece of code that modifies the state. In principle, actions always happen in response to an event. For example, a button was clicked, some input changed, a websocket message arrived, etc.

MobX requires that you declare your actions, although [`makeAutoObservable`](observable-state.md#makeautoobservable) can automate much of this job. Actions help you structure your code better and offer the following performance benefits:

1. They are run inside [transactions](api.md#transaction). No reactions will be run until the outer-most action has finished, guaranteeing that intermediate or incomplete values produced during an action are not visible to the rest of the application until the action has completed.

2. By default, it is not allowed to change the state outside of actions. This helps to clearly identify in your code base where the state updates happen.

The `action` annotation should only be used on functions that intend to _modify_ the state. Functions that derive information (performing lookups or filtering data) should _not_ be marked as actions, to allow MobX to track their invocations. `action` annotated members will be non-enumerable.

## Examples

<!--DOCUSAURUS_CODE_TABS-->
<!--makeObservable-->

```javascript
import { makeObservable, observable, action } from "mobx"

class Doubler {
    value = 0

    constructor() {
        makeObservable(this, {
            value: observable,
            increment: action
        })
    }

    increment() {
        // Intermediate states will not become visible to observers.
        this.value++
        this.value++
    }
}
```

<!--@action-->

```javascript
import { observable, action } from "mobx"

class Doubler {
    @observable accessor value = 0

    @action
    increment() {
        // Intermediate states will not become visible to observers.
        this.value++
        this.value++
    }
}
```

<!--makeAutoObservable-->

```javascript
import { makeAutoObservable } from "mobx"

class Doubler {
    value = 0

    constructor() {
        makeAutoObservable(this)
    }

    increment() {
        this.value++
        this.value++
    }
}
```

<!--action.bound-->

```javascript
import { makeObservable, observable, action } from "mobx"

class Doubler {
    value = 0

    constructor() {
        makeObservable(this, {
            value: observable,
            increment: action.bound
        })
    }

    increment() {
        this.value++
        this.value++
    }
}

const doubler = new Doubler()

// Calling increment this way is safe as it is already bound.
setInterval(doubler.increment, 1000)
```

<!--action(fn)-->

```javascript
import { observable, action } from "mobx"

const state = observable({ value: 0 })

const increment = action(state => {
    state.value++
    state.value++
})

increment(state)
```

<!--runInAction(fn)-->

```javascript
import { observable, runInAction } from "mobx"

const state = observable({ value: 0 })

runInAction(() => {
    state.value++
    state.value++
})
```

<!--END_DOCUSAURUS_CODE_TABS-->

## Wrapping functions using `action`

To leverage the transactional nature of MobX as much as possible, actions should be passed as far outward as possible. It is good to mark a class method as an action if it modifies the state. It is even better to mark event handlers as actions, as it is the outer-most transaction that counts. A single unmarked event handler that calls two actions subsequently would still generate two transactions.

To help create action based event handlers, `action` is not only an annotation, but also a higher order function. It can be called with a function as an argument, and in that case it will return an `action` wrapped function with the same signature.

For example in React, an `onClick` handler can be wrapped as below.

```javascript
const ResetButton = ({ formState }) => (
    <button
        onClick={action(e => {
            formState.resetPendingUploads()
            formState.resetValues()
            e.preventDefault()
        })}
    >
        Reset form
    </button>
)
```

For debugging purposes, we recommend to either name the wrapped function, or pass a name as the first argument to `action`.

<details id="actions-are-untracked"><summary>**Note:** actions are untracked<a href="#actions-are-untracked" class="tip-anchor"></a></summary>

Another feature of actions is that they are [untracked](api.md#untracked). When an action is called from inside a side effect or a computed value (very rare!), observables read by the action won't be counted towards the dependencies of the derivation

`makeAutoObservable`, `extendObservable` and `observable` use a special flavour of `action` called [`autoAction`](observable-state.md#autoAction),
that will determine at runtime if the function is a derivation or action.

</details>

## `action.bound`

Usage:

-   `action.bound` _(annotation)_

The `action.bound` annotation can be used to automatically bind a method to the correct instance, so that `this` is always correctly bound inside the function.

<details id="auto-bind"><summary>**Tip:** use `makeAutoObservable(o, {}, { autoBind: true })` to bind all actions and flows automatically<a href="#avoid-bound" class="tip-anchor"></a></summary>

```javascript
import { makeAutoObservable } from "mobx"

class Doubler {
    value = 0

    constructor() {
        makeAutoObservable(this, {}, { autoBind: true })
    }

    increment() {
        this.value++
        this.value++
    }

    *flow() {
        const response = yield fetch("http://example.com/value")
        this.value = yield response.json()
    }
}
```

</details>

## `runInAction`

Usage:

-   `runInAction(fn)`

Use this utility to create a temporary action that is immediately invoked. Can be useful in asynchronous processes.
Check out the [above code block](#examples) for an example.

## Actions and inheritance

Only actions defined **on prototype** can be **overridden** by subclass:

```javascript
class Parent {
    // on instance
    arrowAction = () => {}

    // on prototype
    action() {}
    boundAction() {}

    constructor() {
        makeObservable(this, {
            arrowAction: action
            action: action,
            boundAction: action.bound,
        })
    }
}
class Child extends Parent {
    // THROWS: TypeError: Cannot redefine property: arrowAction
    arrowAction = () => {}

    // OK
    action() {}
    boundAction() {}

    constructor() {
        super()
        makeObservable(this, {
            arrowAction: override,
            action: override,
            boundAction: override,
        })
    }
}
```

To **bind** a single _action_ to `this`, `action.bound` can be used instead of _arrow functions_.<br>
See [**subclassing**](subclassing.md) for more information.

## Asynchronous actions

In essence, asynchronous processes don't need any special treatment in MobX, as all reactions will update automatically regardless of the moment in time they are caused.
And since observable objects are mutable, it is generally safe to keep references to them for the duration of an action.
However, every step (tick) that updates observables in an asynchronous process should be marked as `action`.
This can be achieved in multiple ways by leveraging the above APIs, as shown below.

For example, when handling promises, the handlers that update state should be actions or should be wrapped using `action`, as shown below.

<!--DOCUSAURUS_CODE_TABS-->
<!--Wrap handlers in `action`-->

Promise resolution handlers are handled in-line, but run after the original action finished, so they need to be wrapped by `action`:

```javascript
import { action, makeAutoObservable } from "mobx"

class Store {
    githubProjects = []
    state = "pending" // "pending", "done" or "error"

    constructor() {
        makeAutoObservable(this)
    }

    fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        fetchGithubProjectsSomehow().then(
            action("fetchSuccess", projects => {
                const filteredProjects = somePreprocessing(projects)
                this.githubProjects = filteredProjects
                this.state = "done"
            }),
            action("fetchError", error => {
                this.state = "error"
            })
        )
    }
}
```

<!--Handle updates in separate actions-->

If the promise handlers are class fields, they will automatically be wrapped in `action` by `makeAutoObservable`:

```javascript
import { makeAutoObservable } from "mobx"

class Store {
    githubProjects = []
    state = "pending" // "pending", "done" or "error"

    constructor() {
        makeAutoObservable(this)
    }

    fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        fetchGithubProjectsSomehow().then(this.projectsFetchSuccess, this.projectsFetchFailure)
    }

    projectsFetchSuccess = projects => {
        const filteredProjects = somePreprocessing(projects)
        this.githubProjects = filteredProjects
        this.state = "done"
    }

    projectsFetchFailure = error => {
        this.state = "error"
    }
}
```

<!--async/await + runInAction-->

Any steps after `await` aren't in the same tick, so they require action wrapping.
Here, we can leverage `runInAction`:

```javascript
import { runInAction, makeAutoObservable } from "mobx"

class Store {
    githubProjects = []
    state = "pending" // "pending", "done" or "error"

    constructor() {
        makeAutoObservable(this)
    }

    async fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        try {
            const projects = await fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            runInAction(() => {
                this.githubProjects = filteredProjects
                this.state = "done"
            })
        } catch (e) {
            runInAction(() => {
                this.state = "error"
            })
        }
    }
}
```

<!--`flow` + generator function -->

```javascript
import { flow, makeAutoObservable, flowResult } from "mobx"

class Store {
    githubProjects = []
    state = "pending"

    constructor() {
        makeAutoObservable(this, {
            fetchProjects: flow
        })
    }

    // Note the star, this a generator function!
    *fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        try {
            // Yield instead of await.
            const projects = yield fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            this.state = "done"
            this.githubProjects = filteredProjects
            return projects
        } catch (error) {
            this.state = "error"
        }
    }
}

const store = new Store()
const projects = await flowResult(store.fetchProjects())
```

<!--END_DOCUSAURUS_CODE_TABS-->

## Using flow instead of async / await {ğŸš€}

Usage:

-   `flow` _(annotation)_
-   `flow(function* (args) { })`
-   `@flow` _(method decorator)_

The `flow` wrapper is an optional alternative to `async` / `await` that makes it easier to
work with MobX actions.
`flow` takes a [generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator) as its only input.
Inside the generator, you can chain promises by yielding them (instead of `await somePromise` you write `yield somePromise`).
The flow mechanism will then make sure the generator either continues or throws when a yielded promise resolves.

So `flow` is an alternative to `async` / `await` that doesn't need any further `action` wrapping. It can be applied as follows:

1. Wrap `flow` around your asynchronous function.
2. Instead of `async` use `function *`.
3. Instead of `await` use `yield`.

The [`flow` + generator function](#asynchronous-actions) example above shows what this looks like in practice.

Note that the `flowResult` function is only needed when using TypeScript.
Since decorating a method with `flow`, it will wrap the returned generator in a promise.
However, TypeScript isn't aware of that transformation, so `flowResult` will make sure that TypeScript is aware of that type change.

`makeAutoObservable` and friends will automatically infer generators to be `flow`s. `flow` annotated members will be non-enumerable.

<details id="flow-wrap"><summary>{ğŸš€} **Note:** using flow on object fields<a href="#flow-wrap" class="tip-anchor"></a></summary>
`flow`, like `action`, can be used to wrap functions directly. The above example could also have been written as follows:

```typescript
import { flow, makeObservable, observable } from "mobx"

class Store {
    githubProjects = []
    state = "pending"

    constructor() {
        makeObservable(this, {
            githubProjects: observable,
            state: observable,
        })
    }

    fetchProjects = flow(function* (this: Store) {
        this.githubProjects = []
        this.state = "pending"
        try {
            // yield instead of await.
            const projects = yield fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            this.state = "done"
            this.githubProjects = filteredProjects
        } catch (error) {
            this.state = "error"
        }
    })
}

const store = new Store()
const projects = await store.fetchProjects()
```

The upside is that we don't need `flowResult` anymore, the downside is that `this` needs to be typed to make sure its type is inferred correctly.

</details>

## `flow.bound`

Usage:

-   `flow.bound` _(annotation)_

The `flow.bound` annotation can be used to automatically bind a method to the correct instance, so that `this` is always correctly bound inside the function.
Similary to actions, flows can be bound by default using [`autoBind` option](#auto-bind).

## Cancelling flows {ğŸš€}

Another neat benefit of flows is that they are cancellable.
The return value of `flow` is a promise that resolves with the value that is returned from the generator function in the end.
The returned promise has an additional `cancel()` method that will interrupt the running generator and cancel it.
Any `try` / `finally` clauses will still be run.

## Disabling mandatory actions {ğŸš€}

By default, MobX 6 and later require that you use actions to make changes to the state.
However, you can configure MobX to disable this behavior. Check out the [`enforceActions`](configuration.md#enforceactions) section.
For example, this can be quite useful in unit test setup, where the warnings don't always have much value.



================================================
FILE: docs/analyzing-reactivity.md
================================================
---
title: Analyzing reactivity
sidebar_label: Analyzing reactivity {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Analyzing reactivity {ğŸš€}

# Using `trace` for debugging

Trace is a small utility that helps you find out why your computed values, reactions or components are re-evaluating.

It can be used by simply importing `import { trace } from "mobx"`, and then putting it inside a reaction or computed value.
It will print why it is re-evaluating the current derivation.

Optionally it is possible to automatically enter the debugger by passing `true` as the last argument.
This way the exact mutation that causes the reaction to re-run will still be in stack, usually ~8 stack frames up. See the image below.

In debugger mode, the debug information will also reveal the full derivation tree that is affecting the current computation / reaction.

![trace](assets/trace-tips2.png)

![trace](assets/trace.gif)

## Live examples

Simple [CodeSandbox `trace` example](https://codesandbox.io/s/trace-dnhbz?file=/src/index.js:309-338).

[Here's a deployed example](https://csb-nr58ylyn4m-hontnuliaa.now.sh/) for exploring the stack.
Make sure to play with the chrome debugger's blackbox feature!

## Usage examples

There are different ways of calling `trace()`, some examples:

```javascript
import { observer } from "mobx-react"
import { trace } from "mobx"

const MyComponent = observer(() => {
    trace(true) // Enter the debugger whenever an observable value causes this component to re-run.
    return <div>{this.props.user.name}</name>
})
```

Enable trace by using the `reaction` argument of a reaction / autorun:

```javascript
mobx.autorun("logger", reaction => {
    reaction.trace()
    console.log(user.fullname)
})
```

Pass in the property name of a computed property:

```javascript
trace(user, "fullname")
```

# Introspection APIs

The following APIs might come in handy if you want to inspect the internal state of MobX while debugging, or want to build cool tools on top of MobX.
Also relevant are the various [`isObservable*` APIs](api.md#isobservable).

### `getDebugName`

Usage:

-   `getDebugName(thing, property?)`

Returns a (generated) friendly debug name of an observable object, property, reaction etc. Used for example by the [MobX developer tools](https://github.com/mobxjs/mobx-devtools).

### `getDependencyTree`

Usage:

-   `getDependencyTree(thing, property?)`.

Returns a tree structure with all observables the given reaction / computation currently depends upon.

### `getObserverTree`

Usage:

-   `getObserverTree(thing, property?)`.

Returns a tree structure with all reactions / computations that are observing the given observable.

### `getAtom`

Usage:

-   `getAtom(thing, property?)`.

Returns the backing _Atom_ of a given observable object, property, reaction etc.

# Spy

Usage:

-   `spy(listener)`

Registers a global spy listener that listens to all events that happen in MobX.
It is similar to attaching an `observe` listener to _all_ observables at once, but also notifies about running (trans/re)actions and computations.
Used for example by the [MobX developer tools](https://github.com/mobxjs/mobx-devtools).

Example usage of spying all actions:

```javascript
spy(event => {
    if (event.type === "action") {
        console.log(`${event.name} with args: ${event.arguments}`)
    }
})
```

Spy listeners always receive one object, which usually has at least a `type` field. The following events are emitted by default by spy:

| Type                            | observableKind | Other fields                                                   | Nested |
| ------------------------------- | -------------- | -------------------------------------------------------------- | ------ |
| action                          |                | name, object (scope), arguments[]                              | yes    |
| scheduled-reaction              |                | name                                                           | no     |
| reaction                        |                | name                                                           | yes    |
| error                           |                | name, message, error                                           | no     |
| add,update,remove,delete,splice |                | Check out [Intercept & observe {ğŸš€}](intercept-and-observe.md) | yes    |
| report-end                      |                | spyReportEnd=true, time? (total execution time in ms)          | no     |

The `report-end` events are part of an earlier fired event that had `spyReportStart: true`.
This event indicates the end of an event and this way groups of events with sub-events are created.
This event might report the total execution time as well.

The spy events for observable values are identical to the events passed to `observe`.
In production builds, the `spy` API is a no-op as it will be minimized away.

Check out the [Intercept & observe {ğŸš€}](intercept-and-observe.md#event-overview) section for an extensive overview.



================================================
FILE: docs/api.md
================================================
---
title: MobX API Reference
sidebar_label: API
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# MobX API Reference

Functions marked with {ğŸš€} are considered advanced, and should typically not be needed.
Consider downloading our handy cheat sheet that explains all important APIs on a single page:

<div class="cheat"><a href="https://gum.co/fSocU"><button title="Download the MobX 6 cheat sheet and sponsor the project">Get the MobX 6 cheat sheet (Â£5)</button></a></div>

## Core APIs

_These are the most important MobX APIs._

> Understanding [`observable`](#observable), [`computed`](#computed), [`reaction`](#reaction) and [`action`](#action) is enough to master and use MobX in your applications!

## Creating observables

_Making things observable._

### `makeObservable`

Usage: `makeObservable(target, annotations?, options?)`
<small>(<b>[further information](observable-state.md#makeobservable)</b>)</small>

Properties, entire objects, arrays, Maps and Sets can all be made observable.

### `makeAutoObservable`

Usage: `makeAutoObservable(target, overrides?, options?)`
<small>(<b>[further information](observable-state.md#makeautoobservable)</b>)</small>

Automatically make properties, objects, arrays, Maps and Sets observable.

### `extendObservable`

{ğŸš€} Usage: `extendObservable(target, properties, overrides?, options?)`

Can be used to introduce new properties on the `target` object and make them observable immediately. Basically a shorthand for `Object.assign(target, properties); makeAutoObservable(target, overrides, options);`. However, existing properties on `target` won't be touched.

Old-fashioned constructor functions can nicely leverage `extendObservable`:

```javascript
function Person(firstName, lastName) {
    extendObservable(this, { firstName, lastName })
}

const person = new Person("Michel", "Weststrate")
```

It is possible to use `extendObservable` to add observable fields to an existing object after instantiation, but be careful that adding an observable property this way is in itself not a fact that can be observed.

### `observable`

Usage: `observable(source, overrides?, options?)`, `observable` _(annotation)_ or `@observable accessor` _(field decorator)_.
<small>(<b>[further information](observable-state.md#observable)</b>)</small>

Clones an object and makes it observable. Source can be a plain object, array, Map or Set. By default, `observable` is applied recursively. If one of the encountered values is an object or array, that value will be passed through `observable` as well.

### `observable.object`

{ğŸš€} Usage: `observable.object(source, overrides?, options?)`
<small>(<b>[further information](observable-state.md#observable)</b>)</small>

Alias for `observable(source, overrides?, options?)`. Creates a clone of the provided object and makes all of its properties observable.

### `observable.array`

{ğŸš€} Usage: `observable.array(initialValues?, options?)`

Creates a new observable array based on the provided `initialValues`.
To convert observable arrays back to plain arrays, use the `.slice()` method, or check out [toJS](#tojs) to convert them recursively.
Besides all the language built-in array functions, the following goodies are available on observable arrays as well:

-   `clear()` removes all current entries from the array.
-   `replace(newItems)` replaces all existing entries in the array with new ones.
-   `remove(value)` removes a single item by value from the array and returns `true` if the item was found and removed.

If the values in the array should not be turned into observables automatically, use the `{ deep: false }` option to make the array shallowly observable.

### `observable.map`

{ğŸš€} Usage: `observable.map(initialMap?, options?)`

Creates a new observable [ES6 Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) based on the provided `initialMap`.
They are very useful if you don't want to react just to the change of a specific entry, but also to their addition and removal.
Creating observable Maps is the recommended approach for creating dynamically keyed collections if you don't have [enabled Proxies](configuration.md#proxy-support).

Besides all the language built-in Map functions, the following goodies are available on observable Maps as well:

-   `toJSON()` returns a shallow plain object representation of this Map (use [toJS](#tojs) for a deep copy).
-   `merge(values)` copies all entries from the provided `values` (plain object, array of entries or a string-keyed ES6 Map) into this Map.
-   `replace(values)` replaces the entire contents of this Map with the provided `values`.

If the values in the Map should not be turned into observables automatically, use the `{ deep: false }` option to make the Map shallowly observable.

### `observable.set`

{ğŸš€} Usage: `observable.set(initialSet?, options?)`

Creates a new observable [ES6 Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) based on the provided `initialSet`. Use it whenever you want to create a dynamic set where the addition and removal of values needs to be observed, but where values can appear only once in the entire collection.

If the values in the Set should not be turned into observables automatically, use the `{ deep: false }` option to make the Set shallowly observable.

Unlike Map keys, Set values are [not tracked individually](https://github.com/mobxjs/mobx/issues/2336#issuecomment-616128089).

### `observable.ref`

Usage: `observable.ref` _(annotation)_
<small>(<b>[further information](observable-state.md#available-annotations)</b>)</small>

Like the `observable` annotation, but only reassignments will be tracked. The assigned values themselves won't be made observable automatically. For example, use this if you intend to store immutable data in an observable field.

### `observable.shallow`

Usage: `observable.shallow` _(annotation)_
<small>(<b>[further information](observable-state.md#available-annotations)</b>)</small>

Like the `observable.ref` annotation, but for collections. Any collection assigned will be made observable, but the contents of the collection itself won't become observable.

### `observable.struct`

{ğŸš€} Usage: `observable.struct` _(annotation)_
<small>(<b>[further information](observable-state.md#available-annotations)</b>)</small>

Like the `observable` annotation, except that any assigned value that is structurally equal to the current value will be ignored.

### `observable.deep`

{ğŸš€} Usage: `observable.deep` _(annotation)_
<small>(<b>[further information](observable-state.md#available-annotations)</b>)</small>

Alias for the [`observable`](#observable) annotation.

### `observable.box`

{ğŸš€} Usage: `observable.box(value, options?)`

All primitive values in JavaScript are immutable and hence per definition not observable.
Usually that is fine, as MobX can just make the _property_ that contains the value observable.
In rare cases, it can be convenient to have an observable _primitive_ that is not owned by an object.
For such cases, it is possible to create an observable _box_ that manages such a _primitive_.

`observable.box(value)` accepts any value and stores it inside a box. The current value can be accessed through `.get()` and updated using `.set(newValue)`.

```javascript
import { observable, autorun } from "mobx"

const cityName = observable.box("Vienna")

autorun(() => {
    console.log(cityName.get())
})
// Prints: 'Vienna'

cityName.set("Amsterdam")
// Prints: 'Amsterdam'
```

If the values in the box should not be turned into observables automatically, use the `{ deep: false }` option to make the box shallowly observable.

---

## Actions

_An action is any piece of code that modifies the state._

### `action`

Usage: `action(fn)`, `action` _(annotation)_ or `@action` _(method / field decorator)_
<small>(<b>[further information](actions.md)</b>)</small>

Use on functions that intend to modify the state.

### `runInAction`

{ğŸš€} Usage: `runInAction(fn)`
<small>(<b>[further information](actions.md#runinaction)</b>)</small>

Create a one-time action that is immediately invoked.

### `flow`

Usage: `flow(fn)`, `flow` _(annotation)_ or `@flow` _(generator method decorator)_
<small>(<b>[further information](actions.md#using-flow-instead-of-async--await-)</b>)</small>

MobX friendly replacement for `async` / `await` that supports cancellation.

### `flowResult`

Usage: `flowResult(flowFunctionResult)`
<small>(<b>[further information](actions.md#using-flow-instead-of-async--await-)</b>)</small>

For TypeScript users only. Utility that casts the output of the generator to a promise.
This is just a type-wise correction for the promise wrapping done by `flow`. At runtime it directly returns the inputted value.

---

## Computeds

_Computed values can be used to derive information from other observables._

### `computed`

Usage: `computed(fn, options?)`, `computed(options?)` _(annotation)_ or `@computed` _(getter decorator)_
<small>(<b>[further information](computeds.md)</b>)</small>

Creates an observable value that is derived from other observables, but won't be recomputed unless one of the underlying observables changes.

---

## React integration

_From the `mobx-react` / `mobx-react-lite` packages._

### `observer`

Usage: `observer(component)`
<small>(<b>[further information](react-integration.md)</b>)</small>

A higher order component you can use to make a functional or class based React component re-render when observables change.

### `Observer`

Usage: `<Observer>{() => rendering}</Observer>`
<small>(<b>[further information](react-integration.md#callback-components-might-require-observer)</b>)</small>

Renders the given render function, and automatically re-renders it once one of the observables used in the render function changes.

### `useLocalObservable`

Usage: `useLocalObservable(() => source, annotations?)`
<small>(<b>[further information](react-integration.md#using-local-observable-state-in-observer-components)</b>)</small>

Creates a new observable object using `makeObservable`, and keeps it around in the component for the entire life-cycle of the component.

---

## Reactions

_The goal of reactions is to model side effects that happen automatically._

### `autorun`

Usage: `autorun(() => effect, options?)`
<small>(<b>[further information](reactions.md#autorun)</b>)</small>

Reruns a function every time anything it observes changes.

### `reaction`

Usage: `reaction(() => data, data => effect, options?)`
<small>(<b>[further information](reactions.md#reaction)</b>)</small>

Reruns a side effect when any selected data changes.

### `when`

Usage: `when(() => condition, () => effect, options?)` or `await when(() => condition, options?)`
<small>(<b>[further information](reactions.md#when)</b>)</small>

Executes a side effect once when a observable condition becomes true.

---

## Utilities

_Utilities that might make working with observable objects or computed values more convenient. Less trivial utilities can also be found in the [mobx-utils](https://github.com/mobxjs/mobx-utils) package._

### `onReactionError`

{ğŸš€} Usage: `onReactionError(handler: (error: any, derivation) => void)`

Attaches a global error listener, which is invoked for every error that is thrown from a _reaction_. This can be used for monitoring or test purposes.

### `intercept`

{ğŸš€} Usage: `intercept(propertyName|array|object|Set|Map, listener)`
<small>(<b>[further information](intercept-and-observe.md#intercept)</b>)</small>

Intercepts changes before they are applied to an observable API. Returns a disposer function that stops the interception.

### `observe`

{ğŸš€} Usage: `observe(propertyName|array|object|Set|Map, listener)`
<small>(<b>[further information](intercept-and-observe.md#observe)</b>)</small>

Low-level API that can be used to observe a single observable value. Returns a disposer function that stops the interception.

### `onBecomeObserved`

{ğŸš€} Usage: `onBecomeObserved(observable, property?, listener: () => void)`
<small>(<b>[further information](lazy-observables.md)</b>)</small>

Hook for when something becomes observed.

### `onBecomeUnobserved`

{ğŸš€} Usage: `onBecomeUnobserved(observable, property?, listener: () => void)`
<small>(<b>[further information](lazy-observables.md)</b>)</small>

Hook for when something stops being observed.

### `toJS`

Usage: `toJS(value)`
<small>(<b>[further information](observable-state.md#converting-observables-back-to-vanilla-javascript-collections)</b>)</small>

Recursively converts an observable object to a JavaScript _object_. Supports observable arrays, objects, Maps and primitives.

It does NOT recurse into non-observables, these are left as they are, even if they contain observables.
Computed and other non-enumerable properties are completely ignored and won't be returned.

For more complex (de)serialization scenarios, it is recommended to give classes a (computed) `toJSON` method, or use a serialization library like [serializr](https://github.com/mobxjs/serializr).

```javascript
const obj = mobx.observable({
    x: 1
})

const clone = mobx.toJS(obj)

console.log(mobx.isObservableObject(obj)) // true
console.log(mobx.isObservableObject(clone)) // false
```

---

## Configuration

_Fine-tuning your MobX instance._

### `configure`

Usage: sets global behavior settings on the active MobX instance.
<small>(<b>[further information](configuration.md)</b>)</small>
Use it to change how MobX behaves as a whole.

---

## Collection utilities {ğŸš€}

_They enable manipulating observable arrays, objects and Maps with the same generic API. This can be useful in [environments without `Proxy` support](configuration.md#limitations-without-proxy-support), but is otherwise typically not needed._

### `values`

{ğŸš€} Usage: `values(array|object|Set|Map)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Returns all values in the collection as an array.

### `keys`

{ğŸš€} Usage: `keys(array|object|Set|Map)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Returns all keys / indices in the collection as an array.

### `entries`

{ğŸš€} Usage: `entries(array|object|Set|Map)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Returns a `[key, value]` pair of every entry in the collection as an array.

### `set`

{ğŸš€} Usage: `set(array|object|Map, key, value)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Updates the collection.

### `remove`

{ğŸš€} Usage: `remove(array|object|Map, key)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Removes item from the collection.

### `has`

{ğŸš€} Usage: `has(array|object|Map, key)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Checks for membership in the collection.

### `get`

{ğŸš€} Usage: `get(array|object|Map, key)`
<small>(<b>[further information](collection-utilities.md)</b>)</small>

Gets value from the collection with key.

---

## Introspection utilities {ğŸš€}

_Utilities that might come in handy if you want to inspect the internal state of MobX, or want to build cool tools on top of MobX._

### `isObservable`

{ğŸš€} Usage: `isObservable(array|object|Set|Map)`

Is the object / collection made observable by MobX?

### `isObservableProp`

{ğŸš€} Usage: `isObservableProp(object, propertyName)`

Is the property observable?

### `isObservableArray`

{ğŸš€} Usage: `isObservableArray(array)`

Is the value an observable array?

### `isObservableObject`

{ğŸš€} Usage: `isObservableObject(object)`

Is the value an observable object?

### `isObservableSet`

{ğŸš€} Usage: `isObservableSet(set)`

Is the value an observable Set?

### `isObservableMap`

{ğŸš€} Usage: `isObservableMap(map)`

Is the value an observable Map?

### `isBoxedObservable`

{ğŸš€} Usage: `isBoxedObservable(value)`

Is the value an observable box, created using `observable.box`?

### `isAction`

{ğŸš€} Usage: `isAction(func)`

Is the function marked as an `action`?

### `isComputed`

{ğŸš€} Usage: `isComputed(boxedComputed)`

Is this a boxed computed value, created using `computed(() => expr)`?

### `isComputedProp`

{ğŸš€} Usage: `isComputedProp(object, propertyName)`

Is this a computed property?

### `trace`

{ğŸš€} Usage: `trace()`, `trace(true)` _(enter debugger)_ or `trace(object, propertyName, enterDebugger?)`
<small>(<b>[further information](analyzing-reactivity.md)</b>)</small>

Should be used inside an observer, reaction or computed value. Logs when the value is invalidated, or sets the debugger breakpoint if called with _true_.

### `spy`

{ğŸš€} Usage: `spy(eventListener)`
<small>(<b>[further information](analyzing-reactivity.md#spy)</b>)</small>

Registers a global spy listener that listens to all events that happen in MobX.

### `getDebugName`

{ğŸš€} Usage: `getDebugName(reaction|array|Set|Map)` or `getDebugName(object|Map, propertyName)`
<small>(<b>[further information](analyzing-reactivity.md#getdebugname)</b>)</small>

Returns the (generated) friendly debug name for an observable or reaction.

### `getDependencyTree`

{ğŸš€} Usage: `getDependencyTree(object, computedPropertyName)`
<small>(<b>[further information](analyzing-reactivity.md#getdependencytree)</b>)</small>

Returns a tree structure with all observables the given reaction / computation currently depends upon.

### `getObserverTree`

{ğŸš€} Usage: `getObserverTree(array|Set|Map)` or `getObserverTree(object|Map, propertyName)`
<small>(<b>[further information](analyzing-reactivity.md#getobservertree)</b>)</small>

Returns a tree structure with all reactions / computations that are observing the given observable.

---

## Extending MobX {ğŸš€}

_In the rare case you want to extend MobX itself._

### `createAtom`

{ğŸš€} Usage: `createAtom(name, onBecomeObserved?, onBecomeUnobserved?)`
<small>(<b>[further information](custom-observables.md)</b>)</small>

Creates your own observable data structure and hooks it up to MobX. Used internally by all observable data types. Atom exposes two _report_ methods to notify MobX with when:

-   `reportObserved()`: the atom has become observed, and should be considered part of the dependency tree of the current derivation.
-   `reportChanged()`: the atom has changed, and all derivations depending on it should be invalidated.

### `getAtom`

{ğŸš€} Usage: `getAtom(thing, property?)`
<small>(<b>[further information](analyzing-reactivity.md#getatom)</b>)</small>

Returns the backing atom.

### `transaction`

{ğŸš€} Usage: `transaction(worker: () => any)`

_Transaction is a low-level API. It is recommended to use [`action`](#action) or [`runInAction`](#runinaction) instead._

Used to batch a bunch of updates without running any reactions until the end of the transaction. Like [`untracked`](#untracked), it is automatically applied by `action`, so usually it makes more sense to use actions than to use `transaction` directly.

It takes a single, parameterless `worker` function as an argument, and returns any value that was returned by it.
Note that `transaction` runs completely synchronously and can be nested. Only after completing the outermost `transaction`, the pending reactions will be run.

```javascript
import { observable, transaction, autorun } from "mobx"

const numbers = observable([])

autorun(() => console.log(numbers.length, "numbers!"))
// Prints: '0 numbers!'

transaction(() => {
    transaction(() => {
        numbers.push(1)
        numbers.push(2)
    })
    numbers.push(3)
})
// Prints: '3 numbers!'
```

### `untracked`

{ğŸš€} Usage: `untracked(worker: () => any)`

_Untracked is a low-level API. It is recommended to use [`reaction`](#reaction), [`action`](#action) or [`runInAction`](#runinaction) instead._

Runs a piece of code without establishing observers. Like `transaction`, `untracked` is automatically applied by `action`, so usually it makes more sense to use actions than to use `untracked` directly.

```javascript
const person = observable({
    firstName: "Michel",
    lastName: "Weststrate"
})

autorun(() => {
    console.log(
        person.lastName,
        ",",
        // This untracked block will return the person's
        // firstName without establishing a dependency.
        untracked(() => person.firstName)
    )
})
// Prints: 'Weststrate, Michel'

person.firstName = "G.K."
// Doesn't print!

person.lastName = "Chesterton"
// Prints: 'Chesterton, G.K.'
```



================================================
FILE: docs/backers-sponsors.md
================================================
---
title: MobX Backers and Sponsors
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# MobX Backers and Sponsors

Thanks to your backers and sponsors for their generous support!

## Backers

Support us with a monthly donation and help us continue our activities. [[Become a backer](https://opencollective.com/mobx#backer)]

<a href="https://opencollective.com/mobx/backer/0/website" target="_blank"><img src="https://opencollective.com/mobx/backer/0/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/1/website" target="_blank"><img src="https://opencollective.com/mobx/backer/1/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/2/website" target="_blank"><img src="https://opencollective.com/mobx/backer/2/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/3/website" target="_blank"><img src="https://opencollective.com/mobx/backer/3/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/4/website" target="_blank"><img src="https://opencollective.com/mobx/backer/4/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/5/website" target="_blank"><img src="https://opencollective.com/mobx/backer/5/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/6/website" target="_blank"><img src="https://opencollective.com/mobx/backer/6/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/7/website" target="_blank"><img src="https://opencollective.com/mobx/backer/7/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/8/website" target="_blank"><img src="https://opencollective.com/mobx/backer/8/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/9/website" target="_blank"><img src="https://opencollective.com/mobx/backer/9/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/10/website" target="_blank"><img src="https://opencollective.com/mobx/backer/10/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/11/website" target="_blank"><img src="https://opencollective.com/mobx/backer/11/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/12/website" target="_blank"><img src="https://opencollective.com/mobx/backer/12/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/13/website" target="_blank"><img src="https://opencollective.com/mobx/backer/13/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/14/website" target="_blank"><img src="https://opencollective.com/mobx/backer/14/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/15/website" target="_blank"><img src="https://opencollective.com/mobx/backer/15/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/16/website" target="_blank"><img src="https://opencollective.com/mobx/backer/16/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/17/website" target="_blank"><img src="https://opencollective.com/mobx/backer/17/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/18/website" target="_blank"><img src="https://opencollective.com/mobx/backer/18/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/19/website" target="_blank"><img src="https://opencollective.com/mobx/backer/19/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/20/website" target="_blank"><img src="https://opencollective.com/mobx/backer/20/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/21/website" target="_blank"><img src="https://opencollective.com/mobx/backer/21/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/22/website" target="_blank"><img src="https://opencollective.com/mobx/backer/22/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/23/website" target="_blank"><img src="https://opencollective.com/mobx/backer/23/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/24/website" target="_blank"><img src="https://opencollective.com/mobx/backer/24/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/25/website" target="_blank"><img src="https://opencollective.com/mobx/backer/25/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/26/website" target="_blank"><img src="https://opencollective.com/mobx/backer/26/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/27/website" target="_blank"><img src="https://opencollective.com/mobx/backer/27/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/28/website" target="_blank"><img src="https://opencollective.com/mobx/backer/28/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/29/website" target="_blank"><img src="https://opencollective.com/mobx/backer/29/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/30/website" target="_blank"><img src="https://opencollective.com/mobx/backer/30/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/31/website" target="_blank"><img src="https://opencollective.com/mobx/backer/31/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/32/website" target="_blank"><img src="https://opencollective.com/mobx/backer/32/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/33/website" target="_blank"><img src="https://opencollective.com/mobx/backer/33/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/34/website" target="_blank"><img src="https://opencollective.com/mobx/backer/34/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/35/website" target="_blank"><img src="https://opencollective.com/mobx/backer/35/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/36/website" target="_blank"><img src="https://opencollective.com/mobx/backer/36/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/37/website" target="_blank"><img src="https://opencollective.com/mobx/backer/37/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/38/website" target="_blank"><img src="https://opencollective.com/mobx/backer/38/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/39/website" target="_blank"><img src="https://opencollective.com/mobx/backer/39/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/40/website" target="_blank"><img src="https://opencollective.com/mobx/backer/40/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/41/website" target="_blank"><img src="https://opencollective.com/mobx/backer/41/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/42/website" target="_blank"><img src="https://opencollective.com/mobx/backer/42/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/43/website" target="_blank"><img src="https://opencollective.com/mobx/backer/43/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/44/website" target="_blank"><img src="https://opencollective.com/mobx/backer/44/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/45/website" target="_blank"><img src="https://opencollective.com/mobx/backer/45/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/46/website" target="_blank"><img src="https://opencollective.com/mobx/backer/46/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/47/website" target="_blank"><img src="https://opencollective.com/mobx/backer/47/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/48/website" target="_blank"><img src="https://opencollective.com/mobx/backer/48/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/49/website" target="_blank"><img src="https://opencollective.com/mobx/backer/49/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/50/website" target="_blank"><img src="https://opencollective.com/mobx/backer/50/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/51/website" target="_blank"><img src="https://opencollective.com/mobx/backer/51/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/52/website" target="_blank"><img src="https://opencollective.com/mobx/backer/52/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/53/website" target="_blank"><img src="https://opencollective.com/mobx/backer/53/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/54/website" target="_blank"><img src="https://opencollective.com/mobx/backer/54/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/55/website" target="_blank"><img src="https://opencollective.com/mobx/backer/55/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/56/website" target="_blank"><img src="https://opencollective.com/mobx/backer/56/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/57/website" target="_blank"><img src="https://opencollective.com/mobx/backer/57/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/58/website" target="_blank"><img src="https://opencollective.com/mobx/backer/58/avatar.svg"></a>
<a href="https://opencollective.com/mobx/backer/59/website" target="_blank"><img src="https://opencollective.com/mobx/backer/59/avatar.svg"></a>

## Sponsors

Become a sponsor and get your logo on our README on Github with a link to your site. [[Become a sponsor](https://opencollective.com/mobx#sponsor)]

<a href="https://opencollective.com/mobx/sponsor/0/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/0/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/1/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/1/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/2/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/2/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/3/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/3/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/4/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/4/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/5/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/5/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/6/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/6/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/7/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/7/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/8/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/8/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/9/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/9/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/10/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/10/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/11/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/11/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/12/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/12/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/13/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/13/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/14/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/14/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/15/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/15/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/16/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/16/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/17/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/17/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/18/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/18/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/19/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/19/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/20/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/20/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/21/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/21/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/22/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/22/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/23/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/23/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/24/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/24/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/25/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/25/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/26/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/26/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/27/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/27/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/28/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/28/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/29/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/29/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/30/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/30/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/31/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/31/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/32/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/32/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/33/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/33/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/34/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/34/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/35/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/35/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/36/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/36/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/37/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/37/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/38/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/38/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/39/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/39/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/40/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/40/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/41/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/41/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/42/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/42/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/43/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/43/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/44/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/44/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/45/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/45/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/46/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/46/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/47/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/47/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/48/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/48/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/49/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/49/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/50/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/50/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/51/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/51/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/52/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/52/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/53/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/53/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/54/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/54/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/55/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/55/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/56/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/56/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/57/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/57/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/58/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/58/avatar.svg"></a>
<a href="https://opencollective.com/mobx/sponsor/59/website" target="_blank"><img src="https://opencollective.com/mobx/sponsor/59/avatar.svg"></a>



================================================
FILE: docs/collection-utilities.md
================================================
---
title: Collection utilities
sidebar_label: Collection utilities {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Collection utilities {ğŸš€}

They enable manipulating observable arrays, objects and Maps with the same generic API.
These APIs are fully reactive, which means that even [without `Proxy` support](configuration.md#limitations-without-proxy-support) new property declarations can be detected by MobX if `set` is used to add them, and `values` or `keys` are used to iterate over them.

Another benefit of `values`, `keys` and `entries` is that they return arrays rather than iterators, which makes it possible to, for example, immediately call `.map(fn)` on the results.

All that being said, a typical project has little reason to use these APIs.

Access:

-   `values(collection)` returns an array of all the values in the collection.
-   `keys(collection)` returns an array of all the keys in the collection.
-   `entries(collection)` returns an array of all the entries `[key, value]` pairs in the collection.

Mutation:

-   `set(collection, key, value)` or `set(collection, { key: value })` update the given collection with the provided key / value pair(s).
-   `remove(collection, key)` removes the specified child from the collection. Splicing is used for arrays.
-   `has(collection, key)` returns _true_ if the collection has the specified _observable_ property.
-   `get(collection, key)` returns the child under the specified key.

If you use the access APIs in an environment without `Proxy` support, then also use the mutation APIs so they can detect the changes.

```javascript
import { autorun, get, set, observable, values } from "mobx"

const twitterUrls = observable.object({
    Joe: "twitter.com/joey"
})

autorun(() => {
    // Get can track not yet existing properties.
    console.log(get(twitterUrls, "Sara"))
})

autorun(() => {
    console.log("All urls: " + values(twitterUrls).join(", "))
})

set(twitterUrls, { Sara: "twitter.com/horsejs" })
```



================================================
FILE: docs/computeds-with-args.md
================================================
---
title: Computeds with arguments
sidebar_label: Computeds with arguments {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Computeds with arguments {ğŸš€}

The `computed` annotation can only be used on getters, which don't take arguments.
What about computations that do take arguments?
Take the below example of a React component that renders a specific `Item`,
and the application supports multi-selection.

How can we implement a derivation like `store.isSelected(item.id)`?

```javascript
import * as React from 'react'
import { observer } from 'mobx-react-lite'

const Item = observer(({ item, store }) => (
    <div className={store.isSelected(item.id) ? "selected" : ""}>
        {item.title}
    </div>
))
```

There are four ways in which we can approach this. You can try the solutions below in [this CodeSandbox](https://codesandbox.io/s/multi-selection-odup1?file=/src/index.tsx).

## 1. Derivations don't _need_ to be `computed`

A function doesn't need to be marked as `computed` in order for MobX to track it.
The above example would already work completely fine out of the box.
It is important to realize that computed values are only _caching points_.
If the derivations are pure (and they should be), having a getter or function without `computed` doesn't change the behavior, it is just slightly less efficient.

The above example works fine despite `isSelected` not being a `computed`. The `observer` component will detect and subscribe to any observables that were read by `isSelected` because the function executes as part of rendering that is tracked.

It is good to realize that all `Item` components, in this case, will respond to future selection changes,
as they all subscribe directly to the observables that capture the selection.
This is a worst-case example. In general, it is completely fine to have unmarked functions that derive information, and this is a good default strategy until numbers prove anything else should be done.

## 2. Close over the arguments

This is a more efficient implementation compared to the original.

```javascript
import * as React from 'react'
import { computed } from 'mobx'
import { observer } from 'mobx-react-lite'

const Item = observer(({ item, store }) => {
    const isSelected = computed(() => store.isSelected(item.id)).get()
    return (
        <div className={isSelected ? "selected" : ""}>
            {item.title}
        </div>
    )
})
```

We create a fresh computed value in the middle of a reaction. This works fine and does introduce that additional caching point, avoiding all components having to directly respond to every selection change.
The advantage of this approach is that the component itself will only re-render if the
`isSelected` state toggles, in which case we indeed have to re-render to swap the `className`.

The fact that we create a new `computed` in a next render is fine, this one will now become the caching
point and the previous one will be cleaned up nicely.
This is a great and advanced optimization technique.

## 3. Move the state

In this specific case the selection could also be stored as an `isSelected` observable on the `Item`. The selection in the store could then be expressed as a `computed` rather than an observable: `get selection() { return this.items.filter(item => item.isSelected) }`, and we don't need `isSelected` anymore.

## 4. Use computedFn {ğŸš€}

Finally,
[`computedFn`](https://github.com/mobxjs/mobx-utils#computedfn) from `mobx-utils` can be used in the definition of `todoStore.selected` to automatically memoize `isSelected`.
It creates a function that memoizes the output for every combination of input arguments.

We recommend to not resort to this one too quickly. It is typical for memoization, that you will need to think about how many different arguments the function is going to be called with, before you can reason about the memory consumption.
It does however automatically clean up entries if their results aren't observed by any reaction, so it won't leak memory in normal circumstances.

Again, check out the [linked CodeSandbox](https://codesandbox.io/s/multi-selection-odup1?file=/src/index.tsx) to try this one out.



================================================
FILE: docs/computeds.md
================================================
---
title: Deriving information with computeds
sidebar_label: Computeds
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Deriving information with computeds

Usage:

-   `computed` _(annotation)_
-   `computed(options)` _(annotation)_
-   `computed(fn, options?)`
-   `@computed` _(getter decorator)_
-   `@computed(options)` _(getter decorator)_

Computed values can be used to derive information from other observables.
They evaluate lazily, caching their output and only recomputing if one of the underlying observables has changed.
If they are not observed by anything, they suspend entirely.

Conceptually, they are very similar to formulas in spreadsheets, and can't be underestimated. They help in reducing the amount of state you have to store and are highly optimized. Use them wherever possible.

## Example

Computed values can be created by annotating JavaScript [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) with `computed`.
Use `makeObservable` to declare a getter as computed. If you instead want all getters to be automatically declared as `computed`, you can use either `makeAutoObservable`, `observable` or `extendObservable`. Computed getters become non-enumerable.

To help illustrate the point of computed values, the example below relies on [`autorun`](reactions.md#autorun) from the [Reactions {ğŸš€}](reactions.md) advanced section.

```javascript
import { makeObservable, observable, computed, autorun } from "mobx"

class OrderLine {
    price = 0
    amount = 1

    constructor(price) {
        makeObservable(this, {
            price: observable,
            amount: observable,
            total: computed
        })
        this.price = price
    }

    get total() {
        console.log("Computing...")
        return this.price * this.amount
    }
}

const order = new OrderLine(0)

const stop = autorun(() => {
    console.log("Total: " + order.total)
})
// Computing...
// Total: 0

console.log(order.total)
// (No recomputing!)
// 0

order.amount = 5
// Computing...
// (No autorun)

order.price = 2
// Computing...
// Total: 10

stop()

order.price = 3
// Neither the computation nor autorun will be recomputed.
```

The above example nicely demonstrates the benefits of a `computed` value, it acts as a caching point.
Even though we change the `amount`, and this will trigger the `total` to recompute,
it won't trigger the `autorun`, as `total` will detect its output hasn't been affected, so there is no need to update the `autorun`.

In comparison, if `total` would not be annotated, the `autorun` would run its effect 3 times,
as it would directly depend on `total` and `amount`. [Try it out yourself](https://codesandbox.io/s/computed-3cjo9?file=/src/index.tsx).

![computed graph](assets/computed-example.png)

This is the dependency graph that would be created for the above example.

## Rules

When using computed values there are a couple of best practices to follow:

1. They should not have side effects or update other observables.
2. Avoid creating and returning new observables.
3. They should not depend on non-observable values.

## Tips

<details id="computed-suspend"><summary>**Tip:** computed values will be suspended if they are _not_ observed<a href="#computed-suspend" class="tip-anchor"></a></summary>

It sometimes confuses people new to MobX, perhaps used to a library like [Reselect](https://github.com/reduxjs/reselect), that if you create a computed property but don't use it anywhere in a reaction, it is not memoized and appears to be recomputed more often than necessary.
For example, if we extended the above example with calling `console.log(order.total)` twice, after we called `stop()`, the value would be recomputed twice.

This allows MobX to automatically suspend computations that are not actively in use
to avoid unnecessary updates to computed values that are not being accessed. But if a computed property is _not_ in use by some reaction, then computed expressions are evaluated each time their value is requested, so they behave just like a normal property.

If you only fiddle around computed properties might not seem efficient, but when applied in a project that uses `observer`, `autorun`, etc., they become very efficient.

The following code demonstrates the issue:

```javascript
// OrderLine has a computed property `total`.
const line = new OrderLine(2.0)

// If you access `line.total` outside of a reaction, it is recomputed every time.
setInterval(() => {
    console.log(line.total)
}, 60)
```

It can be overridden by setting the annotation with the `keepAlive` option ([try it out yourself](https://codesandbox.io/s/computed-3cjo9?file=/src/index.tsx)) or by creating a no-op `autorun(() => { someObject.someComputed })`, which can be nicely cleaned up later if needed.
Note that both solutions have the risk of creating memory leaks. Changing the default behavior here is an anti-pattern.

MobX can also be configured with the [`computedRequiresReaction`](configuration.md#computedrequiresreaction-boolean) option, to report an error when computeds are accessed outside of a reactive context.

</details>

<details id="computed-setter"><summary>**Tip:** computed values can have setters<a href="#computed-setter" class="tip-anchor"></a></summary>

It is possible to define a [setter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) for computed values as well. Note that these setters cannot be used to alter the value of the computed property directly,
but they can be used as an "inverse" of the derivation. Setters are automatically marked as actions. For example:

```javascript
class Dimension {
    length = 2

    constructor() {
        makeAutoObservable(this)
    }

    get squared() {
        return this.length * this.length
    }
    set squared(value) {
        this.length = Math.sqrt(value)
    }
}
```

</details>

<details id="computed-struct"><summary>{ğŸš€} **Tip:** `computed.struct` for comparing output structurally <a href="#computed-struct" class="tip-anchor"></a></summary>

If the output of a computed value that is structurally equivalent to the previous computation doesn't need to notify observers, `computed.struct` can be used. It will make a structural comparison first, rather than a reference equality check, before notifying observers. For example:

```javascript
class Box {
    width = 0
    height = 0

    constructor() {
        makeObservable(this, {
            width: observable,
            height: observable,
            topRight: computed.struct
        })
    }

    get topRight() {
        return {
            x: this.width,
            y: this.height
        }
    }
}
```

By default, the output of a `computed` is compared by reference. Since `topRight` in the above example will always produce a new result object, it is never going to be considered equal to a previous output. Unless `computed.struct` is used.

However, in the above example _we actually don't need `computed.struct`_!
Computed values normally only re-evaluate if the backing values change.
That's why `topRight` will only react to changes in `width` or `height`.
Since if any of those change, we would get a different `topRight` coordinate anyway. `computed.struct` would never have a cache hit and be a waste of effort, so we don't need it.

In practice, `computed.struct` is less useful than it sounds. Only use it if changes in the underlying observables can still lead to the same output. For example, if we were rounding the coordinates first, the rounded coordinates might be equal to the previously rounded coordinates even though the underlying values aren't.

Check out the [`equals`](#equals) option for further customizations on determining whether the output has changed.

</details>

<details id="computed-with-args"><summary>{ğŸš€} **Tip:** computed values with arguments<a href="#computed-with-args" class="tip-anchor"></a></summary>

Although getters don't take arguments, several strategies to work with derived values that need arguments are discussed [here](computeds-with-args.md).

</details>

<details id="standalone"><summary>{ğŸš€} **Tip:** create standalone computed values with `computed(expression)`<a href="#standalone" class="tip-anchor"></a></summary>

`computed` can also be invoked directly as a function, just like [`observable.box`](api.md#observablebox) creates a standalone computed value.
Use `.get()` on the returned object to get the current value of the computation.
This form of `computed` is not used very often, but in some cases where you need to pass a "boxed" computed value around it might prove itself useful, one such case is discussed [here](computeds-with-args.md).

</details>

## Options {ğŸš€}

`computed` usually behaves the way you want it to out of the box, but it's possible to customize its behavior by passing in an `options` argument.

### `name`

This string is used as a debug name in the [Spy event listeners](analyzing-reactivity.md#spy) and [MobX developer tools](https://github.com/mobxjs/mobx-devtools).

### `equals`

Set to `comparer.default` by default. It acts as a comparison function for comparing the previous value with the next value. If this function considers the values to be equal, then the observers will not be re-evaluated.

This is useful when working with structural data and types from other libraries. For example, a computed [moment](https://momentjs.com/) instance could use `(a, b) => a.isSame(b)`. `comparer.structural` and `comparer.shallow` come in handy if you want to use structural / shallow comparison to determine whether the new value is different from the previous value, and as a result notify its observers.

Check out the [`computed.struct`](#computed-struct) section above.

#### Built-in comparers

MobX provides four built-in `comparer` methods which should cover most needs of the `equals` option of `computed`:

-   `comparer.identity` uses the identity (`===`) operator to determine if two values are the same.
-   `comparer.default` is the same as `comparer.identity`, but also considers `NaN` to be equal to `NaN`.
-   `comparer.structural` performs deep structural comparison to determine if two values are the same.
-   `comparer.shallow` performs shallow structural comparison to determine if two values are the same.

You can import `comparer` from `mobx` to access these methods. They can be used for `reaction` as well.

### `requiresReaction`

It is recommended to set this one to `true` on very expensive computed values. If you try to read its value outside of the reactive context, in which case it might not be cached, it will cause the computed to throw instead of doing an expensive re-evalution.

### `keepAlive`

This avoids suspending computed values when they are not being observed by anything (see the above explanation). Can potentially create memory leaks, similar to the ones discussed for [reactions](reactions.md#always-dispose-of-reactions).



================================================
FILE: docs/configuration.md
================================================
---
title: Configuration
sidebar_label: Configuration {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Configuration {ğŸš€}

MobX has several configurations depending on how you prefer to use it, which JavaScript engines you want to target, and whether you want MobX to hint at best practices.
Most configuration options can be set by using the `configure` method.

## Proxy support

By default, MobX uses proxies to make arrays and plain objects observable. Proxies provide the best performance and most consistent behavior across environments.
However, if you are targeting an environment that doesn't support proxies, proxy support has to be disabled.
Most notably this is the case when targeting Internet Explorer or React Native without using the Hermes engine.

Proxy support can be disabled by using `configure`:

```typescript
import { configure } from "mobx"

configure({
    useProxies: "never"
})
```

Accepted values for the `useProxies` configuration are:

-   `"always"` (**default**): MobX expects to run only in environments with [`Proxy` support](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) and it will error if such an environment is not available.
-   `"never"`: Proxies are not used and MobX falls back on non-proxy alternatives. This is compatible with all ES5 environments, but causes various [limitations](#limitations-without-proxy-support).
-   `"ifavailable"` (experimental): Proxies are used if they are available, and otherwise MobX falls back to non-proxy alternatives. The benefit of this mode is that MobX will try to warn if APIs or language features that wouldn't work in ES5 environments are used, triggering errors when hitting an ES5 limitation running on a modern environment.

**Note:** before MobX 6, one had to pick either MobX 4 for older engines, or MobX 5 for new engines. However, MobX 6 supports both, although polyfills for certain APIs like Map will be required when targetting older JavaScript engines.
Proxies cannot be polyfilled. Even though polyfills do exist, they don't support the full spec and are unsuitable for MobX. Don't use them.

### Limitations without Proxy support

1.  Observable arrays are not real arrays, so they won't pass the `Array.isArray()` check. The practical consequence is that you often need to `.slice()` the array first (to get a shallow copy of the real array) before passing it to third party libraries. For example, concatenating observable arrays doesn't work as expected, so `.slice()` them first.
2.  Adding or deleting properties of existing observable plain objects after creation is not automatically picked up. If you intend to use objects as index based lookup maps, in other words, as dynamic collections of things, use observable Maps instead.

It is possible to dynamically add properties to objects, and detect their additions, even when Proxies aren't enabled.
This can be achieved by using the [Collection utilities {ğŸš€}](collection-utilities.md). Make sure that (new) properties are set using the `set` utility, and that the objects are iterated using one of the `values` / `keys` or `entries` utilities, rather than the built-in JavaScript mechanisms.
But, since this is really easy to forget, we instead recommend using observable Maps if possible.

## Decorator support

For enabling experimental decorator support check out the [Enabling decorators {ğŸš€}](enabling-decorators.md) section.

## Linting options

To help you adopt the patterns advocated by MobX, a strict separation between actions, state and derivations, MobX can _"lint"_ your coding patterns at runtime by hinting at smells. To make sure MobX is as strict as possible, adopt the following settings and read on for their explanations:

```typescript
import { configure } from "mobx"

configure({
    enforceActions: "always",
    computedRequiresReaction: true,
    reactionRequiresObservable: true,
    observableRequiresReaction: true,
    disableErrorBoundaries: true
})
```

At some point you will discover that this level of strictness can be pretty annoying.
It is fine to disable these rules to gain productivity once you are sure you (and your colleagues) grokked the mental model of MobX.

Also, occasionally you will have a case where you have to suppress the warnings triggered by these rules (for example by wrapping in `runInAction`).
That is fine, there are good exceptions to these recommendations.
Don't be fundamentalist about them.

Make sure to also try our [`eslint` plugin](https://github.com/mobxjs/mobx/blob/main/packages/eslint-plugin-mobx/README.md).
While some problems are discoverable statically, others are detectable only at runtime.
The plugin is intended to complement these rules, not to replace them.
The autofix feature can also help with the boilerplate code.

#### `enforceActions`

The goal of _enforceActions_ is that you don't forget to wrap event handlers in [`action`](actions.md).

Possible options:

-   `"observed"` (**default**): All state that is observed _somewhere_ needs to be changed through actions. This is the default, and the recommended strictness mode in non-trivial applications.
-   `"never"`: State can be changed from anywhere.
-   `"always"`: State always needs to be changed through actions, which in practice also includes creation.

The benefit of `"observed"` is that it allows you to create observables outside of actions and modify them freely, as long as they aren't used anywhere yet.

Since state should in principle always be created from some event handlers, and event handlers should be wrapped, `"always"` captures this the best. But you probably don't want to use this mode in unit tests.

In the rare case where you create observables lazily, for example in a computed property, you can wrap the creation ad-hoc in an action using `runInAction`.

#### `computedRequiresReaction: boolean`

Forbids the direct access of any unobserved computed value from outside an action or reaction.
This guarantees you aren't using computed values in a way where MobX won't cache them. **Default: `false`**.

In the following example, MobX won't cache the computed value in the first code block, but will cache the result in the second and third block:

```javascript
class Clock {
    seconds = 0

    get milliseconds() {
        console.log("computing")
        return this.seconds * 1000
    }

    constructor() {
        makeAutoObservable(this)
    }
}

const clock = new Clock()
{
    // This would compute twice, but is warned against by this flag.
    console.log(clock.milliseconds)
    console.log(clock.milliseconds)
}
{
    runInAction(() => {
        // Will compute only once.
        console.log(clock.milliseconds)
        console.log(clock.milliseconds)
    })
}
{
    autorun(() => {
        // Will compute only once.
        console.log(clock.milliseconds)
        console.log(clock.milliseconds)
    })
}
```

#### `observableRequiresReaction: boolean`

Warns about any unobserved observable access.
Use this if you want to check whether you are using observables without a "MobX context".
This is a great way to find any missing `observer` wrappers, for example in React components. But it will find missing actions as well. **Default: `false`**

```javascript
configure({ observableRequiresReaction: true })
```

**Note:** using propTypes on components that are wrapped with `observer` might trigger false positives for this rule.

#### `reactionRequiresObservable: boolean`

Warns when a reaction (e.g. `autorun`) is created without accessing any observables.
Use this to check whether you are unnecessarily wrapping React components with `observer`, wrapping functions with `action`, or find cases where you simply forgot to make some data structures or properties observable. **Default: `false`**

```javascript
configure({ reactionRequiresObservable: true })
```

#### `disableErrorBoundaries: boolean`

By default, MobX will catch and re-throw exceptions happening in your code to make sure that a reaction in one exception does not prevent the scheduled execution of other, possibly unrelated, reactions. This means exceptions are not propagated back to the original causing code and therefore you won't be able to catch them using try/catch.

By disabling error boundaries, exceptions can escape derivations. This might ease debugging, but might leave MobX and by extension your application in an unrecoverable broken state. **Default: `false`**.

This option is great for unit tests, but remember to call `_resetGlobalState` after each test, for example by using `afterEach` in jest, for example:

```js
import { _resetGlobalState, observable, autorun, configure } from "mobx"

configure({ disableErrorBoundaries: true })

test("Throw if age is negative", () => {
    expect(() => {
        const age = observable.box(10)
        autorun(() => {
            if (age.get() < 0) throw new Error("Age should not be negative")
        })
        age.set(-1)
    }).toThrow("Age should not be negative")
})

afterEach(() => {
    _resetGlobalState()
})
```

#### `safeDescriptors: boolean`

MobX makes some fields **non-configurable** or **non-writable** to prevent you from doing things that are not supported or would most likely break your code. However this can also prevent **spying/mocking/stubbing** in your tests.
`configure({ safeDescriptors: false })` disables this safety measure, making everything **configurable** and **writable**.
Note it doesn't affect existing observables, only the ones created after it's been configured.
<span style="color:red">**Use with caution**</span> and only when needed - do not turn this off globally for all tests, otherwise you risk false positives (passing tests with broken code). **Default: `true`**

```javascript
configure({ safeDescriptors: false })
```

## Further configuration options

#### `isolateGlobalState: boolean`

Isolates the global state of MobX when there are multiple instances of MobX active in the same environment. This is useful when you have an encapsulated library that is using MobX, living in the same page as the app that is using MobX. The reactivity inside the library will remain self-contained when you call `configure({ isolateGlobalState: true })` from it.

Without this option, if multiple MobX instances are active, their internal state will be shared. The benefit is that observables from both instances work together, the downside is that the MobX versions have to match. **Default: `false`**

```javascript
configure({ isolateGlobalState: true })
```

#### `reactionScheduler: (f: () => void) => void`

Sets a new function that executes all MobX reactions.
By default `reactionScheduler` just runs the `f` reaction without any other behavior.
This can be useful for basic debugging, or slowing down reactions to visualize application updates. **Default: `f => f()`**

```javascript
configure({
    reactionScheduler: (f): void => {
        console.log("Running an event after a delay:", f)
        setTimeout(f, 100)
    }
})
```



================================================
FILE: docs/custom-observables.md
================================================
---
title: Creating custom observables
sidebar_label: Custom observables {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Creating custom observables {ğŸš€}

At some point you might want to have more data structures or other things (like streams) that can be used in reactive computations.
Achieving this is pretty simple by using **atoms**, which is the class that MobX uses internally for all observable data types.
Atoms can be used to signal to MobX that some observable data source has been observed or changed, and MobX will let the atom know when it's being used and when it's not.

> _**Tip**: In many cases you can avoid the need to create your own atoms just by creating a normal observable, and using
the [`onBecomeObserved`](lazy-observables.md) utility to be notified when MobX starts tracking it._

The following example demonstrates how you can create an observable `Clock` that returns the current date-time, which can then be used in reactive functions.
This clock will only actually tick if it is being observed by someone.

The complete API of the `Atom` class is demonstrated by this example. For further information, see [`createAtom`](api.md#createAtom).

```javascript
import { createAtom, autorun } from "mobx"

class Clock {
    atom
    intervalHandler = null
    currentDateTime

    constructor() {
        // Creates an atom to interact with the MobX core algorithm.
        this.atom = createAtom(
            // 1st parameter:
            // - Atom's name, for debugging purposes.
            "Clock",
            // 2nd (optional) parameter:
            // - Callback for when this atom transitions from unobserved to observed.
            () => this.startTicking(),
            // 3rd (optional) parameter:
            // - Callback for when this atom transitions from observed to unobserved.
            () => this.stopTicking()
            // The same atom transitions between these two states multiple times.
        )
    }

    getTime() {
        // Let MobX know this observable data source has been used.
        //
        // reportObserved will return true if the atom is currently being observed
        // by some reaction. If needed, it will also trigger the startTicking
        // onBecomeObserved event handler.
        if (this.atom.reportObserved()) {
            return this.currentDateTime
        } else {
            // getTime was called, but not while a reaction was running, hence
            // nobody depends on this value, and the startTicking onBecomeObserved
            // handler won't be fired.
            //
            // Depending on the nature of your atom it might behave differently
            // in such circumstances, like throwing an error, returning a default
            // value, etc.
            return new Date()
        }
    }

    tick() {
        this.currentDateTime = new Date()
        this.atom.reportChanged() // Let MobX know that this data source has changed.
    }

    startTicking() {
        this.tick() // Initial tick.
        this.intervalHandler = setInterval(() => this.tick(), 1000)
    }

    stopTicking() {
        clearInterval(this.intervalHandler)
        this.intervalHandler = null
    }
}

const clock = new Clock()

const disposer = autorun(() => console.log(clock.getTime()))
// Prints the time every second.

// Stop printing. If nobody else uses the same `clock`, it will stop ticking as well.
disposer()
```



================================================
FILE: docs/defining-data-stores.md
================================================
---
title: Defining data stores
sidebar_label: Defining data stores
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Defining data stores

This section contains some of the best practices for building large scale maintainable projects we discovered at Mendix while working with MobX.
This section is opinionated and you are in no way forced to apply these practices.
There are many ways of working with MobX and React, and this is just one of them.

This section focuses on an unobtrusive way of working with MobX, which works well in existing codebases, or with classic MVC patterns. Alternative, more opinionated ways of organizing stores are [mobx-state-tree](https://github.com/mobxjs/mobx-state-tree) and [mobx-keystone](https://mobx-keystone.js.org/). Both ship with cool features such as structurally shared snapshots, action middlewares, JSON patch support etc. out of the box.

## Stores

Stores can be found in any Flux architecture and can be compared a bit with controllers in the MVC pattern.
The main responsibility of stores is to move _logic_ and _state_ out of your components into a standalone testable unit that can be used in both frontend and backend JavaScript.

Most applications benefit from having at least two stores: one for the _domain state_ and another one for the _UI state_. The advantage of separating those two is you can reuse and test _domain state_ universally, and you might very well reuse it in other applications.

## Domain Stores

Your application will contain one or multiple _domain_ stores.
These stores store the data your application is all about.
Todo items, users, books, movies, orders, you name it.
Your application will most probably have at least one domain store.

A single domain store should be responsible for a single concept in your application. A single store is often organized as a tree structure with
multiple domain objects inside.

For example: one domain store for your products, and one for your orders and orderlines.
As a rule of thumb: if the nature of the relationship between two items is containment, they should typically be in the same store.
So a store just manages _domain objects_.

These are the responsibilities of a store:

-   Instantiate domain objects. Make sure domain objects know the store they belong to.
-   Make sure there is only one instance of each of your domain objects.
    The same user, order or todo should not be stored twice in memory.
    This way you can safely use references and also be sure you are looking at the latest instance, without ever having to resolve a reference.
    This is fast, straightforward and convenient when debugging.
-   Provide backend integration. Store data when needed.
-   Update existing instances if updates are received from the backend.
-   Provide a standalone, universal, testable component of your application.
-   To make sure your store is testable and can be run server-side, you will probably move doing actual websocket / http requests to a separate object so that you can abstract over your communication layer.
-   There should be only one instance of a store.

### Domain objects

Each domain object should be expressed using its own class (or constructor function).
There is no need to treat your client-side application state as some kind of database.
Real references, cyclic data structures and instance methods are powerful concepts in JavaScript.
Domain objects are allowed to refer directly to domain objects from other stores.
Remember: we want to keep our actions and views as simple as possible and needing to manage references and doing garbage collection yourself might be a step backward.
Unlike many Flux architectures such as Redux, with MobX there is no need to normalize your data, and this makes it a lot simpler to build the _essentially_ complex parts of your application:
your business rules, actions and user interface.

Domain objects can delegate all their logic to the store they belong to if that suits your application well.
It is possible to express your domain objects as plain objects, but classes have some important advantages over plain objects:

-   They can have methods.
    This makes your domain concepts easier to use standalone and reduces the amount of contextual awareness that is needed in your application.
    Just pass objects around.
    You don't have to pass stores around, or have to figure out which actions can be applied to an object if they are just available as instance methods.
    This is especially important in large applications.
-   They offer fine grained control over the visibility of attributes and methods.
-   Objects created using a constructor function can freely mix observable properties and methods, and non-observable properties and methods.
-   They are easily recognizable and can be strictly type-checked.

### Example domain store

```javascript
import { makeAutoObservable, runInAction, reaction } from "mobx"
import uuid from "node-uuid"

export class TodoStore {
    authorStore
    transportLayer
    todos = []
    isLoading = true

    constructor(transportLayer, authorStore) {
        makeAutoObservable(this)
        this.authorStore = authorStore // Store that can resolve authors.
        this.transportLayer = transportLayer // Thing that can make server requests.
        this.transportLayer.onReceiveTodoUpdate(updatedTodo =>
            this.updateTodoFromServer(updatedTodo)
        )
        this.loadTodos()
    }

    // Fetches all Todos from the server.
    loadTodos() {
        this.isLoading = true
        this.transportLayer.fetchTodos().then(fetchedTodos => {
            runInAction(() => {
                fetchedTodos.forEach(json => this.updateTodoFromServer(json))
                this.isLoading = false
            })
        })
    }

    // Update a Todo with information from the server. Guarantees a Todo only
    // exists once. Might either construct a new Todo, update an existing one,
    // or remove a Todo if it has been deleted on the server.
    updateTodoFromServer(json) {
        let todo = this.todos.find(todo => todo.id === json.id)
        if (!todo) {
            todo = new Todo(this, json.id)
            this.todos.push(todo)
        }
        if (json.isDeleted) {
            this.removeTodo(todo)
        } else {
            todo.updateFromJson(json)
        }
    }

    // Creates a fresh Todo on the client and the server.
    createTodo() {
        const todo = new Todo(this)
        this.todos.push(todo)
        return todo
    }

    // A Todo was somehow deleted, clean it from the client memory.
    removeTodo(todo) {
        this.todos.splice(this.todos.indexOf(todo), 1)
        todo.dispose()
    }
}

// Domain object Todo.
export class Todo {
    id = null // Unique id of this Todo, immutable.
    completed = false
    task = ""
    author = null // Reference to an Author object (from the authorStore).
    store = null
    autoSave = true // Indicator for submitting changes in this Todo to the server.
    saveHandler = null // Disposer of the side effect auto-saving this Todo (dispose).

    constructor(store, id = uuid.v4()) {
        makeAutoObservable(this, {
            id: false,
            store: false,
            autoSave: false,
            saveHandler: false,
            dispose: false
        })
        this.store = store
        this.id = id

        this.saveHandler = reaction(
            () => this.asJson, // Observe everything that is used in the JSON.
            json => {
                // If autoSave is true, send JSON to the server.
                if (this.autoSave) {
                    this.store.transportLayer.saveTodo(json)
                }
            }
        )
    }

    // Remove this Todo from the client and the server.
    delete() {
        this.store.transportLayer.deleteTodo(this.id)
        this.store.removeTodo(this)
    }

    get asJson() {
        return {
            id: this.id,
            completed: this.completed,
            task: this.task,
            authorId: this.author ? this.author.id : null
        }
    }

    // Update this Todo with information from the server.
    updateFromJson(json) {
        this.autoSave = false // Prevent sending of our changes back to the server.
        this.completed = json.completed
        this.task = json.task
        this.author = this.store.authorStore.resolveAuthor(json.authorId)
        this.autoSave = true
    }

    // Clean up the observer.
    dispose() {
        this.saveHandler()
    }
}
```

## UI stores

The _ui-state-store_ is often very specific for your application, but usually very simple as well.
This store typically doesn't have much logic in it, but will store a plethora of loosely coupled pieces of information about the UI.
This is ideal as most applications will change the UI state often during the development process.

Things you will typically find in UI stores:

-   Session information
-   Information about how far your application has loaded
-   Information that will not be stored in the backend
-   Information that affects the UI globally
    -   Window dimensions
    -   Accessibility information
    -   Current language
    -   Currently active theme
-   User interface state as soon as it affects multiple, further unrelated components:
    -   Current selection
    -   Visibility of toolbars, etc.
    -   State of a wizard
    -   State of a global overlay

It might very well be that these pieces of information start as internal state of a specific component (for example the visibility of a toolbar), but after a while you discover that you need this information somewhere else in your application.
Instead of pushing state in such a case upwards in the component tree, like you would do in plain React apps, you just move that state to the _ui-state-store_.

For isomorphic applications you might also want to provide a stub implementation of this store with sane defaults so that all components render as expected.
You might distribute the _ui-state-store_ through your application by passing it as React context.

Example of a store (using ES6 syntax):

```javascript
import { makeAutoObservable, observable, computed } from "mobx"

export class UiState {
    language = "en_US"
    pendingRequestCount = 0

    // .struct makes sure observer won't be signaled unless the
    // dimensions object changed in a deepEqual manner.
    windowDimensions = {
        width: window.innerWidth,
        height: window.innerHeight
    }

    constructor() {
        makeAutoObservable(this, { windowDimensions: observable.struct })
        window.onresize = () => {
            this.windowDimensions = getWindowDimensions()
        }
    }

    get appIsInSync() {
        return this.pendingRequestCount === 0
    }
}
```

## Combining multiple stores

An often asked question is how to combine multiple stores without using singletons. How will they know about each other?

An effective pattern is to create a `RootStore` that instantiates all stores, and share references. The advantage of this pattern is:

1. Simple to set up.
2. Supports strong typing well.
3. Makes complex unit tests easy as you just have to instantiate a root store.

Example:

```javascript
class RootStore {
    constructor() {
        this.userStore = new UserStore(this)
        this.todoStore = new TodoStore(this)
    }
}

class UserStore {
    constructor(rootStore) {
        this.rootStore = rootStore
    }

    getTodos(user) {
        // Access todoStore through the root store.
        return this.rootStore.todoStore.todos.filter(todo => todo.author === user)
    }
}

class TodoStore {
    todos = []
    rootStore

    constructor(rootStore) {
        makeAutoObservable(this)
        this.rootStore = rootStore
    }
}
```

When using React, this root store is typically inserted into the component tree by using React context.



================================================
FILE: docs/enabling-decorators.md
================================================
---
title: Decorators
sidebar_label: Decorators {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Decorators

## Enabling decorators

After years of alterations, ES decorators have finally reached Stage 3 in the TC39 process, meaning that they are quite stable and won't undergo breaking changes again like the previous decorator proposals have. MobX has implemented support for this new "2022.3/Stage 3" decorator syntax.
With modern decorators, it is no longer needed to call `makeObservable` / `makeAutoObservable`.

2022.3 Decorators are supported in:

-   TypeScript (5.0 and higher, make sure that the `experimentalDecorators` flag is NOT enabled). [Example commit](https://github.com/mweststrate/currencies-demo/commit/acb9ac8c148e8beef88042c847bb395131e85d60).
-   For Babel make sure the plugin [`proposal-decorators`](https://babeljs.io/docs/babel-plugin-proposal-decorators) is enabled with the highest version (currently `2023-05`). [Example commit](https://github.com/mweststrate/currencies-demo/commit/4999d2228208f3e1e10bc00a272046eaefde8585).

```js
// tsconfig.json
{
    "compilerOptions": {
        "experimentalDecorators": false /* or just remove the flag */
    }
}

// babel.config.json (or equivalent)
{
    "plugins": [
        [
            "@babel/plugin-proposal-decorators",
            {
                "version": "2023-05"
            }
        ]
    ]
}
```

-   Vite configuration

```js
// vite.config.js
{
    plugins: [
        react({
            babel: {
                plugins: [
                    [
                        "@babel/plugin-proposal-decorators",
                        {
                            version: "2023-05"
                        }
                    ]
                ]
            }
        })
    ]
}
```

## Using decorators

```javascript
import { observable, computed, action } from "mobx"

class Todo {
    id = Math.random()
    @observable accessor title = ""
    @observable accessor finished = false

    @action
    toggle() {
        this.finished = !this.finished
    }
}

class TodoList {
    @observable accessor todos = []

    @computed
    get unfinishedTodoCount() {
        return this.todos.filter(todo => !todo.finished).length
    }
}
```

Notice the usage of the new `accessor` keyword when using `@observable`.
It is part of the 2022.3 spec and is required if you want to use modern decorators.

<details id="legacy-decorators"><summary>Using legacy decorators</summary>

We do not recommend codebases to use TypeScript / Babel legacy decorators since they well never become an official part of the language, but you can still use them. It does require a specific setup for transpilation:

MobX before version 6 encouraged the use of legacy decorators and mark things as `observable`, `computed` and `action`.
While MobX 6 recommends against using these decorators (and instead use either modern decorators or [`makeObservable` / `makeAutoObservable`](observable-state.md)), it is in the current major version still possible.
Support for legacy decorators will be removed in MobX 7.

```javascript
import { makeObservable, observable, computed, action } from "mobx"

class Todo {
    id = Math.random()
    @observable title = ""
    @observable finished = false

    constructor() {
        makeObservable(this)
    }

    @action
    toggle() {
        this.finished = !this.finished
    }
}

class TodoList {
    @observable todos = []

    @computed
    get unfinishedTodoCount() {
        return this.todos.filter(todo => !todo.finished).length
    }

    constructor() {
        makeObservable(this)
    }
}
```

</details>

<details id="migrate-decorators"><summary>Migrating from legacy decorators</summary>

To migrate from legacy decorators to modern decorators, perform the following steps:

1. Disable / remove the `experimentalDecorators` flag from your TypeScript configuration (or Babel equivalent)
2. Remove all `makeObservable(this)` calls from class constructors that use decorators.
3. Replace all instances of `@observable` (and variations) with `@observable accessor`

Please note that adding `accessor` to a class property will change it into `get` and `set` class methods. Unlike class properties, class methods are not enumerable. This may introduce new behavior with some APIs, such as `Object.keys`, `JSON.stringify`, etc.

</details>

<details id="gotchas"><summary>Decorator changes / gotchas</summary>

MobX' 2022.3 Decorators are very similar to the MobX 5 decorators, so usage is mostly the same, but there are some gotchas:

-   `@observable accessor` decorators are _not_ enumerable. `accessor`s do not have a direct equivalent in the past - they're a new concept in the language. We've chosen to make them non-enumerable, non-own properties in order to better follow the spirit of the ES language and what `accessor` means.
    The main cases for enumerability seem to have been around serialization and rest destructuring.
    -   Regarding serialization, implicitly serializing all properties probably isn't ideal in an OOP-world anyway, so this doesn't seem like a substantial issue (consider implementing `toJSON` or using `serializr` as possible alternatives)
    -   Addressing rest-destructuring, such is an anti-pattern in MobX - doing so would (likely unwantedly) touch all observables and make the observer overly-reactive).
-   `@action some_field = () => {}` was and is valid usage. However, inheritance is different between legacy decorators and modern decorators.
    -   In legacy decorators, if superclass has a field decorated by `@action`, and subclass tries to override the same field, it will throw a `TypeError: Cannot redefine property`.
    -   In modern decorators, if superclass has a field decorated by `@action`, and subclass tries to override the same field, it's allowed to override the field. However, the field on subclass is not an action unless it's also decorated with `@action` in subclass declaration.

</details>

## Using `observer` as a decorator

The `observer` function from `mobx-react` is both a function and a decorator that can be used on class components:

```javascript
@observer
class Timer extends React.Component {
    /* ... */
}
```



================================================
FILE: docs/installation.md
================================================
---
title: Installation
sidebar_label: Installation
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Installation

MobX works in any ES5 environment, which includes browsers and NodeJS.

There are three types of React bindings:
- [mobx-react-lite](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite). Utilities to manually apply observation
- [mobx-react-observer](https://github.com/christianalfoni/mobx-react-observer). Babel/swc plugin to automatically apply observation to components
- [mobx-react](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react). Support for class components

Append the appropriate bindings for your use case to the _Yarn_ or _NPM_ command below:

**Yarn:** `yarn add mobx`

**NPM:** `npm install --save mobx`

**CDN:** https://cdnjs.com/libraries/mobx / https://unpkg.com/mobx/dist/mobx.umd.production.min.js

# Transpilation settings

## MobX and Decorators

Based on your preference, MobX can be used with or without decorators.
Both the legacy implementation and the standardised TC-39 version of decorators are currently supported.
See [enabling-decorators](enabling-decorators.md) for more details on how to enable them.
Legacy decorator support will be removed in MobX 7, in favor of the standard.

## Use spec compliant transpilation for class properties

When using MobX with TypeScript or Babel, and you plan to use classes; make sure to update your configuration to use a TC-39 spec compliant transpilation for class fields, since this is not always the default. Without this, class fields cannot be made observable before they are initialized.

-   **TypeScript**: Set the compiler option `"useDefineForClassFields": true`.
-   **Babel**: Make sure to use at least version 7.12, with the following configuration:
    ```json
    {
        // Babel < 7.13.0
        "plugins": [["@babel/plugin-proposal-class-properties", { "loose": false }]],

        // Babel >= 7.13.0 (https://babeljs.io/docs/en/assumptions)
        "plugins": [["@babel/plugin-proposal-class-properties"]],
        "assumptions": {
            "setPublicClassFields": false
        }
    }
    ```
For verification insert this piece of code at the beginning of your sources (eg. `index.js`)
```javascript
if (!new class { x }().hasOwnProperty('x')) throw new Error('Transpiler is not configured correctly');
```

## MobX on older JavaScript environments

By default, MobX uses proxies for optimal performance and compatibility. However, on older JavaScript engines `Proxy` is not available (check out [Proxy support](https://compat-table.github.io/compat-table/es6/#test-Proxy)). Examples of such are Internet Explorer (before Edge), Node.js < 6, iOS < 10, Android before RN 0.59, or Android on iOS.

In such cases, MobX can fallback to an ES5 compatible implementation which works almost identically, although there are a few [limitations without Proxy support](configuration.md#limitations-without-proxy-support). You will have to explicitly enable the fallback implementation by configuring [`useProxies`](configuration.md#proxy-support):

```javascript
import { configure } from "mobx"

configure({ useProxies: "never" }) // Or "ifavailable".
```

This option will be removed in MobX 7.

## MobX on other frameworks / platforms

-   [MobX.dart](https://mobx.netlify.app/): MobX for Flutter / Dart
-   [lit-mobx](https://github.com/adobe/lit-mobx): MobX for lit-element
-   [mobx-angular](https://github.com/mobxjs/mobx-angular): MobX for angular
-   [mobx-vue](https://github.com/mobxjs/mobx-vue): MobX for Vue



================================================
FILE: docs/intercept-and-observe.md
================================================
---
title: Intercept & Observe
sidebar_label: Intercept & Observe {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Intercept & Observe {ğŸš€}

_âš ï¸ **Warning**: intercept and observe are low level utilities, and should not be needed in practice. Use some form of [reaction](reactions.md) instead, as `observe` doesn't respect transactions and doesn't support deep observing of changes. Using these utilities is an anti-pattern. If you intend to get access to the old and new value using `observe`, use [`reaction`](reactions.md#reaction) instead. âš ï¸_

`observe` and `intercept` can be used to monitor the changes of a single observable, but they **_don't_** track nested observables.

-   `intercept` can be used to detect and modify mutations before they are applied to the observable (validating, normalizing or cancelling).
-   `observe` allows you to intercept changes after they have been made.

## Intercept

Usage: `intercept(target, propertyName?, interceptor)`

_Please avoid this API. It basically provides a bit of aspect-oriented programming, creating flows that are really hard to debug. Instead, do things like data validation **before** updating any state, rather than during._

-   `target`: the observable to guard.
-   `propertyName`: optional parameter to specify a specific property to intercept. Note that `intercept(user.name, interceptor)` is fundamentally different from `intercept(user, "name", interceptor)`. The first tries to add an interceptor to the _current_ `value` inside `user.name`, which might not be an observable at all. The latter intercepts changes to the `name` _property_ of `user`.
-   `interceptor`: callback that is invoked for _each_ change that is made to the observable. Receives a single change object describing the mutation.

The `intercept` should tell MobX what needs to happen with the current change.
Therefore it should do one of the following things:

1. Return the received `change` object as-is from the function, in which case the mutation will be applied.
2. Modify the `change` object and return it, for example to normalize the data. Not all fields are modifiable, see below.
3. Return `null`, this indicates that the change can be ignored and shouldn't be applied. This is a powerful concept with which you can for example make your objects temporarily immutable.
4. Throw an exception, if for example some invariant isn't met.

The function returns a `disposer` function that can be used to cancel the interceptor when invoked.
It is possible to register multiple interceptors to the same observable.
They will be chained in registration order.
If one of the interceptors returns `null` or throws an exception, the other interceptors won't be evaluated anymore.
It is also possible to register an interceptor both on a parent object and on an individual property.
In that case the parent object interceptors are run before the property interceptors.

```javascript
const theme = observable({
    backgroundColor: "#ffffff"
})

const disposer = intercept(theme, "backgroundColor", change => {
    if (!change.newValue) {
        // Ignore attempts to unset the background color.
        return null
    }
    if (change.newValue.length === 6) {
        // Correct missing '#' prefix.
        change.newValue = "#" + change.newValue
        return change
    }
    if (change.newValue.length === 7) {
        // This must be a properly formatted color code!
        return change
    }
    if (change.newValue.length > 10) {
        // Stop intercepting future changes.
        disposer()
    }
    throw new Error("This doesn't look like a color at all: " + change.newValue)
})
```

## Observe

Usage: `observe(target, propertyName?, listener, invokeImmediately?)`

_See above notice, please avoid this API and use [`reaction`](reactions.md#reaction) instead._

-   `target`: the observable to observe.
-   `propertyName`: optional parameter to specify a specific property to observe. Note that `observe(user.name, listener)` is fundamentally different from `observe(user, "name", listener)`. The first observes the _current_ `value` inside `user.name`, which might not be an observable at all. The latter observes the `name` _property_ of `user`.
-   `listener`: callback that will be invoked for _each_ change that is made to the observable. Receives a single change object describing the mutation, except for boxed observables, which will invoke the `listener` with two parameters: `newValue, oldValue`.
-   `invokeImmediately`: _false_ by default. Set it to _true_ if you want `observe` to invoke the `listener` directly with the state of the observable, instead of waiting for the first change. Not supported (yet) by all kinds of observables.

The function returns a `disposer` function that can be used to cancel the observer.
Note that `transaction` does not affect the working of the `observe` method(s).
This means that even inside a transaction `observe` will fire its listeners for each mutation.
Hence [`autorun`](reactions.md#autorun) is usually a more powerful and declarative alternative to `observe`.

_`observe` reacts to **mutations** when they are being made, while reactions like `autorun` or `reaction` react to **new values** when they become available. In many cases the latter is sufficient._

Example:

```javascript
import { observable, observe } from "mobx"

const person = observable({
    firstName: "Maarten",
    lastName: "Luther"
})

// Observe all fields.
const disposer = observe(person, change => {
    console.log(change.type, change.name, "from", change.oldValue, "to", change.object[change.name])
})

person.firstName = "Martin"
// Prints: 'update firstName from Maarten to Martin'

// Ignore any future updates.
disposer()

// Observe a single field.
const disposer2 = observe(person, "lastName", change => {
    console.log("LastName changed to ", change.newValue)
})
```

Related blog: [Object.observe is dead. Long live mobx.observe](https://medium.com/@mweststrate/object-observe-is-dead-long-live-mobservable-observe-ad96930140c5)

## Event overview

The callbacks of `intercept` and `observe` will receive an event object which has at least the following properties:

-   `object`: the observable triggering the event.
-   `debugObjectName`: the name of the observable triggering the event (for debugging).
-   `observableKind`: the type of the observable (value, set, array, object, map, computed).
-   `type` (string): the type of the current event.

These are the additional fields that are available per type:

| Observable type              | Event type | Property     | Description                                                                                       | Available during intercept | Can be modified by intercept |
| ---------------------------- | ---------- | ------------ | ------------------------------------------------------------------------------------------------- | -------------------------- | ---------------------------- |
| Object                       | add        | name         | Name of the property being added.                                                                 | âˆš                          |                              |
|                              |            | newValue     | The new value being assigned.                                                                     | âˆš                          | âˆš                            |
|                              | update\*   | name         | Name of the property being updated.                                                               | âˆš                          |                              |
|                              |            | newValue     | The new value being assigned.                                                                     | âˆš                          | âˆš                            |
|                              |            | oldValue     | The value that is replaced.                                                                       |                            |                              |
| Array                        | splice     | index        | Starting index of the splice. Splices are also fired by `push`, `unshift`, `replace`, etc.        | âˆš                          |                              |
|                              |            | removedCount | Amount of items being removed.                                                                    | âˆš                          | âˆš                            |
|                              |            | added        | Array with items being added.                                                                     | âˆš                          | âˆš                            |
|                              |            | removed      | Array with items that were removed.                                                               |                            |                              |
|                              |            | addedCount   | Amount of items that were added.                                                                  |                            |                              |
|                              | update     | index        | Index of the single entry being updated.                                                          | âˆš                          |                              |
|                              |            | newValue     | The newValue that is / will be assigned.                                                          | âˆš                          | âˆš                            |
|                              |            | oldValue     | The old value that was replaced.                                                                  |                            |                              |
| Map                          | add        | name         | The name of the entry that was added.                                                             | âˆš                          |                              |
|                              |            | newValue     | The new value that is being assigned.                                                             | âˆš                          | âˆš                            |
|                              | update     | name         | The name of the entry being updated.                                                              | âˆš                          |                              |
|                              |            | newValue     | The new value that is being assigned.                                                             | âˆš                          | âˆš                            |
|                              |            | oldValue     | The value that has been replaced.                                                                 |                            |                              |
|                              | delete     | name         | The name of the entry being removed.                                                              | âˆš                          |                              |
|                              |            | oldValue     | The value of the entry that was removed.                                                          |                            |                              |
| Boxed & computed observables | create     | newValue     | The value that was assigned during creation. Only available as `spy` event for boxed observables. |                            |                              |
|                              | update     | newValue     | The new value being assigned.                                                                     | âˆš                          | âˆš                            |
|                              |            | oldValue     | The previous value of the observable.                                                             |                            |                              |

**Note:** object `update` events won't fire for updated computed values (as those aren't mutations). But it is possible to observe them by explicitly subscribing to the specific property using `observe(object, 'computedPropertyName', listener)`.



================================================
FILE: docs/lazy-observables.md
================================================
---
title: Creating lazy observables
sidebar_label: Lazy observables {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Creating lazy observables {ğŸš€}

Usage:

-   `onBecomeObserved(observable, property?, listener: () => void): (() => void)`
-   `onBecomeUnobserved(observable, property?, listener: () => void): (() => void)`

Functions `onBecomeObserved` and `onBecomeUnobserved` can be used to attach lazy behavior or side effects to existing observables. They hook into the observability system of MobX and get notified when an observable _starts_ and _stops_ becoming observed. They both return a _disposer_ function that detaches the _listener_.

In the example below we use them to perform network fetches only when the observed value is actually in use.

```javascript
export class City {
    location
    temperature
    interval

    constructor(location) {
        makeAutoObservable(this, {
            resume: false,
            suspend: false
        })
        this.location = location
        // Only start data fetching if temperature is actually used!
        onBecomeObserved(this, "temperature", this.resume)
        onBecomeUnobserved(this, "temperature", this.suspend)
    }

    resume = () => {
        log(`Resuming ${this.location}`)
        this.interval = setInterval(() => this.fetchTemperature(), 5000)
    }

    suspend = () => {
        log(`Suspending ${this.location}`)
        this.temperature = undefined
        clearInterval(this.interval)
    }

    fetchTemperature = flow(function* () {
        // Data fetching logic...
    })
}
```



================================================
FILE: docs/LINKS.md
================================================
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Resources

-   [Ten minute interactive introduction to MobX and React](https://mobx.js.org/getting-started)
-   How MobX works: [In depth explanation of MobX](https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.wnlo6bw8y)
-   Clone the boilerplate repository containing the above example from: https://github.com/mweststrate/react-mobservable-boilerplate.
-   Or fork this [JSFiddle](https://jsfiddle.net/mweststrate/wgbe4guu/).

## Related projects

-   [mobx-connect](https://github.com/nightwolfz/mobx-connect) MobX @connect decorator for react components. Similar to redux's @connect.
-   [rfx-stack](https://github.com/foxhound87/rfx-stack) RFX Stack - Universal App featuring: React + Feathers + MobX
-   [mobx-reactor](https://github.com/amsb/mobx-reactor) Connect MobX data stores to functional stateless React components with async actions and unidirectional data flow.
-   [mobx-model](https://github.com/ikido/mobx-model) Simplify mobx data stores that mimic backend models
-   [rx-mobx](https://github.com/chicoxyzzy/rx-mobx) Convert MobX observables to RxJS and vice versa

## More examples

A nice list is WIP, but see this [github issue](https://github.com/mobxjs/mobx/issues/104) for a list of example projects, including routing, authorization, server side rendering etc.

-   [TodoMVC using MobX and React](https://github.com/mweststrate/mobx-todomvc)
-   The [ports of the _Notes_ and _Kanban_ examples](https://github.com/survivejs/mobservable-demo) from the book "SurviveJS - Webpack and React" to mobservable.
-   A simple webshop using [React + mobx](https://jsfiddle.net/mweststrate/46vL0phw) or [JQuery + mobx](http://jsfiddle.net/mweststrate/vxn7qgdw).
-   [Simple timer](https://jsfiddle.net/mweststrate/wgbe4guu/) application in JSFiddle.
-   [Simple ES5 MobX examples](https://github.com/mattruby/mobx-examples) Bite sized MobX examples all setup to run in jsFiddle.

## Philosophy

-   [Making React reactive: the pursuit of high performing, easily maintainable React apps](https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/)
-   [SurviveJS interview on Mobservable, React and Flux](http://survivejs.com/blog/mobservable-interview/)
-   [Pure rendering in the light of time and state](https://medium.com/@mweststrate/pure-rendering-in-the-light-of-time-and-state-4b537d8d40b1)
-   [Official homepage](http://mobxjs.github.io/mobx/)



================================================
FILE: docs/migrating-from-4-or-5.md
================================================
---
title: Migrating from MobX 4/5
sidebar_label: Migrating from MobX 4/5 {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Migrating from MobX 4/5 {ğŸš€}

MobX 6 is quite different from MobX 5. This pages covers a migration guide from MobX 4 and 5 to 6, and an extensive list of all the changes.

For a better understanding, check out the MobX 6.0 [CHANGELOG](https://github.com/mobxjs/mobx/blob/main/packages/mobx/CHANGELOG.md#600).

_âš ï¸ **Warning**: Depending on factors like the size and complexity of your code base, your MobX usage patterns, and the quality of your automated tests, this migration guide might take you anywhere between an hour and a couple of days. Please refrain from upgrading if you don't trust your Continuous Integration or QA / test procedures enough to pick up any unexpected breakages. Unexpected behavioral changes might be caused by changes in MobX itself or the changes needed to your Babel / TypeScript build configuration. âš ï¸_

## Getting started

1. Update `mobx` to the latest version of MobX 4/5 and solve any deprecation messages.
2. Update `mobx` to version 6.
3. If you are upgrading from MobX 4, and you will need to support Internet Explorer / React Native without proxies, call `import { configure } from "mobx"; configure({ useProxies: "never" })` at the initialization of your application, to back-out of the Proxy implementation. Check out the [Proxy Support](configuration.md#proxy-support) section for more details.
4. For babel users:
    - If you are using Babel and have class-properties enabled, disable the legacy loose field support: `["@babel/plugin-proposal-class-properties", { "loose": false }]`
    - (Optional) In MobX 6 decorators have become opt-in. If you no longer wish to use decorators, remove `plugin-proposal-decorators` from your babel configuration and dependencies. Check out the [Enabling decorators {ğŸš€}](enabling-decorators.md) section for more details.
5. For Typescript users:
    - Add the flag `"useDefineForClassFields": true` to your compiler config.
    - (Optional) In MobX 6 decorators have become opt-in. If you no longer wish to use decorators, remove / disable the `experimentalDecorators` configuration from your TypeScript config. Check out the [Enabling decorators {ğŸš€}](enabling-decorators.md) section for more details.
6. The MobX default configuration has become more strict. We recommend to adopt the new defaults after completing the upgrade, check out the [Configuration {ğŸš€}](configuration.md) section. During migration, we recommend to configure MobX in the same way as it would be in v4/v5 out of the box: `import {configure} from "mobx"; configure({ enforceActions: "never" });`. After finishing the entire migration process and validating that your project works as expected, consider enabling the flags `computedRequiresReaction`, `reactionRequiresObservable` and `observableRequiresReaction` and `enforceActions: "observed"` to write more idiomatic MobX code.

## Upgrading classes to use `makeObservable`

Due to standardized JavaScript limitations in how class fields are constructed, it is no longer possible for MobX to alter the behavior of class fields by means of decorators or the `decorate` utility. Instead, fields have to be made observable by the `constructor`. This can be done in three different ways:

1. Remove all decorators and call `makeObservable` in the `constructor` and explicitly define which field should be made observable using which decorator. For example: `makeObservable(this, { count: observable, tick: action, elapsedTime: computed })` (note that the second argument corresponds to what would be passed to `decorate`). This is the recommended approach if you want to drop decorators in your code base, and the project isn't yet too big.
2. Leave all the decorators and call `makeObservable(this)` in the `constructor`. This will pick up the metadata generated by the decorators. This is the recommended way if you want to limit the impact of a MobX 6 migration.
3. Remove decorators and use `makeAutoObservable(this)` in the class `constructor`'s.

Check out [makeObservable / makeAutoObservable](observable-state.md) for more details.

Some specifics to note:

1. Using `makeObservable` / `makeAutoObservable` needs to be done in every class definition that declares MobX based members. So if a sub-class and super-class both introduce observable members, they will both have to call `makeObservable`.
2. `makeAutoObservable` will mark methods using a new decorator [`autoAction`](observable-state.md#autoAction), that will apply `action` only if it is not in a derivation context. This makes it safe to call automatically decorated methods also from computed properties.

Migrating a large code base with lots of classes might be daunting. But no worries, there is a code-mod available that will automate the above process!!

## Upgrading your code with the `mobx-undecorate` codemod

If you are an existing MobX user you have code that uses a lot of decorators, or the equivalent calls to `decorate`.

The [`mobx-undecorate`](https://www.npmjs.com/package/mobx-undecorate) package provides a codemod that can automatically update your code to be conformant to MobX 6. There is no need to install it; instead you download and execute it using the [`npx`](https://www.npmjs.com/package/npx) tool which you do need to install if you haven't already.

To get rid of all uses of MobX decorators and replace them with the equivalent `makeObservable` calls, go to the directory that contains your source code and run:

```shell
npx mobx-undecorate
```

MobX will continue to support decorators -- so if you want to retain them
and only introduce `makeObservable(this)` where required, you can use the `--keepDecorators` option:

```shell
npx mobx-undecorate --keepDecorators
```

See [documentation](https://www.npmjs.com/package/mobx-undecorate) for more options.

### Limitations of `mobx-undecorate`

The `mobx-undecorate` command has to introduce a constructor in classes that do not yet have one. If base class of the constructor expects arguments, the codemod cannot introduce these arguments for the subclass being upgraded, and the `super` call won't pass them either. You have to fix these manually.
The tool will generate a `// TODO: [mobx-undecorate]` comment in these cases.

We do have a special case for React class components to do the right thing and
pass along `props` to the superclass.

## Functions are auto-converted

Functions that become part of a deep observable structure are automatically converted to [`autoAction`](observable-state.md#autoAction) or to [`flow`](actions.html#using-flow-instead-of-async--await-) if it's a generator function. See [inference rules](observable-state.html#makeautoobservable) for details.
This means that the original function reference is not preserved - in the same spirit as the original array/object/set/map reference is lost when converted to observable. [This can be surprising in some situations](https://github.com/mobxjs/mobx/issues/3616).
If this behavior is not desired use [`observable.shallow`](observable-state.html#available-annotations) / [`observable.ref`](observable-state.html#available-annotations) / [`false`](observable-state.html#available-annotations) / [`deep: flase`](observable-state.html#options-) to prevent the conversion process or make sure the function is already an `action` as shown in the issue.



================================================
FILE: docs/mobx-utils.md
================================================
---
title: MobX-utils
sidebar_label: MobX-utils {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# MobX-utils {ğŸš€}

[MobX-utils](https://github.com/mobxjs/mobx-utils) provides an extensive series of additional utility functions, observables and common patterns for MobX.



================================================
FILE: docs/observable-state.md
================================================
---
title: Creating observable state
sidebar_label: Observable state
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Creating observable state

Properties, entire objects, arrays, Maps and Sets can all be made observable.
The basics of making objects observable is specifying an annotation per property using `makeObservable`.
The most important annotations are:

-   [`observable`](#observable) defines a trackable field that stores the state.
-   [`action`](actions.md) marks a method as an action that will modify the state.
-   [`computed`](computeds.md) marks a getter that will derive new facts from the state and cache its output.

## `makeObservable`

Usage:

-   `makeObservable(target, annotations?, options?)`

This function can be used to make _existing_ object properties observable. Any JavaScript object (including class instances) can be passed into `target`.
Typically `makeObservable` is used in the constructor of a class, and its first argument is `this`.
The `annotations` argument maps [annotations](#available-annotations) to each member. Only annotated members are affected.

Alternatively, decorators like `@observable` can be used on class members instead of calling `makeObservable` in the constructor.

Methods that derive information and take arguments (for example `findUsersOlderThan(age: number): User[]`) can not be annotated as `computed` â€“ their read operations will still be tracked when they are called from a reaction, but their output won't be memoized to avoid memory leaks. To memoize such methods you can use [MobX-utils computedFn {ğŸš€}](https://github.com/mobxjs/mobx-utils#computedfn) instead.

[Subclassing is supported with some limitations](subclassing.md) by using the `override` annotation (see the example [here](subclassing.md)).

<!--DOCUSAURUS_CODE_TABS-->
<!--class + makeObservable-->

```javascript
import { makeObservable, observable, computed, action, flow } from "mobx"

class Doubler {
    value

    constructor(value) {
        makeObservable(this, {
            value: observable,
            double: computed,
            increment: action,
            fetch: flow
        })
        this.value = value
    }

    get double() {
        return this.value * 2
    }

    increment() {
        this.value++
    }

    *fetch() {
        const response = yield fetch("/api/value")
        this.value = response.json()
    }
}
```

**All annotated** fields are **non-configurable**.<br>
**All non-observable** (stateless) fields (`action`, `flow`) are **non-writable**.

<!--class + decorators-->

When using modern decorators, there is no need to call `makeObservable`, below is what a decorator based class looks like.
Note that the `@observable` annotation should always be used in combination with the `accessor` keyword.

```javascript
import { observable, computed, action, flow } from "mobx"

class Doubler {
    @observable accessor value

    constructor(value) {
        this.value = value
    }

    @computed
    get double() {
        return this.value * 2
    }

    @action
    increment() {
        this.value++
    }

    @flow
    *fetch() {
        const response = yield fetch("/api/value")
        this.value = response.json()
    }
}
```

<!--factory function + makeAutoObservable-->

```javascript
import { makeAutoObservable } from "mobx"

function createDoubler(value) {
    return makeAutoObservable({
        value,
        get double() {
            return this.value * 2
        },
        increment() {
            this.value++
        }
    })
}
```

Note that classes can leverage `makeAutoObservable` as well.
The difference in the examples just demonstrate how MobX can be applied to different programming styles.

<!--observable-->

```javascript
import { observable } from "mobx"

const todosById = observable({
    "TODO-123": {
        title: "find a decent task management system",
        done: false
    }
})

todosById["TODO-456"] = {
    title: "close all tickets older than two weeks",
    done: true
}

const tags = observable(["high prio", "medium prio", "low prio"])
tags.push("prio: for fun")
```

In contrast to the first example with `makeObservable`, `observable` supports adding (and removing) _fields_ to an object.
This makes `observable` great for collections like dynamically keyed objects, arrays, Maps and Sets.

<!--class + decorators (legacy)-->

To use legacy decorators, `makeObservable(this)` should be called in the constructor to make sure decorators work.

```javascript
import { observable, computed, action, flow } from "mobx"

class Doubler {
    @observable value

    constructor(value) {
        makeObservable(this)
        this.value = value
    }

    @computed
    get double() {
        return this.value * 2
    }

    @action
    increment() {
        this.value++
    }

    @flow
    *fetch() {
        const response = yield fetch("/api/value")
        this.value = response.json()
    }
}
```

<!--END_DOCUSAURUS_CODE_TABS-->

## `makeAutoObservable`

Usage:

-   `makeAutoObservable(target, overrides?, options?)`

`makeAutoObservable` is like `makeObservable` on steroids, as it infers all the properties by default. You can however use the `overrides` parameter to override the default behavior with specific annotations â€”
in particular `false` can be used to exclude a property or method from being processed entirely.
Check out the code above for an example.

The `makeAutoObservable` function can be more compact and easier to maintain than using `makeObservable`, since new members don't have to be mentioned explicitly.
However, `makeAutoObservable` cannot be used on classes that have super or are [subclassed](subclassing.md).

Inference rules:

-   All _own_ properties become `observable`.
-   All `getters` become `computed`.
-   All `setters` become `action`.
-   All _functions_ become [`autoAction`](#autoAction).
-   All _generator_ functions become `flow`. (Note that generator functions are not detectable in some transpiler configurations, if flow doesn't work as expected, make sure to specify `flow` explicitly.)
-   Members marked with `false` in the `overrides` argument will not be annotated. For example, using it for read only fields such as identifiers.

## `observable`

Usage:

-   `observable(source, overrides?, options?)`
-   `@observable accessor` _(field decorator)_

The `observable` annotation can also be called as a function to make an entire object observable at once.
The `source` object will be cloned and all members will be made observable, similar to how it would be done by `makeAutoObservable`.
Likewise, an `overrides` map can be provided to specify the annotations of specific members.
Check out the above code block for an example.

The object returned by `observable` will be a Proxy, which means that properties that are added later to the object will be picked up and made observable as well (except when [proxy usage](configuration.md#proxy-support) is disabled).

The `observable` method can also be called with collections types like [arrays](api.md#observablearray), [Maps](api.md#observablemap) and [Sets](api.md#observableset). Those will be cloned as well and converted into their observable counterparts.

> Tip: as holds for JavaScript in general, don't use observable plain objects to create a keyed collection (for example to store a mapping from a user's UUID to user object), use maps instead. Object descriptors are aggressively cached by MobX, so if property names are unstable, this might result in memory leaks.

<details id="observable-array"><summary>**Example:** observable array<a href="#observable-array" class="tip-anchor"></a></summary>

The following example creates an observable and observes it using [`autorun`](reactions.md#autorun).
Working with Map and Set collections works similarly.

```javascript
import { observable, autorun } from "mobx"

const todos = observable([
    { title: "Spoil tea", completed: true },
    { title: "Make coffee", completed: false }
])

autorun(() => {
    console.log(
        "Remaining:",
        todos
            .filter(todo => !todo.completed)
            .map(todo => todo.title)
            .join(", ")
    )
})
// Prints: 'Remaining: Make coffee'

todos[0].completed = false
// Prints: 'Remaining: Spoil tea, Make coffee'

todos[2] = { title: "Take a nap", completed: false }
// Prints: 'Remaining: Spoil tea, Make coffee, Take a nap'

todos.shift()
// Prints: 'Remaining: Make coffee, Take a nap'
```

Observable arrays have some additional nifty utility functions:

-   `clear()` removes all current entries from the array.
-   `replace(newItems)` replaces all existing entries in the array with new ones.
-   `remove(value)` removes a single item by value from the array. Returns `true` if the item was found and removed.

</details>

<details id="non-convertibles"><summary>**Note:** primitives and class instances are never converted to observables<a href="#non-convertibles" class="tip-anchor"></a></summary>

Primitive values cannot be made observable by MobX since they are immutable in JavaScript (but they can be [boxed](api.md#observablebox)).
Although there is typically no use for this mechanism outside libraries.

Class instances will never be made observable automatically by passing them to `observable` or assigning them to an `observable` property.
Making class members observable is considered the responsibility of the class constructor.

</details>

<details id="avoid-proxies"><summary>{ğŸš€} **Tip:** observable (proxied) versus makeObservable (unproxied)<a href="#avoid-proxies" class="tip-anchor"></a></summary>

The primary difference between `make(Auto)Observable` and `observable` is that the first one modifies the object you are passing in as first argument, while `observable` creates a _clone_ that is made observable.

The second difference is that `observable` creates a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object, to be able to trap future property additions in case you use the object as a dynamic lookup map.
If the object you want to make observable has a regular structure where all members are known up-front, we recommend to use `makeObservable` as non proxied objects are a little faster, and they are easier to inspect in the debugger and `console.log`.

Because of that, `make(Auto)Observable` is the recommended API to use in factory functions.
Note that it is possible to pass `{ proxy: false }` as an option to `observable` to get a non proxied clone.

</details>

## Available annotations

| Annotation                                 | Description                                                                                                                                                                                                                                                                                                                                       |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `observable`<br/>`observable.deep`         | Defines a trackable field that stores state. If possible, any value assigned to `observable` is automatically converted to (deep) `observable`, [`autoAction`](#autoAction) or `flow` based on it's type. Only `plain object`, `array`, `Map`, `Set`, `function`, `generator function` are convertible. Class instances and others are untouched. |
| `observable.ref`                           | Like `observable`, but only reassignments will be tracked. The assigned values are completely ignored and will NOT be automatically converted to `observable`/[`autoAction`](#autoAction)/`flow`. For example, use this if you intend to store immutable data in an observable field.                                                             |
| `observable.shallow`                       | Like `observable.ref` but for collections. Any collection assigned will be made observable, but the contents of the collection itself won't become observable.                                                                                                                                                                                    |
| `observable.struct`                        | Like `observable`, except that any assigned value that is structurally equal to the current value will be ignored.                                                                                                                                                                                                                                |
| `action`                                   | Mark a method as an action that will modify the state. Check out [actions](actions.md) for more details. Non-writable.                                                                                                                                                                                                                            |
| `action.bound`                             | Like action, but will also bind the action to the instance so that `this` will always be set. Non-writable.                                                                                                                                                                                                                                       |
| `computed`                                 | Can be used on a [getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) to declare it as a derived value that can be cached. Check out [computeds](computeds.md) for more details.                                                                                                                             |
| `computed.struct`                          | Like `computed`, except that if after recomputing the result is structurally equal to the previous result, no observers will be notified.                                                                                                                                                                                                         |
| `true`                                     | Infer the best annotation. Check out [makeAutoObservable](#makeautoobservable) for more details.                                                                                                                                                                                                                                                  |
| `false`                                    | Explicitly do not annotate this property.                                                                                                                                                                                                                                                                                                         |
| `flow`                                     | Creates a `flow` to manage asynchronous processes. Check out [flow](actions.md#using-flow-instead-of-async--await-) for more details. Note that the inferred return type in TypeScript might be off. Non-writable.                                                                                                                                |
| `flow.bound`                               | Like flow, but will also bind the flow to the instance so that `this` will always be set. Non-writable.                                                                                                                                                                                                                                           |
| `override`                                 | [Applicable to inherited `action`, `flow`, `computed`, `action.bound` overridden by subclass](subclassing.md).                                                                                                                                                                                                                                    |
| <span id="autoAction"></span> `autoAction` | Should not be used explicitly, but is used under the hood by `makeAutoObservable` to mark methods that can act as action or derivation, based on their calling context. It will be determined at runtime if the function is a derivation or action.                                                                                               |

## Limitations

1. `make(Auto)Observable` only supports properties that are already defined. Make sure your [**compiler configuration** is correct](installation.md#use-spec-compliant-transpilation-for-class-properties), or as work-around, that a value is assigned to all properties before using `make(Auto)Observable`. Without correct configuration, fields that are declared but not initialized (like in `class X { y; }`) will not be picked up correctly.
1. `makeObservable` can only annotate properties declared by its own class definition. If a sub- or superclass introduces observable fields, it will have to call `makeObservable` for those properties itself.
1. `options` argument can be provided only once. Passed `options` are _"sticky"_ and can NOT be changed later (eg. in [subclass](subclassing.md)).
1. **Every field can be annotated only once** (except for `override`). The field annotation or configuration can't change in [subclass](subclassing.md).
1. **All annotated** fields of non-plain objects (**classes**) are **non-configurable**.<br>
   [Can be disabled with `configure({ safeDescriptors: false })` {ğŸš€â˜£ï¸} ](configuration.md#safedescriptors-boolean).
1. **All non-observable** (stateless) fields (`action`, `flow`) are **non-writable**.<br>
   [Can be disabled with `configure({ safeDescriptors: false })` {ğŸš€â˜£ï¸} ](configuration.md#safedescriptors-boolean).
1. [Only **`action`, `computed`, `flow`, `action.bound`** defined **on prototype** can be **overridden** by subclass](subclassing.md).
1. By default _TypeScript_ will not allow you to annotate **private** fields. This can be overcome by explicitly passing the relevant private fields as generic argument, like this: `makeObservable<MyStore, "privateField" | "privateField2">(this, { privateField: observable, privateField2: observable })`
1. **Calling `make(Auto)Observable`** and providing annotations must be done **unconditionally**, as this makes it possible to cache the inference results.
1. **Modifying prototypes** after **`make(Auto)Observable`** has been called is **not supported**.
1. _EcmaScript_ **private** fields (**`#field`**) are **not supported** by `make(Auto)Observable`. Use auto-accessor + Stage-3 decorators (`@observable accessor #field`) syntax instead. Otherwise, when using _TypeScript_, it is recommended to use the `private` modifier.
1. **Mixing annotations and decorators** within single inheritance chain is **not supported** - eg. you can't use decorators for superclass and annotations for subclass.
1. `makeObservable`,`extendObservable` cannot be used on other builtin observable types (`ObservableMap`, `ObservableSet`, `ObservableArray`, etc)
1. `makeObservable(Object.create(prototype))` copies properties from `prototype` to created object and makes them `observable`. This behavior is wrong, unexpected and therefore **deprecated** and will likely change in future versions. Don't rely on it.

## Options {ğŸš€}

The above APIs take an optional `options` argument which is an object that supports the following options:

-   **`autoBind: true`** uses `action.bound`/`flow.bound` by default, rather than `action`/`flow`. Does not affect explicitely annotated members.
-   **`deep: false`** uses `observable.ref` by default, rather than `observable`. Does not affect explicitely annotated members.
-   **`name: <string>`** gives the object a debug name that is printed in error messages and reflection APIs.
-   **`proxy: false`** forces `observable(thing)` to use non-[**proxy**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) implementation. This is a good option if the shape of the object will not change over time, as non-proxied objects are easier to debug and faster. This option is **not** available for `make(Auto)Observable`, see [avoiding proxies](#avoid-proxies).

<details id="one-options-per-target"><summary>**Note:** options are *sticky* and can be provided only once<a href="#one-options-per-target" class="tip-anchor"></a></summary>
`options` argument can be provided only for `target` that is NOT observable yet.<br>
It is NOT possible to change options once the observable object was initialized.<br>
Options are stored on target and respected by subsequent `makeObservable`/`extendObservable` calls.<br>
You can't pass different options in [subclass](subclassing.md).
</details>

## Converting observables back to vanilla JavaScript collections

Sometimes it is necessary to convert observable data structures back to their vanilla counterparts.
For example when passing observable objects to a React component that can't track observables, or to obtain a clone that should not be further mutated.

To convert a collection shallowly, the usual JavaScript mechanisms work:

```javascript
const plainObject = { ...observableObject }
const plainArray = observableArray.slice()
const plainMap = new Map(observableMap)
```

To convert a data tree recursively to plain objects, the [`toJS`](api.md#tojs) utility can be used.
For classes, it is recommended to implement a `toJSON()` method, as it will be picked up by `JSON.stringify`.

## A short note on classes

So far most examples above have been leaning towards the class syntax.
MobX is in principle unopinionated about this, and there are probably just as many MobX users that use plain objects.
However, a slight benefit of classes is that they have more easily discoverable APIs, e.g. TypeScript.
Also, `instanceof` checks are really powerful for type inference, and class instances aren't wrapped in `Proxy` objects, giving them a better experience in debuggers.
Finally, classes benefit from a lot of engine optimizations, since their shape is predictable, and methods are shared on the prototype.
But heavy inheritance patterns can easily become foot-guns, so if you use classes, keep them simple.
So, even though there is a slight preference to use classes, we definitely want to encourage you to deviate from this style if that suits you better.



================================================
FILE: docs/react-integration.md
================================================
---
title: React integration
sidebar_label: React integration
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# React integration

This documentation outlines how to manually apply observation to React components. However, by using the [mobx-react-observer](https://github.com/christianalfoni/mobx-react-observer) Babel/SWC plugin, you can automatically handle observation without manual intervention. Still, understanding how MobX observation integrates with React components remains valuable, even when leveraging automated solutions.

```javascript
import { observer } from "mobx-react-lite" // Or "mobx-react".

const MyComponent = observer(props => ReactElement)
```

While MobX works independently from React, they are most commonly used together. In [The gist of MobX](the-gist-of-mobx.md) you have already seen the most important part of this integration: the `observer` [HoC](https://reactjs.org/docs/higher-order-components.html) that you can wrap around a React component.

`observer` is provided by a separate React bindings package you choose [during installation](installation.md#installation). In this example, we're going to use the more lightweight [`mobx-react-lite` package](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite).

```javascript
import React from "react"
import ReactDOM from "react-dom"
import { makeAutoObservable } from "mobx"
import { observer } from "mobx-react-lite"

class Timer {
    secondsPassed = 0

    constructor() {
        makeAutoObservable(this)
    }

    increaseTimer() {
        this.secondsPassed += 1
    }
}

const myTimer = new Timer()

// A function component wrapped with `observer` will react
// to any future change in an observable it used before.
const TimerView = observer(({ timer }) => <span>Seconds passed: {timer.secondsPassed}</span>)

ReactDOM.render(<TimerView timer={myTimer} />, document.body)

setInterval(() => {
    myTimer.increaseTimer()
}, 1000)
```

**Hint:** you can play with the above example yourself on [CodeSandbox](https://codesandbox.io/s/minimal-observer-p9ti4?file=/src/index.tsx).

The `observer` HoC automatically subscribes React components to _any observables_ that are used _during rendering_.
As a result, components will automatically re-render when relevant observables change.
It also makes sure that components don't re-render when there are _no relevant_ changes.
So, observables that are accessible by the component, but not actually read, won't ever cause a re-render.

In practice this makes MobX applications very well optimized out of the box and they typically don't need any additional code to prevent excessive rendering.

For `observer` to work, it doesn't matter _how_ the observables arrive in the component, only that they are read.
Reading observables deeply is fine, complex expression like `todos[0].author.displayName` work out of the box.
This makes the subscription mechanism much more precise and efficient compared to other frameworks in which data dependencies have to be declared explicitly or be pre-computed (e.g. selectors).

## Local and external state

There is great flexibility in how state is organized, since it doesn't matter (technically that is) which observables we read or where observables originated from.
The examples below demonstrate different patterns on how external and local observable state can be used in components wrapped with `observer`.

### Using external state in `observer` components

<!--DOCUSAURUS_CODE_TABS-->
<!--using props-->

Observables can be passed into components as props (as in the example above):

```javascript
import { observer } from "mobx-react-lite"

const myTimer = new Timer() // See the Timer definition above.

const TimerView = observer(({ timer }) => <span>Seconds passed: {timer.secondsPassed}</span>)

// Pass myTimer as a prop.
ReactDOM.render(<TimerView timer={myTimer} />, document.body)
```

<!--using global variables-->

Since it doesn't matter _how_ we got the reference to an observable, we can consume
observables from outer scopes directly (including from imports, etc.):

```javascript
const myTimer = new Timer() // See the Timer definition above.

// No props, `myTimer` is directly consumed from the closure.
const TimerView = observer(() => <span>Seconds passed: {myTimer.secondsPassed}</span>)

ReactDOM.render(<TimerView />, document.body)
```

Using observables directly works very well, but since this typically introduces module state, this pattern might complicate unit testing. Instead, we recommend using React Context instead.

<!--using React context-->

[React Context](https://reactjs.org/docs/context.html) is a great mechanism to share observables with an entire subtree:

```javascript
import {observer} from 'mobx-react-lite'
import {createContext, useContext} from "react"

const TimerContext = createContext<Timer>()

const TimerView = observer(() => {
    // Grab the timer from the context.
    const timer = useContext(TimerContext) // See the Timer definition above.
    return (
        <span>Seconds passed: {timer.secondsPassed}</span>
    )
})

ReactDOM.render(
    <TimerContext.Provider value={new Timer()}>
        <TimerView />
    </TimerContext.Provider>,
    document.body
)
```

Note that we don't recommend ever replacing the `value` of a `Provider` with a different one. Using MobX, there should be no need for that, since the observable that is shared can be updated itself.

<!--END_DOCUSAURUS_CODE_TABS-->

### Using local observable state in `observer` components

Since observables used by `observer` can come from anywhere, they can be local state as well.
Again, different options are available for us.

<!--DOCUSAURUS_CODE_TABS-->
<!--`useState` with observable class-->

The simplest way to use local observable state is to store a reference to an observable class with `useState`.
Note that, since we typically don't want to replace the reference, we totally ignore the updater function returned by `useState`:

```javascript
import { observer } from "mobx-react-lite"
import { useState } from "react"

const TimerView = observer(() => {
    const [timer] = useState(() => new Timer()) // See the Timer definition above.
    return <span>Seconds passed: {timer.secondsPassed}</span>
})

ReactDOM.render(<TimerView />, document.body)
```

If you want to automatically update the timer like we did in the original example,
`useEffect` could be used in typical React fashion:

```javascript
useEffect(() => {
    const handle = setInterval(() => {
        timer.increaseTimer()
    }, 1000)
    return () => {
        clearInterval(handle)
    }
}, [timer])
```

<!--`useState` with local observable object-->

As stated before, instead of using classes, it is possible to directly create observable objects.
We can leverage [observable](observable-state.md#observable) for that:

```javascript
import { observer } from "mobx-react-lite"
import { observable } from "mobx"
import { useState } from "react"

const TimerView = observer(() => {
    const [timer] = useState(() =>
        observable({
            secondsPassed: 0,
            increaseTimer() {
                this.secondsPassed++
            }
        })
    )
    return <span>Seconds passed: {timer.secondsPassed}</span>
})

ReactDOM.render(<TimerView />, document.body)
```

<!--`useLocalObservable` hook-->

The combination `const [store] = useState(() => observable({ /* something */}))` is
quite common. To make this pattern simpler the [`useLocalObservable`](https://github.com/mobxjs/mobx-react#uselocalobservable-hook) hook is exposed from `mobx-react-lite` package, making it possible to simplify the earlier example to:

```javascript
import { observer, useLocalObservable } from "mobx-react-lite"

const TimerView = observer(() => {
    const timer = useLocalObservable(() => ({
        secondsPassed: 0,
        increaseTimer() {
            this.secondsPassed++
        }
    }))
    return <span>Seconds passed: {timer.secondsPassed}</span>
})

ReactDOM.render(<TimerView />, document.body)
```

<!--END_DOCUSAURUS_CODE_TABS-->

### You might not need locally observable state

In general, we recommend to not resort to MobX observables for local component state too quickly, as this can theoretically lock you out of some features of React's Suspense mechanism.
As a rule of thumb, use MobX observables when the state captures domain data that is shared among components (including children). Such as todo items, users, bookings, etc.

State that only captures UI state, like loading state, selections, etc, might be better served by the [`useState` hook](https://reactjs.org/docs/hooks-state.html), since this will allow you to leverage React suspense features in the future.

Using observables inside React components adds value as soon as they are either 1) deep, 2) have computed values or 3) are shared with other `observer` components.

## Always read observables inside `observer` components

You might be wondering, when do I apply `observer`? The rule of thumb is: _apply `observer` to all components that read observable data_.

`observer` only enhances the component you are decorating, not the components called by it. So usually all your components should be wrapped by `observer`. Don't worry, this is not inefficient. On the contrary, more `observer` components make rendering more efficient as updates become more fine-grained.

### Tip: Grab values from objects as late as possible

`observer` works best if you pass object references around as long as possible, and only read their properties inside the `observer` based components that are going to render them into the DOM / low-level components.
In other words, `observer` reacts to the fact that you 'dereference' a value from an object.

In the above example, the `TimerView` component would **not** react to future changes if it was defined
as follows, because the `.secondsPassed` is not read inside the `observer` component, but outside, and is hence _not_ tracked:

```javascript
const TimerView = observer(({ secondsPassed }) => <span>Seconds passed: {secondsPassed}</span>)

React.render(<TimerView secondsPassed={myTimer.secondsPassed} />, document.body)
```

Note that this is a different mindset from other libraries like `react-redux`, where it is a good practice to dereference early and pass primitives down, to better leverage memoization.
If the problem is not entirely clear, make sure to check out the [Understanding reactivity](understanding-reactivity.md) section.

### Don't pass observables into components that aren't `observer`

Components wrapped with `observer` _only_ subscribe to observables used during their _own_ rendering of the component. So if observable objects / arrays / maps are passed to child components, those have to be wrapped with `observer` as well.
This is also true for any callback based components.

If you want to pass observables to a component that isn't an `observer`, either because it is a third-party component, or because you want to keep that component MobX agnostic, you will have to [convert the observables to plain JavaScript values or structures](observable-state.md#converting-observables-back-to-vanilla-javascript-collections) before passing them on.

To elaborate on the above,
take the following example observable `todo` object, a `TodoView` component (observer) and an imaginary `GridRow` component that takes a column / value mapping, but which isn't an `observer`:

```javascript
class Todo {
    title = "test"
    done = true

    constructor() {
        makeAutoObservable(this)
    }
}

const TodoView = observer(({ todo }: { todo: Todo }) =>
   // WRONG: GridRow won't pick up changes in todo.title / todo.done
   //        since it isn't an observer.
   return <GridRow data={todo} />

   // CORRECT: let `TodoView` detect relevant changes in `todo`,
   //          and pass plain data down.
   return <GridRow data={{
       title: todo.title,
       done: todo.done
   }} />

   // CORRECT: using `toJS` works as well, but being explicit is typically better.
   return <GridRow data={toJS(todo)} />
)
```

### Callback components might require `<Observer>`

Imagine the same example, where `GridRow` takes an `onRender` callback instead.
Since `onRender` is part of the rendering cycle of `GridRow`, rather than `TodoView`'s render (even though that is where it syntactically appears), we have to make sure that the callback component uses an `observer` component.
Or, we can create an in-line anonymous observer using [`<Observer />`](https://github.com/mobxjs/mobx-react#observer):

```javascript
const TodoView = observer(({ todo }: { todo: Todo }) => {
    // WRONG: GridRow.onRender won't pick up changes in todo.title / todo.done
    //        since it isn't an observer.
    return <GridRow onRender={() => <td>{todo.title}</td>} />

    // CORRECT: wrap the callback rendering in Observer to be able to detect changes.
    return <GridRow onRender={() => <Observer>{() => <td>{todo.title}</td>}</Observer>} />
})
```

## Tips

<details id="static-rendering"><summary>Server Side Rendering (SSR)<a href="#static-rendering" class="tip-anchor"></a></summary>
If `observer` is used in server side rendering context; make sure to call `enableStaticRendering(true)`, so that `observer` won't subscribe to any observables used, and no GC problems are introduced.
</details>

<details id="react-vs-lite"><summary>**Note:** mobx-react vs. mobx-react-lite<a href="#react-vs-lite" class="tip-anchor"></a></summary>
In this documentation we used `mobx-react-lite` as default.
[mobx-react](https://github.com/mobxjs/mobx-react/) is it's big brother, which uses `mobx-react-lite` under the hood.
It offers a few more features which are typically not needed anymore in greenfield projects. The additional things offered by mobx-react:

1. Support for React class components.
1. `Provider` and `inject`. MobX's own React.createContext predecessor which is not needed anymore.
1. Observable specific `propTypes`.

Note that `mobx-react` fully repackages and re-exports `mobx-react-lite`, including functional component support.
If you use `mobx-react`, there is no need to add `mobx-react-lite` as a dependency or import from it anywhere.

</details>

<details id="observer-vs-memo"><summary>**Note:** `observer` or `React.memo`?<a href="#observer-vs-memo" class="tip-anchor"></a></summary>
`observer` automatically applies `memo`, so `observer` components never need to be wrapped in `memo`.
`memo` can be applied safely to observer components because mutations (deeply) inside the props will be picked up by `observer` anyway if relevant.
</details>

<details id="class-comp"><summary>**Tip:** `observer` for class based React components<a href="#class-comp" class="tip-anchor"></a>
</summary>
As stated above, class based components are only supported through `mobx-react`, and not `mobx-react-lite`.
Briefly, you can wrap class-based components in `observer` just like
you can wrap function components:

```javascript
import React from "React"

const TimerView = observer(
    class TimerView extends React.Component {
        render() {
            const { timer } = this.props
            return <span>Seconds passed: {timer.secondsPassed} </span>
        }
    }
)
```

Check out [mobx-react docs](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react#class-components) for more information.

</details>

<details id="displayname"><summary>**Tip:** nice component names in React DevTools<a href="#displayname" class="tip-anchor"></a>
</summary>
[React DevTools](https://reactjs.org/blog/2019/08/15/new-react-devtools.html) uses the display name information of components to properly display the component hierarchy.

If you use:

```javascript
export const MyComponent = observer(props => <div>hi</div>)
```

then no display name will be visible in the DevTools.

![devtools-noname](assets/devtools-noDisplayName.png)

The following approaches can be used to fix this:

-   use `function` with a name instead of an arrow function. `mobx-react` infers component name from the function name:

    ```javascript
    export const MyComponent = observer(function MyComponent(props) {
        return <div>hi</div>
    })
    ```

-   Transpilers (like Babel or TypeScript) infer component name from the variable name:

    ```javascript
    const _MyComponent = props => <div>hi</div>
    export const MyComponent = observer(_MyComponent)
    ```

-   Infer from the variable name again, using default export:

    ```javascript
    const MyComponent = props => <div>hi</div>
    export default observer(MyComponent)
    ```

-   [**Broken**] Set `displayName` explicitly:

    ```javascript
    export const MyComponent = observer(props => <div>hi</div>)
    MyComponent.displayName = "MyComponent"
    ```

    This is broken in React 16 at the time of writing; mobx-react `observer` uses a React.memo and runs into this bug: https://github.com/facebook/react/issues/18026, but it will be fixed in React 17.

Now you can see component names:

![devtools-withname](assets/devtools-withDisplayName.png)

</details>

<details id="wrap-order"><summary>{ğŸš€} **Tip:** when combining `observer` with other higher-order-components, apply `observer` first<a href="#wrap-order" class="tip-anchor"></a></summary>

When `observer` needs to be combined with other decorators or higher-order-components, make sure that `observer` is the innermost (first applied) decorator;
otherwise it might do nothing at all.

</details>

<details id="computed-props"><summary>{ğŸš€} **Tip:** deriving computeds from props<a href="#computed-props" class="tip-anchor"></a></summary>
In some cases the computed values of your local observables might depend on some of the props your component receives.
However, the set of props that a React component receives is in itself not observable, so changes to the props won't be reflected in any computed values. You have to manually update local observable state in order to properly derive computed values from latest data.

```javascript
import { observer, useLocalObservable } from "mobx-react-lite"
import { useEffect } from "react"

const TimerView = observer(({ offset = 0 }) => {
    const timer = useLocalObservable(() => ({
        offset, // The initial offset value
        secondsPassed: 0,
        increaseTimer() {
            this.secondsPassed++
        },
        get offsetTime() {
            return this.secondsPassed - this.offset // Not 'offset' from 'props'!
        }
    }))

    useEffect(() => {
        // Sync the offset from 'props' into the observable 'timer'
        timer.offset = offset
    }, [offset])

    // Effect to set up a timer, only for demo purposes.
    useEffect(() => {
        const handle = setInterval(timer.increaseTimer, 1000)
        return () => {
            clearInterval(handle)
        }
    }, [])

    return <span>Seconds passed: {timer.offsetTime}</span>
})

ReactDOM.render(<TimerView />, document.body)
```

In practice you will rarely need this pattern, since
`return <span>Seconds passed: {timer.secondsPassed - offset}</span>`
is a much simpler, albeit slightly less efficient solution.

</details>

<details id="useeffect"><summary>{ğŸš€} **Tip:** useEffect and observables<a href="#useeffect" class="tip-anchor"></a></summary>

`useEffect` can be used to set up side effects that need to happen, and which are bound to the life-cycle of the React component.
Using `useEffect` requires specifying dependencies.
With MobX that isn't really needed, since MobX has already a way to automatically determine the dependencies of an effect, `autorun`.
Combining `autorun` and coupling it to the life-cycle of the component using `useEffect` is luckily straightforward:

```javascript
import { observer, useLocalObservable, useAsObservableSource } from "mobx-react-lite"
import { useState } from "react"

const TimerView = observer(() => {
    const timer = useLocalObservable(() => ({
        secondsPassed: 0,
        increaseTimer() {
            this.secondsPassed++
        }
    }))

    // Effect that triggers upon observable changes.
    useEffect(
        () =>
            autorun(() => {
                if (timer.secondsPassed > 60) alert("Still there. It's a minute already?!!")
            }),
        []
    )

    // Effect to set up a timer, only for demo purposes.
    useEffect(() => {
        const handle = setInterval(timer.increaseTimer, 1000)
        return () => {
            clearInterval(handle)
        }
    }, [])

    return <span>Seconds passed: {timer.secondsPassed}</span>
})

ReactDOM.render(<TimerView />, document.body)
```

Note that we return the disposer created by `autorun` from our effect function.
This is important, since it makes sure the `autorun` gets cleaned up once the component unmounts!

The dependency array can typically be left empty, unless a non-observable value should trigger a re-run of the autorun, in which case you will need to add it there.
To make your linter happy, you can define `timer` (in the above example) as a dependency.
That is safe and has no further effect, since the reference will never actually change.

If you'd rather explicitly define which observables should trigger the effect, use `reaction` instead of `autorun`, beyond that the pattern remains identical.

</details>

### How can I further optimize my React components?

Check out the [React optimizations {ğŸš€}](react-optimizations.md) section.

## Troubleshooting

Help! My component isn't re-rendering...

1. Make sure you didn't forget `observer` (yes, this is the most common mistake).
1. Verify that the thing you intend to react to is indeed observable. Use utilities like [`isObservable`](api.md#isobservable), [`isObservableProp`](api.md#isobservableprop) if needed to verify this at runtime.
1. Check the console logs in the browsers for any warnings or errors.
1. Make sure you grok how tracking works in general. Check out the [Understanding reactivity](understanding-reactivity.md) section.
1. Read the common pitfalls as described above.
1. [Configure](configuration.md#linting-options) MobX to warn you of unsound usage of mechanisms and check the console logs.
1. Use [trace](analyzing-reactivity.md) to verify that you are subscribing to the right things or check what MobX is doing in general using [spy](analyzing-reactivity.md#spy) / the [mobx-log](https://github.com/kubk/mobx-log) package.



================================================
FILE: docs/react-optimizations.md
================================================
---
title: Optimizing React component rendering
sidebar_label: React optimizations {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Optimizing React component rendering {ğŸš€}

MobX is very fast, [often even faster than Redux](https://twitter.com/mweststrate/status/718444275239882753), but here are some tips to get most out of React and MobX. Most apply to React in general and are not specific to MobX.
Note that while it's good to be aware of these patterns, usually your application
will be fast enough even if you don't worry about them at all.

Prioritize performance only when it's an actual issue!

## Use many small components

`observer` components will track all values they use and re-render if any of them changes.
So the smaller your components are, the smaller the change they have to re-render. It means that more parts of your user interface have the possibility to render independently of each other.

## Render lists in dedicated components

The above is especially true when rendering big collections.
React is notoriously bad at rendering large collections as the reconciler has to evaluate the components produced by a collection on each collection change.
It is therefore recommended to have components that just map over a collection and render it, and render nothing else.

Bad:

```javascript
const MyComponent = observer(({ todos, user }) => (
    <div>
        {user.name}
        <ul>
            {todos.map(todo => (
                <TodoView todo={todo} key={todo.id} />
            ))}
        </ul>
    </div>
))
```

In the above listing React will unnecessarily need to reconcile all `TodoView` components when the `user.name` changes. They won't re-render, but the reconcile process is expensive in itself.

Good:

```javascript
const MyComponent = observer(({ todos, user }) => (
    <div>
        {user.name}
        <TodosView todos={todos} />
    </div>
))

const TodosView = observer(({ todos }) => (
    <ul>
        {todos.map(todo => (
            <TodoView todo={todo} key={todo.id} />
        ))}
    </ul>
))
```

## Don't use array indexes as keys

Don't use array indexes or any value that might change in the future as key. Generate ids for your objects if needed.
Check out this [blog post](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318).

## Dereference values late

When using `mobx-react` it is recommended to dereference values as late as possible.
This is because MobX will re-render components that dereference observable values automatically.
If this happens deeper in your component tree, less components have to re-render.

Slower:

```javascript
<DisplayName name={person.name} />
```

Faster:

```javascript
<DisplayName person={person} />
```

In the faster example, a change in the `name` property triggers only `DisplayName` to re-render, while in the slower one the owner of the component has to re-render as well. There is nothing wrong with that, and if rendering of the owning component is fast enough (usually it is!), then this approach works well.

### Function props {ğŸš€}

You may notice that to dereference values late, you have to create lots of small observer components where each is customized to render a different part of data, for example:

```javascript
const PersonNameDisplayer = observer(({ person }) => <DisplayName name={person.name} />)

const CarNameDisplayer = observer(({ car }) => <DisplayName name={car.model} />)

const ManufacturerNameDisplayer = observer(({ car }) => 
    <DisplayName name={car.manufacturer.name} />
)
```

This quickly becomes tedious if you have lots of data of different shape. An alternative is to use a function that returns the data that you want your `*Displayer` to render:

```javascript
const GenericNameDisplayer = observer(({ getName }) => <DisplayName name={getName()} />)
```

Then, you can use the component like this:

```javascript
const MyComponent = ({ person, car }) => (
    <>
        <GenericNameDisplayer getName={() => person.name} />
        <GenericNameDisplayer getName={() => car.model} />
        <GenericNameDisplayer getName={() => car.manufacturer.name} />
    </>
)
```

This approach will allow `GenericNameDisplayer` to be reused throughout your application to render any name, and you still keep component re-rendering
to a minimum.



================================================
FILE: docs/reactions.md
================================================
---
title: Running side effects with reactions
sidebar_label: Reactions {ğŸš€}
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Running side effects with reactions {ğŸš€}

Reactions are an important concept to understand, as it is where everything in MobX comes together.
The goal of reactions is to model side effects that happen automatically.
Their significance is in creating consumers for your observable state and _automatically_ running side effects whenever something _relevant_ changes.

However, with that in mind, it is important to realize that the APIs discussed here should rarely be used.
They are often abstracted away in other libraries (like mobx-react) or abstractions specific to your application.

But, to grok MobX, let's take a look at how reactions can be created.
The simplest way is to use the [`autorun`](#autorun) utility.
Beyond that, there are also [`reaction`](#reaction) and [`when`](#when).

## Autorun

Usage:

-   `autorun(effect: (reaction) => void, options?)`

The `autorun` function accepts one function that should run every time anything it observes changes.
It also runs once when you create the `autorun` itself. It only responds to changes in observable state, things you have annotated `observable` or `computed`.

### How tracking works

Autorun works by running the `effect` in a _reactive context_. During the execution of the provided function, MobX keeps track of all observable and computed values that are directly or indirectly _read_ by the effect.
Once the function finishes, MobX will collect and subscribe to all observables that were read and wait until any of them changes again.
Once they do, the `autorun` will trigger again, repeating the entire process.

![autorun](assets/autorun.png)

This is how the example below works like.

### Example

```javascript
import { makeAutoObservable, autorun } from "mobx"

class Animal {
    name
    energyLevel

    constructor(name) {
        this.name = name
        this.energyLevel = 100
        makeAutoObservable(this)
    }

    reduceEnergy() {
        this.energyLevel -= 10
    }

    get isHungry() {
        return this.energyLevel < 50
    }
}

const giraffe = new Animal("Gary")

autorun(() => {
    console.log("Energy level:", giraffe.energyLevel)
})

autorun(() => {
    if (giraffe.isHungry) {
        console.log("Now I'm hungry!")
    } else {
        console.log("I'm not hungry!")
    }
})

console.log("Now let's change state!")
for (let i = 0; i < 10; i++) {
    giraffe.reduceEnergy()
}
```

Running this code, you will get the following output:

```
Energy level: 100
I'm not hungry!
Now let's change state!
Energy level: 90
Energy level: 80
Energy level: 70
Energy level: 60
Energy level: 50
Energy level: 40
Now I'm hungry!
Energy level: 30
Energy level: 20
Energy level: 10
Energy level: 0
```

As you can see in the first two lines of the output above, both `autorun` functions run once when they are initialized. This is all you would see without the `for` loop.

Once we run the `for` loop to change the `energyLevel` with the `reduceEnergy`
action, we see a new log entry every time an `autorun` function observes a
change in its observable state:

1.  For the _"Energy level"_ function, this is every time the `energyLevel` observable changes, 10 times in total.

2.  For the _"Now I'm hungry"_ function, this is every time the `isHungry` computed
    changes, only one time.

## Reaction

Usage:

-   `reaction(() => value, (value, previousValue, reaction) => { sideEffect }, options?)`.

`reaction` is like `autorun`, but gives more fine grained control on which observables will be tracked.
It takes two functions: the first, _data_ function, is tracked and returns the data that is used as input for the second, _effect_ function.
It is important to note that the side effect _only_ reacts to data that was _accessed_ in the data function, which might be less than the data that is actually used in the effect function.

The typical pattern is that you produce the things you need in your side effect
in the _data_ function, and in that way control more precisely when the effect triggers.
By default, the result of the _data_ function has to change in order for the _effect_ function to be triggered.
Unlike `autorun`, the side effect won't run once when initialized, but only after the data expression returns a new value for the first time.

<details id="reaction-example"><summary>**Example:** the data and effect functions<a href="#reaction-example" class="tip-anchor"></a></summary>

In the example below, the reaction is only triggered once, when `isHungry` changes.
Changes to `giraffe.energyLevel`, which is used by the _effect_ function, do not cause the _effect_ function to be executed. If you wanted `reaction` to respond to this
as well, you would have to also access it in the _data_ function and return it.

```javascript
import { makeAutoObservable, reaction } from "mobx"

class Animal {
    name
    energyLevel

    constructor(name) {
        this.name = name
        this.energyLevel = 100
        makeAutoObservable(this)
    }

    reduceEnergy() {
        this.energyLevel -= 10
    }

    get isHungry() {
        return this.energyLevel < 50
    }
}

const giraffe = new Animal("Gary")

reaction(
    () => giraffe.isHungry,
    isHungry => {
        if (isHungry) {
            console.log("Now I'm hungry!")
        } else {
            console.log("I'm not hungry!")
        }
        console.log("Energy level:", giraffe.energyLevel)
    }
)

console.log("Now let's change state!")
for (let i = 0; i < 10; i++) {
    giraffe.reduceEnergy()
}
```

Output:

```
Now let's change state!
Now I'm hungry!
Energy level: 40
```

</details>

## When

Usage:

-   `when(predicate: () => boolean, effect?: () => void, options?)`
-   `when(predicate: () => boolean, options?): Promise`

`when` observes and runs the given _predicate_ function until it returns `true`.
Once that happens, the given _effect_ function is executed and the autorunner is disposed.

The `when` function returns a disposer, allowing you to cancel it manually, unless you don't pass in a second `effect` function, in which case it returns a `Promise`.

<details id="when-example">
  <summary>**Example:** dispose of things in a reactive way<a href="#when-example" class="tip-anchor"></a></summary>

`when` is really useful for disposing or canceling of things in a reactive way.
For example:

```javascript
import { when, makeAutoObservable } from "mobx"

class MyResource {
    constructor() {
        makeAutoObservable(this, { dispose: false })
        when(
            // Once...
            () => !this.isVisible,
            // ... then.
            () => this.dispose()
        )
    }

    get isVisible() {
        // Indicate whether this item is visible.
    }

    dispose() {
        // Clean up some resources.
    }
}
```

As soon as `isVisible` becomes `false`, the `dispose` method is called that
then does some cleanup for `MyResource`.

</details>

### `await when(...)`

If no `effect` function is provided, `when` returns a `Promise`. This combines nicely with `async / await` to let you wait for changes in observable state.

```javascript
async function() {
	await when(() => that.isVisible)
	// etc...
}
```

To cancel `when` prematurely, it is possible to call `.cancel()` on the promise returned by itself.

## Rules

There are a few rules that apply to any reactive context:

1. Affected reactions run by default immediately (synchronously) if an observable is changed. However, they won't run before the end of the current outermost (trans)action.
2. Autorun tracks only the observables that are read during the synchronous execution of the provided function, but it won't track anything that happens asynchronously.
3. Autorun won't track observables that are read by an action invoked by the autorun, as actions are always _untracked_.

For more examples on what precisely MobX will and will not react to, check out the [Understanding reactivity](understanding-reactivity.md) section.
For a more detailed technical breakdown on how tracking works, read the blog post [Becoming fully reactive: an in-depth explanation of MobX](https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254).

## Always dispose of reactions

The functions passed to `autorun`, `reaction` and `when` are only garbage collected if all objects they observe are garbage collected themselves. In principle, they keep waiting forever for new changes to happen in the observables they use.
To be able to stop them from waiting until forever has passed, they all return a disposer function that can be used to stop them and unsubscribe from any observables they used.

```javascript
const counter = observable({ count: 0 })

// Sets up the autorun and prints 0.
const disposer = autorun(() => {
    console.log(counter.count)
})

// Prints: 1
counter.count++

// Stops the autorun.
disposer()

// Will not print.
counter.count++
```

We strongly recommend to always use the disposer function that is returned from these methods as soon as their side effect is no longer needed.
Failing to do so can lead to memory leaks.

The `reaction` argument that is passed as second argument to the effect functions of `reaction` and `autorun`, can be used to prematurely clean up the reaction as well by calling `reaction.dispose()`.

<details id="mem-leak-example"><summary>**Example:** memory leak<a href="#mem-leak-example" class="tip-anchor"></a></summary>

```javascript
class Vat {
    value = 1.2

    constructor() {
        makeAutoObservable(this)
    }
}

const vat = new Vat()

class OrderLine {
    price = 10
    amount = 1
    constructor() {
        makeAutoObservable(this)

        // This autorun will be GC-ed together with the current orderline
        // instance as it only uses observables from `this`. It's not strictly
        // necessary to dispose of it once an OrderLine instance is deleted.
        this.disposer1 = autorun(() => {
            doSomethingWith(this.price * this.amount)
        })

        // This autorun won't be GC-ed together with the current orderline
        // instance, since vat keeps a reference to notify this autorun, which
        // in turn keeps 'this' in scope.
        this.disposer2 = autorun(() => {
            doSomethingWith(this.price * this.amount * vat.value)
        })
    }

    dispose() {
        // So, to avoid subtle memory issues, always call the
        // disposers when the reactions are no longer needed.
        this.disposer1()
        this.disposer2()
    }
}
```

</details>

In environments that support [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management),
the disposer function includes a `[Symbol.dispose]` method that can be used to
dispose of the reaction. This can be useful when disposing of several reactions
simultaneously or when disposing of reactions alongside other Disposables.

<details id="disposable-stack"><summary>**Example:** using DisposableStack<a href="#disposable-stack" class="tip-anchor"></a></summary>

```javascript
function createSomeDisposableResource() {}

class Vat {
    value = 1.2

    constructor() {
        makeAutoObservable(this)
    }
}

const vat = new Vat()

class OrderLine {
    price = 10
    amount = 1
    disposableStack = new DisposableStack()
    someDisposableResource

    constructor() {
        makeAutoObservable(this)

        this.disposableStack.use(autorun(() => {
            doSomethingWith(this.price * this.amount)
        }))

        this.disposableStack.use(autorun(() => {
            doSomethingWith(this.price * this.amount * vat.value)
        }))

        this.someDisposableResource = this.disposableStack.use(createSomeDisposableResource())
    }

    [Symbol.dispose]() {
        this.disposableStack[Symbol.dispose]();
    }
}
```

</details>

## Use reactions sparingly!

As it was already said, you won't create reactions very often.
It might very well be that your application doesn't use any of these APIs directly, and the only way reactions are constructed is indirectly, through for example `observer` from the mobx-react bindings.

Before you set up a reaction, it is good to first check if it conforms to the following principles:

1. **Only use Reactions if there is no direct relation between cause and effect**: If a side effect should happen in response to a very limited set of events / actions, it will often be clearer to directly trigger the effect from those specific actions. For example, if pressing a form submit button should lead to a network request to be posted, it is clearer to trigger this effect directly in response of the `onClick` event, rather than indirectly through a reaction. In contrast, if any change you make to the form state should automatically end up in local storage, then a reaction can be very useful, so that you don't have to trigger this effect from every individual `onChange` event.
1. **Reactions shouldn't update other observables**: Is the reaction going to modify other observables? If the answer is yes, typically the observable you want to update should be annotated as a [`computed`](computeds.md) value instead. For example, if a collection of todos is altered, don't use a reaction to compute the amount of `remainingTodos`, but annotate `remainingTodos` as a computed value. That will lead to much clearer and easier to debug code. Reactions should not compute new data, but only cause effects.
1. **Reactions should be independent**: Does your code rely on some other reaction having to run first? If that is the case, you probably
   either violated the first rule, or the new reaction you are about to create should be merged into the one it is depending upon. MobX does not guarantee the order in which reactions will be run.

There are real-life scenarios that do not fit in the above principles. That is why they are _principles_, not _laws_.
But, the exceptions are rare so only violate them as a last resort.

## Options {ğŸš€}

The behavior of `autorun`, `reaction` and `when` can be further fine-tuned by passing in an `options` argument as shown in the usages above.

### `name`

This string is used as a debug name for this reaction in the [Spy event listeners](analyzing-reactivity.md#spy) and [MobX developer tools](https://github.com/mobxjs/mobx-devtools).

### `fireImmediately` _(reaction)_

Boolean indicating that the _effect_ function should immediately be triggered after the first run of the _data_ function. `false` by default.

### `delay` _(autorun, reaction)_

Number of milliseconds that can be used to throttle the effect function. If zero (default), no throttling happens.

### `timeout` _(when)_

Set a limited amount of time that `when` will wait for. If the deadline passes, `when` will reject / throw.

### `signal`

An AbortSignal object instance; can be used as an alternative method for disposal.<br>
When used with promise version of `when`, the promise rejects with the "WHEN_ABORTED" error.

### `onError`

By default, any exception thrown inside an reaction will be logged, but not further thrown. This is to make sure that an exception in one reaction does not prevent the scheduled execution of other, possibly unrelated reactions. This also allows reactions to recover from exceptions. Throwing an exception does not break the tracking done by MobX, so subsequent runs of the reaction might complete normally again if the cause for the exception is removed. This option allows overriding that behavior. It is possible to set a global error handler or to disable catching errors completely using [configure](configuration.md#disableerrorboundaries-boolean).

### `scheduler` _(autorun, reaction)_

Set a custom scheduler to determine how re-running the autorun function should be scheduled. It takes a function that should be invoked at some point in the future, for example: `{ scheduler: run => { setTimeout(run, 1000) }}`

### `equals`: (reaction)

Set to `comparer.default` by default. If specified, this comparer function is used to compare the previous and next values produced by the _data_ function. The _effect_ function is only invoked if this function returns false.

Check out the [Built-in comparers](computeds.md#built-in-comparers) section.



================================================
FILE: docs/subclassing.md
================================================
---
title: Subclassing
sidebar_label: Subclassing
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Subclassing

Subclassing is supported with [limitations](#limitations). Most notably you can only **override actions/flows/computeds on prototype** - you cannot override _[field declarations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#field_declarations)_. Use the `override` annotation for methods/getters overridden in a subclass - see example below. Try to keep things simple and prefer composition over inheritance.

```javascript
import { makeObservable, observable, computed, action, override } from "mobx"

class Parent {
    // Annotated instance fields are NOT overridable
    observable = 0
    arrowAction = () => {}

    // Non-annotated instance fields are overridable
    overridableArrowAction = action(() => {})

    // Annotated prototype methods/getters are overridable
    action() {}
    actionBound() {}
    get computed() {}

    constructor(value) {
        makeObservable(this, {
            observable: observable,
            arrowAction: action
            action: action,
            actionBound: action.bound,
            computed: computed,
        })
    }
}

class Child extends Parent {
    /* --- INHERITED --- */
    // THROWS - TypeError: Cannot redefine property
    // observable = 5
    // arrowAction = () = {}

    // OK - not annotated
    overridableArrowAction = action(() => {})

    // OK - prototype
    action() {}
    actionBound() {}
    get computed() {}

    /* --- NEW --- */
    childObservable = 0;
    childArrowAction = () => {}
    childAction() {}
    childActionBound() {}
    get childComputed() {}

    constructor(value) {
        super()
        makeObservable(this, {
            // inherited
            action: override,
            actionBound: override,
            computed: override,
            // new
            childObservable: observable,
            childArrowAction: action
            childAction: action,
            childActionBound: action.bound,
            childComputed: computed,
        })
    }
}
```

## Limitations

1. Only `action`, `computed`, `flow`, `action.bound` defined **on prototype** can be **overridden** by subclass.
1. Field can't be re-annotated in subclass, except with `override`.
1. `makeAutoObservable` does not support subclassing.
1. Extending builtins (`ObservableMap`, `ObservableArray`, etc) is not supported.
1. You can't provide different options to `makeObservable` in subclass.
1. You can't mix annotations/decorators in single inheritance chain.
1. [All other limitations apply as well](observable-state.html#limitations)

### `TypeError: Cannot redefine property`

If you see this, you're probably trying to **override arrow function** in subclass `x = () => {}`. That's not possible because **all annotated** fields of classes are **non-configurable** ([see limitations](observable-state.md#limitations)). You have two options:

<details><summary>1. Move function to prototype and use `action.bound` annotation instead</summary>

```javascript
class Parent {
    // action = () => {};
    // =>
    action() {}

    constructor() {
        makeObservable(this, {
            action: action.bound
        })
    }
}
class Child {
    action() {}

    constructor() {
        super()
        makeObservable(this, {
            action: override
        })
    }
}
```

</details>
<details><summary>2. Remove `action` annotation and wrap the function in action manually: `x = action(() => {})`</summary>

```javascript
class Parent {
    // action = () => {};
    // =>
    action = action(() => {})

    constructor() {
        makeObservable(this, {}) // <-- annotation removed
    }
}
class Child {
    action = action(() => {})

    constructor() {
        super()
        makeObservable(this, {}) // <-- annotation removed
    }
}
```

</details>



================================================
FILE: docs/the-gist-of-mobx.md
================================================
---
title: The gist of MobX
sidebar_label: The gist of MobX
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# The gist of MobX

## Concepts

MobX distinguishes between the following three concepts in your application:

1. State
2. Actions
3. Derivations

Let's take a closer look at these concepts below, or alternatively, in the [10 minute introduction to MobX and React](https://mobx.js.org/getting-started), where you can interactively dive deeper into these concepts step by step and build a simple Todo list app.

Some might recognise the concept of "Signals" in the concepts described below.
This is correct, MobX is a signal based state management library avant la lettre.

### 1. Define state and make it observable

_State_ is the data that drives your application.
Usually, there is _domain specific state_ like a list of todo items, and there is _view state_, such as the currently selected element.
State is like spreadsheet cells that hold a value.

Store state in any data structure you like: plain objects, arrays, classes, cyclic data structures or references. It doesn't matter for the workings of MobX.
Just make sure that all properties you want to change over time are marked as `observable` so MobX can track them.

Here is a simple example:

```javascript
import { makeObservable, observable, action } from "mobx"

class Todo {
    id = Math.random()
    title = ""
    finished = false

    constructor(title) {
        makeObservable(this, {
            title: observable,
            finished: observable,
            toggle: action
        })
        this.title = title
    }

    toggle() {
        this.finished = !this.finished
    }
}
```

Using `observable` is like turning a property of an object into a spreadsheet cell.
But unlike spreadsheets, these values can not only be primitive values, but also references, objects and arrays.

<details><summary>Tip: Prefer classes, plain objects or decorators? MobX supports many styles.</summary>

This example can be shortened using [`makeAutoObservable`](observable-state.md), but by being explicit we can showcase the different concepts in greater detail.
Note that MobX doesn't dictate an object style, plain objects instead can be used as well, as can decorators for even more concise classes. See the page for more details.

</details>

But what about `toggle`, which we marked as `action`?

### 2. Update state using actions

An _action_ is any piece of code that changes the _state_. User events, backend data pushes, scheduled events, etc.
An action is like a user that enters a new value into a spreadsheet cell.

In the `Todo` model above you can see that we have a `toggle` method that changes the value of `finished`. `finished` is marked as `observable`. It is recommended that you mark any piece of code that changes `observable`'s as an [`action`](actions.md). That way MobX can automatically apply transactions for effortless optimal performance.

Using actions helps you structure your code and prevents you from inadvertently changing state when you don't intend to.
Methods that modify state are called _actions_ in MobX terminology. In contrast to _views_, which compute new information based on the current state.
Every method should serve at most one of those two goals.

### 3. Create derivations that automatically respond to state changes

_Anything_ that can be derived from the _state_ without any further interaction is a derivation.
Derivations exist in many forms:

-   The _user interface_
-   _Derived data_, such as the number of remaining `todos`
-   _Backend integrations_, e.g. sending changes to the server

MobX distinguishes between two kinds of derivations:

-   _Computed values_, which can always be derived from the current observable state using a pure function
-   _Reactions_, side effects that need to happen automatically when the state changes (bridge between imperative and reactive programming)

When starting with MobX, people tend to overuse reactions.
The golden rule is, always use `computed` if you want to create a value based on the current state.

#### 3.1. Model derived values using computed

To create a _computed_ value, define a property using a JS getter function `get` and mark it as `computed` with `makeObservable`.

```javascript
import { makeObservable, observable, computed } from "mobx"

class TodoList {
    todos = []
    get unfinishedTodoCount() {
        return this.todos.filter(todo => !todo.finished).length
    }
    constructor(todos) {
        makeObservable(this, {
            todos: observable,
            unfinishedTodoCount: computed
        })
        this.todos = todos
    }
}
```

MobX will ensure that `unfinishedTodoCount` is updated automatically when a todo is added or when one of the `finished` properties is modified.

These computations resemble formulas in spreadsheet programs like MS Excel. They update automatically, but only when required. That is, if something is interested in their outcome.

#### 3.2. Model side effects using reactions

For you as a user to be able to see a change in state or computed values on the screen, a _reaction_ that repaints a part of the GUI is needed.

Reactions are similar to computed values, but instead of producing information, they produce side effects like printing to the console, making network requests, incrementally updating React component tree to patch the DOM, etc.

In short, reactions bridge the worlds of [reactive](https://en.wikipedia.org/wiki/Reactive_programming) and [imperative](https://en.wikipedia.org/wiki/Imperative_programming) programming.

By far the most used form of reactions are UI components.
Note that it is possible to trigger side effects from both actions and reactions.
Side effects that have a clear, explicit origin from which they can be triggered, such
as making a network request when submitting a form, should be triggered explicitly from the relevant event handler.

#### 3.3. Reactive React components

If you are using React, you can make your components reactive by wrapping them with the [`observer`](react-integration.md) function from the bindings package you've [chosen during installation](installation.md#installation). In this example, we're going to use the more lightweight `mobx-react-lite` package.

```javascript
import * as React from "react"
import { render } from "react-dom"
import { observer } from "mobx-react-lite"

const TodoListView = observer(({ todoList }) => (
    <div>
        <ul>
            {todoList.todos.map(todo => (
                <TodoView todo={todo} key={todo.id} />
            ))}
        </ul>
        Tasks left: {todoList.unfinishedTodoCount}
    </div>
))

const TodoView = observer(({ todo }) => (
    <li>
        <input type="checkbox" checked={todo.finished} onClick={() => todo.toggle()} />
        {todo.title}
    </li>
))

const store = new TodoList([new Todo("Get Coffee"), new Todo("Write simpler code")])
render(<TodoListView todoList={store} />, document.getElementById("root"))
```

`observer` converts React components into derivations of the data they render.
When using MobX there are no smart or dumb components.
All components render smartly, but are defined in a dumb manner. MobX will simply make sure the components are always re-rendered whenever needed, and never more than that.

So the `onClick` handler in the above example will force the proper `TodoView` component to re-render as it uses the `toggle` action, but will only cause the `TodoListView` component to re-render if the number of unfinished tasks has changed.
And if you would remove the `Tasks left` line (or put it into a separate component), the `TodoListView` component would no longer re-render when ticking a task.

To learn more about how React works with MobX, check out the [React integration](react-integration.md) section.

#### 3.4. Custom reactions

You will need them rarely, but they can be created using the [`autorun`](reactions.md#autorun),
[`reaction`](reactions.md#reaction) or [`when`](reactions.md#when) functions to fit your specific situations.
For example, the following `autorun` prints a log message every time the amount of `unfinishedTodoCount` changes:

```javascript
// A function that automatically observes the state.
autorun(() => {
    console.log("Tasks left: " + todos.unfinishedTodoCount)
})
```

Why does a new message get printed every time the `unfinishedTodoCount` is changed? The answer is this rule of thumb:

_MobX reacts to any existing observable property that is read during the execution of a tracked function._

To learn more about how MobX determines which observables need to be reacted to, check out the [Understanding reactivity](understanding-reactivity.md) section.

## Principles

MobX uses a uni-directional data flow where _actions_ change the _state_, which in turn updates all affected _views_.


![Action, State, View](assets/action-state-view.png)

1. All _derivations_ are updated **automatically** and **atomically** when the _state_ changes. As a result, it is never possible to observe intermediate values.

2. All _derivations_ are updated **synchronously** by default. This means that, for example, _actions_ can safely inspect a computed value directly after altering the _state_.

3. _Computed values_ are updated **lazily**. Any computed value that is not actively in use will not be updated until it is needed for a side effect (I/O).
   If a view is no longer in use it will be garbage collected automatically.

4. All _computed values_ should be **pure**. They are not supposed to change _state_.

To learn more about the background context, check out [the fundamental principles behind MobX](https://hackernoon.com/the-fundamental-principles-behind-mobx-7a725f71f3e8).

## Try it out!

You can play with the above examples yourself on [CodeSandbox](https://codesandbox.io/s/concepts-principles-il8lt?file=/src/index.js:1161-1252).

## Linting

If you find it hard to adopt the mental model of MobX, configure it to be very strict and warn you at runtime whenever you deviate from these patterns. Check out the [linting MobX](configuration.md#linting-options) section.



================================================
FILE: docs/understanding-reactivity.md
================================================
---
title: Understanding reactivity
sidebar_label: Understanding reactivity
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# Understanding reactivity

MobX usually reacts to exactly the things you expect it to, which means that in 90% of your use cases MobX should "just work".
However, at some point you will encounter a case where it does not do what you expected.
At that point it is invaluable to understand how MobX determines what to react to.

> MobX reacts to any _existing_ **observable** _property_ that is read during the execution of a tracked function.

-   _"reading"_ is dereferencing an object's property, which can be done through "dotting into" it (eg. `user.name`) or using the bracket notation (eg. `user['name']`, `todos[3]`) or destructuring (eg. `const {name} = user`).
-   _"tracked functions"_ are the expression of `computed`, the _rendering_ of an `observer` React function component, the `render()` method of an `observer` based React class component, and the functions that are passed as the first param to `autorun`, `reaction` and `when`.
-   _"during"_ means that only those observables that are read while the function is executing are tracked. It doesn't matter whether these values are used directly or indirectly by the tracked function. But things that have been 'spawned' from the function won't be tracked (e.g. `setTimeout`, `promise.then`, `await` etc).

In other words, MobX will not react to:

-   Values that are obtained from observables, but outside a tracked function
-   Observables that are read in an asynchronously invoked code block

## MobX tracks property access, not values

To elaborate on the above rules with an example, suppose that you have the following observable instance:

```javascript
class Message {
    title
    author
    likes
    constructor(title, author, likes) {
        makeAutoObservable(this)
        this.title = title
        this.author = author
        this.likes = likes
    }

    updateTitle(title) {
        this.title = title
    }
}

let message = new Message("Foo", { name: "Michel" }, ["Joe", "Sara"])
```

In memory this looks as follows. The green boxes indicate _observable_ properties. Note that the _values_ themselves are not observable!

![MobX reacts to changing references](assets/observed-refs.png)

What MobX basically does is recording which _arrows_ you use in your function. After that, it will re-run whenever one of these _arrows_ changes; when they start to refer to something else.

## Examples

Let's show that with a bunch of examples (based on the `message` variable defined above):

#### Correct: dereference inside the tracked function

```javascript
autorun(() => {
    console.log(message.title)
})
message.updateTitle("Bar")
```

This will react as expected. The `.title` property was dereferenced by the autorun, and changed afterwards, so this change is detected.

You can verify what MobX will track by calling [`trace()`](analyzing-reactivity.md) inside the tracked function. In the case of the above function it outputs the following:

```javascript
import { trace } from "mobx"

const disposer = autorun(() => {
    console.log(message.title)
    trace()
})
// Outputs:
// [mobx.trace] 'Autorun@2' tracing enabled

message.updateTitle("Hello")
// Outputs:
// [mobx.trace] 'Autorun@2' is invalidated due to a change in: 'Message@1.title'
Hello
```

It is also possible to get the internal dependency (or observer) tree by using `getDependencyTree`:

```javascript
import { getDependencyTree } from "mobx"

// Prints the dependency tree of the reaction coupled to the disposer.
console.log(getDependencyTree(disposer))
// Outputs:
// { name: 'Autorun@2', dependencies: [ { name: 'Message@1.title' } ] }
```

#### Incorrect: changing a non-observable reference

```javascript
autorun(() => {
    console.log(message.title)
})
message = new Message("Bar", { name: "Martijn" }, ["Felicia", "Marcus"])
```

This will **not** react. `message` was changed, but `message` is not an observable, just a variable which _refers to_ an observable, but the variable (reference) itself is not observable.

#### Incorrect: dereference outside of a tracked function

```javascript
let title = message.title
autorun(() => {
    console.log(title)
})
message.updateMessage("Bar")
```

This will **not** react. `message.title` was dereferenced outside of `autorun`, and just contains the value of `message.title` at the moment of dereferencing (the string `"Foo"`). `title` is not an observable so `autorun` will never react.

#### Correct: dereference inside the tracked function

```javascript
autorun(() => {
    console.log(message.author.name)
})

runInAction(() => {
    message.author.name = "Sara"
})
runInAction(() => {
    message.author = { name: "Joe" }
})
```

This reacts to both changes. Both `author` and `author.name` are dotted into, allowing MobX to track these references.

Note that we had to use `runInAction` here to be allowed to make changes outside
of an `action`.

#### Incorrect: store a local reference to an observable object without tracking

```javascript
const author = message.author
autorun(() => {
    console.log(author.name)
})

runInAction(() => {
    message.author.name = "Sara"
})
runInAction(() => {
    message.author = { name: "Joe" }
})
```

The first change will be picked up, `message.author` and `author` are the same object, and the `.name` property is dereferenced in the autorun.
However, the second change is **not** picked up, because the `message.author` relation is not tracked by the `autorun`. Autorun is still using the "old" `author`.

#### Common pitfall: console.log

```javascript
autorun(() => {
    console.log(message)
})

// Won't trigger a re-run.
message.updateTitle("Hello world")
```

In the above example, the updated message title won't be printed, because it is not used inside the autorun.
The autorun only depends on `message`, which is not an observable, but a variable. In other words, as far as MobX is concerned, `title` is not used in the `autorun`.

If you use this in a web browser debugging tool, you may be able to find the
updated value of `title` after all, but this is misleading -- autorun run after all has run once when it was first called. This happens because `console.log` is an asynchronous function and the object is only formatted later in time. This means that if you follow the title in the debugging toolbar, you can find the updated value. But the `autorun` does not track any updates.

The way to make this work is to make sure to always pass immutable data or defensive copies to `console.log`. So the following solutions all react to changes in `message.title`:

```javascript
autorun(() => {
    console.log(message.title) // Clearly, the `.title` observable is used.
})

autorun(() => {
    console.log(mobx.toJS(message)) // toJS creates a deep clone, and thus will read the message.
})

autorun(() => {
    console.log({ ...message }) // Creates a shallow clone, also using `.title` in the process.
})

autorun(() => {
    console.log(JSON.stringify(message)) // Also reads the entire structure.
})
```

#### Correct: access array properties in tracked function

```javascript
autorun(() => {
    console.log(message.likes.length)
})
message.likes.push("Jennifer")
```

This will react as expected. `.length` counts towards a property.
Note that this will react to _any_ change in the array.
Arrays are not tracked per index / property (like observable objects and maps), but as a whole.

#### Incorrect: access out-of-bounds indices in tracked function

```javascript
autorun(() => {
    console.log(message.likes[0])
})
message.likes.push("Jennifer")
```

This will react with the above sample data because array indexes count as property access. But **only** if the provided `index < length`.
MobX does not track not-yet-existing array indices.
So always guard your array index based access with a `.length` check.

#### Correct: access array functions in tracked function

```javascript
autorun(() => {
    console.log(message.likes.join(", "))
})
message.likes.push("Jennifer")
```

This will react as expected. All array functions that do not mutate the array are tracked automatically.

---

```javascript
autorun(() => {
    console.log(message.likes.join(", "))
})
message.likes[2] = "Jennifer"
```

This will react as expected. All array index assignments are detected, but only if `index <= length`.

#### Incorrect: "use" an observable but without accessing any of its properties

```javascript
autorun(() => {
    message.likes
})
message.likes.push("Jennifer")
```

This will **not** react. Simply because the `likes` array itself is not being used by the `autorun`, only the reference to the array.
So in contrast, `message.likes = ["Jennifer"]` would be picked up; that statement does not modify the array, but the `likes` property itself.

#### Correct: using not yet existing map entries

```javascript
const twitterUrls = observable.map({
    Joe: "twitter.com/joey"
})

autorun(() => {
    console.log(twitterUrls.get("Sara"))
})

runInAction(() => {
    twitterUrls.set("Sara", "twitter.com/horsejs")
})
```

This **will** react. Observable maps support observing entries that may not exist.
Note that this will initially print `undefined`.
You can check for the existence of an entry first by using `twitterUrls.has("Sara")`.
So in an environment without Proxy support for dynamically keyed collections always use observable maps. If you do have Proxy support you can use observable maps as well,
but you also have the option to use plain objects.

#### MobX does not track asynchronously accessed data

```javascript
function upperCaseAuthorName(author) {
    const baseName = author.name
    return baseName.toUpperCase()
}
autorun(() => {
    console.log(upperCaseAuthorName(message.author))
})

runInAction(() => {
    message.author.name = "Chesterton"
})
```

This will react. Even though `author.name` is not dereferenced by the function passed to `autorun` itself, MobX will still track the dereferencing that happens in `upperCaseAuthorName`, because it happens _during_ the execution of the autorun.

---

```javascript
autorun(() => {
    setTimeout(() => console.log(message.likes.join(", ")), 10)
})

runInAction(() => {
    message.likes.push("Jennifer")
})
```

This will **not** react because during the execution of the `autorun` no observables were accessed, only during the `setTimeout`, which is an asynchronous function.

Check out the [Asynchronous actions](actions.md#asynchronous-actions) section as well.

#### Using non-observable object properties

```javascript
autorun(() => {
    console.log(message.author.age)
})

runInAction(() => {
    message.author.age = 10
})
```

This **will** react if you run React in an environment that supports Proxy.
Note that this is only done for objects created with `observable` or `observable.object`. New properties on class instances will not be made observable automatically.

_Environments without Proxy support_

This will **not** react. MobX can only track observable properties, and 'age' has not been defined as observable property above.

However, it is possible to use the `get` and `set` methods as exposed by MobX to work around this:

```javascript
import { get, set } from "mobx"

autorun(() => {
    console.log(get(message.author, "age"))
})
set(message.author, "age", 10)
```

#### [Without Proxy support] Incorrect: using not yet existing observable object properties

```javascript
autorun(() => {
    console.log(message.author.age)
})
extendObservable(message.author, {
    age: 10
})
```

This will **not** react. MobX will not react to observable properties that did not exist when tracking started.
If the two statements are swapped, or if any other observable causes the `autorun` to re-run, the `autorun` will start tracking the `age` as well.

#### [Without Proxy support] Correct: using MobX utilities to read / write to objects

If you are in an environment without proxy support and still want to use observable
objects as a dynamic collection, you can handle them using the MobX `get` and `set`
API.

The following will react as well:

```javascript
import { get, set, observable } from "mobx"

const twitterUrls = observable.object({
    Joe: "twitter.com/joey"
})

autorun(() => {
    console.log(get(twitterUrls, "Sara")) // `get` can track not yet existing properties.
})

runInAction(() => {
    set(twitterUrls, { Sara: "twitter.com/horsejs" })
})
```

Check out the [Collection utilities API](api.md#collection-utilities-) for more details.

#### TL;DR

> MobX reacts to any _existing_ **observable** _property_ that is read during the execution of a tracked function.



================================================
FILE: docs/assets/action-state-view.excalidraw
================================================
{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "pIZO1JmQiFI2poIar1JJR",
      "type": "rectangle",
      "x": 1265.39453125,
      "y": 506.8125,
      "width": 169.73437500000006,
      "height": 42.90625,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fab005",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 217429890,
      "version": 373,
      "versionNonce": 1117308162,
      "isDeleted": false
    },
    {
      "id": "pD5v3-2w2hmmHs3ijydzw",
      "type": "text",
      "x": 1288.564453125,
      "y": 513.876953125,
      "width": 126,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 258359006,
      "version": 335,
      "versionNonce": 1677952030,
      "isDeleted": false,
      "text": "reduceEnergy",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 18
    },
    {
      "id": "u7JpBImi1GLSlmI3XfhSo",
      "type": "rectangle",
      "x": 1016.30859375,
      "y": 490.58984375,
      "width": 96.56250000000003,
      "height": 51.124999999999986,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#228be6",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 1302734018,
      "version": 259,
      "versionNonce": 1929172162,
      "isDeleted": false
    },
    {
      "id": "BWk9D8NLVXhfJLVv98F7C",
      "type": "text",
      "x": 1026.07421875,
      "y": 500.50390625,
      "width": 76,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 1412671326,
      "version": 121,
      "versionNonce": 1736003678,
      "isDeleted": false,
      "text": "isHungry",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "top",
      "baseline": 18
    },
    {
      "id": "4-ymabCsXtPMIqHbdW8oE",
      "type": "rectangle",
      "x": 531.86328125,
      "y": 477.41015625,
      "width": 320.26171875000006,
      "height": 119.37500000000001,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fa5252",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 500763422,
      "version": 549,
      "versionNonce": 1668755806,
      "isDeleted": false
    },
    {
      "id": "LKVSistQFQl5dwvDIha03",
      "type": "text",
      "x": 548.16796875,
      "y": 485.490234375,
      "width": 74,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 275201474,
      "version": 248,
      "versionNonce": 399874946,
      "isDeleted": false,
      "text": "autorun",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 18
    },
    {
      "id": "AmfUhwRl3kmfUpDL-cz69",
      "type": "arrow",
      "x": 893.578125,
      "y": 542.67578125,
      "width": 103.203125,
      "height": 26.18359375,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fa5252",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 14401054,
      "version": 98,
      "versionNonce": 1922705986,
      "isDeleted": false,
      "points": [
        [
          0,
          0
        ],
        [
          103.203125,
          -26.18359375
        ]
      ],
      "lastCommittedPoint": null
    },
    {
      "id": "5Ri4oSpXCOayASosdJczV",
      "type": "rectangle",
      "x": 643.65625,
      "y": 500.65234375,
      "width": 181.6875,
      "height": 77.12109375,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 958282526,
      "version": 72,
      "versionNonce": 1344405954,
      "isDeleted": false
    },
    {
      "id": "4VRPEmGVy-I7ISGPIC3lG",
      "type": "text",
      "x": 697,
      "y": 526.712890625,
      "width": 75,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 132157534,
      "version": 17,
      "versionNonce": 1011446622,
      "isDeleted": false,
      "text": "function",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 18
    },
    {
      "id": "FQzAKSjfUWyDZAjvXVOY5",
      "type": "text",
      "x": 537.37890625,
      "y": 429.46484375,
      "width": 217,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 1833437214,
      "version": 104,
      "versionNonce": 499153282,
      "isDeleted": false,
      "text": "1. autorun runs initially",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 18
    },
    {
      "id": "DaIFjPSHk2uPQUxrBhM14",
      "type": "text",
      "x": 897.24609375,
      "y": 434.5,
      "width": 197,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 1406985630,
      "version": 127,
      "versionNonce": 2009028510,
      "isDeleted": false,
      "text": "2. read & subscribe",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 18
    },
    {
      "id": "gdEVREQf-CI_WiOGb0k0p",
      "type": "arrow",
      "x": 1248.12109375,
      "y": 535.2734375,
      "width": 117.19921875,
      "height": 10.93359375,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 419114910,
      "version": 39,
      "versionNonce": 1265546206,
      "isDeleted": false,
      "points": [
        [
          0,
          0
        ],
        [
          -117.19921875,
          -10.93359375
        ]
      ],
      "lastCommittedPoint": null
    },
    {
      "id": "2L7qtsz980qi281apFm68",
      "type": "text",
      "x": 1170.65625,
      "y": 565.06640625,
      "width": 161,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 942371998,
      "version": 36,
      "versionNonce": 1861058818,
      "isDeleted": false,
      "text": "3. update state",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 18
    },
    {
      "id": "W81Z7ZPQ_NNZj_IpAcRgP",
      "type": "arrow",
      "x": 1055.921875,
      "y": 563.03125,
      "width": 283.78515625,
      "height": 130.73046875,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 93774430,
      "version": 90,
      "versionNonce": 1080000386,
      "isDeleted": false,
      "points": [
        [
          0,
          0
        ],
        [
          -169.859375,
          130.73046875
        ],
        [
          -283.78515625,
          56.4453125
        ]
      ],
      "lastCommittedPoint": [
        -283.78515625,
        56.4453125
      ]
    },
    {
      "id": "7PSGJMcV7z4iygXHJNS_o",
      "type": "text",
      "x": 966.2265625,
      "y": 676.7265625,
      "width": 276,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fff",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "seed": 775974494,
      "version": 50,
      "versionNonce": 1448293598,
      "isDeleted": false,
      "text": "4. notify and re-run autorun",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 18
    }
  ],
  "appState": {
    "viewBackgroundColor": "#ffffff",
    "gridSize": null
  }
}


================================================
FILE: docs/assets/flow.excalidraw..excalidraw..excalidraw
================================================
{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "umJvYNbrYyosAii0TCe8X",
      "type": "ellipse",
      "x": 600.93359375,
      "y": 295.0234375,
      "width": 166,
      "height": 98.13671875,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fd7e14",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 798279679,
      "version": 61,
      "versionNonce": 534261841,
      "isDeleted": false,
      "boundElementIds": [
        "SQTF1dyrT_6IGmfEPfDFk",
        "Qs4t0BM0S_4Pke8rNKbmD",
        "c9iGYLrlWNl56Bq2qFVR3"
      ]
    },
    {
      "id": "tMxgXvq5-KCTnP_iTfUt8",
      "type": "text",
      "x": 648.93359375,
      "y": 331.826171875,
      "width": 70,
      "height": 25,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1329095185,
      "version": 11,
      "versionNonce": 637794161,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "Actions",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 18
    },
    {
      "id": "fESH7TjYaPiRAXCLgu6gj",
      "type": "ellipse",
      "x": 889.2734375,
      "y": 293.07421875,
      "width": 153.390625,
      "height": 97.08984375,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#228be6",
      "fillStyle": "cross-hatch",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 754120735,
      "version": 162,
      "versionNonce": 277796639,
      "isDeleted": false,
      "boundElementIds": [
        "SQTF1dyrT_6IGmfEPfDFk",
        "Gfe2kVUk-oe4nZFYZ4TS2"
      ]
    },
    {
      "id": "YNybqj5LHUYEaaw-npqM0",
      "type": "text",
      "x": 913.22265625,
      "y": 316.373046875,
      "width": 105,
      "height": 50,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1139926705,
      "version": 92,
      "versionNonce": 806532223,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "Observable\nState",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 43
    },
    {
      "id": "Rp_m5EtBqLK880zk0HPes",
      "type": "ellipse",
      "x": 1168.73046875,
      "y": 287.671875,
      "width": 152.62109375,
      "height": 101.0078125,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#82c91e",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 979115551,
      "version": 137,
      "versionNonce": 842295903,
      "isDeleted": false,
      "boundElementIds": [
        "Gfe2kVUk-oe4nZFYZ4TS2",
        "muBFJlzUT62Z5u6vtgoPo"
      ]
    },
    {
      "id": "bUQmcBczRpetKGA2QAQOC",
      "type": "text",
      "x": 1198.294921875,
      "y": 313.17578125,
      "width": 93,
      "height": 50,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 21397215,
      "version": 89,
      "versionNonce": 275028479,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "Computed\nValues",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 43
    },
    {
      "id": "2iAmN0ThUq3khqXmobwXR",
      "type": "ellipse",
      "x": 1440.24609375,
      "y": 280.24609375,
      "width": 180,
      "height": 97.82421875,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "#fa5252",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 155797873,
      "version": 93,
      "versionNonce": 1218509617,
      "isDeleted": false,
      "boundElementIds": [
        "muBFJlzUT62Z5u6vtgoPo",
        "YsOB3_rayI5zJZmc-0vka",
        "MwGF75DmHeJQFvsbtXTC3",
        "c9iGYLrlWNl56Bq2qFVR3"
      ]
    },
    {
      "id": "-ksRGDFon1_cAw4yzn-NY",
      "type": "text",
      "x": 1468.4375,
      "y": 303.76953125,
      "width": 122,
      "height": 50,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 919383807,
      "version": 107,
      "versionNonce": 1840129151,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "Side-effects\n(like render)",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "center",
      "verticalAlign": "middle",
      "baseline": 43
    },
    {
      "id": "SQTF1dyrT_6IGmfEPfDFk",
      "type": "arrow",
      "x": 778.8445740250362,
      "y": 346.239580272118,
      "width": 99.00070983588682,
      "height": 1.6378151789648427,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "round",
      "seed": 1143683505,
      "version": 44,
      "versionNonce": 965939217,
      "isDeleted": false,
      "boundElementIds": null,
      "points": [
        [
          0,
          0
        ],
        [
          99.00070983588682,
          -1.6378151789648427
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "umJvYNbrYyosAii0TCe8X",
        "focus": 0.07806863034707597,
        "gap": 11.969792579631289
      },
      "endBinding": {
        "elementId": "fESH7TjYaPiRAXCLgu6gj",
        "focus": -0.031398466371432183,
        "gap": 11.536940281179355
      }
    },
    {
      "id": "Gfe2kVUk-oe4nZFYZ4TS2",
      "type": "arrow",
      "x": 1053.9983652852434,
      "y": 343.1772085606117,
      "width": 106.42230116522956,
      "height": 0.10172927196111914,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "round",
      "seed": 1805338897,
      "version": 44,
      "versionNonce": 468837745,
      "isDeleted": false,
      "boundElementIds": null,
      "points": [
        [
          0,
          0
        ],
        [
          106.42230116522956,
          -0.10172927196111914
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "fESH7TjYaPiRAXCLgu6gj",
        "focus": 0.034035946947105086,
        "gap": 11.364088475962532
      },
      "endBinding": {
        "elementId": "Rp_m5EtBqLK880zk0HPes",
        "focus": -0.09541448620171078,
        "gap": 8.602060160628056
      }
    },
    {
      "id": "muBFJlzUT62Z5u6vtgoPo",
      "type": "arrow",
      "x": 1341.157078677608,
      "y": 339.7422181379586,
      "width": 88.60855868842668,
      "height": 2.6091895262144362,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "round",
      "seed": 1832057969,
      "version": 128,
      "versionNonce": 1342081055,
      "isDeleted": false,
      "boundElementIds": null,
      "points": [
        [
          0,
          0
        ],
        [
          88.60855868842668,
          -2.6091895262144362
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "Rp_m5EtBqLK880zk0HPes",
        "gap": 19.82936306898931,
        "focus": 0.08945444862904846
      },
      "endBinding": {
        "elementId": "2iAmN0ThUq3khqXmobwXR",
        "gap": 11.37138636336131,
        "focus": -0.1024021768851719
      }
    },
    {
      "id": "Qs4t0BM0S_4Pke8rNKbmD",
      "type": "arrow",
      "x": 492.0234375,
      "y": 350.046875,
      "width": 95.43387310642322,
      "height": 0.9643864370914343,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "round",
      "seed": 234060401,
      "version": 68,
      "versionNonce": 297558161,
      "isDeleted": false,
      "boundElementIds": null,
      "points": [
        [
          0,
          0
        ],
        [
          95.43387310642322,
          -0.9643864370914343
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": null,
      "endBinding": {
        "elementId": "umJvYNbrYyosAii0TCe8X",
        "focus": -0.08182839036919108,
        "gap": 13.781886293370846
      }
    },
    {
      "id": "c9iGYLrlWNl56Bq2qFVR3",
      "type": "arrow",
      "x": 1521.4329053171455,
      "y": 397.76984274454924,
      "width": 847.5934093483568,
      "height": 71.62078225545076,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "round",
      "seed": 1408772703,
      "version": 339,
      "versionNonce": 455396689,
      "isDeleted": false,
      "boundElementIds": null,
      "points": [
        [
          0,
          0
        ],
        [
          -85.06181156714547,
          61.46453225545076
        ],
        [
          -770.2180615671455,
          71.62078225545076
        ],
        [
          -847.5934093483568,
          15.194066486107488
        ]
      ],
      "lastCommittedPoint": [
        -834.17578125,
        10.3515625
      ],
      "startBinding": {
        "elementId": "2iAmN0ThUq3khqXmobwXR",
        "gap": 19.92113118460233,
        "focus": -0.7649085384743577
      },
      "endBinding": {
        "elementId": "umJvYNbrYyosAii0TCe8X",
        "focus": 0.9783632894951878,
        "gap": 20.136000442647486
      }
    },
    {
      "id": "eGPmufgc-vKMKmqf5K70-",
      "type": "text",
      "x": 499.75,
      "y": 299.75,
      "width": 59,
      "height": 24,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1637190321,
      "version": 57,
      "versionNonce": 722379505,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "event",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 19
    },
    {
      "id": "vynyr8w8fVE7OJXHAE365",
      "type": "text",
      "x": 780,
      "y": 300,
      "width": 70,
      "height": 24,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1893934897,
      "version": 361,
      "versionNonce": 1504841009,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "update",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 19
    },
    {
      "id": "4svZvrPyD8SmDlCrAqiub",
      "type": "text",
      "x": 1060,
      "y": 300,
      "width": 70,
      "height": 24,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1281306641,
      "version": 14,
      "versionNonce": 881014001,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "notify",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 19
    },
    {
      "id": "9SF49CHx9H587dg3XyxK3",
      "type": "text",
      "x": 1340,
      "y": 300,
      "width": 82,
      "height": 24,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1159088735,
      "version": 18,
      "versionNonce": 1065184433,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "trigger",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 19
    },
    {
      "id": "Qw_akk4TX_QbVkg5X1aKS",
      "type": "text",
      "x": 1078.23046875,
      "y": 484.29296875,
      "width": 59,
      "height": 24,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1289093279,
      "version": 95,
      "versionNonce": 313892977,
      "isDeleted": false,
      "boundElementIds": null,
      "text": "event",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 19
    }
  ],
  "appState": {
    "viewBackgroundColor": "#ffffff",
    "gridSize": null
  }
}


================================================
FILE: docs/assets/getting-started-assets/script.js
================================================
/* For demo purposes only, component to track its own (and parents) amount of renderings */
var RenderCounter = function() {
    var _c = React.useRef(0);
    return React.createElement(
        "div",
        { className: "render-counter " + (++_c.current % 2 ? "odd" : "even") },
        _c.current
    )
}

// Save the original source before pretty printer is fired
function getCodeFromTA(elem) {
    var cm = $(elem).data("cm")
    if (!cm) {
        console.log("Code editors not yet loaded")
        return ""
    }
    var code = cm.getDoc().getValue()
    return code
}

function runCodeHelper(code) {
    // some global vars..
    window.observable = mobx.observable
    window.autorun = mobx.autorun
    window.computed = mobx.computed
    window.action = mobx.action
    window.observer = mobxReactLite.observer
    window.makeObservable = mobx.makeObservable
    window.makeAutoObservable = mobx.makeAutoObservable

    var globalEval = eval // global scope trick, See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

    try {
    code = Babel.transform(code, {
        presets: ["react", "es2015-no-commonjs", "stage-1"],
    }).code.replace(/"use strict"/g, "")
        globalEval(code)
    } catch (e) {
        console.error(e)
    }
}

function runCode(ids) {
    $(ids.join(",")).each(function(i, elem) {
        clearConsole()
        var code = getCodeFromTA(elem)
        runCodeHelper(code)
    })
}

var runLineHandle = null
var runLineIndex = 0
var lineMarker

function runCodePerLine() {
    if (typeof observableTodoStore === "undefined") {
        runCode(["#code1", "#code3", "#code4", "#react1"])
    }

    function runNext() {
        var cm = $("#play1").data("cm")
        var code = cm.getDoc().getValue()
        var lines = code.split("\n")
        var idx = runLineIndex % lines.length
        var line = lines[idx]
        if (lineMarker) lineMarker.clear()
        lineMarker = cm
            .getDoc()
            .markText(
                { line: idx, ch: 0 },
                { line: idx, ch: line.length },
                { css: "background-color:#ff9955;" }
            )
        runCodeHelper(line)
        runLineIndex++
    }

    if (!runLineHandle) {
        $("#runline-btn").text("Pause")
        runNext()
        runLineHandle = setInterval(runNext, 2000)
    } else {
        clearInterval(runLineHandle)
        runLineHandle = null
        $("#runline-btn").text("Continue")
    }
}

$console = $("#consoleout")
var baseLog = console.log,
    baseError = console.error
console.log = function(arg) {
    baseLog.apply(console, arguments)
    $console.html($console.html() + "<div>" + escapeHtml(arg).replace("\n", "<br/>\n") + "</div>")
}
console.error = function(arg) {
    baseError.apply(console, arguments)
    $console.html(
        $console.html() +
            "<pre style='color:white;background:red;padding:10px;'>" +
            escapeHtml(arg).replace(/\n/, "<br/>") +
            "</pre>\n"
    )
}

function clearConsole() {
    $("#consoleout").text("")
}

var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
}

function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function(s) {
        return entityMap[s]
    })
}

$(function() {
    $("textarea").each(function(i, t) {
        var cm = CodeMirror.fromTextArea(t, {
            lineNumbers: false,
            mode: "javascript",
            theme: "xq-light"
        })
        $(t).data("cm", cm)
    })
})



================================================
FILE: docs/assets/getting-started-assets/style.css
================================================
body, html {
    padding: 0;
    margin: 0;
    height: 100%;
	font-family: 'PT Serif', serif;
}
.root {
    height: 100vh;
    width: 100%;
    border-spacing: 0px;
}
.left, .right {
    padding: 0px;
    width: 50%;
    vertical-align: top;
}
.left-content-wrapper {
    height:100vh;
    overflow: scroll;
}
.left-content {
	margin-left: auto;
	margin-right: 0;
}
.right {
	background: #3B64AF;
	color: white;
}
.right-content, .left-content {
	max-width: 600px;
	padding: 40px;
}
.right-content {
}
h1,h2,h3,h4 {
	font-weight: bold;
    font-size: 2em;
}
h1 {
	size: 40pt;
}
hr {
	border: none;
	border-top: 1px dotted #999;
	width: 30%;
}

#project_title {
	font-size: 60pt;
}
#project_tagline {
	clear: left;
	font-family: 'arial';
	font-size: 18pt;
	text-align: center;
}

textarea, body .CodeMirror {
    width: 560px;
}

textarea {
    border-style: none;
    white-space: pre;
    overflow: auto;
    padding: 20px;
    font-family: courier new;
    color: #333;
    font-size: 10pt;
    text-shadow: #fff 1px 1px;
    margin: 30px 0 20px;
}
body .CodeMirror {
	border: 1px solid #999;
    height: auto;
    font-size: 10pt;
    font-family: courier new;
    margin-top: 30px;
    margin-bottom: 30px;
    padding: 14px;
}
code {
    padding: 0;
    margin: 0;
    box-shadow: none;
    color: #007edf;
    font-family: 'courier new';
    font-size: 11pt;
    background: none;
}
.right li {
	color: white;
    padding-left: 10px;
}
button {
    cursor: pointer;
}
.btn-run {
    margin-left: 8px;
    float: right;
    position: relative;
    padding: 4px 10px;
    top: -22px;
    left: 7px;
}
.btn-run:hover {
	outline: 2px solid #ff9955;
}
.right h3 {
	margin-bottom: 4px;
}
#reactjs-app {
    margin-left: -20px;
    padding: 20px;
    width: 100%;
}
#consoleout div {
    border-bottom: 1px solid #ccc;
    padding: 4px 0;
    font-family: courier new;
    font-size: 10pt;
}
.render-counter {
    position: relative;
    float: right;
    border-radius: 8px;
    background-color: #bbb;
    font-family: arial;
    font-size: 8pt;
    font-weight: bold;
    text-align: center;
    display: inline-block;
    padding: 1px 5px;
    color: white;
    top: 2px;
}
@keyframes blink1 {
    0% { background-color : #bbb}
    50% { background-color : #ff9955}
    100% { background-color : #bbb}
}
@keyframes blink2 {
    0% { background-color : #bbb}
    50% { background-color : #ff9955}
    100% { background-color : #bbb}
}
.render-counter.odd {
    animation: blink1 1s ease;
}
.render-counter.even {
    animation: blink2 1s ease;
}
small {
    color: #999;
    font-size: 10pt;
    font-style: italic;
}
#reactjs-app {
    font-size: 16pt;
}
#reactjs-app small {
    color: white;
    padding-left: 10px;
}

body .github-fork-ribbon {
    background-color: cornflowerblue;
}

#devtools {
    color: black;
}

pre {
    background-color: #e9e9e9;
    padding: 20px;
}


================================================
FILE: docs/assets/getting-started-assets/javascripts/mobx-react.js
================================================
;(function() {
    function mrFactory(mobx, React, ReactDOM) {
        if (!mobx) throw new Error("mobx-react requires the MobX package")
        if (!React) throw new Error("mobx-react requires React to be available")

        var isDevtoolsEnabled = false

        // WeakMap<Node, Object>;
        var componentByNodeRegistery = typeof WeakMap !== "undefined" ? new WeakMap() : undefined
        var renderReporter = new mobx.SimpleEventEmitter()

        function findDOMNode(component) {
            if (ReactDOM) return ReactDOM.findDOMNode(component)
            return null
        }

        function reportRendering(component) {
            var node = findDOMNode(component)
            if (node) componentByNodeRegistery.set(node, component)

            renderReporter.emit({
                event: "render",
                renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
                totalTime: Date.now() - component.__$mobRenderStart,
                component: component,
                node: node
            })
        }

        var reactiveMixin = {
            componentWillMount: function() {
                // Generate friendly name for debugging
                var name = [
                    this.displayName ||
                        this.name ||
                        (this.constructor && this.constructor.name) ||
                        "<component>",
                    "#",
                    this._reactInternalInstance && this._reactInternalInstance._rootNodeID,
                    ".render()"
                ].join("")

                var baseRender = this.render.bind(this)
                var self = this
                var reaction = null
                var isRenderingPending = false

                function initialRender() {
                    reaction = new mobx.Reaction(name, function() {
                        if (!isRenderingPending) {
                            isRenderingPending = true
                            React.Component.prototype.forceUpdate.call(self)
                        }
                    })
                    reactiveRender.$mobx = reaction
                    self.render = reactiveRender
                    return reactiveRender()
                }

                function reactiveRender() {
                    isRenderingPending = false
                    var rendering
                    reaction.track(function() {
                        if (isDevtoolsEnabled) self.__$mobRenderStart = Date.now()
                        rendering = mobx.extras.allowStateChanges(false, baseRender)
                        if (isDevtoolsEnabled) self.__$mobRenderEnd = Date.now()
                    })
                    return rendering
                }

                this.render = initialRender
            },

            componentWillUnmount: function() {
                this.render.$mobx && this.render.$mobx.dispose()
                if (isDevtoolsEnabled) {
                    var node = findDOMNode(this)
                    if (node) {
                        componentByNodeRegistery.delete(node)
                    }
                    renderReporter.emit({
                        event: "destroy",
                        component: this,
                        node: node
                    })
                }
            },

            componentDidMount: function() {
                if (isDevtoolsEnabled) reportRendering(this)
            },

            componentDidUpdate: function() {
                if (isDevtoolsEnabled) reportRendering(this)
            },

            shouldComponentUpdate: function(nextProps, nextState) {
                // TODO: if context changed, return true.., see #18

                // if props or state did change, but a render was scheduled already, no additional render needs to be scheduled
                if (this.render.$mobx && this.render.$mobx.isScheduled() === true) return false

                // update on any state changes (as is the default)
                if (this.state !== nextState) return true
                // update if props are shallowly not equal, inspired by PureRenderMixin
                var keys = Object.keys(this.props)
                var key
                if (keys.length !== Object.keys(nextProps).length) return true
                for (var i = keys.length - 1; i >= 0, (key = keys[i]); i--) {
                    var newValue = nextProps[key]
                    if (newValue !== this.props[key]) {
                        return true
                    } else if (
                        newValue &&
                        typeof newValue === "object" &&
                        !mobx.isObservable(newValue)
                    ) {
                        /**
                         * If the newValue is still the same object, but that object is not observable,
                         * fallback to the default React behavior: update, because the object *might* have changed.
                         * If you need the non default behavior, just use the React pure render mixin, as that one
                         * will work fine with mobx as well, instead of the default implementation of
                         * observer.
                         */
                        return true
                    }
                }
                return false
            }
        }

        function patch(target, funcName) {
            var base = target[funcName]
            var mixinFunc = reactiveMixin[funcName]
            target[funcName] = function() {
                base && base.apply(this, arguments)
                mixinFunc.apply(this, arguments)
            }
        }

        function observer(componentClass) {
            // If it is function but doesn't seem to be a react class constructor,
            // wrap it to a react class automatically
            if (
                typeof componentClass === "function" &&
                !componentClass.prototype.render &&
                !componentClass.isReactClass &&
                !React.Component.isPrototypeOf(componentClass)
            ) {
                return observer(
                    React.createClass({
                        displayName: componentClass.displayName || componentClass.name,
                        propTypes: componentClass.propTypes,
                        contextTypes: componentClass.contextTypes,
                        getDefaultProps: function() {
                            return componentClass.defaultProps
                        },
                        render: function() {
                            return componentClass.call(this, this.props, this.context)
                        }
                    })
                )
            }

            if (!componentClass) throw new Error("Please pass a valid component to 'observer'")
            var target = componentClass.prototype || componentClass

            ;[
                "componentWillMount",
                "componentWillUnmount",
                "componentDidMount",
                "componentDidUpdate"
            ].forEach(function(funcName) {
                patch(target, funcName)
            })

            if (!target.shouldComponentUpdate)
                target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate
            componentClass.isMobXReactObserver = true
            return componentClass
        }

        function trackComponents() {
            if (typeof WeakMap === "undefined")
                throw new Error(
                    "[mobx-react] tracking components is not supported in this browser."
                )
            if (!isDevtoolsEnabled) isDevtoolsEnabled = true
        }

        return {
            observer: observer,
            reactiveComponent: function() {
                console.warn(
                    "[mobx-react] `reactiveComponent` has been renamed to `observer` and will be removed in 1.1."
                )
                return observer.apply(null, arguments)
            },
            renderReporter: renderReporter,
            componentByNodeRegistery: componentByNodeRegistery,
            trackComponents: trackComponents
        }
    }

    // UMD
    if (typeof define === "function" && define.amd) {
        define("mobx-react", ["mobx", "react", "react-dom"], mrFactory)
    } else if (typeof exports === "object") {
        module.exports = mrFactory(require("mobx"), require("react"), require("react-dom"))
    } else {
        this.mobxReact = mrFactory(this["mobx"], this["React"], this["ReactDOM"])
    }
})()



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/javascript/index.html
================================================
<!doctype html>

<title>CodeMirror: JavaScript mode</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="../../doc/docs.css">

<link rel="stylesheet" href="../../lib/codemirror.css">
<script src="../../lib/codemirror.js"></script>
<script src="../../addon/edit/matchbrackets.js"></script>
<script src="../../addon/comment/continuecomment.js"></script>
<script src="../../addon/comment/comment.js"></script>
<script src="javascript.js"></script>
<style type="text/css">.CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}</style>
<div id=nav>
  <a href="http://codemirror.net"><h1>CodeMirror</h1><img id=logo src="../../doc/logo.png"></a>

  <ul>
    <li><a href="../../index.html">Home</a>
    <li><a href="../../doc/manual.html">Manual</a>
    <li><a href="https://github.com/codemirror/codemirror">Code</a>
  </ul>
  <ul>
    <li><a href="../index.html">Language modes</a>
    <li><a class=active href="#">JavaScript</a>
  </ul>
</div>

<article>
<h2>JavaScript mode</h2>


<div><textarea id="code" name="code">
// Demo code (the actual new parser character stream implementation)

function StringStream(string) {
  this.pos = 0;
  this.string = string;
}

StringStream.prototype = {
  done: function() {return this.pos >= this.string.length;},
  peek: function() {return this.string.charAt(this.pos);},
  next: function() {
    if (this.pos &lt; this.string.length)
      return this.string.charAt(this.pos++);
  },
  eat: function(match) {
    var ch = this.string.charAt(this.pos);
    if (typeof match == "string") var ok = ch == match;
    else var ok = ch &amp;&amp; match.test ? match.test(ch) : match(ch);
    if (ok) {this.pos++; return ch;}
  },
  eatWhile: function(match) {
    var start = this.pos;
    while (this.eat(match));
    if (this.pos > start) return this.string.slice(start, this.pos);
  },
  backUp: function(n) {this.pos -= n;},
  column: function() {return this.pos;},
  eatSpace: function() {
    var start = this.pos;
    while (/\s/.test(this.string.charAt(this.pos))) this.pos++;
    return this.pos - start;
  },
  match: function(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}
      if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
        if (consume !== false) this.pos += str.length;
        return true;
      }
    }
    else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match &amp;&amp; consume !== false) this.pos += match[0].length;
      return match;
    }
  }
};
</textarea></div>

    <script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        matchBrackets: true,
        continueComments: "Enter",
        extraKeys: {"Ctrl-Q": "toggleComment"}
      });
    </script>

    <p>
      JavaScript mode supports several configuration options:
      <ul>
        <li><code>json</code> which will set the mode to expect JSON
        data rather than a JavaScript program.</li>
        <li><code>jsonld</code> which will set the mode to expect
        <a href="http://json-ld.org">JSON-LD</a> linked data rather
        than a JavaScript program (<a href="json-ld.html">demo</a>).</li>
        <li><code>typescript</code> which will activate additional
        syntax highlighting and some other things for TypeScript code
        (<a href="typescript.html">demo</a>).</li>
        <li><code>statementIndent</code> which (given a number) will
        determine the amount of indentation to use for statements
        continued on a new line.</li>
        <li><code>wordCharacters</code>, a regexp that indicates which
        characters should be considered part of an identifier.
        Defaults to <code>/[\w$]/</code>, which does not handle
        non-ASCII identifiers. Can be set to something more elaborate
        to improve Unicode support.</li>
      </ul>
    </p>

    <p><strong>MIME types defined:</strong> <code>text/javascript</code>, <code>application/json</code>, <code>application/ld+json</code>, <code>text/typescript</code>, <code>application/typescript</code>.</p>
  </article>



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/javascript/javascript.js
================================================
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

;(function(mod) {
    if (typeof exports == "object" && typeof module == "object")
        // CommonJS
        mod(require("../../lib/codemirror"))
    else if (typeof define == "function" && define.amd)
        // AMD
        define(["../../lib/codemirror"], mod)
    // Plain browser env
    else mod(CodeMirror)
})(function(CodeMirror) {
    "use strict"

    CodeMirror.defineMode("javascript", function(config, parserConfig) {
        var indentUnit = config.indentUnit
        var statementIndent = parserConfig.statementIndent
        var jsonldMode = parserConfig.jsonld
        var jsonMode = parserConfig.json || jsonldMode
        var isTS = parserConfig.typescript
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/

        // Tokenizer

        var keywords = (function() {
            function kw(type) {
                return { type: type, style: "keyword" }
            }
            var A = kw("keyword a"),
                B = kw("keyword b"),
                C = kw("keyword c")
            var operator = kw("operator"),
                atom = { type: "atom", style: "atom" }

            var jsKeywords = {
                if: kw("if"),
                while: A,
                with: A,
                else: B,
                do: B,
                try: B,
                finally: B,
                return: C,
                break: C,
                continue: C,
                new: C,
                delete: C,
                throw: C,
                debugger: C,
                var: kw("var"),
                const: kw("var"),
                let: kw("var"),
                function: kw("function"),
                catch: kw("catch"),
                for: kw("for"),
                switch: kw("switch"),
                case: kw("case"),
                default: kw("default"),
                in: operator,
                typeof: operator,
                instanceof: operator,
                true: atom,
                false: atom,
                null: atom,
                undefined: atom,
                NaN: atom,
                Infinity: atom,
                this: kw("this"),
                module: kw("module"),
                class: kw("class"),
                super: kw("atom"),
                yield: C,
                export: kw("export"),
                import: kw("import"),
                extends: C
            }

            // Extend the 'normal' keywords with the TypeScript language extensions
            if (isTS) {
                var type = { type: "variable", style: "variable-3" }
                var tsKeywords = {
                    // object-like things
                    interface: kw("interface"),
                    extends: kw("extends"),
                    constructor: kw("constructor"),

                    // scope modifiers
                    public: kw("public"),
                    private: kw("private"),
                    protected: kw("protected"),
                    static: kw("static"),

                    // types
                    string: type,
                    number: type,
                    bool: type,
                    any: type
                }

                for (var attr in tsKeywords) {
                    jsKeywords[attr] = tsKeywords[attr]
                }
            }

            return jsKeywords
        })()

        var isOperatorChar = /[+\-*&%=<>!?|~^]/
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/

        function readRegexp(stream) {
            var escaped = false,
                next,
                inSet = false
            while ((next = stream.next()) != null) {
                if (!escaped) {
                    if (next == "/" && !inSet) return
                    if (next == "[") inSet = true
                    else if (inSet && next == "]") inSet = false
                }
                escaped = !escaped && next == "\\"
            }
        }

        // Used as scratch variables to communicate multiple values without
        // consing up tons of objects.
        var type, content
        function ret(tp, style, cont) {
            type = tp
            content = cont
            return style
        }
        function tokenBase(stream, state) {
            var ch = stream.next()
            if (ch == '"' || ch == "'") {
                state.tokenize = tokenString(ch)
                return state.tokenize(stream, state)
            } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
                return ret("number", "number")
            } else if (ch == "." && stream.match("..")) {
                return ret("spread", "meta")
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
                return ret(ch)
            } else if (ch == "=" && stream.eat(">")) {
                return ret("=>", "operator")
            } else if (ch == "0" && stream.eat(/x/i)) {
                stream.eatWhile(/[\da-f]/i)
                return ret("number", "number")
            } else if (/\d/.test(ch)) {
                stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/)
                return ret("number", "number")
            } else if (ch == "/") {
                if (stream.eat("*")) {
                    state.tokenize = tokenComment
                    return tokenComment(stream, state)
                } else if (stream.eat("/")) {
                    stream.skipToEnd()
                    return ret("comment", "comment")
                } else if (
                    state.lastType == "operator" ||
                    state.lastType == "keyword c" ||
                    state.lastType == "sof" ||
                    /^[\[{}\(,;:]$/.test(state.lastType)
                ) {
                    readRegexp(stream)
                    stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/)
                    return ret("regexp", "string-2")
                } else {
                    stream.eatWhile(isOperatorChar)
                    return ret("operator", "operator", stream.current())
                }
            } else if (ch == "`") {
                state.tokenize = tokenQuasi
                return tokenQuasi(stream, state)
            } else if (ch == "#") {
                stream.skipToEnd()
                return ret("error", "error")
            } else if (isOperatorChar.test(ch)) {
                stream.eatWhile(isOperatorChar)
                return ret("operator", "operator", stream.current())
            } else if (wordRE.test(ch)) {
                stream.eatWhile(wordRE)
                var word = stream.current(),
                    known = keywords.propertyIsEnumerable(word) && keywords[word]
                return known && state.lastType != "."
                    ? ret(known.type, known.style, word)
                    : ret("variable", "variable", word)
            }
        }

        function tokenString(quote) {
            return function(stream, state) {
                var escaped = false,
                    next
                if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
                    state.tokenize = tokenBase
                    return ret("jsonld-keyword", "meta")
                }
                while ((next = stream.next()) != null) {
                    if (next == quote && !escaped) break
                    escaped = !escaped && next == "\\"
                }
                if (!escaped) state.tokenize = tokenBase
                return ret("string", "string")
            }
        }

        function tokenComment(stream, state) {
            var maybeEnd = false,
                ch
            while ((ch = stream.next())) {
                if (ch == "/" && maybeEnd) {
                    state.tokenize = tokenBase
                    break
                }
                maybeEnd = ch == "*"
            }
            return ret("comment", "comment")
        }

        function tokenQuasi(stream, state) {
            var escaped = false,
                next
            while ((next = stream.next()) != null) {
                if (!escaped && (next == "`" || (next == "$" && stream.eat("{")))) {
                    state.tokenize = tokenBase
                    break
                }
                escaped = !escaped && next == "\\"
            }
            return ret("quasi", "string-2", stream.current())
        }

        var brackets = "([{}])"
        // This is a crude lookahead trick to try and notice that we're
        // parsing the argument patterns for a fat-arrow function before we
        // actually hit the arrow token. It only works if the arrow is on
        // the same line as the arguments and there's no strange noise
        // (comments) in between. Fallback is to only notice when we hit the
        // arrow, and not declare the arguments as locals for the arrow
        // body.
        function findFatArrow(stream, state) {
            if (state.fatArrowAt) state.fatArrowAt = null
            var arrow = stream.string.indexOf("=>", stream.start)
            if (arrow < 0) return

            var depth = 0,
                sawSomething = false
            for (var pos = arrow - 1; pos >= 0; --pos) {
                var ch = stream.string.charAt(pos)
                var bracket = brackets.indexOf(ch)
                if (bracket >= 0 && bracket < 3) {
                    if (!depth) {
                        ++pos
                        break
                    }
                    if (--depth == 0) break
                } else if (bracket >= 3 && bracket < 6) {
                    ++depth
                } else if (wordRE.test(ch)) {
                    sawSomething = true
                } else if (/["'\/]/.test(ch)) {
                    return
                } else if (sawSomething && !depth) {
                    ++pos
                    break
                }
            }
            if (sawSomething && !depth) state.fatArrowAt = pos
        }

        // Parser

        var atomicTypes = {
            atom: true,
            number: true,
            variable: true,
            string: true,
            regexp: true,
            this: true,
            "jsonld-keyword": true
        }

        function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented
            this.column = column
            this.type = type
            this.prev = prev
            this.info = info
            if (align != null) this.align = align
        }

        function inScope(state, varname) {
            for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true
            for (var cx = state.context; cx; cx = cx.prev) {
                for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true
            }
        }

        function parseJS(state, style, type, content, stream) {
            var cc = state.cc
            // Communicate our context to the combinators.
            // (Less wasteful than consing up a hundred closures on every call.)
            cx.state = state
            cx.stream = stream
            ;(cx.marked = null), (cx.cc = cc)
            cx.style = style

            if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true

            while (true) {
                var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement
                if (combinator(type, content)) {
                    while (cc.length && cc[cc.length - 1].lex) cc.pop()()
                    if (cx.marked) return cx.marked
                    if (type == "variable" && inScope(state, content)) return "variable-2"
                    return style
                }
            }
        }

        // Combinator utils

        var cx = { state: null, column: null, marked: null, cc: null }
        function pass() {
            for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i])
        }
        function cont() {
            pass.apply(null, arguments)
            return true
        }
        function register(varname) {
            function inList(list) {
                for (var v = list; v; v = v.next) if (v.name == varname) return true
                return false
            }
            var state = cx.state
            if (state.context) {
                cx.marked = "def"
                if (inList(state.localVars)) return
                state.localVars = { name: varname, next: state.localVars }
            } else {
                if (inList(state.globalVars)) return
                if (parserConfig.globalVars)
                    state.globalVars = { name: varname, next: state.globalVars }
            }
        }

        // Combinators

        var defaultVars = { name: "this", next: { name: "arguments" } }
        function pushcontext() {
            cx.state.context = { prev: cx.state.context, vars: cx.state.localVars }
            cx.state.localVars = defaultVars
        }
        function popcontext() {
            cx.state.localVars = cx.state.context.vars
            cx.state.context = cx.state.context.prev
        }
        function pushlex(type, info) {
            var result = function() {
                var state = cx.state,
                    indent = state.indented
                if (state.lexical.type == "stat") indent = state.lexical.indented
                else
                    for (
                        var outer = state.lexical;
                        outer && outer.type == ")" && outer.align;
                        outer = outer.prev
                    )
                        indent = outer.indented
                state.lexical = new JSLexical(
                    indent,
                    cx.stream.column(),
                    type,
                    null,
                    state.lexical,
                    info
                )
            }
            result.lex = true
            return result
        }
        function poplex() {
            var state = cx.state
            if (state.lexical.prev) {
                if (state.lexical.type == ")") state.indented = state.lexical.indented
                state.lexical = state.lexical.prev
            }
        }
        poplex.lex = true

        function expect(wanted) {
            function exp(type) {
                if (type == wanted) return cont()
                else if (wanted == ";") return pass()
                else return cont(exp)
            }
            return exp
        }

        function statement(type, value) {
            if (type == "var")
                return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex)
            if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex)
            if (type == "keyword b") return cont(pushlex("form"), statement, poplex)
            if (type == "{") return cont(pushlex("}"), block, poplex)
            if (type == ";") return cont()
            if (type == "if") {
                if (
                    cx.state.lexical.info == "else" &&
                    cx.state.cc[cx.state.cc.length - 1] == poplex
                )
                    cx.state.cc.pop()()
                return cont(pushlex("form"), expression, statement, poplex, maybeelse)
            }
            if (type == "function") return cont(functiondef)
            if (type == "for") return cont(pushlex("form"), forspec, statement, poplex)
            if (type == "variable") return cont(pushlex("stat"), maybelabel)
            if (type == "switch")
                return cont(
                    pushlex("form"),
                    expression,
                    pushlex("}", "switch"),
                    expect("{"),
                    block,
                    poplex,
                    poplex
                )
            if (type == "case") return cont(expression, expect(":"))
            if (type == "default") return cont(expect(":"))
            if (type == "catch")
                return cont(
                    pushlex("form"),
                    pushcontext,
                    expect("("),
                    funarg,
                    expect(")"),
                    statement,
                    poplex,
                    popcontext
                )
            if (type == "module")
                return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex)
            if (type == "class") return cont(pushlex("form"), className, poplex)
            if (type == "export") return cont(pushlex("form"), afterExport, poplex)
            if (type == "import") return cont(pushlex("form"), afterImport, poplex)
            return pass(pushlex("stat"), expression, expect(";"), poplex)
        }
        function expression(type) {
            return expressionInner(type, false)
        }
        function expressionNoComma(type) {
            return expressionInner(type, true)
        }
        function expressionInner(type, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
                var body = noComma ? arrowBodyNoComma : arrowBody
                if (type == "(")
                    return cont(
                        pushcontext,
                        pushlex(")"),
                        commasep(pattern, ")"),
                        poplex,
                        expect("=>"),
                        body,
                        popcontext
                    )
                else if (type == "variable")
                    return pass(pushcontext, pattern, expect("=>"), body, popcontext)
            }

            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma
            if (atomicTypes.hasOwnProperty(type)) return cont(maybeop)
            if (type == "function") return cont(functiondef, maybeop)
            if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression)
            if (type == "(")
                return cont(
                    pushlex(")"),
                    maybeexpression,
                    comprehension,
                    expect(")"),
                    poplex,
                    maybeop
                )
            if (type == "operator" || type == "spread")
                return cont(noComma ? expressionNoComma : expression)
            if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop)
            if (type == "{") return contCommasep(objprop, "}", null, maybeop)
            if (type == "quasi") {
                return pass(quasi, maybeop)
            }
            return cont()
        }
        function maybeexpression(type) {
            if (type.match(/[;\}\)\],]/)) return pass()
            return pass(expression)
        }
        function maybeexpressionNoComma(type) {
            if (type.match(/[;\}\)\],]/)) return pass()
            return pass(expressionNoComma)
        }

        function maybeoperatorComma(type, value) {
            if (type == ",") return cont(expression)
            return maybeoperatorNoComma(type, value, false)
        }
        function maybeoperatorNoComma(type, value, noComma) {
            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma
            var expr = noComma == false ? expression : expressionNoComma
            if (type == "=>")
                return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext)
            if (type == "operator") {
                if (/\+\+|--/.test(value)) return cont(me)
                if (value == "?") return cont(expression, expect(":"), expr)
                return cont(expr)
            }
            if (type == "quasi") {
                return pass(quasi, me)
            }
            if (type == ";") return
            if (type == "(") return contCommasep(expressionNoComma, ")", "call", me)
            if (type == ".") return cont(property, me)
            if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me)
        }
        function quasi(type, value) {
            if (type != "quasi") return pass()
            if (value.slice(value.length - 2) != "${") return cont(quasi)
            return cont(expression, continueQuasi)
        }
        function continueQuasi(type) {
            if (type == "}") {
                cx.marked = "string-2"
                cx.state.tokenize = tokenQuasi
                return cont(quasi)
            }
        }
        function arrowBody(type) {
            findFatArrow(cx.stream, cx.state)
            return pass(type == "{" ? statement : expression)
        }
        function arrowBodyNoComma(type) {
            findFatArrow(cx.stream, cx.state)
            return pass(type == "{" ? statement : expressionNoComma)
        }
        function maybelabel(type) {
            if (type == ":") return cont(poplex, statement)
            return pass(maybeoperatorComma, expect(";"), poplex)
        }
        function property(type) {
            if (type == "variable") {
                cx.marked = "property"
                return cont()
            }
        }
        function objprop(type, value) {
            if (type == "variable" || cx.style == "keyword") {
                cx.marked = "property"
                if (value == "get" || value == "set") return cont(getterSetter)
                return cont(afterprop)
            } else if (type == "number" || type == "string") {
                cx.marked = jsonldMode ? "property" : cx.style + " property"
                return cont(afterprop)
            } else if (type == "jsonld-keyword") {
                return cont(afterprop)
            } else if (type == "[") {
                return cont(expression, expect("]"), afterprop)
            }
        }
        function getterSetter(type) {
            if (type != "variable") return pass(afterprop)
            cx.marked = "property"
            return cont(functiondef)
        }
        function afterprop(type) {
            if (type == ":") return cont(expressionNoComma)
            if (type == "(") return pass(functiondef)
        }
        function commasep(what, end) {
            function proceed(type) {
                if (type == ",") {
                    var lex = cx.state.lexical
                    if (lex.info == "call") lex.pos = (lex.pos || 0) + 1
                    return cont(what, proceed)
                }
                if (type == end) return cont()
                return cont(expect(end))
            }
            return function(type) {
                if (type == end) return cont()
                return pass(what, proceed)
            }
        }
        function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i])
            return cont(pushlex(end, info), commasep(what, end), poplex)
        }
        function block(type) {
            if (type == "}") return cont()
            return pass(statement, block)
        }
        function maybetype(type) {
            if (isTS && type == ":") return cont(typedef)
        }
        function maybedefault(_, value) {
            if (value == "=") return cont(expressionNoComma)
        }
        function typedef(type) {
            if (type == "variable") {
                cx.marked = "variable-3"
                return cont()
            }
        }
        function vardef() {
            return pass(pattern, maybetype, maybeAssign, vardefCont)
        }
        function pattern(type, value) {
            if (type == "variable") {
                register(value)
                return cont()
            }
            if (type == "[") return contCommasep(pattern, "]")
            if (type == "{") return contCommasep(proppattern, "}")
        }
        function proppattern(type, value) {
            if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
                register(value)
                return cont(maybeAssign)
            }
            if (type == "variable") cx.marked = "property"
            return cont(expect(":"), pattern, maybeAssign)
        }
        function maybeAssign(_type, value) {
            if (value == "=") return cont(expressionNoComma)
        }
        function vardefCont(type) {
            if (type == ",") return cont(vardef)
        }
        function maybeelse(type, value) {
            if (type == "keyword b" && value == "else")
                return cont(pushlex("form", "else"), statement, poplex)
        }
        function forspec(type) {
            if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex)
        }
        function forspec1(type) {
            if (type == "var") return cont(vardef, expect(";"), forspec2)
            if (type == ";") return cont(forspec2)
            if (type == "variable") return cont(formaybeinof)
            return pass(expression, expect(";"), forspec2)
        }
        function formaybeinof(_type, value) {
            if (value == "in" || value == "of") {
                cx.marked = "keyword"
                return cont(expression)
            }
            return cont(maybeoperatorComma, forspec2)
        }
        function forspec2(type, value) {
            if (type == ";") return cont(forspec3)
            if (value == "in" || value == "of") {
                cx.marked = "keyword"
                return cont(expression)
            }
            return pass(expression, expect(";"), forspec3)
        }
        function forspec3(type) {
            if (type != ")") cont(expression)
        }
        function functiondef(type, value) {
            if (value == "*") {
                cx.marked = "keyword"
                return cont(functiondef)
            }
            if (type == "variable") {
                register(value)
                return cont(functiondef)
            }
            if (type == "(")
                return cont(
                    pushcontext,
                    pushlex(")"),
                    commasep(funarg, ")"),
                    poplex,
                    statement,
                    popcontext
                )
        }
        function funarg(type) {
            if (type == "spread") return cont(funarg)
            return pass(pattern, maybetype, maybedefault)
        }
        function className(type, value) {
            if (type == "variable") {
                register(value)
                return cont(classNameAfter)
            }
        }
        function classNameAfter(type, value) {
            if (value == "extends") return cont(expression, classNameAfter)
            if (type == "{") return cont(pushlex("}"), classBody, poplex)
        }
        function classBody(type, value) {
            if (type == "variable" || cx.style == "keyword") {
                if (value == "static") {
                    cx.marked = "keyword"
                    return cont(classBody)
                }
                cx.marked = "property"
                if (value == "get" || value == "set")
                    return cont(classGetterSetter, functiondef, classBody)
                return cont(functiondef, classBody)
            }
            if (value == "*") {
                cx.marked = "keyword"
                return cont(classBody)
            }
            if (type == ";") return cont(classBody)
            if (type == "}") return cont()
        }
        function classGetterSetter(type) {
            if (type != "variable") return pass()
            cx.marked = "property"
            return cont()
        }
        function afterModule(type, value) {
            if (type == "string") return cont(statement)
            if (type == "variable") {
                register(value)
                return cont(maybeFrom)
            }
        }
        function afterExport(_type, value) {
            if (value == "*") {
                cx.marked = "keyword"
                return cont(maybeFrom, expect(";"))
            }
            if (value == "default") {
                cx.marked = "keyword"
                return cont(expression, expect(";"))
            }
            return pass(statement)
        }
        function afterImport(type) {
            if (type == "string") return cont()
            return pass(importSpec, maybeFrom)
        }
        function importSpec(type, value) {
            if (type == "{") return contCommasep(importSpec, "}")
            if (type == "variable") register(value)
            if (value == "*") cx.marked = "keyword"
            return cont(maybeAs)
        }
        function maybeAs(_type, value) {
            if (value == "as") {
                cx.marked = "keyword"
                return cont(importSpec)
            }
        }
        function maybeFrom(_type, value) {
            if (value == "from") {
                cx.marked = "keyword"
                return cont(expression)
            }
        }
        function arrayLiteral(type) {
            if (type == "]") return cont()
            return pass(expressionNoComma, maybeArrayComprehension)
        }
        function maybeArrayComprehension(type) {
            if (type == "for") return pass(comprehension, expect("]"))
            if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"))
            return pass(commasep(expressionNoComma, "]"))
        }
        function comprehension(type) {
            if (type == "for") return cont(forspec, comprehension)
            if (type == "if") return cont(expression, comprehension)
        }

        function isContinuedStatement(state, textAfter) {
            return (
                state.lastType == "operator" ||
                state.lastType == "," ||
                isOperatorChar.test(textAfter.charAt(0)) ||
                /[,.]/.test(textAfter.charAt(0))
            )
        }

        // Interface

        return {
            startState: function(basecolumn) {
                var state = {
                    tokenize: tokenBase,
                    lastType: "sof",
                    cc: [],
                    lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                    localVars: parserConfig.localVars,
                    context: parserConfig.localVars && { vars: parserConfig.localVars },
                    indented: 0
                }
                if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
                    state.globalVars = parserConfig.globalVars
                return state
            },

            token: function(stream, state) {
                if (stream.sol()) {
                    if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false
                    state.indented = stream.indentation()
                    findFatArrow(stream, state)
                }
                if (state.tokenize != tokenComment && stream.eatSpace()) return null
                var style = state.tokenize(stream, state)
                if (type == "comment") return style
                state.lastType =
                    type == "operator" && (content == "++" || content == "--") ? "incdec" : type
                return parseJS(state, style, type, content, stream)
            },

            indent: function(state, textAfter) {
                if (state.tokenize == tokenComment) return CodeMirror.Pass
                if (state.tokenize != tokenBase) return 0
                var firstChar = textAfter && textAfter.charAt(0),
                    lexical = state.lexical
                // Kludge to prevent 'maybelse' from blocking lexical scope pops
                if (!/^\s*else\b/.test(textAfter))
                    for (var i = state.cc.length - 1; i >= 0; --i) {
                        var c = state.cc[i]
                        if (c == poplex) lexical = lexical.prev
                        else if (c != maybeelse) break
                    }
                if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev
                if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
                    lexical = lexical.prev
                var type = lexical.type,
                    closing = firstChar == type

                if (type == "vardef")
                    return (
                        lexical.indented +
                        (state.lastType == "operator" || state.lastType == ","
                            ? lexical.info + 1
                            : 0)
                    )
                else if (type == "form" && firstChar == "{") return lexical.indented
                else if (type == "form") return lexical.indented + indentUnit
                else if (type == "stat")
                    return (
                        lexical.indented +
                        (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0)
                    )
                else if (
                    lexical.info == "switch" &&
                    !closing &&
                    parserConfig.doubleIndentSwitch != false
                )
                    return (
                        lexical.indented +
                        (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit)
                    )
                else if (lexical.align) return lexical.column + (closing ? 0 : 1)
                else return lexical.indented + (closing ? 0 : indentUnit)
            },

            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : "/*",
            blockCommentEnd: jsonMode ? null : "*/",
            lineComment: jsonMode ? null : "//",
            fold: "brace",
            closeBrackets: "()[]{}''\"\"``",

            helperType: jsonMode ? "json" : "javascript",
            jsonldMode: jsonldMode,
            jsonMode: jsonMode
        }
    })

    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/)

    CodeMirror.defineMIME("text/javascript", "javascript")
    CodeMirror.defineMIME("text/ecmascript", "javascript")
    CodeMirror.defineMIME("application/javascript", "javascript")
    CodeMirror.defineMIME("application/x-javascript", "javascript")
    CodeMirror.defineMIME("application/ecmascript", "javascript")
    CodeMirror.defineMIME("application/json", { name: "javascript", json: true })
    CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true })
    CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true })
    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true })
    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true })
})



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/javascript/json-ld.html
================================================
<!doctype html>

<title>CodeMirror: JSON-LD mode</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="../../doc/docs.css">

<link rel="stylesheet" href="../../lib/codemirror.css">
<script src="../../lib/codemirror.js"></script>
<script src="../../addon/edit/matchbrackets.js"></script>
<script src="../../addon/comment/continuecomment.js"></script>
<script src="../../addon/comment/comment.js"></script>
<script src="javascript.js"></script>
<style type="text/css">.CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}</style>
<div id="nav">
  <a href="http://codemirror.net"><h1>CodeMirror</h1><img id=logo src="../../doc/logo.png"/></a>

  <ul>
    <li><a href="../../index.html">Home</a>
    <li><a href="../../doc/manual.html">Manual</a>
    <li><a href="https://github.com/codemirror/codemirror">Code</a>
  </ul>
  <ul>
    <li><a href="../index.html">Language modes</a>
    <li><a class=active href="#">JSON-LD</a>
  </ul>
</div>

<article>
<h2>JSON-LD mode</h2>


<div><textarea id="code" name="code">
{
  "@context": {
    "name": "http://schema.org/name",
    "description": "http://schema.org/description",
    "image": {
      "@id": "http://schema.org/image",
      "@type": "@id"
    },
    "geo": "http://schema.org/geo",
    "latitude": {
      "@id": "http://schema.org/latitude",
      "@type": "xsd:float"
    },
    "longitude": {
      "@id": "http://schema.org/longitude",
      "@type": "xsd:float"
    },
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "name": "The Empire State Building",
  "description": "The Empire State Building is a 102-story landmark in New York City.",
  "image": "http://www.civil.usherbrooke.ca/cours/gci215a/empire-state-building.jpg",
  "geo": {
    "latitude": "40.75",
    "longitude": "73.98"
  }
}
</textarea></div>

    <script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        matchBrackets: true,
        autoCloseBrackets: true,
        mode: "application/ld+json",
        lineWrapping: true
      });
    </script>
    
    <p>This is a specialization of the <a href="index.html">JavaScript mode</a>.</p>
  </article>



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/javascript/test.js
================================================
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

;(function() {
    var mode = CodeMirror.getMode({ indentUnit: 2 }, "javascript")
    function MT(name) {
        test.mode(name, mode, Array.prototype.slice.call(arguments, 1))
    }

    MT(
        "locals",
        "[keyword function] [variable foo]([def a], [def b]) { [keyword var] [def c] [operator =] [number 10]; [keyword return] [variable-2 a] [operator +] [variable-2 c] [operator +] [variable d]; }"
    )

    MT(
        "comma-and-binop",
        "[keyword function](){ [keyword var] [def x] [operator =] [number 1] [operator +] [number 2], [def y]; }"
    )

    MT(
        "destructuring",
        "([keyword function]([def a], [[[def b], [def c] ]]) {",
        "  [keyword let] {[def d], [property foo]: [def c][operator =][number 10], [def x]} [operator =] [variable foo]([variable-2 a]);",
        "  [[[variable-2 c], [variable y] ]] [operator =] [variable-2 c];",
        "})();"
    )

    MT(
        "class_body",
        "[keyword class] [variable Foo] {",
        "  [property constructor]() {}",
        "  [property sayName]() {",
        "    [keyword return] [string-2 `foo${][variable foo][string-2 }oo`];",
        "  }",
        "}"
    )

    MT(
        "class",
        "[keyword class] [variable Point] [keyword extends] [variable SuperThing] {",
        "  [property get] [property prop]() { [keyword return] [number 24]; }",
        "  [property constructor]([def x], [def y]) {",
        "    [keyword super]([string 'something']);",
        "    [keyword this].[property x] [operator =] [variable-2 x];",
        "  }",
        "}"
    )

    MT(
        "module",
        "[keyword module] [string 'foo'] {",
        "  [keyword export] [keyword let] [def x] [operator =] [number 42];",
        "  [keyword export] [keyword *] [keyword from] [string 'somewhere'];",
        "}"
    )

    MT(
        "import",
        "[keyword function] [variable foo]() {",
        "  [keyword import] [def $] [keyword from] [string 'jquery'];",
        "  [keyword module] [def crypto] [keyword from] [string 'crypto'];",
        "  [keyword import] { [def encrypt], [def decrypt] } [keyword from] [string 'crypto'];",
        "}"
    )

    MT(
        "const",
        "[keyword function] [variable f]() {",
        "  [keyword const] [[ [def a], [def b] ]] [operator =] [[ [number 1], [number 2] ]];",
        "}"
    )

    MT("for/of", "[keyword for]([keyword let] [variable of] [keyword of] [variable something]) {}")

    MT(
        "generator",
        "[keyword function*] [variable repeat]([def n]) {",
        "  [keyword for]([keyword var] [def i] [operator =] [number 0]; [variable-2 i] [operator <] [variable-2 n]; [operator ++][variable-2 i])",
        "    [keyword yield] [variable-2 i];",
        "}"
    )

    MT(
        "quotedStringAddition",
        "[keyword let] [variable f] [operator =] [variable a] [operator +] [string 'fatarrow'] [operator +] [variable c];"
    )

    MT(
        "quotedFatArrow",
        "[keyword let] [variable f] [operator =] [variable a] [operator +] [string '=>'] [operator +] [variable c];"
    )

    MT(
        "fatArrow",
        "[variable array].[property filter]([def a] [operator =>] [variable-2 a] [operator +] [number 1]);",
        "[variable a];", // No longer in scope
        "[keyword let] [variable f] [operator =] ([[ [def a], [def b] ]], [def c]) [operator =>] [variable-2 a] [operator +] [variable-2 c];",
        "[variable c];"
    )

    MT(
        "spread",
        "[keyword function] [variable f]([def a], [meta ...][def b]) {",
        "  [variable something]([variable-2 a], [meta ...][variable-2 b]);",
        "}"
    )

    MT(
        "comprehension",
        "[keyword function] [variable f]() {",
        "  [[([variable x] [operator +] [number 1]) [keyword for] ([keyword var] [def x] [keyword in] [variable y]) [keyword if] [variable pred]([variable-2 x]) ]];",
        "  ([variable u] [keyword for] ([keyword var] [def u] [keyword of] [variable generateValues]()) [keyword if] ([variable-2 u].[property color] [operator ===] [string 'blue']));",
        "}"
    )

    MT(
        "quasi",
        "[variable re][string-2 `fofdlakj${][variable x] [operator +] ([variable re][string-2 `foo`]) [operator +] [number 1][string-2 }fdsa`] [operator +] [number 2]"
    )

    MT(
        "quasi_no_function",
        "[variable x] [operator =] [string-2 `fofdlakj${][variable x] [operator +] [string-2 `foo`] [operator +] [number 1][string-2 }fdsa`] [operator +] [number 2]"
    )

    MT(
        "indent_statement",
        "[keyword var] [variable x] [operator =] [number 10]",
        "[variable x] [operator +=] [variable y] [operator +]",
        "  [atom Infinity]",
        "[keyword debugger];"
    )

    MT(
        "indent_if",
        "[keyword if] ([number 1])",
        "  [keyword break];",
        "[keyword else] [keyword if] ([number 2])",
        "  [keyword continue];",
        "[keyword else]",
        "  [number 10];",
        "[keyword if] ([number 1]) {",
        "  [keyword break];",
        "} [keyword else] [keyword if] ([number 2]) {",
        "  [keyword continue];",
        "} [keyword else] {",
        "  [number 10];",
        "}"
    )

    MT(
        "indent_for",
        "[keyword for] ([keyword var] [variable i] [operator =] [number 0];",
        "     [variable i] [operator <] [number 100];",
        "     [variable i][operator ++])",
        "  [variable doSomething]([variable i]);",
        "[keyword debugger];"
    )

    MT("indent_c_style", "[keyword function] [variable foo]()", "{", "  [keyword debugger];", "}")

    MT(
        "indent_else",
        "[keyword for] (;;)",
        "  [keyword if] ([variable foo])",
        "    [keyword if] ([variable bar])",
        "      [number 1];",
        "    [keyword else]",
        "      [number 2];",
        "  [keyword else]",
        "    [number 3];"
    )

    MT(
        "indent_funarg",
        "[variable foo]([number 10000],",
        "    [keyword function]([def a]) {",
        "  [keyword debugger];",
        "};"
    )

    MT(
        "indent_below_if",
        "[keyword for] (;;)",
        "  [keyword if] ([variable foo])",
        "    [number 1];",
        "[number 2];"
    )

    MT(
        "multilinestring",
        "[keyword var] [variable x] [operator =] [string 'foo\\]",
        "[string bar'];"
    )

    MT("scary_regexp", "[string-2 /foo[[/]]bar/];")

    MT(
        "indent_strange_array",
        "[keyword var] [variable x] [operator =] [[",
        "  [number 1],,",
        "  [number 2],",
        "]];",
        "[number 10];"
    )

    MT(
        "param_default",
        "[keyword function] [variable foo]([def x] [operator =] [string-2 `foo${][number 10][string-2 }bar`]) {",
        "  [keyword return] [variable-2 x];",
        "}"
    )

    var jsonld_mode = CodeMirror.getMode({ indentUnit: 2 }, { name: "javascript", jsonld: true })
    function LD(name) {
        test.mode(name, jsonld_mode, Array.prototype.slice.call(arguments, 1))
    }

    LD(
        "json_ld_keywords",
        "{",
        '  [meta "@context"]: {',
        '    [meta "@base"]: [string "http://example.com"],',
        '    [meta "@vocab"]: [string "http://xmlns.com/foaf/0.1/"],',
        '    [property "likesFlavor"]: {',
        '      [meta "@container"]: [meta "@list"]',
        '      [meta "@reverse"]: [string "@beFavoriteOf"]',
        "    },",
        '    [property "nick"]: { [meta "@container"]: [meta "@set"] },',
        '    [property "nick"]: { [meta "@container"]: [meta "@index"] }',
        "  },",
        '  [meta "@graph"]: [[ {',
        '    [meta "@id"]: [string "http://dbpedia.org/resource/John_Lennon"],',
        '    [property "name"]: [string "John Lennon"],',
        '    [property "modified"]: {',
        '      [meta "@value"]: [string "2010-05-29T14:17:39+02:00"],',
        '      [meta "@type"]: [string "http://www.w3.org/2001/XMLSchema#dateTime"]',
        "    }",
        "  } ]]",
        "}"
    )

    LD(
        "json_ld_fake",
        "{",
        '  [property "@fake"]: [string "@fake"],',
        '  [property "@contextual"]: [string "@identifier"],',
        '  [property "user@domain.com"]: [string "@graphical"],',
        '  [property "@ID"]: [string "@@ID"]',
        "}"
    )
})()



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/javascript/typescript.html
================================================
<!doctype html>

<title>CodeMirror: TypeScript mode</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="../../doc/docs.css">

<link rel="stylesheet" href="../../lib/codemirror.css">
<script src="../../lib/codemirror.js"></script>
<script src="javascript.js"></script>
<style type="text/css">.CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}</style>
<div id=nav>
  <a href="http://codemirror.net"><h1>CodeMirror</h1><img id=logo src="../../doc/logo.png"></a>

  <ul>
    <li><a href="../../index.html">Home</a>
    <li><a href="../../doc/manual.html">Manual</a>
    <li><a href="https://github.com/codemirror/codemirror">Code</a>
  </ul>
  <ul>
    <li><a href="../index.html">Language modes</a>
    <li><a class=active href="#">TypeScript</a>
  </ul>
</div>

<article>
<h2>TypeScript mode</h2>


<div><textarea id="code" name="code">
class Greeter {
	greeting: string;
	constructor (message: string) {
		this.greeting = message;
	}
	greet() {
		return "Hello, " + this.greeting;
	}
}   

var greeter = new Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
	alert(greeter.greet())
}

document.body.appendChild(button)

</textarea></div>

    <script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "text/typescript"
      });
    </script>

    <p>This is a specialization of the <a href="index.html">JavaScript mode</a>.</p>
  </article>



================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/lib/codemirror.css
================================================
/* BASICS */

.CodeMirror {
    /* Set height, width, borders, and global font properties here */
    font-family: monospace;
    height: 300px;
    color: black;
    direction: ltr;
  }
  
  /* PADDING */
  
  .CodeMirror-lines {
    padding: 4px 0; /* Vertical padding around content */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    padding: 0 4px; /* Horizontal padding of content */
  }
  
  .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
    background-color: white; /* The little square between H and V scrollbars */
  }
  
  /* GUTTER */
  
  .CodeMirror-gutters {
    border-right: 1px solid #ddd;
    background-color: #f7f7f7;
    white-space: nowrap;
  }
  .CodeMirror-linenumbers {}
  .CodeMirror-linenumber {
    padding: 0 3px 0 5px;
    min-width: 20px;
    text-align: right;
    color: #999;
    white-space: nowrap;
  }
  
  .CodeMirror-guttermarker { color: black; }
  .CodeMirror-guttermarker-subtle { color: #999; }
  
  /* CURSOR */
  
  .CodeMirror-cursor {
    border-left: 1px solid black;
    border-right: none;
    width: 0;
  }
  /* Shown when moving in bi-directional text */
  .CodeMirror div.CodeMirror-secondarycursor {
    border-left: 1px solid silver;
  }
  .cm-fat-cursor .CodeMirror-cursor {
    width: auto;
    border: 0 !important;
    background: #7e7;
  }
  .cm-fat-cursor div.CodeMirror-cursors {
    z-index: 1;
  }
  .cm-fat-cursor-mark {
    background-color: rgba(20, 255, 20, 0.5);
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
  }
  .cm-animate-fat-cursor {
    width: auto;
    border: 0;
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
    background-color: #7e7;
  }
  @-moz-keyframes blink {
    0% {}
    50% { background-color: transparent; }
    100% {}
  }
  @-webkit-keyframes blink {
    0% {}
    50% { background-color: transparent; }
    100% {}
  }
  @keyframes blink {
    0% {}
    50% { background-color: transparent; }
    100% {}
  }
  
  /* Can style cursor different in overwrite (non-insert) mode */
  .CodeMirror-overwrite .CodeMirror-cursor {}
  
  .cm-tab { display: inline-block; text-decoration: inherit; }
  
  .CodeMirror-rulers {
    position: absolute;
    left: 0; right: 0; top: -50px; bottom: 0;
    overflow: hidden;
  }
  .CodeMirror-ruler {
    border-left: 1px solid #ccc;
    top: 0; bottom: 0;
    position: absolute;
  }
  
  /* DEFAULT THEME */
  
  .cm-s-default .cm-header {color: blue;}
  .cm-s-default .cm-quote {color: #090;}
  .cm-negative {color: #d44;}
  .cm-positive {color: #292;}
  .cm-header, .cm-strong {font-weight: bold;}
  .cm-em {font-style: italic;}
  .cm-link {text-decoration: underline;}
  .cm-strikethrough {text-decoration: line-through;}
  
  .cm-s-default .cm-keyword {color: #708;}
  .cm-s-default .cm-atom {color: #219;}
  .cm-s-default .cm-number {color: #164;}
  .cm-s-default .cm-def {color: #00f;}
  .cm-s-default .cm-variable,
  .cm-s-default .cm-punctuation,
  .cm-s-default .cm-property,
  .cm-s-default .cm-operator {}
  .cm-s-default .cm-variable-2 {color: #05a;}
  .cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
  .cm-s-default .cm-comment {color: #a50;}
  .cm-s-default .cm-string {color: #a11;}
  .cm-s-default .cm-string-2 {color: #f50;}
  .cm-s-default .cm-meta {color: #555;}
  .cm-s-default .cm-qualifier {color: #555;}
  .cm-s-default .cm-builtin {color: #30a;}
  .cm-s-default .cm-bracket {color: #997;}
  .cm-s-default .cm-tag {color: #170;}
  .cm-s-default .cm-attribute {color: #00c;}
  .cm-s-default .cm-hr {color: #999;}
  .cm-s-default .cm-link {color: #00c;}
  
  .cm-s-default .cm-error {color: #f00;}
  .cm-invalidchar {color: #f00;}
  
  .CodeMirror-composing { border-bottom: 2px solid; }
  
  /* Default styles for common addons */
  
  div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
  div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
  .CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
  .CodeMirror-activeline-background {background: #e8f2ff;}
  
  /* STOP */
  
  /* The rest of this file contains styles related to the mechanics of
     the editor. You probably shouldn't touch them. */
  
  .CodeMirror {
    position: relative;
    overflow: hidden;
    background: white;
  }
  
  .CodeMirror-scroll {
    overflow: scroll !important; /* Things will break if this is overridden */
    /* 30px is the magic margin used to hide the element's real scrollbars */
    /* See overflow: hidden in .CodeMirror */
    margin-bottom: -30px; margin-right: -30px;
    padding-bottom: 30px;
    height: 100%;
    outline: none; /* Prevent dragging from highlighting the element */
    position: relative;
  }
  .CodeMirror-sizer {
    position: relative;
    border-right: 30px solid transparent;
  }
  
  /* The fake, visible scrollbars. Used to force redraw during scrolling
     before actual scrolling happens, thus preventing shaking and
     flickering artifacts. */
  .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
    position: absolute;
    z-index: 6;
    display: none;
  }
  .CodeMirror-vscrollbar {
    right: 0; top: 0;
    overflow-x: hidden;
    overflow-y: scroll;
  }
  .CodeMirror-hscrollbar {
    bottom: 0; left: 0;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .CodeMirror-scrollbar-filler {
    right: 0; bottom: 0;
  }
  .CodeMirror-gutter-filler {
    left: 0; bottom: 0;
  }
  
  .CodeMirror-gutters {
    position: absolute; left: 0; top: 0;
    min-height: 100%;
    z-index: 3;
  }
  .CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    display: inline-block;
    vertical-align: top;
    margin-bottom: -30px;
  }
  .CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: none !important;
    border: none !important;
  }
  .CodeMirror-gutter-background {
    position: absolute;
    top: 0; bottom: 0;
    z-index: 4;
  }
  .CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
  }
  .CodeMirror-gutter-wrapper ::selection { background-color: transparent }
  .CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }
  
  .CodeMirror-lines {
    cursor: text;
    min-height: 1px; /* prevents collapsing before first draw */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    /* Reset some styles that the rest of the page might have set */
    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
    border-width: 0;
    background: transparent;
    font-family: inherit;
    font-size: inherit;
    margin: 0;
    white-space: pre;
    word-wrap: normal;
    line-height: inherit;
    color: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
    -webkit-tap-highlight-color: transparent;
    -webkit-font-variant-ligatures: contextual;
    font-variant-ligatures: contextual;
  }
  .CodeMirror-wrap pre.CodeMirror-line,
  .CodeMirror-wrap pre.CodeMirror-line-like {
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
  }
  
  .CodeMirror-linebackground {
    position: absolute;
    left: 0; right: 0; top: 0; bottom: 0;
    z-index: 0;
  }
  
  .CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    padding: 0.1px; /* Force widget margins to stay inside of the container */
  }
  
  .CodeMirror-widget {}
  
  .CodeMirror-rtl pre { direction: rtl; }
  
  .CodeMirror-code {
    outline: none;
  }
  
  /* Force content-box sizing for the elements where we expect it */
  .CodeMirror-scroll,
  .CodeMirror-sizer,
  .CodeMirror-gutter,
  .CodeMirror-gutters,
  .CodeMirror-linenumber {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }
  
  .CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0;
    overflow: hidden;
    visibility: hidden;
  }
  
  .CodeMirror-cursor {
    position: absolute;
    pointer-events: none;
  }
  .CodeMirror-measure pre { position: static; }
  
  div.CodeMirror-cursors {
    visibility: hidden;
    position: relative;
    z-index: 3;
  }
  div.CodeMirror-dragcursors {
    visibility: visible;
  }
  
  .CodeMirror-focused div.CodeMirror-cursors {
    visibility: visible;
  }
  
  .CodeMirror-selected { background: #d9d9d9; }
  .CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
  .CodeMirror-crosshair { cursor: crosshair; }
  .CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }
  .CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }
  
  .cm-searching {
    background-color: #ffa;
    background-color: rgba(255, 255, 0, .4);
  }
  
  /* Used to force a border model for a node */
  .cm-force-border { padding-right: .1px; }
  
  @media print {
    /* Hide the cursor when printing */
    .CodeMirror div.CodeMirror-cursors {
      visibility: hidden;
    }
  }
  
  /* See issue #2901 */
  .cm-tab-wrap-hack:after { content: ''; }
  
  /* Help users use markselection to safely style text background */
  span.CodeMirror-selectedtext { background: none; }
  


================================================
FILE: docs/assets/getting-started-assets/javascripts/codemirror/theme/xq-light.css
================================================
/*
Copyright (C) 2011 by MarkLogic Corporation
Author: Mike Brevoort <mike@brevoort.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
.cm-s-xq-light span.cm-keyword {line-height: 1em; font-weight: bold; color: #5A5CAD; }
.cm-s-xq-light span.cm-atom {color: #6C8CD5;}
.cm-s-xq-light span.cm-number {color: #164;}
.cm-s-xq-light span.cm-def {text-decoration:underline;}
.cm-s-xq-light span.cm-variable {color: black; }
.cm-s-xq-light span.cm-variable-2 {color:black;}
.cm-s-xq-light span.cm-variable-3 {color: black; }
.cm-s-xq-light span.cm-property {}
.cm-s-xq-light span.cm-operator {}
.cm-s-xq-light span.cm-comment {color: #0080FF; font-style: italic;}
.cm-s-xq-light span.cm-string {color: red;}
.cm-s-xq-light span.cm-meta {color: yellow;}
.cm-s-xq-light span.cm-qualifier {color: grey}
.cm-s-xq-light span.cm-builtin {color: #7EA656;}
.cm-s-xq-light span.cm-bracket {color: #cc7;}
.cm-s-xq-light span.cm-tag {color: #3F7F7F;}
.cm-s-xq-light span.cm-attribute {color: #7F007F;}
.cm-s-xq-light span.cm-error {color: #f00;}

.cm-s-xq-light .CodeMirror-activeline-background {background: #e8f2ff !important;}
.cm-s-xq-light .CodeMirror-matchingbracket {outline:1px solid grey;color:black !important;background:yellow;}


================================================
FILE: docs/assets/getting-started-assets/stylesheets/github-light.css
================================================
/*
   Copyright 2014 GitHub Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

.pl-c /* comment */ {
  color: #969896;
}

.pl-c1      /* constant, markup.raw, meta.diff.header, meta.module-reference, meta.property-name, support, support.constant, support.variable, variable.other.constant */,
.pl-s .pl-v /* string variable */ {
  color: #0086b3;
}

.pl-e  /* entity */,
.pl-en /* entity.name */ {
  color: #795da3;
}

.pl-s .pl-s1 /* string source */,
.pl-smi      /* storage.modifier.import, storage.modifier.package, storage.type.java, variable.other, variable.parameter.function */ {
  color: #333;
}

.pl-ent /* entity.name.tag */ {
  color: #63a35c;
}

.pl-k /* keyword, storage, storage.type */ {
  color: #a71d5d;
}

.pl-pds              /* punctuation.definition.string, string.regexp.character-class */,
.pl-s                /* string */,
.pl-s .pl-pse .pl-s1 /* string punctuation.section.embedded source */,
.pl-sr               /* string.regexp */,
.pl-sr .pl-cce       /* string.regexp constant.character.escape */,
.pl-sr .pl-sra       /* string.regexp string.regexp.arbitrary-repitition */,
.pl-sr .pl-sre       /* string.regexp source.ruby.embedded */ {
  color: #183691;
}

.pl-v /* variable */ {
  color: #ed6a43;
}

.pl-id /* invalid.deprecated */ {
  color: #b52a1d;
}

.pl-ii /* invalid.illegal */ {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.pl-sr .pl-cce /* string.regexp constant.character.escape */ {
  color: #63a35c;
  font-weight: bold;
}

.pl-ml /* markup.list */ {
  color: #693a17;
}

.pl-mh        /* markup.heading */,
.pl-mh .pl-en /* markup.heading entity.name */,
.pl-ms        /* meta.separator */ {
  color: #1d3e81;
  font-weight: bold;
}

.pl-mq /* markup.quote */ {
  color: #008080;
}

.pl-mi /* markup.italic */ {
  color: #333;
  font-style: italic;
}

.pl-mb /* markup.bold */ {
  color: #333;
  font-weight: bold;
}

.pl-md /* markup.deleted, meta.diff.header.from-file */ {
  background-color: #ffecec;
  color: #bd2c00;
}

.pl-mi1 /* markup.inserted, meta.diff.header.to-file */ {
  background-color: #eaffea;
  color: #55a532;
}

.pl-mdr /* meta.diff.range */ {
  color: #795da3;
  font-weight: bold;
}

.pl-mo /* meta.output */ {
  color: #1d3e81;
}




================================================
FILE: docs/assets/getting-started-assets/stylesheets/stylesheet.css
================================================
@import url(github-light.css);

/*
Overrides by mweststrate
*/
#usps {
  border-style: none;
}
#usps td {
  border-style: none;
  vertical-align: top;
  text-align: center;
  width: 50%;
}
#usps h4 {
  text-transform: uppercase;
}
#approot {
  padding: 20px;
  background-color: white;
  border: 3px solid orange;

}
#logo {
  float: left;
  border-style: none;
  box-shadow: none;
  margin-right: 20px;
  height: 100px;
}
#overview_content {
  background-color: #ff9955;
}
#overview_content h3{
  color: #fff;
}
#overview_content .inner {
  text-align: center;
  padding: 0;
}
#overview_img {
  margin: auto;
  width: 520px;
  box-shadow: none;
  border-style: none;
}
#shout {
  text-align: center;
  color: #ff9955;
}

/*******************************************************************************
Slate Theme for GitHub Pages
by Jason Costello, @jsncostello
*******************************************************************************/


/*******************************************************************************
MeyerWeb Reset
*******************************************************************************/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font: inherit;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

ol, ul {
  list-style: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

/*******************************************************************************
Theme Styles
*******************************************************************************/

body {
  box-sizing: border-box;
  color:#373737;
  background: #212121;
  font-size: 16px;
  font-family: 'Myriad Pro', Calibri, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}

h1, h2, h3, h4, h5, h6 {
  margin: 10px 0;
  font-weight: 700;
  color:#222222;
  font-family: 'Lucida Grande', 'Calibri', Helvetica, Arial, sans-serif;
  letter-spacing: -1px;
}

h1 {
  font-size: 36px;
  font-weight: 700;
}

h2 {
  padding-bottom: 10px;
  font-size: 32px;
  background: url('../images/bg_hr.png') repeat-x bottom;
}

h3 {
  font-size: 24px;
}

h4 {
  font-size: 21px;
}

h5 {
  font-size: 18px;
}

h6 {
  font-size: 16px;
}

p {
  margin: 10px 0 15px 0;
}

footer p {
  color: #f2f2f2;
}

a {
  text-decoration: none;
  color: #007edf;
  text-shadow: none;

  transition: color 0.5s ease;
  transition: text-shadow 0.5s ease;
  -webkit-transition: color 0.5s ease;
  -webkit-transition: text-shadow 0.5s ease;
  -moz-transition: color 0.5s ease;
  -moz-transition: text-shadow 0.5s ease;
  -o-transition: color 0.5s ease;
  -o-transition: text-shadow 0.5s ease;
  -ms-transition: color 0.5s ease;
  -ms-transition: text-shadow 0.5s ease;
}

a:hover, a:focus {text-decoration: underline;}

footer a {
  color: #F2F2F2;
  text-decoration: underline;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

img {
  position: relative;
  margin: 0 auto;
  max-width: 739px;
  padding: 5px;
  margin: 10px 0 10px 0;
  border: 1px solid #ebebeb;

  box-shadow: 0 0 5px #ebebeb;
  -webkit-box-shadow: 0 0 5px #ebebeb;
  -moz-box-shadow: 0 0 5px #ebebeb;
  -o-box-shadow: 0 0 5px #ebebeb;
  -ms-box-shadow: 0 0 5px #ebebeb;
}

p img {
  display: inline;
  margin: 0;
  padding: 0;
  vertical-align: middle;
  text-align: center;
  border: none;
}

pre, code {
  width: 100%;
  color: #222;
  background-color: #fff;

  font-family: Monaco, "Bitstream Vera Sans Mono", "Lucida Console", Terminal, monospace;
  font-size: 14px;

  border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
}

pre {
  width: 100%;
  padding: 10px;
  box-shadow: 0 0 10px rgba(0,0,0,.1);
  overflow: auto;
}

code {
  padding: 3px;
  margin: 0 3px;
  box-shadow: 0 0 10px rgba(0,0,0,.1);
}

pre code {
  display: block;
  box-shadow: none;
}

blockquote {
  color: #666;
  margin-bottom: 20px;
  padding: 0 0 0 20px;
  border-left: 3px solid #bbb;
}


ul, ol, dl {
  margin-bottom: 15px
}

ul {
  list-style-position: inside;
  list-style: disc;
  padding-left: 20px;
}

ol {
  list-style-position: inside;
  list-style: decimal;
  padding-left: 20px;
}

dl dt {
  font-weight: bold;
}

dl dd {
  padding-left: 20px;
  font-style: italic;
}

dl p {
  padding-left: 20px;
  font-style: italic;
}

hr {
  height: 1px;
  margin-bottom: 5px;
  border: none;
  background: url('../images/bg_hr.png') repeat-x center;
}

table {
  border: 1px solid #373737;
  margin-bottom: 20px;
  text-align: left;
 }

th {
  font-family: 'Lucida Grande', 'Helvetica Neue', Helvetica, Arial, sans-serif;
  padding: 10px;
  background: #373737;
  color: #fff;
 }

td {
  padding: 10px;
  border: 1px solid #373737;
 }

form {
  background: #f2f2f2;
  padding: 20px;
}

/*******************************************************************************
Full-Width Styles
*******************************************************************************/

.outer {
  width: 100%;
}

.inner {
  position: relative;
  max-width: 640px;
  padding: 20px 10px;
  margin: 0 auto;
}

#forkme_banner {
  display: block;
  position: absolute;
  top:0;
  right: 10px;
  z-index: 10;
  padding: 10px 50px 10px 10px;
  color: #fff;
  background: url('../images/blacktocat.png') #0090ff no-repeat 95% 50%;
  font-weight: 700;
  box-shadow: 0 0 10px rgba(0,0,0,.5);
  border-bottom-left-radius: 2px;
  border-bottom-right-radius: 2px;
}

#header_wrap {
  background: #212121;
  background: -moz-linear-gradient(top, #373737, #212121);
  background: -webkit-linear-gradient(top, #373737, #212121);
  background: -ms-linear-gradient(top, #373737, #212121);
  background: -o-linear-gradient(top, #373737, #212121);
  background: linear-gradient(top, #373737, #212121);
}

#header_wrap .inner {
  padding: 40px 10px 10px 10px; /*50px 10px 30px 10px*/

}

#project_title {
  margin: 0;
  color: #fff;
  font-size: 42px;
  font-weight: 700;
  text-shadow: #111 0px 0px 10px;
}

#project_tagline {
  color: #fff;
  font-size: 24px;
  font-weight: 300;
  background: none;
  text-shadow: #111 0px 0px 10px;
}

#downloads {
  position: absolute;
  width: 210px;
  z-index: 10;
  bottom: -40px;
  right: 0;
  height: 70px;
  background: url('../images/icon_download.png') no-repeat 0% 90%;
}

.zip_download_link {
  display: block;
  float: right;
  width: 90px;
  height:70px;
  text-indent: -5000px;
  overflow: hidden;
  background: url(../images/sprite_download.png) no-repeat bottom left;
}

.tar_download_link {
  display: block;
  float: right;
  width: 90px;
  height:70px;
  text-indent: -5000px;
  overflow: hidden;
  background: url(../images/sprite_download.png) no-repeat bottom right;
  margin-left: 10px;
}

.zip_download_link:hover {
  background: url(../images/sprite_download.png) no-repeat top left;
}

.tar_download_link:hover {
  background: url(../images/sprite_download.png) no-repeat top right;
}

#main_content_wrap {
  background: #f2f2f2;
  /*border-top: 1px solid #111;*/
  border-bottom: 1px solid #111;
}

#main_content {
  padding-top: 10px;/*40px*/
}

#footer_wrap {
  background: #212121;
}



/*******************************************************************************
Small Device Styles
*******************************************************************************/

@media screen and (max-width: 480px) {
  body {
    font-size:14px;
  }

  #downloads {
    display: none;
  }

  .inner {
    min-width: 320px;
    max-width: 480px;
  }

  #project_title {
  font-size: 32px;
  }

  h1 {
    font-size: 28px;
  }

  h2 {
    font-size: 24px;
  }

  h3 {
    font-size: 21px;
  }

  h4 {
    font-size: 18px;
  }

  h5 {
    font-size: 14px;
  }

  h6 {
    font-size: 12px;
  }

  code, pre {
    min-width: 320px;
    max-width: 480px;
    font-size: 11px;
  }

}



================================================
FILE: docs/best/debugging-mobx.md
================================================
---
title: Analyzing reactivity
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../analyzing-reactivity.md)



================================================
FILE: docs/best/decorators.md
================================================
---
title: Enabling decorators
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../enabling-decorators.md)



================================================
FILE: docs/best/store.md
================================================
---
title: Defining data stores
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../defining-data-stores.md)



================================================
FILE: docs/best/what-does-mobx-react-to.md
================================================
---
title: Understanding reactivity
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../understanding-reactivity.md)



================================================
FILE: docs/faq/migrate-to-6.md
================================================
---
title: Migrating from MobX 4/5
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../migrating-from-4-or-5.md)



================================================
FILE: docs/intro/concepts.md
================================================
---
title: The gist of MobX
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../the-gist-of-mobx.md)



================================================
FILE: docs/intro/how-to-read.md
================================================
---
title: About this documentation
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../about-this-documentation.md)



================================================
FILE: docs/intro/installation.md
================================================
---
title: Installation
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../installation.md)



================================================
FILE: docs/react/react-integration.md
================================================
---
title: React integration
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../react-integration.md)



================================================
FILE: docs/react/react-performance.md
================================================
---
title: Optimizing React component rendering
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../react-optimizations.md)



================================================
FILE: docs/refguide/action.md
================================================
---
title: Updating state using actions
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../actions.md)



================================================
FILE: docs/refguide/api.md
================================================
---
title: MobX API overview
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../api.md)



================================================
FILE: docs/refguide/autorun.md
================================================
---
title: Running side effects with reactions
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../reactions.md)



================================================
FILE: docs/refguide/computed-with-args.md
================================================
---
title: Computeds with arguments
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../computeds-with-args.md)



================================================
FILE: docs/refguide/computed.md
================================================
---
title: Deriving information with computeds
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../computeds.md)



================================================
FILE: docs/refguide/configure.md
================================================
---
title: Configuration
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../configuration.md)



================================================
FILE: docs/refguide/extending.md
================================================
---
title: Creating custom observables
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../custom-observables.md)



================================================
FILE: docs/refguide/mobx-utils.md
================================================
---
title: MobX-utils
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../mobx-utils.md)



================================================
FILE: docs/refguide/modifiers.md
================================================
---
title: Observable modifiers
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../observable-state.md#available-annotations)



================================================
FILE: docs/refguide/object-api.md
================================================
---
title: Collection utilities
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../collection-utilities.md)



================================================
FILE: docs/refguide/object.md
================================================
---
title: Observable Objects
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../api.md#observableobject)



================================================
FILE: docs/refguide/observable.md
================================================
---
title: Creating observable state
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../observable-state.md)



================================================
FILE: docs/refguide/observe.md
================================================
---
title: Intercept & Observe
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../intercept-and-observe.md)



================================================
FILE: docs/refguide/on-become-observed.md
================================================
---
title: Creating lazy observables
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../lazy-observables.md)



================================================
FILE: docs/refguide/set.md
================================================
---
title: Observable Sets
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

# This document has been updated and moved

[Please click on this link to open the updated version.](../api.md#observableset)



================================================
FILE: docs/styles/website.css
================================================
h1 {
    display: -ms-flexbox;
    display: flex;
    width: 100%;
    -ms-flex-pack: start;
    justify-content: flex-start;
}



================================================
FILE: packages/eslint-plugin-mobx/README.md
================================================
# eslint-plugin-mobx

Mobx specific linting rules for `eslint`.

## Installation

```
npm install --save-dev eslint @typescript-eslint/parser eslint-plugin-mobx
```

## Configuration

### Legacy Config

```javascript
// .eslintrc.js
module.exports = {
    parser: "@typescript-eslint/parser",
    // Include "mobx" in plugins array:
    plugins: ["mobx"],
    // Either extend our recommended configuration:
    extends: "plugin:mobx/recommended",
    // ...or specify and customize individual rules:
    rules: {
        // these values are the same as recommended
        "mobx/exhaustive-make-observable": "warn",
        "mobx/unconditional-make-observable": "error",
        "mobx/missing-make-observable": "error",
        "mobx/missing-observer": "warn"
    }
}
```

### Flat Config

```javascript
// eslint.config.js
import pluginMobx from "eslint-plugin-mobx"

export default [
    // ...

    // Either extend our recommended configuration:
    pluginMobx.flatConfigs.recommended,

    // ...or specify and customize individual rules:
    {
        plugins: { mobx: pluginMobx },
        rules: {
            // these values are the same as recommended
            "mobx/exhaustive-make-observable": "warn",
            "mobx/unconditional-make-observable": "error",
            "mobx/missing-make-observable": "error",
            "mobx/missing-observer": "warn"
        }
    }
]
```

## Rules

### mobx/exhaustive-make-observable

Makes sure that `makeObservable` annotates all fields defined on class or object literal.<br>
To exclude a field, annotate it using `field: false`.<br>
Does not support fields introduced by constructor (`this.foo = 5`).<br>
Does not warn about annotated non-existing fields (there is a runtime check, but the autofix removing the field could be handy...).<br>
**Autofix** adds `field: true` for each missing field by default. You can change this behaviour by specifying options in your eslint config:

```json
{
    "rules": {
        "mobx/exhaustive-make-observable": ["error", { "autofixAnnotation": false }]
    }
}
```

This is a boolean value that controls if the field is annotated with `true` or `false`.
If you are migrating an existing project using `makeObservable` and do not want this rule to override
your current usage (even if it may be wrong), you should run the autofix with the annotation set to `false` to maintain existing behaviour: `eslint --no-eslintrc --fix --rule='mobx/exhaustive-make-observable: [2, { "autofixAnnotation": false }]' .`

### mobx/missing-make-observable

_When using decorators (eg `@observable foo = 5`)_, makes sure that `makeObservable(this)` is called in a constructor.<br>
**Autofix** creates a constructor if necessary and adds `makeObservable(this)` at it's end.

### mobx/unconditional-make-observable

Makes sure the `make(Auto)Observable(this)` is called unconditionally inside a constructor.

### mobx/missing-observer

Makes sure every React component is wrapped with `observer`. A React component is considered to be any _class_ extending from `Component` or `React.Component` and any _function_ which name has the first letter capitalized (for anonymous functions the name is inferred from variable). These are all considered components:

```javascript
class Cmp extends React.Component { }
class Cmp extends Component { }
const Cmp = class extends React.Component { }
const Cmp = class extends Component { }
class extends Component { }
class extends React.Component { }

function Named() { }
const foo = function Named() { }
const Anonym = function () { };
const Arrow = () => { };
```

**Autofix** wraps the component with `observer` and if necessary declares a constant of the same name: `const Name = observer(function Name() {})`.
It's a bit opinionated and can lead to a lot of false positives depending on your conventions. You will probably want to combine this rule with `overrides` option, eg:

```javascript
// .eslintrc.js
"overrides": [
  {
    "files": ["*.jsx"],
    "rules": {
      "mobx/missing-observer": "error"
    }
  }
]
```

### mobx/no-anonymous-observer (deprecated)

_Deprecated in favor of [react/display-name](https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/display-name.md) + [componentWrapperFunctions](https://github.com/jsx-eslint/eslint-plugin-react). Example of **.eslintrc**:_

```
{
  "rules": {
    "react/display-name": "warn"
  },
  "settings": {
    "componentWrapperFunctions": [
      "observer"
    ]
  }
}
```

---

Forbids anonymous functions or classes as `observer` components.
Improves debugging experience and [avoids problem with inability to customize `displayName`](https://github.com/mobxjs/mobx/issues/2721).
Plays nice with `eslint-plugin-react-hooks` and `mobx/missing-observer` as both of these don't recognize anonymous function as component.
**Autofix** infers the name from variable if possible.



================================================
FILE: packages/eslint-plugin-mobx/CHANGELOG.md
================================================
# eslint-plugin-mobx

## 0.0.13

### Patch Changes

-   [`88aa10828eabdf9edf2d0e523e0388c854c79dea`](https://github.com/mobxjs/mobx/commit/88aa10828eabdf9edf2d0e523e0388c854c79dea) [#3947](https://github.com/mobxjs/mobx/pull/3947) Thanks [@dartess](https://github.com/dartess)! - fix config name for recommended flat config

## 0.0.12

### Patch Changes

-   [`218ebde877712775054e027cfda812210d2aa7d6`](https://github.com/mobxjs/mobx/commit/218ebde877712775054e027cfda812210d2aa7d6) [#3942](https://github.com/mobxjs/mobx/pull/3942) Thanks [@dartess](https://github.com/dartess)! - add eslint@9 support and flat config

## 0.0.11

### Patch Changes

-   [`638533e592f4fda7663fa351447380f9d0917d14`](https://github.com/mobxjs/mobx/commit/638533e592f4fda7663fa351447380f9d0917d14) [#3909](https://github.com/mobxjs/mobx/pull/3909) Thanks [@urugator](https://github.com/urugator)! - mobx/missing-observer rule false positive with forwardRef #3908

## 0.0.10

### Patch Changes

-   [`44a5fe07`](https://github.com/mobxjs/mobx/commit/44a5fe07fb95c2ba24d8df19f18b57ee92abb1a9) [#3881](https://github.com/mobxjs/mobx/pull/3881) Thanks [@kade-robertson](https://github.com/kade-robertson)! - Adds an option for the `mobx/exhaustive-make-observable` eslint rule to configure whether fields are annotated with `true` or `false` with the autofixer.

    This option defaults to `true` if not present or an invalid value is received to maintain existing behavior.

## 0.0.9

### Patch Changes

-   [`e63c2df0`](https://github.com/mobxjs/mobx/commit/e63c2df0ef166868675bce21892cd686a46db953) [#3443](https://github.com/mobxjs/mobx/pull/3443) Thanks [@urugator](https://github.com/urugator)! - changeset for PR #3423: deprecate no-anonymous-observer

## 0.0.8

### Patch Changes

-   [`aafda613`](https://github.com/mobxjs/mobx/commit/aafda6136afd107c6cbdd73d9bab57e45a2eb9f5) [#3256](https://github.com/mobxjs/mobx/pull/3256) Thanks [@urugator](https://github.com/urugator)! - fix `no-anonymous-observer` autofix for arrow functions without BlockStatement body

## 0.0.7

### Patch Changes

-   [`0aaf1831`](https://github.com/mobxjs/mobx/commit/0aaf183131f3eadd40c05ccc94139282bd8d7d56) [#3231](https://github.com/mobxjs/mobx/pull/3231) Thanks [@ahoisl](https://github.com/ahoisl)! - fix(lint): fix 'missing-make-observable' rule with constructor overloads

## 0.0.6

### Patch Changes

-   [`4b1337ec`](https://github.com/mobxjs/mobx/commit/4b1337ecd64c7bfc904a04063bd1b07e62e392f1) [#3228](https://github.com/mobxjs/mobx/pull/3228) Thanks [@ahoisl](https://github.com/ahoisl)! - fix name for missing-observer rule in recommended

## 0.0.5

### Patch Changes

-   [`021f34ec`](https://github.com/mobxjs/mobx/commit/021f34ec81daed9e5b5ed8425b2f3e0fa85dfe5b) [#3219](https://github.com/mobxjs/mobx/pull/3219) Thanks [@urugator](https://github.com/urugator)! - Add [`mobx/missing-observer`](https://github.com/mobxjs/mobx/tree/main/packages/eslint-plugin-mobx#mobxmissing-observer),
    [`mobx/no-anonymous-observer`](https://github.com/mobxjs/mobx/tree/main/packages/eslint-plugin-mobx#mobxno-anonymous-observer) rules,

## 0.0.4

### Patch Changes

-   [`5b6f3001`](https://github.com/mobxjs/mobx/commit/5b6f30017939a2082f7d767a857e0189210a91a7) [#3204](https://github.com/mobxjs/mobx/pull/3204) Thanks [@urugator](https://github.com/urugator)! - changed build process

## 0.0.3

### Patch Changes

-   [`cd6a6a68`](https://github.com/mobxjs/mobx/commit/cd6a6a68245f082bdc35a3109214a5449ef9818d) [#3200](https://github.com/mobxjs/mobx/pull/3200) Thanks [@urugator](https://github.com/urugator)! - fix package.json



================================================
FILE: packages/eslint-plugin-mobx/jest.config-eslint-7.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    displayName: 'eslint-plugin-mobx with eslint@7',
    setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
    testRegex: "__tests__/[^/]+\\.(t|j)sx?$",
    globals: {
        ESLINT_V: 7
    }
})



================================================
FILE: packages/eslint-plugin-mobx/jest.config-eslint-9.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    displayName: 'eslint-plugin-mobx with eslint@9',
    setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
    testRegex: "__tests__/[^/]+\\.(t|j)sx?$",
    globals: {
        ESLINT_V: 9
    }
})



================================================
FILE: packages/eslint-plugin-mobx/jest.setup.js
================================================
/** @see https://github.com/jsdom/jsdom/issues/3363 */
global.structuredClone = val => {
    return JSON.parse(JSON.stringify(val))
}



================================================
FILE: packages/eslint-plugin-mobx/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 Michel Weststrate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: packages/eslint-plugin-mobx/package.json
================================================
{
    "name": "eslint-plugin-mobx",
    "version": "0.0.13",
    "description": "ESLint rules for MobX",
    "main": "dist/index.js",
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git",
        "directory": "packages/eslint-plugin-mobx"
    },
    "license": "MIT",
    "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mobx"
    },
    "bugs": {
        "url": "https://github.com/mobxjs/mobx/issues"
    },
    "files": [
        "src",
        "dist",
        "LICENSE",
        "CHANGELOG.md",
        "README.md"
    ],
    "homepage": "https://mobx.js.org/",
    "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0"
    },
    "devDependencies": {
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@rollup/plugin-babel": "^5.3.0",
        "@rollup/plugin-commonjs": "^21.0.1",
        "@rollup/plugin-node-resolve": "13.0.6",
        "@typescript-eslint/eslint-plugin": "^5.0.0",
        "@typescript-eslint/parser": "^5.0.0",
        "eslint": "^7.0.0",
        "eslint-7": "npm:eslint@^7.0.0",
        "eslint-9": "npm:eslint@^9.0.0",
        "rollup": "^2.60.2"
    },
    "keywords": [
        "eslint",
        "eslint-plugin",
        "eslintplugin",
        "mobx"
    ],
    "scripts": {
        "test:7": "jest --config jest.config-eslint-7.js",
        "test:9": "jest --config jest.config-eslint-9.js",
        "test": "npm run test:7 && npm run test:9",
        "build": "yarn rollup --config",
        "prepublishOnly": "yarn build"
    }
}



================================================
FILE: packages/eslint-plugin-mobx/rollup.config.js
================================================
import { nodeResolve } from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";
import babel from "@rollup/plugin-babel";
import pkg from "./package.json";

export default [
  {
    input: "src/index.js",
    plugins: [
      nodeResolve(),
      commonjs(),
      babel({
        babelHelpers: "bundled",
        exclude: "**/node_modules/**",
      }),
    ],
    output: [
      { file: pkg.main, format: "cjs", exports: "auto" },
    ],
  },
];


================================================
FILE: packages/eslint-plugin-mobx/.babelrc.js
================================================
module.exports = {
  "presets": [
    ["@babel/preset-env"],
  ],
  "plugins": [
    //"@babel/plugin-transform-runtime"
  ]
};


================================================
FILE: packages/eslint-plugin-mobx/__tests__/exhaustive-make-observable.js
================================================
import { getRuleTester } from "./utils/get-rule-tester";

import rule from "../src/exhaustive-make-observable.js";

const tester = getRuleTester();

const decoratedFields = [
  '@observable o = 5',
  '@observable.ref or = []',
  '@observable.shallow os = []',
  '@observable.deep od = {}',
  '@computed get c() {}',
  '@computed.struct get cs() {}',
  '@computed({ equals }) get co() {}',
  '@action a() {}',
  '@action.bound ab() {}',
  '@flow *f() {}',
  '@flow.bound *fb() {}',
];

const valid1 = decoratedFields.map(field => `
class C {     
  ${field}

  constructor() {
    makeObservable(this) 
  }      
}
`).map(code => ({ code }))

const valid2 = {
  code: `
class C {     
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, {
      o: true,
      a: true,
      c: true,
      f: true,
    }) 
  }  
}
`
}

const valid3 = {
  code: `
class C {     
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable({})
  }  
}
`
}

const invalid1 = {
  code: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, {
      a: true,
      c: true,
      f: true,
    })
  }
}
`,
  errors: [{ messageId: 'missingAnnotation' }],
  output: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, { o: true, 
      a: true,
      c: true,
      f: true,
    })
  }
}
`
}

const invalid2 = {
  code: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, {
      o: true,
      c: true,
      f: true,
    })
  }
}
`,
  errors: [{ messageId: 'missingAnnotation' }],
  output: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, { a: true, 
      o: true,
      c: true,
      f: true,
    })
  }
}
`
}

const invalid3 = {
  code: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, {
      o: true,
      a: true,
      f: true,
    })
  }
}
`,
  errors: [{ messageId: 'missingAnnotation' }],
  output: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, { c: true, 
      o: true,
      a: true,
      f: true,
    })
  }
}
`
}

const invalid4 = {
  code: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, {
      o: true,
      a: true,
      c: true,
    })
  }
}
`,
  errors: [{ messageId: 'missingAnnotation' }],
  output: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, { f: true, 
      o: true,
      a: true,
      c: true,
    })
  }
}
`
}

const invalid5 = {
  code: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this)
  }
}
`,
  errors: [{ messageId: 'missingAnnotation' }],
  output: `
class C {
  o = 5
  get c() {}
  a() {}
  *f() {}
  
  constructor() {
    makeObservable(this, { o: true, c: true, a: true, f: true, })
  }
}
`
}

tester.run("exhaustive-make-observable", rule, {
  valid: [
    ...valid1,
    valid2,
    valid3,
  ],
  invalid: [
    invalid1,
    invalid2,
    invalid3,
    invalid4,
    invalid5,
  ],
});


================================================
FILE: packages/eslint-plugin-mobx/__tests__/missing-make-observable.js
================================================
import { getRuleTester } from "./utils/get-rule-tester";

import rule from "../src/missing-make-observable.js";

const tester = getRuleTester();

const fields = [
  '@observable o = 5',
  '@observable.ref or = []',
  '@observable.shallow os = []',
  '@observable.deep od = {}',
  '@computed get c() {}',
  '@computed.struct get cs() {}',
  '@computed({ equals }) get co() {}',
  '@action a() {}',
  '@action.bound ab() {}',
  '@flow *f() {}',
  '@flow.bound *fb() {}',
];

const valid1 = fields.map(field => `
class C {     
  ${field}

  constructor() {
    makeObservable(this) 
  }      
}
`).map(code => ({ code }))

const valid2 = {
  code: `
class C {       
  o = 5;
  get c() {};
  a() {};
  *f() {};

  constructor() {
    makeObservable(this, {}) 
  }      
}
`
}

const valid3 = fields.map(field => `
class C {     
  ${field}

  constructor() {
    makeObservable(this, null, { name: 'foo' }) 
  }      
}
`).map(code => ({ code }))

const valid4 = fields.map(field => `
class C {     
  ${field}

  constructor(aString: string);
  constructor(aNum: number);
  constructor(stringOrNum: string | number) {
    makeObservable(this, null, { name: 'foo' }) 
  }      
}
`).map(code => ({ code }))

const invalid1 = fields.map(field => ({
  code: `
class C {
  ${field}
}
`,
  errors: [
    { messageId: 'missingMakeObservable' },
  ],
  output: `
class C {
constructor() { makeObservable(this); }
  ${field}
}
`
}))

const invalid2 = fields.map(field => ({
  code: `
class C {
  ${field}
  constructor() {}
}
`,
  errors: [
    { messageId: 'missingMakeObservable' },
  ],
  output: `
class C {
  ${field}
  constructor() {;makeObservable(this);}
}
`,
}))

const invalid3 = fields.map(field => ({
  code: `
class C {
  ${field}
  constructor() {
    makeObservable({ a: 5 });
  }
}
`,
  errors: [
    { messageId: 'missingMakeObservable' },
  ],
  output: `
class C {
  ${field}
  constructor() {
    makeObservable({ a: 5 });
  ;makeObservable(this);}
}
`,
}))

const invalid4 = fields.map(field => ({
  code: `
class C {
  ${field}
  constructor()
}
`,
  errors: [
    { messageId: 'missingMakeObservable' },
  ],
  output: `
class C {
  ${field}
  constructor() { makeObservable(this); }
}
`,
}))


const invalid5 = fields.map(field => ({
  code: `
class C {
  ${field}
  constructor() {
    makeObservable(this, { o: observable.ref });
  }
}
`,
  errors: [
    { messageId: 'secondArgMustBeNullish' },
  ],
}))


tester.run("missing-make-observable", rule, {
  valid: [
    ...valid1,
    valid2,
    ...valid3,
    ...valid4,
  ],
  invalid: [
    ...invalid1,
    ...invalid2,
    ...invalid3,
    ...invalid4,
    ...invalid5,
  ],
});


================================================
FILE: packages/eslint-plugin-mobx/__tests__/missing-observer.js
================================================
import { getRuleTester } from "./utils/get-rule-tester";

import rule from "../src/missing-observer.js"

const tester = getRuleTester();

const valids = [
    "observer(function Named() { });",
    "const foo = observer(function Named() { })",
    "const Anonym = observer(function () { });",
    "const Arrow = observer(() => { });",
    "function notCmp() { }",
    "const notCmp = function notCmp() { }",
    "const notCmp = function () { }",
    "const notCmp = () => { }",
    "class NotCmp { }",
    "class NotCmp extends Foo { }",
    "class NotCmp extends React.Foo { }",
    "const Cmp = observer(class Cmp extends React.Component { })",
    "const Cmp = observer(class Cmp extends Component { })",
    "const Cmp = observer(class extends React.Component { })",
    "const Cmp = observer(class extends Component { })"
]

const invalids = [
    ["function Named() { }", "const Named = observer(function Named() { })"],
    ["const foo = function Named() { }", "const foo = observer(function Named() { })"],
    ["const Anonym = function () { };", "const Anonym = observer(function () { });"],
    ["const Arrow = () => { };", "const Arrow = observer(() => { });"],
    [
        "class Cmp extends React.Component { }",
        "const Cmp = observer(class Cmp extends React.Component { })"
    ],
    ["class Cmp extends Component { }", "const Cmp = observer(class Cmp extends Component { })"],
    [
        "const Cmp = class extends React.Component { }",
        "const Cmp = observer(class extends React.Component { })"
    ],
    [
        "const Cmp = class extends Component { }",
        "const Cmp = observer(class extends Component { })"
    ],
    ["class extends Component { }", "observer(class extends Component { })"],
    ["class extends React.Component { }", "observer(class extends React.Component { })"]
]

tester.run("missing-observer", rule, {
    valid: valids.map(code => ({ code })),
    invalid: invalids.map(([code, output]) => ({
        code,
        output,
        errors: [{ messageId: "missingObserver" }]
    }))
})



================================================
FILE: packages/eslint-plugin-mobx/__tests__/no-anonymous-observer.js
================================================
import { getRuleTester } from "./utils/get-rule-tester";

import rule from "../src/no-anonymous-observer.js"

const tester = getRuleTester();

const valids = ["observer(function Name() {})", "observer(class Name {})"]

const invalidsNotFixed = ["observer(() => {})", "observer(function () {})", "observer(class {})"]

const invalidsFixed = [
    ["const Cmp = observer(() => {})", "const Cmp = observer(function Cmp()  {})"],
    ['const Cmp = observer(() => "")', 'const Cmp = observer(function Cmp()  { return "" })'],
    [
        "const Cmp = observer(() => expr())",
        "const Cmp = observer(function Cmp()  { return expr() })"
    ],
    [
        "const Cmp = observer(() => literal)",
        "const Cmp = observer(function Cmp()  { return literal })"
    ],
    ["const Cmp = observer(function () {})", "const Cmp = observer(function Cmp () {})"],
    ["const Cmp = observer(class {})", "const Cmp = observer(class Cmp {})"]
]

tester.run("no-anonymous-observer", rule, {
    valid: valids.map(code => ({ code })),
    invalid: [
        ...invalidsNotFixed.map(code => ({
            code,
            errors: [{ messageId: "observerComponentMustHaveName" }]
        })),
        ...invalidsFixed.map(([code, output]) => ({
            code,
            output,
            errors: [{ messageId: "observerComponentMustHaveName" }]
        }))
    ]
})



================================================
FILE: packages/eslint-plugin-mobx/__tests__/unconditional-make-observable.js
================================================
import { getRuleTester } from "./utils/get-rule-tester";

import rule from "../src/unconditional-make-observable.js";

const tester = getRuleTester();

const valid1 = {
  code: `
class C {
  constructor() {
    makeObservable()
    makeObservable({})
    makeObservable(this)
    function f() {
      makeObservable(this, {});
    }
    const ff = function () {
      makeObservable(this, {});
    }
  }    
}
`
}

const invalid1 = {
  code: `
class C {
  constructor() {    
    if (true) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    for (let i = 0; i < 1; i++) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    while (Math.random() > 1) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    const a = () => {
      makeObservable(this, {});
    }
  }    
}
`,
  errors: [
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
    { messageId: 'mustCallUnconditionally' },
  ],
}

tester.run("unconditional-make-observable", rule, {
  valid: [
    valid1,
  ],
  invalid: [
    invalid1
  ],
});


================================================
FILE: packages/eslint-plugin-mobx/__tests__/utils/get-rule-tester.js
================================================
const version = global.ESLINT_V;

const { RuleTester } = require(`eslint-${version}`);
const typescriptEslintParser = require("@typescript-eslint/parser");

function getRuleTesterConfig() {
    switch (version) {
        case 7:
            return {
                parser: require.resolve("@typescript-eslint/parser"),
                parserOptions: {},
            };
        case 9:
            return {
                languageOptions: {
                    parser: typescriptEslintParser,
                    parserOptions: {},
                },
            };
        default:
            throw new Error(`Unknown or unspecified ESLINT_V (${String(version)})`);
    }
}

function getRuleTester() {
    return new RuleTester(getRuleTesterConfig());
}

export { getRuleTester }


================================================
FILE: packages/eslint-plugin-mobx/preview/make-observable.js
================================================
/* eslint mobx/exhaustive-make-observable: "error" */
/* eslint mobx/missing-make-observable: "error" */
/* eslint mobx/unconditional-make-observable: "error" */

makeObservable();
makeObservable(foo, {});
makeObservable(this, {});
makeAutoObservable();
makeAutoObservable(foo, {});
makeAutoObservable(this, {});

makeObservable({
  o: 5,
  a() { },
  get c() { },
  set c() { },
  "lit": 1,
  [cmp()]() { },
});

// ok
makeObservable({
  o: 5,
  a() { },
  get c() { },
  set c() { },
  "lit": 1,
}, {
  o: observable,
  a: action,
  c: computed,
  "lit": 1,
  [cmp()]() { },
});

class Exhaustive1 {
  o = 5;
  a() { };
  get c() { };
  set c() { };
  "lit" = 1;
  [cmp()]() { };

  constructor() {
    makeObservable(this, {})
  }
}

class Exhaustive2 {
  o = 5;
  a() { };
  get c() { };
  set c() { };
  "lit" = 1;
  [cmp()]() { };

  constructor() {
    // ok
    makeObservable(this, {
      o: observable,
      a: action,
      c: computed,
      "lit": 1,
      [cmp()]() { },
    })
  }
}

class Exhaustive3 {
  o = 5;
  o2 = 5;
  a() { };
  a2() { };
  get c() { };
  get c2() { };

  constructor() {
    makeObservable(this, {
      o: observable,
      a: action,
      c: computed,
    })
  }
}

class Exhaustive4 {
  o = 5;
  a() { };
  get c() { };

  constructor() {
    function a() {
      makeObservable(this) // ok - `this` doesn't refer to class instance  
    }
  }
}

class Exhaustive4 {
  o = 5;
  a() { };
  get c() { };

  constructor() {
    makeObservable({}); // ok - not making `this` observable 
  }
}

class Unconditional2 {
  constructor() {
    makeObservable(this, {}); // ok - no condition
    makeObservable() // ok - no `this`
    makeObservable({}) // ok - no `this`
    if (true) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    for (let i = 0; i < 1; i++) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    while (Math.random() > 1) {
      makeObservable(this, {});
      makeAutoObservable(this, {});
    }
    const a = () => {
      makeObservable(this, {});
    }
    function f() {
      makeObservable(this, {}); // ok - `this` doesn't refer to class instance    
    }
    const ff = function () {
      makeObservable(this, {}); // ok - `this` doesn't refer to class instance    
    }
  }
}

class MissingMakeObservable1 {
  @observable o = 5;
}

class MissingMakeObservable2 {
  @observable o = 5;
  constructor() { }
}

class MissingMakeObservable3 {
  @observable o = 5;
  constructor() {
    makeObservable({})
  }
}

class MissingMakeObservable4 {
  @observable o = 5;
  constructor()
}

// ok
class MissingMakeObservable5 {
  @observable o = 5;
  constructor() {
    makeObservable(this)
  }
}


================================================
FILE: packages/eslint-plugin-mobx/preview/missing-observer.js
================================================
/* eslint mobx/missing-observer: "error" */

function Named() {}
const named = function Named() {}
const namedRef = forwardRef(function Named() {})
const Anonym = function () {}
const AnonymRef = forwardRef(function () {})
const Arrow = () => {}
const ArrowRef = forwardRef(() => {})

observer(function Named() {})
observer(forwardRef(function Named() {}))
const namedObs = observer(function Named() {})
const namedRefObs = observer(forwardRef(function Named() {}))
const AnonymObs = observer(function () {})
const AnonymRefObs = observer(forwardRef(function () {}))
const ArrowObs = observer(() => {})
const ArrowRefObs = observer(forwardRef(() => {}))

function notCmp() {}
const notCmp = function notCmp() {}
const notCmp = function () {}
const notCmp = () => {}
const notCmp = forwardRef(() => {})

class Cmp extends React.Component {}
class Cmp extends Component {}
const Cmp = class extends React.Component {}
const Cmp = class extends Component {}
;(class extends Component {})
;(class extends React.Component {})

class NotCmp {}
class NotCmp extends Foo {}
class NotCmp extends React.Foo {}

const Cmp = observer(class Cmp extends React.Component {})
const Cmp = observer(class Cmp extends Component {})
const Cmp = observer(class extends React.Component {})
const Cmp = observer(class extends Component {})



================================================
FILE: packages/eslint-plugin-mobx/preview/no-anonymous-observer.js
================================================
/* eslint mobx/no-anonymous-observer: "error" */

observer(() => {})
observer(function () {})
observer(class {})

const Cmp = observer(() => {})
const Cmp = observer(() => "") // different autofix
const Cmp = observer(() => expr()) // different autofix
const Cmp = observer(() => literal) // different autofix
const Cmp = observer(function () {})
const Cmp = observer(class {})

observer(function Name() {})
observer(class Name {})



================================================
FILE: packages/eslint-plugin-mobx/preview/.eslintrc.js
================================================
module.exports = {
    "extends": [
        "plugin:mobx/recommended"
    ],
    "env": {
        "browser": true,
        "es6": true,
        "node": true
    },
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 2018,
        "sourceType": "module"
    },
    "plugins": [
        "mobx",
        //"@typescript-eslint"
    ],
    "rules": {
        //'mobx/exhaustive-make-observable': 'off',
        //'mobx/unconditional-make-observable': 'off',
        //'mobx/missing-observer': 'off',
    }
};


================================================
FILE: packages/eslint-plugin-mobx/src/exhaustive-make-observable.js
================================================
"use strict"

const { findAncestor, isMobxDecorator } = require("./utils.js")

// TODO support this.foo = 5; in constructor
// TODO? report on field as well
function create(context) {
    const sourceCode = context.getSourceCode()
    const autofixAnnotation = context.options[0]?.autofixAnnotation ?? true

    function fieldToKey(field) {
        // TODO cache on field?
        const key = sourceCode.getText(field.key)
        return field.computed ? `[${key}]` : key
    }

    return {
        'CallExpression[callee.name="makeObservable"]': makeObservable => {
            // Only interested about makeObservable(this, ...) in constructor or makeObservable({}, ...)
            // ClassDeclaration
            //   ClassBody
            //     MethodDefinition[kind="constructor"]
            //       FunctionExpression
            //         BlockStatement
            //           ExpressionStatement
            //             CallExpression[callee.name="makeObservable"]
            const [firstArg, secondArg] = makeObservable.arguments
            if (!firstArg) return
            let members
            if (firstArg.type === "ThisExpression") {
                const closestFunction = findAncestor(
                    makeObservable,
                    node =>
                        node.type === "FunctionExpression" || node.type === "FunctionDeclaration"
                )
                if (closestFunction?.parent?.kind !== "constructor") return
                members = closestFunction.parent.parent.parent.body.body
            } else if (firstArg.type === "ObjectExpression") {
                members = firstArg.properties
            } else {
                return
            }

            const annotationProps = secondArg?.properties || []
            const nonAnnotatedMembers = []
            let hasAnyDecorator = false

            members.forEach(member => {
                if (member.static) return
                if (member.kind === "constructor") return
                //if (member.type !== 'MethodDefinition' && member.type !== 'ClassProperty') return;
                hasAnyDecorator =
                    hasAnyDecorator || member.decorators?.some(isMobxDecorator) || false
                if (!annotationProps.some(prop => fieldToKey(prop) === fieldToKey(member))) {
                    // TODO optimize?
                    nonAnnotatedMembers.push(member)
                }
            })
            /*
      // With decorators, second arg must be null/undefined or not provided
      if (hasAnyDecorator && secondArg && secondArg.name !== "undefined" && secondArg.value !== null) {
        context.report({
          node: makeObservable,
          message: 'When using decorators, second arg must be `null`, `undefined` or not provided.',
        })
      }
      // Without decorators, in constructor, second arg must be object literal
      if (!hasAnyDecorator && firstArg.type === 'ThisExpression' && (!secondArg || secondArg.type !== 'ObjectExpression')) {
        context.report({
          node: makeObservable,
          message: 'Second argument must be object in form of `{ key: annotation }`.',
        })
      }
      */

            if (!hasAnyDecorator && nonAnnotatedMembers.length) {
                // Set avoids reporting twice for setter+getter pair or actual duplicates
                const keys = [...new Set(nonAnnotatedMembers.map(fieldToKey))]
                const keyList = keys.map(key => `\`${key}\``).join(", ")

                const fix = fixer => {
                    const annotationList =
                        keys.map(key => `${key}: ${autofixAnnotation}`).join(", ") + ","
                    if (!secondArg) {
                        return fixer.insertTextAfter(firstArg, `, { ${annotationList} }`)
                    } else if (secondArg.type !== "ObjectExpression") {
                        return fixer.replaceText(secondArg, `{ ${annotationList} }`)
                    } else {
                        const openingBracket = sourceCode.getFirstToken(secondArg)
                        return fixer.insertTextAfter(openingBracket, ` ${annotationList} `)
                    }
                }

                context.report({
                    node: makeObservable,
                    messageId: "missingAnnotation",
                    data: { keyList },
                    fix
                })
            }
        }
    }
}

module.exports = {
    meta: {
        type: "suggestion",
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    autofixAnnotation: {
                        type: "boolean"
                    }
                },
                additionalProperties: false
            }
        ],
        docs: {
            description: "enforce all fields being listen in `makeObservable`",
            recommended: true,
            suggestion: false
        },
        messages: {
            missingAnnotation:
                "Missing annotation for {{ keyList }}. To exclude a field, use `false` as annotation."
        }
    },
    create
}



================================================
FILE: packages/eslint-plugin-mobx/src/index.js
================================================
"use strict"

const fs = require("fs")
const path = require("path")

const exhaustiveMakeObservable = require("./exhaustive-make-observable.js")
const unconditionalMakeObservable = require("./unconditional-make-observable.js")
const missingMakeObservable = require("./missing-make-observable.js")
const missingObserver = require("./missing-observer")
const noAnonymousObserver = require("./no-anonymous-observer.js")

const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "package.json"), "utf8"))

const pluginMobx = {
    meta: {
        name: pkg.name,
        version: pkg.version
    },
    rules: {
        "exhaustive-make-observable": exhaustiveMakeObservable,
        "unconditional-make-observable": unconditionalMakeObservable,
        "missing-make-observable": missingMakeObservable,
        "missing-observer": missingObserver,
        "no-anonymous-observer": noAnonymousObserver
    }
}

const recommendedRules = {
    "mobx/exhaustive-make-observable": "warn",
    "mobx/unconditional-make-observable": "error",
    "mobx/missing-make-observable": "error",
    "mobx/missing-observer": "warn"
}

module.exports = {
    ...pluginMobx,
    configs: {
        recommended: {
            plugins: ["mobx"],
            rules: recommendedRules
        }
    },
    flatConfigs: {
        recommended: {
            name: "mobx/recommended",
            plugins: { mobx: pluginMobx },
            rules: recommendedRules
        }
    }
}



================================================
FILE: packages/eslint-plugin-mobx/src/missing-make-observable.js
================================================
'use strict';

const { findAncestor, isMobxDecorator } = require('./utils.js');

function create(context) {
  const sourceCode = context.getSourceCode();

  return {
    'Decorator': decorator => {
      if (!isMobxDecorator(decorator)) return;
      const clazz = findAncestor(decorator, node => node.type === 'ClassDeclaration' || node.type === 'ClassExpression');
      if (!clazz) return;
      // ClassDeclaration > ClassBody > []
      const constructor = clazz.body.body.find(node => node.kind === 'constructor' && node.value.type === 'FunctionExpression') ??
        clazz.body.body.find(node => node.kind === 'constructor');
      // MethodDefinition > FunctionExpression > BlockStatement > []
      const isMakeObservable = node => node.expression?.callee?.name === 'makeObservable' && node.expression?.arguments[0]?.type === 'ThisExpression';
      const makeObservable = constructor?.value.body?.body.find(isMakeObservable)?.expression;

      if (makeObservable) {
        // make sure second arg is nullish
        const secondArg = makeObservable.arguments[1];
        if (secondArg && secondArg.value !== null && secondArg.name !== 'undefined') {
          context.report({
            node: makeObservable,
            messageId: 'secondArgMustBeNullish',
          })
        }
      } else {
        const fix = fixer => {
          if (constructor?.value.type === 'TSEmptyBodyFunctionExpression') {
            // constructor() - yes this a thing
            const closingBracket = sourceCode.getLastToken(constructor.value);
            return fixer.insertTextAfter(closingBracket, ' { makeObservable(this); }')
          } else if (constructor) {
            // constructor() {}
            const closingBracket = sourceCode.getLastToken(constructor.value.body);
            return fixer.insertTextBefore(closingBracket, ';makeObservable(this);')
          } else {
            // class C {}
            const openingBracket = sourceCode.getFirstToken(clazz.body);
            return fixer.insertTextAfter(openingBracket, '\nconstructor() { makeObservable(this); }')
          }
        };

        context.report({
          node: clazz,
          messageId: 'missingMakeObservable',
          fix,
        })
      }
    },
  };
}

module.exports = {
  meta: {
    type: 'problem',
    fixable: 'code',
    docs: {
      description: 'prevents missing `makeObservable(this)` when using decorators',
      recommended: true,
      suggestion: false,
    },
    messages: {
      missingMakeObservable: "Constructor is missing `makeObservable(this)`.",
      secondArgMustBeNullish: "`makeObservable`'s second argument must be nullish or not provided when using decorators."
    },
  },
  create,
};


================================================
FILE: packages/eslint-plugin-mobx/src/missing-observer.js
================================================
"use strict"

function create(context) {
    const sourceCode = context.getSourceCode()

    return {
        "FunctionDeclaration,FunctionExpression,ArrowFunctionExpression,ClassDeclaration,ClassExpression":
            cmp => {
                if (
                    cmp.parent &&
                    cmp.parent.type === "CallExpression" &&
                    cmp.parent.callee.name === "observer"
                ) {
                    // observer(...)
                    return
                }
                let forwardRef =
                    cmp.parent &&
                    cmp.parent.type === "CallExpression" &&
                    cmp.parent.callee.name === "forwardRef"
                        ? cmp.parent
                        : undefined
                if (
                    forwardRef &&
                    forwardRef.parent &&
                    forwardRef.parent.type === "CallExpression" &&
                    forwardRef.parent.callee.name === "observer"
                ) {
                    // forwardRef(observer(...))
                    return
                }

                const cmpOrForwardRef = forwardRef || cmp
                let name = cmp.id?.name
                // If anonymous try to infer name from variable declaration
                if (!name && cmpOrForwardRef.parent?.type === "VariableDeclarator") {
                    name = cmpOrForwardRef.parent.id.name
                }
                if (cmp.type.startsWith("Class")) {
                    // Must extend Component or React.Component
                    const { superClass } = cmp
                    if (!superClass) {
                        // not a component
                        return
                    }
                    const superClassText = sourceCode.getText(superClass)
                    if (superClassText !== "Component" && superClassText !== "React.Component") {
                        // not a component
                        return
                    }
                } else {
                    // Name must start with uppercase letter
                    if (!name?.charAt(0).match(/^[A-Z]$/)) {
                        // not a component
                        return
                    }
                }

                const fix = fixer => {
                    return [
                        fixer.insertTextBefore(
                            sourceCode.getFirstToken(cmpOrForwardRef),
                            (name && cmp.type.endsWith("Declaration") ? `const ${name} = ` : "") +
                                "observer("
                        ),
                        fixer.insertTextAfter(sourceCode.getLastToken(cmpOrForwardRef), ")")
                    ]
                }
                context.report({
                    node: cmp,
                    messageId: "missingObserver",
                    data: {
                        name: name || "<anonymous>"
                    },
                    fix
                })
            }
    }
}

module.exports = {
    meta: {
        type: "problem",
        fixable: "code",
        docs: {
            description: "prevents missing `observer` on react component",
            recommended: true
        },
        messages: {
            missingObserver: "Component `{{ name }}` is missing `observer`."
        }
    },
    create
}



================================================
FILE: packages/eslint-plugin-mobx/src/no-anonymous-observer.js
================================================
"use strict"

function create(context) {
    const sourceCode = context.getSourceCode()

    return {
        'CallExpression[callee.name="observer"]': observer => {
            const cmp = observer.arguments[0]
            if (!cmp) return
            if (cmp?.id?.name) return

            const fix = fixer => {
                // Use name from variable for autofix
                const name =
                    observer.parent?.type === "VariableDeclarator"
                        ? observer.parent.id.name
                        : undefined

                if (!name) return
                if (cmp.type === "ArrowFunctionExpression") {
                    const arrowToken = sourceCode.getTokenBefore(cmp.body)
                    const fixes = [
                        fixer.replaceText(arrowToken, ""),
                        fixer.insertTextBefore(cmp, `function ${name}`)
                    ]
                    if (cmp.body.type !== "BlockStatement") {
                        fixes.push(
                            fixer.insertTextBefore(cmp.body, `{ return `),
                            fixer.insertTextAfter(cmp.body, ` }`)
                        )
                    }
                    return fixes
                }
                if (cmp.type === "FunctionExpression") {
                    const functionToken = sourceCode.getFirstToken(cmp)
                    return fixer.replaceText(functionToken, `function ${name}`)
                }
                if (cmp.type === "ClassExpression") {
                    const classToken = sourceCode.getFirstToken(cmp)
                    return fixer.replaceText(classToken, `class ${name}`)
                }
            }
            context.report({
                node: cmp,
                messageId: "observerComponentMustHaveName",
                fix
            })
        }
    }
}

module.exports = {
    meta: {
        type: "problem",
        fixable: "code",
        docs: {
            description: "forbids anonymous functions or classes as `observer` components",
            recommended: true
        },
        messages: {
            observerComponentMustHaveName: "`observer` component must have a name."
        }
    },
    create
}



================================================
FILE: packages/eslint-plugin-mobx/src/unconditional-make-observable.js
================================================
'use strict';

const { findAncestor } = require('./utils.js');

function create(context) {
  return {
    'CallExpression[callee.name=/(makeObservable|makeAutoObservable)/]': makeObservable => {
      // Only iterested about makeObservable(this, ...) inside constructor and not inside nested bindable function
      const [firstArg] = makeObservable.arguments;
      if (!firstArg) return;
      if (firstArg.type !== 'ThisExpression') return;
      //     MethodDefinition[key.name="constructor"][kind="constructor"]
      //       FunctionExpression
      //         BlockStatement
      //           ExpressionStatement
      //             CallExpression[callee.name="makeObservable"]
      const closestFunction = findAncestor(makeObservable, node => node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration');
      if (closestFunction?.parent?.kind !== 'constructor') return;
      if (makeObservable.parent.parent.parent !== closestFunction) {
        context.report({
          node: makeObservable,
          messageId: 'mustCallUnconditionally',
          data: {
            name: makeObservable.callee.name,
          }
        });
      }
    },
  };
}

module.exports = {
  meta: {
    type: 'problem',
    docs: {
      description: 'disallows calling `makeObservable(this)` conditionally inside constructors',
      recommended: true,
    },
    messages: {
      mustCallUnconditionally: '`{{ name }}` must be called unconditionally inside constructor.',
    }
  },
  create,
}


================================================
FILE: packages/eslint-plugin-mobx/src/utils.js
================================================
'use strict';

const mobxDecorators = new Set(['observable', 'computed', 'action', 'flow', 'override']);

function isMobxDecorator(decorator) {
  return mobxDecorators.has(decorator.expression.name) // @foo
    || mobxDecorators.has(decorator.expression.callee?.name) // @foo()
    || mobxDecorators.has(decorator.expression.object?.name) // @foo.bar
}

function findAncestor(node, match) {
  const { parent } = node;
  if (!parent) return;
  if (match(parent)) return parent;
  return findAncestor(parent, match);
}

function assert(expr, error) {
  if (!expr) {
    error ??= 'Assertion failed';
    error = error instanceof Error ? error : new Error(error)
    throw error;
  }
}

module.exports = {
  findAncestor,
  isMobxDecorator,
}


================================================
FILE: packages/mobx/jest.config-decorators.js
================================================
const path = require("path")
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(
    __dirname,
    {
        testRegex: "__tests__/decorators_20223/.*\\.(t|j)sx?$",
        setupFilesAfterEnv: [`<rootDir>/jest.setup.ts`]
    },
    path.resolve(__dirname, "./__tests__/decorators_20223/tsconfig.json")
)



================================================
FILE: packages/mobx/jest.config.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    projects: ["<rootDir>/jest.config.js", "<rootDir>/jest.config-decorators.js"],
    testRegex: "__tests__/v[4|5]/base/.*\\.(t|j)sx?$",
    setupFilesAfterEnv: [`<rootDir>/jest.setup.ts`]
})



================================================
FILE: packages/mobx/jest.setup.ts
================================================
import { configure, _resetGlobalState } from "./src/mobx"

global.setImmediate = global.setImmediate || ((fn, ...args) => global.setTimeout(fn, 0, ...args))

beforeEach(() => {
    // @ts-ignore
    global.__DEV__ = true
    _resetGlobalState()
    configure({
        enforceActions: "never"
    })
})



================================================
FILE: packages/mobx/package.json
================================================
{
    "name": "mobx",
    "version": "6.14.0",
    "description": "Simple, scalable state management.",
    "source": "src/mobx.ts",
    "main": "dist/index.js",
    "umd:main": "dist/mobx.umd.production.min.js",
    "unpkg": "dist/mobx.umd.production.min.js",
    "jsdelivr": "dist/mobx.umd.production.min.js",
    "jsnext:main": "dist/mobx.esm.production.min.js",
    "module": "dist/mobx.esm.js",
    "react-native": "dist/mobx.esm.js",
    "types": "dist/mobx.d.ts",
    "typings": "dist/mobx.d.ts",
    "files": [
        "src",
        "dist",
        "LICENSE",
        "CHANGELOG.md",
        "README.md"
    ],
    "sideEffects": false,
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git"
    },
    "author": "Michel Weststrate",
    "license": "MIT",
    "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mobx"
    },
    "bugs": {
        "url": "https://github.com/mobxjs/mobx/issues"
    },
    "homepage": "https://mobx.js.org/",
    "dependencies": {},
    "devDependencies": {
        "@babel/core": "^7.9.0",
        "@babel/plugin-proposal-class-properties": "^7.8.3",
        "@babel/plugin-proposal-decorators": "^7.8.3",
        "@babel/plugin-transform-runtime": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/runtime": "^7.9.2",
        "conditional-type-checks": "^1.0.5",
        "flow-bin": "^0.123.0"
    },
    "keywords": [
        "mobx",
        "mobservable",
        "observable",
        "react-component",
        "react",
        "reactjs",
        "reactive",
        "model",
        "frp",
        "functional-reactive-programming",
        "state management",
        "data flow"
    ],
    "scripts": {
        "test": "jest",
        "lint": "eslint src/**/*",
        "build": "node ../../scripts/build.js mobx",
        "build:test": "yarn build --target test",
        "perf": "scripts/perf.sh",
        "perf-legacy": "node --expose-gc ./__tests__/perf/index.js legacy",
        "perf-proxy": "node --expose-gc ./__tests__/perf/index.js proxy",
        "test:performance": "yarn perf proxy && yarn perf legacy",
        "test:mixed-versions": "yarn test --testRegex mixed-versions",
        "test:types": "tsc --noEmit",
        "test:flow": "flow check",
        "test:coverage": "yarn test -i --coverage",
        "test:size": "yarn import-size --report . observable computed autorun action",
        "test:check": "yarn test:types",
        "prepublishOnly": "node ./scripts/prepublish.js && yarn build --target publish"
    }
}



================================================
FILE: packages/mobx/tsconfig.json
================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
        "rootDir": "src"
    },
    "include": ["src"]
}



================================================
FILE: packages/mobx/tsdx.config.js
================================================
const { terser } = require("rollup-plugin-terser")

module.exports = {
    // This function will run for each entry/format/env combination
    rollup(config, options) {
        // MWE: disabled minifying esm builds as source maps aren't too reliable.
        // It is a shame because mangle properties saves quite a bit (1 KB gzipped)
        // For comparison:
        // webpack + terser + unminified mobx:
        // 13757
        // webpack + pre-minified mobx:
        // 12949
        if (/*options.format === "esm" || */ options.env === "production") {
            config.plugins.push(
                terser({
                    sourcemap: true,
                    module: true,
                    compress: {
                        hoist_funs: true,
                        passes: 2,
                        keep_fargs: false,
                        pure_getters: true,
                        unsafe: false
                    },
                    mangle: {
                        properties: {
                            regex: /_$/
                        }
                    }
                })
            )
        }
        return config
    }
}



================================================
FILE: packages/mobx/.flowconfig
================================================
[ignore]
.*/node_modules

[include]
__tests__/v5/flow

[libs]
flow-typed/

[options]
suppress_comment= \\(.\\|\n\\)*\\$ExpectError



================================================
FILE: packages/mobx/__tests__/tsconfig.json
================================================
{
    "extends": "../../../tsconfig.test.json"
}



================================================
FILE: packages/mobx/__tests__/.babelrc
================================================
{
    "presets": ["@babel/preset-env"],
    "plugins": [
        [
            "@babel/plugin-transform-runtime",
            {
                "regenerator": true
            }
        ],
        ["@babel/plugin-proposal-decorators", { "legacy": true }],
        ["@babel/plugin-proposal-class-properties", { "loose": false }]
    ]
}



================================================
FILE: packages/mobx/__tests__/decorators_20223/stage3-decorators.ts
================================================
"use strict"

import {
    observe,
    computed,
    observable,
    autorun,
    extendObservable,
    action,
    IObservableArray,
    IArrayWillChange,
    IArrayWillSplice,
    IObservableValue,
    isObservable,
    isObservableProp,
    isObservableObject,
    transaction,
    IObjectDidChange,
    spy,
    configure,
    isAction,
    IAtom,
    createAtom,
    runInAction,
    makeObservable
} from "../../src/mobx"
import { type ObservableArrayAdministration } from "../../src/internal"
import * as mobx from "../../src/mobx"

const testFunction = function (a: any) {}

// lazy wrapper around yest

const t = {
    equal(a: any, b: any) {
        expect(a).toBe(b)
    },
    deepEqual(a: any, b: any) {
        expect(a).toEqual(b)
    },
    notEqual(a: any, b: any) {
        expect(a).not.toEqual(b)
    },

    throws(a: any, b: any) {
        expect(a).toThrow(b)
    }
}

test("decorators", () => {
    class Order {
        @observable accessor price: number = 3
        @observable accessor amount: number = 2
        @observable accessor orders: string[] = []
        @observable accessor aFunction = testFunction

        @computed
        get total() {
            return this.amount * this.price * (1 + this.orders.length)
        }
    }

    const o = new Order()
    t.equal(isObservableObject(o), true)
    t.equal(isObservableProp(o, "amount"), true)
    t.equal(isObservableProp(o, "total"), true)

    const events: any[] = []
    const d1 = observe(o, (ev: IObjectDidChange) => events.push(ev.name, (ev as any).oldValue))
    const d2 = observe(o, "price", ev => events.push(ev.newValue, ev.oldValue))
    const d3 = observe(o, "total", ev => events.push(ev.newValue, ev.oldValue))

    o.price = 4

    d1()
    d2()
    d3()

    o.price = 5

    t.deepEqual(events, [
        8, // new total
        6, // old total
        4, // new price
        3, // old price
        "price", // event name
        3 // event oldValue
    ])
})

test("annotations", () => {
    const fn0 = () => 0
    class Order {
        @observable accessor price: number = 3
        @observable accessor amount: number = 2
        @observable accessor orders: string[] = []
        @observable accessor aFunction = fn0

        @computed
        get total() {
            return this.amount * this.price * (1 + this.orders.length)
        }
    }

    const order1totals: number[] = []
    const order1 = new Order()
    const order2 = new Order()

    const disposer = autorun(() => {
        order1totals.push(order1.total)
    })

    order2.price = 4
    order1.amount = 1

    t.equal(order1.price, 3)
    t.equal(order1.total, 3)
    t.equal(order2.total, 8)
    order2.orders.push("bla")
    t.equal(order2.total, 16)

    order1.orders.splice(0, 0, "boe", "hoi")
    t.deepEqual(order1totals, [6, 3, 9])

    disposer()
    order1.orders.pop()
    t.equal(order1.total, 6)
    t.deepEqual(order1totals, [6, 3, 9])
    expect(isAction(order1.aFunction)).toBe(true)
    expect(order1.aFunction()).toBe(0)
    order1.aFunction = () => 1
    expect(isAction(order1.aFunction)).toBe(true)
    expect(order1.aFunction()).toBe(1)
})

test("box", () => {
    class Box {
        @observable accessor uninitialized: any
        @observable accessor height = 20
        @observable accessor sizes = [2]
        @observable accessor someFunc = function () {
            return 2
        }
        @computed
        get width() {
            return this.height * this.sizes.length * this.someFunc() * (this.uninitialized ? 2 : 1)
        }
        @action("test")
        addSize() {
            this.sizes.push(3)
            this.sizes.push(4)
        }
    }

    const box = new Box()

    const ar: number[] = []

    autorun(() => {
        ar.push(box.width)
    })

    t.deepEqual(ar.slice(), [40])
    box.height = 10
    t.deepEqual(ar.slice(), [40, 20])
    box.sizes.push(3, 4)
    t.deepEqual(ar.slice(), [40, 20, 60])
    box.someFunc = () => 7
    t.deepEqual(ar.slice(), [40, 20, 60, 210])
    box.uninitialized = true
    t.deepEqual(ar.slice(), [40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
})

test("computed setter should succeed", () => {
    class Bla {
        @observable accessor a = 3
        @computed
        get propX() {
            return this.a * 2
        }
        set propX(v) {
            this.a = v
        }
    }

    const b = new Bla()
    t.equal(b.propX, 6)
    b.propX = 4
    t.equal(b.propX, 8)
})

test("ClassFieldDecorators should NOT work without accessor without legacy compilation", () => {
    expect(() => {
        class Order {
            @observable price: number = 3
        }
    }).toThrowError("[MobX] Please use `@observable accessor price` instead of `@observable price`")
})

test("Reasonable error for decorator kind mismatch", () => {
    expect(() => {
        class Order {
            // @ts-ignore
            @computed total = 3
        }
    }).toThrowError("[MobX] The decorator applied to 'total' cannot be used on a field element")
})

test("typescript: parameterized computed decorator", () => {
    class TestClass {
        @observable accessor x = 3
        @observable accessor y = 3
        @computed.struct
        get boxedSum() {
            return { sum: Math.round(this.x) + Math.round(this.y) }
        }
    }

    const t1 = new TestClass()
    const changes: { sum: number }[] = []
    const d = autorun(() => changes.push(t1.boxedSum))

    t1.y = 4 // change
    t.equal(changes.length, 2)
    t1.y = 4.2 // no change
    t.equal(changes.length, 2)
    transaction(() => {
        t1.y = 3
        t1.x = 4
    }) // no change
    t.equal(changes.length, 2)
    t1.x = 6 // change
    t.equal(changes.length, 3)
    d()

    t.deepEqual(changes, [{ sum: 6 }, { sum: 7 }, { sum: 9 }])
})

test("issue 165", () => {
    function report<T>(msg: string, value: T) {
        // console.log(msg, ":", value)
        return value
    }

    class Card {
        constructor(public game: Game, public id: number) {
            makeObservable(this)
        }

        @computed
        get isWrong() {
            return report(
                "Computing isWrong for card " + this.id,
                this.isSelected && this.game.isMatchWrong
            )
        }

        @computed
        get isSelected() {
            return report(
                "Computing isSelected for card" + this.id,
                this.game.firstCardSelected === this || this.game.secondCardSelected === this
            )
        }
    }

    class Game {
        @observable accessor firstCardSelected: Card | null = null
        @observable accessor secondCardSelected: Card | null = null

        @computed
        get isMatchWrong() {
            return report(
                "Computing isMatchWrong",
                this.secondCardSelected !== null &&
                    this.firstCardSelected!.id !== this.secondCardSelected.id
            )
        }
    }

    let game = new Game()
    let card1 = new Card(game, 1),
        card2 = new Card(game, 2)

    autorun(() => {
        card1.isWrong
        card2.isWrong
        // console.log("card1.isWrong =", card1.isWrong)
        // console.log("card2.isWrong =", card2.isWrong)
        // console.log("------------------------------")
    })

    // console.log("Selecting first card")
    game.firstCardSelected = card1
    // console.log("Selecting second card")
    game.secondCardSelected = card2

    t.equal(card1.isWrong, true)
    t.equal(card2.isWrong, true)
})

test("issue 191 - shared initializers (2022.3)", () => {
    class Test {
        @observable accessor obj = { a: 1 }
        @observable accessor array = [2]
    }

    const t1 = new Test()
    t1.obj.a = 2
    t1.array.push(3)

    const t2 = new Test()
    t2.obj.a = 3
    t2.array.push(4)

    t.notEqual(t1.obj, t2.obj)
    t.notEqual(t1.array, t2.array)
    t.equal(t1.obj.a, 2)
    t.equal(t2.obj.a, 3)

    t.deepEqual(t1.array.slice(), [2, 3])
    t.deepEqual(t2.array.slice(), [2, 4])
})

function normalizeSpyEvents(events: any[]) {
    events.forEach(ev => {
        delete ev.fn
        delete ev.time
    })
    return events
}

test("action decorator (2022.3)", () => {
    class Store {
        constructor(private multiplier: number) {}

        @action
        add(a: number, b: number): number {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(2, 2), 12)
    t.equal(store1.add(1, 1), 4)

    t.deepEqual(normalizeSpyEvents(events), [
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [1, 1], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator (2022.3)", () => {
    class Store {
        constructor(private multiplier: number) {}

        @action("zoem zoem")
        add(a: number, b: number): number {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(2, 2), 12)
    t.equal(store1.add(1, 1), 4)

    t.deepEqual(normalizeSpyEvents(events), [
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [1, 1],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("action decorator on field (2022.3)", () => {
    class Store {
        constructor(private multiplier: number) {}

        @action
        add = (a: number, b: number) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)
    expect(store1.add).not.toEqual(store2.add)

    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(4, 5), 63)
    t.equal(store1.add(2, 2), 8)

    t.deepEqual(normalizeSpyEvents(events), [
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [4, 5], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator on field (2022.3)", () => {
    class Store {
        constructor(private multiplier: number) {}

        @action("zoem zoem")
        add = (a: number, b: number) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(4, 5), 63)
    t.equal(store1.add(2, 2), 8)

    t.deepEqual(normalizeSpyEvents(events), [
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [4, 5],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("267 (2022.3) should be possible to declare properties observable outside strict mode", () => {
    configure({ enforceActions: "observed" })

    class Store {
        @observable accessor timer: number | null = null
    }

    configure({ enforceActions: "never" })
})

test("288 atom not detected for object property", () => {
    class Store {
        @observable accessor foo = ""
    }

    const store = new Store()

    mobx.observe(
        store,
        "foo",
        () => {
            // console.log("Change observed")
        },
        true
    )
})

test.skip("observable performance - ts - decorators", () => {
    const AMOUNT = 100000

    class A {
        @observable accessor a = 1
        @observable accessor b = 2
        @observable accessor c = 3
        @computed
        get d() {
            return this.a + this.b + this.c
        }
    }

    const objs: any[] = []
    const start = Date.now()

    for (let i = 0; i < AMOUNT; i++) objs.push(new A())

    console.log("created in ", Date.now() - start)

    for (let j = 0; j < 4; j++) {
        for (let i = 0; i < AMOUNT; i++) {
            const obj = objs[i]
            obj.a += 3
            obj.b *= 4
            obj.c = obj.b - obj.a
            obj.d
        }
    }

    console.log("changed in ", Date.now() - start)
})

test("unbound methods", () => {
    class A {
        // shared across all instances
        @action
        m1() {}
    }

    const a1 = new A()
    const a2 = new A()

    t.equal(a1.m1, a2.m1)
    t.equal(Object.hasOwnProperty.call(a1, "m1"), false)
    t.equal(Object.hasOwnProperty.call(a2, "m1"), false)
})

test("inheritance", () => {
    class A {
        @observable accessor a = 2
    }

    class B extends A {
        @observable accessor b = 3
        @computed
        get c() {
            return this.a + this.b
        }
        constructor() {
            super()
            makeObservable(this)
        }
    }
    const b1 = new B()
    const b2 = new B()
    const values: any[] = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    t.deepEqual(values, [10, 11, 12, 14, 18])
})

test("inheritance overrides observable", () => {
    class A {
        @observable accessor a = 2
    }

    class B {
        @observable accessor a = 5
        @observable accessor b = 3
        @computed
        get c() {
            return this.a + this.b
        }
    }

    const b1 = new B()
    const b2 = new B()
    const values: any[] = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    t.deepEqual(values, [16, 14, 15, 17, 18])
})

test("reusing initializers", () => {
    class A {
        @observable accessor a = 3
        @observable accessor b = this.a + 2
        @computed
        get c() {
            return this.a + this.b
        }
        @computed
        get d() {
            return this.c + 1
        }
    }

    const a = new A()
    const values: any[] = []
    mobx.autorun(() => values.push(a.d))

    a.a = 4
    t.deepEqual(values, [9, 10])
})

test("enumerability", () => {
    class A {
        @observable accessor a = 1 // enumerable, on proto
        @computed
        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        @action
        m() {} // non-enumerable, on proto
    }

    const a = new A()

    // not initialized yet
    let ownProps = Object.keys(a)
    let enumProps: string[] = []
    for (const key in a) enumProps.push(key)

    t.deepEqual(ownProps, [])

    t.deepEqual(enumProps, [])

    t.equal("a" in a, true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("a"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("b"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m"), false)

    t.equal(mobx.isAction(a.m), true)

    // after initialization
    a.a
    a.b
    a.m

    ownProps = Object.keys(a)
    enumProps = []
    for (const key in a) enumProps.push(key)

    t.deepEqual(ownProps, [])

    t.deepEqual(enumProps, [])

    t.equal("a" in a, true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("a"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("b"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m"), false)
})

// Re-enable when late initialization is supported in TS
test.skip("issue 285 (2022.3)", () => {
    const { observable, toJS } = mobx

    class Todo {
        id = 1
        @observable accessor title: string
        @observable accessor finished = false
        @observable accessor childThings = [1, 2, 3]
        @computed get bla() {
            return 3
        }
        @action someMethod() {}
        constructor(title: string) {
            this.title = title
        }
    }

    const todo = new Todo("Something to do")

    t.deepEqual(toJS(todo), {
        id: 1,
        title: "Something to do",
        finished: false,
        childThings: [1, 2, 3]
    })
})

// Re-enable when late initialization is supported in TS
test.skip("verify object assign (2022.3) (legacy/field decorator)", () => {
    class Todo {
        @observable accessor title = "test"
        @computed
        get upperCase() {
            return this.title.toUpperCase()
        }
    }

    t.deepEqual((Object as any).assign({}, new Todo()), {
        title: "test"
    })
})

test("373 - fix isObservable for unused computed", () => {
    class Bla {
        ts_53332_workaround: string = ""

        @computed
        get computedVal() {
            return 3
        }
        constructor() {
            makeObservable(this)
            t.equal(isObservableProp(this, "computedVal"), true)
            this.computedVal
            t.equal(isObservableProp(this, "computedVal"), true)
        }
    }

    new Bla()
})

test("705 - setter undoing caching (2022.3)", () => {
    let recomputes = 0
    let autoruns = 0

    class Person {
        @observable accessor name: string = ""
        @observable accessor title: string = ""

        // Typescript bug: if fullName is before the getter, the property is defined twice / incorrectly, see #705
        // set fullName(val) {
        // 	// Noop
        // }
        @computed
        get fullName() {
            recomputes++
            return this.title + " " + this.name
        }
        // Should also be possible to define the setter _before_ the fullname
        set fullName(val) {
            // Noop
        }
    }

    let p1 = new Person()
    p1.name = "Tom Tank"
    p1.title = "Mr."

    t.equal(recomputes, 0)
    t.equal(autoruns, 0)

    const d1 = autorun(() => {
        autoruns++
        p1.fullName
    })

    const d2 = autorun(() => {
        autoruns++
        p1.fullName
    })

    t.equal(recomputes, 1)
    t.equal(autoruns, 2)

    p1.title = "Master"
    t.equal(recomputes, 2)
    t.equal(autoruns, 4)

    d1()
    d2()
})

test("@observable.ref (2022.3)", () => {
    class A {
        @observable.ref accessor ref = { a: 3 }
    }

    const a = new A()
    t.equal(a.ref.a, 3)
    t.equal(mobx.isObservable(a.ref), false)
    t.equal(mobx.isObservableProp(a, "ref"), true)
})

test("@observable.shallow (2022.3)", () => {
    class A {
        @observable.shallow accessor arr = [{ todo: 1 }]
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)
    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr[0]), false)
    t.equal(mobx.isObservable(a.arr[1]), false)
    t.equal(a.arr[1] === todo2, true)
})

test("@observable.shallow - 2 (2022.3)", () => {
    class A {
        @observable.shallow accessor arr: Record<string, any> = { x: { todo: 1 } }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.y = todo2
    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr.x), false)
    t.equal(mobx.isObservable(a.arr.y), false)
    t.equal(a.arr.y === todo2, true)
})

test("@observable.deep (2022.3)", () => {
    class A {
        @observable.deep accessor arr = [{ todo: 1 }]
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)

    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr[0]), true)
    t.equal(mobx.isObservable(a.arr[1]), true)
    t.equal(a.arr[1] !== todo2, true)
    t.equal(isObservable(todo2), false)
})

test("action.bound binds (2022.3)", () => {
    class A {
        @observable accessor x = 0
        @action.bound
        inc(value: number) {
            this.x += value
        }
    }

    const a = new A()
    const runner = a.inc
    runner(2)

    t.equal(a.x, 2)
})

test("action.bound binds property function (2022.3)", () => {
    class A {
        @observable accessor x = 0
        @action.bound
        inc = function (value: number) {
            this.x += value
        }
    }

    const a = new A()
    const runner = a.inc
    runner(2)

    t.equal(a.x, 2)
})

test("@computed.equals (2022.3)", () => {
    const sameTime = (from: Time, to: Time) => from.hour === to.hour && from.minute === to.minute
    class Time {
        constructor(hour: number, minute: number) {
            makeObservable(this)
            this.hour = hour
            this.minute = minute
        }

        @observable public accessor hour: number
        @observable public accessor minute: number

        @computed({ equals: sameTime })
        public get time() {
            return { hour: this.hour, minute: this.minute }
        }
    }
    const time = new Time(9, 0)

    const changes: Array<{ hour: number; minute: number }> = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.hour = 9
    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.minute = 0
    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.hour = 10
    t.deepEqual(changes, [
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    t.deepEqual(changes, [
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("1072 - @observable accessor without initial value and observe before first access", () => {
    class User {
        @observable accessor loginCount: number = 0
    }

    const user = new User()
    observe(user, "loginCount", () => {})
})

test("unobserved computed reads should warn with requiresReaction enabled", () => {
    const consoleWarn = console.warn
    const warnings: string[] = []
    console.warn = function (...args) {
        warnings.push(...args)
    }
    try {
        class A {
            @observable accessor x = 0

            @computed({ requiresReaction: true })
            get y() {
                return this.x * 2
            }
        }

        const a = new A()

        a.y
        const d = mobx.reaction(
            () => a.y,
            () => {}
        )
        a.y
        d()
        a.y

        expect(warnings.length).toEqual(2)
        expect(warnings[0]).toContain(
            "is being read outside a reactive context. Doing a full recompute."
        )
        expect(warnings[1]).toContain(
            "is being read outside a reactive context. Doing a full recompute."
        )
    } finally {
        console.warn = consoleWarn
    }
})

test("multiple inheritance should work", () => {
    class A {
        @observable accessor x = 1
    }

    class B extends A {
        @observable accessor y = 1

        constructor() {
            super()
            makeObservable(this)
        }
    }

    const obsvKeys = [
        ...(mobx._getAdministration(new B()) as ObservableArrayAdministration).values_.keys()
    ]
    expect(obsvKeys).toEqual(["x", "y"])
})

// 19.12.2020 @urugator:
// All annotated non-observable fields are not writable.
// All annotated fields of non-plain objects are non-configurable.
// https://github.com/mobxjs/mobx/pull/2641
test.skip("actions are reassignable", () => {
    // See #1398 and #1545, make actions reassignable to support stubbing
    class A {
        @action
        m1() {}
        @action.bound
        m3() {}
    }

    const a = new A()
    expect(isAction(a.m1)).toBe(true)
    expect(isAction(a.m3)).toBe(true)
    a.m1 = () => {}
    expect(isAction(a.m1)).toBe(false)
    a.m3 = () => {}
    expect(isAction(a.m3)).toBe(false)
})

test("it should support asyncAction as decorator (2022.3)", async () => {
    mobx.configure({ enforceActions: "observed" })

    class X {
        @observable accessor a = 1

        f = mobx.flow(function* f(this: X, initial: number) {
            this.a = initial // this runs in action
            this.a += yield Promise.resolve(5) as any
            this.a = this.a * 2
            return this.a
        })
    }

    const x = new X()

    expect(await x.f(3)).toBe(16)
})

test("toJS bug #1413 (2022.3)", () => {
    class X {
        @observable
        accessor test = {
            test1: 1
        }
    }

    const x = new X()
    const res = mobx.toJS(x.test) as any
    expect(res).toEqual({ test1: 1 })
    expect(res.__mobxDidRunLazyInitializers).toBe(undefined)
})

test("#2159 - computed property keys", () => {
    const testSymbol = Symbol("test symbol")
    const testString = "testString"

    class TestClass {
        @observable accessor [testSymbol] = "original symbol value"
        @observable accessor [testString] = "original string value"
    }

    const o = new TestClass()

    const events: any[] = []
    observe(o, testSymbol, ev => events.push(ev.newValue, ev.oldValue))
    observe(o, testString, ev => events.push(ev.newValue, ev.oldValue))

    runInAction(() => {
        o[testSymbol] = "new symbol value"
        o[testString] = "new string value"
    })

    t.deepEqual(events, [
        "new symbol value", // new symbol
        "original symbol value", // original symbol
        "new string value", // new string
        "original string value" // original string
    ])
})

test(`decorated field can be inherited, but doesn't inherite the effect of decorator`, () => {
    class Store {
        @action
        action = () => {
            return
        }
    }

    class SubStore extends Store {
        action = () => {
            // should not be a MobX action
            return
        }
    }

    const store = new Store()
    expect(isAction(store.action)).toBe(true)

    const subStore = new SubStore()
    expect(isAction(subStore.action)).toBe(false)
})



================================================
FILE: packages/mobx/__tests__/decorators_20223/tsconfig.json
================================================
{
    "extends": ["../../tsconfig.json", "../../../../tsconfig.test.json"],
    "compilerOptions": {
        "target": "ES6",
        "experimentalDecorators": false,
        "useDefineForClassFields": true,

        "rootDir": "../../"
    },
    "exclude": ["__tests__"],
    "include": ["./", "../../src"] // ["../../src", "./"]
}



================================================
FILE: packages/mobx/__tests__/mixed-versions/mixed-versions.js
================================================
const fs = require("fs")
const child_process = require("child_process")

if (!fs.existsSync(__dirname + "/../../dist/mobx.umd.development.js")) {
    // make sure the minified build exists
    child_process.execSync("yarn build", { stdio: "inherit" })
}

const mobx1 = require("../../dist")
/* istanbul ignore next */
const mobx2 = require("../../dist/mobx.umd.development.js")

test("two versions should not work together by default", () => {
    expect(global.__mobxInstanceCount).toBe(2)
    expect(global.__mobxGlobals).not.toBe(undefined)

    const a = mobx1.observable({
        x: 1
    })
    const b = mobx2.observable({
        x: 3
    })

    const values = []
    const d1 = mobx1.autorun(() => {
        values.push(b.x)
    })
    const d2 = mobx2.autorun(() => {
        values.push(a.x)
    })

    a.x = 2
    b.x = 4

    d1()
    d2()

    expect(values).toEqual([3, 1, 2, 4])
})

test("two versions should not work together if state is isolated", () => {
    mobx1.configure({ isolateGlobalState: true })
    expect(global.__mobxInstanceCount).toBe(1)
    expect(global.__mobxGlobals).not.toBe(undefined)

    const a = mobx1.observable({
        x: 1
    })
    const b = mobx2.observable({
        x: 3
    })

    const values = []
    const d1 = mobx1.autorun(() => {
        values.push(b.x)
    })
    const d2 = mobx2.autorun(() => {
        values.push(a.x)
    })

    a.x = 2
    b.x = 4

    d1()
    d2()

    expect(values).toEqual([3, 1])
})

test("global state should disappear if all imports are isolated", () => {
    mobx2.configure({ isolateGlobalState: true })
    expect(global.__mobxInstanceCount).toBe(0)
    expect(global.__mobxGlobals).toBe(undefined)
    const a = mobx1.observable({
        x: 1
    })
    const b = mobx2.observable({
        x: 3
    })

    const values = []
    const d1 = mobx1.autorun(() => {
        values.push(b.x)
    })
    const d2 = mobx2.autorun(() => {
        values.push(a.x)
    })

    a.x = 2
    b.x = 4

    d1()
    d2()

    expect(values).toEqual([3, 1])
})



================================================
FILE: packages/mobx/__tests__/mixed-versions/state-sharing.js
================================================
"use strict"
const child_process = require("child_process")

function testOutput(cmd, expected) {
    it("Global state sharing: " + cmd, done => {
        child_process.exec("node -e '" + cmd + "'", { cwd: __dirname }, (e, stdout, stderr) => {
            if (e) {
                if (!expected) done.fail(e)
                else {
                    expect("" + e).toContain(expected)
                    done()
                }
            } else {
                expect(stdout.toString()).toBe("")
                expect(stderr.toString()).toBe(expected)
                done()
            }
        })
    })
}

describe("it should handle multiple instances with the correct warnings", () => {
    testOutput(
        'require("../../dist");global.__mobxGlobals.version = -1; require("../../dist/mobx.umd.development.js")',
        "There are multiple, different versions of MobX active. Make sure MobX is loaded only once"
    )
    testOutput(
        'const m = require("../../dist/"); global.__mobxGlobals.version = -1; m.configure({isolateGlobalState: true});require("../../dist/mobx.umd.development.js").configure({isolateGlobalState: true})',
        ""
    )
    // testOutput(
    //     'require("../../");global.__mobxGlobals.version = -1;require("../../mobx.umd.development.js").configure({isolateGlobalState: true})',
    //     ""
    // )
    testOutput(
        'const m = require("../../dist/");global.__mobxGlobals.version = -1;m.configure({isolateGlobalState: true});require("../../dist/mobx.umd.development.js")',
        ""
    )
})



================================================
FILE: packages/mobx/__tests__/perf/index.js
================================================
const start = Date.now()
const mkdirp = require("mkdirp")

const ver = process.argv[2]
if (!ver || !ver.match(/legacy|proxy/)) {
    throw new Error("specify version to perf test as (legacy|proxy)")
}

if (process.env.PERSIST) {
    const fs = require("fs")
    const path = require("path")
    const logFile = path.resolve(`${__dirname}/../../perf_report/${ver}.txt`)
    mkdirp.sync(path.dirname(logFile))
    // clear previous results
    if (fs.existsSync(logFile)) fs.unlinkSync(logFile)

    exports.logMeasurement = function (msg) {
        console.log(msg)
        fs.appendFileSync(logFile, "\n" + msg, "utf8")
    }
} else {
    exports.logMeasurement = function (msg) {
        console.log(msg)
    }
}

const perf = require("./perf.js")
perf(ver)

// This test runs last..
require("tape")(t => {
    exports.logMeasurement(
        "\n\nCompleted performance suite in " + (Date.now() - start) / 1000 + " sec."
    )
    t.end()
})



================================================
FILE: packages/mobx/__tests__/perf/perf.js
================================================
const test = require("tape")
const log = require("./index.js").logMeasurement

function gc() {
    if (typeof global.gc === "function") global.gc()
}

function voidObserver() {
    // nothing, nada, noppes.
}

module.exports = function runForVersion(version) {
    /*
results of this test:
300/40000 mseconds on netbook (AMD c60 processor, same test is on Intel i7 3770 ~10 times faster)
220/37000 after removing forEach
140/30000 after not using (un)shift / pop / push
186/113 after remove filter/length call to detect whether depencies are stable. 300 times faster. w00t.

*/
    const mobx = require(`../../dist/mobx.cjs.production.min.js`)
    if (version === "legacy") {
        mobx.configure({ useProxies: false })
    }
    const observable = mobx.observable
    const computed = mobx.computed

    test(`${version} - one observes ten thousand that observe one`, function (t) {
        gc()
        const a = observable.box(2)

        // many observers that listen to one..
        const observers = []
        for (let i = 0; i < 10000; i++) {
            ;(function (idx) {
                observers.push(
                    computed(function () {
                        return a.get() * idx
                    })
                )
            })(i)
        }

        // let bCalcs = 0
        // one observers that listens to many..
        const b = computed(function () {
            let res = 0
            for (let i = 0; i < observers.length; i++) res += observers[i].get()
            // bCalcs += 1
            return res
        })

        const start = now()

        mobx.observe(b, voidObserver, true) // start observers
        t.equal(99990000, b.get())
        const initial = now()

        a.set(3)
        t.equal(149985000, b.get()) // yes, I verified ;-).
        //t.equal(2, bCalcs);
        const end = now()

        log(
            "One observers many observes one - Started/Updated in " +
                (initial - start) +
                "/" +
                (end - initial) +
                " ms."
        )
        t.end()
    })

    test(`${version} - five hundrend properties that observe their sibling`, function (t) {
        gc()
        const observables = [observable.box(1)]
        for (let i = 0; i < 500; i++) {
            ;(function (idx) {
                observables.push(
                    computed(function () {
                        return observables[idx].get() + 1
                    })
                )
            })(i)
        }

        const start = now()

        const last = observables[observables.length - 1]
        mobx.observe(last, voidObserver)
        t.equal(501, last.get())
        const initial = now()

        observables[0].set(2)
        t.equal(502, last.get())
        const end = now()

        log(
            "500 props observing sibling -  Started/Updated in " +
                (initial - start) +
                "/" +
                (end - initial) +
                " ms."
        )
        t.end()
    })

    test(`${version} - late dependency change`, function (t) {
        gc()
        const values = []
        for (let i = 0; i < 100; i++) values.push(observable.box(0))

        const sum = computed(function () {
            let sum = 0
            for (let i = 0; i < 100; i++) sum += values[i].get()
            return sum
        })

        mobx.observe(sum, voidObserver, true)

        const start = new Date()

        for (let i = 0; i < 10000; i++) values[99].set(i)

        t.equal(sum.get(), 9999)
        log("Late dependency change - Updated in " + (new Date() - start) + "ms.")
        t.end()
    })

    test(`${version} - lots of unused computables`, function (t) {
        gc()
        const a = observable.box(1)

        // many observers that listen to one..
        const observers = []
        for (let i = 0; i < 10000; i++) {
            ;(function (idx) {
                observers.push(
                    computed(function () {
                        return a.get() * idx
                    })
                )
            })(i)
        }

        // one observers that listens to many..
        const b = computed(function () {
            let res = 0
            for (let i = 0; i < observers.length; i++) res += observers[i].get()
            return res
        })

        let sum = 0
        const subscription = mobx.observe(
            b,
            function (e) {
                sum = e.newValue
            },
            true
        )

        t.equal(sum, 49995000)

        // unsubscribe, nobody should listen to a() now!
        subscription()

        const start = now()

        a.set(3)
        t.equal(sum, 49995000) // unchanged!

        const end = now()

        log("Unused computables -   Updated in " + (end - start) + " ms.")
        t.end()
    })

    test(`${version} - many unreferenced observables`, function (t) {
        gc()
        const a = observable.box(3)
        const b = observable.box(6)
        const c = observable.box(7)
        const d = computed(function () {
            return a.get() * b.get() * c.get()
        })
        t.equal(d.get(), 126)
        const start = now()
        for (let i = 0; i < 10000; i++) {
            c.set(i)
            d.get()
        }
        const end = now()

        log("Unused observables -  Updated in " + (end - start) + " ms.")

        t.end()
    })

    test(`${version} - array.es2023 findLastIndex methods`, function (t) {
        gc()
        let aCalc = 0
        let bCalc = 0
        const ar = observable([0])
        const findLastIndexOfZero = computed(function () {
            aCalc++
            return ar.findLastIndex(x => x === 0)
        })
        const lastIndexOfZero = computed(function () {
            bCalc++
            return ar.lastIndexOf(0)
        })
        mobx.observe(findLastIndexOfZero, voidObserver, true)
        mobx.observe(lastIndexOfZero, voidObserver, true)

        const start = now()

        t.equal(1, aCalc)
        t.equal(1, bCalc)
        for (let i = 1; i < 10000; i++) ar.push(i)

        t.equal(0, lastIndexOfZero.get())
        t.equal(0, findLastIndexOfZero.get())
        t.equal(10000, aCalc)
        t.equal(10000, bCalc)

        const end = now()

        log("Array findLastIndex loop -  Updated in " + (end - start) + " ms.")
        t.end()
    })

    test(`${version} - array reduce`, function (t) {
        gc()
        let aCalc = 0
        const ar = observable([])
        const b = observable.box(1)

        const sum = computed(function () {
            aCalc++
            return ar.reduce(function (a, c) {
                return a + c * b.get()
            }, 0)
        })
        mobx.observe(sum, voidObserver)

        const start = now()

        for (let i = 0; i < 1000; i++) ar.push(i)

        t.equal(499500, sum.get())
        t.equal(1001, aCalc)
        aCalc = 0

        const initial = now()

        for (let i = 0; i < 1000; i++) ar[i] = ar[i] * 2
        b.set(2)

        t.equal(1998000, sum.get())
        t.equal(1000, aCalc)

        const end = now()

        log(
            "Array reduce -  Started/Updated in " +
                (initial - start) +
                "/" +
                (end - initial) +
                " ms."
        )
        t.end()
    })

    test(`${version} - array classic loop`, function (t) {
        gc()
        const ar = observable([])
        let aCalc = 0
        const b = observable.box(1)
        const sum = computed(function () {
            let s = 0
            aCalc++
            for (let i = 0; i < ar.length; i++) s += ar[i] * b.get()
            return s
        })
        mobx.observe(sum, voidObserver, true) // calculate

        const start = now()

        t.equal(1, aCalc)
        for (let i = 0; i < 1000; i++) ar.push(i)

        t.equal(499500, sum.get())
        t.equal(1001, aCalc)

        const initial = now()
        aCalc = 0

        for (let i = 0; i < 1000; i++) ar[i] = ar[i] * 2
        b.set(2)

        t.equal(1998000, sum.get())
        t.equal(1000, aCalc)

        const end = now()

        log(
            "Array loop -  Started/Updated in " + (initial - start) + "/" + (end - initial) + " ms."
        )
        t.end()
    })

    function order_system_helper(t, usebatch, keepObserving) {
        gc()
        t.equal(mobx._isComputingDerivation(), false)
        const orders = observable([])
        const vat = observable.box(2)

        const totalAmount = computed(function () {
            let sum = 0,
                l = orders.length
            for (let i = 0; i < l; i++) sum += orders[i].total.get()
            return sum
        })

        function OrderLine(order, price, amount) {
            this.price = observable.box(price)
            this.amount = observable.box(amount)
            this.total = computed(
                function () {
                    return order.vat.get() * this.price.get() * this.amount.get()
                },
                { context: this }
            )
        }

        function Order(includeVat) {
            this.includeVat = observable.box(includeVat)
            this.lines = observable([])

            this.vat = computed(
                function () {
                    if (this.includeVat.get()) return vat.get()
                    return 1
                },
                { context: this }
            )

            this.total = computed(
                function () {
                    return this.lines.reduce(function (acc, order) {
                        return acc + order.total.get()
                    }, 0)
                },
                { context: this }
            )
        }

        let disp
        if (keepObserving) disp = mobx.observe(totalAmount, voidObserver)

        const start = now()

        function setup() {
            for (let i = 0; i < 100; i++) {
                const c = new Order(i % 2 == 0)
                orders.push(c)
                for (let j = 0; j < 100; j++) c.lines.unshift(new OrderLine(c, 5, 5))
            }
        }

        if (usebatch) mobx.transaction(setup)
        else setup()

        t.equal(totalAmount.get(), 375000)

        const initial = now()

        function update() {
            for (let i = 0; i < 50; i++) orders[i].includeVat.set(!orders[i].includeVat.get())
            vat.set(3)
        }

        if (usebatch) mobx.transaction(update)
        else update()

        t.equal(totalAmount.get(), 500000)

        if (keepObserving) disp()

        const end = now()
        log(
            "Order system batched: " +
                usebatch +
                " tracked: " +
                keepObserving +
                "  Started/Updated in " +
                (initial - start) +
                "/" +
                (end - initial) +
                " ms."
        )

        t.end()
    }

    test(`${version} - order system observed`, function (t) {
        order_system_helper(t, false, true)
    })

    test(`${version} - order system batched observed`, function (t) {
        order_system_helper(t, true, true)
    })

    test(`${version} - order system lazy`, function (t) {
        order_system_helper(t, false, false)
    })

    test(`${version} - order system batched lazy`, function (t) {
        order_system_helper(t, true, false)
    })

    test(`${version} - create array`, function (t) {
        gc()
        const a = []
        for (let i = 0; i < 1000; i++) a.push(i)
        const start = now()
        for (let i = 0; i < 1000; i++) observable.array(a)
        log("\nCreate array -  Created in " + (now() - start) + "ms.")
        t.end()
    })

    test(`${version} - create array (fast)`, function (t) {
        gc()
        const a = []
        for (let i = 0; i < 1000; i++) a.push(i)
        const start = now()
        for (let i = 0; i < 1000; i++) mobx.observable.array(a, { deep: false })
        log("\nCreate array (non-recursive)  Created in " + (now() - start) + "ms.")
        t.end()
    })

    test(`${version} - observe and dispose`, t => {
        gc()

        const start = now()
        const a = mobx.observable.box(1)
        const observers = []
        const MAX = 50000

        for (let i = 0; i < MAX * 2; i++) observers.push(mobx.autorun(() => a.get()))
        a.set(2)
        // favorable order
        // + unfavorable order
        for (let i = 0; i < MAX; i++) {
            observers[i]()
            observers[observers.length - 1 - i]()
        }

        log("Observable with many observers  + dispose: " + (now() - start) + "ms")
        t.end()
    })

    test(`${version} - sort`, t => {
        gc()

        function Item(a, b, c) {
            mobx.extendObservable(this, {
                a: a,
                b: b,
                c: c,
                get d() {
                    return this.a + this.b + this.c
                }
            })
        }
        const items = mobx.observable([])

        function sortFn(l, r) {
            items.length // screw all optimizations!
            l.d
            r.d
            if (l.a > r.a) return 1
            if (l.a < r.a) return -1
            if (l.b > r.b) return 1
            if (l.b < r.b) return -1
            if (l.c > r.c) return 1
            if (l.c < r.c) return -1
            return 0
        }

        const sorted = mobx.computed(() => {
            items.slice().sort(sortFn)
        })

        let start = now()
        const MAX = 100000

        const ar = mobx.autorun(() => sorted.get())

        mobx.transaction(() => {
            for (let i = 0; i < MAX; i++) items.push(new Item(i % 10, i % 3, i % 7))
        })

        log("expensive sort: created " + (now() - start))
        start = now()

        for (let i = 0; i < 5; i++) {
            items[i * 1000].a = 7
            items[i * 1100].b = 5
            items[i * 1200].c = 9
        }

        log("expensive sort: updated " + (now() - start))
        start = now()

        ar()

        log("expensive sort: disposed " + (now() - start))

        const plain = mobx.toJS(items, false)
        t.equal(plain.length, MAX)

        start = now()
        for (let i = 0; i < 5; i++) {
            plain[i * 1000].a = 7
            plain.sort(sortFn)
            plain[i * 1100].b = 5
            plain.sort(sortFn)
            plain[i * 1200].c = 9
            plain.sort(sortFn)
        }
        log("native plain sort: updated " + (now() - start))

        t.end()
    })

    test(`${version} - computed temporary memoization`, t => {
        "use strict"
        gc()
        const computeds = []
        for (let i = 0; i < 40; i++) {
            computeds.push(
                mobx.computed(() => (i ? computeds[i - 1].get() + computeds[i - 1].get() : 1))
            )
        }
        const start = now()
        t.equal(computeds[27].get(), 134217728)

        log("computed memoization " + (now() - start) + "ms")
        t.end()
    })

    test(`${version} - Set: initializing`, function (t) {
        gc()
        const iterationsCount = 100000
        let i

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            mobx.observable.set()
        }
        const end = Date.now()
        log("Initilizing " + iterationsCount + " maps: " + (end - start) + " ms.")
        t.end()
    })

    test(`${version} - Set: setting and deleting properties`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 10000
        const set = mobx.observable.set()
        let i
        let p

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            for (p = 0; p < propertiesCount; p++) {
                set.add("" + p)
            }
            for (p = 0; p < propertiesCount; p++) {
                set.delete("" + p)
            }
        }
        const end = Date.now()

        log(
            "Setting and deleting " +
                propertiesCount +
                " set properties " +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })

    test(`${version} - Set: looking up properties`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 10000
        const set = mobx.observable.set()
        let i
        let p

        for (p = 0; p < propertiesCount; p++) {
            set.add("" + p)
        }

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            for (p = 0; p < propertiesCount; p++) {
                set.has("" + p)
            }
        }
        const end = Date.now()

        log(
            "Looking up " +
                propertiesCount +
                " set properties " +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })

    test(`${version} - Set: iterator helpers`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 10000
        const set = mobx.observable.set()
        let i
        let p

        for (p = 0; p < propertiesCount; p++) {
            set.add("" + p)
        }

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            set.entries().take(1)
        }
        const end = Date.now()

        log(
            "Single take out of" +
                propertiesCount +
                " set properties " +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })

    test(`${version} - Set: conversion to array`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 10000
        const set = mobx.observable.set()
        let i
        let p

        for (p = 0; p < propertiesCount; p++) {
            set.add("" + p)
        }

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            Array.from(set.keys())
            Array.from(set.values())
            Array.from(set.entries())
            ;[...set]
        }
        const end = Date.now()

        log(
            "Converting " +
                propertiesCount +
                " set properties into an array" +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })

    test(`${version} - Map: initializing`, function (t) {
        gc()
        const iterationsCount = 100000
        let i

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            mobx.observable.map()
        }
        const end = Date.now()
        log("Initilizing " + iterationsCount + " maps: " + (end - start) + " ms.")
        t.end()
    })

    test(`${version} - Map: looking up properties`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 100
        const map = mobx.observable.map()
        let i
        let p

        for (p = 0; p < propertiesCount; p++) {
            map.set("" + p, p)
        }

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            for (p = 0; p < propertiesCount; p++) {
                map.get("" + p)
            }
        }
        const end = Date.now()

        log(
            "Looking up " +
                propertiesCount +
                " map properties " +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })

    test(`${version} - Map: setting and deleting properties`, function (t) {
        gc()
        const iterationsCount = 1000
        const propertiesCount = 100
        const map = mobx.observable.map()
        let i
        let p

        const start = Date.now()
        for (i = 0; i < iterationsCount; i++) {
            for (p = 0; p < propertiesCount; p++) {
                map.set("" + p, i)
            }
            for (p = 0; p < propertiesCount; p++) {
                map.delete("" + p, i)
            }
        }
        const end = Date.now()

        log(
            "Setting and deleting " +
                propertiesCount +
                " map properties " +
                iterationsCount +
                " times: " +
                (end - start) +
                " ms."
        )
        t.end()
    })
}

function now() {
    return +new Date()
}



================================================
FILE: packages/mobx/__tests__/v4/mobx4.ts
================================================
import { configure } from "../../src/mobx"

configure({
    useProxies: "never",
    enforceActions: "never"
})

export * from "../../src/mobx"



================================================
FILE: packages/mobx/__tests__/v4/base/array.js
================================================
"use strict"

const { LegacyObservableArray } = require("../../../src/internal")
const mobx = require("../mobx4")
const { observable, _getAdministration, reaction, makeObservable } = mobx
const iterall = require("iterall")

let consoleWarnMock
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

expect.addEqualityTesters([
    function (a, b, ...rest) {
        if (a instanceof LegacyObservableArray || b instanceof LegacyObservableArray) {
            return this.equals([...a], [...b], ...rest)
        }
        return undefined
    }
])

test("test1", function () {
    const a = observable.array([])
    expect(a.length).toBe(0)
    expect(Object.keys(a)).toEqual([])
    expect(a.slice()).toEqual([])

    a.push(1)
    expect(a.length).toBe(1)
    expect(a.slice()).toEqual([1])

    a[1] = 2
    expect(a.length).toBe(2)
    expect(a.slice()).toEqual([1, 2])

    const sum = mobx.computed(function () {
        return (
            -1 +
            a.reduce(function (a, b) {
                return a + b
            }, 1)
        )
    })

    expect(sum.get()).toBe(3)

    a[1] = 3
    expect(a.length).toBe(2)
    expect(a.slice()).toEqual([1, 3])
    expect(sum.get()).toBe(4)

    a.splice(1, 1, 4, 5)
    expect(a.length).toBe(3)
    expect(a.slice()).toEqual([1, 4, 5])
    expect(sum.get()).toBe(10)

    a.replace([2, 4])
    expect(sum.get()).toBe(6)

    a.splice(1, 1)
    expect(sum.get()).toBe(2)
    expect(a.slice()).toEqual([2])

    a.spliceWithArray(0, 0, [4, 3])
    expect(sum.get()).toBe(9)
    expect(a.slice()).toEqual([4, 3, 2])

    a.clear()
    expect(sum.get()).toBe(0)
    expect(a.slice()).toEqual([])

    a.length = 4
    expect(isNaN(sum.get())).toBe(true)
    expect(a.length).toEqual(4)

    expect(a.slice()).toEqual([undefined, undefined, undefined, undefined])

    a.replace([1, 2, 2, 4])
    expect(sum.get()).toBe(9)
    a.length = 4
    expect(sum.get()).toBe(9)

    a.length = 2
    expect(sum.get()).toBe(3)
    expect(a.slice()).toEqual([1, 2])

    expect(a.reverse()).toEqual([2, 1])
    expect(a).toEqual([2, 1])
    expect(a.slice()).toEqual([2, 1])

    a.unshift(3)
    expect(a.sort()).toEqual([1, 2, 3])
    expect(a.slice()).toEqual([1, 2, 3])

    expect(JSON.stringify(a)).toBe("[1,2,3]")

    expect(a[1]).toBe(2)
    a[2] = 4
    expect(a[2]).toBe(4)

    //	t.deepEqual(Object.keys(a), ['0', '1', '2']); // ideally....
    expect(Object.keys(a)).toEqual([])
})

test("array should support iterall / iterable ", () => {
    const a = observable([1, 2, 3])

    expect(iterall.isIterable(a)).toBe(true)

    const values = []
    iterall.forEach(a, v => values.push(v))

    expect(values).toEqual([1, 2, 3])

    let iter = iterall.getIterator(a)
    expect(iter.next()).toEqual({ value: 1, done: false })
    expect(iter.next()).toEqual({ value: 2, done: false })
    expect(iter.next()).toEqual({ value: 3, done: false })
    expect(iter.next()).toEqual({ value: undefined, done: true })

    a.replace([])
    iter = iterall.getIterator(a)
    expect(iter.next()).toEqual({ value: undefined, done: true })
})

test("find(findIndex) and remove", function () {
    const a = mobx.observable([10, 20, 20])
    let idx = -1
    function predicate(item, index) {
        if (item === 20) {
            idx = index
            return true
        }
        return false
    }

    expect(a.find(predicate)).toBe(20)
    expect(idx).toBe(1)
    expect(a.findIndex(predicate)).toBe(1)
    expect(a.find(predicate, null)).toBe(20)
    expect(idx).toBe(1)
    idx = -1

    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(20)
    expect(idx).toBe(1)
    expect(a.findIndex(predicate)).toBe(1)
    idx = -1
    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(undefined)
    expect(idx).toBe(-1)
    expect(a.findIndex(predicate)).toBe(-1)

    expect(a.remove(20)).toBe(false)
})

test("findLast(findLastIndex) and remove", function () {
    const a = mobx.observable([10, 20, 20])
    let idx = -1
    function predicate(item, index) {
        if (item === 20) {
            idx = index
            return true
        }
        return false
    }
    ;[].findLastIndex;
    expect(a.findLast(predicate)).toBe(20)
    expect(a.findLastIndex(predicate)).toBe(2)
    expect(a.findLast(predicate)).toBe(20)

    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(20)
    expect(idx).toBe(1)
    expect(a.findIndex(predicate)).toBe(1)
    idx = -1
    expect(a.remove(20)).toBe(true)
    expect(a.findLast(predicate)).toBe(undefined)
    expect(idx).toBe(-1)
    expect(a.findLastIndex(predicate)).toBe(-1)

    expect(a.remove(20)).toBe(false)
})

test("concat should automatically slice observable arrays, #260", () => {
    const a1 = mobx.observable([1, 2])
    const a2 = mobx.observable([3, 4])
    expect(a1.concat(a2)).toEqual([1, 2, 3, 4])
})

test("observe", function () {
    const ar = mobx.observable([1, 4])
    const buf = []
    const disposer = mobx.observe(
        ar,
        function (changes) {
            buf.push(changes)
        },
        true
    )

    ar[1] = 3 // 1,3
    ar[2] = 0 // 1, 3, 0
    ar.shift() // 3, 0
    ar.push(1, 2) // 3, 0, 1, 2
    ar.splice(1, 2, 3, 4) // 3, 3, 4, 2
    expect(ar.slice()).toEqual([3, 3, 4, 2])
    ar.splice(6)
    ar.splice(6, 2)
    ar.replace(["a"])
    ar.pop()
    ar.pop() // does not fire anything

    // check the object param
    buf.forEach(function (change) {
        expect(change.object).toBe(ar)
        delete change.object
        expect(change.observableKind).toBe("array")
        delete change.observableKind
        delete change.debugObjectName
    })

    const result = [
        { type: "splice", index: 0, addedCount: 2, removed: [], added: [1, 4], removedCount: 0 },
        { type: "update", index: 1, oldValue: 4, newValue: 3 },
        { type: "splice", index: 2, addedCount: 1, removed: [], added: [0], removedCount: 0 },
        { type: "splice", index: 0, addedCount: 0, removed: [1], added: [], removedCount: 1 },
        { type: "splice", index: 2, addedCount: 2, removed: [], added: [1, 2], removedCount: 0 },
        {
            type: "splice",
            index: 1,
            addedCount: 2,
            removed: [0, 1],
            added: [3, 4],
            removedCount: 2
        },
        {
            type: "splice",
            index: 0,
            addedCount: 1,
            removed: [3, 3, 4, 2],
            added: ["a"],
            removedCount: 4
        },
        { type: "splice", index: 0, addedCount: 0, removed: ["a"], added: [], removedCount: 1 }
    ]

    expect(buf).toEqual(result)

    disposer()
    ar[0] = 5
    expect(buf).toEqual(result)
})

test("array modification1", function () {
    const a = mobx.observable([1, 2, 3])
    const r = a.splice(-10, 5, 4, 5, 6)
    expect(a.slice()).toEqual([4, 5, 6])
    expect(r).toEqual([1, 2, 3])
})

test("serialize", function () {
    let a = [1, 2, 3]
    const m = mobx.observable(a)

    expect(JSON.stringify(m)).toEqual(JSON.stringify(a))
    expect(a).toEqual(m.slice())

    a = [4]
    m.replace(a)
    expect(JSON.stringify(m)).toEqual(JSON.stringify(a))
    expect(a).toEqual(m.toJSON())
})

test("array modification functions", function () {
    const ars = [[], [1, 2, 3]]
    const funcs = ["push", "pop", "shift", "unshift"]
    funcs.forEach(function (f) {
        ars.forEach(function (ar) {
            const a = ar.slice()
            const b = mobx.observable(a)
            const res1 = a[f](4)
            const res2 = b[f](4)
            expect(res1).toEqual(res2)
            expect(a).toEqual(b.slice())
        })
    })
})

test("array modifications", function () {
    const a2 = mobx.observable([])
    const inputs = [undefined, -10, -4, -3, -1, 0, 1, 3, 4, 10]
    const arrays = [
        [],
        [1],
        [1, 2, 3, 4],
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        [1, undefined],
        [undefined]
    ]
    for (let i = 0; i < inputs.length; i++)
        for (let j = 0; j < inputs.length; j++)
            for (let k = 0; k < arrays.length; k++)
                for (let l = 0; l < arrays.length; l++) {
                    ;[
                        "array mod: [",
                        arrays[k].toString(),
                        "] i: ",
                        inputs[i],
                        " d: ",
                        inputs[j],
                        " [",
                        arrays[l].toString(),
                        "]"
                    ].join(" ")
                    const a1 = arrays[k].slice()
                    a2.replace(a1)
                    const res1 = a1.splice.apply(a1, [inputs[i], inputs[j]].concat(arrays[l]))
                    const res2 = a2.splice.apply(a2, [inputs[i], inputs[j]].concat(arrays[l]))
                    expect(a1.slice()).toEqual(a2.slice())
                    expect(res1).toEqual(res2)
                    expect(a1.length).toBe(a2.length)
                }
})

test("is array", function () {
    const x = mobx.observable([])
    expect(x instanceof Array).toBe(true)

    // would be cool if this would return true...
    expect(Array.isArray(x)).toBe(false)
})

test("stringifies same as ecma array", function () {
    const x = mobx.observable([])
    expect(x instanceof Array).toBe(true)

    // would be cool if these two would return true...
    expect(x.toString()).toBe("")
    expect(x.toLocaleString()).toBe("")
    x.push(1, 2)
    expect(x.toString()).toBe("1,2")
    expect(x.toLocaleString()).toBe("1,2")
})

test("observes when stringified", function () {
    const x = mobx.observable([])
    let c = 0
    mobx.autorun(function () {
        x.toString()
        c++
    })
    x.push(1)
    expect(c).toBe(2)
})

test("observes when stringified to locale", function () {
    const x = mobx.observable([])
    let c = 0
    mobx.autorun(function () {
        x.toLocaleString()
        c++
    })
    x.push(1)
    expect(c).toBe(2)
})

test("react to sort changes", function () {
    const x = mobx.observable([4, 2, 3])
    const sortedX = mobx.computed(function () {
        return x.slice().sort()
    })
    let sorted

    mobx.autorun(function () {
        sorted = sortedX.get()
    })

    expect(x.slice()).toEqual([4, 2, 3])
    expect(sorted).toEqual([2, 3, 4])
    x.push(1)
    expect(x.slice()).toEqual([4, 2, 3, 1])
    expect(sorted).toEqual([1, 2, 3, 4])
    x.shift()
    expect(x.slice()).toEqual([2, 3, 1])
    expect(sorted).toEqual([1, 2, 3])
})

test("autoextend buffer length", function () {
    const ar = observable(new Array(1000))
    let changesCount = 0
    mobx.observe(ar, () => ++changesCount)

    ar[ar.length] = 0
    ar.push(0)

    expect(changesCount).toBe(2)
})

test("array exposes correct keys", () => {
    const keys = []
    const ar = observable([1, 2])
    for (const key in ar) keys.push(key)

    expect(keys).toEqual([])
})

test("accessing out of bound values throws", () => {
    const a = mobx.observable([])

    let warns = 0
    const baseWarn = console.warn
    console.warn = () => {
        warns++
    }

    a[0] // out of bounds
    a[1] // out of bounds

    expect(warns).toBe(2)

    expect(() => (a[0] = 3)).not.toThrow()
    expect(() => (a[2] = 4)).toThrow(/Index out of bounds, 2 is larger than 1/)

    console.warn = baseWarn
})

test("replace can handle large arrays", () => {
    const a = mobx.observable([])
    const b = []
    b.length = 1000 * 1000
    expect(() => {
        a.replace(b)
    }).not.toThrow()

    expect(() => {
        a.spliceWithArray(0, 0, b)
    }).not.toThrow()
})

test("can iterate arrays", () => {
    const x = mobx.observable([])
    const y = []
    const d = mobx.reaction(
        () => Array.from(x),
        items => y.push(items),
        { fireImmediately: true }
    )

    x.push("a")
    x.push("b")
    expect(y).toEqual([[], ["a"], ["a", "b"]])
    d()
})

test("array is concat spreadable, #1395", () => {
    const x = mobx.observable([1, 2, 3, 4])
    const y = [5].concat(x)
    expect(y.length).toBe(2) // Should become 5 in MobX 5
    expect(y).toEqual([5, x]) // should become [5, 1,2,3,4] in MobX 5
})

test("array is spreadable, #1395", () => {
    const x = mobx.observable([1, 2, 3, 4])
    expect([5, ...x]).toEqual([5, 1, 2, 3, 4])

    const y = mobx.observable([])
    expect([5, ...y]).toEqual([5])
})

test("array supports toStringTag, #1490", () => {
    // N.B. on old environments this requires polyfils for these symbols *and* Object.prototype.toString.
    // core-js provides both
    const a = mobx.observable([])
    expect(Object.prototype.toString.call(a)).toBe("[object Array]")
})

test("concats correctly #1667", () => {
    const x = observable({ data: [] })

    function generate(count) {
        const d = []
        for (let i = 0; i < count; i++) d.push({})
        return d
    }

    x.data = generate(10000)
    const first = x.data[0]

    x.data = x.data.concat(generate(1000))
    expect(x.data[0]).toBe(first)
    expect(x.data.length).toBe(11000)
})

test("dehances last value on shift/pop", () => {
    const x1 = observable([3, 5])
    _getAdministration(x1).dehancer = value => {
        return value * 2
    }
    expect(x1.shift()).toBe(6)
    expect(x1.shift()).toBe(10)

    const x2 = observable([3, 5])
    _getAdministration(x2).dehancer = value => {
        return value * 2
    }
    expect(x2.pop()).toBe(10)
    expect(x2.pop()).toBe(6)
})

test("#2044 symbol key on array", () => {
    const x = observable([1, 2])
    const s = Symbol("test")
    x[s] = 3
    expect(x[s]).toBe(3)

    let reacted = false
    const d = reaction(
        () => x[s],
        () => {
            reacted = true
        }
    )

    x[s] = 4
    expect(x[s]).toBe(4)

    // although x[s] can be stored, it won't be reactive!
    expect(reacted).toBe(false)
    d()
})

test("#2044 non-symbol key on array", () => {
    const x = observable([1, 2])
    const s = "test"
    x[s] = 3
    expect(x[s]).toBe(3)

    let reacted = false
    const d = reaction(
        () => x[s],
        () => {
            reacted = true
        }
    )

    x[s] = 4
    expect(x[s]).toBe(4)

    // although x[s] can be stored, it won't be reactive!
    expect(reacted).toBe(false)
    d()
})

describe("extended array prototype", () => {
    const extensionKey = "__extension"

    // A single setup/teardown for all tests because we're pretending to do a
    // singular global (dirty) change to the "environment".
    beforeAll(() => {
        Array.prototype[extensionKey] = () => {}
    })
    afterAll(() => {
        delete Array.prototype[extensionKey]
    })

    test("creating an observable should work", () => {
        mobx.observable({ b: "b" })
    })

    test("extending an observable should work", () => {
        const a = { b: "b" }
        mobx.extendObservable(a, {})
    })
})

test("reproduce #2021", () => {
    expect.assertions(1)
    try {
        Array.prototype.extension = function () {
            console.log("I'm the extension!", this.length)
        }

        class Test {
            data = null

            constructor() {
                makeObservable(this, {
                    data: observable
                })
            }
        }

        const test = new Test()

        mobx.autorun(() => {
            if (test.data) expect(test.data.someStr).toBe("123")
        })

        test.data = { someStr: "123" }
    } finally {
        delete Array.prototype.extension
    }
})

test("correct array should be passed to callbacks #2326", () => {
    const array = observable([1, 2, 3])

    function callback() {
        const lastArg = arguments[arguments.length - 1]
        expect(lastArg).toBe(array)
    }
    ;[
        "every",
        "filter",
        "find",
        "findIndex",
        "findLast",
        "findLastIndex",
        "flatMap",
        "forEach",
        "map",
        "reduce",
        "reduceRight",
        "some"
    ].forEach(method => {
        if (Array.prototype[method]) array[method](callback)
        else console.warn("SKIPPING: " + method)
    })
})

test("very long arrays can be safely passed to nativeArray.concat #2379", () => {
    const nativeArray = ["a", "b"]
    const longNativeArray = [...Array(10000).keys()]
    const longObservableArray = observable(longNativeArray)
    expect(longObservableArray.length).toBe(10000)
    expect(longObservableArray).toEqual(longNativeArray)
    expect(longObservableArray[9000]).toBe(longNativeArray[9000])
    expect(longObservableArray[9999]).toBe(longNativeArray[9999])
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
    expect(longObservableArray[10000]).toBe(longNativeArray[10000])
    expect(consoleWarnMock).toMatchSnapshot()

    const expectedArray = nativeArray.concat(longNativeArray)
    const actualArray = nativeArray.concat(longObservableArray.slice()) // NOTE: in MobX4 slice is needed

    expect(actualArray).toEqual(expectedArray)

    const anotherArray = [0, 1, 2, 3, 4, 5]
    const observableArray = observable(anotherArray)
    const r1 = anotherArray.splice(2, 2, ...longNativeArray)
    const r2 = observableArray.splice(2, 2, ...longNativeArray)
    expect(r2).toEqual(r1)
    expect(observableArray).toEqual(anotherArray)
})

describe("dehances", () => {
    function supressConsoleWarn(fn) {
        const { warn } = console
        console.warn = () => {}
        const result = fn()
        console.warn = warn
        return result
    }

    const dehancer = thing => {
        // Dehance only objects of a proper type
        if (thing && typeof thing === "object" && thing.hasOwnProperty("value")) {
            return thing.value
        }
        // Support nested arrays
        if (Array.isArray(thing)) {
            // If array has own dehancer it's still applied prior to ours.
            // It doesn't matter how many dehancers we apply,
            // if they ignore unknown types.
            return thing.map(dehancer)
        }
        // Ignore unknown types
        return thing
    }

    let enhanced, dehanced, array

    beforeEach(() => {
        enhanced = [{ value: 1 }, { value: 2 }, { value: 3 }]
        dehanced = enhanced.map(dehancer)
        array = observable(enhanced)
        mobx._getAdministration(array).dehancer = dehancer
    })

    test("slice", () => {
        expect(array.slice()).toEqual(dehanced.slice())
    })

    test("filter", () => {
        const predicate = value => value === 2
        expect(array.filter(predicate)).toEqual(dehanced.filter(predicate))
    })

    test("concat", () => {
        expect(array.concat(4)).toEqual(dehanced.concat(4))
    })

    test("entries", () => {
        expect([...array.entries()]).toEqual([...dehanced.entries()])
    })

    test("every", () => {
        array.every((value, index) => {
            expect(value).toEqual(dehanced[index])
            return true
        })
    })

    test("find", () => {
        const predicate = value => value === 2
        expect(array.find(predicate)).toEqual(dehanced.find(predicate))
    })

    test("forEach", () => {
        array.forEach((value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("includes", () => {
        expect(array.includes(2)).toEqual(dehanced.includes(2))
    })

    test("indexOf", () => {
        expect(array.indexOf(2)).toEqual(dehanced.indexOf(2))
    })

    test("join", () => {
        expect(array.join()).toEqual(dehanced.join())
    })

    test("lastIndexOf", () => {
        expect(array.lastIndexOf(2)).toEqual(dehanced.lastIndexOf(2))
    })

    test("map", () => {
        array.map((value, index) => {
            expect(value).toEqual(dehanced[index])
            return value
        })
    })

    test("pop", () => {
        expect(array.pop()).toEqual(dehanced.pop())
    })

    test("reduce", () => {
        array.reduce((_, value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("reduceRight", () => {
        array.reduceRight((_, value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("reverse", () => {
        const reversedArray = supressConsoleWarn(() => array.reverse())
        expect(reversedArray).toEqual(dehanced.reverse())
    })

    test("shift", () => {
        expect(array.shift()).toEqual(dehanced.shift())
    })

    test("some", () => {
        array.some((value, index) => {
            expect(value).toEqual(dehanced[index])
            return false
        })
    })

    test("splice", () => {
        expect(array.splice(1, 2)).toEqual(dehanced.splice(1, 2))
    })

    test("sort", () => {
        const comparator = (a, b) => {
            expect(typeof a).toEqual("number")
            expect(typeof b).toEqual("number")
            return b > a
        }
        const sortedArray = supressConsoleWarn(() => array.sort(comparator))
        expect(sortedArray).toEqual(dehanced.sort(comparator))
    })

    test("values", () => {
        expect([...array.values()]).toEqual([...dehanced.values()])
    })

    test("toReversed", () => {
        expect(array.toReversed()).toEqual(dehanced.toReversed())
    })
 
     test("toSorted", () => {
        expect(array.toSorted()).toEqual(dehanced.toSorted())
    })
 
     test("toSorted with args", () => {
        expect(array.toSorted((a, b) => a - b)).toEqual(dehanced.toSorted((a, b) => a - b))
    })
 
     test("toSpliced", () => {
        expect(array.toSpliced(1, 2)).toEqual(dehanced.toSpliced(1, 2))
    })
 
     test("with", () => {
        expect(array.with(1, 5)).toEqual(dehanced.with(1, 5))
    })

    test("at", () => {
        expect(array.at(1)).toEqual(dehanced.at(1))
        expect(array.at(-1)).toEqual(dehanced.at(-1))
    })

    test("flat/flatMap", () => {
        // not supported in V4
    })
})

test("reduce without initial value #2432", () => {
    const array = [1, 2, 3]
    const observableArray = observable(array)

    const arrayReducerArgs = []
    const observableArrayReducerArgs = []

    const arraySum = array.reduce((...args) => {
        arrayReducerArgs.push(args)
        return args[0] + args[1]
    })

    const observableArraySum = observableArray.reduce((...args) => {
        observableArrayReducerArgs.push(args)
        return args[0] + args[1]
    })

    expect(arraySum).toEqual(1 + 2 + 3)
    expect(observableArraySum).toEqual(arraySum)
    expect(arrayReducerArgs).toEqual(observableArrayReducerArgs)
})



================================================
FILE: packages/mobx/__tests__/v4/base/autorun.js
================================================
/**
 * @type {typeof import("./../../../src/v4/mobx")}
 */
const mobx = require("../mobx4")
const utils = require("../../v5/utils/test-utils")

test("autorun passes Reaction as an argument to view function", function () {
    const a = mobx.observable.box(1)
    const values = []

    mobx.autorun(r => {
        expect(typeof r.dispose).toBe("function")
        if (a.get() === "pleaseDispose") r.dispose()
        values.push(a.get())
    })

    a.set(2)
    a.set(2)
    a.set("pleaseDispose")
    a.set(3)
    a.set(4)

    expect(values).toEqual([1, 2, "pleaseDispose"])
})

test("autorun can be disposed on first run", function () {
    const a = mobx.observable.box(1)
    const values = []

    mobx.autorun(r => {
        r.dispose()
        values.push(a.get())
    })

    a.set(2)

    expect(values).toEqual([1])
})

test("autorun warns when passed an action", function () {
    const action = mobx.action(() => {})
    expect.assertions(1)
    expect(() => mobx.autorun(action)).toThrowError(/Autorun does not accept actions/)
})

test("autorun batches automatically", function () {
    let runs = 0
    let a1runs = 0
    let a2runs = 0

    const x = mobx.observable({
        a: 1,
        b: 1,
        c: 1,
        get d() {
            runs++
            return this.c + this.b
        }
    })

    const d1 = mobx.autorun(() => {
        a1runs++
        x.d // read
    })

    const d2 = mobx.autorun(() => {
        a2runs++
        x.b = x.a
        x.c = x.a
    })

    expect(a1runs).toBe(1)
    expect(a2runs).toBe(1)
    expect(runs).toBe(1)

    x.a = 17

    expect(a1runs).toBe(2)
    expect(a2runs).toBe(2)
    expect(runs).toBe(2)

    d1()
    d2()
})

test("autorun tracks invalidation of unbound dependencies", function () {
    const a = mobx.observable.box(0)
    const b = mobx.observable.box(0)
    const c = mobx.computed(() => a.get() + b.get())
    const values = []

    mobx.autorun(() => {
        values.push(c.get())
        b.set(100)
    })

    a.set(1)
    expect(values).toEqual([0, 100, 101])
})

test("when effect is an action", function (done) {
    const a = mobx.observable.box(0)

    mobx.configure({ enforceActions: "observed" })
    mobx.when(
        () => a.get() === 1,
        () => {
            a.set(2)

            mobx.configure({ enforceActions: "never" })
            done()
        },
        { timeout: 1 }
    )

    mobx.runInAction(() => {
        a.set(1)
    })
})

describe("autorun opts requiresObservable", () => {
    test("warn when no observable", () => {
        utils.consoleWarn(() => {
            const disposer = mobx.autorun(() => 2, {
                requiresObservable: true
            })

            disposer()
        }, /is created\/updated without reading any observable value/)
    })

    test("Don't warn when observable", () => {
        const obsr = mobx.observable({
            x: 1
        })

        const messages = utils.supressConsole(() => {
            const disposer = mobx.autorun(() => obsr.x, {
                requiresObservable: true
            })

            disposer()
        })

        expect(messages.length).toBe(0)
    })
})



================================================
FILE: packages/mobx/__tests__/v4/base/cycles.js
================================================
const m = require("../mobx4")

test("cascading active state (form 1)", function () {
    const Store = function () {
        m.extendObservable(this, { _activeItem: null })
    }
    Store.prototype.activeItem = function (item) {
        const _this = this

        if (arguments.length === 0) return this._activeItem

        m.transaction(function () {
            if (_this._activeItem === item) return
            if (_this._activeItem) _this._activeItem.isActive = false
            _this._activeItem = item
            if (_this._activeItem) _this._activeItem.isActive = true
        })
    }

    const Item = function () {
        m.extendObservable(this, { isActive: false })
    }

    const store = new Store()
    const item1 = new Item(),
        item2 = new Item()
    expect(store.activeItem()).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)

    store.activeItem(item1)
    expect(store.activeItem()).toBe(item1)
    expect(item1.isActive).toBe(true)
    expect(item2.isActive).toBe(false)

    store.activeItem(item2)
    expect(store.activeItem()).toBe(item2)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(true)

    store.activeItem(null)
    expect(store.activeItem()).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)
})

test("cascading active state (form 2)", function () {
    const Store = function () {
        const _this = this
        m.extendObservable(this, { activeItem: null })

        m.autorun(function () {
            if (_this._activeItem === _this.activeItem) return
            if (_this._activeItem) _this._activeItem.isActive = false
            _this._activeItem = _this.activeItem
            if (_this._activeItem) _this._activeItem.isActive = true
        })
    }

    const Item = function () {
        m.extendObservable(this, { isActive: false })
    }

    const store = new Store()
    const item1 = new Item(),
        item2 = new Item()
    expect(store.activeItem).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)

    store.activeItem = item1
    expect(store.activeItem).toBe(item1)
    expect(item1.isActive).toBe(true)
    expect(item2.isActive).toBe(false)

    store.activeItem = item2
    expect(store.activeItem).toBe(item2)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(true)

    store.activeItem = null
    expect(store.activeItem).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)
})

test("emulate rendering", function () {
    let renderCount = 0

    const Component = function (props) {
        this.props = props
    }
    Component.prototype.destroy = function () {
        if (this.handler) {
            this.handler()
            this.handler = null
        }
    }

    Component.prototype.render = function () {
        const _this = this

        if (this.handler) {
            this.handler()
            this.handler = null
        }
        this.handler = m.autorun(function () {
            if (!_this.props.data.title) _this.props.data.title = "HELLO"
            renderCount++
        })
    }

    const data = {}
    m.extendObservable(data, { title: null })
    const component = new Component({ data: data })
    expect(renderCount).toBe(0)

    component.render()
    expect(renderCount).toBe(1)

    data.title = "WORLD"
    expect(renderCount).toBe(2)

    data.title = null
    // Note that this causes two invalidations
    // however, the real mobx-react binding optimizes this as well
    // see mobx-react #12, so maybe this ain't the best test
    expect(renderCount).toBe(4)

    data.title = "WORLD"
    expect(renderCount).toBe(5)

    component.destroy()
    data.title = "HELLO"
    expect(renderCount).toBe(5)
})

test("efficient selection", function () {
    function Item(value) {
        m.extendObservable(this, {
            selected: false,
            value: value
        })
    }

    function Store() {
        this.prevSelection = null
        m.extendObservable(this, {
            selection: null,
            items: [new Item(1), new Item(2), new Item(3)]
        })
        m.autorun(() => {
            if (this.previousSelection === this.selection) return true // converging condition
            if (this.previousSelection) this.previousSelection.selected = false
            if (this.selection) this.selection.selected = true
            this.previousSelection = this.selection
        })
    }

    const store = new Store()

    expect(store.selection).toBe(null)
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(0)

    store.selection = store.items[1]
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(1)
    expect(store.selection).toBe(store.items[1])
    expect(store.items[1].selected).toBe(true)

    store.selection = store.items[2]
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(1)
    expect(store.selection).toBe(store.items[2])
    expect(store.items[2].selected).toBe(true)

    store.selection = null
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(0)
    expect(store.selection).toBe(null)
})



================================================
FILE: packages/mobx/__tests__/v4/base/extendObservable.js
================================================
// @ts-check

import {
    action,
    autorun,
    isObservable,
    isObservableProp,
    isComputedProp,
    isAction,
    extendObservable
} from "../mobx4"

test("extendObservable should work", function () {
    class Box {
        // @ts-ignore
        uninitialized
        height = 20
        sizes = [2]
        someFunc = function () {
            return 2
        }
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        }
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
        constructor() {
            this.undeclared = 1
        }
    }

    const box = new Box()

    extendObservable(box, {
        height: 20,
        sizes: [2],
        get someFunc() {
            return 2
        },
        width: 40
    })

    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "someFunc")).toBe(true)
    expect(isObservableProp(box, "width")).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
})

test("extendObservable should work with plain object", function () {
    const box = {
        /** @type {boolean | undefined} */
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    box.undeclared = 1

    extendObservable(box, {
        height: 20,
        sizes: [2],
        get someFunc() {
            return 2
        },
        width: 40
    })

    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "someFunc")).toBe(true)
    expect(isObservableProp(box, "width")).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
})

test("extendObservable should apply specified decorators", function () {
    const box = {
        /** @type {boolean | undefined} */
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    box.undeclared = 1

    extendObservable(
        box,
        {
            someFunc: function () {
                return 2
            }
        },
        // @ts-ignore
        { someFunc: action }
    )

    expect(isAction(box.someFunc)).toBe(true)
    expect(box.someFunc()).toEqual(2)
})



================================================
FILE: packages/mobx/__tests__/v4/base/extras.js
================================================
const mobx = require("../mobx4")
const m = mobx
const { $mobx } = mobx

test("treeD", function () {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0
    const a = m.observable.box(3)
    const aName = "ObservableValue@1"

    const dtree = m.getDependencyTree
    expect(dtree(a)).toEqual({
        name: aName
    })

    const b = m.computed(() => a.get() * a.get())
    const bName = "ComputedValue@2"
    expect(dtree(b)).toEqual({
        name: bName
        // no dependencies yet, since it isn't observed yet
    })

    const c = m.autorun(() => b.get())
    const cName = "Autorun@3"
    expect(dtree(c[$mobx])).toEqual({
        name: cName,
        dependencies: [
            {
                name: bName,
                dependencies: [
                    {
                        name: aName
                    }
                ]
            }
        ]
    })

    expect(aName !== bName).toBeTruthy()
    expect(bName !== cName).toBeTruthy()

    expect(m.getObserverTree(a)).toEqual({
        name: aName,
        observers: [
            {
                name: bName,
                observers: [
                    {
                        name: cName
                    }
                ]
            }
        ]
    })

    const x = mobx.observable.map({ temperature: 0 })
    const d = mobx.autorun(function () {
        x.keys()
        if (x.has("temperature")) x.get("temperature")
        x.has("absent")
    })

    expect(m.getDependencyTree(d[$mobx])).toEqual({
        name: "Autorun@5",
        dependencies: [
            {
                name: "ObservableMap@4.keys()"
            },
            {
                name: "ObservableMap@4.temperature?"
            },
            {
                name: "ObservableMap@4.temperature"
            },
            {
                name: "ObservableMap@4.absent?"
            }
        ]
    })
})

function stripTrackerOutput(output) {
    return output.map(function (i) {
        if (Array.isArray(i)) return stripTrackerOutput(i)
        delete i.object
        delete i.time
        delete i.fn
        return i
    })
}

test("spy 1", function () {
    m._resetGlobalState()
    const lines = []

    const a = m.observable.box(3)
    const b = m.computed(function () {
        return a.get() * 2
    })
    m.autorun(function () {
        b.get()
    })
    const stop = m.spy(function (line) {
        lines.push(line)
    })

    a.set(4)
    stop()
    a.set(5)
    expect(stripTrackerOutput(lines)).toMatchSnapshot()
})

test("get atom", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()

    function atom(thing, prop) {
        return mobx.getAtom(thing, prop).constructor.name
    }

    const ovClassName = mobx.observable.box(3).constructor.name
    const atomClassName = mobx.createAtom("test").constructor.name
    // const reactionClassName = mobx.Reaction.name

    expect(atom(a)).toBe(ovClassName)

    expect(atom(b, "a")).toBe(ovClassName)
    expect(() => atom(b)).toThrowError(/please specify a property/)
    expect(() => atom(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )

    expect(atom(c)).toBe(atomClassName) // returns ke, "bla".constructor, === "Atomys
    expect(atom(c, "a")).toBe(ovClassName) // returns ent, "bla".constructor, === "Atomry
    expect(atom(c, "b")).toBe(ovClassName) // returns has entry (see autoru, "bla", "Atomn)
    expect(() => atom(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(atom(d)).toBe(atomClassName)
    expect(() => atom(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(atom(e)).toBe(mobx.computed(() => {}).constructor.name)
    expect(atom(f)).toBe(mobx.Reaction.name)

    expect(() => atom(g)).toThrowError(/please specify a property/)
    expect(atom(g, "a")).toBe(ovClassName)

    f()
})

test("get debug name", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()

    function name(thing, prop) {
        return mobx.getDebugName(thing, prop)
    }

    expect(name(a)).toBe("ObservableValue@1")

    expect(name(b, "a")).toBe("ObservableObject@2.a")
    expect(() => name(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )

    expect(name(c)).toBe("ObservableMap@3") // returns ke, "bla"ys
    expect(name(c, "a")).toBe("ObservableMap@3.a") // returns ent, "bla"ry
    expect(name(c, "b")).toBe("ObservableMap@3.b?") // returns has entry (see autoru, "bla"n)
    expect(() => name(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(name(d)).toBe("ObservableArray@4")
    expect(() => name(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(name(e)).toBe("ComputedValue@5")
    expect(name(f)).toBe("Autorun@6")

    expect(name(g)).toBe("Clazz@7")
    expect(name(g, "a")).toBe("Clazz@7.a")

    f()
})

test("get administration", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()

    function adm(thing, prop) {
        return mobx._getAdministration(thing, prop).constructor.name
    }

    const ovClassName = mobx.observable.box(3).constructor.name
    const mapClassName = mobx.observable.map().constructor.name

    expect(adm(a)).toBe(ovClassName)

    expect(adm(b, "a")).toBe(ovClassName)
    expect(adm(b)).toBe(b[$mobx].constructor.name)
    expect(() => adm(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )

    expect(adm(c)).toBe(mapClassName)
    expect(adm(c, "a")).toBe(ovClassName)
    expect(adm(c, "b")).toBe(ovClassName)
    expect(() => adm(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(adm(d)).toBe(d[$mobx].constructor.name)
    expect(() => adm(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(adm(e)).toBe(mobx.computed(() => {}).constructor.name)
    expect(adm(f)).toBe(mobx.Reaction.name)

    expect(adm(g)).toBe(b[$mobx].constructor.name)
    expect(adm(g, "a")).toBe(ovClassName)

    f()
})

test("onBecome(Un)Observed simple", () => {
    const x = mobx.observable.box(3)
    const events = []

    mobx.onBecomeObserved(x, () => {
        events.push("x observed")
    })
    mobx.onBecomeUnobserved(x, () => {
        events.push("x unobserved")
    })

    expect(events.length).toBe(0) // nothing happened yet
    x.get()
    expect(events.length).toBe(0) // nothing happened yet
    x.set(4)
    expect(events.length).toBe(0) // nothing happened yet

    const d5 = mobx.reaction(
        () => x.get(),
        () => {}
    )
    expect(events.length).toBe(1)
    expect(events).toEqual(["x observed"])

    d5()
    expect(events.length).toBe(2)
    expect(events).toEqual(["x observed", "x unobserved"])
})

test("onBecome(Un)Observed - less simple", () => {
    const x = mobx.observable({
        a: 3,
        get b() {
            return this.a * 2
        }
    })
    const events = []

    const d1 = mobx.onBecomeObserved(x, "a", () => {
        events.push("a observed")
    })
    const d2 = mobx.onBecomeUnobserved(x, "a", () => {
        events.push("a unobserved")
    })
    const d3 = mobx.onBecomeObserved(x, "b", () => {
        events.push("b observed")
    })
    const d4 = mobx.onBecomeUnobserved(x, "b", () => {
        events.push("b unobserved")
    })

    x.b
    x.a = 4

    expect(events.length).toBe(0) // nothing happened yet

    const d5 = mobx.reaction(
        () => x.b,
        () => {}
    )
    expect(events.length).toBe(2)
    expect(events).toEqual(["b observed", "a observed"])

    const d6 = mobx.reaction(
        () => x.b,
        () => {}
    )
    expect(events.length).toBe(2)

    d5()
    expect(events.length).toBe(2)
    d6()
    expect(events.length).toBe(4)
    expect(events).toEqual(["b observed", "a observed", "b unobserved", "a unobserved"])

    d1()
    d2()
    d3()
    d4()
    events.splice(0)
    const d7 = mobx.reaction(
        () => x.b,
        () => {}
    )
    d7()
    expect(events.length).toBe(0)
})

test("deepEquals should yield correct results for complex objects #1118 - 1", () => {
    const d2016jan1 = new Date("2016-01-01")
    const d2016jan1_2 = new Date("2016-01-01")
    const d2017jan1 = new Date("2017-01-01")

    expect(d2016jan1).toEqual(d2016jan1_2)
    expect(d2016jan1).not.toEqual(d2017jan1)
    expect(mobx.comparer.structural(d2016jan1, d2016jan1)).toBe(true)
    expect(mobx.comparer.structural(d2016jan1, d2017jan1)).toBe(false)
    expect(mobx.comparer.structural(d2016jan1, d2016jan1_2)).toBe(true)
})

test("deepEquals should yield correct results for complex objects #1118 - 2", () => {
    class A {
        x = 3
        y = 4

        constructor(x) {
            this.x = x
        }
    }

    const a1 = new A(2)
    const a2 = new A(2)
    const a3 = new A(3)
    const a4 = new A(2)
    a4.z = 2

    expect(a1).toEqual(a2)
    expect(a1).not.toEqual(a3)
    expect(mobx.comparer.structural(a1, a1)).toBe(true)
    expect(mobx.comparer.structural(a1, a3)).toBe(false)
    expect(mobx.comparer.structural(a1, a2)).toBe(true)
    expect(mobx.comparer.structural(a1, a4)).toBe(false)
})

test("comparer.shallow should work", () => {
    const sh = mobx.comparer.shallow

    expect(sh(1, 1)).toBe(true)

    expect(sh(1, 2)).toBe(false)

    expect(sh({}, {})).toBe(true)
    expect(sh([], [])).toBe(true)

    expect(sh({}, [])).toBe(false)
    expect(sh([], {})).toBe(false)

    expect(sh({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 })).toBe(true)

    expect(sh({ a: 1, b: 2, c: 3, d: 4 }, { a: 1, b: 2, c: 3 })).toBe(false)
    expect(sh({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3, d: 4 })).toBe(false)
    expect(sh({ a: {}, b: 2, c: 3 }, { a: {}, b: 2, c: 3 })).toBe(false)

    expect(sh([1, 2, 3], [1, 2, 3])).toBe(true)

    expect(sh([1, 2, 3, 4], [1, 2, 3])).toBe(false)
    expect(sh([1, 2, 3], [1, 2, 3, 4])).toBe(false)
    expect(sh([{}, 2, 3], [{}, 2, 3])).toBe(false)
})



================================================
FILE: packages/mobx/__tests__/v4/base/intercept.js
================================================
const m = require("../mobx4")
const intercept = m.intercept

test("intercept observable value", () => {
    const a = m.observable.box(1)

    let d = intercept(a, () => {
        return null
    })

    a.set(2)

    expect(a.get()).toBe(1)

    d()

    a.set(3)
    expect(a.get()).toBe(3)

    d = intercept(a, c => {
        if (c.newValue % 2 === 0) {
            throw "value should be odd!"
        }
        return c
    })

    expect(() => {
        a.set(4)
    }).toThrow(/value should be odd/)

    expect(a.get()).toBe(3)
    a.set(5)
    expect(a.get()).toBe(5)

    d()
    d = intercept(a, c => {
        c.newValue *= 2
        return c
    })

    a.set(6)
    expect(a.get()).toBe(12)

    intercept(a, c => {
        c.newValue += 1
        return c
    })

    a.set(7)
    expect(a.get()).toBe(15)

    d()
    a.set(8)
    expect(a.get()).toBe(9)
})

test("intercept array", () => {
    const a = m.observable([1, 2])

    let d = m.intercept(a, () => null)
    a.push(2)
    expect(a.slice()).toEqual([1, 2])

    d()

    d = intercept(a, c => {
        if (c.type === "splice") {
            c.added.push(c.added[0] * 2)
            c.removedCount = 1
            return c
        } else if (c.type === "update") {
            c.newValue = c.newValue * 3
            return c
        }
    })

    a.unshift(3, 4)

    expect(a.slice()).toEqual([3, 4, 6, 2])
    a[2] = 5
    expect(a.slice()).toEqual([3, 4, 15, 2])
})

test("intercept object", () => {
    const a = m.observable({
        b: 3
    })

    intercept(a, change => {
        change.newValue *= 3
        return change
    })

    a.b = 4

    expect(a.b).toBe(12)

    intercept(a, "b", change => {
        change.newValue += 1
        return change
    })

    a.b = 5
    expect(a.b).toBe(16)

    const d3 = intercept(a, c => {
        expect(c.name).toBe("b")
        expect(c.object).toBe(a)
        expect(c.type).toBe("update")
        return null
    })

    a.b = 7
    expect(a.b).toBe(16)

    d3()
    a.b = 7
    expect(a.b).toBe(22)
})

test("intercept property additions", () => {
    const a = m.observable({})
    const d4 = intercept(a, change => {
        if (change.type === "add") {
            return null
        }
        return change
    })

    m.extendObservable(a, { c: 1 }) // not added!
    expect(a.c).toBe(undefined)
    expect(m.isObservableProp(a, "c")).toBe(false)

    d4()

    m.extendObservable(a, { c: 2 })
    expect(a.c).toBe(2)
    expect(m.isObservableProp(a, "c")).toBe(true)
})

test("intercept map", () => {
    const a = m.observable.map({
        b: 3
    })

    intercept(a, c => {
        c.newValue *= 3
        return c
    })

    a.set("b", 4)

    expect(a.get("b")).toBe(12)

    intercept(a, "b", c => {
        c.newValue += 1
        return c
    })

    a.set("b", 5)
    expect(a.get("b")).toBe(16)

    const d3 = intercept(a, c => {
        expect(c.name).toBe("b"), expect(c.object).toBe(a)
        expect(c.type).toBe("update")
        return null
    })

    a.set("b", 7)
    expect(a.get("b")).toBe(16)

    d3()
    a.set("b", 7)
    expect(a.get("b")).toBe(22)

    const d4 = intercept(a, c => {
        if (c.type === "delete") return null
        return c
    })

    a.delete("b")
    expect(a.has("b")).toBe(true)
    expect(a.get("b")).toBe(22)

    d4()
    a.delete("b")
    expect(a.has("b")).toBe(false)
    expect(a.get("c")).toBe(undefined)
})



================================================
FILE: packages/mobx/__tests__/v4/base/jsconfig.json
================================================
{
    "compilerOptions": {
        "target": "es2015",
        "experimentalDecorators": true
    }
}



================================================
FILE: packages/mobx/__tests__/v4/base/makereactive.js
================================================
const mobx = require("../mobx4")
const m = mobx
const o = mobx.observable
const { makeObservable } = mobx

function buffer() {
    const b = []
    const res = function (x) {
        b.push(x)
    }
    res.toArray = function () {
        return b
    }
    return res
}

test("isObservable", function () {
    function Order() {}

    function ReactiveOrder(price) {
        m.extendObservable(this, {
            price: price
        })
    }
    expect(m.isObservable(null)).toBe(false)
    expect(m.isObservable(null)).toBe(false)

    expect(m.isObservable(m.observable([]))).toBe(true)
    expect(m.isObservable(m.observable({}))).toBe(true)
    expect(m.isObservable(m.observable.box(function () {}))).toBe(true)
    expect(m.isObservable(m.computed(function () {}))).toBe(true)

    expect(m.isObservable([])).toBe(false)
    expect(m.isObservable({})).toBe(false)
    expect(m.isObservable(function () {})).toBe(false)

    expect(m.isObservable(new Order())).toBe(false)
    expect(m.isObservable(m.observable.box(new Order()))).toBe(true)

    expect(m.isObservable(new ReactiveOrder())).toBe(true)
    expect(m.isObservable(m.observable.box(3))).toBe(true)

    const obj = {}
    expect(m.isObservable(obj)).toBe(false)

    expect(m.isObservable(m.observable.box(function () {}))).toBe(true)
    expect(m.isObservable(m.autorun(function () {}))).toBe(true)

    expect(m.isObservableProp(m.observable({ a: 1 }), "a")).toBe(true)
    expect(m.isObservableProp(m.observable({ a: 1 }), "b")).toBe(false)

    expect(m.isObservable(m.observable.map())).toBe(true)

    const base = { a: 3 }
    const obs = m.observable(base)
    expect(m.isObservable(base)).toBe(false)
    expect(m.isObservableProp(base, "a")).toBe(false)
    expect(m.isObservable(obs)).toBe(true)
    expect(m.isObservableProp(obs, "a")).toBe(true)
})

test("isBoxedObservable", function () {
    expect(m.isBoxedObservable(m.observable({}))).toBe(false)
    expect(m.isBoxedObservable(m.computed(() => 3))).toBe(false)
    expect(m.isBoxedObservable(m.observable.box(3))).toBe(true)
    expect(m.isBoxedObservable(m.observable.box(3))).toBe(true)
    expect(m.isBoxedObservable(m.observable.box({}))).toBe(true)
})

test("observable1", function () {
    m._resetGlobalState()

    // recursive structure
    const x = m.observable({
        a: {
            b: {
                c: 3
            }
        }
    })
    const b = buffer()
    m.autorun(function () {
        b(x.a.b.c)
    })
    x.a = { b: { c: 4 } }
    x.a.b.c = 5 // new structure was reactive as well
    expect(b.toArray()).toEqual([3, 4, 5])

    // recursive structure, but asReference passed in
    expect(m.isObservable(x.a.b)).toBe(true)
    const x2 = m.observable.object(
        {
            a: {
                b: {
                    c: 3
                }
            }
        },
        {
            a: m.observable.ref
        }
    )

    expect(m.isObservable(x2)).toBe(true)
    expect(m.isObservable(x2.a)).toBe(false)
    expect(m.isObservable(x2.a.b)).toBe(false)

    const b2 = buffer()
    m.autorun(function () {
        b2(x2.a.b.c)
    })
    x2.a = { b: { c: 4 } }
    x2.a.b.c = 5 // not picked up, not reactive, since passed as reference
    expect(b2.toArray()).toEqual([3, 4])

    // non recursive structure
    const x3 = o.object(
        {
            a: {
                b: {
                    c: 3
                }
            }
        },
        {},
        { deep: false }
    )
    const b3 = buffer()
    m.autorun(function () {
        b3(x3.a.b.c)
    })
    x3.a = { b: { c: 4 } }
    x3.a.b.c = 5 // sub structure not reactive
    expect(b3.toArray()).toEqual([3, 4])
})

test("observable3", function () {
    function Order(price) {
        this.price = price
    }

    const x = m.observable({
        orders: [new Order(1), new Order(2)]
    })

    const b = buffer()
    m.autorun(function () {
        b(x.orders.length)
    })

    expect(m.isObservable(x.orders)).toBe(true)
    expect(m.isObservable(x.orders[0])).toBe(false)
    x.orders[2] = new Order(3)
    x.orders = []
    expect(m.isObservable(x.orders)).toBe(true)
    x.orders[0] = new Order(2)
    expect(b.toArray()).toEqual([2, 3, 0, 1])
})

test("observable4", function () {
    const x = m.observable([{ x: 1 }, { x: 2 }])

    const b = buffer()
    m.observe(
        m.computed(function () {
            return x.map(function (d) {
                return d.x
            })
        }),
        x => b(x.newValue),
        true
    )

    x[0].x = 3
    x.shift()
    x.push({ x: 5 })
    expect(b.toArray()).toEqual([[1, 2], [3, 2], [2], [2, 5]])

    // non recursive
    const x2 = o.array([{ x: 1 }, { x: 2 }], { deep: false })

    const b2 = buffer()
    m.observe(
        m.computed(function () {
            return x2.map(function (d) {
                return d.x
            })
        }),
        x => b2(x.newValue),
        true
    )

    x2[0].x = 3
    x2.shift()
    x2.push({ x: 5 })
    expect(b2.toArray()).toEqual([[1, 2], [2], [2, 5]])
})

test("observable5", function () {
    let x = m.computed(function () {})
    expect(function () {
        x.set(7) // set not allowed
    }).toThrow(/It is not possible to assign a new value to a computed value/)

    let f = m._autoAction(function () {})
    const x2 = m.observable.box(f)
    expect(x2.get()).toBe(f)
    x2.set(null) // allowed

    f = m._autoAction(function () {
        return this.price
    })
    x = m.observable(
        {
            price: 17,
            get reactive() {
                return this.price
            },
            nonReactive: f
        },
        {
            nonReactive: false
        }
    )

    const b = buffer()
    m.autorun(function () {
        b([x.reactive, x.nonReactive, x.nonReactive()])
    })

    x.price = 18
    const three = function () {
        return 3
    }
    x.nonReactive = three

    expect(b.toArray()).toEqual([
        [17, f, 17],
        [18, f, 18]
    ])
})

test("flat array", function () {
    const x = m.observable.object(
        {
            x: [
                {
                    a: 1
                }
            ]
        },
        { x: m.observable.shallow }
    )

    let result
    let updates = 0
    m.autorun(function () {
        updates++
        result = JSON.stringify(mobx.toJS(x))
    })

    expect(result).toEqual(JSON.stringify({ x: [{ a: 1 }] }))
    expect(updates).toBe(1)

    x.x[0].a = 2 // not picked up; object is not made reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 1 }] }))
    expect(updates).toBe(1)

    x.x.push({ a: 3 }) // picked up, array is reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 2 }, { a: 3 }] }))
    expect(updates).toBe(2)

    x.x[0] = { a: 4 } // picked up, array is reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 4 }, { a: 3 }] }))
    expect(updates).toBe(3)

    x.x[1].a = 6 // not picked up
    expect(result).toEqual(JSON.stringify({ x: [{ a: 4 }, { a: 3 }] }))
    expect(updates).toBe(3)
})

test("flat object", function () {
    const y = m.observable.object(
        {
            x: { z: 3 }
        },
        {},
        { deep: false }
    )

    let result
    let updates = 0
    m.autorun(function () {
        updates++
        result = JSON.stringify(mobx.toJS(y))
    })

    expect(result).toEqual(JSON.stringify({ x: { z: 3 } }))
    expect(updates).toBe(1)

    y.x.z = 4 // not picked up
    expect(result).toEqual(JSON.stringify({ x: { z: 3 } }))
    expect(updates).toBe(1)

    y.x = { z: 5 }
    expect(result).toEqual(JSON.stringify({ x: { z: 5 } }))
    expect(updates).toBe(2)

    y.x.z = 6 // not picked up
    expect(result).toEqual(JSON.stringify({ x: { z: 5 } }))
    expect(updates).toBe(2)
})

test("as structure", function () {
    const x = m.observable.object(
        {
            x: null
        },
        {
            x: m.observable.struct
        }
    )

    let changed = 0
    const dis = m.autorun(function () {
        changed++
        JSON.stringify(x)
    })

    function c() {
        expect(changed).toBe(1)
        if (changed !== 1) console.trace()
        changed = 0
    }

    function nc() {
        expect(changed).toBe(0)
        if (changed !== 0) console.trace()
        changed = 0
    }

    // nc = no change, c = changed.
    c()
    x.x = null
    nc()
    x.x = undefined
    c()
    x.x = 3
    c()
    x.x = 1 * x.x
    nc()
    x.x = "3"
    c()

    x.x = {
        y: 3
    }
    c()
    x.x.y = 3
    nc()
    x.x = {
        y: 3
    }
    nc()
    x.x = {
        y: 4
    }
    c()
    x.x = {
        y: 3
    }
    c()
    x.x = {
        y: {
            y: 3
        }
    }
    c()
    x.x.y.y = 3
    nc()
    x.x.y = { y: 3 }
    nc()
    x.x = { y: { y: 3 } }
    nc()
    x.x = { y: { y: 4 } }
    c()
    x.x = {}
    c()
    x.x = {}
    nc()

    x.x = []
    c()
    x.x = []
    nc()
    x.x = [3, 2, 1]
    c()
    x.x.sort()
    nc()
    x.x.sort()
    nc()
    x.x[1] = 2
    nc()
    x.x[0] = 0
    nc() // not detected

    dis()
})

test("as structure view", function () {
    const x = m.observable.object(
        {
            a: 1,
            aa: 1,
            get b() {
                this.a
                return { a: this.aa }
            },
            get c() {
                this.b
                return { a: this.aa }
            }
        },
        {
            c: m.computed({ compareStructural: true })
        }
    )

    let bc = 0
    m.autorun(function () {
        x.b
        bc++
    })
    expect(bc).toBe(1)

    let cc = 0
    m.autorun(function () {
        x.c
        cc++
    })
    expect(cc).toBe(1)

    x.a = 2
    x.a = 3
    expect(bc).toBe(3)
    expect(cc).toBe(1)
    x.aa = 3
    expect(bc).toBe(4)
    expect(cc).toBe(2)
})

test("540 - extendobservable should not report cycles", function () {
    expect(() => m.extendObservable(Object.freeze({}), {})).toThrowError(
        /Cannot make the designated object observable/
    )

    const objWrapper = mobx.observable({
        value: null
    })

    const obj = {
        name: "Hello"
    }

    objWrapper.value = obj
    expect(() => mobx.extendObservable(objWrapper, objWrapper.value)).toThrowError(
        /Extending an object with another observable \(object\) is not supported/
    )
})

test("computed value", () => {
    mobx._getGlobalState().mobxGuid = 0
    const c = mobx.computed(() => 3)

    expect(0 + c).toBe(3)
    expect(mobx.isComputed(c)).toBe(true)
    expect(c.toString()).toMatchSnapshot()
})

test("boxed value json", () => {
    const a = mobx.observable.box({ x: 1 })
    expect(a.get().x).toEqual(1)
    a.set(3)
    expect(a.get()).toEqual(3)
    expect("" + a).toBe("3")
    expect(a.toJSON()).toBe(3)
})

test("computed value scope", () => {
    const a = mobx.observable({
        x: 1,
        get y() {
            return this.x * 2
        },
        set y(v) {
            this.x = v
        }
    })

    expect(a.y).toBe(2)
    a.x = 2
    expect(a.y).toBe(4)
    a.y = 3
    expect(a.y).toBe(6)
})

test("shallow array", () => {
    const a = mobx.observable.array([], { deep: false })
    a.push({ x: 1 }, [], 2, mobx.observable({ y: 3 }))

    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservable(a[0])).toBe(false)
    expect(mobx.isObservable(a[1])).toBe(false)
    expect(mobx.isObservable(a[2])).toBe(false)
    expect(mobx.isObservable(a[3])).toBe(true)
})

test("761 - deeply nested modifiers work", () => {
    const a = {}
    mobx.extendObservable(a, {
        someKey: mobx.observable.object(
            {
                someNestedKey: []
            },
            {
                someNestedKey: mobx.observable.ref
            }
        )
    })

    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservableProp(a, "someKey")).toBe(true)
    expect(mobx.isObservable(a.someKey)).toBe(true)
    expect(mobx.isObservableProp(a.someKey, "someNestedKey")).toBe(true)
    expect(mobx.isObservable(a.someKey.someNestedKey)).toBe(false)
    expect(Array.isArray(a.someKey.someNestedKey)).toBe(true)

    Object.assign(a, { someKey: { someNestedKey: [1, 2, 3] } })
    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservableProp(a, "someKey")).toBe(true)
    expect(mobx.isObservable(a.someKey)).toBe(true)
    expect(mobx.isObservableProp(a.someKey, "someNestedKey")).toBe(true)
    expect(mobx.isObservable(a.someKey.someNestedKey)).toBe(true) // Too bad: no deep merge with Object.assign! someKey object gets replaced in its entirity
    expect(Array.isArray(a.someKey.someNestedKey)).toBe(false)
})

test("compare structurally, ref", () => {
    const a = mobx.observable.object(
        {
            x: undefined
        },
        {
            x: mobx.observable.struct
        }
    )

    let changed = 0
    const d = mobx.autorun(() => {
        mobx.toJS(a)
        changed++
    })

    expect(changed).toBe(1)
    a.x = { y: 2 }
    expect(changed).toBe(2)
    a.x.y = 3
    expect(mobx.isObservable(a.x)).toBe(false)
    expect(changed).toBe(2)

    a.x = { y: 3 }
    expect(changed).toBe(2)

    a.x = { y: 4 }
    expect(changed).toBe(3)
    a.x = { y: 4 }
    expect(changed).toBe(3)

    d()
})

test("structural collections", () => {
    const o = mobx.observable(
        {
            x: [1, 2, 3]
        },
        {
            x: mobx.observable.struct
        }
    )

    expect(mobx.isObservable(o.x)).toBeFalsy()
    const x = o.x
    o.x = [1, 2, 3]
    expect(o.x).toBe(x)
    expect(() => {
        o.x = mobx.observable([1, 2, 3])
    }).toThrow("observable.struct should not be used with observable values")
})

test("yest object equals issue - reference", () => {
    class Store {
        constructor() {
            mobx.extendObservable(this, { x: 3 })
        }
    }

    const store = new Store()
    expect(store).toEqual(new Store())
})

test("yest object equals issue", () => {
    class Store {
        @mobx.observable x = 2

        constructor() {
            makeObservable(this)
            this.x = 3
        }
    }

    const store = new Store()
    expect(store).toEqual(new Store())
})

test("yest array equals issue", () => {
    class Store {
        @mobx.observable things = []

        constructor() {
            makeObservable(this)
        }
    }

    const store = new Store()
    expect(store.things).toEqual([])
})

test("#1650, toString is not treated correctly", () => {
    const o = { a: "a", toString: "toString" }
    const oo = mobx.observable(o)
    expect(oo.toString).toBe("toString")
})



================================================
FILE: packages/mobx/__tests__/v4/base/nested.js
================================================
"use strict"

import { extendObservable, observable, autorun, computed, runInAction } from "../mobx4"

test("nested computeds should not run unnecessary", () => {
    function Item(name) {
        extendObservable(this, {
            name: name,
            get index() {
                const i = store.items.indexOf(this)
                if (i === -1) throw "not found"
                return i
            }
        })
    }

    const store = observable({
        items: [],
        get asString() {
            return this.items.map(item => item.index + ":" + item.name).join(",")
        }
    })
    store.items.push(new Item("item1"))

    const values = []
    autorun(() => {
        values.push(store.asString)
    })

    store.items.replace([new Item("item2")])

    expect(values).toEqual(["0:item1", "0:item2"])
})

test("fix #1535: stale observables", cb => {
    // see https://codesandbox.io/s/k92o2jmz63
    const snapshots = []

    const x = observable.box(1)

    // Depends on observable x
    const derived1 = computed(() => {
        return x.get() + 1
    })

    // Depends on computed derived1
    const derived2 = computed(() => {
        return derived1.get() + 1
    })

    function increment() {
        runInAction(() => {
            x.set(x.get() + 1)
            // No problems here
            derived1.get()
            derived2.get()
        })
    }

    function brokenIncrement() {
        runInAction(() => x.set(x.get() + 1))
        // Acessing computed outside of action causes staleness
        // NOTE IT DOESN'T MATTER WHICH COMPUTED IS ACCESSED
        // derived1.get();
        derived2.get()
    }

    autorun(
        () => {
            snapshots.push(`${x.get()}, ${derived1.get()}, ${derived2.get()}`)
        },
        {
            scheduler(f) {
                setImmediate(f)
            }
        }
    )

    increment()
    setTimeout(() => {
        brokenIncrement()
    }, 100)
    setTimeout(() => {
        expect(snapshots).toEqual(["2, 3, 4", "3, 4, 5"])
        cb()
    }, 1000)
})



================================================
FILE: packages/mobx/__tests__/v4/base/object-api.js
================================================
const mobx = require("../mobx4")
const { autorun, keys, when, set, remove, values, entries, reaction, observable, has, get } = mobx

test("keys should be observable when extending", () => {
    const todos = observable({})

    const todoTitles = []
    reaction(
        () => keys(todos).map(key => `${key}: ${todos[key]}`),
        titles => todoTitles.push(titles.join(","))
    )

    mobx.set(todos, {
        lewis: "Read Lewis",
        chesterton: "Be mind blown by Chesterton"
    })
    expect(todoTitles).toEqual(["lewis: Read Lewis,chesterton: Be mind blown by Chesterton"])

    mobx.set(todos, { lewis: "Read Lewis twice" })
    mobx.set(todos, { coffee: "Grab coffee" })
    expect(todoTitles).toEqual([
        "lewis: Read Lewis,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton,coffee: Grab coffee"
    ])
})

test("toJS respects key changes", () => {
    const todos = observable({})

    const serialized = []
    mobx.autorun(() => {
        serialized.push(JSON.stringify(mobx.toJS(todos)))
    })

    mobx.set(todos, {
        lewis: "Read Lewis",
        chesterton: "Be mind blown by Chesterton"
    })
    mobx.set(todos, { lewis: "Read Lewis twice" })
    mobx.set(todos, { coffee: "Grab coffee" })
    expect(serialized).toEqual([
        "{}",
        '{"lewis":"Read Lewis","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton","coffee":"Grab coffee"}'
    ])
})

test("keys(object), values(object), entries(object)", () => {
    const todos = observable({})
    const plain = {}
    const keysSnapshots = []
    const valuesSnapshots = []
    const entriesSnapshots = []
    const expectedKeysSnapshots = []
    const expectedValuesSnapshots = []
    const expectedEntriesSnapshots = []

    const s1 = Symbol()
    const s2 = Symbol()

    function expectEquality() {
        expect(todos).toEqual(plain)
    }

    function expectKeysReaction() {
        expectedKeysSnapshots.push(Object.keys(plain))
    }

    function expectValuesReaction() {
        expectedValuesSnapshots.push(Object.values(plain))
    }

    function expectEntriesReaction() {
        expectedEntriesSnapshots.push(Object.entries(plain))
    }

    reaction(
        () => keys(todos),
        result => keysSnapshots.push(result)
    )

    reaction(
        () => values(todos),
        result => valuesSnapshots.push(result)
    )

    reaction(
        () => entries(todos),
        result => entriesSnapshots.push(result)
    )

    expectEquality()
    // add
    set(todos, "k1", 1)
    plain["k1"] = 1
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add symbol
    set(todos, s1, 2)
    plain[s1] = 2
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete non-existent
    remove(todos, "-")
    delete plain["-"]
    expectEquality()
    // delete non-existent symbol
    remove(todos, Symbol())
    delete plain[Symbol()]
    expectEquality()
    // add second
    set(todos, "k2", 3)
    plain["k2"] = 3
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add second symbol
    set(todos, s2, 4)
    plain[s2] = 4
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // update
    set(todos, "k1", 11)
    plain["k1"] = 11
    expectEquality()
    expectValuesReaction()
    expectEntriesReaction()
    // update symbol
    set(todos, s1, 22)
    plain[s1] = 22
    expectEquality()
    // delete
    remove(todos, "k1")
    delete plain["k1"]
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete symbol
    remove(todos, s1)
    delete plain[s1]
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()

    expect(keysSnapshots).toEqual(expectedKeysSnapshots)
    expect(valuesSnapshots).toEqual(expectedValuesSnapshots)
    expect(entriesSnapshots).toEqual(expectedEntriesSnapshots)
})

test("map - set, remove, values are reactive", () => {
    const todos = observable.map({})
    const snapshots = []

    reaction(
        () => values(todos),
        values => snapshots.push(values)
    )

    expect(has(todos, "x")).toBe(false)
    expect(get(todos, "x")).toBe(undefined)
    set(todos, "x", 3)
    expect(has(todos, "x")).toBe(true)
    expect(get(todos, "x")).toBe(3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")

    expect(snapshots).toEqual([[3], [3, 4], [5, 4], [5]])
})

test("map - set, remove, entries are reactive", () => {
    const todos = observable.map({})
    const snapshots = []

    reaction(
        () => entries(todos),
        entries => snapshots.push(entries)
    )

    expect(has(todos, "x")).toBe(false)
    expect(get(todos, "x")).toBe(undefined)
    set(todos, "x", 3)
    expect(has(todos, "x")).toBe(true)
    expect(get(todos, "x")).toBe(3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")

    expect(snapshots).toEqual([
        [["x", 3]],
        [
            ["x", 3],
            ["z", 4]
        ],
        [
            ["x", 5],
            ["z", 4]
        ],
        [["x", 5]]
    ])
})

test("map - set, remove, keys are reactive", () => {
    const todos = observable.map({ a: 3 })
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, "x", 3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")
    remove(todos, "a")

    expect(snapshots).toEqual([["a", "x"], ["a", "x", "z"], ["a", "x"], ["x"]])
})

test("array - set, remove, values are reactive", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => values(todos),
        values => snapshots.push(values)
    )

    expect(has(todos, 0)).toBe(false)
    expect(get(todos, 0)).toBe(undefined)
    set(todos, 0, 2)
    expect(has(todos, 0)).toBe(true)
    expect(get(todos, 0)).toBe(2)

    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([
        [2],
        [2, 4],
        [2, 4, undefined, 4],
        [2, 3, undefined, 4],
        [2, 3, 4],
        [3, 4]
    ])
})

test("array - set, remove, entries are reactive", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => entries(todos),
        entries => snapshots.push(entries)
    )

    expect(has(todos, 0)).toBe(false)
    expect(get(todos, 0)).toBe(undefined)
    set(todos, 0, 2)
    expect(has(todos, 0)).toBe(true)
    expect(get(todos, 0)).toBe(2)

    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([
        [[0, 2]],
        [
            [0, 2],
            [1, 4]
        ],
        [
            [0, 2],
            [1, 4],
            [2, undefined],
            [3, 4]
        ],
        [
            [0, 2],
            [1, 3],
            [2, undefined],
            [3, 4]
        ],
        [
            [0, 2],
            [1, 3],
            [2, 4]
        ],
        [
            [0, 3],
            [1, 4]
        ]
    ])
})

test("array - set, remove, keys are reactive", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, 0, 2)
    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([[0], [0, 1], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2], [0, 1]])
})

test("observe & intercept", () => {
    let events = []
    const todos = observable(
        {
            a: { title: "get coffee" }
        },
        {},
        { deep: false, name: "TestObject" }
    )
    mobx.observe(todos, c => events.push({ observe: c }))
    const d = mobx.intercept(todos, c => {
        events.push({ intercept: c })
        return null // no addition!
    })

    set(todos, { b: { title: "get tea" } })
    remove(todos, "a")
    expect(events).toMatchSnapshot()
    expect(mobx.toJS(todos)).toEqual({
        a: { title: "get coffee" }
    })

    events.splice(0)
    d()
    set(todos, { b: { title: "get tea" } })
    remove(todos, "a")
    expect(events).toMatchSnapshot()
    expect(mobx.toJS(todos)).toEqual({
        b: { title: "get tea" }
    })
})

test("observe & intercept set called multiple times", () => {
    const a = mobx.observable({})
    const interceptLogs = []
    const observeLogs = []

    mobx.intercept(a, change => {
        interceptLogs.push(`${change.name}: ${change.newValue}`)
        return change
    })
    mobx.observe(a, change => observeLogs.push(`${change.name}: ${change.newValue}`))

    mobx.set(a, "x", 0)
    a.x = 1
    mobx.set(a, "x", 2)

    expect(interceptLogs).toEqual(["x: 0", "x: 1", "x: 2"])
    expect(observeLogs).toEqual(["x: 0", "x: 1", "x: 2"])
})

test("dynamically adding properties should preserve the original modifiers of an object", () => {
    const todos = observable(
        {
            a: { title: "get coffee" }
        },
        {},
        { deep: false }
    )
    expect(mobx.isObservable(todos.a)).toBe(false)
    set(todos, { b: { title: "get tea" } })
    expect(mobx.isObservable(todos.b)).toBe(false)
})

test("has and get are reactive", async () => {
    const todos = observable({})

    const p1 = when(() => has(todos, "x"))
    const p2 = when(() => get(todos, "y") === 3)

    setTimeout(() => {
        set(todos, { x: false, y: 3 })
    }, 100)

    await p1
    await p2
})

test("computed props are considered part of collections", () => {
    const x = observable({
        get y() {
            return 3
        }
    })
    expect(mobx.isComputedProp(x, "y")).toBe(true)
    expect(x.y).toBe(3)
    expect(has(x, "y")).toBe(true)
    expect(get(x, "y")).toBe(3)
    expect(keys(x)).toEqual([])
    expect(values(x)).toEqual([])
    expect(entries(x)).toEqual([])
})

test("#1739 - delete and undelete should work", () => {
    const x = observable({})

    const events = []
    autorun(() => {
        events.push(has(x, "a"))
    })

    set(x, "a", 1)
    set(x, "a", 2)
    remove(x, "a")
    set(x, "a", 2)
    remove(x, "a")
    set(x, "a", 3)
    expect(events).toEqual([false, true, false, true, false, true])
})

test("set - set, remove, keys are reactive", () => {
    const todos = observable.set([1])
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, 2)
    remove(todos, 2)
    set(todos, 3)
    set(todos, 4)
    remove(todos, 3)

    expect(snapshots).toEqual([[1, 2], [1], [1, 3], [1, 3, 4], [1, 4]])
})

test("defineProperty - configurable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: false,
        writable: true,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    obj.foo++
    expect(obj.foo).toBe(1)
    expect(() => mobx.extendObservable(obj, { foo: 0 })).toThrow(TypeError)
    expect(() => mobx.makeObservable(obj, { foo: mobx.observable })).toThrow(TypeError)
    expect(() => mobx.defineProperty(obj, "foo", { configurable: false })).toThrow(TypeError)
})

test("defineProperty - writable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(() => obj.foo++).toThrow(TypeError)
    mobx.extendObservable(obj, { foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    obj.foo++
    expect(obj.foo).toBe(1)
})

test("defineProperty - redefine observable", () => {
    const obj = mobx.observable({ foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
})

test("defineProperty notifies keys observers", () => {
    const obj = mobx.observable({})
    let reactionCount = 0
    reaction(
        () => mobx.keys(obj),
        () => reactionCount++
    )

    const desc = {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(reactionCount).toBe(1)
    mobx.remove(obj, 'foo')
    expect(obj.hasOwnProperty("foo")).toBe(false)
    expect(reactionCount).toBe(2)
})


================================================
FILE: packages/mobx/__tests__/v4/base/observables.js
================================================
"use strict"

const mobx = require("../mobx4")
const m = mobx
const { $mobx, makeObservable, observable, computed, transaction, autorun, extendObservable } = mobx
const utils = require("../../v5/utils/test-utils")

const voidObserver = function () {}

function buffer() {
    const b = []
    const res = function (x) {
        if (typeof x.newValue === "object") {
            const copy = { ...x.newValue }
            delete copy[$mobx]
            b.push(copy)
        } else {
            b.push(x.newValue)
        }
    }
    res.toArray = function () {
        return b
    }
    return res
}

test("argumentless observable", () => {
    const a = observable.box()

    expect(m.isObservable(a)).toBe(true)
    expect(a.get()).toBe(undefined)
})

test("basic", function () {
    const x = observable.box(3)
    const b = buffer()
    m.observe(x, b)
    expect(3).toBe(x.get())

    x.set(5)
    expect(5).toBe(x.get())
    expect([5]).toEqual(b.toArray())
    expect(mobx._isComputingDerivation()).toBe(false)
})

test("basic2", function () {
    const x = observable.box(3)
    const z = computed(function () {
        return x.get() * 2
    })
    const y = computed(function () {
        return x.get() * 3
    })

    m.observe(z, voidObserver)

    expect(z.get()).toBe(6)
    expect(y.get()).toBe(9)

    x.set(5)
    expect(z.get()).toBe(10)
    expect(y.get()).toBe(15)

    expect(mobx._isComputingDerivation()).toBe(false)
})

test("computed with asStructure modifier", function () {
    const x1 = observable.box(3)
    const x2 = observable.box(5)
    const y = m.computed(
        function () {
            return {
                sum: x1.get() + x2.get()
            }
        },
        { compareStructural: true }
    )
    const b = buffer()
    m.observe(y, b, true)

    expect(8).toBe(y.get().sum)

    x1.set(4)
    expect(9).toBe(y.get().sum)

    m.transaction(function () {
        // swap values, computation results is structuraly unchanged
        x1.set(5)
        x2.set(4)
    })

    expect(b.toArray()).toEqual([{ sum: 8 }, { sum: 9 }])
    expect(mobx._isComputingDerivation()).toBe(false)
})

test("dynamic", function (done) {
    try {
        const x = observable.box(3)
        const y = m.computed(function () {
            return x.get()
        })
        const b = buffer()
        m.observe(y, b, true)

        expect(3).toBe(y.get()) // First evaluation here..

        x.set(5)
        expect(5).toBe(y.get())

        expect(b.toArray()).toEqual([3, 5])
        expect(mobx._isComputingDerivation()).toBe(false)

        done()
    } catch (e) {
        console.log(e.stack)
    }
})

test("dynamic2", function (done) {
    try {
        const x = observable.box(3)
        const y = computed(function () {
            return x.get() * x.get()
        })

        expect(9).toBe(y.get())
        const b = buffer()
        m.observe(y, b)

        x.set(5)
        expect(25).toBe(y.get())

        //no intermediate value 15!
        expect([25]).toEqual(b.toArray())
        expect(mobx._isComputingDerivation()).toBe(false)

        done()
    } catch (e) {
        console.log(e.stack)
    }
})

test("box uses equals", function (done) {
    try {
        const x = observable.box("a", {
            equals: (oldValue, newValue) => {
                return oldValue.toLowerCase() === newValue.toLowerCase()
            }
        })

        const b = buffer()
        m.observe(x, b)

        x.set("A")
        x.set("b")
        x.set("B")
        x.set("C")

        expect(["b", "C"]).toEqual(b.toArray())
        expect(mobx._isComputingDerivation()).toBe(false)

        done()
    } catch (e) {
        console.log(e.stack)
    }
})

test("box uses equals2", function (done) {
    try {
        const x = observable.box("01", {
            equals: (oldValue, newValue) => {
                return parseInt(oldValue) === parseInt(newValue)
            }
        })

        const y = computed(function () {
            return parseInt(x)
        })

        const b = buffer()
        m.observe(y, b)

        x.set("2")
        x.set("02")
        x.set("002")
        x.set("03")

        expect([2, 3]).toEqual(b.toArray())
        expect(mobx._isComputingDerivation()).toBe(false)

        done()
    } catch (e) {
        console.log(e.stack)
    }
})

test("readme1", function (done) {
    try {
        const b = buffer()

        const vat = observable.box(0.2)
        const order = {}
        order.price = observable.box(10)
        // Prints: New price: 24
        // in TS, just: value(() => this.price() * (1+vat()))
        order.priceWithVat = computed(function () {
            return order.price.get() * (1 + vat.get())
        })

        m.observe(order.priceWithVat, b)

        order.price.set(20)
        expect([24]).toEqual(b.toArray())
        order.price.set(10)
        expect([24, 12]).toEqual(b.toArray())
        expect(mobx._isComputingDerivation()).toBe(false)

        done()
    } catch (e) {
        console.log(e.stack)
        throw e
    }
})

test("batch", function () {
    const a = observable.box(2)
    const b = observable.box(3)
    const c = computed(function () {
        return a.get() * b.get()
    })
    const d = computed(function () {
        return c.get() * b.get()
    })
    const buf = buffer()
    m.observe(d, buf)

    a.set(4)
    b.set(5)
    // Note, 60 should not happen! (that is d begin computed before c after update of b)
    expect(buf.toArray()).toEqual([36, 100])

    const x = mobx.transaction(function () {
        a.set(2)
        b.set(3)
        a.set(6)
        expect(d.value_).toBe(100) // not updated; in transaction
        expect(d.get()).toBe(54) // consistent due to inspection
        return 2
    })

    expect(x).toBe(2) // test return value
    expect(buf.toArray()).toEqual([36, 100, 54]) // only one new value for d
})

test("transaction with inspection", function () {
    const a = observable.box(2)
    let calcs = 0
    const b = computed(function () {
        calcs++
        return a.get() * 2
    })

    // if not inspected during transaction, postpone value to end
    mobx.transaction(function () {
        a.set(3)
        expect(b.get()).toBe(6)
        expect(calcs).toBe(1)
    })
    expect(b.get()).toBe(6)
    expect(calcs).toBe(2)

    // if inspected, evaluate eagerly
    mobx.transaction(function () {
        a.set(4)
        expect(b.get()).toBe(8)
        expect(calcs).toBe(3)
    })
    expect(b.get()).toBe(8)
    expect(calcs).toBe(4)
})

test("transaction with inspection 2", function () {
    const a = observable.box(2)
    let calcs = 0
    let b
    mobx.autorun(function () {
        calcs++
        b = a.get() * 2
    })

    // if not inspected during transaction, postpone value to end
    mobx.transaction(function () {
        a.set(3)
        expect(b).toBe(4)
        expect(calcs).toBe(1)
    })
    expect(b).toBe(6)
    expect(calcs).toBe(2)

    // if inspected, evaluate eagerly
    mobx.transaction(function () {
        a.set(4)
        expect(b).toBe(6)
        expect(calcs).toBe(2)
    })
    expect(b).toBe(8)
    expect(calcs).toBe(3)
})

test("scope", function () {
    const vat = observable.box(0.2)
    const Order = function () {
        this.price = observable.box(20)
        this.amount = observable.box(2)
        this.total = computed(
            function () {
                return (1 + vat.get()) * this.price.get() * this.amount.get()
            },
            { context: this }
        )
    }

    const order = new Order()
    m.observe(order.total, voidObserver)
    order.price.set(10)
    order.amount.set(3)
    expect(36).toBe(order.total.get())
    expect(mobx._isComputingDerivation()).toBe(false)
})

test("props1", function () {
    const vat = observable.box(0.2)
    const Order = function () {
        mobx.extendObservable(this, {
            price: 20,
            amount: 2,
            get total() {
                return (1 + vat.get()) * this.price * this.amount // price and amount are now properties!
            }
        })
    }

    const order = new Order()
    expect(48).toBe(order.total)
    order.price = 10
    order.amount = 3
    expect(36).toBe(order.total)

    const totals = []
    const sub = mobx.autorun(function () {
        totals.push(order.total)
    })
    order.amount = 4
    sub()
    order.amount = 5
    expect(totals).toEqual([36, 48])

    expect(mobx._isComputingDerivation()).toBe(false)
})

test("props2", function () {
    const vat = observable.box(0.2)
    const Order = function () {
        mobx.extendObservable(this, {
            price: 20,
            amount: 2,
            get total() {
                return (1 + vat.get()) * this.price * this.amount // price and amount are now properties!
            }
        })
    }

    const order = new Order()
    expect(48).toBe(order.total)
    order.price = 10
    order.amount = 3
    expect(36).toBe(order.total)
})

test("props4", function () {
    function Bzz() {
        mobx.extendObservable(this, {
            fluff: [1, 2],
            get sum() {
                return this.fluff.reduce(function (a, b) {
                    return a + b
                }, 0)
            }
        })
    }

    const x = new Bzz()
    x.fluff
    expect(x.sum).toBe(3)
    x.fluff.push(3)
    expect(x.sum).toBe(6)
    x.fluff = [5, 6]
    expect(x.sum).toBe(11)
    x.fluff.push(2)
    expect(x.sum).toBe(13)
})

test("object enumerable props", function () {
    const x = mobx.observable({
        a: 3,
        get b() {
            return 2 * this.a
        }
    })
    mobx.extendObservable(x, { c: 4 })
    const ar = []
    for (const key in x) ar.push(key)
    expect(ar).toEqual(["a", "c"])
})

test("observe property", function () {
    const sb = []
    const mb = []

    const Wrapper = function (chocolateBar) {
        mobx.extendObservable(this, {
            chocolateBar: chocolateBar,
            get calories() {
                return this.chocolateBar.calories
            }
        })
    }

    const snickers = mobx.observable({
        calories: null
    })
    const mars = mobx.observable({
        calories: undefined
    })

    const wrappedSnickers = new Wrapper(snickers)
    const wrappedMars = new Wrapper(mars)

    const disposeSnickers = mobx.autorun(function () {
        sb.push(wrappedSnickers.calories)
    })
    const disposeMars = mobx.autorun(function () {
        mb.push(wrappedMars.calories)
    })
    snickers.calories = 10
    mars.calories = 15

    disposeSnickers()
    disposeMars()
    snickers.calories = 5
    mars.calories = 7

    expect(sb).toEqual([null, 10])
    expect(mb).toEqual([undefined, 15])
})

test("observe object", function () {
    let events = []
    const a = observable({
        a: 1,
        get da() {
            return this.a * 2
        }
    })
    const stop = m.observe(a, function (change) {
        expect(change.observableKind).toEqual("object")
        delete change.observableKind
        delete change.debugObjectName
        events.push(change)
    })

    a.a = 2
    mobx.extendObservable(a, {
        b: 3
    })
    a.a = 4
    a.b = 5
    expect(events).toEqual([
        {
            type: "update",
            object: a,
            name: "a",
            newValue: 2,
            oldValue: 1
        },
        {
            type: "add",
            object: a,
            newValue: 3,
            name: "b"
        },
        {
            type: "update",
            object: a,
            name: "a",
            newValue: 4,
            oldValue: 2
        },
        {
            type: "update",
            object: a,
            name: "b",
            newValue: 5,
            oldValue: 3
        }
    ])

    stop()
    events = []
    a.a = 6
    expect(events.length).toBe(0)
})

test("mobx.observe", function () {
    const events = []
    const o = observable({ b: 2 })
    const ar = observable([3])
    const map = mobx.observable.map({})

    const push = function (event) {
        delete event.debugObjectName
        events.push(event)
    }

    const stop2 = mobx.observe(o, push)
    const stop3 = mobx.observe(ar, push)
    const stop4 = mobx.observe(map, push)

    o.b = 5
    ar[0] = 6
    map.set("d", 7)

    stop2()
    stop3()
    stop4()

    o.b = 9
    ar[0] = 10
    map.set("d", 11)

    expect(events).toEqual([
        {
            type: "update",
            observableKind: "object",
            object: o,
            name: "b",
            newValue: 5,
            oldValue: 2
        },
        {
            type: "update",
            observableKind: "array",
            object: ar,
            index: 0,
            newValue: 6,
            oldValue: 3
        },
        {
            type: "add",
            observableKind: "map",
            object: map,
            newValue: 7,
            name: "d"
        }
    ])
})

test("change count optimization", function () {
    let bCalcs = 0
    let cCalcs = 0
    const a = observable.box(3)
    const b = computed(function () {
        bCalcs += 1
        return 4 + a.get() - a.get()
    })
    const c = computed(function () {
        cCalcs += 1
        return b.get()
    })

    m.observe(c, voidObserver)

    expect(b.get()).toBe(4)
    expect(c.get()).toBe(4)
    expect(bCalcs).toBe(1)
    expect(cCalcs).toBe(1)

    a.set(5)

    expect(b.get()).toBe(4)
    expect(c.get()).toBe(4)
    expect(bCalcs).toBe(2)
    expect(cCalcs).toBe(1)

    expect(mobx._isComputingDerivation()).toBe(false)
})

test("observables removed", function () {
    let calcs = 0
    const a = observable.box(1)
    const b = observable.box(2)
    const c = computed(function () {
        calcs++
        if (a.get() === 1) return b.get() * a.get() * b.get()
        return 3
    })

    expect(calcs).toBe(0)
    m.observe(c, voidObserver)
    expect(c.get()).toBe(4)
    expect(calcs).toBe(1)
    a.set(2)
    expect(c.get()).toBe(3)
    expect(calcs).toBe(2)

    b.set(3) // should not retrigger calc
    expect(c.get()).toBe(3)
    expect(calcs).toBe(2)

    a.set(1)
    expect(c.get()).toBe(9)
    expect(calcs).toBe(3)

    expect(mobx._isComputingDerivation()).toBe(false)
})

test("lazy evaluation", function () {
    let bCalcs = 0
    let cCalcs = 0
    let dCalcs = 0
    let observerChanges = 0

    const a = observable.box(1)
    const b = computed(function () {
        bCalcs += 1
        return a.get() + 1
    })

    const c = computed(function () {
        cCalcs += 1
        return b.get() + 1
    })

    expect(bCalcs).toBe(0)
    expect(cCalcs).toBe(0)
    expect(c.get()).toBe(3)
    expect(bCalcs).toBe(1)
    expect(cCalcs).toBe(1)

    expect(c.get()).toBe(3)
    expect(bCalcs).toBe(2)
    expect(cCalcs).toBe(2)

    a.set(2)
    expect(bCalcs).toBe(2)
    expect(cCalcs).toBe(2)

    expect(c.get()).toBe(4)
    expect(bCalcs).toBe(3)
    expect(cCalcs).toBe(3)

    const d = computed(function () {
        dCalcs += 1
        return b.get() * 2
    })

    const handle = m.observe(
        d,
        function () {
            observerChanges += 1
        },
        false
    )
    expect(bCalcs).toBe(4)
    expect(cCalcs).toBe(3)
    expect(dCalcs).toBe(1) // d is evaluated, so that its dependencies are known

    a.set(3)
    expect(d.get()).toBe(8)
    expect(bCalcs).toBe(5)
    expect(cCalcs).toBe(3)
    expect(dCalcs).toBe(2)

    expect(c.get()).toBe(5)
    expect(bCalcs).toBe(5)
    expect(cCalcs).toBe(4)
    expect(dCalcs).toBe(2)

    expect(b.get()).toBe(4)
    expect(bCalcs).toBe(5)
    expect(cCalcs).toBe(4)
    expect(dCalcs).toBe(2)

    handle() // unlisten
    expect(d.get()).toBe(8)
    expect(bCalcs).toBe(6) // gone to sleep
    expect(cCalcs).toBe(4)
    expect(dCalcs).toBe(3)

    expect(observerChanges).toBe(1)

    expect(mobx._isComputingDerivation()).toBe(false)
})

test("multiple view dependencies", function () {
    let bCalcs = 0
    let dCalcs = 0
    const a = observable.box(1)
    const b = computed(function () {
        bCalcs++
        return 2 * a.get()
    })
    const c = observable.box(2)
    const d = computed(function () {
        dCalcs++
        return 3 * c.get()
    })

    let zwitch = true
    const buffer = []
    let fCalcs = 0
    const dis = mobx.autorun(function () {
        fCalcs++
        if (zwitch) buffer.push(b.get() + d.get())
        else buffer.push(d.get() + b.get())
    })

    zwitch = false
    c.set(3)
    expect(bCalcs).toBe(1)
    expect(dCalcs).toBe(2)
    expect(fCalcs).toBe(2)
    expect(buffer).toEqual([8, 11])

    c.set(4)
    expect(bCalcs).toBe(1)
    expect(dCalcs).toBe(3)
    expect(fCalcs).toBe(3)
    expect(buffer).toEqual([8, 11, 14])

    dis()
    c.set(5)
    expect(bCalcs).toBe(1)
    expect(dCalcs).toBe(3)
    expect(fCalcs).toBe(3)
    expect(buffer).toEqual([8, 11, 14])
})

test("nested observable2", function () {
    const factor = observable.box(0)
    const price = observable.box(100)
    let totalCalcs = 0
    let innerCalcs = 0

    const total = computed(function () {
        totalCalcs += 1 // outer observable shouldn't recalc if inner observable didn't publish a real change
        return (
            price.get() *
            computed(function () {
                innerCalcs += 1
                return factor.get() % 2 === 0 ? 1 : 3
            }).get()
        )
    })

    const b = []
    m.observe(
        total,
        function (x) {
            b.push(x.newValue)
        },
        true
    )

    price.set(150)
    factor.set(7) // triggers innerCalc twice, because changing the outcome triggers the outer calculation which recreates the inner calculation
    factor.set(5) // doesn't trigger outer calc
    factor.set(3) // doesn't trigger outer calc
    factor.set(4) // triggers innerCalc twice
    price.set(20)

    expect(b).toEqual([100, 150, 450, 150, 20])
    expect(innerCalcs).toBe(9)
    expect(totalCalcs).toBe(5)
})

test("observe", function () {
    const x = observable.box(3)
    const x2 = computed(function () {
        return x.get() * 2
    })
    const b = []

    const cancel = mobx.autorun(function () {
        b.push(x2.get())
    })

    x.set(4)
    x.set(5)
    expect(b).toEqual([6, 8, 10])
    cancel()
    x.set(7)
    expect(b).toEqual([6, 8, 10])
})

test("when", function () {
    const x = observable.box(3)

    let called = 0
    mobx.when(
        function () {
            return x.get() === 4
        },
        function () {
            called += 1
        }
    )

    x.set(5)
    expect(called).toBe(0)
    x.set(4)
    expect(called).toBe(1)
    x.set(3)
    expect(called).toBe(1)
    x.set(4)
    expect(called).toBe(1)
})

test("when 2", function () {
    const x = observable.box(3)

    let called = 0
    const d = mobx.when(
        function () {
            return x.get() === 3
        },
        function () {
            called += 1
        },
        { name: "when x is 3" }
    )

    expect(called).toBe(1)
    x.set(5)
    x.set(3)
    expect(called).toBe(1)

    expect(d[$mobx].name_).toBe("when x is 3")
})

function stripSpyOutput(events) {
    events.forEach(ev => {
        delete ev.time
        delete ev.fn
        delete ev.object
    })
    return events
}

test("issue 50", function (done) {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0
    const x = observable({
        a: true,
        b: false,
        get c() {
            events.push("calc c")
            return this.b
        }
    })

    let result
    const events = []
    const disposer1 = mobx.autorun(function ar() {
        events.push("auto")
        result = [x.a, x.b, x.c].join(",")
    })

    const disposer2 = mobx.spy(function (info) {
        events.push(info)
    })

    setTimeout(function () {
        mobx.transaction(function () {
            events.push("transstart")
            x.a = !x.a
            x.b = !x.b
            events.push("transpreend")
        })
        events.push("transpostend")
        expect(result).toBe("false,true,true")
        expect(x.c).toBe(x.b)

        expect(stripSpyOutput(events)).toMatchSnapshot()

        disposer1()
        disposer2()
        done()
    }, 500)
})

test("verify transaction events", function () {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0

    const x = observable({
        b: 1,
        get c() {
            events.push("calc c")
            return this.b
        }
    })

    const events = []
    const disposer1 = mobx.autorun(function ar() {
        events.push("auto")
        x.c
    })

    const disposer2 = mobx.spy(function (info) {
        events.push(info)
    })

    mobx.transaction(function () {
        events.push("transstart")
        x.b = 1
        x.b = 2
        events.push("transpreend")
    })
    events.push("transpostend")

    expect(stripSpyOutput(events)).toMatchSnapshot()

    disposer1()
    disposer2()
})

test("verify array in transaction", function () {
    const ar = observable([])
    let aCount = 0
    let aValue

    mobx.autorun(function () {
        aCount++
        aValue = 0
        for (let i = 0; i < ar.length; i++) aValue += ar[i]
    })

    mobx.transaction(function () {
        ar.push(2)
        ar.push(3)
        ar.push(4)
        ar.unshift(1)
    })
    expect(aValue).toBe(10)
    expect(aCount).toBe(2)
})

test("delay autorun until end of transaction", function () {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0
    const events = []
    const x = observable({
        a: 2,
        get b() {
            events.push("calc y")
            return this.a
        }
    })
    let disposer1
    const disposer2 = mobx.spy(function (info) {
        events.push(info)
    })
    let didRun = false

    mobx.transaction(function () {
        mobx.transaction(function () {
            disposer1 = mobx.autorun(function test() {
                didRun = true
                events.push("auto")
                x.b
            })

            expect(didRun).toBe(false)

            x.a = 3
            x.a = 4

            events.push("end1")
        })
        expect(didRun).toBe(false)
        x.a = 5
        events.push("end2")
    })

    expect(didRun).toBe(true)
    events.push("post trans1")
    x.a = 6
    events.push("post trans2")
    disposer1()
    x.a = 3
    events.push("post trans3")

    expect(stripSpyOutput(events)).toMatchSnapshot()

    disposer2()
})

test("computed values believe NaN === NaN", function () {
    const a = observable.box(2)
    const b = observable.box(3)
    const c = computed(function () {
        return String(a.get() * b.get())
    })
    const buf = buffer()
    m.observe(c, buf)

    a.set(NaN)
    b.set(NaN)
    a.set(NaN)
    a.set(2)
    b.set(3)

    expect(buf.toArray()).toEqual(["NaN", "6"])
})

test("computed values believe deep NaN === deep NaN when using compareStructural", function () {
    const a = observable({ b: { a: 1 } })
    const c = computed(
        function () {
            return a.b
        },
        { compareStructural: true }
    )

    const buf = new buffer()
    m.observe(c, newValue => {
        buf(newValue)
    })

    a.b = { a: NaN }
    a.b = { a: NaN }
    a.b = { a: NaN }
    a.b = { a: 2 }
    a.b = { a: NaN }

    const bufArray = buf.toArray()
    expect(isNaN(bufArray[0].b)).toBe(true)
    expect(bufArray[1]).toEqual({ a: 2 })
    expect(isNaN(bufArray[2].b)).toEqual(true)
    expect(bufArray.length).toBe(3)
})

test("issue 71, transacting running transformation", function () {
    const state = mobx.observable({
        things: []
    })

    function Thing(value) {
        mobx.extendObservable(this, {
            value: value,
            get pos() {
                return state.things.indexOf(this)
            },
            get isVisible() {
                return this.pos !== -1
            }
        })

        mobx.when(
            () => {
                return this.isVisible
            },
            () => {
                if (this.pos < 4) state.things.push(new Thing(value + 1))
            }
        )
    }

    let copy
    let vSum
    mobx.autorun(function () {
        copy = state.things.map(function (thing) {
            return thing.value
        })
        vSum = state.things.reduce(function (a, thing) {
            return a + thing.value
        }, 0)
    })

    expect(copy).toEqual([])

    mobx.transaction(function () {
        state.things.push(new Thing(1))
    })

    expect(copy).toEqual([1, 2, 3, 4, 5])
    expect(vSum).toBe(15)

    state.things.splice(0, 2)
    state.things.push(new Thing(6))

    expect(copy).toEqual([3, 4, 5, 6, 7])
    expect(vSum).toBe(25)
})

test("eval in transaction", function () {
    let bCalcs = 0
    const x = mobx.observable({
        a: 1,
        get b() {
            bCalcs++
            return this.a * 2
        }
    })
    let c

    mobx.autorun(function () {
        c = x.b
    })

    expect(bCalcs).toBe(1)
    expect(c).toBe(2)

    mobx.transaction(function () {
        x.a = 3
        expect(x.b).toBe(6)
        expect(bCalcs).toBe(2)
        expect(c).toBe(2)

        x.a = 4
        expect(x.b).toBe(8)
        expect(bCalcs).toBe(3)
        expect(c).toBe(2)
    })
    expect(bCalcs).toBe(3) // 2 or 3 would be fine as well
    expect(c).toBe(8)
})

test("forcefully tracked reaction should still yield valid results", function () {
    const x = observable.box(3)
    let z
    let runCount = 0
    const identity = function () {
        runCount++
        z = x.get()
    }
    const a = new mobx.Reaction("test", function () {
        this.track(identity)
    })
    a.runReaction_()

    expect(z).toBe(3)
    expect(runCount).toBe(1)

    transaction(function () {
        x.set(4)
        a.track(identity)
        expect(a.isScheduled).toBe(true)
        expect(z).toBe(4)
        expect(runCount).toBe(2)
    })

    expect(z).toBe(4)
    expect(runCount).toBe(2) // x is observed, so it should recompute only on dependency change

    transaction(function () {
        x.set(5)
        expect(a.isScheduled).toBe(true)
        a.track(identity)
        expect(z).toBe(5)
        expect(runCount).toBe(3)
        expect(a.isScheduled).toBe(true)

        x.set(6)
        expect(z).toBe(5)
        expect(runCount).toBe(3)
    })
    expect(a.isScheduled).toBe(false)
    expect(z).toBe(6)
    expect(runCount).toBe(4)
})

test("autoruns created in autoruns should kick off", function () {
    const x = observable.box(3)
    const x2 = []
    let d

    const a = m.autorun(function () {
        if (d) {
            // dispose previous autorun
            d()
        }
        d = m.autorun(function () {
            x2.push(x.get() * 2)
        })
    })

    // a should be observed by the inner autorun, not the outer
    expect(a[$mobx].observing_.length).toBe(0)
    expect(d[$mobx].observing_.length).toBe(1)

    x.set(4)
    expect(x2).toEqual([6, 8])
})

test("#502 extendObservable throws on objects created with Object.create(null)", () => {
    const a = Object.create(null)
    mobx.extendObservable(a, { b: 3 })
    expect(mobx.isObservableProp(a, "b")).toBe(true)
})

test("#328 atom throwing exception if observing stuff in onObserved", () => {
    const b = mobx.observable.box(1)
    const a = mobx.createAtom("test atom", () => {
        b.get()
    })
    const d = mobx.autorun(() => {
        a.reportObserved() // threw
    })
    d()
})

test("prematurely ended autoruns are cleaned up properly", () => {
    const a = mobx.observable.box(1)
    const b = mobx.observable.box(2)
    const c = mobx.observable.box(3)
    let called = 0

    const d = mobx.autorun(() => {
        called++
        if (a.get() === 2) {
            d() // dispose
            b.get() // consume
            a.set(3) // cause itself to re-run, but, disposed!
        } else {
            c.get()
        }
    })

    expect(called).toBe(1)

    a.set(2)

    expect(called).toBe(2)
})

test("unoptimizable subscriptions are diffed correctly", () => {
    const a = mobx.observable.box(1)
    const b = mobx.observable.box(1)
    const c = mobx.computed(() => {
        a.get()
        return 3
    })
    let called = 0
    let val = 0

    const d = mobx.autorun(() => {
        called++
        a.get()
        c.get() // reads a as well
        val = a.get()
        if (
            b.get() === 1 // only on first run
        )
            a.get() // second run: one read less for a
    })

    expect(called).toBe(1)
    expect(val).toBe(1)

    b.set(2)

    expect(called).toBe(2)
    expect(val).toBe(1)

    a.set(2)

    expect(called).toBe(3)
    expect(val).toBe(2)

    d()
})

test("atom events #427", () => {
    let start = 0
    let stop = 0
    let runs = 0

    const a = mobx.createAtom(
        "test",
        () => start++,
        () => stop++
    )
    expect(a.reportObserved()).toEqual(false)

    expect(start).toBe(0)
    expect(stop).toBe(0)

    let d = mobx.autorun(() => {
        runs++
        expect(a.reportObserved()).toBe(true)
        expect(start).toBe(1)
        expect(a.reportObserved()).toBe(true)
        expect(start).toBe(1)
    })

    expect(runs).toBe(1)
    expect(start).toBe(1)
    expect(stop).toBe(0)
    a.reportChanged()
    expect(runs).toBe(2)
    expect(start).toBe(1)
    expect(stop).toBe(0)

    d()
    expect(runs).toBe(2)
    expect(start).toBe(1)
    expect(stop).toBe(1)

    expect(a.reportObserved()).toBe(false)
    expect(start).toBe(1)
    expect(stop).toBe(1)

    d = mobx.autorun(() => {
        expect(a.reportObserved()).toBe(true)
        expect(start).toBe(2)
        a.reportObserved()
        expect(start).toBe(2)
    })

    expect(start).toBe(2)
    expect(stop).toBe(1)
    a.reportChanged()
    expect(start).toBe(2)
    expect(stop).toBe(1)

    d()
    expect(stop).toBe(2)
})

test("verify calculation count", () => {
    const calcs = []
    const a = observable.box(1)
    const b = mobx.computed(() => {
        calcs.push("b")
        return a.get()
    })
    const c = mobx.computed(() => {
        calcs.push("c")
        return b.get()
    })
    const d = mobx.autorun(() => {
        calcs.push("d")
        return b.get()
    })
    const e = mobx.autorun(() => {
        calcs.push("e")
        return c.get()
    })
    const f = mobx.computed(() => {
        calcs.push("f")
        return c.get()
    })

    expect(f.get()).toBe(1)

    calcs.push("change")
    a.set(2)

    expect(f.get()).toBe(2)

    calcs.push("transaction")
    transaction(() => {
        expect(b.get()).toBe(2)
        expect(c.get()).toBe(2)
        expect(f.get()).toBe(2)
        expect(f.get()).toBe(2)
        calcs.push("change")
        a.set(3)
        expect(b.get()).toBe(3)
        expect(b.get()).toBe(3)
        calcs.push("try c")
        expect(c.get()).toBe(3)
        expect(c.get()).toBe(3)
        calcs.push("try f")
        expect(f.get()).toBe(3)
        expect(f.get()).toBe(3)
        calcs.push("end transaction")
    })

    expect(calcs).toEqual([
        "d",
        "b",
        "e",
        "c",
        "f",
        "change",
        "b",
        "d",
        "c",
        "e",
        "f", // would have expected b c e d f, but alas
        "transaction",
        "f",
        "change",
        "b",
        "try c",
        "c",
        "try f",
        "f",
        "end transaction",
        "d",
        "e"
    ])

    d()
    e()
})

test("support computed property getters / setters", () => {
    let a = observable({
        size: 1,
        get volume() {
            return this.size * this.size
        }
    })

    expect(a.volume).toBe(1)
    a.size = 3
    expect(a.volume).toBe(9)

    expect(() => (a.volume = 9)).toThrowError(
        /It is not possible to assign a new value to a computed value/
    )

    a = {}
    mobx.extendObservable(a, {
        size: 2,
        get volume() {
            return this.size * this.size
        },
        set volume(v) {
            this.size = Math.sqrt(v)
        }
    })

    const values = []
    const d = mobx.autorun(() => values.push(a.volume))

    a.volume = 9
    mobx.transaction(() => {
        a.volume = 100
        a.volume = 64
    })

    expect(values).toEqual([4, 9, 64])
    expect(a.size).toEqual(8)

    d()
})

test("computed getter / setter for plan objects should succeed", function () {
    const b = observable({
        a: 3,
        get propX() {
            return this.a * 2
        },
        set propX(v) {
            this.a = v
        }
    })

    const values = []
    mobx.autorun(function () {
        return values.push(b.propX)
    })
    expect(b.propX).toBe(6)
    b.propX = 4
    expect(b.propX).toBe(8)

    expect(values).toEqual([6, 8])
})

test("helpful error for self referencing setter", function () {
    const a = observable({
        x: 1,
        get y() {
            return this.x
        },
        set y(v) {
            this.y = v // woops...;-)
        }
    })

    expect(() => (a.y = 2)).toThrowError(/The setter of computed value/)
})

test("#558 boxed observables stay boxed observables", function () {
    const a = observable({
        x: observable.box(3)
    })

    expect(typeof a.x).toBe("object")
    expect(typeof a.x.get).toBe("function")
})

test("iscomputed", function () {
    expect(mobx.isComputed(observable.box(3))).toBe(false)
    expect(
        mobx.isComputed(
            mobx.computed(function () {
                return 3
            })
        )
    ).toBe(true)

    const x = observable({
        a: 3,
        get b() {
            return this.a
        }
    })

    expect(mobx.isComputedProp(x, "a")).toBe(false)
    expect(mobx.isComputedProp(x, "b")).toBe(true)
})

test("603 - transaction should not kill reactions", () => {
    const a = observable.box(1)
    let b = 1
    const d = mobx.autorun(() => {
        b = a.get()
    })

    try {
        mobx.transaction(() => {
            a.set(2)
            throw 3
        })
    } catch (e) {
        // empty
    }

    const g = m._getGlobalState()
    expect(g.inBatch).toEqual(0)
    expect(g.pendingReactions.length).toEqual(0)
    expect(g.pendingUnobservations.length).toEqual(0)
    expect(g.trackingDerivation).toEqual(null)

    expect(b).toBe(2)
    a.set(3)
    expect(b).toBe(3)
    d()
})

test("#561 test toPrimitive() of observable objects", function () {
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
        let x = observable.box(3)

        expect(x.valueOf()).toBe(3)
        expect(x[Symbol.toPrimitive]()).toBe(3)

        expect(+x).toBe(3)
        expect(++x).toBe(4)

        const y = observable.box(3)

        expect(y + 7).toBe(10)

        const z = computed(() => ({ a: 3 }))
        expect(3 + z).toBe("3[object Object]")
    } else {
        let x = observable.box(3)

        expect(x.valueOf()).toBe(3)
        expect(x["@@toPrimitive"]()).toBe(3)

        expect(+x).toBe(3)
        expect(++x).toBe(4)

        const y = observable.box(3)

        expect(y + 7).toBe(10)

        const z = computed(() => ({ a: 3 }))
        expect("3" + z["@@toPrimitive"]()).toBe("3[object Object]")
    }
})

test("computed equals function only invoked when necessary", () => {
    utils.supressConsole(() => {
        const comparisons = []
        const loggingComparer = (from, to) => {
            comparisons.push({ from, to })
            return from === to
        }

        const left = mobx.observable.box("A")
        const right = mobx.observable.box("B")
        const combinedToLowerCase = mobx.computed(
            () => left.get().toLowerCase() + right.get().toLowerCase(),
            { equals: loggingComparer }
        )

        const values = []
        let disposeAutorun = mobx.autorun(() => values.push(combinedToLowerCase.get()))

        // No comparison should be made on the first value
        expect(comparisons).toEqual([])

        // First change will cause a comparison
        left.set("C")
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Transition *to* CaughtException in the computed won't cause a comparison
        left.set(null)
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Transition *between* CaughtException-s in the computed won't cause a comparison
        right.set(null)
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Transition *from* CaughtException in the computed won't cause a comparison
        left.set("D")
        right.set("E")
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Another value change will cause a comparison
        right.set("F")
        expect(comparisons).toEqual([
            { from: "ab", to: "cb" },
            { from: "de", to: "df" }
        ])

        // Becoming unobserved, then observed won't cause a comparison
        disposeAutorun()
        disposeAutorun = mobx.autorun(() => values.push(combinedToLowerCase.get()))
        expect(comparisons).toEqual([
            { from: "ab", to: "cb" },
            { from: "de", to: "df" }
        ])

        expect(values).toEqual(["ab", "cb", "de", "df", "df"])

        disposeAutorun()
    })
})

// document that extendObservable is not inheritance compatible,
// and make sure this does work with decorate
test("Issue 1092 - Should not access attributes of siblings in the prot. chain", () => {
    // The parent is an observable
    // and has an attribute
    const parent = {}
    mobx.extendObservable(parent, {
        staticObservable: 11
    })

    // Child1 "inherit" from the parent
    // and has an observable attribute
    const child1 = Object.create(parent)
    mobx.extendObservable(child1, {
        attribute: 7
    })

    // Child2 also "inherit" from the parent
    // But does not have any observable attribute
    const child2 = Object.create(parent)

    // The second child should not be aware of the attribute of his
    // sibling child1
    expect(typeof child2.attribute).toBe("undefined")

    expect(parent.staticObservable).toBe(11)
    parent.staticObservable = 12
    expect(parent.staticObservable).toBe(12)
})

test("Issue 1092 - We should be able to define observable on all siblings", () => {
    expect.assertions(1)

    // The parent is an observable
    const parent = {}
    mobx.extendObservable(parent, {})

    // Child1 "inherit" from the parent
    // and has an observable attribute
    const child1 = Object.create(parent)
    mobx.extendObservable(child1, {
        attribute: 7
    })

    // Child2 also "inherit" from the parent
    // But does not have any observable attribute
    const child2 = Object.create(parent)
    expect(() => {
        mobx.extendObservable(child2, {
            attribute: 8
        })
    }).not.toThrow()
})

test("Issue 1120 - isComputed should return false for a non existing property", () => {
    expect(mobx.isComputedProp({}, "x")).toBe(false)
    expect(mobx.isComputedProp(observable({}), "x")).toBe(false)
})

test("computed comparer works with decorate (plain)", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    function Time(hour, minute) {
        this.hour = hour
        this.minute = minute
        makeObservable(this, {
            hour: observable,
            minute: observable,
            time: computed({ equals: sameTime })
        })
    }

    Object.defineProperty(Time.prototype, "time", {
        configurable: true,
        enumerable: true,
        get() {
            return { hour: this.hour, minute: this.minute }
        }
    })
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("computed comparer works with decorate (plain) - 2", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    function Time(hour, minute) {
        extendObservable(
            this,
            {
                hour,
                minute,
                get time() {
                    return { hour: this.hour, minute: this.minute }
                }
            },
            {
                time: computed({ equals: sameTime })
            }
        )
    }
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("computed comparer works with decorate (plain) - 3", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    const time = observable.object(
        {
            hour: 9,
            minute: 0,
            get time() {
                return { hour: this.hour, minute: this.minute }
            }
        },
        {
            time: computed({ equals: sameTime })
        }
    )

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("can create computed with setter", () => {
    let y = 1
    let x = mobx.computed(() => y, {
        set: v => {
            y = v * 2
        }
    })
    expect(x.get()).toBe(1)
    x.set(3)
    expect(x.get()).toBe(6)
})

test("can make non-extenible objects observable", () => {
    const base = { x: 3 }
    Object.freeze(base)
    const o = mobx.observable(base)
    o.x = 4
    expect(o.x).toBe(4)
    expect(mobx.isObservableProp(o, "x")).toBeTruthy()
})

test("keeping computed properties alive does not run before access", () => {
    let calcs = 0
    observable(
        {
            x: 1,
            get y() {
                calcs++
                return this.x * 2
            }
        },
        {
            y: mobx.computed({ keepAlive: true })
        }
    )

    expect(calcs).toBe(0) // initially there is no calculation done
})

test("(for objects) keeping computed properties alive does not run before access", () => {
    let calcs = 0
    class Foo {
        @observable x = 1

        constructor() {
            makeObservable(this)
        }

        @computed({ keepAlive: true })
        get y() {
            calcs++
            return this.x * 2
        }
    }
    new Foo()

    expect(calcs).toBe(0) // initially there is no calculation done
})

test("keeping computed properties alive runs on first access", () => {
    let calcs = 0
    const x = observable(
        {
            x: 1,
            get y() {
                calcs++
                return this.x * 2
            }
        },
        {
            y: mobx.computed({ keepAlive: true })
        }
    )

    expect(calcs).toBe(0)
    expect(x.y).toBe(2) // perform calculation on access
    expect(calcs).toBe(1)
})

test("keeping computed properties alive caches values on subsequent accesses", () => {
    let calcs = 0
    const x = observable(
        {
            x: 1,
            get y() {
                calcs++
                return this.x * 2
            }
        },
        {
            y: mobx.computed({ keepAlive: true })
        }
    )

    expect(x.y).toBe(2) // first access: do calculation
    expect(x.y).toBe(2) // second access: use cached value, no calculation
    expect(calcs).toBe(1) // only one calculation: cached!
})

test("keeping computed properties alive does not recalculate when dirty", () => {
    let calcs = 0
    const x = observable(
        {
            x: 1,
            get y() {
                calcs++
                return this.x * 2
            }
        },
        {
            y: mobx.computed({ keepAlive: true })
        }
    )

    expect(x.y).toBe(2) // first access: do calculation
    expect(calcs).toBe(1)
    x.x = 3 // mark as dirty: no calculation
    expect(calcs).toBe(1)
    expect(x.y).toBe(6)
})

test("keeping computed properties alive recalculates when accessing it dirty", () => {
    let calcs = 0
    const x = observable(
        {
            x: 1,
            get y() {
                calcs++
                return this.x * 2
            }
        },
        {
            y: mobx.computed({ keepAlive: true })
        }
    )

    expect(x.y).toBe(2) // first access: do calculation
    expect(calcs).toBe(1)
    x.x = 3 // mark as dirty: no calculation
    expect(calcs).toBe(1)
    expect(x.y).toBe(6) // second access: do calculation because it is dirty
    expect(calcs).toBe(2)
})

test("(for objects) keeping computed properties alive recalculates when accessing it dirty", () => {
    let calcs = 0
    class Foo {
        @observable x = 1

        constructor() {
            makeObservable(this)
        }

        @computed({ keepAlive: true })
        get y() {
            calcs++
            return this.x * 2
        }
    }
    const x = new Foo()

    expect(x.y).toBe(2) // first access: do calculation
    expect(calcs).toBe(1)
    x.x = 3 // mark as dirty: no calculation
    expect(calcs).toBe(1)
    expect(x.y).toBe(6) // second access: do calculation because it is dirty
    expect(calcs).toBe(2)
})

test("tuples", () => {
    // See #1391
    function tuple() {
        const res = new Array(arguments.length)
        for (let i = 0; i < arguments.length; i++) mobx.extendObservable(res, { [i]: arguments[i] })
        return res
    }

    const myStuff = tuple(1, 3)
    const events = []

    mobx.reaction(
        () => myStuff[0],
        val => events.push(val)
    )
    myStuff[1] = 17 // should not react
    myStuff[0] = 2 // should react
    expect(events).toEqual([2])

    expect(myStuff.map(x => x * 2)).toEqual([4, 34])
})



================================================
FILE: packages/mobx/__tests__/v4/base/observe.ts
================================================
import { observable, observe, computed } from "../mobx4"

test("observe object and map properties", function () {
    const map = observable.map({ a: 1 })
    const events: any[] = []

    expect(() => observe(map, "b", () => {})).toThrow(
        /the entry 'b' does not exist in the observable map/
    )

    const d1 = observe(map, "a", e => events.push([e.newValue, e.oldValue]))

    map.set("a", 2)
    map.set("a", 3)
    d1()
    map.set("a", 4)

    const o = observable({ a: 5 })

    expect(() => observe(o, "b" as any, () => {})).toThrow(
        /no observable property 'b' found on the observable object/
    )
    const d2 = observe(o, "a", e => events.push([e.newValue, e.oldValue]))

    o.a = 6
    o.a = 7
    d2()
    o.a = 8

    expect(events).toEqual([
        [2, 1],
        [3, 2],
        [6, 5],
        [7, 6]
    ])
})

test("observe computed values", () => {
    const events: any[] = []

    const v = observable.box(0)
    const f = observable.box(0)
    const c = computed(() => v.get())

    observe(c, e => {
        v.get()
        f.get()
        events.push([e.newValue, e.oldValue])
    })

    v.set(6)
    f.set(10)

    expect(events).toEqual([[6, 0]])
})



================================================
FILE: packages/mobx/__tests__/v4/base/spy.js
================================================
"use strict"
const mobx = require("../mobx4")
const utils = require("../../v5/utils/test-utils")

test("spy output", () => {
    const events = []

    const stop = mobx.spy(c => events.push(c))

    doStuff()

    stop()

    doStuff()

    events.forEach(ev => {
        delete ev.object
        delete ev.fn
        delete ev.time
    })

    expect(events).toMatchSnapshot()
})

function doStuff() {
    const a = mobx.observable.box(2)
    a.set(3)

    const b = mobx.observable({
        c: 4
    })
    b.c = 5
    mobx.extendObservable(b, { d: 6 })
    b.d = 7

    const e = mobx.observable([1, 2])
    e.push(3, 4)
    e.shift()
    e[2] = 5

    const f = mobx.observable.map({ g: 1 })
    f.delete("h")
    f.delete("g")
    f.set("i", 5)
    f.set("i", 6)

    const j = mobx.computed(() => a.get() * 2)

    mobx.autorun(() => {
        j.get()
    })

    a.set(4)

    mobx.transaction(function myTransaction() {
        a.set(5)
        a.set(6)
    })

    mobx.action("myTestAction", newValue => {
        a.set(newValue)
    }).call({}, 7)
}

test("spy error", () => {
    utils.supressConsole(() => {
        mobx._getGlobalState().mobxGuid = 0

        const a = mobx.observable({
            x: 2,
            get y() {
                if (this.x === 3) throw "Oops"
                return this.x * 2
            }
        })

        const events = []
        const stop = mobx.spy(c => events.push(c))

        const d = mobx.autorun(() => a.y, { name: "autorun" })

        a.x = 3

        events.forEach(x => {
            delete x.fn
            delete x.object
            delete x.time
        })

        expect(events).toMatchSnapshot()

        d()
        stop()
    })
})

test("spy stop listen from handler, #1459", () => {
    const stop = mobx.spy(() => stop())
    mobx.spy(() => {})
    doStuff()
})



================================================
FILE: packages/mobx/__tests__/v4/base/tojs.js
================================================
"use strict"

const mobx = require("../mobx4")
const m = mobx
const observable = mobx.observable
const { makeObservable } = mobx

test("json1", function () {
    mobx._resetGlobalState()

    const todos = observable([
        {
            title: "write blog"
        },
        {
            title: "improve coverge"
        }
    ])

    let output
    mobx.autorun(function () {
        output = todos
            .map(function (todo) {
                return todo.title
            })
            .join(", ")
    })

    todos[1].title = "improve coverage" // prints: write blog, improve coverage
    expect(output).toBe("write blog, improve coverage")
    todos.push({ title: "take a nap" }) // prints: write blog, improve coverage, take a nap
    expect(output).toBe("write blog, improve coverage, take a nap")
})

test("json2", function () {
    const source = {
        todos: [
            {
                title: "write blog",
                tags: ["react", "frp"],
                details: {
                    url: "somewhere"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh"],
                details: {
                    url: "here"
                }
            }
        ]
    }

    const o = mobx.observable(JSON.parse(JSON.stringify(source)))

    expect(mobx.toJS(o)).toEqual(source)

    const analyze = mobx.computed(function () {
        return [o.todos.length, o.todos[1].details.url]
    })

    const alltags = mobx.computed(function () {
        return o.todos
            .map(function (todo) {
                return todo.tags.join(",")
            })
            .join(",")
    })

    let ab = []
    let tb = []

    m.observe(
        analyze,
        function (d) {
            ab.push(d.newValue)
        },
        true
    )
    m.observe(
        alltags,
        function (d) {
            tb.push(d.newValue)
        },
        true
    )

    o.todos[0].details.url = "boe"
    o.todos[1].details.url = "ba"
    o.todos[0].tags[0] = "reactjs"
    o.todos[1].tags.push("pff")

    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh", "pff"],
                details: {
                    url: "ba"
                }
            }
        ]
    })
    expect(ab).toEqual([
        [2, "here"],
        [2, "ba"]
    ])
    expect(tb).toEqual(["react,frp,mweh", "reactjs,frp,mweh", "reactjs,frp,mweh,pff"])
    ab = []
    tb = []

    o.todos.push(
        mobx.observable({
            title: "test",
            tags: ["x"]
        })
    )

    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh", "pff"],
                details: {
                    url: "ba"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(ab).toEqual([[3, "ba"]])
    expect(tb).toEqual(["reactjs,frp,mweh,pff,x"])
    ab = []
    tb = []

    o.todos[1] = mobx.observable({
        title: "clean the attic",
        tags: ["needs sabbatical"],
        details: {
            url: "booking.com"
        }
    })
    expect(JSON.parse(JSON.stringify(o))).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "clean the attic",
                tags: ["needs sabbatical"],
                details: {
                    url: "booking.com"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(ab).toEqual([[3, "booking.com"]])
    expect(tb).toEqual(["reactjs,frp,needs sabbatical,x"])
    ab = []
    tb = []

    o.todos[1].details = mobx.observable({ url: "google" })
    o.todos[1].tags = ["foo", "bar"]
    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "clean the attic",
                tags: ["foo", "bar"],
                details: {
                    url: "google"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(mobx.toJS(o)).toEqual(mobx.toJS(o))
    expect(ab).toEqual([[3, "google"]])
    expect(tb).toEqual(["reactjs,frp,foo,bar,x"])
})

test("toJS handles dates", () => {
    const a = observable({
        d: new Date()
    })

    const b = mobx.toJS(a)
    expect(b.d instanceof Date).toBe(true)
    expect(a.d === b.d).toBe(true)
})

test("json cycles", function () {
    const a = observable({
        b: 1,
        c: [2],
        d: mobx.observable.map()
    })

    a.e = a
    a.c.push(a, a.d)
    a.d.set("f", a)
    a.d.set("d", a.d)
    a.d.set("c", a.c)

    const cloneA = mobx.toJS(a)
    const cloneC = cloneA.c
    const cloneD = cloneA.d

    expect(cloneA.b).toBe(1)
    expect(cloneA.c[0]).toBe(2)
    expect(cloneA.c[1]).toBe(cloneA)
    expect(cloneA.c[2]).toBe(cloneD)
    expect(cloneD.get("f")).toBe(cloneA)
    expect(cloneD.get("d")).toBe(cloneD)
    expect(cloneD.get("c")).toBe(cloneC)
    expect(cloneA.e).toBe(cloneA)
})

test("#285 class instances with toJS", () => {
    function Person() {
        this.firstName = "michel"
        mobx.extendObservable(this, {
            lastName: "weststrate",
            tags: ["user", "mobx-member"],
            get fullName() {
                return this.firstName + this.lastName
            }
        })
    }

    const p1 = new Person()
    // check before lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: "weststrate",
        tags: ["user", "mobx-member"]
    })

    // check after lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: "weststrate",
        tags: ["user", "mobx-member"]
    })
})

test("#285 non-mobx class instances with toJS", () => {
    const nameObservable = mobx.observable.box("weststrate")
    function Person() {
        this.firstName = "michel"
        this.lastName = nameObservable
    }

    const p1 = new Person()
    // check before lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: nameObservable // toJS doesn't recurse into non observable objects!
    })
})

test("verify #566 solution", () => {
    function MyClass() {}
    const a = new MyClass()
    const b = mobx.observable({ x: 3 })
    const c = mobx.observable({ a: a, b: b })

    expect(mobx.toJS(c).a === a).toBeTruthy() // true
    expect(mobx.toJS(c).b !== b).toBeTruthy() // false, cloned
    expect(mobx.toJS(c).b.x === b.x).toBeTruthy() // true, both 3
})

test("verify already seen", () => {
    const a = mobx.observable({ x: null, y: 3 })
    a.x = a

    const res = mobx.toJS(a)
    expect(res.y).toBe(3)
    expect(res.x === res).toBeTruthy()
    expect(res.x === a).toBeFalsy()
})

test("json cycles when exporting maps as maps", function () {
    const a = observable({
        b: 1,
        c: [2],
        d: mobx.observable.map()
    })

    a.e = a
    a.c.push(a, a.d)
    a.d.set("f", a)
    a.d.set("d", a.d)
    a.d.set("c", a.c)

    const cloneA = mobx.toJS(a)
    const cloneC = cloneA.c
    const cloneD = cloneA.d

    expect(cloneA.b).toBe(1)
    expect(cloneA.c[0]).toBe(2)
    expect(cloneA.c[1]).toBe(cloneA)
    expect(cloneA.c[2]).toBe(cloneD)
    expect(cloneD).toBeInstanceOf(Map)
    expect(cloneD.get("f")).toBe(cloneA)
    expect(cloneD.get("d")).toBe(cloneD)
    expect(cloneD.get("c")).toBe(cloneC)
    expect(cloneA.e).toBe(cloneA)
})

test("map to JS", () => {
    class MyClass {
        @observable meta = new Map()

        constructor() {
            makeObservable(this)
            this.meta.set("test", { abc: "def", ghi: "jkl" })

            expect(mobx.toJS(this.meta).constructor.name).toBe("Map")
        }
    }
    new MyClass()
})

test("Correctly converts observable objects with computed values", () => {
    const a = observable({ key: "value" })
    const c = observable({ computedValue: mobx.computed(() => a.key) })

    const j = mobx.toJS(c)
    expect(j).toMatchObject({ computedValue: "value" })
})



================================================
FILE: packages/mobx/__tests__/v4/base/untracked.ts
================================================
import { autorun, observable, computed, untracked } from "../mobx4"

test("untracked 1", () => {
    let cCalcs = 0,
        dCalcs = 0
    const a = observable.box(1)
    const b = observable.box(2)
    const c = computed(() => {
        cCalcs++
        return a.get() + untracked(() => b.get())
    })
    let result

    autorun(() => {
        dCalcs++
        result = c.get()
    })

    expect(result).toBe(3)
    expect(cCalcs).toBe(1)
    expect(dCalcs).toBe(1)

    b.set(3)
    expect(result).toBe(3)
    expect(cCalcs).toBe(1)
    expect(dCalcs).toBe(1)

    a.set(2)
    expect(result).toBe(5)
    expect(cCalcs).toBe(2)
    expect(dCalcs).toBe(2)
})



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/array.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`very long arrays can be safely passed to nativeArray.concat #2379 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx.array] Attempt to read an array index (10000) that is out of bounds (10000). Please check length first. Out of bound indices will not be tracked by MobX",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/extras.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`spy 1 1`] = `
[
  {
    "debugObjectName": "ObservableValue@6",
    "newValue": 4,
    "observableKind": "value",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ComputedValue@7",
    "newValue": 8,
    "observableKind": "computed",
    "oldValue": 6,
    "type": "update",
  },
  {
    "name": "Autorun@8",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/makereactive.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`computed value 1`] = `"ComputedValue@1[() => 3]"`;



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/object-api.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`observe & intercept 1`] = `
[
  {
    "intercept": {
      "name": "b",
      "newValue": {
        "title": "get tea",
      },
      "object": {
        "a": {
          "title": "get coffee",
        },
      },
      "type": "add",
    },
  },
  {
    "intercept": {
      "name": "a",
      "object": {
        "a": {
          "title": "get coffee",
        },
      },
      "type": "remove",
    },
  },
]
`;

exports[`observe & intercept 2`] = `
[
  {
    "observe": {
      "debugObjectName": "TestObject",
      "name": "b",
      "newValue": {
        "title": "get tea",
      },
      "object": {
        "b": {
          "title": "get tea",
        },
      },
      "observableKind": "object",
      "type": "add",
    },
  },
  {
    "observe": {
      "debugObjectName": "TestObject",
      "name": "a",
      "object": {
        "b": {
          "title": "get tea",
        },
      },
      "observableKind": "object",
      "oldValue": {
        "title": "get coffee",
      },
      "type": "remove",
    },
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/observables.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`delay autorun until end of transaction 1`] = `
[
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 4,
    "observableKind": "object",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "end1",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 5,
    "observableKind": "object",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "end2",
  {
    "name": "test",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  "calc y",
  {
    "debugObjectName": "ObservableObject@1.b",
    "newValue": 5,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans1",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 6,
    "observableKind": "object",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  "calc y",
  {
    "debugObjectName": "ObservableObject@1.b",
    "newValue": 6,
    "observableKind": "computed",
    "oldValue": 5,
    "type": "update",
  },
  {
    "name": "test",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans2",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans3",
]
`;

exports[`issue 50 1`] = `
[
  "auto",
  "calc c",
  "transstart",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": false,
    "observableKind": "object",
    "oldValue": true,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "b",
    "newValue": true,
    "observableKind": "object",
    "oldValue": false,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpreend",
  {
    "name": "ar",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  "calc c",
  {
    "debugObjectName": "ObservableObject@1.c",
    "newValue": true,
    "observableKind": "computed",
    "oldValue": false,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpostend",
]
`;

exports[`verify transaction events 1`] = `
[
  "auto",
  "calc c",
  "transstart",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "b",
    "newValue": 2,
    "observableKind": "object",
    "oldValue": 1,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpreend",
  "calc c",
  {
    "debugObjectName": "ObservableObject@1.c",
    "newValue": 2,
    "observableKind": "computed",
    "oldValue": 1,
    "type": "update",
  },
  {
    "name": "ar",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpostend",
]
`;



================================================
FILE: packages/mobx/__tests__/v4/base/__snapshots__/spy.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`spy error 1`] = `
[
  {
    "name": "autorun",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "debugObjectName": "ObservableObject@1.y",
    "newValue": 4,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "x",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ObservableObject@1.y",
    "newValue": CaughtException {
      "cause": "Oops",
    },
    "observableKind": "computed",
    "oldValue": 4,
    "type": "update",
  },
  {
    "name": "autorun",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "error": "Oops",
    "message": "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: 'Reaction[autorun]'",
    "name": "autorun",
    "type": "error",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;

exports[`spy output 1`] = `
[
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": "2",
    "observableKind": "value",
    "type": "create",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 3,
    "observableKind": "value",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "c",
    "newValue": 4,
    "observableKind": "object",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "c",
    "newValue": 5,
    "observableKind": "object",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "d",
    "newValue": 6,
    "observableKind": "object",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "d",
    "newValue": 7,
    "observableKind": "object",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [
      1,
      2,
    ],
    "addedCount": 2,
    "debugObjectName": "ObservableArray@3",
    "index": 0,
    "observableKind": "array",
    "removed": [],
    "removedCount": 0,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [
      3,
      4,
    ],
    "addedCount": 2,
    "debugObjectName": "ObservableArray@3",
    "index": 2,
    "observableKind": "array",
    "removed": [],
    "removedCount": 0,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [],
    "addedCount": 0,
    "debugObjectName": "ObservableArray@3",
    "index": 0,
    "observableKind": "array",
    "removed": [
      1,
    ],
    "removedCount": 1,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableArray@3",
    "index": 2,
    "newValue": 5,
    "observableKind": "array",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "g",
    "newValue": 1,
    "observableKind": "map",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "g",
    "observableKind": "map",
    "oldValue": 1,
    "spyReportStart": true,
    "type": "delete",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "i",
    "newValue": 5,
    "observableKind": "map",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "i",
    "newValue": 6,
    "observableKind": "map",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 6,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 4,
    "observableKind": "value",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 8,
    "observableKind": "computed",
    "oldValue": 6,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 5,
    "observableKind": "value",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 6,
    "observableKind": "value",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 12,
    "observableKind": "computed",
    "oldValue": 8,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      7,
    ],
    "name": "myTestAction",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 7,
    "observableKind": "value",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 14,
    "observableKind": "computed",
    "oldValue": 12,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/action.js
================================================
import * as mobx from "../../../src/mobx"
import * as utils from "../utils/test-utils"

test("action should wrap in transaction", () => {
    const values = []

    const observable = mobx.observable.box(0)
    mobx.autorun(() => values.push(observable.get()))

    const increment = mobx.action("increment", amount => {
        observable.set(observable.get() + amount * 2)
        observable.set(observable.get() - amount) // oops
    })

    expect(mobx.isAction(increment)).toBe(true)
    expect(mobx.isAction(function () {})).toBe(false)

    increment(7)

    expect(values).toEqual([0, 7])
})

test("action modifications should be picked up 1", () => {
    const a = mobx.observable.box(1)
    let i = 3
    let b = 0

    mobx.autorun(() => {
        b = a.get() * 2
    })

    expect(b).toBe(2)

    const action = mobx.action(() => {
        a.set(++i)
    })

    action()
    expect(b).toBe(8)

    action()
    expect(b).toBe(10)
})

test("action modifications should be picked up 1", () => {
    const a = mobx.observable.box(1)
    let b = 0

    mobx.autorun(() => {
        b = a.get() * 2
    })

    expect(b).toBe(2)

    const action = mobx.action(() => {
        a.set(a.get() + 1) // ha, no loop!
    })

    action()
    expect(b).toBe(4)

    action()
    expect(b).toBe(6)
})

test("action modifications should be picked up 3", () => {
    const a = mobx.observable.box(1)
    let b = 0

    const doubler = mobx.computed(() => a.get() * 2)

    mobx.observe(
        doubler,
        () => {
            b = doubler.get()
        },
        true
    )

    expect(b).toBe(2)

    const action = mobx.action(() => {
        a.set(a.get() + 1) // ha, no loop!
    })

    action()
    expect(b).toBe(4)

    action()
    expect(b).toBe(6)
})

test("test action should be untracked", () => {
    const a = mobx.observable.box(3)
    const b = mobx.observable.box(4)
    let latest = 0
    let runs = 0

    const action = mobx.action(baseValue => {
        b.set(baseValue * 2)
        latest = b.get() // without action this would trigger loop
    })

    const d = mobx.autorun(() => {
        runs++
        const current = a.get()
        action(current)
    })

    expect(b.get()).toBe(6)
    expect(latest).toBe(6)

    a.set(7)
    expect(b.get()).toBe(14)
    expect(latest).toBe(14)

    a.set(8)
    expect(b.get()).toBe(16)
    expect(latest).toBe(16)

    b.set(7) // should have no effect
    expect(a.get()).toBe(8)
    expect(b.get()).toBe(7)
    expect(latest).toBe(16) // effect not triggered

    a.set(3)
    expect(b.get()).toBe(6)
    expect(latest).toBe(6)

    expect(runs).toBe(4)

    d()
})

test("should be possible to create autorun in action", () => {
    const a = mobx.observable.box(1)
    const values = []

    const adder = mobx.action(inc => {
        return mobx.autorun(() => {
            values.push(a.get() + inc)
        })
    })

    const d1 = adder(2)
    a.set(3)
    const d2 = adder(17)
    a.set(24)
    d1()
    a.set(11)
    d2()
    a.set(100)

    expect(values).toEqual([3, 5, 20, 26, 41, 28]) // n.b. order could swap as autorun creation order doesn't guarantee stuff
})

test("should be possible to change unobserved state in an action called from computed", () => {
    const a = mobx.observable.box(2)

    const testAction = mobx.action(() => {
        a.set(3)
    })

    const c = mobx.computed(() => {
        testAction()
    })

    expect.assertions(1)
    mobx.autorun(() => {
        expect(() => {
            c.get()
        }).not.toThrow(/bla/)
    })

    mobx._resetGlobalState()
})

test("should be possible to change observed state in an action called from computed", () => {
    const a = mobx.observable.box(2)
    const d = mobx.autorun(() => {
        a.get()
    })

    const testAction = mobx.action(() => {
        a.set(5) // this is fine
        expect(a.get()).toBe(5)
    })

    const c = mobx.computed(() => {
        expect(
            utils.grabConsole(() => {
                a.set(4)
            })
        ).toMatchInlineSnapshot(
            `"<STDOUT> [MobX] Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ObservableValue@19"`
        )
        expect(a.get()).toBe(4)
        testAction()
        return a.get()
    })

    expect(c.get()).toBe(5)

    mobx._resetGlobalState()
    d()
})

test("should be possible to change observed state in an action called from computed", () => {
    const a = mobx.observable.box(2)
    const d = mobx.autorun(() => {
        a.get()
    })

    const testAction = mobx.action(() => {
        a.set(3)
    })

    const c = mobx.computed(() => {
        testAction()
        return a.get()
    })

    expect(
        utils.grabConsole(() => {
            c.get()
        })
    ).toBe("")

    mobx._resetGlobalState()
    d()
})

test("action in autorun should be untracked", () => {
    const a = mobx.observable.box(2)
    const b = mobx.observable.box(3)

    const data = []
    const multiplier = mobx.action(val => val * b.get())

    const d = mobx.autorun(() => {
        data.push(multiplier(a.get()))
    })

    a.set(3)
    b.set(4)
    a.set(5)

    d()

    a.set(6)

    expect(data).toEqual([6, 9, 20])
})

test("action should not be converted to computed when using (extend)observable", () => {
    const a = mobx.observable({
        a: 1,
        b: mobx.action(function () {
            this.a++
        })
    })

    expect(mobx.isAction(a.b)).toBe(true)
    a.b()
    expect(a.a).toBe(2)

    mobx.extendObservable(a, {
        c: mobx.action(function () {
            this.a *= 3
        })
    })

    expect(mobx.isAction(a.c)).toBe(true)
    a.c()
    expect(a.a).toBe(6)
})

test("#286 exceptions in actions should not affect global state", () => {
    let autorunTimes = 0
    function Todos() {
        mobx.extendObservable(this, {
            count: 0,
            add: mobx.action(function () {
                this.count++
                if (this.count === 2) {
                    throw new Error("An Action Error!")
                }
            })
        })
    }
    const todo = new Todos()
    mobx.autorun(() => {
        autorunTimes++
        return todo.count
    })
    try {
        todo.add()
        expect(autorunTimes).toBe(2)
        todo.add()
    } catch (e) {
        expect(autorunTimes).toBe(3)
        todo.add()
        expect(autorunTimes).toBe(4)
    }
})

test("runInAction", () => {
    mobx.configure({ enforceActions: "observed" })
    const values = []
    const events = []
    const spyDisposer = mobx.spy(ev => {
        if (ev.type === "action")
            events.push({
                name: ev.name,
                arguments: ev.arguments
            })
    })

    const observable = mobx.observable.box(0)
    const d = mobx.autorun(() => values.push(observable.get()))

    let res = mobx.runInAction(() => {
        observable.set(observable.get() + 6 * 2)
        observable.set(observable.get() - 3) // oops
        return 2
    })

    expect(res).toBe(2)
    expect(values).toEqual([0, 9])

    res = mobx.runInAction(() => {
        observable.set(observable.get() + 5 * 2)
        observable.set(observable.get() - 4) // oops
        return 3
    })

    expect(res).toBe(3)
    expect(values).toEqual([0, 9, 15])
    expect(events).toEqual([
        { arguments: [], name: "<unnamed action>" },
        { arguments: [], name: "<unnamed action>" }
    ])

    mobx.configure({ enforceActions: "never" })
    spyDisposer()

    d()
})

test("action in autorun does not keep / make computed values alive", () => {
    let calls = 0
    const myComputed = mobx.computed(() => calls++)
    const callComputedTwice = () => {
        myComputed.get()
        myComputed.get()
    }

    const runWithMemoizing = fun => {
        mobx.autorun(fun)()
    }

    callComputedTwice()
    expect(calls).toBe(2)

    runWithMemoizing(callComputedTwice)
    expect(calls).toBe(3)

    callComputedTwice()
    expect(calls).toBe(5)

    runWithMemoizing(function () {
        mobx.runInAction(callComputedTwice)
    })
    expect(calls).toBe(6)

    callComputedTwice()
    expect(calls).toBe(8)
})

test("computed values and actions", () => {
    let calls = 0

    const number = mobx.observable.box(1)
    const squared = mobx.computed(() => {
        calls++
        return number.get() * number.get()
    })
    const changeNumber10Times = mobx.action(() => {
        squared.get()
        squared.get()
        for (let i = 0; i < 10; i++) number.set(number.get() + 1)
    })

    changeNumber10Times()
    expect(calls).toBe(1)

    mobx.autorun(() => {
        changeNumber10Times()
        expect(calls).toBe(2)
    })()
    expect(calls).toBe(2)

    changeNumber10Times()
    expect(calls).toBe(3)
})

test("extendObservable respects action decorators", () => {
    const x = mobx.observable(
        {
            a1() {
                return this
            },
            a2() {
                return this
            },
            a3() {
                return this
            }
        },
        {
            a1: mobx.action,
            a2: mobx.action.bound,
            a3: false
        }
    )
    expect(mobx.isAction(x.a1)).toBe(true)
    expect(mobx.isAction(x.a2)).toBe(true)
    expect(mobx.isAction(x.a3)).toBe(false)

    // const global = (function() {
    //     return this
    // })()

    const { a1, a2, a3 } = x
    expect(a1.call(x)).toBe(x)
    // expect(a1()).toBe(global)
    expect(a2.call(x)).toBeTruthy() // it is not this! proxies :) see test in proxies.js
    expect(a2()).toBeTruthy()
    expect(a3.call(x)).toBe(x)
    // expect(a3()).toBe(global)
})

test("expect warning for invalid decorator", () => {
    expect(() => {
        mobx.observable({ x: 1 }, { x: undefined })
    }).toThrow(/Invalid annotation/)
})

test("bound actions bind", () => {
    let called = 0
    const x = mobx.observable(
        {
            y: 0,
            z: function (v) {
                this.y += v
                this.y += v
            },
            get yValue() {
                called++
                return this.y
            }
        },
        {
            z: mobx.action.bound
        }
    )

    const d = mobx.autorun(() => {
        x.yValue
    })
    const events = []
    const d2 = mobx.spy(e => events.push(e))

    const runner = x.z
    runner(3)
    expect(x.yValue).toBe(6)
    expect(called).toBe(2)

    expect(events.filter(e => e.type === "action").map(e => e.name)).toEqual(["z"])
    expect(Object.keys(x)).toEqual(["y"])

    d()
    d2()
})

test("Fix #1367", () => {
    const x = mobx.extendObservable(
        {},
        {
            method() {}
        },
        {
            method: mobx.action
        }
    )
    expect(mobx.isAction(x.method)).toBe(true)
})

test("error logging, #1836 - 1", () => {
    const messages = utils.supressConsole(() => {
        try {
            const a = mobx.observable.box(3)
            mobx.autorun(() => {
                if (a.get() === 4) throw new Error("Reaction error")
            })

            mobx.action(() => {
                a.set(4)
                throw new Error("Action error")
            })()
        } catch (e) {
            expect(e.toString()).toEqual("Error: Action error")
            console.error(e)
        }
    })

    expect(messages).toMatchSnapshot()
})

test("error logging, #1836 - 2", () => {
    const messages = utils.supressConsole(() => {
        try {
            const a = mobx.observable.box(3)
            mobx.autorun(() => {
                if (a.get() === 4) throw new Error("Reaction error")
            })

            mobx.action(() => {
                a.set(4)
            })()
        } catch (e) {
            expect(e.toString()).toEqual("Error: Action error")
            console.error(e)
        }
    })

    expect(messages).toMatchSnapshot()
})

test("out of order startAction / endAction", () => {
    const a1 = mobx._startAction("a1")
    const a2 = mobx._startAction("a2")

    expect(() => mobx._endAction(a1)).toThrow("invalid action stack")

    mobx._endAction(a2)

    // double finishing
    expect(() => mobx._endAction(a2)).toThrow("invalid action stack")

    mobx._endAction(a1)
})

test("given actionName, the action function name should be defined as the actionName", () => {
    const a1 = mobx.action("testAction", () => {})
    expect(a1.name).toBe("testAction")
})

test("given anonymous action, the action name should be <unnamed action>", () => {
    const a1 = mobx.action(() => {})
    expect(a1.name).toBe("<unnamed action>")
})

test("given function declaration, the action name should be as the function name", () => {
    const a1 = mobx.action(function testAction() {})
    expect(a1.name).toBe("testAction")
})

test("auto action can be used in a derivation and is tracked", () => {
    const a = mobx.observable(1)
    const events = []

    const double = mobx._autoAction(() => {
        return a.get() * 2
    })

    const d = mobx.autorun(() => {
        events.push(double())
    })

    a.set(2)
    expect(events).toEqual([2, 4])
    d()
})

test("auto action can be used to update and is batched", () => {
    const a = mobx.observable(1)
    const events = []

    const d = mobx.autorun(() => {
        events.push(a.get() * 2)
    })

    mobx._autoAction(() => {
        a.set(2)
        a.set(3)
    })()

    expect(events).toEqual([2, 6]) // No 4!
    d()
})

test("auto action should not update state from inside a derivation", async () => {
    const a = mobx.observable(1)

    const d = mobx.autorun(() => a.get()) // observe

    const double = mobx._autoAction(() => {
        a.set(a.get() * 2)
    })

    await mobx.when(() => {
        expect(
            utils.grabConsole(() => {
                double()
            })
        ).toMatchInlineSnapshot(
            `"<STDOUT> [MobX] Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ObservableValue@51"`
        )
        return a.get() === 2
    })
    d()
})

test("auto action should not update state from inside a derivation", async () => {
    const a = mobx.observable(1)

    const d = mobx.autorun(() => a.get()) // observe

    const double = mobx._autoAction(() => {
        a.set(a.get() * 2)
    })

    await mobx.when(() => {
        expect(
            utils.grabConsole(() => {
                mobx.runInAction(() => {
                    // extra nesting, just in case
                    mobx._autoAction(() => {
                        double()
                    })()
                })
            })
        ).toBe("")
        return a.get() === 2
    })
    d()
})

test("action forwards toString of underlying function", async () => {
    const fn = () => {
        /* not actually doing anything */
    }
    fn.a = 42
    fn.toString = function () {
        return `toString referencing this, a=${this.a}`
    }

    const act = mobx.action(fn)

    expect(fn.toString()).toBe("toString referencing this, a=42")
    expect(act.toString()).toBe("toString referencing this, a=42")
})



================================================
FILE: packages/mobx/__tests__/v5/base/api.js
================================================
const mobx = require("../../../src/mobx.ts")

test("correct api should be exposed", function () {
    expect(
        Object.keys(mobx)
            .filter(key => mobx[key] !== undefined)
            .sort()
    ).toEqual(
        [
            "$mobx", // adminstration symbol
            "action",
            "_allowStateChanges",
            "_allowStateChangesInsideComputed",
            "_allowStateReadsEnd",
            "_allowStateReadsStart",
            "_autoAction",
            "autorun",
            "comparer",
            "computed",
            "configure",
            "createAtom",
            "defineProperty",
            "extendObservable",
            "flow",
            "isFlow",
            "flowResult",
            "FlowCancellationError",
            "isFlowCancellationError",
            "get",
            "_getAdministration",
            "getAtom",
            "getDebugName",
            "getDependencyTree",
            "has",
            "_getGlobalState",
            "getObserverTree",
            "intercept",
            "_interceptReads",
            "isAction",
            "isBoxedObservable",
            "isComputed",
            "isComputedProp",
            "_isComputingDerivation",
            "isObservable",
            "isObservableArray",
            "isObservableMap",
            "isObservableSet",
            "isObservableObject",
            "isObservableProp",
            "keys",
            "makeAutoObservable",
            "makeObservable",
            "ObservableMap",
            "ObservableSet",
            "observable",
            "observe",
            "onReactionError",
            "onBecomeObserved",
            "onBecomeUnobserved",
            "ownKeys",
            "Reaction",
            "reaction",
            "remove",
            "_resetGlobalState",
            "runInAction",
            "set",
            "spy",
            "toJS",
            "trace",
            "transaction",
            "untracked",
            "values",
            "entries",
            "when",
            "_startAction",
            "_endAction",
            "override"
        ].sort()
    )
})

test("mobx has no dependencies", () => {
    const pkg = require("../../../package.json")
    expect(pkg.dependencies).toEqual({})
})



================================================
FILE: packages/mobx/__tests__/v5/base/array.js
================================================
"use strict"

const mobx = require("../../../src/mobx.ts")
const { observable, when, _getAdministration, reaction, computed, makeObservable, autorun } = mobx
const iterall = require("iterall")

let consoleWarnSpy
afterEach(() => {
    consoleWarnSpy?.mockRestore()
})

test("test1", function () {
    const a = observable.array([])
    expect(a.length).toBe(0)
    expect(Object.keys(a)).toEqual([])
    expect(a.slice()).toEqual([])

    a.push(1)
    expect(a.length).toBe(1)
    expect(a.slice()).toEqual([1])

    a[1] = 2
    expect(a.length).toBe(2)
    expect(a.slice()).toEqual([1, 2])

    const sum = mobx.computed(function () {
        return (
            -1 +
            a.reduce(function (a, b) {
                return a + b
            }, 1)
        )
    })

    expect(sum.get()).toBe(3)

    a[1] = 3
    expect(a.length).toBe(2)
    expect(a.slice()).toEqual([1, 3])
    expect(sum.get()).toBe(4)

    a.splice(1, 1, 4, 5)
    expect(a.length).toBe(3)
    expect(a.slice()).toEqual([1, 4, 5])
    expect(sum.get()).toBe(10)

    a.replace([2, 4])
    expect(sum.get()).toBe(6)

    a.splice(1, 1)
    expect(sum.get()).toBe(2)
    expect(a.slice()).toEqual([2])

    a.spliceWithArray(0, 0, [4, 3])
    expect(sum.get()).toBe(9)
    expect(a.slice()).toEqual([4, 3, 2])

    a.clear()
    expect(sum.get()).toBe(0)
    expect(a.slice()).toEqual([])

    a.length = 4
    expect(isNaN(sum.get())).toBe(true)
    expect(a.length).toEqual(4)

    expect(a.slice()).toEqual([undefined, undefined, undefined, undefined])

    a.replace([1, 2, 2, 4])
    expect(sum.get()).toBe(9)
    a.length = 4
    expect(sum.get()).toBe(9)

    a.length = 2
    expect(sum.get()).toBe(3)
    expect(a.slice()).toEqual([1, 2])

    expect(a.reverse()).toEqual([2, 1])
    expect(a).toEqual([2, 1])
    expect(a.slice()).toEqual([2, 1])

    a.unshift(3)
    expect(a.sort()).toEqual([1, 2, 3])
    expect(a).toEqual([1, 2, 3])
    expect(a.slice()).toEqual([1, 2, 3])

    expect(JSON.stringify(a)).toBe("[1,2,3]")

    expect(a[1]).toBe(2)
    a[2] = 4
    expect(a[2]).toBe(4)

    expect(Object.keys(a)).toEqual(["0", "1", "2"])
})

test("cannot reverse or sort an array in a derivation", () => {
    const ar = observable([3, 2, 1])
    reaction(
        () => {
            expect(() => {
                ar.sort()
            }).toThrowErrorMatchingInlineSnapshot(
                `"[MobX] [mobx] \`observableArray.sort()\` mutates the array in-place, which is not allowed inside a derivation. Use \`array.slice().sort()\` instead"`
            )
        },
        () => {}
    )()
    reaction(
        () => {
            expect(() => {
                ar.reverse()
            }).toThrowErrorMatchingInlineSnapshot(
                `"[MobX] [mobx] \`observableArray.reverse()\` mutates the array in-place, which is not allowed inside a derivation. Use \`array.slice().reverse()\` instead"`
            )
        },
        () => {}
    )()

    const c = computed(() => {
        ar.sort()
    })
    autorun(() => {
        expect(() => {
            c.get()
        }).toThrowErrorMatchingInlineSnapshot(
            `"[MobX] [mobx] \`observableArray.sort()\` mutates the array in-place, which is not allowed inside a derivation. Use \`array.slice().sort()\` instead"`
        )
    })()

    expect(ar).toEqual([3, 2, 1])
})

test("array should support iterall / iterable ", () => {
    const a = observable([1, 2, 3])

    expect(iterall.isIterable(a)).toBe(true)

    const values = []
    iterall.forEach(a, v => values.push(v))

    expect(values).toEqual([1, 2, 3])

    let iter = iterall.getIterator(a)
    expect(iter.next()).toEqual({ value: 1, done: false })
    expect(iter.next()).toEqual({ value: 2, done: false })
    expect(iter.next()).toEqual({ value: 3, done: false })
    expect(iter.next()).toEqual({ value: undefined, done: true })

    a.replace([])
    iter = iterall.getIterator(a)
    expect(iter.next()).toEqual({ value: undefined, done: true })
})

test("find(findIndex) and remove", function () {
    const a = mobx.observable([10, 20, 20])
    let idx = -1
    function predicate(item, index) {
        if (item === 20) {
            idx = index
            return true
        }
        return false
    }
    ;[].findIndex
    expect(a.find(predicate)).toBe(20)
    expect(a.findIndex(predicate)).toBe(1)
    expect(a.find(predicate)).toBe(20)

    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(20)
    expect(idx).toBe(1)
    expect(a.findIndex(predicate)).toBe(1)
    idx = -1
    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(undefined)
    expect(idx).toBe(-1)
    expect(a.findIndex(predicate)).toBe(-1)

    expect(a.remove(20)).toBe(false)
})

test("findLast(findLastIndex) and remove", function () {
    const a = mobx.observable([10, 20, 20])
    let idx = -1
    function predicate(item, index) {
        if (item === 20) {
            idx = index
            return true
        }
        return false
    }
    ;[].findLastIndex;
    expect(a.findLast(predicate)).toBe(20)
    expect(a.findLastIndex(predicate)).toBe(2)
    expect(a.findLast(predicate)).toBe(20)

    expect(a.remove(20)).toBe(true)
    expect(a.find(predicate)).toBe(20)
    expect(idx).toBe(1)
    expect(a.findIndex(predicate)).toBe(1)
    idx = -1
    expect(a.remove(20)).toBe(true)
    expect(a.findLast(predicate)).toBe(undefined)
    expect(idx).toBe(-1)
    expect(a.findLastIndex(predicate)).toBe(-1)

    expect(a.remove(20)).toBe(false)
})

test("concat should automatically slice observable arrays, #260", () => {
    const a1 = mobx.observable([1, 2])
    const a2 = mobx.observable([3, 4])
    expect(a1.concat(a2)).toEqual([1, 2, 3, 4])
})

test("observe", function () {
    const ar = mobx.observable([1, 4])
    const buf = []
    const disposer = mobx.observe(
        ar,
        function (changes) {
            buf.push(changes)
        },
        true
    )

    ar[1] = 3 // 1,3
    ar[2] = 0 // 1, 3, 0
    ar.shift() // 3, 0
    ar.push(1, 2) // 3, 0, 1, 2
    ar.splice(1, 2, 3, 4) // 3, 3, 4, 2
    expect(ar.slice()).toEqual([3, 3, 4, 2])
    ar.splice(6)
    ar.splice(6, 2)
    ar.replace(["a"])
    ar.pop()
    ar.pop() // does not fire anything

    // check the object param
    buf.forEach(function (change) {
        expect(change.object).toBe(ar)
        delete change.object
        expect(change.observableKind).toBe("array")
        delete change.observableKind
        delete change.debugObjectName
    })

    const result = [
        { type: "splice", index: 0, addedCount: 2, removed: [], added: [1, 4], removedCount: 0 },
        { type: "update", index: 1, oldValue: 4, newValue: 3 },
        { type: "splice", index: 2, addedCount: 1, removed: [], added: [0], removedCount: 0 },
        { type: "splice", index: 0, addedCount: 0, removed: [1], added: [], removedCount: 1 },
        { type: "splice", index: 2, addedCount: 2, removed: [], added: [1, 2], removedCount: 0 },
        {
            type: "splice",
            index: 1,
            addedCount: 2,
            removed: [0, 1],
            added: [3, 4],
            removedCount: 2
        },
        {
            type: "splice",
            index: 0,
            addedCount: 1,
            removed: [3, 3, 4, 2],
            added: ["a"],
            removedCount: 4
        },
        { type: "splice", index: 0, addedCount: 0, removed: ["a"], added: [], removedCount: 1 }
    ]

    expect(buf).toEqual(result)

    disposer()
    ar[0] = 5
    expect(buf).toEqual(result)
})

test("array modification1", function () {
    const a = mobx.observable([1, 2, 3])
    const r = a.splice(-10, 5, 4, 5, 6)
    expect(a.slice()).toEqual([4, 5, 6])
    expect(r).toEqual([1, 2, 3])
})

test("serialize", function () {
    let a = [1, 2, 3]
    const m = mobx.observable(a)

    expect(JSON.stringify(m)).toEqual(JSON.stringify(a))

    expect(a).toEqual(m.slice())

    a = [4]
    m.replace(a)
    expect(JSON.stringify(m)).toEqual(JSON.stringify(a))
    expect(a).toEqual(m.toJSON())
})

test("array modification functions", function () {
    const ars = [[], [1, 2, 3]]
    const funcs = ["push", "pop", "shift", "unshift"]
    funcs.forEach(function (f) {
        ars.forEach(function (ar) {
            const a = ar.slice()
            const b = mobx.observable(a)
            const res1 = a[f](4)
            const res2 = b[f](4)
            expect(res1).toEqual(res2)
            expect(a).toEqual(b.slice())
        })
    })
})

test("array modifications", function () {
    const a2 = mobx.observable([])
    const inputs = [undefined, -10, -4, -3, -1, 0, 1, 3, 4, 10]
    const arrays = [
        [],
        [1],
        [1, 2, 3, 4],
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        [1, undefined],
        [undefined]
    ]
    for (let i = 0; i < inputs.length; i++)
        for (let j = 0; j < inputs.length; j++)
            for (let k = 0; k < arrays.length; k++)
                for (let l = 0; l < arrays.length; l++) {
                    ;[
                        "array mod: [",
                        arrays[k].toString(),
                        "] i: ",
                        inputs[i],
                        " d: ",
                        inputs[j],
                        " [",
                        arrays[l].toString(),
                        "]"
                    ].join(" ")
                    const a1 = arrays[k].slice()
                    a2.replace(a1)
                    const res1 = a1.splice.apply(a1, [inputs[i], inputs[j]].concat(arrays[l]))
                    const res2 = a2.splice.apply(a2, [inputs[i], inputs[j]].concat(arrays[l]))
                    expect(a1.slice()).toEqual(a2.slice())
                    expect(res1).toEqual(res2)
                    expect(a1.length).toBe(a2.length)
                }
})

test("is array", function () {
    const x = mobx.observable([])
    expect(x instanceof Array).toBe(true)

    // would be cool if this would return true...
    expect(Array.isArray(x)).toBe(true)
})

test("stringifies same as ecma array", function () {
    const x = mobx.observable([])
    expect(x instanceof Array).toBe(true)

    // would be cool if these two would return true...
    expect(x.toString()).toBe("")
    expect(x.toLocaleString()).toBe("")
    x.push(1, 2)
    expect(x.toString()).toBe("1,2")
    expect(x.toLocaleString()).toBe("1,2")
})

test("observes when stringified", function () {
    const x = mobx.observable([])
    let c = 0
    mobx.autorun(function () {
        x.toString()
        c++
    })
    x.push(1)
    expect(c).toBe(2)
})

test("observes when stringified to locale", function () {
    const x = mobx.observable([])
    let c = 0
    mobx.autorun(function () {
        x.toLocaleString()
        c++
    })
    x.push(1)
    expect(c).toBe(2)
})

test("react to sort changes", function () {
    const x = mobx.observable([4, 2, 3])
    const sortedX = mobx.computed(function () {
        return x.slice().sort()
    })
    let sorted

    mobx.autorun(function () {
        sorted = sortedX.get()
    })

    expect(x.slice()).toEqual([4, 2, 3])
    expect(sorted).toEqual([2, 3, 4])
    x.push(1)
    expect(x.slice()).toEqual([4, 2, 3, 1])
    expect(sorted).toEqual([1, 2, 3, 4])
    x.shift()
    expect(x.slice()).toEqual([2, 3, 1])
    expect(sorted).toEqual([1, 2, 3])
})

test("autoextend buffer length", function () {
    const ar = observable(new Array(1000))
    let changesCount = 0
    mobx.observe(ar, () => ++changesCount)

    ar[ar.length] = 0
    ar.push(0)

    expect(changesCount).toBe(2)
})

test("array exposes correct keys", () => {
    const keys = []
    const ar = observable([1, 2])
    for (const key in ar) keys.push(key)

    expect(keys).toEqual(["0", "1"])
})

test("replace can handle large arrays", () => {
    const a = mobx.observable([])
    const b = []
    b.length = 1000 * 1000
    expect(() => {
        a.replace(b)
    }).not.toThrow()

    expect(() => {
        a.spliceWithArray(0, 0, b)
    }).not.toThrow()
})

test("can iterate arrays", () => {
    const x = mobx.observable([])
    const y = []
    const d = mobx.reaction(
        () => Array.from(x),
        items => y.push(items),
        { fireImmediately: true }
    )

    x.push("a")
    x.push("b")
    expect(y).toEqual([[], ["a"], ["a", "b"]])
    d()
})

test("array is concat spreadable, #1395", () => {
    const x = mobx.observable([1, 2, 3, 4])
    const y = [5].concat(x)
    expect(y.length).toBe(5)
    expect(y).toEqual([5, 1, 2, 3, 4])
})

test("array is spreadable, #1395", () => {
    const x = mobx.observable([1, 2, 3, 4])
    expect([5, ...x]).toEqual([5, 1, 2, 3, 4])

    const y = mobx.observable([])
    expect([5, ...y]).toEqual([5])
})

test("array supports toStringTag, #1490", () => {
    // N.B. on old environments this requires polyfils for these symbols *and* Object.prototype.toString.
    // core-js provides both
    const a = mobx.observable([])
    expect(Object.prototype.toString.call(a)).toBe("[object Array]")
})

test("slice works", () => {
    const a = mobx.observable([1, 2, 3])
    expect(a.slice(0, 2)).toEqual([1, 2])
})

test("slice is reactive", () => {
    const a = mobx.observable([1, 2, 3])
    let ok = false
    when(
        () => a.slice().length === 4,
        () => (ok = true)
    )
    expect(ok).toBe(false)
    a.push(1)
    expect(ok).toBe(true)
})

test("toString", () => {
    expect(mobx.observable([1, 2]).toString()).toEqual([1, 2].toString())
    expect(mobx.observable([1, 2]).toLocaleString()).toEqual([1, 2].toLocaleString())
})

test("can define properties on arrays", () => {
    const ar = observable.array([1, 2])
    Object.defineProperty(ar, "toString", {
        enumerable: false,
        configurable: true,
        value: function () {
            return "hoi"
        }
    })

    expect(ar.toString()).toBe("hoi")
    expect("" + ar).toBe("hoi")
})

test("concats correctly #1667", () => {
    const x = observable({ data: [] })

    function generate(count) {
        const d = []
        for (let i = 0; i < count; i++) d.push({})
        return d
    }

    x.data = generate(10000)
    const first = x.data[0]
    expect(Array.isArray(x.data)).toBe(true)

    x.data = x.data.concat(generate(1000))
    expect(Array.isArray(x.data)).toBe(true)
    expect(x.data[0]).toBe(first)
    expect(x.data.length).toBe(11000)
})

test("dehances last value on shift/pop", () => {
    const x1 = observable([3, 5])
    _getAdministration(x1).dehancer = value => {
        return value * 2
    }
    expect(x1.shift()).toBe(6)
    expect(x1.shift()).toBe(10)

    const x2 = observable([3, 5])
    _getAdministration(x2).dehancer = value => {
        return value * 2
    }
    expect(x2.pop()).toBe(10)
    expect(x2.pop()).toBe(6)
})

test("#2044 symbol key on array", () => {
    const x = observable([1, 2])
    const s = Symbol("test")
    x[s] = 3
    expect(x[s]).toBe(3)

    let reacted = false
    const d = reaction(
        () => x[s],
        () => {
            reacted = true
        }
    )

    x[s] = 4
    expect(x[s]).toBe(4)

    // although x[s] can be stored, it won't be reactive!
    expect(reacted).toBe(false)
    d()
})

test("#2044 non-symbol key on array", () => {
    const x = observable([1, 2])
    const s = "test"
    x[s] = 3
    expect(x[s]).toBe(3)

    let reacted = false
    const d = reaction(
        () => x[s],
        () => {
            reacted = true
        }
    )

    x[s] = 4
    expect(x[s]).toBe(4)

    // although x[s] can be stored, it won't be reactive!
    expect(reacted).toBe(false)
    d()
})

describe("extended array prototype", () => {
    const extensionKey = "__extension"

    // A single setup/teardown for all tests because we're pretending to do a
    // singular global (dirty) change to the "environment".
    beforeAll(() => {
        Array.prototype[extensionKey] = () => {}
    })
    afterAll(() => {
        delete Array.prototype[extensionKey]
    })

    test("creating an observable should work", () => {
        mobx.observable({ b: "b" })
    })

    test("extending an observable should work", () => {
        const a = { b: "b" }
        mobx.extendObservable(a, {})
    })
})

test("reproduce #2021", () => {
    expect.assertions(1)
    try {
        Array.prototype.extension = function () {
            console.log("I'm the extension!", this.length)
        }

        class Test {
            data = null

            constructor() {
                makeObservable(this, {
                    data: observable
                })
            }
        }

        const test = new Test()

        mobx.autorun(() => {
            if (test.data) expect(test.data.someStr).toBe("123")
        })

        test.data = { someStr: "123" }
    } finally {
        delete Array.prototype.extension
    }
})

test("correct array should be passed to callbacks #2326", () => {
    const array = observable([1, 2, 3])

    function callback() {
        const lastArg = arguments[arguments.length - 1]
        expect(lastArg).toBe(array)
    }
    ;[
        "every",
        "filter",
        "find",
        "findIndex",
        "findLast",
        "findLastIndex",
        "flatMap",
        "forEach",
        "map",
        "reduce",
        "reduceRight",
        "some"
    ].forEach(method => {
        if (Array.prototype[method]) array[method](callback)
        else console.warn("SKIPPING: " + method)
    })
})

test("very long arrays can be safely passed to nativeArray.concat #2379", () => {
    const nativeArray = ["a", "b"]
    const longNativeArray = [...Array(10000).keys()] // MAX_SPLICE_SIZE seems to be the threshold
    const longObservableArray = observable(longNativeArray)
    expect(longObservableArray.length).toBe(10000)
    expect(longObservableArray).toEqual(longNativeArray)
    expect(longObservableArray[9000]).toBe(longNativeArray[9000])
    expect(longObservableArray[9999]).toBe(longNativeArray[9999])
    expect(longObservableArray[10000]).toBe(longNativeArray[10000])

    const expectedArray = nativeArray.concat(longNativeArray)
    const actualArray = nativeArray.concat(longObservableArray)

    expect(actualArray).toEqual(expectedArray)

    const anotherArray = [0, 1, 2, 3, 4, 5]
    const observableArray = observable(anotherArray)
    const r1 = anotherArray.splice(2, 2, ...longNativeArray)
    const r2 = observableArray.splice(2, 2, ...longNativeArray)
    expect(r2).toEqual(r1)
    expect(observableArray).toEqual(anotherArray)
})

describe("dehances", () => {
    function supressConsoleWarn(fn) {
        const { warn } = console
        console.warn = () => {}
        const result = fn()
        console.warn = warn
        return result
    }

    const dehancer = thing => {
        // Dehance only objects of a proper type
        if (thing && typeof thing === "object" && thing.hasOwnProperty("value")) {
            return thing.value
        }
        // Support nested arrays
        if (Array.isArray(thing)) {
            // If array has own dehancer it's still applied prior to ours.
            // It doesn't matter how many dehancers we apply,
            // if they ignore unknown types.
            return thing.map(dehancer)
        }
        // Ignore unknown types
        return thing
    }

    let enhanced, dehanced, array

    beforeEach(() => {
        enhanced = [{ value: 1 }, { value: 2 }, { value: 3 }]
        dehanced = enhanced.map(dehancer)
        array = observable(enhanced)
        mobx._getAdministration(array).dehancer = dehancer
    })

    test("slice", () => {
        expect(array.slice()).toEqual(dehanced.slice())
    })

    test("filter", () => {
        const predicate = value => value === 2
        expect(array.filter(predicate)).toEqual(dehanced.filter(predicate))
    })

    test("concat", () => {
        expect(array.concat(4)).toEqual(dehanced.concat(4))
    })

    test("entries", () => {
        expect([...array.entries()]).toEqual([...dehanced.entries()])
    })

    test("every", () => {
        array.every((value, index) => {
            expect(value).toEqual(dehanced[index])
            return true
        })
    })

    test("find", () => {
        const predicate = value => value === 2
        expect(array.find(predicate)).toEqual(dehanced.find(predicate))
    })

    test("forEach", () => {
        array.forEach((value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("includes", () => {
        expect(array.includes(2)).toEqual(dehanced.includes(2))
    })

    test("indexOf", () => {
        expect(array.indexOf(2)).toEqual(dehanced.indexOf(2))
    })

    test("join", () => {
        expect(array.join()).toEqual(dehanced.join())
    })

    test("lastIndexOf", () => {
        expect(array.lastIndexOf(2)).toEqual(dehanced.lastIndexOf(2))
    })

    test("map", () => {
        array.map((value, index) => {
            expect(value).toEqual(dehanced[index])
            return value
        })
    })

    test("pop", () => {
        expect(array.pop()).toEqual(dehanced.pop())
    })

    test("reduce", () => {
        array.reduce((_, value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("reduceRight", () => {
        array.reduceRight((_, value, index) => {
            expect(value).toEqual(dehanced[index])
        })
    })

    test("reverse", () => {
        const reversedArray = supressConsoleWarn(() => array.reverse())
        expect(reversedArray).toEqual(dehanced.reverse())
    })

    test("shift", () => {
        expect(array.shift()).toEqual(dehanced.shift())
    })

    test("some", () => {
        array.some((value, index) => {
            expect(value).toEqual(dehanced[index])
            return false
        })
    })

    test("splice", () => {
        expect(array.splice(1, 2)).toEqual(dehanced.splice(1, 2))
    })

    test("sort", () => {
        const comparator = (a, b) => {
            expect(typeof a).toEqual("number")
            expect(typeof b).toEqual("number")
            return b > a
        }
        const sortedArray = supressConsoleWarn(() => array.sort(comparator))
        expect(sortedArray).toEqual(dehanced.sort(comparator))
    })

    test("values", () => {
        expect([...array.values()]).toEqual([...dehanced.values()])
    })

    test("toReversed", () => {
        expect(array.toReversed()).toEqual(dehanced.toReversed())
    })

    test("toSorted", () => {
        expect(array.toSorted()).toEqual(dehanced.toSorted())
    })

    test("toSorted with args", () => {
        expect(array.toSorted((a, b) => a - b)).toEqual(dehanced.toSorted((a, b) => a - b))
    })

    test("toSpliced", () => {
        expect(array.toSpliced(1, 2)).toEqual(dehanced.toSpliced(1, 2))
    })

    test("with", () => {
        expect(array.with(1, 5)).toEqual(dehanced.with(1, 5))
    })

    test("at", () => {
        expect(array.at(1)).toEqual(dehanced.at(1))
        expect(array.at(-1)).toEqual(dehanced.at(-1))
    })

    test("flat/flatMap", () => {
        const nestedArray = [{ value: 1 }, [{ value: 2 }, [{ value: 3 }]]]
        const dehancedNestedArray = nestedArray.map(dehancer)

        // flat
        array.replace(nestedArray)
        expect(array.flat(Infinity)).toEqual(dehancedNestedArray.flat(Infinity))

        // flatMap
        const flattenedArray = array.flatMap((value, index) => {
            expect(value).toEqual(dehancedNestedArray[index])
            return value
        })
        expect(flattenedArray).toEqual(dehancedNestedArray.flat(1))
    })
})

test("reduce without initial value #2432", () => {
    const array = [1, 2, 3]
    const observableArray = observable(array)

    const arrayReducerArgs = []
    const observableArrayReducerArgs = []

    const arraySum = array.reduce((...args) => {
        arrayReducerArgs.push(args)
        return args[0] + args[1]
    })

    const observableArraySum = observableArray.reduce((...args) => {
        observableArrayReducerArgs.push(args)
        return args[0] + args[1]
    })

    expect(arraySum).toEqual(1 + 2 + 3)
    expect(observableArraySum).toEqual(arraySum)
    expect(arrayReducerArgs).toEqual(observableArrayReducerArgs)
})

test("accessing out of bound indices is supported", () => {
    consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {
        throw new Error(`Unexpected console.warn call`)
    })

    const array = observable([])

    array[1]
    array[2]
    array[1001] = "foo"
    expect(array.length).toBe(1002)
    expect(array[1001]).toBe("foo")
})



================================================
FILE: packages/mobx/__tests__/v5/base/autorun.js
================================================
/**
 * @type {typeof import("./../../../src/v5/mobx")}
 */
const mobx = require("../../../src/mobx.ts")
const utils = require("../../v5/utils/test-utils")

test("autorun passes Reaction as an argument to view function", function () {
    const a = mobx.observable.box(1)
    const values = []

    mobx.autorun(r => {
        expect(typeof r.dispose).toBe("function")
        if (a.get() === "pleaseDispose") r.dispose()
        values.push(a.get())
    })

    a.set(2)
    a.set(2)
    a.set("pleaseDispose")
    a.set(3)
    a.set(4)

    expect(values).toEqual([1, 2, "pleaseDispose"])
})

test("autorun can be disposed on first run", function () {
    const a = mobx.observable.box(1)
    const values = []

    mobx.autorun(r => {
        r.dispose()
        values.push(a.get())
    })

    a.set(2)

    expect(values).toEqual([1])
})

test("autorun can be disposed using AbortSignal", function () {
    const a = mobx.observable.box(1)
    const ac = new AbortController()
    const values = []

    mobx.autorun(() => {
        values.push(a.get())
    }, { signal: ac.signal })

    a.set(2)
    a.set(3)
    ac.abort()
    a.set(4)

    expect(values).toEqual([1, 2, 3])
})

test("autorun should not run first time when passing already aborted AbortSignal", function () {
    const a = mobx.observable.box(1)
    const ac = new AbortController()
    const values = []

    ac.abort()

    mobx.autorun(() => {
        values.push(a.get())
    }, { signal: ac.signal })

    expect(values).toEqual([])
})

test("autorun warns when passed an action", function () {
    const action = mobx.action(() => {})
    expect.assertions(1)
    expect(() => mobx.autorun(action)).toThrowError(/Autorun does not accept actions/)
})

test("autorun batches automatically", function () {
    let runs = 0
    let a1runs = 0
    let a2runs = 0

    const x = mobx.observable({
        a: 1,
        b: 1,
        c: 1,
        get d() {
            runs++
            return this.c + this.b
        }
    })

    const d1 = mobx.autorun(() => {
        a1runs++
        x.d // read
    })

    const d2 = mobx.autorun(() => {
        a2runs++
        x.b = x.a
        x.c = x.a
    })

    expect(a1runs).toBe(1)
    expect(a2runs).toBe(1)
    expect(runs).toBe(1)

    x.a = 17

    expect(a1runs).toBe(2)
    expect(a2runs).toBe(2)
    expect(runs).toBe(2)

    d1()
    d2()
})

test("autorun tracks invalidation of unbound dependencies", function () {
    const a = mobx.observable.box(0)
    const b = mobx.observable.box(0)
    const c = mobx.computed(() => a.get() + b.get())
    const values = []

    mobx.autorun(() => {
        values.push(c.get())
        b.set(100)
    })

    a.set(1)
    expect(values).toEqual([0, 100, 101])
})

test("when effect is an action", function (done) {
    const a = mobx.observable.box(0)

    mobx.configure({ enforceActions: "observed" })
    mobx.when(
        () => a.get() === 1,
        () => {
            a.set(2)

            mobx.configure({ enforceActions: "never" })
            done()
        },
        { timeout: 1 }
    )

    mobx.runInAction(() => {
        a.set(1)
    })
})

describe("autorun opts requiresObservable", () => {
    test("warn when no observable", () => {
        utils.consoleWarn(() => {
            const disposer = mobx.autorun(() => 2, {
                requiresObservable: true
            })

            disposer()
        }, /is created\/updated without reading any observable value/)
    })

    test("Don't warn when observable", () => {
        const obsr = mobx.observable({
            x: 1
        })

        const messages = utils.supressConsole(() => {
            const disposer = mobx.autorun(() => obsr.x, {
                requiresObservable: true
            })

            disposer()
        })

        expect(messages.length).toBe(0)
    })
})



================================================
FILE: packages/mobx/__tests__/v5/base/autorunAsync.js
================================================
/**
 * @type {typeof import("../../../src/v5/mobx")}
 */
const mobx = require("../../../src/mobx.ts")

const utils = require("../../v5/utils/test-utils")

const { $mobx } = mobx

test("autorun 1", function (done) {
    let _fired = 0
    let _result = null
    let _cCalcs = 0
    const to = setTimeout

    function check(fired, cCalcs, result) {
        expect(_fired).toBe(fired)
        expect(_cCalcs).toBe(cCalcs)
        if (fired) expect(_result).toBe(result)
        _fired = 0
        _cCalcs = 0
    }

    const a = mobx.observable.box(2)
    const b = mobx.observable.box(3)
    const c = mobx.computed(function () {
        _cCalcs++
        return a.get() * b.get()
    })
    const d = mobx.observable.box(1)
    const autorun = function () {
        _fired++
        _result = d.get() > 0 ? a.get() * c.get() : d.get()
    }
    let disp = mobx.autorun(autorun, { delay: 20 })

    check(0, 0, null)
    disp()
    to(function () {
        check(0, 0, null)
        disp = mobx.autorun(autorun, { delay: 20 })

        to(function () {
            check(1, 1, 12)
            a.set(4)
            b.set(5)
            a.set(6)
            check(0, 0, null) // a change triggered async rerun, compute will trigger after 20ms of async timeout
            to(function () {
                check(1, 1, 180)
                d.set(2)

                to(function () {
                    check(1, 0, 180)

                    d.set(-2)
                    to(function () {
                        check(1, 0, -2)

                        a.set(7)
                        to(function () {
                            check(0, 0, 0) // change a has no effect

                            a.set(4)
                            b.set(2)
                            d.set(2)

                            to(function () {
                                check(1, 1, 32)

                                disp()
                                a.set(1)
                                b.set(2)
                                d.set(4)
                                to(function () {
                                    check(0, 0, 0)
                                    done()
                                }, 30)
                            }, 30)
                        }, 30)
                    }, 30)
                }, 30)
            }, 30)
        }, 30)
    }, 30)
})

test("autorun should not result in loop", function (done) {
    let i = 0
    const a = mobx.observable({
        x: i
    })

    let autoRunsCalled = 0
    const d = mobx.autorun(
        function () {
            autoRunsCalled++
            a.x = ++i
            setTimeout(function () {
                a.x = ++i
            }, 10)
        },
        { delay: 10, name: "named async" }
    )

    setTimeout(function () {
        expect(autoRunsCalled).toBe(1)
        done()

        expect(d[$mobx].name_).toBe("named async")
        d()
    }, 100)
})

test("autorunAsync passes Reaction as an argument to view function", function (done) {
    const a = mobx.observable.box(1)

    let autoRunsCalled = 0

    mobx.autorun(
        r => {
            expect(typeof r.dispose).toBe("function")
            autoRunsCalled++
            if (a.get() === "pleaseDispose") r.dispose()
        },
        { delay: 10 }
    )

    setTimeout(() => a.set(2), 250)
    setTimeout(() => a.set("pleaseDispose"), 400)
    setTimeout(() => a.set(3), 550)
    setTimeout(() => a.set(4), 700)

    setTimeout(function () {
        expect(autoRunsCalled).toBe(3)
        done()
    }, 1000)
})

test("autorunAsync accepts a scheduling function", function (done) {
    const a = mobx.observable({
        x: 0,
        y: 1
    })

    let autoRunsCalled = 0
    let schedulingsCalled = 0

    mobx.autorun(
        function () {
            autoRunsCalled++
            expect(a.y).toBe(a.x + 1)

            if (a.x < 10) {
                // Queue the two actions separately, if this was autorun it would fail
                setTimeout(function () {
                    a.x = a.x + 1
                }, 0)
                setTimeout(function () {
                    a.y = a.y + 1
                }, 0)
            }
        },
        {
            scheduler: function (fn) {
                schedulingsCalled++
                setTimeout(fn, 0)
            }
        }
    )

    setTimeout(function () {
        expect(autoRunsCalled).toBe(11)
        expect(schedulingsCalled).toBe(11)
        done()
    }, 1000)
})

test("reaction accepts a scheduling function", function (done) {
    const a = mobx.observable({
        x: 0,
        y: 1
    })

    let autoRunsCalled = 0
    let schedulingsCalled = 0
    let exprCalled = 0

    const values = []

    mobx.reaction(
        () => {
            exprCalled++
            return a.x
        },
        () => {
            autoRunsCalled++
            values.push(a.x)
        },
        {
            fireImmediately: true,
            scheduler: function (fn) {
                schedulingsCalled++
                setTimeout(fn, 2)
            }
        }
    )

    a.x++
    a.x++
    a.x++
    setTimeout(() => {
        a.x++
        a.x++
        a.x++
    }, 20)

    setTimeout(function () {
        expect(exprCalled).toBe(3) // start, 2 batches
        expect(autoRunsCalled).toBe(3) // start, 2 batches
        expect(schedulingsCalled).toBe(2) // skipped first time due to fireImmediately
        expect(values).toEqual([0, 3, 6])
        done()
    }, 100)
})

test("autorunAsync warns when passed an action", function () {
    const action = mobx.action(() => {})
    expect.assertions(1)
    expect(() => mobx.autorun(action)).toThrowError(/Autorun does not accept actions/)
})

test("whenWithTimeout should operate normally", done => {
    const a = mobx.observable.box(1)

    mobx.when(
        () => a.get() === 2,
        () => done(),
        {
            timeout: 500,
            onError: () => done.fail("error triggered")
        }
    )

    setTimeout(
        mobx.action(() => a.set(2)),
        200
    )
})

test("whenWithTimeout should timeout", done => {
    const a = mobx.observable.box(1)

    mobx.when(
        () => a.get() === 2,
        () => done.fail("should have timed out"),
        {
            timeout: 500,
            onError: e => {
                expect("" + e).toMatch(/WHEN_TIMEOUT/)
                done()
            }
        }
    )

    setTimeout(
        mobx.action(() => a.set(2)),
        1000
    )
})

test("whenWithTimeout should dispose", done => {
    const a = mobx.observable.box(1)

    const d1 = mobx.when(
        () => a.get() === 2,
        () => done.fail("1 should not finsih"),
        {
            timeout: 100,
            onError: () => done.fail("1 should not timeout")
        }
    )

    const d2 = mobx.when(
        () => a.get() === 2,
        () => t.fail("2 should not finsih"),
        {
            timeout: 200,
            onError: () => done.fail("2 should not timeout")
        }
    )

    d1()
    d2()

    setTimeout(
        mobx.action(() => {
            a.set(2)
            done()
        }),
        150
    )
})

describe("when opts requiresObservable", () => {
    test("warn when no observable", () => {
        utils.consoleWarn(() => {
            const disposer = mobx.when(() => 2, {
                requiresObservable: true
            })

            disposer.cancel()
        }, /is created\/updated without reading any observable value/)
    })

    test("Don't warn when observable", () => {
        const obsr = mobx.observable({
            x: 1
        })

        const messages = utils.supressConsole(() => {
            const disposer = mobx.when(() => obsr.x, {
                requiresObservable: true
            })

            disposer.cancel()
        })

        expect(messages.length).toBe(0)
    })
})



================================================
FILE: packages/mobx/__tests__/v5/base/babel-decorators.js
================================================
import {
    observable,
    computed,
    transaction,
    autorun,
    extendObservable,
    action,
    isObservableObject,
    observe,
    isObservable,
    isObservableProp,
    isComputedProp,
    spy,
    isAction,
    configure,
    makeObservable
} from "../../../src/mobx"
import * as mobx from "../../../src/mobx"

test("babel", function () {
    class Box {
        @observable uninitialized
        @observable height = 20
        @observable sizes = [2]
        @observable
        someFunc = function () {
            return 2
        }

        constructor() {
            makeObservable(this)
        }

        @computed
        get width() {
            return this.height * this.sizes.length * this.someFunc() * (this.uninitialized ? 2 : 1)
        }
        @action
        addSize() {
            this.sizes.push(3)
            this.sizes.push(4)
        }
    }

    const box = new Box()
    const ar = []
    autorun(() => {
        ar.push(box.width)
    })

    let s = ar.slice()
    expect(s).toEqual([40])
    box.height = 10
    s = ar.slice()
    expect(s).toEqual([40, 20])
    box.sizes.push(3, 4)
    s = ar.slice()
    expect(s).toEqual([40, 20, 60])
    box.someFunc = () => 7
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210, 420, 700])
})

test("should not be possible to use @action with getters", () => {
    class A {
        constructor() {
            makeObservable(this)
        }

        @action
        get Test() {}
    }
    expect(() => {
        new A()
    }).toThrow(/can only be used on properties with a function value/)

    mobx._resetGlobalState()
})

test("babel: parameterized computed decorator", () => {
    class TestClass {
        @observable x = 3
        @observable y = 3

        constructor() {
            makeObservable(this)
        }

        @computed.struct
        get boxedSum() {
            return { sum: Math.round(this.x) + Math.round(this.y) }
        }
    }

    const t1 = new TestClass()
    const changes = []
    const d = autorun(() => changes.push(t1.boxedSum))

    t1.y = 4 // change
    expect(changes.length).toBe(2)
    t1.y = 4.2 // no change
    expect(changes.length).toBe(2)
    transaction(() => {
        t1.y = 3
        t1.x = 4
    }) // no change
    expect(changes.length).toBe(2)
    t1.x = 6 // change
    expect(changes.length).toBe(3)
    d()

    expect(changes).toEqual([{ sum: 6 }, { sum: 7 }, { sum: 9 }])
})

test("computed value should be the same around changing which was considered equivalent", () => {
    class TestClass {
        @observable c = null
        defaultCollection = []

        constructor() {
            makeObservable(this)
        }

        @computed.struct
        get collection() {
            return this.c || this.defaultCollection
        }
    }

    const t1 = new TestClass()

    const d = autorun(() => t1.collection)

    const oldCollection = t1.collection
    t1.c = []
    const newCollection = t1.collection

    expect(oldCollection).toBe(newCollection)

    d()
})

class Order {
    @observable price = 3
    @observable amount = 2
    @observable orders = []
    @observable aFunction = function () {}

    constructor() {
        makeObservable(this)
    }

    @computed
    get total() {
        return this.amount * this.price * (1 + this.orders.length)
    }
}

test("issue 191 - shared initializers (babel)", function () {
    class Test {
        @observable obj = { a: 1 }
        @observable array = [2]

        constructor() {
            makeObservable(this)
        }
    }

    const t1 = new Test()
    t1.obj.a = 2
    t1.array.push(3)

    const t2 = new Test()
    t2.obj.a = 3
    t2.array.push(4)

    expect(t1.obj).not.toBe(t2.obj)
    expect(t1.array).not.toBe(t2.array)
    expect(t1.obj.a).toBe(2)
    expect(t2.obj.a).toBe(3)

    expect(t1.array.slice()).toEqual([2, 3])
    expect(t2.array.slice()).toEqual([2, 4])
})

test("705 - setter undoing caching (babel)", () => {
    let recomputes = 0
    let autoruns = 0

    class Person {
        @observable name
        @observable title

        constructor() {
            makeObservable(this)
        }

        set fullName(val) {
            // Noop
        }
        @computed
        get fullName() {
            recomputes++
            return this.title + " " + this.name
        }
    }

    let p1 = new Person()
    p1.name = "Tom Tank"
    p1.title = "Mr."

    expect(recomputes).toBe(0)
    expect(autoruns).toBe(0)

    const d1 = autorun(() => {
        autoruns++
        p1.fullName
    })

    const d2 = autorun(() => {
        autoruns++
        p1.fullName
    })

    expect(recomputes).toBe(1)
    expect(autoruns).toBe(2)

    p1.title = "Master"
    expect(recomputes).toBe(2)
    expect(autoruns).toBe(4)

    d1()
    d2()
})

function normalizeSpyEvents(events) {
    events.forEach(ev => {
        delete ev.fn
        delete ev.time
    })
    return events
}

test("action decorator (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this)
            this.multiplier = multiplier
        }

        @action
        add(a, b) {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(3, 4)).toBe(21)
    expect(store1.add(1, 1)).toBe(4)

    expect(normalizeSpyEvents(events)).toEqual([
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [1, 1], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this)
            this.multiplier = multiplier
        }

        @action("zoem zoem")
        add(a, b) {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(3, 4)).toBe(21)
    expect(store1.add(1, 1)).toBe(4)

    expect(normalizeSpyEvents(events)).toEqual([
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [1, 1],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("action decorator on field (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this)
            this.multiplier = multiplier
        }

        @action
        add = (a, b) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(5, 4)).toBe(63)
    expect(store1.add(2, 2)).toBe(8)

    expect(normalizeSpyEvents(events)).toEqual([
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [5, 4], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator on field (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this)
            this.multiplier = multiplier
        }

        @action("zoem zoem")
        add = (a, b) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(5, 4)).toBe(63)
    expect(store1.add(2, 2)).toBe(8)

    expect(normalizeSpyEvents(events)).toEqual([
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [5, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("267 (babel) should be possible to declare properties observable outside strict mode", () => {
    configure({ enforceActions: "observed" })

    class Store {
        @observable timer

        constructor() {
            makeObservable(this)
        }
    }
    Store // just to avoid linter warning

    configure({ enforceActions: "never" })
})

test("288 atom not detected for object property", () => {
    class Store {
        @mobx.observable foo = ""

        constructor() {
            makeObservable(this)
        }
    }

    const store = new Store()
    let changed = false

    mobx.observe(
        store,
        "foo",
        () => {
            changed = true
        },
        true
    )
    expect(changed).toBe(true)
})

test.skip("observable performance - babel - decorators", () => {
    const AMOUNT = 100000

    class A {
        @observable a = 1
        @observable b = 2
        @observable c = 3

        constructor() {
            makeObservable(this)
        }

        @computed
        get d() {
            return this.a + this.b + this.c
        }
    }

    const objs = []
    const start = Date.now()

    for (let i = 0; i < AMOUNT; i++) objs.push(new A())

    console.log("created in ", Date.now() - start)

    for (let j = 0; j < 4; j++) {
        for (let i = 0; i < AMOUNT; i++) {
            const obj = objs[i]
            obj.a += 3
            obj.b *= 4
            obj.c = obj.b - obj.a
            obj.d
        }
    }

    console.log("changed in ", Date.now() - start)
})

test("unbound methods", () => {
    class A {
        constructor() {
            makeObservable(this)
        }

        // shared across all instances
        @action
        m1() {}

        // per instance
        @action m2 = () => {}
    }

    const a1 = new A()
    const a2 = new A()

    expect(a1.m1).toBe(a2.m1)
    expect(a1.m2).not.toBe(a2.m2)
    expect(a1.hasOwnProperty("m1")).toBe(false)
    expect(a1.hasOwnProperty("m2")).toBe(true)
    expect(a2.hasOwnProperty("m1")).toBe(false)
    expect(a2.hasOwnProperty("m2")).toBe(true)
})

test("inheritance", () => {
    class A {
        @observable a = 2

        constructor() {
            makeObservable(this)
        }
    }

    class B extends A {
        @observable b = 3

        constructor() {
            super()
            makeObservable(this)
        }

        @computed
        get c() {
            return this.a + this.b
        }
    }

    const b1 = new B()
    const b2 = new B()
    const values = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    expect(values).toEqual([10, 11, 12, 14, 18])
})

test("reusing initializers", () => {
    class A {
        @observable a = 3
        @observable b = this.a + 2

        constructor() {
            makeObservable(this)
        }

        @computed
        get c() {
            return this.a + this.b
        }
        @computed
        get d() {
            return this.c + 1
        }
    }

    const a = new A()
    const values = []
    mobx.autorun(() => values.push(a.d))

    a.a = 4
    expect(values).toEqual([9, 10])
})

test("enumerability", () => {
    class A {
        @observable a = 1 // enumerable, on proto
        @observable a2 = 2

        constructor() {
            makeObservable(this)
        }

        @computed
        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        @action
        m() {} // non-enumerable, on proto
        @action m2 = () => {} // non-enumerable, on self
    }

    const a = new A()

    // not initialized yet
    let ownProps = Object.keys(a)
    let props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual(["a", "a2"])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true)
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)

    expect(mobx.isAction(a.m)).toBe(true)
    expect(mobx.isAction(a.m2)).toBe(true)

    // after initialization
    a.a
    a.b
    a.m
    a.m2

    ownProps = Object.keys(a)
    props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual([
        "a",
        "a2" // a2 is now initialized as well, altough never accessed!
    ])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("a2")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true) // true would better.. but, #1777
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)
})

test("enumerability - workaround", () => {
    class A {
        @observable a = 1 // enumerable, on proto
        @observable a2 = 2
        @computed
        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        @action
        m() {} // non-enumerable, on proto
        @action m2 = () => {} // non-enumerable, on self

        constructor() {
            makeObservable(this)
            this.a = 1
            this.a2 = 2
        }
    }

    const a = new A()

    const ownProps = Object.keys(a)
    const props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual([
        "a",
        "a2" // a2 is now initialized as well, altough never accessed!
    ])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("a2")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true) // ideally, false, but #1777
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)
})

test("issue 285 (babel)", () => {
    const { observable, toJS } = mobx

    class Todo {
        id = 1
        @observable title
        @observable finished = false
        @observable childThings = [1, 2, 3]
        constructor(title) {
            makeObservable(this)
            this.title = title
        }
    }

    const todo = new Todo("Something to do")

    expect(toJS(todo)).toEqual({
        id: 1,
        title: "Something to do",
        finished: false,
        childThings: [1, 2, 3]
    })
})

test("verify object assign (babel)", () => {
    class Todo {
        @observable title = "test"

        constructor() {
            makeObservable(this)
        }

        @computed
        get upperCase() {
            return this.title.toUpperCase()
        }
    }

    const todo = new Todo()
    expect(Object.assign({}, todo)).toEqual({
        title: "test"
    })
})

test("379, inheritable actions (babel)", () => {
    class A {
        constructor() {
            makeObservable(this)
        }

        @action
        method() {
            return 42
        }
    }

    class B extends A {
        constructor() {
            super()
            makeObservable(this)
        }

        method() {
            return super.method() * 2
        }
    }

    class C extends B {
        constructor() {
            super()
            makeObservable(this)
        }

        method() {
            return super.method() + 3
        }
    }

    const b = new B()
    expect(b.method()).toBe(84)
    expect(isAction(b.method)).toBe(true)

    const a = new A()
    expect(a.method()).toBe(42)
    expect(isAction(a.method)).toBe(true)

    const c = new C()
    expect(c.method()).toBe(87)
    expect(isAction(c.method)).toBe(true)
})

test("505, don't throw when accessing subclass fields in super constructor (babel)", () => {
    const values = {}
    class A {
        @observable a = 1
        constructor() {
            makeObservable(this)
            values.b = this.b
            values.a = this.a
        }
    }

    class B extends A {
        @observable b = 2

        constructor() {
            super()
            makeObservable(this)
        }
    }

    new B()
    expect(values).toEqual({ a: 1, b: undefined })
})

test("computed setter should succeed (babel)", function () {
    class Bla {
        @observable a = 3

        constructor() {
            makeObservable(this)
        }

        @computed
        get propX() {
            return this.a * 2
        }
        set propX(v) {
            this.a = v
        }
    }

    const b = new Bla()
    expect(b.propX).toBe(6)
    b.propX = 4
    expect(b.propX).toBe(8)
})

test("issue #701", () => {
    class Model {
        @observable a = 5

        constructor() {
            makeObservable(this)
        }
    }

    const model = new Model()

    expect(mobx.toJS(model)).toEqual({ a: 5 })
    expect(mobx.isObservable(model)).toBe(true)
    expect(mobx.isObservableObject(model)).toBe(true)
})

test("@observable.ref (Babel)", () => {
    class A {
        @observable.ref ref = { a: 3 }

        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    expect(a.ref.a).toBe(3)
    expect(mobx.isObservable(a.ref)).toBe(false)
    expect(mobx.isObservableProp(a, "ref")).toBe(true)
})

test("@observable.shallow (Babel)", () => {
    class A {
        @observable.shallow arr = [{ todo: 1 }]

        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)
    expect(mobx.isObservable(a.arr)).toBe(true)
    expect(mobx.isObservableProp(a, "arr")).toBe(true)
    expect(mobx.isObservable(a.arr[0])).toBe(false)
    expect(mobx.isObservable(a.arr[1])).toBe(false)
    expect(a.arr[1] === todo2).toBeTruthy()
})

test("@observable.deep (Babel)", () => {
    class A {
        @observable.deep arr = [{ todo: 1 }]

        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)

    expect(mobx.isObservable(a.arr)).toBe(true)
    expect(mobx.isObservableProp(a, "arr")).toBe(true)
    expect(mobx.isObservable(a.arr[0])).toBe(true)
    expect(mobx.isObservable(a.arr[1])).toBe(true)
    expect(a.arr[1] !== todo2).toBeTruthy()
    expect(isObservable(todo2)).toBe(false)
})

test("action.bound binds (Babel)", () => {
    class A {
        @observable x = 0

        constructor() {
            makeObservable(this)
        }

        @action.bound
        inc(value) {
            this.x += value
        }
    }

    const a = new A()
    const runner = a.inc
    runner(2)

    expect(a.x).toBe(2)
})

test("@computed.equals (Babel)", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    class Time {
        constructor(hour, minute) {
            makeObservable(this)
            this.hour = hour
            this.minute = minute
        }

        @observable hour
        @observable minute

        @computed({ equals: sameTime })
        get time() {
            return { hour: this.hour, minute: this.minute }
        }
    }
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

// 19.12.2020 @urugator:
// All annotated non-observable fields are not writable.
// All annotated fields of non-plain objects are non-configurable.
// https://github.com/mobxjs/mobx/pull/2641
test.skip("actions are reassignable", () => {
    // See #1398, make actions reassignable to support stubbing
    class A {
        constructor() {
            makeObservable(this)
        }

        @action
        m1() {}
        @action m2 = () => {}
        @action.bound
        m3() {}
        @action.bound m4 = () => {}
    }

    const a = new A()
    expect(isAction(a.m1)).toBe(true)
    expect(isAction(a.m2)).toBe(true)
    expect(isAction(a.m3)).toBe(true)
    expect(isAction(a.m4)).toBe(true)
    a.m1 = () => {}
    expect(isAction(a.m1)).toBe(false)
    a.m2 = () => {}
    expect(isAction(a.m2)).toBe(false)
    a.m3 = () => {}
    expect(isAction(a.m3)).toBe(false)
    a.m4 = () => {}
    expect(isAction(a.m4)).toBe(false)
})

test("it should support asyncAction (babel)", async () => {
    mobx.configure({ enforceActions: "observed" })

    class X {
        @observable a = 1

        f = mobx.flow(function* f(initial) {
            this.a = initial // this runs in action
            this.a += yield Promise.resolve(5)
            this.a = this.a * 2
            return this.a
        })

        constructor() {
            makeObservable(this)
        }
    }

    const x = new X()

    expect(await x.f(3)).toBe(16)
})

test("toJS bug #1413 (babel)", () => {
    class X {
        @observable
        test = {
            test1: 1
        }

        constructor() {
            makeObservable(this)
        }
    }

    const x = new X()
    const res = mobx.toJS(x.test)
    expect(res).toEqual({ test1: 1 })
    expect(res.__mobxDidRunLazyInitializers).toBe(undefined)
})

test("computed setter problem", () => {
    class Contact {
        @observable firstName = ""
        @observable lastName = ""

        constructor() {
            makeObservable(this)
        }

        @computed({
            set(value) {
                const [firstName, lastName] = value.split(" ")

                this.firstName = firstName
                this.lastName = lastName
            }
        })
        get fullName() {
            return `${this.firstName} ${this.lastName}`
        }

        set fullName(value) {
            const [firstName, lastName] = value.split(" ")

            this.firstName = firstName
            this.lastName = lastName
        }
    }

    const c = new Contact()

    c.firstName = "Pavan"
    c.lastName = "Podila"

    expect(c.fullName).toBe("Pavan Podila")

    c.fullName = "Michel Weststrate"
    expect(c.firstName).toBe("Michel")
    expect(c.lastName).toBe("Weststrate")
})

test("#1740, combining extendObservable & decorators", () => {
    class AppState {
        constructor(id) {
            makeObservable(this)
            extendObservable(this, {
                id
            })
            expect(this.foo).toBe(id)
        }

        @computed
        get foo() {
            return this.id
        }
    }

    let app = new AppState(1)
    expect(app.id).toBe(1)
    expect(app.foo).toBe(1)
    expect(isObservableProp(app, "id")).toBe(true)
    expect(isComputedProp(app, "foo")).toBe(true)

    app = new AppState(2)
    expect(app.id).toBe(2)
    expect(app.foo).toBe(2)
    expect(isObservableProp(app, "id")).toBe(true)
    expect(isComputedProp(app, "foo")).toBe(true)
})



================================================
FILE: packages/mobx/__tests__/v5/base/babel-tests.js
================================================
import {
    observable,
    computed,
    transaction,
    autorun,
    extendObservable,
    action,
    isObservableObject,
    observe,
    isObservable,
    isObservableProp,
    isComputedProp,
    spy,
    isAction,
    configure,
    makeObservable
} from "../../../src/mobx"
import * as mobx from "../../../src/mobx"

test("babel", function () {
    class Box {
        uninitialized
        height = 20
        sizes = [2]
        someFunc = function () {
            return 2
        }

        constructor() {
            makeObservable(this, {
                uninitialized: observable,
                height: observable,
                sizes: observable,
                someFunc: observable,
                width: computed,
                addSize: action
            })
        }

        get width() {
            return this.height * this.sizes.length * this.someFunc() * (this.uninitialized ? 2 : 1)
        }
        addSize() {
            this.sizes.push(3)
            this.sizes.push(4)
        }
    }

    const box = new Box()
    const ar = []
    autorun(() => {
        ar.push(box.width)
    })

    let s = ar.slice()
    expect(s).toEqual([40])
    box.height = 10
    s = ar.slice()
    expect(s).toEqual([40, 20])
    box.sizes.push(3, 4)
    s = ar.slice()
    expect(s).toEqual([40, 20, 60])
    box.someFunc = () => 7
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    s = ar.slice()
    expect(s).toEqual([40, 20, 60, 210, 420, 700])
})

test("should not be possible to use @action with getters", () => {
    expect(() => {
        class A {
            constructor() {
                makeObservable(this, {
                    Test: action
                })
            }

            get Test() {}
        }
        return new A()
    }).toThrow(/can only be used on properties with a function value/)

    mobx._resetGlobalState()
})

test("babel: parameterized computed decorator", () => {
    class TestClass {
        x = 3
        y = 3

        constructor() {
            makeObservable(this, {
                x: observable,
                y: observable,
                boxedSum: computed.struct
            })
        }

        get boxedSum() {
            return { sum: Math.round(this.x) + Math.round(this.y) }
        }
    }

    const t1 = new TestClass()
    const changes = []
    const d = autorun(() => changes.push(t1.boxedSum))

    t1.y = 4 // change
    expect(changes.length).toBe(2)
    t1.y = 4.2 // no change
    expect(changes.length).toBe(2)
    transaction(() => {
        t1.y = 3
        t1.x = 4
    }) // no change
    expect(changes.length).toBe(2)
    t1.x = 6 // change
    expect(changes.length).toBe(3)
    d()

    expect(changes).toEqual([{ sum: 6 }, { sum: 7 }, { sum: 9 }])
})

test("computed value should be the same around changing which was considered equivalent", () => {
    class TestClass {
        c = null
        defaultCollection = []

        constructor() {
            makeObservable(this, {
                c: observable,
                collection: computed.struct
            })
        }

        get collection() {
            return this.c || this.defaultCollection
        }
    }

    const t1 = new TestClass()

    const d = autorun(() => t1.collection)

    const oldCollection = t1.collection
    t1.c = []
    const newCollection = t1.collection

    expect(oldCollection).toBe(newCollection)

    d()
})

class Order {
    price = 3
    amount = 2
    orders = []
    aFunction = function () {}

    constructor() {
        makeObservable(this, {
            price: observable,
            amount: observable,
            orders: observable,
            aFunction: observable,
            total: computed
        })
    }

    get total() {
        return this.amount * this.price * (1 + this.orders.length)
    }
}

test("decorators", function () {
    const o = new Order()
    expect(isObservableObject(o)).toBe(true)
    expect(isObservableProp(o, "amount")).toBe(true)
    expect(o.total).toBe(6) // .... this is required to initialize the props which are made reactive lazily...
    expect(isObservableProp(o, "total")).toBe(true)

    const events = []
    const d1 = observe(o, ev => events.push(ev.name, ev.oldValue))
    const d2 = observe(o, "price", ev => events.push(ev.newValue, ev.oldValue))
    const d3 = observe(o, "total", ev => events.push(ev.newValue, ev.oldValue))

    o.price = 4

    d1()
    d2()
    d3()

    o.price = 5

    expect(events).toEqual([
        8, // new total
        6, // old total
        4, // new price
        3, // old price
        "price", // event name
        3 // event oldValue
    ])
})

test("issue 191 - shared initializers (babel)", function () {
    class Test {
        obj = { a: 1 }
        array = [2]

        constructor() {
            makeObservable(this, {
                obj: observable,
                array: observable
            })
        }
    }

    const t1 = new Test()
    t1.obj.a = 2
    t1.array.push(3)

    const t2 = new Test()
    t2.obj.a = 3
    t2.array.push(4)

    expect(t1.obj).not.toBe(t2.obj)
    expect(t1.array).not.toBe(t2.array)
    expect(t1.obj.a).toBe(2)
    expect(t2.obj.a).toBe(3)

    expect(t1.array.slice()).toEqual([2, 3])
    expect(t2.array.slice()).toEqual([2, 4])
})

test("705 - setter undoing caching (babel)", () => {
    let recomputes = 0
    let autoruns = 0

    class Person {
        name
        title

        constructor() {
            makeObservable(this, {
                name: observable,
                title: observable,
                fullName: computed
            })
        }

        set fullName(val) {
            // Noop
        }
        get fullName() {
            recomputes++
            return this.title + " " + this.name
        }
    }

    let p1 = new Person()
    p1.name = "Tom Tank"
    p1.title = "Mr."

    expect(recomputes).toBe(0)
    expect(autoruns).toBe(0)

    const d1 = autorun(() => {
        autoruns++
        p1.fullName
    })

    const d2 = autorun(() => {
        autoruns++
        p1.fullName
    })

    expect(recomputes).toBe(1)
    expect(autoruns).toBe(2)

    p1.title = "Master"
    expect(recomputes).toBe(2)
    expect(autoruns).toBe(4)

    d1()
    d2()
})

function normalizeSpyEvents(events) {
    events.forEach(ev => {
        delete ev.fn
        delete ev.time
    })
    return events
}

test("action decorator (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this, {
                add: action
            })

            this.multiplier = multiplier
        }

        add(a, b) {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(3, 4)).toBe(21)
    expect(store1.add(1, 1)).toBe(4)

    expect(normalizeSpyEvents(events)).toEqual([
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [1, 1], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this, {
                add: action("zoem zoem")
            })

            this.multiplier = multiplier
        }

        add(a, b) {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(3, 4)).toBe(21)
    expect(store1.add(1, 1)).toBe(4)

    expect(normalizeSpyEvents(events)).toEqual([
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [1, 1],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("action decorator on field (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this, {
                add: action
            })

            this.multiplier = multiplier
        }

        add = (a, b) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(5, 4)).toBe(63)
    expect(store1.add(2, 2)).toBe(8)

    expect(normalizeSpyEvents(events)).toEqual([
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [5, 4], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator on field (babel)", function () {
    class Store {
        constructor(multiplier) {
            makeObservable(this, {
                add: action("zoem zoem")
            })

            this.multiplier = multiplier
        }

        add = (a, b) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events = []
    const d = spy(events.push.bind(events))
    expect(store1.add(3, 4)).toBe(14)
    expect(store2.add(5, 4)).toBe(63)
    expect(store1.add(2, 2)).toBe(8)

    expect(normalizeSpyEvents(events)).toEqual([
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [5, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("267 (babel) should be possible to declare properties observable outside strict mode", () => {
    configure({ enforceActions: "observed" })

    class Store {
        timer

        constructor() {
            makeObservable(this, {
                timer: observable
            })
        }
    }
    Store // just to avoid linter warning

    configure({ enforceActions: "never" })
})

test("288 atom not detected for object property", () => {
    class Store {
        foo = ""

        constructor() {
            makeObservable(this, {
                foo: mobx.observable
            })
        }
    }

    const store = new Store()
    let changed = false

    mobx.observe(
        store,
        "foo",
        () => {
            changed = true
        },
        true
    )
    expect(changed).toBe(true)
})

test.skip("observable performance - babel", () => {
    const AMOUNT = 100000

    class A {
        a = 1
        b = 2
        c = 3

        constructor() {
            makeObservable(this, {
                a: observable,
                b: observable,
                c: observable,
                d: computed
            })
        }

        get d() {
            return this.a + this.b + this.c
        }
    }

    const objs = []
    const start = Date.now()

    for (let i = 0; i < AMOUNT; i++) objs.push(new A())

    console.log("created in ", Date.now() - start)

    for (let j = 0; j < 4; j++) {
        for (let i = 0; i < AMOUNT; i++) {
            const obj = objs[i]
            obj.a += 3
            obj.b *= 4
            obj.c = obj.b - obj.a
            obj.d
        }
    }

    console.log("changed in ", Date.now() - start)
})

test.skip("observable performance - babel - decorators", () => {
    const AMOUNT = 100000

    class A {
        @observable
        a = 1
        @observable
        b = 2
        @observable
        c = 3

        constructor() {
            makeObservable(this)
        }

        @computed
        get d() {
            return this.a + this.b + this.c
        }
    }

    const objs = []
    const start = Date.now()

    for (let i = 0; i < AMOUNT; i++) objs.push(new A())

    console.log("created in ", Date.now() - start)

    for (let j = 0; j < 4; j++) {
        for (let i = 0; i < AMOUNT; i++) {
            const obj = objs[i]
            obj.a += 3
            obj.b *= 4
            obj.c = obj.b - obj.a
            obj.d
        }
    }

    console.log("changed in ", Date.now() - start)
})
test("unbound methods", () => {
    class A {
        constructor() {
            makeObservable(this, {
                m1: action,
                m2: action
            })
        }

        // shared across all instances
        m1() {}

        // per instance
        m2 = () => {}
    }

    const a1 = new A()
    const a2 = new A()

    expect(a1.m1).toBe(a2.m1)
    expect(a1.m2).not.toBe(a2.m2)
    expect(a1.hasOwnProperty("m1")).toBe(false)
    expect(a1.hasOwnProperty("m2")).toBe(true)
    expect(a2.hasOwnProperty("m1")).toBe(false)
    expect(a2.hasOwnProperty("m2")).toBe(true)
})

test("inheritance", () => {
    class A {
        a = 2

        constructor() {
            makeObservable(this, {
                a: observable
            })
        }
    }

    class B extends A {
        b = 3

        constructor() {
            super()
            makeObservable(this, {
                b: observable,
                c: computed
            })
        }

        get c() {
            return this.a + this.b
        }
    }

    const b1 = new B()
    const b2 = new B()
    const values = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    expect(values).toEqual([10, 11, 12, 14, 18])
})

test("inheritance - 2", () => {
    class A {
        b = 3

        constructor() {
            makeObservable(this, {
                b: observable,
                c: computed
            })
        }

        get c() {
            return this.a + this.b
        }
    }

    class B extends A {
        a = 2

        constructor() {
            super()
            makeObservable(this, {
                a: observable
            })
        }
    }

    const b1 = new B()
    const b2 = new B()
    const values = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    expect(values).toEqual([10, 11, 12, 14, 18])
})

test("reusing initializers", () => {
    class A {
        a = 3
        b = this.a + 2

        constructor() {
            makeObservable(this, {
                a: observable,
                b: observable,
                c: computed,
                d: computed
            })
        }

        get c() {
            return this.a + this.b
        }
        get d() {
            return this.c + 1
        }
    }

    const a = new A()
    const values = []
    mobx.autorun(() => values.push(a.d))

    a.a = 4
    expect(values).toEqual([9, 10])
})

test("enumerability", () => {
    class A {
        a = 1
        a2 = 2

        constructor() {
            makeObservable(this, {
                a: observable,
                a2: observable,
                b: computed,
                m: action,
                m2: action
            })
        }

        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        m() {} // non-enumerable, on proto
        m2 = () => {} // non-enumerable, on self
    }

    const a = new A()

    // not initialized yet
    let ownProps = Object.keys(a)
    let props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual(["a", "a2"])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true) // false could be ok as well
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)

    expect(mobx.isAction(a.m)).toBe(true)
    expect(mobx.isAction(a.m2)).toBe(true)

    // after initialization
    a.a
    a.b
    a.m
    a.m2

    ownProps = Object.keys(a)
    props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual([
        "a",
        "a2" // a2 is now initialized as well, altough never accessed!
    ])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("a2")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true) // true would better.. but, #1777
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)
})

test("enumerability - workaround", () => {
    class A {
        a = 1 // enumerable, on proto
        a2 = 2
        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        m() {} // non-enumerable, on proto
        m2 = () => {} // non-enumerable, on self

        constructor() {
            makeObservable(this, {
                a: observable,
                a2: observable,
                b: computed,
                m: action,
                m2: action
            })

            this.a = 1
            this.a2 = 2
        }
    }

    const a = new A()

    const ownProps = Object.keys(a)
    const props = []
    for (const key in a) props.push(key)

    expect(ownProps).toEqual([
        "a",
        "a2" // a2 is now initialized as well, altough never accessed!
    ])

    expect(props).toEqual(["a", "a2"])

    expect("a" in a).toBe(true)
    expect(a.hasOwnProperty("a")).toBe(true)
    expect(a.hasOwnProperty("a2")).toBe(true)
    expect(a.hasOwnProperty("b")).toBe(true) // ideally, false, but #1777
    expect(a.hasOwnProperty("m")).toBe(false)
    expect(a.hasOwnProperty("m2")).toBe(true)
})

test("issue 285 (babel)", () => {
    const { observable, toJS } = mobx

    class Todo {
        id = 1
        title
        finished = false
        childThings = [1, 2, 3]
        constructor(title) {
            makeObservable(this, {
                title: observable,
                finished: observable,
                childThings: observable
            })

            this.title = title
        }
    }

    const todo = new Todo("Something to do")

    expect(toJS(todo)).toEqual({
        id: 1,
        title: "Something to do",
        finished: false,
        childThings: [1, 2, 3]
    })
})

test("verify object assign (babel)", () => {
    class Todo {
        title = "test"

        constructor() {
            makeObservable(this, {
                title: observable,
                upperCase: computed
            })
        }

        get upperCase() {
            return this.title.toUpperCase()
        }
    }

    const todo = new Todo()
    expect(Object.assign({}, todo)).toEqual({
        title: "test"
    })
})

test("379, inheritable actions (babel)", () => {
    class A {
        constructor() {
            makeObservable(this, {
                method: action
            })
        }

        method() {
            return 42
        }
    }

    class B extends A {
        method() {
            return super.method() * 2
        }
    }

    class C extends B {
        method() {
            return super.method() + 3
        }
    }

    const b = new B()
    expect(b.method()).toBe(84)
    expect(isAction(b.method)).toBe(true)

    const a = new A()
    expect(a.method()).toBe(42)
    expect(isAction(a.method)).toBe(true)

    const c = new C()
    expect(c.method()).toBe(87)
    expect(isAction(c.method)).toBe(true)
})

test("505, don't throw when accessing subclass fields in super constructor (babel)", () => {
    const values = {}
    class A {
        a = 1
        constructor() {
            makeObservable(this, {
                a: observable
            })

            values.b = this.b
            values.a = this.a
        }
    }

    class B extends A {
        b = 2

        constructor() {
            super()

            makeObservable(this, {
                b: observable
            })
        }
    }

    new B()
    expect(values).toEqual({ a: 1, b: undefined })
})

test("computed setter should succeed (babel)", function () {
    class Bla {
        a = 3

        constructor() {
            makeObservable(this, {
                a: observable,
                propX: computed
            })
        }

        get propX() {
            return this.a * 2
        }
        set propX(v) {
            this.a = v
        }
    }

    const b = new Bla()
    expect(b.propX).toBe(6)
    b.propX = 4
    expect(b.propX).toBe(8)
})

test("computed getter / setter for plan objects should succeed (babel)", function () {
    const b = observable({
        a: 3,
        get propX() {
            return this.a * 2
        },
        set propX(v) {
            this.a = v
        }
    })

    const values = []
    mobx.autorun(() => values.push(b.propX))
    expect(b.propX).toBe(6)
    b.propX = 4
    expect(b.propX).toBe(8)

    expect(values).toEqual([6, 8])
})

test("issue #701", () => {
    class Model {
        a = 5

        constructor() {
            makeObservable(this, {
                a: observable
            })
        }
    }

    const model = new Model()

    expect(mobx.toJS(model)).toEqual({ a: 5 })
    expect(mobx.isObservable(model)).toBe(true)
    expect(mobx.isObservableObject(model)).toBe(true)
})

test("@observable.ref (Babel)", () => {
    class A {
        ref = { a: 3 }

        constructor() {
            makeObservable(this, {
                ref: observable.ref
            })
        }
    }

    const a = new A()
    expect(a.ref.a).toBe(3)
    expect(mobx.isObservable(a.ref)).toBe(false)
    expect(mobx.isObservableProp(a, "ref")).toBe(true)
})

test("@observable.shallow (Babel)", () => {
    class A {
        arr = [{ todo: 1 }]

        constructor() {
            makeObservable(this, {
                arr: observable.shallow
            })
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)
    expect(mobx.isObservable(a.arr)).toBe(true)
    expect(mobx.isObservableProp(a, "arr")).toBe(true)
    expect(mobx.isObservable(a.arr[0])).toBe(false)
    expect(mobx.isObservable(a.arr[1])).toBe(false)
    expect(a.arr[1] === todo2).toBeTruthy()
})

test("@observable.deep (Babel)", () => {
    class A {
        arr = [{ todo: 1 }]

        constructor() {
            makeObservable(this, {
                arr: observable.deep
            })
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)

    expect(mobx.isObservable(a.arr)).toBe(true)
    expect(mobx.isObservableProp(a, "arr")).toBe(true)
    expect(mobx.isObservable(a.arr[0])).toBe(true)
    expect(mobx.isObservable(a.arr[1])).toBe(true)
    expect(a.arr[1] !== todo2).toBeTruthy()
    expect(isObservable(todo2)).toBe(false)
})

test("action.bound binds (Babel)", () => {
    class A {
        x = 0

        constructor() {
            makeObservable(this, {
                x: observable,
                inc: action.bound
            })
        }

        inc(value) {
            this.x += value
        }
    }

    const a = new A()
    const runner = a.inc
    runner(2)

    expect(a.x).toBe(2)
})

test("@computed.equals (Babel)", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    class Time {
        constructor(hour, minute) {
            makeObservable(this, {
                hour: observable,
                minute: observable,
                time: computed({ equals: sameTime })
            })

            this.hour = hour
            this.minute = minute
        }

        hour
        minute

        get time() {
            return { hour: this.hour, minute: this.minute }
        }
    }
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("computed comparer works with decorate (babel)", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    class Time {
        hour
        minute

        constructor(hour, minute) {
            makeObservable(this, {
                hour: observable,
                minute: observable,
                time: computed({ equals: sameTime })
            })

            this.hour = hour
            this.minute = minute
        }

        get time() {
            return { hour: this.hour, minute: this.minute }
        }
    }
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("computed comparer works with decorate (babel) - 2", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    class Time {
        constructor(hour, minute) {
            extendObservable(
                this,
                {
                    hour,
                    minute,
                    get time() {
                        return { hour: this.hour, minute: this.minute }
                    }
                },
                {
                    time: computed({ equals: sameTime })
                }
            )
        }
    }
    const time = new Time(9, 0)

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("computed comparer works with decorate (babel) - 3", () => {
    const sameTime = (from, to) => from.hour === to.hour && from.minute === to.minute
    const time = observable.object(
        {
            hour: 9,
            minute: 0,
            get time() {
                return { hour: this.hour, minute: this.minute }
            }
        },
        {
            time: computed({ equals: sameTime })
        }
    )

    const changes = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 9
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.minute = 0
    expect(changes).toEqual([{ hour: 9, minute: 0 }])
    time.hour = 10
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    expect(changes).toEqual([
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

// 19.12.2020 @urugator:
// All annotated non-observable fields are not writable.
// All annotated fields of non-plain objects are non-configurable.
// https://github.com/mobxjs/mobx/pull/2641
test.skip("actions are reassignable", () => {
    // See #1398, make actions reassignable to support stubbing
    class A {
        constructor() {
            makeObservable(this, {
                m1: action,
                m2: action,
                m3: action.bound,
                m4: action.bound
            })
        }

        m1() {}
        m2 = () => {}
        m3() {}
        m4 = () => {}
    }

    const a = new A()
    expect(isAction(a.m1)).toBe(true)
    expect(isAction(a.m2)).toBe(true)
    expect(isAction(a.m3)).toBe(true)
    expect(isAction(a.m4)).toBe(true)
    a.m1 = () => {}
    expect(isAction(a.m1)).toBe(false)
    a.m2 = () => {}
    expect(isAction(a.m2)).toBe(false)
    a.m3 = () => {}
    expect(isAction(a.m3)).toBe(false)
    a.m4 = () => {}
    expect(isAction(a.m4)).toBe(false)
})

test("it should support asyncAction (babel)", async () => {
    mobx.configure({ enforceActions: "observed" })

    class X {
        a = 1

        f = mobx.flow(function* f(initial) {
            this.a = initial // this runs in action
            this.a += yield Promise.resolve(5)
            this.a = this.a * 2
            return this.a
        })

        constructor() {
            makeObservable(this, {
                a: observable
            })
        }
    }

    const x = new X()

    expect(await x.f(3)).toBe(16)
})

test("toJS bug #1413 (babel)", () => {
    class X {
        test = {
            test1: 1
        }

        constructor() {
            makeObservable(this, {
                test: observable
            })
        }
    }

    const x = new X()
    const res = mobx.toJS(x.test)
    expect(res).toEqual({ test1: 1 })
    expect(res.__mobxDidRunLazyInitializers).toBe(undefined)
})

test("computed setter problem", () => {
    class Contact {
        firstName = ""
        lastName = ""

        constructor() {
            makeObservable(this, {
                firstName: observable,
                lastName: observable,

                fullName: computed({
                    set(value) {
                        const [firstName, lastName] = value.split(" ")

                        this.firstName = firstName
                        this.lastName = lastName
                    }
                })
            })
        }

        get fullName() {
            return `${this.firstName} ${this.lastName}`
        }

        set fullName(value) {
            const [firstName, lastName] = value.split(" ")

            this.firstName = firstName
            this.lastName = lastName
        }
    }

    const c = new Contact()

    c.firstName = "Pavan"
    c.lastName = "Podila"

    expect(c.fullName).toBe("Pavan Podila")

    c.fullName = "Michel Weststrate"
    expect(c.firstName).toBe("Michel")
    expect(c.lastName).toBe("Weststrate")
})

test("#1740, combining extendObservable & decorators", () => {
    class AppState {
        constructor(id) {
            makeObservable(this, {
                foo: computed
            })

            extendObservable(this, {
                id
            })
            expect(this.foo).toBe(id)
        }

        get foo() {
            return this.id
        }
    }

    let app = new AppState(1)
    expect(app.id).toBe(1)
    expect(app.foo).toBe(1)
    expect(isObservableProp(app, "id")).toBe(true)
    expect(isComputedProp(app, "foo")).toBe(true)

    app = new AppState(2)
    expect(app.id).toBe(2)
    expect(app.foo).toBe(2)
    expect(isObservableProp(app, "id")).toBe(true)
    expect(isComputedProp(app, "foo")).toBe(true)
})



================================================
FILE: packages/mobx/__tests__/v5/base/become-observed.ts
================================================
import {
    autorun,
    onBecomeObserved,
    observable,
    computed,
    action,
    makeObservable,
    onBecomeUnobserved,
    runInAction,
    makeAutoObservable
} from "../../../src/mobx"

describe("become-observed", () => {
    it("work on map with number as key", () => {
        const oMap = observable.map()
        const key = 1
        oMap.set(key, observable.box("value"))
        const cb = jest.fn()
        onBecomeObserved(oMap, key, cb)
        autorun(() => oMap.get(key))
        expect(cb).toBeCalled()
    })
})

test("#2309 don't trigger oBO for computeds that aren't subscribed to", () => {
    const events: string[] = []

    class Asd {
        @observable prop = 42

        @computed
        get computed() {
            return this.prop
        }

        @action
        actionProp() {
            const foo = this.prop
        }

        @action
        actionComputed() {
            const bar = this.computed
        }

        constructor() {
            makeObservable(this)
        }
    }

    const asd = new Asd()
    onBecomeObserved(asd, "prop", () => {
        events.push("onBecomeObserved")
    })

    onBecomeUnobserved(asd, "prop", () => {
        events.push("onBecomeUnobserved")
    })

    asd.actionProp()
    events.push("--")
    asd.actionComputed()
    expect(events).toEqual(["--"])
})

describe("#2309 onBecomeObserved inconsistencies", () => {
    let events: string[] = []

    beforeEach(() => {
        events = []
    })

    test("caseA", () => {
        // Computed {keepAlive: false} -> Observable
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        expect(events).toEqual([])
        ca.get()
        expect(events).toEqual([])
    })

    test("caseB", () => {
        // Computed {keepAlive: false} -> Computed {keepAlive: false} -> Observable
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        const cb = computed(
            () => {
                return ca.get() * 2
            },
            { keepAlive: false }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        onBecomeObserved(cb, () => events.push(`cb observed`))
        onBecomeUnobserved(cb, () => events.push(`cb unobserved`))
        expect(events).toEqual([])
        cb.get()
        expect(events).toEqual([])
    })

    test("caseC", () => {
        // Computed {keepAlive: true} -> Observable
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: true }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        expect(events).toEqual([])
        ca.get()
        expect(events).toEqual(["o observed"]) // everything is hot, and 'o' is really observed so that the keptAlive computed knows about its state
    })

    test("caseD", () => {
        // Computed {keepAlive: true} -> Computed {keepAlive: false} -> Observable
        // logs: `o observed`
        // potential issue: why are the callbacks not called on `ca` ?
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        const cb = computed(
            () => {
                return ca.get() * 2
            },
            { keepAlive: true }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        onBecomeObserved(cb, () => events.push(`cb observed`))
        onBecomeUnobserved(cb, () => events.push(`cb unobserved`))
        expect(events).toEqual([])
        cb.get()
        expect(events).toEqual(["ca observed", "o observed"]) // see above
    })

    test("caseE - base", () => {
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        const cb = computed(
            () => {
                return ca.get() * 2
            },
            { keepAlive: false }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        onBecomeObserved(cb, () => events.push(`cb observed`))
        onBecomeUnobserved(cb, () => events.push(`cb unobserved`))

        const u = autorun(() => cb.get())
        u()
        expect(events).toEqual([
            "cb observed",
            "ca observed",
            "o observed",
            "cb unobserved",
            "ca unobserved",
            "o unobserved"
        ])
    })

    test("caseE", () => {
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        const cb = computed(
            () => {
                return ca.get() * 2
            },
            { keepAlive: true }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        onBecomeObserved(cb, () => events.push(`cb observed`))
        onBecomeUnobserved(cb, () => events.push(`cb unobserved`))

        const u = autorun(() => cb.get())
        u()
        // Note that at this point the observables never become unobserved anymore!
        // That is correct, because if doing our kept-alive computed doesn't recompute until reobserved,
        // itself it is still observing all the values of its own deps to figure whether it is still
        // up to date or not
        expect(events).toEqual(["cb observed", "ca observed", "o observed", "cb unobserved"])

        events.splice(0)
        const u2 = autorun(() => cb.get())
        u2()
        expect(events).toEqual(["cb observed", "cb unobserved"])
    })

    test("caseF", () => {
        // Computed {keepAlive: true} -> Computed {keepAlive: false} -> Observable
        // cb.get() first then autorun() then unsub()
        const o = observable.box(1)
        const ca = computed(
            () => {
                return o.get()
            },
            { keepAlive: false }
        )

        const cb = computed(
            () => {
                return ca.get() * 2
            },
            { keepAlive: true }
        )

        onBecomeObserved(o, () => events.push(`o observed`))
        onBecomeUnobserved(o, () => events.push(`o unobserved`))
        onBecomeObserved(ca, () => events.push(`ca observed`))
        onBecomeUnobserved(ca, () => events.push(`ca unobserved`))
        onBecomeObserved(cb, () => events.push(`cb observed`))
        onBecomeUnobserved(cb, () => events.push(`cb unobserved`))
        cb.get()

        expect(events).toEqual(["ca observed", "o observed"])
        events.splice(0)
        const u = autorun(() => cb.get())
        u()
        expect(events).toEqual(["cb observed", "cb unobserved"])
    })
})

describe("nested computes don't trigger hooks #2686", () => {
    let events: string[] = []

    class Lower {
        public lowerValue$ = -1

        public isObserved = false

        constructor() {
            makeObservable(this, {
                lowerValue$: observable
            })

            onBecomeObserved(
                this,
                "lowerValue$",
                action(() => {
                    events.push("onBecomeObserved")
                    this.isObserved = true
                })
            )
            onBecomeUnobserved(
                this,
                "lowerValue$",
                action(() => {
                    events.push("onBecomeUnobserved")
                    this.isObserved = false
                })
            )
        }
    }

    class UpperComputed {
        constructor() {
            makeObservable(this, {
                upperValue$: computed,
                lower$: observable.ref
            })
        }

        public lower$: Lower | undefined

        public get upperValue$() {
            events.push("upperValue$")
            const lower = this.lower$
            return lower ? lower.lowerValue$ : -Infinity
        }
    }

    const upperComputed = new UpperComputed()
    const lowerForComputed = new Lower()

    // Set up observers
    const d = autorun(() => {
        events.push("value read through computed: " + upperComputed.upperValue$)
    })

    // Provide the 'lower' values
    runInAction(() => {
        upperComputed.lower$ = lowerForComputed
    })

    // Check if the lower values are being observed.
    expect(lowerForComputed.isObserved).toBe(true)

    d()
    expect(lowerForComputed.isObserved).toBe(false)

    expect(events).toEqual([
        "upperValue$",
        "value read through computed: -Infinity",
        "upperValue$",
        "onBecomeObserved",
        "value read through computed: -1",
        "onBecomeUnobserved"
    ])
})

test("#2686 - 2", () => {
    const events: string[] = []
    const options = { useColors: false }
    makeAutoObservable(options)
    const selection = { color: "red" }
    makeAutoObservable(selection)

    const blue = computed(() => {
        let val
        if (options.useColors) {
            const isSelected = computed(() => selection.color === "blue")
            onBecomeObserved(isSelected, () => events.push("observing"))
            onBecomeUnobserved(isSelected, () => events.push("unobserving"))
            val = isSelected.get()
        }
        return { isSelected: val }
    })

    const d = autorun(() => events.push(blue.get().isSelected ? "selected" : "unselected"))

    runInAction(() => {
        options.useColors = true
        selection.color = "blue"
    })
    d()
    expect(events).toEqual(["unselected", "observing", "selected", "unobserving"])
})

test("#2686 - 3", () => {
    const events: string[] = []

    // half first element of array
    function halfFirst(data) {
        const first = computed(() => {
            events.push("recalculating")
            return Math.round(data.elements[0] / 2) + data.suffix
        })

        onBecomeObserved(first, () => {
            events.push("observing first")
        })

        return first
    }

    // APP

    const network = observable({ model: null as any })

    // load
    const load = computed(() => {
        // wait to load it
        if (network.model) {
            return halfFirst(network.model)
        }
        return undefined
    })

    // display
    const result = computed(() => (load.get() ? load.get()!.get() : "loading"))
    autorun(() => {
        events.push("Current result: " + result.get())
    })

    runInAction(() => (network.model = observable({ suffix: "$", elements: [2, 4, 5] })))
    runInAction(() => (network.model.elements[0] = 3))
    runInAction(() => (network.model.elements[0] = 4))
    runInAction(() => (network.model.elements[0] = 5))
    expect(events).toEqual([
        "Current result: loading",
        "observing first",
        "recalculating",
        "Current result: 1$",
        "recalculating",
        "Current result: 2$",
        "recalculating",
        "recalculating",
        "Current result: 3$"
    ])
})

test("#2667", () => {
    const events: any[] = []
    class LazyInitializedList {
        @observable
        public items: string[] | undefined

        @observable
        public listName

        public constructor(listName: string, lazyItems: string[]) {
            makeObservable(this)
            this.listName = listName
            onBecomeObserved(
                this,
                "items",
                action(() => {
                    this.items = lazyItems
                    events.push("onBecomeObserved" + listName)
                })
            )
            onBecomeUnobserved(
                this,
                "items",
                action(() => {
                    this.items = undefined
                    events.push("onBecomeUnobserved" + listName)
                })
            )
        }
    }

    class ItemsStore {
        @observable
        private list: LazyInitializedList

        public constructor() {
            this.list = new LazyInitializedList("initial", ["a, b, c"])
            makeObservable(this)
        }

        @action
        public changeList = () => {
            this.list = new LazyInitializedList("new", ["b, c, a"])
        }

        @computed
        public get items(): string[] | undefined {
            return this.list.items
        }

        @computed
        public get activeListName(): string {
            return this.list.listName
        }
    }

    const store = new ItemsStore()

    const d = autorun(() => {
        events.push(store.items?.length ?? "-")
        events.push(store.activeListName)
    })

    store.changeList()

    d()

    expect(events).toEqual([
        "onBecomeObservedinitial",
        1,
        "initial",
        "onBecomeObservednew",
        1,
        "new",
        "onBecomeUnobservedinitial",
        "onBecomeUnobservednew"
    ])
})

test("works with ObservableSet #3595", () => {
    const onSetObserved = jest.fn()
    const onSetUnobserved = jest.fn()

    const set = observable.set()

    const disposeOBO = onBecomeObserved(set, onSetObserved)
    const disposeOBU = onBecomeUnobserved(set, onSetUnobserved)
    const diposeAutorun = autorun(() => set.size)
    diposeAutorun()
    disposeOBO()
    disposeOBU()

    expect(onSetObserved).toBeCalledTimes(1)
    expect(onSetUnobserved).toBeCalledTimes(1)
})



================================================
FILE: packages/mobx/__tests__/v5/base/cycles.js
================================================
const m = require("../../../src/mobx.ts")

test("cascading active state (form 1)", function () {
    const Store = function () {
        m.extendObservable(this, { _activeItem: null })
    }
    Store.prototype.activeItem = function (item) {
        const _this = this

        if (arguments.length === 0) return this._activeItem

        m.transaction(function () {
            if (_this._activeItem === item) return
            if (_this._activeItem) _this._activeItem.isActive = false
            _this._activeItem = item
            if (_this._activeItem) _this._activeItem.isActive = true
        })
    }

    const Item = function () {
        m.extendObservable(this, { isActive: false })
    }

    const store = new Store()
    const item1 = new Item(),
        item2 = new Item()
    expect(store.activeItem()).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)

    store.activeItem(item1)
    expect(store.activeItem()).toBe(item1)
    expect(item1.isActive).toBe(true)
    expect(item2.isActive).toBe(false)

    store.activeItem(item2)
    expect(store.activeItem()).toBe(item2)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(true)

    store.activeItem(null)
    expect(store.activeItem()).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)
})

test("cascading active state (form 2)", function () {
    const Store = function () {
        const _this = this
        m.extendObservable(this, { activeItem: null })

        m.autorun(function () {
            if (_this._activeItem === _this.activeItem) return
            if (_this._activeItem) _this._activeItem.isActive = false
            _this._activeItem = _this.activeItem
            if (_this._activeItem) _this._activeItem.isActive = true
        })
    }

    const Item = function () {
        m.extendObservable(this, { isActive: false })
    }

    const store = new Store()
    const item1 = new Item(),
        item2 = new Item()
    expect(store.activeItem).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)

    store.activeItem = item1
    expect(store.activeItem).toBe(item1)
    expect(item1.isActive).toBe(true)
    expect(item2.isActive).toBe(false)

    store.activeItem = item2
    expect(store.activeItem).toBe(item2)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(true)

    store.activeItem = null
    expect(store.activeItem).toBe(null)
    expect(item1.isActive).toBe(false)
    expect(item2.isActive).toBe(false)
})

test("emulate rendering", function () {
    let renderCount = 0

    const Component = function (props) {
        this.props = props
    }
    Component.prototype.destroy = function () {
        if (this.handler) {
            this.handler()
            this.handler = null
        }
    }

    Component.prototype.render = function () {
        const _this = this

        if (this.handler) {
            this.handler()
            this.handler = null
        }
        this.handler = m.autorun(function () {
            if (!_this.props.data.title) _this.props.data.title = "HELLO"
            renderCount++
        })
    }

    const data = {}
    m.extendObservable(data, { title: null })
    const component = new Component({ data: data })
    expect(renderCount).toBe(0)

    component.render()
    expect(renderCount).toBe(1)

    data.title = "WORLD"
    expect(renderCount).toBe(2)

    data.title = null
    // Note that this causes two invalidations
    // however, the real mobx-react binding optimizes this as well
    // see mobx-react #12, so maybe this ain't the best test
    expect(renderCount).toBe(4)

    data.title = "WORLD"
    expect(renderCount).toBe(5)

    component.destroy()
    data.title = "HELLO"
    expect(renderCount).toBe(5)
})

test("efficient selection", function () {
    function Item(value) {
        m.extendObservable(this, {
            selected: false,
            value: value
        })
    }

    function Store() {
        this.prevSelection = null
        m.extendObservable(this, {
            selection: null,
            items: [new Item(1), new Item(2), new Item(3)]
        })
        m.autorun(() => {
            if (this.previousSelection === this.selection) return true // converging condition
            if (this.previousSelection) this.previousSelection.selected = false
            if (this.selection) this.selection.selected = true
            this.previousSelection = this.selection
        })
    }

    const store = new Store()

    expect(store.selection).toBe(null)
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(0)

    store.selection = store.items[1]
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(1)
    expect(store.selection).toBe(store.items[1])
    expect(store.items[1].selected).toBe(true)

    store.selection = store.items[2]
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(1)
    expect(store.selection).toBe(store.items[2])
    expect(store.items[2].selected).toBe(true)

    store.selection = null
    expect(
        store.items.filter(function (i) {
            return i.selected
        }).length
    ).toBe(0)
    expect(store.selection).toBe(null)
})



================================================
FILE: packages/mobx/__tests__/v5/base/decorate.js
================================================
// @ts-check
// Why @ts-check?

import {
    observable,
    computed,
    autorun,
    action,
    isObservableObject,
    isObservable,
    isObservableProp,
    isComputedProp,
    isAction,
    makeObservable
} from "../../../src/mobx"

// @ts-ignore
import { primitive, serialize, deserialize, createModelSchema } from "serializr"

test("throws on undeclared prop", () => {
    class Box {
        constructor() {
            makeObservable(this, {
                // @ts-ignore
                notExisting: true
            })
        }
    }

    expect(() => {
        new Box()
    }).toThrow(/Field not found/)
})

test("decorate should work", function () {
    class Box {
        // @ts-ignore
        uninitialized
        height = 20
        sizes = [2]
        someFunc = function () {
            return 2
        }
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        }
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
        constructor() {
            makeObservable(this, {
                uninitialized: observable.ref,
                height: observable,
                sizes: observable,
                someFunc: observable,
                width: computed,
                addSize: action
            })

            this.undeclared = 1
        }
    }

    const box = new Box()
    expect(isObservableObject(box)).toBe(true)
    expect(box.uninitialized).toBe(undefined)
    expect(box.height).toBe(20)
    expect(isObservableProp(box, "uninitialized")).toBe(true)
    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "width")).toBe(true)
    expect(isAction(box.addSize)).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
    box.height = 10
    expect(ar.slice()).toEqual([40, 20])
    box.sizes.push(3, 4)
    expect(ar.slice()).toEqual([40, 20, 60])
    box.someFunc = () => 7
    expect(ar.slice()).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
    box.undeclared = 2 // not observable, doesn't trigger anything
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])

    const box2 = new Box()
    expect(box2.width).toBe(40) // no shared state!
})

test("decorate should work with plain object", function () {
    const box = {
        /** @type {boolean | undefined} */
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    makeObservable(box, {
        uninitialized: observable,
        height: observable,
        sizes: observable,
        someFunc: observable,
        width: computed,
        addSize: action
    })
    box.undeclared = 1

    expect(isObservableObject(box)).toBe(true)
    expect(box.uninitialized).toBe(undefined)
    expect(box.height).toBe(20)
    expect(isObservableProp(box, "uninitialized")).toBe(true)
    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "width")).toBe(true)
    expect(isAction(box.addSize)).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
    box.height = 10
    expect(ar.slice()).toEqual([40, 20])
    box.sizes.push(3, 4)
    expect(ar.slice()).toEqual([40, 20, 60])
    box.someFunc = () => 7
    expect(ar.slice()).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
    box.undeclared = 2 // not observable, doesn't trigger anything
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
})

// 21.12.2020 @urugator:
// Copying props from prototype to instance and making them observable doesn't make much sense.
// Probably we shouldn't support this. TODO@major
test("decorate should work with Object.create", function () {
    const Box = {
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    const box = Object.create(Box)
    makeObservable(box, {
        uninitialized: observable,
        height: observable,
        sizes: observable,
        someFunc: observable,
        width: computed,
        addSize: action
    })
    box.undeclared = 1

    expect(isObservableObject(box)).toBe(true)
    expect(box.uninitialized).toBe(undefined)
    expect(box.height).toBe(20)
    expect(isObservableProp(box, "uninitialized")).toBe(true)
    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "width")).toBe(true)
    expect(isAction(box.addSize)).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
    box.height = 10
    expect(ar.slice()).toEqual([40, 20])
    box.sizes.push(3, 4)
    expect(ar.slice()).toEqual([40, 20, 60])
    box.someFunc = () => 7
    expect(ar.slice()).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
    box.undeclared = 2 // not observable, doesn't trigger anything
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
})

test("decorate should work with constructor function", function () {
    function Box() {
        this.uninitialized = undefined
        this.height = 20
        Object.defineProperty(this, "width", {
            configurable: true,
            enumerable: false,
            get() {
                /** @type {Box} */
                const t /** @type {any} */ = this

                return (
                    // @ts-ignore
                    t.undeclared *
                    t.height *
                    t.sizes.length *
                    t.someFunc() *
                    (t.uninitialized ? 2 : 1)
                )
            }
        })
        this.sizes = [2]
        this.someFunc = function () {
            return 2
        }
        this.addSize = function () {
            this.sizes.push(3)
            this.sizes.push(4)
        }
        makeObservable(this, {
            uninitialized: observable,
            height: observable,
            sizes: observable,
            someFunc: observable,
            // @ts-ignore TS is unable to see property through defineProperty
            width: computed,
            addSize: action
        })
    }

    const box = new Box()
    // @ts-ignore
    box.undeclared = 1

    expect(isObservableObject(box)).toBe(true)
    expect(box.uninitialized).toBe(undefined)
    expect(box.height).toBe(20)
    expect(isObservableProp(box, "uninitialized")).toBe(true)
    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "width")).toBe(true)
    expect(isAction(box.addSize)).toBe(true)

    const ar = []

    autorun(() => {
        // @ts-ignore
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
    box.height = 10
    expect(ar.slice()).toEqual([40, 20])
    box.sizes.push(3, 4)
    expect(ar.slice()).toEqual([40, 20, 60])
    box.someFunc = () => 7
    expect(ar.slice()).toEqual([40, 20, 60, 210])
    box.uninitialized = true
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])

    const box2 = new Box()
    // @ts-ignore
    box2.undeclared = 1
    // @ts-ignore
    expect(box2.width).toBe(40) // no shared state!
})

test("decorate should work with inheritance through Object.create", () => {
    const P = {
        x: 3
    }
    makeObservable(P, {
        x: observable
    })

    const child1 = Object.create(P)
    expect(child1.x).toBe(3)
    child1.x = 4 // this modifies the prop on P, since that is what was made observable
    expect(child1.x).toBe(4)
    const child2 = Object.create(P)
    expect(child2.x).toBe(4)
    child2.x = 5
    expect(child2.x).toBe(5)
    expect(child1.x).toBe(5)
})

test("decorator requires correct types", function () {
    const obj = {
        x: 0,
        get y() {
            return 0
        }
    }

    expect(() => {
        makeObservable(obj, {
            x: computed
        })
    }).toThrow(/can only be used on getter\(\+setter\) properties/)

    expect(() => {
        makeObservable(obj, {
            x: action
        })
    }).toThrow(/can only be used on properties with a function value/)

    expect(() => {
        makeObservable(obj, {
            y: observable
        })
    }).toThrow(/cannot be used on getter\/setter properties/)
})

test("decorate a property with two decorators", function () {
    let updatedByAutorun

    class Obj {
        x = null

        constructor() {
            makeObservable(this, {
                x: observable
            })
        }
    }
    createModelSchema(Obj, {
        x: primitive()
    })

    const obj = deserialize(Obj, {
        x: 0
    })

    const d = autorun(() => {
        updatedByAutorun = obj.x
    })

    expect(isObservableProp(obj, "x")).toBe(true)
    expect(updatedByAutorun).toEqual(0)
    // @ts-ignore
    obj.x++

    expect(obj.x).toEqual(1)
    expect(updatedByAutorun).toEqual(1)
    expect(serialize(obj).x).toEqual(1)

    d()
})

test("expect warning for missing decorated getter", () => {
    const obj = {
        x: 0,
        get y() {
            return 1
        }
    }

    expect(() => {
        makeObservable(obj, {
            x: observable,
            y: computed,
            // @ts-expect-error
            z: computed
        })
    }).toThrow(/Field not found/)
})



================================================
FILE: packages/mobx/__tests__/v5/base/errorhandling.js
================================================
const mobx = require("../../../src/mobx.ts")
const m = mobx
const utils = require("../../v5/utils/test-utils")

const { observable, computed, $mobx, autorun } = mobx

const voidObserver = function () {}

function checkGlobalState() {
    const gs = mobx._getGlobalState()
    expect(gs.isRunningReactions).toBe(false)
    expect(gs.trackingDerivation).toBe(null)
    expect(gs.inBatch).toBe(0)
    expect(gs.allowStateChanges).toBe(!gs.strictMode)
    expect(gs.pendingUnobservations.length).toBe(0)
}

test("exception1", function () {
    const a = computed(function () {
        throw "hoi"
    })
    expect(() => a.get()).toThrow(/hoi/)
    checkGlobalState()
})

test("exceptions in computed values can be recovered from", () => {
    const a = observable({
        x: 1,
        get y() {
            if (this.x === 2) throw "Uhoh"
            return this.x * 2
        }
    })

    expect(a.y).toBe(2)
    a.x = 2

    expect(() => a.y).toThrowError(/Uhoh/)

    checkGlobalState()

    a.x = 3
    expect(a.y).toBe(6)
    checkGlobalState()
})

test("exception when starting autorun can be recovered from", () => {
    let b = undefined
    const a = observable({
        x: 2,
        get y() {
            if (this.x === 2) throw "Uhoh"
            return this.x * 2
        }
    })

    utils.consoleError(() => {
        mobx.autorun(() => {
            b = a.y
        })
    }, /Uhoh/)
    expect(b).toBe(undefined)
    checkGlobalState()
    a.x = 3
    expect(b).toBe(6)
    checkGlobalState()
    expect(mobx.getAtom(a, "y").observers_.size).toBe(1)
})

test("exception in autorun can be recovered from", () => {
    let b = undefined
    const a = observable({
        x: 1,
        get y() {
            if (this.x === 2) throw "Uhoh"
            return this.x * 2
        }
    })

    const d = mobx.autorun(() => {
        b = a.y
    })
    expect(a.y).toBe(2)
    expect(b).toBe(2)
    expect(mobx.getAtom(a, "y").observers_.size).toBe(1)

    utils.consoleError(() => {
        a.x = 2
    }, /Uhoh/)

    // exception is also rethrown to each consumer
    expect(() => {
        expect(a.y).toBe(2) // old cached value!
    }).toThrowError(/Uhoh/)
    expect(mobx.getAtom(a, "y").observers_.size).toBe(1)

    expect(b).toBe(2)
    checkGlobalState()

    a.x = 3
    expect(a.y).toBe(6)
    expect(b).toBe(6)
    checkGlobalState()
    expect(mobx.getAtom(a, "y").observers_.size).toBe(1)
    d()
    expect(mobx.getAtom(a, "y").observers_.size).toBe(0)
})

test("multiple autoruns with exceptions are handled correctly", () => {
    const a = mobx.observable.box(1)
    const values = []
    const d1 = mobx.autorun(() => values.push("a" + a.get()))
    const d2 = mobx.autorun(() => {
        if (a.get() === 2) throw /Uhoh/
        values.push("b" + a.get())
    })
    const d3 = mobx.autorun(() => values.push("c" + a.get()))

    expect(values).toEqual(["a1", "b1", "c1"])
    values.splice(0)

    utils.consoleError(() => a.set(2), /Uhoh/)
    checkGlobalState()

    expect(values.sort()).toEqual(["a2", "c2"]) // order is irrelevant
    values.splice(0)

    a.set(3)
    expect(values.sort()).toEqual(["a3", "b3", "c3"]) // order is irrelevant

    checkGlobalState()
    d1()
    d2()
    d3()
})

test("deny state changes in views", function () {
    const x = observable.box(3)
    const z = observable.box(5)
    const y = computed(function () {
        z.set(6)
        return x.get() * x.get()
    })

    expect(() => {
        y.get() // modifying unobserved values in computeds is allowed, so that new observables can be created and returned
    }).not.toThrow()

    m.reaction(
        () => z.get(),
        () => {}
    )
    expect(
        utils.grabConsole(() => {
            y.get()
        })
    ).toMatchInlineSnapshot(
        `"<STDOUT> [MobX] Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ObservableValue@15"`
    )

    checkGlobalState()
})

test("allow state changes in autorun", function () {
    const x = observable.box(3)
    const z = observable.box(3)

    m.autorun(function () {
        if (x.get() !== 3) z.set(x.get())
    })

    expect(x.get()).toBe(3)
    expect(z.get()).toBe(3)

    x.set(5) // autorunneres are allowed to change state

    expect(x.get()).toBe(5)
    expect(z.get()).toBe(5)

    expect(mobx._isComputingDerivation()).toBe(false)
    checkGlobalState()
})

test("deny array change in view", function (done) {
    const x = observable.box(3)
    const z = observable([])
    const y = computed(function () {
        z.push(3)
        return x.get() * x.get()
    })

    expect(function () {
        y.get() // modifying z is allowed if nobody is observing
    }).not.toThrow()
    m.reaction(
        () => z.length,
        () => {}
    )

    expect(
        utils.grabConsole(function () {
            y.get()
        })
    ).toMatchInlineSnapshot(
        `"<STDOUT> [MobX] Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ObservableArray@22"`
    )

    expect(z.slice()).toEqual([3, 3])
    expect(mobx._isComputingDerivation()).toBe(false)

    checkGlobalState()
    done()
})

test("allow array change in autorun", function () {
    const x = observable.box(3)
    const z = observable([])
    m.autorun(function () {
        if (x.get() > 4) z.push(x.get())
    })

    x.set(5)
    x.set(6)
    expect(z.slice()).toEqual([5, 6])
    x.set(2)
    expect(z.slice()).toEqual([5, 6])

    expect(mobx._isComputingDerivation()).toBe(false)
    checkGlobalState()
})

test("throw error if modification loop", function () {
    const x = observable.box(3)
    m.autorun(function () {
        x.set(x.get() + 1) // is allowed to throw, but doesn't as the observables aren't bound yet during first execution
    })
    utils.consoleError(() => {
        x.set(5)
    }, /Reaction doesn't converge to a stable state/)
    checkGlobalState()
})

test("cycle1", function () {
    const p = computed(function () {
        return p.get() * 2
    }) // thats a cycle!
    utils.consoleError(() => {
        mobx.observe(p, voidObserver, true)
    }, /Cycle detected/)
    checkGlobalState()
})

test("cycle2", function () {
    const a = computed(function () {
        return b.get() * 2
    })
    const b = computed(function () {
        return a.get() * 2
    })
    expect(() => {
        b.get()
    }).toThrow(/Cycle detected/)
    checkGlobalState()
})

test("cycle3", function () {
    const p = computed(function () {
        return p.get() * 2
    })
    expect(() => {
        p.get()
    }).toThrow(/Cycle detected/)
    checkGlobalState()
})

test("cycle4", function () {
    const z = observable.box(true)
    const a = computed(function () {
        return z.get() ? 1 : b.get() * 2
    })
    const b = computed(function () {
        return a.get() * 2
    })

    m.observe(b, voidObserver)
    expect(1).toBe(a.get())

    utils.consoleError(() => {
        z.set(false) // introduces a cycle!
    }, /Cycle detected/)
    checkGlobalState()
})

test("throws when the max iterations over reactions are done", () => {
    const foo = mobx.observable({
        a: 1
    })

    mobx.autorun(
        () => {
            foo.a
            foo.a = Math.random()
        },
        { name: "bar" }
    )

    utils.consoleError(
        () => foo.a++,
        /Reaction doesn't converge to a stable state after 100 iterations/
    )
    mobx._resetGlobalState()
})

test("issue 86, converging cycles", function () {
    function findIndex(arr, predicate) {
        for (let i = 0, l = arr.length; i < l; i++) if (predicate(arr[i]) === true) return i
        return -1
    }

    const deleteThisId = mobx.observable.box(1)
    const state = mobx.observable({ someArray: [] })
    let calcs = 0

    state.someArray.push({ id: 1, text: "I am 1" })
    state.someArray.push({ id: 2, text: "I am 2" })

    // should delete item 1 in first run, which works fine
    mobx.autorun(() => {
        calcs++
        const i = findIndex(state.someArray, item => item.id === deleteThisId.get())
        state.someArray.remove(state.someArray[i])
    })

    expect(state.someArray.length).toBe(1) // should be 1, which prints fine
    expect(calcs).toBe(1)
    deleteThisId.set(2) // should delete item 2, but it errors on cycle

    expect(state.someArray.length).toBe(0) // should be 0, which never prints
    expect(calcs).toBe(3)

    checkGlobalState()
})

test("slow converging cycle", function () {
    const x = mobx.observable.box(1)
    let res = -1
    mobx.autorun(() => {
        if (x.get() === 100) res = x.get()
        else x.set(x.get() + 1)
    })

    // ideally the outcome should be 100 / 100.
    // autorun is only an observer of x *after* the first run, hence the initial outcome is not as expected..
    // is there a practical use case where such a pattern would be expected?
    // maybe we need to immediately register observers on the observable? but that would be slow....
    // or detect cycles and re-run the autorun in that case once?
    expect(x.get()).toBe(2)
    expect(res).toBe(-1)

    x.set(7)
    expect(x.get()).toBe(100)
    expect(res).toBe(100)

    checkGlobalState()
})

test("error handling assistence ", function (done) {
    const baseError = console.error
    const baseWarn = console.warn
    const errors = [] // logged errors
    const warns = [] // logged warns
    const values = [] // produced errors
    const thrown = [] // list of actually thrown exceptons

    console.error = function (msg) {
        errors.push(msg)
    }
    console.warn = function (msg) {
        warns.push(msg)
    }

    const a = observable.box(3)
    const b = computed(function () {
        if (a.get() === 42) throw "should not be 42"
        return a.get() * 2
    })

    m.autorun(function () {
        values.push(b.get())
    })

    a.set(2)
    try {
        a.set(42)
    } catch (e) {
        thrown.push(e)
    }
    a.set(7)

    // Test recovery
    setTimeout(function () {
        a.set(4)
        try {
            a.set(42)
        } catch (e) {
            thrown.push(e)
        }

        expect(values).toEqual([6, 4, 14, 8])
        expect(errors.length).toBe(2)
        expect(warns.length).toBe(0)
        expect(thrown.length).toBe(0) // Mobx doesn't propagate throws from reactions

        console.error = baseError
        console.warn = baseWarn

        checkGlobalState()
        done()
    }, 10)
})

test("236 - cycles", () => {
    const Parent = function () {
        m.extendObservable(this, {
            children: [],
            get total0() {
                // Sum "value" of children of kind "0"
                return this.children
                    .filter(c => c.kind === 0)
                    .map(c => c.value)
                    .reduce((a, b) => a + b, 0)
            },
            get total1() {
                // Sum "value" of children of kind "1"
                return this.children
                    .filter(c => c.kind === 1)
                    .map(c => c.value)
                    .reduce((a, b) => a + b, 0)
            }
        })
    }

    const Child = function (parent, kind) {
        this.parent = parent
        m.extendObservable(this, {
            kind: kind,
            get value() {
                if (this.kind === 0) {
                    return 3
                } else {
                    // Value of child of kind "1" depends on the total value for all children of kind "0"
                    return this.parent.total0 * 2
                }
            }
        })
    }

    const parent = new Parent()
    parent.children.push(new Child(parent, 0))
    parent.children.push(new Child(parent, 0))
    parent.children.push(new Child(parent, 0))

    const msg = []
    m.autorun(() => {
        msg.push("total0:", parent.total0, "total1:", parent.total1)
    })
    // So far, so good: total0: 9 total1: 0
    expect(msg).toEqual(["total0:", 9, "total1:", 0])
    parent.children[0].kind = 1
    expect(msg).toEqual(["total0:", 9, "total1:", 0, "total0:", 6, "total1:", 12])

    checkGlobalState()
})

test("peeking inside erroring computed value doesn't bork (global) state", () => {
    const a = mobx.observable.box(1)
    const b = mobx.computed(() => {
        a.get()
        throw "chocolademelk"
    })

    expect(() => {
        b.get()
    }).toThrowError(/chocolademelk/)

    expect(a.isPendingUnobservation).toBe(false)
    expect(a.observers_.size).toBe(0)
    expect(a.diffValue).toBe(0)
    expect(a.lowestObserverState_).toBe(-1)
    expect(a.hasUnreportedChange_).toBe(false)
    expect(a.value_).toBe(1)

    expect(b.dependenciesState_).toBe(-1) // NOT_TRACKING
    expect(b.observing_.length).toBe(0)
    expect(b.newObserving_).toBe(null)
    expect(b.isPendingUnobservation).toBe(false)
    expect(b.observers_.size).toBe(0)
    expect(b.diffValue).toBe(0)
    expect(b.lowestObserverState_).toBe(0)
    expect(b.unboundDepsCount_).toBe(0)
    expect(() => {
        b.get()
    }).toThrowError(/chocolademelk/)
    expect(b.isComputing).toBe(false)

    checkGlobalState()
})

describe("peeking inside autorun doesn't bork (global) state", () => {
    let r = -1
    const a = mobx.observable.box(1)
    const b = mobx.computed(() => {
        const res = (r = a.get())
        if (res === 2) throw "chocolademelk"
        return res
    })
    const d = mobx.autorun(() => b.get())
    const c = d[$mobx]

    expect(b.get()).toBe(1)
    expect(r).toBe(1)

    test("it should update correctly initially", () => {
        expect(a.isPendingUnobservation).toBe(false)
        expect(a.observers_.size).toBe(1)
        expect(a.diffValue).toBe(0)
        expect(a.lowestObserverState_).toBe(-1)
        expect(a.hasUnreportedChange_).toBe(false)
        expect(a.value_).toBe(1)

        expect(b.dependenciesState_).toBe(0)
        expect(b.observing_.length).toBe(1)
        expect(b.newObserving_).toBe(null)
        expect(b.isPendingUnobservation).toBe(false)
        expect(b.observers_.size).toBe(1)
        expect(b.diffValue).toBe(0)
        expect(b.lowestObserverState_).toBe(0)
        expect(b.unboundDepsCount_).toBe(1) // value is always the last bound amount of observers
        expect(b.value_).toBe(1)
        expect(b.isComputing).toBe(false)

        expect(c.dependenciesState_).toBe(0)
        expect(c.observing_.length).toBe(1)
        expect(c.newObserving_).toBe(null)
        expect(c.diffValue).toBe(0)
        expect(c.unboundDepsCount_).toBe(1)
        expect(c.isDisposed).toBe(false)
        expect(c.isScheduled).toBe(false)
        expect(c.isTrackPending).toBe(false)
        expect(c.isRunning).toBe(false)
        checkGlobalState()
    })

    test("it should not break internal consistency when exception occurred", () => {
        // Trigger exception
        utils.consoleError(() => {
            a.set(2)
        }, /chocolademelk/)
        expect(r).toBe(2)

        expect(a.isPendingUnobservation).toBe(false)
        expect(a.observers_.size).toBe(1)
        expect(a.diffValue).toBe(0)
        expect(a.lowestObserverState_).toBe(0)
        expect(a.hasUnreportedChange_).toBe(false)
        expect(a.value_).toBe(2)

        expect(b.dependenciesState_).toBe(0) // up to date (for what it's worth)
        expect(b.observing_.length).toBe(1)
        expect(b.newObserving_).toBe(null)
        expect(b.isPendingUnobservation).toBe(false)
        expect(b.observers_.size).toBe(1)
        expect(b.diffValue).toBe(0)
        expect(b.lowestObserverState_).toBe(0)
        expect(b.unboundDepsCount_).toBe(1)
        expect(b.isComputing).toBe(false)
        expect(() => b.get()).toThrowError(/chocolademelk/)

        expect(c.dependenciesState_).toBe(0)
        expect(c.observing_.length).toBe(1)
        expect(c.newObserving_).toBe(null)
        expect(c.diffValue).toBe(0)
        expect(c.unboundDepsCount_).toBe(1)
        expect(c.isDisposed).toBe(false)
        expect(c.isScheduled).toBe(false)
        expect(c.isTrackPending).toBe(false)
        expect(c.isRunning).toBe(false)
        checkGlobalState()
    })

    // Trigger a new change, will this recover?
    // is this actually a supported case or should we just give up?
    test("it should recover from errors", () => {
        a.set(3)
        expect(r).toBe(3)

        expect(a.isPendingUnobservation).toBe(false)
        expect(a.observers_.size).toBe(1)
        expect(a.diffValue).toBe(0)
        expect(a.lowestObserverState_).toBe(0)
        expect(a.hasUnreportedChange_).toBe(false)
        expect(a.value_).toBe(3)

        expect(b.dependenciesState_).toBe(0) // up to date
        expect(b.observing_.length).toBe(1)
        expect(b.newObserving_).toBe(null)
        expect(b.isPendingUnobservation).toBe(false)
        expect(b.observers_.size).toBe(1)
        expect(b.diffValue).toBe(0)
        expect(b.lowestObserverState_).toBe(0)
        expect(b.unboundDepsCount_).toBe(1)
        expect(b.value_).toBe(3)
        expect(b.isComputing).toBe(false)

        expect(c.dependenciesState_).toBe(0)
        expect(c.observing_.length).toBe(1)
        expect(c.newObserving_).toBe(null)
        expect(c.diffValue).toBe(0)
        expect(c.unboundDepsCount_).toBe(1)
        expect(c.isDisposed).toBe(false)
        expect(c.isScheduled).toBe(false)
        expect(c.isTrackPending).toBe(false)
        expect(c.isRunning).toBe(false)

        checkGlobalState()
    })

    test("it should clean up correctly", () => {
        d()

        expect(a.isPendingUnobservation).toBe(false)
        expect(a.observers_.size).toBe(0)
        expect(a.diffValue).toBe(0)
        expect(a.lowestObserverState_).toBe(0)
        expect(a.hasUnreportedChange_).toBe(false)
        expect(a.value_).toBe(3)

        expect(b.dependenciesState_).toBe(-1) // not tracking
        expect(b.observing_.length).toBe(0)
        expect(b.newObserving_).toBe(null)
        expect(b.isPendingUnobservation).toBe(false)
        expect(b.observers_.size).toBe(0)
        expect(b.diffValue).toBe(0)
        expect(b.lowestObserverState_).toBe(0)
        expect(b.unboundDepsCount_).toBe(1)
        expect(b.value_).not.toBe(3)
        expect(b.isComputing).toBe(false)

        expect(c.dependenciesState_).toBe(-1)
        expect(c.observing_.length).toBe(0)
        expect(c.newObserving_).toBe(null)
        expect(c.diffValue).toBe(0)
        expect(c.unboundDepsCount_).toBe(1)
        expect(c.isDisposed).toBe(true)
        expect(c.isScheduled).toBe(false)
        expect(c.isTrackPending).toBe(false)
        expect(c.isRunning).toBe(false)

        expect(b.get()).toBe(3)

        checkGlobalState()
    })
})

test("it should be possible to handle exceptions in reaction", () => {
    utils.supressConsole(() => {
        const errors = []
        const a = mobx.observable.box(1)
        const d = mobx.autorun(
            function () {
                throw a.get()
            },
            {
                onError(e) {
                    errors.push(e)
                }
            }
        )

        a.set(2)
        a.set(3)

        expect(errors).toEqual([1, 2, 3])
        d()

        checkGlobalState()
    })
})

test("it should be possible to handle global errors in reactions", () => {
    utils.supressConsole(() => {
        const a = mobx.observable.box(1)
        const errors = []
        const d2 = mobx.onReactionError(e => errors.push(e))

        const d = mobx.autorun(function () {
            throw a.get()
        })

        a.set(2)
        a.set(3)

        d2()
        a.set(4)

        expect(errors).toEqual([1, 2, 3])
        d()

        checkGlobalState()
    })
})

test("it should be possible to handle global errors in reactions - 2 - #1480", () => {
    utils.supressConsole(() => {
        const a = mobx.observable.box(1)
        const errors = []
        const d2 = mobx.onReactionError(e => errors.push(e))

        const d = mobx.reaction(
            () => a.get(),
            a => {
                if (a >= 2) throw a
            }
        )

        a.set(2)
        a.set(3)

        d2()
        a.set(4)

        expect(errors).toEqual([2, 3])
        d()

        checkGlobalState()
    })
})

test("global error handling will be skipped when using disableErrorBoundaries - 1", () => {
    utils.supressConsole(() => {
        mobx.configure({ disableErrorBoundaries: true })
        try {
            mobx.observable.box(1)

            expect(() => {
                mobx.autorun(function () {
                    throw "OOPS"
                })
            }).toThrowError(/OOPS/)
        } finally {
            mobx.configure({ disableErrorBoundaries: false })
            mobx._resetGlobalState()
        }
    })
})

test("global error handling will be skipped when using disableErrorBoundaries - 2", () => {
    utils.supressConsole(() => {
        mobx.configure({ disableErrorBoundaries: true })
        try {
            const a = mobx.observable.box(1)

            const d = mobx.reaction(
                () => a.get(),
                () => {
                    throw "OOPS"
                }
            )
            expect(() => {
                a.set(2)
            }).toThrowError(/OOPS/)

            d()
        } finally {
            mobx.configure({ disableErrorBoundaries: false })
            mobx._resetGlobalState()
        }
    })
})

test("error in effect of when is properly cleaned up", () => {
    checkGlobalState()

    const b = mobx.observable.box(1)
    utils.supressConsole(() => {
        mobx.when(
            () => b.get() === 2,
            () => {
                throw "OOPS"
            }
        )
        b.set(2)
    })

    checkGlobalState()
})

describe("es5 compat warnings", () => {
    beforeEach(() => {
        mobx.configure({
            useProxies: "ifavailable"
        })
    })

    test("adding / deleting property", () => {
        const x = observable({
            z: 0
        })

        expect(() => {
            x.y = 2
        }).toThrowErrorMatchingInlineSnapshot(
            `"[MobX] MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to add a new observable property through direct assignment. Use 'set' from 'mobx' instead."`
        )

        expect(() => {
            delete x.z
        }).toThrowErrorMatchingInlineSnapshot(
            `"[MobX] MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to delete properties from an observable object. Use 'remove' from 'mobx' instead."`
        )
    })

    test("iterating props", () => {
        const x = observable({
            z: 0
        })

        expect(() => {
            "z" in x
        }).not.toThrowError()

        let e
        autorun(() => {
            try {
                "z" in x
            } catch (err) {
                e = err
            }
        })
        expect(e).toMatchInlineSnapshot(
            `[Error: [MobX] MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.]`
        )

        e = undefined

        expect(() => {
            Object.getOwnPropertyNames(x)
        }).not.toThrowError()
        autorun(() => {
            try {
                Object.getOwnPropertyNames(x)
            } catch (err) {
                e = err
            }
        })
        expect(e).toMatchInlineSnapshot(
            `[Error: [MobX] MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.]`
        )
    })

    afterEach(() => {
        mobx._resetGlobalState()
        mobx.configure({
            useProxies: "always"
        })
    })
})

test("should throw when adding properties in ES5 compat mode", () => {})



================================================
FILE: packages/mobx/__tests__/v5/base/extendObservable.js
================================================
// @ts-check

import {
    action,
    autorun,
    isObservable,
    isObservableProp,
    isComputedProp,
    isAction,
    extendObservable,
    observable,
    reaction
} from "../../../src/mobx"

test("extendObservable should work", function () {
    class Box {
        // @ts-ignore
        uninitialized
        height = 20
        sizes = [2]
        someFunc = function () {
            return 2
        }
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        }
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
        constructor() {
            this.undeclared = 1
        }
    }

    const box = new Box()

    extendObservable(box, {
        height: 20,
        sizes: [2],
        get someFunc() {
            return 2
        },
        width: 40
    })

    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "someFunc")).toBe(true)
    expect(isObservableProp(box, "width")).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
})

test("extendObservable should work with plain object", function () {
    const box = {
        /** @type {boolean | undefined} */
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    box.undeclared = 1

    extendObservable(box, {
        height: 20,
        sizes: [2],
        get someFunc() {
            return 2
        },
        width: 40
    })

    expect(isObservableProp(box, "height")).toBe(true)
    expect(isObservableProp(box, "sizes")).toBe(true)
    expect(isObservable(box.sizes)).toBe(true)
    expect(isObservableProp(box, "someFunc")).toBe(true)
    expect(isComputedProp(box, "someFunc")).toBe(true)
    expect(isObservableProp(box, "width")).toBe(true)

    const ar = []

    autorun(() => {
        ar.push(box.width)
    })

    expect(ar.slice()).toEqual([40])
})

test("extendObservable should apply specified decorators", function () {
    const box = {
        /** @type {boolean | undefined} */
        uninitialized: undefined,
        height: 20,
        sizes: [2],
        someFunc: function () {
            return 2
        },
        get width() {
            return (
                this.undeclared *
                this.height *
                this.sizes.length *
                this.someFunc() *
                (this.uninitialized ? 2 : 1)
            )
        },
        addSize() {
            // @ts-ignore
            this.sizes.push([3])
            // @ts-ignore
            this.sizes.push([4])
        }
    }

    box.undeclared = 1
    extendObservable(
        box,
        {
            someFunc: function () {
                return 2
            }
        },
        // @ts-ignore
        { someFunc: action }
    )

    expect(isAction(box.someFunc)).toBe(true)
    expect(box.someFunc()).toEqual(2)
})

test("extendObservable notifies about added keys", () => {
    let reactionCalled = false
    const o = observable({})
    const disposeReaction = reaction(
        () => Object.keys(o),
        () => (reactionCalled = true)
    )
    extendObservable(o, { x: 0 })
    expect(reactionCalled).toBe(true)
    disposeReaction()
})



================================================
FILE: packages/mobx/__tests__/v5/base/extras.js
================================================
const mobx = require("../../../src/mobx.ts")
const m = mobx

const { $mobx } = mobx

test("treeD", function () {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0
    const a = m.observable.box(3)
    const aName = "ObservableValue@1"

    const dtree = m.getDependencyTree
    expect(dtree(a)).toEqual({
        name: aName
    })

    const b = m.computed(() => a.get() * a.get())
    const bName = "ComputedValue@2"
    expect(dtree(b)).toEqual({
        name: bName
        // no dependencies yet, since it isn't observed yet
    })

    const c = m.autorun(() => b.get())
    const cName = "Autorun@3"
    expect(dtree(c[$mobx])).toEqual({
        name: cName,
        dependencies: [
            {
                name: bName,
                dependencies: [
                    {
                        name: aName
                    }
                ]
            }
        ]
    })

    expect(aName !== bName).toBeTruthy()
    expect(bName !== cName).toBeTruthy()

    expect(m.getObserverTree(a)).toEqual({
        name: aName,
        observers: [
            {
                name: bName,
                observers: [
                    {
                        name: cName
                    }
                ]
            }
        ]
    })

    const x = mobx.observable.map({ temperature: 0 })
    const d = mobx.autorun(function () {
        Array.from(x.keys())
        if (x.has("temperature")) x.get("temperature")
        x.has("absent")
    })

    expect(m.getDependencyTree(d[$mobx])).toEqual({
        name: "Autorun@5",
        dependencies: [
            {
                name: "ObservableMap@4.keys()"
            },
            {
                name: "ObservableMap@4.temperature?"
            },
            {
                name: "ObservableMap@4.temperature"
            },
            {
                name: "ObservableMap@4.absent?"
            }
        ]
    })
})

test("names", function () {
    m._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0

    const struct = {
        x: "ObservableValue@1",
        y: {
            z: 7
        },
        ar: [
            4,
            {
                w: 5
            }
        ]
    }

    const rstruct = m.observable(struct)
    m.extendObservable(rstruct.y, { a: { b: 2 } })
    rstruct.ar.push({ b: 2 })
    rstruct.ar.push([])
    expect(rstruct[$mobx].values_.get("x").name_).toBe("ObservableObject@1.x")
    expect(rstruct[$mobx].values_.get("y").name_).toBe("ObservableObject@1.y")
    expect(rstruct.y[$mobx].values_.get("z").name_).toBe("ObservableObject@1.y.z")
    expect(rstruct[$mobx].values_.get("ar").name_).toBe("ObservableObject@1.ar")
    expect(rstruct.ar[$mobx].atom_.name_).toBe("ObservableObject@1.ar")
    expect(rstruct.ar[1][$mobx].values_.get("w").name_).toBe("ObservableObject@1.ar[..].w")
    expect(rstruct.y.a[$mobx].values_.get("b").name_).toBe("ObservableObject@1.y.a.b")
    expect(rstruct.ar[2][$mobx].values_.get("b").name_).toBe("ObservableObject@1.ar[..].b")

    const d = m.autorun(function () {})
    expect(d[$mobx].name_).toBeTruthy()

    expect(m.autorun(function namedFunction() {})[$mobx].name_).toBe("namedFunction")

    expect(m.computed(function () {})).toBeTruthy()

    expect(m.computed(function namedFunction() {}).name_).toBe("namedFunction")

    function Task() {
        m.extendObservable(this, {
            title: "test"
        })
    }

    const task = new Task()
    expect(task[$mobx].name_).toBe("Task@4")
    expect(task[$mobx].values_.get("title").name_).toBe("Task@4.title")
})

function stripTrackerOutput(output) {
    return output.map(function (i) {
        if (Array.isArray(i)) return stripTrackerOutput(i)
        delete i.object
        delete i.time
        delete i.fn
        return i
    })
}

test("spy 1", function () {
    m._resetGlobalState()
    const lines = []

    const a = m.observable.box(3)
    const b = m.computed(function () {
        return a.get() * 2
    })
    m.autorun(function () {
        b.get()
    })
    const stop = m.spy(function (line) {
        lines.push(line)
    })

    a.set(4)
    stop()
    a.set(5)
    expect(stripTrackerOutput(lines)).toMatchSnapshot()
})

test("get atom", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()

    function atom(thing, prop) {
        return mobx.getAtom(thing, prop).constructor.name_
    }

    const ovClassName = mobx.observable.box(3).constructor.name_
    const atomClassName = mobx.createAtom("test").constructor.name_
    // const reactionClassName = mobx.Reaction.name_

    expect(atom(a)).toBe(ovClassName)

    expect(atom(b, "a")).toBe(ovClassName)
    expect(() => atom(b)).toThrowError(/please specify a property/)
    expect(() => atom(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )

    expect(atom(c)).toBe(atomClassName) // returns ke, "bla".constructor, === "Atomys
    expect(atom(c, "a")).toBe(ovClassName) // returns ent, "bla".constructor, === "Atomry
    expect(atom(c, "b")).toBe(ovClassName) // returns has entry (see autoru, "bla", "Atomn)
    expect(() => atom(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(atom(d)).toBe(atomClassName)
    expect(() => atom(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(atom(e)).toBe(mobx.computed(() => {}).constructor.name_)
    expect(atom(f)).toBe(mobx.Reaction.name_)

    expect(() => atom(g)).toThrowError(/please specify a property/)
    expect(atom(g, "a")).toBe(ovClassName)

    f()
})

test("get debug name", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()

    function name(thing, prop) {
        return mobx.getDebugName(thing, prop)
    }

    expect(name(a)).toBe("ObservableValue@1")

    expect(name(b, "a")).toBe("ObservableObject@2.a")
    expect(() => name(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )

    expect(name(c)).toBe("ObservableMap@3") // returns ke, "bla"ys
    expect(name(c, "a")).toBe("ObservableMap@3.a") // returns ent, "bla"ry
    expect(name(c, "b")).toBe("ObservableMap@3.b?") // returns has entry (see autoru, "bla"n)
    expect(() => name(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(name(d)).toBe("ObservableArray@4")
    expect(() => name(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(name(e)).toBe("ComputedValue@5")
    expect(name(f)).toBe("Autorun@6")

    expect(name(g)).toBe("Clazz@7")
    expect(name(g, "a")).toBe("Clazz@7.a")

    f()
})

test("get administration", function () {
    mobx._resetGlobalState()
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    function Clazz() {
        mobx.extendObservable(this, {
            a: 17
        })
    }

    const a = mobx.observable.box(3)
    const b = mobx.observable({ a: 3 })
    const c = mobx.observable.map({ a: 3 })
    const d = mobx.observable([1, 2])
    const e = mobx.computed(() => 3)
    const f = mobx.autorun(() => c.has("b"))
    const g = new Clazz()
    const h = {}
    mobx.extendObservable(h, { a: 3 })

    function adm(thing, prop) {
        return mobx._getAdministration(thing, prop).constructor.name_
    }

    const ovClassName = mobx.observable.box(3).constructor.name_
    const mapClassName = mobx.observable.map().constructor.name_

    expect(adm(a)).toBe(ovClassName)

    expect(adm(b, "a")).toBe(ovClassName)
    expect(adm(b)).toBe(b[$mobx].constructor.name_)
    expect(() => adm(b, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@2'/
    )
    expect(adm(h, "a")).toBe(ovClassName)
    expect(adm(h)).toBe(h[$mobx].constructor.name_)
    expect(() => adm(h, "b")).toThrowError(
        /no observable property 'b' found on the observable object 'ObservableObject@8'/
    )

    expect(adm(c)).toBe(mapClassName)
    expect(adm(c, "a")).toBe(ovClassName)
    expect(adm(c, "b")).toBe(ovClassName)
    expect(() => adm(c, "c")).toThrowError(
        /the entry 'c' does not exist in the observable map 'ObservableMap@3'/
    )

    expect(adm(d)).toBe(d[$mobx].constructor.name_)
    expect(() => adm(d, 0)).toThrowError(/It is not possible to get index atoms from arrays/)

    expect(adm(e)).toBe(mobx.computed(() => {}).constructor.name_)
    expect(adm(f)).toBe(mobx.Reaction.name_)

    expect(adm(g)).toBe(h[$mobx].constructor.name_)
    expect(adm(g, "a")).toBe(ovClassName)
})

test("onBecome(Un)Observed simple", () => {
    const x = mobx.observable.box(3)
    const events = []

    mobx.onBecomeObserved(x, () => {
        events.push("x observed")
    })
    mobx.onBecomeUnobserved(x, () => {
        events.push("x unobserved")
    })

    expect(events.length).toBe(0) // nothing happened yet
    x.get()
    expect(events.length).toBe(0) // nothing happened yet
    x.set(4)
    expect(events.length).toBe(0) // nothing happened yet

    const d5 = mobx.reaction(
        () => x.get(),
        () => {}
    )
    expect(events.length).toBe(1)
    expect(events).toEqual(["x observed"])

    d5()
    expect(events.length).toBe(2)
    expect(events).toEqual(["x observed", "x unobserved"])
})

test("onBecome(Un)Observed - less simple", () => {
    const x = mobx.observable({
        a: 3,
        get b() {
            return this.a * 2
        }
    })
    const events = []

    const d1 = mobx.onBecomeObserved(x, "a", () => {
        events.push("a observed")
    })
    const d2 = mobx.onBecomeUnobserved(x, "a", () => {
        events.push("a unobserved")
    })
    const d3 = mobx.onBecomeObserved(x, "b", () => {
        events.push("b observed")
    })
    const d4 = mobx.onBecomeUnobserved(x, "b", () => {
        events.push("b unobserved")
    })

    x.b
    x.a = 4

    expect(events.length).toBe(0) // nothing happened yet

    const d5 = mobx.reaction(
        () => x.b,
        () => {}
    )
    expect(events.length).toBe(2)
    expect(events).toEqual(["b observed", "a observed"])

    const d6 = mobx.reaction(
        () => x.b,
        () => {}
    )
    expect(events.length).toBe(2)

    d5()
    expect(events.length).toBe(2)
    d6()
    expect(events.length).toBe(4)
    expect(events).toEqual(["b observed", "a observed", "b unobserved", "a unobserved"])

    d1()
    d2()
    d3()
    d4()
    events.splice(0)
    const d7 = mobx.reaction(
        () => x.b,
        () => {}
    )
    d7()
    expect(events.length).toBe(0)
})

test("onBecomeObserved correctly disposes second listener #1537", () => {
    const x = mobx.observable.box(3)
    const events = []
    const d1 = mobx.onBecomeObserved(x, "a", () => {
        events.push("a observed")
    })
    mobx.onBecomeObserved(x, "b", () => {
        events.push("b observed")
    })
    d1()
    mobx.reaction(
        () => x.get(),
        () => {}
    )
    expect(events.length).toBe(1)
    expect(events).toEqual(["b observed"])
})

test("onBecomeObserved correctly disposes second listener #1537", () => {
    const x = mobx.observable.box(3)
    const events = []
    const d1 = mobx.onBecomeObserved(x, "a", () => {
        events.push("a observed")
    })
    const d2 = mobx.onBecomeObserved(x, "b", () => {
        events.push("b observed")
    })
    d1()
    const d3 = mobx.reaction(
        () => x.get(),
        () => {}
    )
    d3()
    expect(events.length).toBe(1)
    expect(events).toEqual(["b observed"])
    d2()
    mobx.reaction(
        () => x.get(),
        () => {}
    )
    expect(events).toEqual(["b observed"])
})

test("onBecomeUnobserved correctly disposes second listener #1537", () => {
    const x = mobx.observable.box(3)
    const events = []
    const d1 = mobx.onBecomeUnobserved(x, "a", () => {
        events.push("a unobserved")
    })
    const d2 = mobx.onBecomeUnobserved(x, "b", () => {
        events.push("b unobserved")
    })
    d1()
    const d3 = mobx.reaction(
        () => x.get(),
        () => {}
    )
    d3()
    expect(events.length).toBe(1)
    expect(events).toEqual(["b unobserved"])
    d2()
    mobx.reaction(
        () => x.get(),
        () => {}
    )
    expect(events).toEqual(["b unobserved"])
})

test("deepEquals should yield correct results for complex objects #1118 - 1", () => {
    const d2016jan1 = new Date("2016-01-01")
    const d2016jan1_2 = new Date("2016-01-01")
    const d2017jan1 = new Date("2017-01-01")

    expect(d2016jan1).toEqual(d2016jan1_2)
    expect(d2016jan1).not.toEqual(d2017jan1)
    expect(mobx.comparer.structural(d2016jan1, d2016jan1)).toBe(true)
    expect(mobx.comparer.structural(d2016jan1, d2017jan1)).toBe(false)
    expect(mobx.comparer.structural(d2016jan1, d2016jan1_2)).toBe(true)
})

test("deepEquals should yield correct results for complex objects #1118 - 2", () => {
    class A {
        x = 3
        y = 4

        constructor(x) {
            this.x = x
        }
    }

    const a1 = new A(2)
    const a2 = new A(2)
    const a3 = new A(3)
    const a4 = new A(2)
    a4.z = 2

    expect(a1).toEqual(a2)
    expect(a1).not.toEqual(a3)
    expect(mobx.comparer.structural(a1, a1)).toBe(true)
    expect(mobx.comparer.structural(a1, a3)).toBe(false)
    expect(mobx.comparer.structural(a1, a2)).toBe(true)
    expect(mobx.comparer.structural(a1, a4)).toBe(false)
})

test("comparer.shallow should require types to be equal", () => {
    const sh = mobx.comparer.shallow
    const obs = mobx.observable

    expect(sh({}, {})).toBe(true)
    expect(sh({}, [])).toBe(false)
    expect(sh({}, new Set())).toBe(false)
    expect(sh({}, new Map())).toBe(false)
    expect(sh({}, obs({}))).toBe(true)
    expect(sh({}, obs([]))).toBe(false)
    expect(sh({}, obs(new Set()))).toBe(false)
    expect(sh({}, obs(new Map()))).toBe(false)

    expect(sh([], {})).toBe(false)
    expect(sh([], [])).toBe(true)
    expect(sh([], new Set())).toBe(false)
    expect(sh([], new Map())).toBe(false)
    expect(sh([], obs({}))).toBe(false)
    expect(sh([], obs([]))).toBe(true)
    expect(sh([], obs(new Set()))).toBe(false)
    expect(sh([], obs(new Map()))).toBe(false)

    expect(sh(new Set(), {})).toBe(false)
    expect(sh(new Set(), [])).toBe(false)
    expect(sh(new Set(), new Set())).toBe(true)
    expect(sh(new Set(), new Map())).toBe(false)
    expect(sh(new Set(), obs({}))).toBe(false)
    expect(sh(new Set(), obs([]))).toBe(false)
    expect(sh(new Set(), obs(new Set()))).toBe(true)
    expect(sh(new Set(), obs(new Map()))).toBe(false)

    expect(sh(new Map(), {})).toBe(false)
    expect(sh(new Map(), [])).toBe(false)
    expect(sh(new Map(), new Set())).toBe(false)
    expect(sh(new Map(), new Map())).toBe(true)
    expect(sh(new Map(), obs({}))).toBe(false)
    expect(sh(new Map(), obs([]))).toBe(false)
    expect(sh(new Map(), obs(new Set()))).toBe(false)
    expect(sh(new Map(), obs(new Map()))).toBe(true)

    expect(sh(obs({}), {})).toBe(true)
    expect(sh(obs({}), [])).toBe(false)
    expect(sh(obs({}), new Set())).toBe(false)
    expect(sh(obs({}), new Map())).toBe(false)
    expect(sh(obs({}), obs({}))).toBe(true)
    expect(sh(obs({}), obs([]))).toBe(false)
    expect(sh(obs({}), obs(new Set()))).toBe(false)
    expect(sh(obs({}), obs(new Map()))).toBe(false)

    expect(sh(obs([]), {})).toBe(false)
    expect(sh(obs([]), [])).toBe(true)
    expect(sh(obs([]), new Set())).toBe(false)
    expect(sh(obs([]), new Map())).toBe(false)
    expect(sh(obs([]), obs({}))).toBe(false)
    expect(sh(obs([]), obs([]))).toBe(true)
    expect(sh(obs([]), obs(new Set()))).toBe(false)
    expect(sh(obs([]), obs(new Map()))).toBe(false)

    expect(sh(obs(new Set()), {})).toBe(false)
    expect(sh(obs(new Set()), [])).toBe(false)
    expect(sh(obs(new Set()), new Set())).toBe(true)
    expect(sh(obs(new Set()), new Map())).toBe(false)
    expect(sh(obs(new Set()), obs({}))).toBe(false)
    expect(sh(obs(new Set()), obs([]))).toBe(false)
    expect(sh(obs(new Set()), obs(new Set()))).toBe(true)
    expect(sh(obs(new Set()), obs(new Map()))).toBe(false)

    expect(sh(obs(new Map()), {})).toBe(false)
    expect(sh(obs(new Map()), [])).toBe(false)
    expect(sh(obs(new Map()), new Set())).toBe(false)
    expect(sh(obs(new Map()), new Map())).toBe(true)
    expect(sh(obs(new Map()), obs({}))).toBe(false)
    expect(sh(obs(new Map()), obs([]))).toBe(false)
    expect(sh(obs(new Map()), obs(new Set()))).toBe(false)
    expect(sh(obs(new Map()), obs(new Map()))).toBe(true)
})
test("comparer.shallow should work", () => {
    const sh = mobx.comparer.shallow
    const obs = mobx.observable

    expect(sh(1, 1)).toBe(true)
    expect(sh(1, 2)).toBe(false)

    // Object tests
    expect(sh({ a: 1, b: 2 }, { a: 1, b: 2 })).toBe(true)
    expect(sh({ a: 1, b: 2 }, { b: 2, a: 1 })).toBe(true) // order does not matter

    expect(sh({ a: 1, b: 2 }, { c: 1, b: 2 })).toBe(false)
    expect(sh({ a: 1, b: 2 }, { a: 3, b: 2 })).toBe(false)
    expect(sh({ a: 1, b: 2 }, { a: 1, c: 2 })).toBe(false)
    expect(sh({ a: 1, b: 2 }, { a: 1, b: 3 })).toBe(false)
    expect(sh({ a: 1, b: 2 }, { a: 1 })).toBe(false)
    expect(sh({ a: 1 }, { a: 1, b: 2 })).toBe(false)
    expect(sh({ a: {} }, { a: {} })).toBe(false)

    // Observable tests
    expect(sh(obs({ a: 1, b: 2 }), obs({ a: 1, b: 2 }))).toBe(true)
    expect(sh(obs({ a: 1, b: 2 }), obs({ b: 2, a: 1 }))).toBe(true) // order does not matter

    expect(sh(obs({ a: 1, b: 2 }), obs({ c: 1, b: 2 }))).toBe(false)
    expect(sh(obs({ a: 1, b: 2 }), obs({ a: 3, b: 2 }))).toBe(false)
    expect(sh(obs({ a: 1, b: 2 }), obs({ a: 1, c: 2 }))).toBe(false)
    expect(sh(obs({ a: 1, b: 2 }), obs({ a: 1, b: 3 }))).toBe(false)
    expect(sh(obs({ a: 1, b: 2 }), obs({ a: 1 }))).toBe(false)
    expect(sh(obs({ a: 1 }), obs({ a: 1, b: 2 }))).toBe(false)
    expect(sh(obs({ a: {} }), obs({ a: {} }))).toBe(false)

    // Array tests
    expect(sh([1, 2], [1, 2])).toBe(true)

    expect(sh([1, 2], [3, 2])).toBe(false)
    expect(sh([1, 2], [1, 3])).toBe(false)
    expect(sh([1, 2], [1])).toBe(false)
    expect(sh([1], [1, 2])).toBe(false)
    expect(sh([{}, 2], [{}, 2])).toBe(false)

    // ObservableArray tests
    expect(sh(obs([1, 2]), obs([1, 2]))).toBe(true)

    expect(sh(obs([1, 2]), obs([3, 2]))).toBe(false)
    expect(sh(obs([1, 2]), obs([1, 3]))).toBe(false)
    expect(sh(obs([1, 2]), obs([1]))).toBe(false)
    expect(sh(obs([1]), obs([1, 2]))).toBe(false)
    expect(sh(obs([{}, 2]), obs([{}, 2]))).toBe(false)

    // Set tests
    expect(sh(new Set([1, 2]), new Set([1, 2]))).toBe(true)

    expect(sh(new Set([1, 2]), new Set([2, 1]))).toBe(false) // order matters
    expect(sh(new Set([1, 2]), new Set([3, 2]))).toBe(false)
    expect(sh(new Set([1, 2]), new Set([1, 3]))).toBe(false)
    expect(sh(new Set([1, 2]), new Set([1]))).toBe(false)
    expect(sh(new Set([1]), new Set([1, 2]))).toBe(false)
    expect(sh(new Set([{}]), new Set([{}]))).toBe(false)

    // ObservableSet tests
    expect(sh(obs(new Set([1, 2])), obs(new Set([1, 2])))).toBe(true)

    expect(sh(obs(new Set([1, 2])), obs(new Set([2, 1])))).toBe(false) // order matters
    expect(sh(obs(new Set([1, 2])), obs(new Set([3, 2])))).toBe(false)
    expect(sh(obs(new Set([1, 2])), obs(new Set([1, 3])))).toBe(false)
    expect(sh(obs(new Set([1, 2])), obs(new Set([1])))).toBe(false)
    expect(sh(obs(new Set([1])), obs(new Set([1, 2])))).toBe(false)
    expect(sh(obs(new Set([{}])), obs(new Set([{}])))).toBe(false)

    // Map tests
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["a", 1],
                ["b", 2]
            ])
        )
    ).toBe(true)

    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["b", 2],
                ["a", 1]
            ])
        )
    ).toBe(false) // order matters
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["c", 1],
                ["b", 2]
            ])
        )
    ).toBe(false)
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["a", 3],
                ["b", 2]
            ])
        )
    ).toBe(false)
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["a", 1],
                ["c", 2]
            ])
        )
    ).toBe(false)
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([
                ["a", 1],
                ["b", 3]
            ])
        )
    ).toBe(false)
    expect(
        sh(
            new Map([
                ["a", 1],
                ["b", 2]
            ]),
            new Map([["a", 1]])
        )
    ).toBe(false)
    expect(
        sh(
            new Map([["a", 1]]),
            new Map([
                ["a", 1],
                ["b", 2]
            ])
        )
    ).toBe(false)
    expect(sh(new Map([[{}, 1]]), new Map([[{}, 1]]))).toBe(false)
    expect(sh(new Map([["a", {}]]), new Map([["a", {}]]))).toBe(false)

    // ObservableMap tests
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            )
        )
    ).toBe(true)

    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["b", 2],
                    ["a", 1]
                ])
            )
        )
    ).toBe(false) // order matters
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["c", 1],
                    ["b", 2]
                ])
            )
        )
    ).toBe(false)
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["a", 3],
                    ["b", 2]
                ])
            )
        )
    ).toBe(false)
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["a", 1],
                    ["c", 2]
                ])
            )
        )
    ).toBe(false)
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(
                new Map([
                    ["a", 1],
                    ["b", 3]
                ])
            )
        )
    ).toBe(false)
    expect(
        sh(
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            ),
            obs(new Map([["a", 1]]))
        )
    ).toBe(false)
    expect(
        sh(
            obs(new Map([["a", 1]])),
            obs(
                new Map([
                    ["a", 1],
                    ["b", 2]
                ])
            )
        )
    ).toBe(false)
    expect(sh(obs(new Map([[{}, 1]])), obs(new Map([[{}, 1]])))).toBe(false)
    expect(sh(obs(new Map([["a", {}]])), obs(new Map([["a", {}]])))).toBe(false)
})

test("getDebugName(action)", () => {
    expect(mobx.getDebugName(mobx.action(() => {}))).toBe("<unnamed action>")
    expect(mobx.getDebugName(mobx.action(function fn() {}))).toBe("fn")
    expect(mobx.getDebugName(mobx.action("custom", function fn() {}))).toBe("custom")
})

test("Default debug names - development", () => {
    expect(mobx.getDebugName(mobx.observable({ x() {} }, { x: mobx.action }).x)).toBe("x")
    expect(/Atom@\d+/.test(mobx.getDebugName(mobx.createAtom()))).toBe(true)
    expect(/ComputedValue@\d+/.test(mobx.getDebugName(mobx.computed(() => {})))).toBe(true)
    expect(mobx.getDebugName(mobx.action(function fn() {}))).toBe("fn")
    expect(/ObservableObject@\d+/.test(mobx.getDebugName(mobx.observable({})))).toBe(true)
    expect(/ObservableObject@\d+.x/.test(mobx.getDebugName(mobx.observable({ x: "x" }), "x"))).toBe(
        true
    )
    expect(
        /ObservableObject@\d+.x/.test(mobx.getDebugName(mobx.observable({ get x() {} }), "x"))
    ).toBe(true)
    expect(/ObservableArray@\d+/.test(mobx.getDebugName(mobx.observable([])))).toBe(true)
    expect(
        /ObservableArray@\d+/.test(mobx.getDebugName(mobx.observable([], { proxy: false })))
    ).toBe(true)
    expect(/ObservableMap@\d+/.test(mobx.getDebugName(mobx.observable(new Map())))).toBe(true)
    expect(/ObservableSet@\d+/.test(mobx.getDebugName(mobx.observable(new Set())))).toBe(true)
    expect(/ObservableValue@\d+/.test(mobx.getDebugName(mobx.observable("x")))).toBe(true)
    expect(
        /Reaction@\d+/.test(
            mobx.getDebugName(
                mobx.reaction(
                    () => {},
                    () => {}
                )
            )
        )
    ).toBe(true)
    expect(/Autorun@\d+/.test(mobx.getDebugName(mobx.autorun(() => {})))).toBe(true)
})

test("Default debug names - production", () => {
    const mobx = require(`../../../dist/mobx.cjs.production.min.js`)

    expect(mobx.getDebugName(mobx.observable({ x() {} }, { x: mobx.action }).x)).toBe("x") // perhaps should be "<unnamed action>"??
    expect(mobx.getDebugName(mobx.createAtom())).toBe("Atom")
    expect(mobx.getDebugName(mobx.computed(() => {}))).toBe("ComputedValue")
    expect(mobx.getDebugName(mobx.action(function fn() {}))).toBe("fn")
    expect(mobx.getDebugName(mobx.observable({}))).toBe("ObservableObject")
    expect(mobx.getDebugName(mobx.observable({ x: "x" }), "x")).toBe("ObservableObject.key")
    expect(mobx.getDebugName(mobx.observable({ get x() {} }), "x")).toBe("ObservableObject.key")
    expect(mobx.getDebugName(mobx.observable([]))).toBe("ObservableArray")
    expect(mobx.getDebugName(mobx.observable([], { proxy: false }))).toBe("ObservableArray")
    expect(mobx.getDebugName(mobx.observable(new Map()))).toBe("ObservableMap")
    expect(mobx.getDebugName(mobx.observable(new Set()))).toBe("ObservableSet")
    expect(mobx.getDebugName(mobx.observable("x"))).toBe("ObservableValue")
    expect(
        mobx.getDebugName(
            mobx.reaction(
                () => {},
                () => {}
            )
        )
    ).toBe("Reaction")
    expect(mobx.getDebugName(mobx.autorun(() => {}))).toBe("Autorun")
})

test("User provided debug names are always respected", () => {
    const mobxDevelopment = mobx
    const mobxProduction = require(`../../../dist/mobx.cjs.production.min.js`)

    const name = "CustomName"

    ;[mobxDevelopment, mobxProduction].forEach(mobx => {
        expect(mobx.getDebugName(mobx.action(name, function fn() {}))).toBe(name)
        expect(mobx.getDebugName(mobx.createAtom(name))).toBe(name)
        expect(mobx.getDebugName(mobx.computed(() => {}, { name }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable({}, {}, { name }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable([], { name }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable([], { name, proxy: false }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable(new Map(), { name }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable(new Set(), { name }))).toBe(name)
        expect(mobx.getDebugName(mobx.observable("x", { name }))).toBe(name)
        expect(
            mobx.getDebugName(
                mobx.reaction(
                    () => {},
                    () => {},
                    { name }
                )
            )
        ).toBe(name)
        expect(mobx.getDebugName(mobx.autorun(() => {}, { name }))).toBe(name)
    })
})



================================================
FILE: packages/mobx/__tests__/v5/base/flow.js
================================================
import * as mobx from "../../../src/mobx"
import {
    flow,
    FlowCancellationError,
    isFlowCancellationError,
    makeObservable
} from "../../../src/mobx"

function delay(time, value, shouldThrow = false) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (shouldThrow) reject(value)
            else resolve(value)
        }, time)
    })
}

test("it should support async generator actions", done => {
    mobx.configure({ enforceActions: "observed" })
    const values = []
    const x = mobx.observable({ a: 1 })
    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    const f = mobx.flow(function* (initial) {
        x.a = initial // this runs in action
        x.a = yield delay(100, 3) // and this as well!
        yield delay(100, 0)
        x.a = 4
        return x.a
    })

    setTimeout(() => {
        f(2).then(v => {
            // note: ideally, type of v should be inferred..
            expect(v).toBe(4)
            expect(values).toEqual([1, 2, 3, 4])
            done()
        })
    }, 10)
})

test("it should support try catch in async generator", done => {
    mobx.configure({ enforceActions: "observed" })
    const values = []
    const x = mobx.observable({ a: 1 })
    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    const f = mobx.flow(function* (initial) {
        x.a = initial // this runs in action
        try {
            x.a = yield delay(100, 5, true) // and this as well!
            yield delay(100, 0)
            x.a = 4
        } catch (e) {
            x.a = e
        }
        return x.a
    })

    setTimeout(() => {
        f(2).then(v => {
            // note: ideally, type of v should be inferred..
            expect(v).toBe(5)
            expect(values).toEqual(values, [1, 2, 5])
            done()
        })
    }, 10)
})

test("it should support throw from async generator", done => {
    mobx.flow(function* () {
        yield "a"
        throw 7
    })().then(
        () => {
            done.fail("should fail")
        },
        e => {
            expect(e).toBe(7)
            done()
        }
    )
})

test("it should support throw from yielded promise generator", done => {
    mobx.flow(function* () {
        return yield delay(10, 7, true)
    })().then(
        () => {
            done.fail("should fail")
        },
        e => {
            expect(e).toBe(7)
            done()
        }
    )
})

test("it should support asyncAction in classes", done => {
    const values = []

    mobx.configure({ enforceActions: "observed" })

    class X {
        a = 1

        f = mobx.flow(function* (initial) {
            this.a = initial // this runs in action
            try {
                this.a = yield delay(100, 5, true) // and this as well!
                yield delay(100, 0)
                this.a = 4
            } catch (e) {
                this.a = e
            }
            return this.a
        })
        constructor() {
            makeObservable(this, {
                a: true
            })
        }
    }

    const x = new X()
    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    setTimeout(() => {
        x.f(2).then(v => {
            expect(v).toBe(5)
            expect(values).toEqual([1, 2, 5])
            expect(x.a).toBe(5)
            done()
        })
    }, 10)
})

test("it should support logging", done => {
    mobx.configure({ enforceActions: "observed" })
    const events = []
    const x = mobx.observable({ a: 1 })

    const f = mobx.flow(function* myaction(initial) {
        x.a = initial
        x.a = yield delay(100, 5)
        x.a = 4
        x.a = yield delay(100, 3)
        return x.a
    })
    const d = mobx.spy(ev => events.push(ev))

    setTimeout(() => {
        f(2).then(() => {
            expect(stripEvents(events)).toMatchSnapshot()
            d()
            done()
        })
    }, 10)
})

function stripEvents(events) {
    return events.map(e => {
        delete e.object
        delete e.fn
        delete e.time
        return e
    })
}

test("flows are cancelled with an instance of FlowCancellationError", async () => {
    const start = flow(function* () {
        yield Promise.resolve()
    })

    const promise = start()

    promise.cancel()
    await expect(promise).rejects.toBeInstanceOf(FlowCancellationError)
})

test("FlowCancellationError sanity check", () => {
    const cancellationError = new FlowCancellationError()
    expect(cancellationError).toBeInstanceOf(Error)
    expect(cancellationError).toBeInstanceOf(FlowCancellationError)
    expect(cancellationError.message).toBe("FLOW_CANCELLED")
})

test("isFlowCancellationError returns true iff the argument is a FlowCancellationError", () => {
    expect(isFlowCancellationError(new FlowCancellationError())).toBe(true)
    expect(isFlowCancellationError(new Error("some random error"))).toBe(false)
})

test("flows can be cancelled - 1 - uncaught cancellation", done => {
    let steps = 0
    const start = flow(function* () {
        steps = 1
        yield Promise.resolve()
        steps = 2
    })

    const promise = start()
    promise.then(
        () => {
            fail()
        },
        err => {
            expect(steps).toBe(1)
            expect("" + err).toBe("Error: FLOW_CANCELLED")
            done()
        }
    )
    promise.cancel()
})

test("flows can be cancelled - 2 - finally clauses are run", done => {
    let steps = 0
    let finallyHandled = false
    const start = flow(function* () {
        steps = 1
        try {
            yield Promise.resolve()
            steps = 2
        } finally {
            expect(steps).toBe(1)
            finallyHandled = true
        }
    })
    const promise = start()
    promise.then(
        () => {
            fail()
        },
        err => {
            expect("" + err).toBe("Error: FLOW_CANCELLED")
            expect(finallyHandled).toBeTruthy()
            done()
        }
    )
    promise.cancel()
})

test("flows can be cancelled - 3 - throw in finally should be caught", done => {
    const counter = mobx.observable({ counter: 0 })
    const d = mobx.reaction(
        () => counter.counter,
        () => {}
    )
    mobx.configure({ enforceActions: "observed" })

    const start = flow(function* () {
        counter.counter = 1
        try {
            yield Promise.resolve()
            counter.counter = 15
        } finally {
            counter.counter = 4
            // eslint-disable-next-line no-unsafe-finally
            throw "OOPS"
        }
    })

    const promise = start()
    promise.then(
        () => fail("flow should not have failed"),
        err => {
            expect("" + err).toBe("OOPS")
            expect(counter.counter).toBe(4)
            mobx.configure({ enforceActions: "never" })
            d()
            done()
        }
    )
    promise.cancel()
})

test("flows can be cancelled - 4 - pending Promise will be ignored", done => {
    let steps = 0
    const start = flow(function* () {
        steps = 1
        yield Promise.reject("This won't be caught anywhere!") // cancel will resolve this flow before this one is throw, so this promise goes uncaught
        steps = 2
    })

    const promise = start()
    promise.then(
        () => fail(),
        err => {
            expect(steps).toBe(1)
            expect("" + err).toBe("Error: FLOW_CANCELLED")
            done()
        }
    )
    promise.cancel()
})

test("flows can be cancelled - 5 - return before cancel", done => {
    // eslint-disable-next-line require-yield
    const start = flow(function* () {
        return Promise.resolve(2) // cancel will be to late..
    })

    const promise = start()
    promise.then(
        value => {
            expect(value).toBe(2), done()
        },
        () => {
            fail()
        }
    )
    promise.cancel() // no-op
})

test("flows can be cancelled - 5 - flows cancel recursively", done => {
    let flow1cancelled = false
    let flow2cancelled = false
    let stepsReached = 0

    const flow1 = flow(function* () {
        try {
            yield Promise.resolve()
            stepsReached++
        } finally {
            flow1cancelled = true
        }
    })

    const flow2 = flow(function* () {
        try {
            yield flow1()
            stepsReached++
        } finally {
            flow2cancelled = true
        }
    })

    const p = flow2()
    p.then(
        () => fail(),
        err => {
            expect("" + err).toBe("Error: FLOW_CANCELLED")
            expect(stepsReached).toBe(0)
            expect(flow2cancelled).toBeTruthy()
            expect(flow1cancelled).toBeTruthy()
            done()
        }
    )
    p.cancel()
})

test("flows yield anything", async () => {
    const start = flow(function* () {
        const x = yield 2
        return x
    })

    const res = await start()
    expect(res).toBe(2)
})

test("cancelled flow should not result in runaway reject", async () => {
    const start = flow(function* () {
        try {
            const x = yield 2
            return x
        } finally {
            yield Promise.reject("Oh noes")
            // eslint-disable-next-line no-unsafe-finally
            return 4
        }
    })

    const p = start()
    p.cancel()
    try {
        await p
        fail()
    } catch (e) {
        expect("" + e).toBe("Error: FLOW_CANCELLED")
    }
})

test("it should support flow as annotation", done => {
    const values = []

    mobx.configure({ enforceActions: "observed" })

    class X {
        a = 1

        f = function* (initial) {
            this.a = initial // this runs in action
            try {
                this.a = yield delay(100, 5, true) // and this as well!
                yield delay(100, 0)
                this.a = 4
            } catch (e) {
                this.a = e
            }
            return this.a
        }
        constructor() {
            makeObservable(this, {
                a: true,
                f: flow
            })
        }
    }

    const x = new X()
    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    const x2 = new X()
    expect(x2.f).not.toBe(x.f) // local field!

    setTimeout(() => {
        x.f(2).then(v => {
            expect(v).toBe(5)
            expect(values).toEqual([1, 2, 5])
            expect(x.a).toBe(5)
            done()
        })
    }, 10)
})

test("it should support flow in makeAutoObservable", done => {
    const values = []

    mobx.configure({ enforceActions: "observed" })

    class X {
        a = 1;

        *f(initial) {
            this.a = initial // this runs in action
            try {
                this.a = yield delay(100, 5, true) // and this as well!
                yield delay(100, 0)
                this.a = 4
            } catch (e) {
                this.a = e
            }
            return this.a
        }

        constructor() {
            mobx.makeAutoObservable(this)
        }
    }

    const x = new X()
    expect(mobx.isFlow(X.prototype.f)).toBe(true)
    expect(x.hasOwnProperty("f")).toBe(false)

    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    setTimeout(() => {
        x.f(2).then(v => {
            expect(v).toBe(5)
            expect(values).toEqual([1, 2, 5])
            expect(x.a).toBe(5)
            done()
        })
    }, 10)
})

test("verify #2519", done => {
    mobx.configure({ enforceActions: "observed" })
    const values = []
    const x = mobx.observable({ a: 1 })
    mobx.reaction(
        () => x.a,
        v => values.push(v),
        { fireImmediately: true }
    )

    const f = mobx.flow(function* (initial) {
        x.a = initial // this runs in action
        try {
            x.a = yield delay(100, 5, false) // and this as well!
            yield delay(100, 0)
            x.a = 4
        } catch (e) {
            x.a = e
        }
        return x.a
    })

    setTimeout(() => {
        f(2).then(v => {
            expect(v).toBe(4)
            expect(values).toEqual(values, [1, 2, 5, 4])
            done()
        })
    }, 10)
})

test("flow is called with correct context", async () => {
    const thisArg = {}
    const f = flow(function* () {
        yield delay(100)
        expect(this).toBe(thisArg)
    })
    await f.call(thisArg)
})



================================================
FILE: packages/mobx/__tests__/v5/base/intercept.js
================================================
const m = require("../../../src/mobx.ts")
const intercept = m.intercept

test("intercept observable value", () => {
    const a = m.observable.box(1)

    let d = intercept(a, () => {
        return null
    })

    a.set(2)

    expect(a.get()).toBe(1)

    d()

    a.set(3)
    expect(a.get()).toBe(3)

    d = intercept(a, c => {
        expect(c.object).toBe(a)
        if (c.newValue % 2 === 0) {
            throw "value should be odd!"
        }
        return c
    })

    expect(() => {
        a.set(4)
    }).toThrow(/value should be odd/)

    expect(a.get()).toBe(3)
    a.set(5)
    expect(a.get()).toBe(5)

    d()
    d = intercept(a, c => {
        expect(c.object).toBe(a)
        c.newValue *= 2
        return c
    })

    a.set(6)
    expect(a.get()).toBe(12)

    intercept(a, c => {
        expect(c.object).toBe(a)
        c.newValue += 1
        return c
    })

    a.set(7)
    expect(a.get()).toBe(15)

    d()
    a.set(8)
    expect(a.get()).toBe(9)
})

test("intercept array", () => {
    const a = m.observable([1, 2])

    let d = m.intercept(a, () => null)
    a.push(2)
    expect(a.slice()).toEqual([1, 2])

    d()

    d = intercept(a, c => {
        expect(c.object).toBe(a)
        if (c.type === "splice") {
            c.added.push(c.added[0] * 2)
            c.removedCount = 1
            return c
        } else if (c.type === "update") {
            c.newValue = c.newValue * 3
            return c
        }
    })

    a.unshift(3, 4)

    expect(a.slice()).toEqual([3, 4, 6, 2])
    a[2] = 5
    expect(a.slice()).toEqual([3, 4, 15, 2])
})

test("intercept object", () => {
    const a = m.observable({
        b: 3
    })

    intercept(a, change => {
        expect(change.object).toBe(a)
        change.newValue *= 3
        return change
    })

    a.b = 4

    expect(a.b).toBe(12)

    intercept(a, "b", change => {
        change.newValue += 1
        return change
    })

    a.b = 5
    expect(a.b).toBe(16)

    const d3 = intercept(a, c => {
        expect(c.name).toBe("b")
        expect(c.object).toBe(a)
        expect(c.type).toBe("update")
        return null
    })

    a.b = 7
    expect(a.b).toBe(16)

    d3()
    a.b = 7
    expect(a.b).toBe(22)
})

test("intercept property additions", () => {
    const a = m.observable({})
    const d4 = intercept(a, change => {
        expect(change.object).toBe(a)
        if (change.type === "add") {
            return null
        }
        return change
    })

    m.extendObservable(a, { c: 1 }) // not added!
    expect(a.c).toBe(undefined)
    expect(m.isObservableProp(a, "c")).toBe(false)

    d4()

    m.extendObservable(a, { c: 2 })
    expect(a.c).toBe(2)
    expect(m.isObservableProp(a, "c")).toBe(true)
})

test("intercept map", () => {
    const a = m.observable.map({
        b: 3
    })

    intercept(a, c => {
        expect(c.object).toBe(a)
        c.newValue *= 3
        return c
    })

    a.set("b", 4)

    expect(a.get("b")).toBe(12)

    intercept(a, "b", c => {
        c.newValue += 1
        return c
    })

    a.set("b", 5)
    expect(a.get("b")).toBe(16)

    const d3 = intercept(a, c => {
        expect(c.object).toBe(a)
        expect(c.name).toBe("b"), expect(c.object).toBe(a)
        expect(c.type).toBe("update")
        return null
    })

    a.set("b", 7)
    expect(a.get("b")).toBe(16)

    d3()
    a.set("b", 7)
    expect(a.get("b")).toBe(22)

    const d4 = intercept(a, c => {
        expect(c.object).toBe(a)
        if (c.type === "delete") return null
        return c
    })

    a.delete("b")
    expect(a.has("b")).toBe(true)
    expect(a.get("b")).toBe(22)

    d4()
    a.delete("b")
    expect(a.has("b")).toBe(false)
    expect(a.get("c")).toBe(undefined)
})

test("intercept prevent dispose from breaking current execution", () => {
    const a = m.observable.box(1)

    intercept(a, c => {
        c.newValue += 1
        return c
    })

    const d = intercept(a, c => {
        d()
        expect(c.object).toBe(a)
        c.newValue *= 2
        return c
    })

    intercept(a, c => {
        c.newValue += 1
        return c
    })

    a.set(2)

    expect(a.get()).toBe(7)

    a.set(2)

    expect(a.get()).toBe(4)
})



================================================
FILE: packages/mobx/__tests__/v5/base/make-observable.ts
================================================
import { isFlow } from "../../../src/api/flow"
import { deepEnhancer } from "../../../src/internal"
import {
    makeObservable,
    action,
    computed,
    observable,
    isObservable,
    isObservableObject,
    isObservableProp,
    isComputedProp,
    isAction,
    makeAutoObservable,
    autorun,
    extendObservable,
    getDebugName,
    _getAdministration,
    configure,
    flow,
    override,
    ObservableSet,
    ObservableMap
} from "../../../src/mobx"

test("makeObservable picks up decorators", () => {
    class Test {
        @observable x = 3
        y = 3

        @computed
        get double() {
            return this.x * 2
        }

        @action
        unbound() {
            return this
        }

        @action.bound bound() {
            return this
        }

        constructor() {
            makeObservable(this)
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(false)
    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(t)
})

test("makeObservable picks up annotations", () => {
    class Test {
        x = 3
        y = 2

        get double() {
            return this.x * 2
        }

        unbound() {
            return this
        }

        bound() {
            return this
        }

        constructor() {
            makeObservable(this, {
                x: observable,
                double: computed,
                unbound: action,
                bound: action.bound
            })
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(false)

    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(t)
})

test("makeObservable supports private fields", () => {
    class Test {
        private x = 3
        private y = 2

        private get double() {
            return this.x * 2
        }

        private unbound() {
            return this
        }

        private bound() {
            return this
        }

        constructor() {
            makeObservable<this, "x" | "double" | "unbound" | "bound">(this, {
                x: observable,
                double: computed,
                unbound: action,
                bound: action.bound
            })
            if (3 - 1 === 4) {
                makeObservable<this, "x" | "double" | "unbound" | "bound">(this, {
                    // @ts-expect-error
                    z: false
                })

                makeObservable(this, {
                    // @ts-expect-error
                    z: false
                })
            }
        }
    }

    const t: any = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(false)

    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(t)
})

test("makeObservable has sane defaults", () => {
    class Test {
        x = 3
        y = 2

        get double() {
            return this.x * 2
        }

        unbound() {
            return this
        }

        bound() {
            return this
        }

        constructor() {
            makeObservable(this, {
                x: true,
                y: false,
                double: true,
                unbound: true,
                bound: action.bound
            })
            if (3 - 1 === 4) {
                makeObservable(this, {
                    x: false,
                    // @ts-expect-error
                    z: true
                })
            }
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(false)

    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(t)
})

test("makeObservable supports autoBind", async () => {
    class Test {
        action() {
            return this
        }

        actionBound() {
            return this
        }

        *flow() {
            return this
        }

        *flowBound() {
            return this
        }

        constructor() {
            makeObservable(
                this,
                {
                    action: action,
                    actionBound: true,
                    flow: flow,
                    flowBound: true
                },
                {
                    autoBind: true
                }
            )
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isAction(t.action)).toBe(true)
    expect(isAction(t.actionBound)).toBe(true)
    expect(t.action.call(undefined)).toBe(undefined)
    expect(t.actionBound.call(undefined)).toBe(t)
    expect(isFlow(t.flow)).toBe(true)
    expect(isFlow(t.flowBound)).toBe(true)
    expect(await t.flow.call(undefined)).toBe(undefined)
    expect(await t.flowBound.call(undefined)).toBe(t)
})

test("Extending builtins is not support #2765", () => {
    class ObservableMapLimitedSize extends ObservableMap {
        limitSize = 0
        constructor(map: Map<any, any>, enhancer = deepEnhancer, name: string) {
            super(map, enhancer, name)
            makeObservable(this, {
                limitSize: observable
            })
        }
    }

    class ObservableSetLimitedSize extends ObservableSet {
        limitSize = 0
        constructor(set: Set<any>, enhancer = deepEnhancer, name: string) {
            super(set, enhancer, name)
            makeObservable(this, {
                limitSize: observable
            })
        }
    }

    expect(() => {
        new ObservableMapLimitedSize(new Map([["key", "val"]]), deepEnhancer, "TestObject")
    }).toThrowErrorMatchingInlineSnapshot(`
        "[MobX] Cannot convert 'TestObject' into observable object:
        The target is already observable of different type.
        Extending builtins is not supported."
    `)
    expect(() => {
        new ObservableSetLimitedSize(new Set(), deepEnhancer, "TestObject")
    }).toThrowErrorMatchingInlineSnapshot(`
        "[MobX] Cannot convert 'TestObject' into observable object:
        The target is already observable of different type.
        Extending builtins is not supported."
    `)
})

test("makeAutoObservable has sane defaults", () => {
    class Test {
        x = 3
        y = 2

        get double() {
            return this.x * 2
        }

        unbound() {
            return this
        }

        bound() {
            return this
        }

        constructor() {
            makeAutoObservable(this)
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(true) // will be observable

    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(undefined)
})

test("makeAutoObservable supports autoBind", async () => {
    class Test {
        action() {
            return this
        }

        *flow() {
            return this
        }

        constructor() {
            makeAutoObservable(this, {}, { autoBind: true })
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isAction(t.action)).toBe(true)
    expect(isFlow(t.flow)).toBe(true)
    expect(t.action.call(undefined)).toBe(t)
    expect(await t.flow.call(undefined)).toBe(t)
})

test("makeAutoObservable allows overrides", () => {
    class Test {
        x = 3
        y = 2

        get double() {
            return this.x * 2
        }

        unbound() {
            return this
        }

        bound() {
            return this
        }

        constructor() {
            makeAutoObservable(this, {
                unbound: true,
                bound: action.bound,
                y: false
            })
            if (3 - 1 === 4) {
                makeObservable(this, {
                    // @ts-expect-error
                    z: true
                })
            }
        }
    }

    const t = new Test()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "x")).toBe(true)
    expect(isObservableProp(t, "y")).toBe(false)

    expect(isComputedProp(t, "double")).toBe(true)
    expect(isAction(t.unbound)).toBe(true)
    expect(isAction(t.bound)).toBe(true)
    expect(t.unbound.call(undefined)).toBe(undefined)
    expect(t.bound.call(undefined)).toBe(t)
})

test("makeAutoObservable cannot be used on subclasses", () => {
    class A {}

    class B extends A {
        constructor() {
            super()
            makeAutoObservable(this)
        }
    }

    expect(() => {
        new B()
    }).toThrowErrorMatchingInlineSnapshot(
        `"[MobX] 'makeAutoObservable' can only be used for classes that don't have a superclass"`
    )
})

test("makeAutoObservable cannot be used on observable objects", () => {
    expect(() => {
        makeAutoObservable(observable({ x: 3 }))
    }).toThrowErrorMatchingInlineSnapshot(
        `"[MobX] makeAutoObservable can only be used on objects not already made observable"`
    )
})

test("makeAutoObservable actions can be used for state updaters and state readers", () => {
    class A {
        x = 1

        constructor() {
            makeAutoObservable(this)
        }

        double() {
            return this.x * 2
        }

        addTwo() {
            this.x++
            this.x++
        }
    }

    const events: number[] = []
    const a = new A()

    expect(isObservableProp(a, "x")).toBe(true)
    expect(isAction(a.double)).toBe(true)
    expect(isAction(a.addTwo)).toBe(true)

    const d = autorun(() => {
        events.push(a.double())
    })

    a.addTwo()

    expect(a.x).toBe(3)

    // tracked and batched!
    expect(events).toEqual([2, 6])

    d()
})

test("observable actions can be used for state updaters and state readers", () => {
    const events: number[] = []
    const a = observable({
        x: 1,
        double() {
            return this.x * 2
        },
        addTwo() {
            this.x++
            this.x++
        }
    })
    const d = autorun(() => {
        events.push(a.double())
    })

    expect(isObservableProp(a, "x")).toBe(true)
    expect(isAction(a.double)).toBe(true)
    expect(isAction(a.addTwo)).toBe(true)

    a.addTwo()

    expect(a.x).toBe(3)

    // tracked and batched!
    expect(events).toEqual([2, 6])

    d()
})

test("makeObservable can be used late and support non-enumerable getters", () => {
    function MyClass() {
        this.x = 1
        Object.defineProperty(this, "double", {
            get() {
                return this.x
            },
            configurable: true,
            enumerable: false
        })
        this.inc = function () {
            this.x++
        }
        makeObservable(this, {
            x: observable,
            double: computed,
            inc: action
        })
    }
    const i = new MyClass()

    expect(isObservableProp(i, "x")).toBe(true)
    expect(isComputedProp(i, "double")).toBe(true)
    expect(isAction(i.inc)).toBe(true)
})

test("makeAutoObservable can be used late and support non-enumerable getters", () => {
    function MyClass() {
        this.x = 1
        Object.defineProperty(this, "double", {
            get() {
                return this.x
            },
            configurable: true,
            enumerable: false
        })
        this.inc = function () {
            this.x++
        }
        makeAutoObservable(this)
    }
    // check if annotations are cached
    expect(Object.getOwnPropertySymbols(MyClass.prototype).length).toBe(0)
    const x = new MyClass()
    expect(Object.getOwnPropertySymbols(MyClass.prototype).length).toBe(1)

    const i = new MyClass()

    expect(isObservableProp(i, "x")).toBe(true)
    expect(isComputedProp(i, "double")).toBe(true)
    expect(isAction(i.inc)).toBe(true)
})

test("extendObservable can be used late and support non-enumerable getters #2386", () => {
    function MyClass() {
        const args = {
            x: 1,
            inc() {
                this.x++
            }
        }
        Object.defineProperty(args, "double", {
            get() {
                return this.x
            },
            enumerable: false
        })
        extendObservable(this, args)
    }
    const i = new MyClass()

    expect(isObservableProp(i, "x")).toBe(true)
    expect(isComputedProp(i, "double")).toBe(true)
    expect(isAction(i.inc)).toBe(true)
})

test("makeObservable doesn't trigger in always mode'", () => {
    configure({
        enforceActions: "always"
    })
    class C {
        x = 3
        constructor() {
            makeAutoObservable(this)
        }
    }

    expect(new C()).toBeTruthy()
})

test("#2457", () => {
    class BaseClass {
        @observable
        value1?: number

        constructor() {
            makeObservable(this)
        }
    }

    class SubClass extends BaseClass {
        constructor() {
            super()
            makeObservable(this)
        }

        @computed
        get value1Computed() {
            return this.value1
        }
    }

    const t = new SubClass()
    expect(isObservableObject(t)).toBe(true)
    expect(isObservableProp(t, "value1")).toBe(true)
    expect(isComputedProp(t, "value1Computed")).toBe(true)
})

test("makeAutoObservable respects options.deep #2542'", () => {
    const o = makeAutoObservable({ nested: {} }, {}, { deep: false })
    expect(isObservable(o)).toBe(true)
    expect(isObservableProp(o, "nested")).toBe(true)
    expect(isObservable(o.nested)).toBe(false)

    const deepO = makeAutoObservable({ nested: {} }, {}, { deep: true })
    expect(isObservable(deepO)).toBe(true)
    expect(isObservableProp(deepO, "nested")).toBe(true)
    expect(isObservable(deepO.nested)).toBe(true)
})

test("makeObservable respects options.name #2614'", () => {
    const name = "DebugName"

    class Clazz {
        timer = 0
        constructor() {
            makeObservable(this, { timer: observable }, { name })
        }
    }

    const instance = new Clazz()
    const plain = makeObservable({ timer: 0 }, { timer: observable }, { name })

    expect(getDebugName(instance)).toBe(name)
    expect(getDebugName(plain)).toBe(name)
})
// "makeObservable + @action + arrow function + subclass override #2614"

test("class - annotations", async () => {
    class Foo {
        ["observable"] = { nested: {} };
        ["observable.ref"] = { nested: {} };
        ["observable.shallow"] = { nested: {} }

        constructor() {
            makeObservable(this, {
                observable: observable,
                "observable.ref": observable.ref,
                "observable.shallow": observable.shallow,
                computed: computed,
                action: action,
                "action.bound": action.bound,
                flow: flow,
                "flow.bound": flow.bound
            })
        }

        get computed() {
            return this
        }

        ["action"]() {
            return this
        }

        ["action.bound"]() {
            return this
        }

        *["flow"]() {
            return this
        }

        *["flow.bound"]() {
            return this
        }
    }

    const foo = new Foo()
    expect(isObservableObject(foo)).toBe(true)

    expect(isObservableProp(foo, "observable")).toBe(true)
    expect(isObservableObject(foo["observable"])).toBe(true)

    expect(isObservableProp(foo, "observable.ref")).toBe(true)
    expect(isObservableObject(foo["observable.ref"])).toBe(false)
    expect(isObservableObject(foo["observable.ref"].nested)).toBe(false)

    expect(isObservableProp(foo, "observable.shallow")).toBe(true)
    expect(isObservableObject(foo["observable.shallow"])).toBe(true)
    expect(isObservableObject(foo["observable.shallow"].nested)).toBe(false)

    expect(isComputedProp(foo, "computed")).toBe(true)

    expect(isAction(foo["action"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("action")).toBe(true)
    expect(foo.hasOwnProperty("action")).toBe(false)
    expect(foo["action"].call(null)).toBe(null)

    expect(isAction(foo["action.bound"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("action.bound")).toBe(true)
    expect(foo.hasOwnProperty("action.bound")).toBe(true)
    expect(foo["action.bound"].call(null)).toBe(foo)

    expect(isFlow(foo["flow"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("flow")).toBe(true)
    expect(foo.hasOwnProperty("flow")).toBe(false)

    expect(isFlow(foo["flow.bound"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("flow.bound")).toBe(true)
    expect(foo.hasOwnProperty("flow.bound")).toBe(true)
    expect(await foo["flow.bound"].call(null)).toBe(foo)
})

test("class - decorators", async () => {
    class Foo {
        @observable
        ["observable"] = { nested: {} };
        @observable.ref
        ["observable.ref"] = { nested: {} };
        @observable.shallow
        ["observable.shallow"] = { nested: {} }

        constructor() {
            makeObservable(this)
        }

        @computed
        get computed() {
            return this
        }

        @action
        ["action"]() {
            return this
        }

        @action.bound
        ["action.bound"]() {
            return this
        }

        @flow
        *["flow"]() {
            return this
        }

        @flow.bound
        *["flow.bound"]() {
            return this
        }
    }

    const foo = new Foo()
    expect(isObservableObject(foo)).toBe(true)

    expect(isObservableProp(foo, "observable")).toBe(true)
    expect(isObservableObject(foo["observable"])).toBe(true)

    expect(isObservableProp(foo, "observable.ref")).toBe(true)
    expect(isObservableObject(foo["observable.ref"])).toBe(false)
    expect(isObservableObject(foo["observable.ref"].nested)).toBe(false)

    expect(isObservableProp(foo, "observable.shallow")).toBe(true)
    expect(isObservableObject(foo["observable.shallow"])).toBe(true)
    expect(isObservableObject(foo["observable.shallow"].nested)).toBe(false)

    expect(isComputedProp(foo, "computed")).toBe(true)

    expect(isAction(foo["action"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("action")).toBe(true)
    expect(foo.hasOwnProperty("action")).toBe(false)
    expect(foo["action"].call(null)).toBe(null)

    expect(isAction(foo["action.bound"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("action.bound")).toBe(true)
    expect(foo.hasOwnProperty("action.bound")).toBe(true)
    expect(foo["action.bound"].call(null)).toBe(foo)

    expect(isFlow(foo["flow"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("flow")).toBe(true)
    expect(foo.hasOwnProperty("flow")).toBe(false)

    expect(isFlow(foo["flow.bound"])).toBe(true)
    expect(Object.getPrototypeOf(foo).hasOwnProperty("flow.bound")).toBe(true)
    expect(foo.hasOwnProperty("flow.bound")).toBe(true)
    expect(await foo["flow.bound"].call(null)).toBe(foo)
})

test("subclass - annotation", () => {
    class Parent {
        ["observable"] = { nested: {} };
        ["observable.ref"] = { nested: {} };
        ["observable.shallow"] = { nested: {} }

        constructor() {
            makeObservable(this, {
                observable: observable,
                "observable.ref": observable.ref,
                "observable.shallow": observable.shallow,
                computed: computed,
                action: action,
                "action.bound": action.bound,
                flow: flow
            })
        }

        get computed() {
            return this
        }

        ["action"]() {
            return this
        }

        ["action.bound"]() {
            return this
        }

        *["flow"]() {
            return this
        }
    }

    class Child extends Parent {
        ["observable2"] = { nested: {} };
        ["observable.ref2"] = { nested: {} };
        ["observable.shallow2"] = { nested: {} }

        constructor() {
            super()
            makeObservable(this, {
                observable2: observable,
                "observable.ref2": observable.ref,
                "observable.shallow2": observable.shallow,
                computed2: computed,
                action2: action,
                "action.bound2": action.bound,
                flow2: flow
            })
        }

        get computed2() {
            return this
        }

        ["action2"]() {
            return this
        }

        ["action.bound2"]() {
            return this
        }

        *["flow2"]() {
            return this
        }
    }

    const child = new Child()
    expect(isObservableObject(child)).toBe(true)

    expect(isObservableProp(child, "observable")).toBe(true)
    expect(isObservableObject(child["observable"])).toBe(true)

    expect(isObservableProp(child, "observable.ref")).toBe(true)
    expect(isObservableObject(child["observable.ref"])).toBe(false)
    expect(isObservableObject(child["observable.ref"].nested)).toBe(false)

    expect(isObservableProp(child, "observable.shallow")).toBe(true)
    expect(isObservableObject(child["observable.shallow"])).toBe(true)
    expect(isObservableObject(child["observable.shallow"].nested)).toBe(false)

    expect(isComputedProp(child, "computed")).toBe(true)

    expect(isAction(child["action"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action")).toBe(false)
    expect(child.hasOwnProperty("action")).toBe(false)
    expect(child["action"].call(null)).toBe(null)

    expect(isAction(child["action.bound"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action.bound")).toBe(false)
    expect(child.hasOwnProperty("action.bound")).toBe(true)
    expect(child["action.bound"].call(null)).toBe(child)

    expect(isFlow(child["flow"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("flow")).toBe(false)
    expect(child.hasOwnProperty("flow")).toBe(false)

    expect(isObservableProp(child, "observable2")).toBe(true)
    expect(isObservableObject(child["observable2"])).toBe(true)

    expect(isObservableProp(child, "observable.ref2")).toBe(true)
    expect(isObservableObject(child["observable.ref2"])).toBe(false)
    expect(isObservableObject(child["observable.ref2"].nested)).toBe(false)

    expect(isObservableProp(child, "observable.shallow2")).toBe(true)
    expect(isObservableObject(child["observable.shallow2"])).toBe(true)
    expect(isObservableObject(child["observable.shallow2"].nested)).toBe(false)

    expect(isComputedProp(child, "computed2")).toBe(true)

    expect(isAction(child["action2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action2")).toBe(true)
    expect(child.hasOwnProperty("action2")).toBe(false)
    expect(child["action2"].call(null)).toBe(null)

    expect(isAction(child["action.bound2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action.bound2")).toBe(true)
    expect(child.hasOwnProperty("action.bound2")).toBe(true)
    expect(child["action.bound2"].call(null)).toBe(child)

    expect(isFlow(child["flow2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("flow2")).toBe(true)
    expect(child.hasOwnProperty("flow2")).toBe(false)
})

test("subclass - decorator", () => {
    class Parent {
        @observable
        ["observable"] = { nested: {} };
        @observable.ref
        ["observable.ref"] = { nested: {} };
        @observable.shallow
        ["observable.shallow"] = { nested: {} }

        constructor() {
            makeObservable(this)
        }

        @computed
        get computed() {
            return this
        }

        @action
        ["action"]() {
            return this
        }

        @action.bound
        ["action.bound"]() {
            return this
        }

        @flow
        *["flow"]() {
            return this
        }
    }

    class Child extends Parent {
        @observable
        ["observable2"] = { nested: {} };
        @observable.ref
        ["observable.ref2"] = { nested: {} };
        @observable.shallow
        ["observable.shallow2"] = { nested: {} }

        constructor() {
            super()
            makeObservable(this)
        }

        @computed
        get computed2() {
            return this
        }

        @action
        ["action2"]() {
            return this
        }

        @action.bound
        ["action.bound2"]() {
            return this
        }

        @flow
        *["flow2"]() {
            return this
        }
    }

    const child = new Child()
    expect(isObservableObject(child)).toBe(true)

    expect(isObservableProp(child, "observable")).toBe(true)
    expect(isObservableObject(child["observable"])).toBe(true)

    expect(isObservableProp(child, "observable.ref")).toBe(true)
    expect(isObservableObject(child["observable.ref"])).toBe(false)
    expect(isObservableObject(child["observable.ref"].nested)).toBe(false)

    expect(isObservableProp(child, "observable.shallow")).toBe(true)
    expect(isObservableObject(child["observable.shallow"])).toBe(true)
    expect(isObservableObject(child["observable.shallow"].nested)).toBe(false)

    expect(isComputedProp(child, "computed")).toBe(true)

    expect(isAction(child["action"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action")).toBe(false)
    expect(child.hasOwnProperty("action")).toBe(false)
    expect(child["action"].call(null)).toBe(null)

    expect(isAction(child["action.bound"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action.bound")).toBe(false)
    expect(child.hasOwnProperty("action.bound")).toBe(true)
    expect(child["action.bound"].call(null)).toBe(child)

    expect(isFlow(child["flow"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("flow")).toBe(false)
    expect(child.hasOwnProperty("flow")).toBe(false)

    expect(isObservableProp(child, "observable2")).toBe(true)
    expect(isObservableObject(child["observable2"])).toBe(true)

    expect(isObservableProp(child, "observable.ref2")).toBe(true)
    expect(isObservableObject(child["observable.ref2"])).toBe(false)
    expect(isObservableObject(child["observable.ref2"].nested)).toBe(false)

    expect(isObservableProp(child, "observable.shallow2")).toBe(true)
    expect(isObservableObject(child["observable.shallow2"])).toBe(true)
    expect(isObservableObject(child["observable.shallow2"].nested)).toBe(false)

    expect(isComputedProp(child, "computed2")).toBe(true)

    expect(isAction(child["action2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action2")).toBe(true)
    expect(child.hasOwnProperty("action2")).toBe(false)
    expect(child["action2"].call(null)).toBe(null)

    expect(isAction(child["action.bound2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("action.bound2")).toBe(true)
    expect(child.hasOwnProperty("action.bound2")).toBe(true)
    expect(child["action.bound2"].call(null)).toBe(child)

    expect(isFlow(child["flow2"])).toBe(true)
    expect(Object.getPrototypeOf(child).hasOwnProperty("flow2")).toBe(true)
    expect(child.hasOwnProperty("flow2")).toBe(false)
})

test("subclass - annotation - override", async () => {
    class Parent {
        constructor() {
            makeObservable(this, {
                action: action,
                ["action.bound"]: action.bound,
                computed: computed,
                flow: flow,
                ["flow.bound"]: flow.bound
            })
        }
        action() {
            return "parent"
        }
        ["action.bound"]() {
            return "parent"
        }
        *flow() {
            return "parent"
        }
        *["flow.bound"]() {
            return "parent"
        }
        get computed() {
            return "parent"
        }
    }

    class Child extends Parent {
        action() {
            return "child of " + super.action()
        }
        ["action.bound"]() {
            return "child of " + super["action.bound"]()
        }
        get computed() {
            return "child"
        }
        *flow(): any {
            const parent = yield super.flow()
            return "child of " + parent
        }
        *["flow.bound"](): any {
            const parent = yield super["flow.bound"]()
            return "child of " + parent
        }
    }
    const child = new Child()

    // Action
    expect(isAction(Parent.prototype.action)).toBe(true)
    expect(isAction(Child.prototype.action)).toBe(true)
    expect(isAction(child.action)).toBe(true)

    expect(child.hasOwnProperty("action")).toBe(false)

    expect(Parent.prototype.action()).toBe("parent")
    expect(Child.prototype.action()).toBe("child of parent")
    expect(child.action()).toBe("child of parent")

    // Action bound
    expect(isAction(Parent.prototype["action.bound"])).toBe(false)
    expect(isAction(Child.prototype["action.bound"])).toBe(false)
    expect(isAction(child["action.bound"])).toBe(true)

    expect(child.hasOwnProperty("action.bound")).toBe(true)

    expect(Parent.prototype["action.bound"]()).toBe("parent")
    expect(Child.prototype["action.bound"]()).toBe("child of parent")
    expect(child["action.bound"]()).toBe("child of parent")

    // Computed
    expect(isComputedProp(child, "computed")).toBe(true)
    expect(child.computed).toBe("child")

    // Flow
    expect(isFlow(Parent.prototype.flow)).toBe(true)
    expect(isFlow(Child.prototype.flow)).toBe(true)
    expect(isFlow(child.flow)).toBe(true)

    expect(child.hasOwnProperty("flow")).toBe(false)

    expect(await Parent.prototype.flow()).toBe("parent")
    expect(await Child.prototype.flow()).toBe("child of parent")
    expect(await child.flow()).toBe("child of parent")

    // Flow bound
    expect(isFlow(Parent.prototype["flow.bound"])).toBe(true)
    expect(isFlow(Child.prototype["flow.bound"])).toBe(true)
    expect(isFlow(child["flow.bound"])).toBe(true)

    expect(child.hasOwnProperty("flow.bound")).toBe(true)

    expect(await Parent.prototype["flow.bound"]()).toBe("parent")
    expect(await Child.prototype["flow.bound"]()).toBe("child of parent")
    expect(await child["flow.bound"]()).toBe("child of parent")
})

test("subclass - decorator - override", async () => {
    class Parent {
        constructor() {
            makeObservable(this)
        }
        @action
        action() {
            return "parent"
        }
        @action.bound
        ["action.bound"]() {
            return "parent"
        }
        @flow
        *flow() {
            return "parent"
        }
        @flow.bound
        *["flow.bound"]() {
            return "parent"
        }
        @computed
        get computed() {
            return "parent"
        }
    }

    class Child extends Parent {
        action() {
            return "child of " + super.action()
        }
        ["action.bound"]() {
            return "child of " + super["action.bound"]()
        }
        get computed() {
            return "child"
        }
        *flow(): any {
            const parent = yield super.flow()
            return "child of " + parent
        }
        *["flow.bound"](): any {
            const parent = yield super["flow.bound"]()
            return "child of " + parent
        }
    }
    const child = new Child()

    // Action
    expect(isAction(Parent.prototype.action)).toBe(true)
    expect(isAction(Child.prototype.action)).toBe(true)
    expect(isAction(child.action)).toBe(true)

    expect(child.hasOwnProperty("action")).toBe(false)

    expect(Parent.prototype.action()).toBe("parent")
    expect(Child.prototype.action()).toBe("child of parent")
    expect(child.action()).toBe("child of parent")

    // Action bound
    expect(isAction(Parent.prototype["action.bound"])).toBe(false)
    expect(isAction(Child.prototype["action.bound"])).toBe(false)
    expect(isAction(child["action.bound"])).toBe(true)

    expect(child.hasOwnProperty("action.bound")).toBe(true)

    expect(Parent.prototype["action.bound"]()).toBe("parent")
    expect(Child.prototype["action.bound"]()).toBe("child of parent")
    expect(child["action.bound"]()).toBe("child of parent")

    // Computed
    expect(isComputedProp(child, "computed")).toBe(true)
    expect(child.computed).toBe("child")

    // Flow
    expect(isFlow(Parent.prototype.flow)).toBe(true)
    expect(isFlow(Child.prototype.flow)).toBe(true)
    expect(isFlow(child.flow)).toBe(true)

    expect(child.hasOwnProperty("flow")).toBe(false)

    expect(await Parent.prototype.flow()).toBe("parent")
    expect(await Child.prototype.flow()).toBe("child of parent")
    expect(await child.flow()).toBe("child of parent")

    // Flow bound
    expect(isFlow(Parent.prototype["flow.bound"])).toBe(true)
    expect(isFlow(Child.prototype["flow.bound"])).toBe(true)
    expect(isFlow(child["flow.bound"])).toBe(true)

    expect(child.hasOwnProperty("flow.bound")).toBe(true)

    expect(await Parent.prototype["flow.bound"]()).toBe("parent")
    expect(await Child.prototype["flow.bound"]()).toBe("child of parent")
    expect(await child["flow.bound"]()).toBe("child of parent")
})

test("subclass - cannot re-annotate", () => {
    class Parent {
        observable = 1
        constructor() {
            makeObservable(this, {
                action: action,
                observable: observable,
                actionBound: action.bound,
                flow: flow,
                flowBound: flow.bound,
                computed: computed
            })
        }
        action() {}
        actionBound() {}
        *flow() {}
        *flowBound() {}
        get computed() {
            return this
        }
    }

    class ChildAction extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                action: action
            })
        }
        action() {}
    }

    class ChildActionBound extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                actionBound: action.bound
            })
        }
        actionBound() {}
    }

    class ChildFlow extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                flow: flow
            })
        }
        *flow() {}
    }

    class ChildFlowBound extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                flowBound: flow.bound
            })
        }
        *flowBound() {}
    }

    class ChildObservable extends Parent {
        constructor() {
            super()
            this.observable = 2
            makeObservable(this, {
                observable: observable
            })
        }
    }

    class ChildComputed extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                computed: computed
            })
        }
        get computed() {
            return this
        }
    }

    expect(() => new ChildAction()).toThrow(/^\[MobX\] Cannot apply/)
    expect(() => new ChildActionBound()).toThrow(/^\[MobX\] Cannot apply/)
    expect(() => new ChildFlow()).toThrow(/^\[MobX\] Cannot apply/)
    expect(() => new ChildFlowBound()).toThrow(/^\[MobX\] Cannot apply/)
    expect(() => new ChildObservable()).toThrow(/^\[MobX\] Cannot apply/)
    expect(() => new ChildComputed()).toThrow(/^\[MobX\] Cannot apply/)
})

test("subclass - cannot re-decorate", () => {
    class Parent {
        @observable
        observable = 1
        constructor() {
            makeObservable(this)
        }
        @action
        action() {}
        @action.bound
        actionBound() {}
        @flow
        *flow() {}
        @flow.bound
        *flowBound() {}
        @computed
        get computed() {
            return this
        }
    }

    expect(() => {
        class ChildAction extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @action
            action() {}
        }
    }).toThrow(/^\[MobX\] Cannot apply/)

    expect(() => {
        class ChildActionBound extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @action.bound
            actionBound() {}
        }
    }).toThrow(/^\[MobX\] Cannot apply/)

    expect(() => {
        class ChildFlow extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @flow
            *flow() {}
        }
    }).toThrow(/^\[MobX\] Cannot apply/)

    expect(() => {
        class ChildFlowBound extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @flow.bound
            *flowBound() {}
        }
    }).toThrow(/^\[MobX\] Cannot apply/)

    expect(() => {
        class ChildObservable extends Parent {
            @observable
            observable = 1
            constructor() {
                super()
                makeObservable(this)
            }
        }
    }).toThrow(/^\[MobX\] Cannot apply/)

    expect(() => {
        class ChildComputed extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @computed
            get computed() {
                return this
            }
        }
    }).toThrow(/^\[MobX\] Cannot apply/)
})

test("subclass - cannot redefine property", () => {
    class Parent {
        observable = 1
        constructor() {
            makeObservable(this, {
                observable: observable,
                action: action,
                computed: computed
            })
        }
        action = () => {}
        get computed() {
            return this
        }
    }

    class ChildAction extends Parent {
        action = () => {}
    }

    class ChildObservable extends Parent {
        observable = 2
    }

    class ChildComputed extends Parent {
        // @ts-ignore
        computed = "foo"
    }

    expect(() => new ChildAction()).toThrow(/^Cannot redefine property/)
    expect(() => new ChildObservable()).toThrow(/^Cannot redefine property/)
    expect(() => new ChildComputed()).toThrow(/^Cannot redefine property/)
})

test("@override", () => {
    class Parent {
        constructor() {
            makeObservable(this)
        }

        @action
        action() {
            return "parent"
        }
    }

    class Child extends Parent {
        @override
        action() {
            return `child of ${super.action()}`
        }
    }

    const child = new Child()
    expect(isAction(Parent.prototype.action))
    expect(Parent.prototype.action()).toBe("parent")
    expect(isAction(Child.prototype.action))
    expect(isAction(child.action)).toBe(true)
    expect(child.action()).toBe("child of parent")
})

test("override", () => {
    class Parent {
        constructor() {
            makeObservable(this, {
                action: action
            })
        }
        action() {
            return "parent"
        }
    }

    class Child extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                action: override
            })
        }
        action() {
            return `child of ${super.action()}`
        }
    }

    const child = new Child()
    expect(isAction(Parent.prototype.action))
    expect(Parent.prototype.action()).toBe("parent")
    expect(isAction(Child.prototype.action))
    expect(isAction(child.action)).toBe(true)

    expect(child.action()).toBe("child of parent")
})

test("override must override", () => {
    class Parent {
        action() {
            return "parent"
        }
    }

    class Child extends Parent {
        constructor() {
            super()
            makeObservable(this, {
                action: override
            })
        }
        action() {
            return `child of ${super.action()}`
        }
    }

    expect(() => new Child()).toThrow(
        /^\[MobX\] 'Child@\d+\.action' is annotated with 'override', but no such annotated member was found on prototype\./
    )
})

test("@override must override", () => {
    class Parent {
        action() {
            return "parent"
        }
    }

    expect(() => {
        class Child extends Parent {
            constructor() {
                super()
                makeObservable(this)
            }
            @override
            action() {
                return `child of ${super.action()}`
            }
        }
    }).toThrow(
        /^\[MobX\] 'Child\.prototype\.action' is decorated with 'override', but no such decorated member was found on prototype\./
    )
})

test("makeAutoObservable + production build #2751", () => {
    const mobx = require(`../../../dist/mobx.cjs.production.min.js`)
    class Foo {
        x = "x"
        constructor() {
            mobx.makeAutoObservable(this)
        }
    }
    const foo = new Foo()
    expect(mobx.isObservableObject(foo)).toBe(true)
    expect(mobx.isObservableProp(foo, "x")).toBe(true)
})

// Makes sure that we don't define properties on proto as non-writable,
// as that would prevent initializing prop on instance via assigment.
test("inherited fields are assignable before makeObservable", () => {
    class Foo {
        constructor() {
            this.action = () => {}
            this.flow = function* flow() {}
            makeObservable(this, {
                action,
                flow
            })
        }

        action() {}
        *flow() {}
    }

    const foo1 = new Foo()
    expect(isAction(foo1.action)).toBe(true)
    expect(isFlow(foo1.flow)).toBe(true)

    const foo2 = new Foo()
    expect(isAction(foo2.action)).toBe(true)
    expect(isFlow(foo2.flow)).toBe(true)
})

test("makeAutoObservable + symbolic keys", () => {
    const observableSymbol = Symbol()
    const computedSymbol = Symbol()
    const actionSymbol = Symbol()

    class Foo {
        observable = "observable";
        [observableSymbol] = "observableSymbol"
        get [computedSymbol]() {
            return this.observable
        }
        [actionSymbol]() {}

        constructor() {
            makeAutoObservable(this)
        }
    }

    ;[new Foo(), new Foo()].forEach(foo => {
        expect(isObservableProp(foo, "observable")).toBe(true)
        expect(isObservableProp(foo, observableSymbol)).toBe(true)
        expect(isComputedProp(foo, computedSymbol)).toBe(true)
        expect(isAction(foo[actionSymbol])).toBe(true)
    })
})

test("makeAutoObservable + override + annotation cache #2832", () => {
    class Clazz {
        auto = []
        override = []
        constructor() {
            makeAutoObservable(this, {
                override: observable.ref
            })
        }
    }

    ;[new Clazz(), new Clazz()].forEach(x => {
        expect(isObservableProp(x, "auto")).toBe(true)
        expect(isObservable(x.auto)).toBe(true)
        expect(isObservableProp(x, "override")).toBe(true)
        expect(isObservable(x.override)).toBe(false)
    })
})

test("flow.bound #2941", async () => {
    class Clazz {
        constructor() {
            makeObservable(this, {
                flowBound: flow.bound
            })
        }
        *flowBound() {
            return this
        }
    }
    new Clazz()
    new Clazz()
    expect(isFlow(Clazz.prototype.flowBound)).toBe(true)
    expect(await Clazz.prototype.flowBound.call("ctx")).toBe("ctx")
})

test("makeObservable throws when mixing @decorators with annotations", () => {
    class Test {
        @observable x = 3

        constructor() {
            makeObservable(this, {})
        }
    }

    expect(() => new Test()).toThrow(
        /makeObservable second arg must be nullish when using decorators/
    )
})

test("makeAutoObservable + Object.create #3197", () => {
    const proto = {
        action() {},
        *flow() {},
        get computed() {
            return null
        }
    }
    const o = Object.create(proto)
    o.observable = 5
    makeAutoObservable(o)
    expect(isAction(proto.action)).toBe(true)
    expect(isFlow(proto.flow)).toBe(true)
    expect(isComputedProp(o, "computed")).toBe(true)
    expect(isObservableProp(o, "observable")).toBe(true)
})

test("flow.bound #3271", async () => {
    class Test {
        constructor() {
            makeObservable(this, { flowBound: flow.bound })
        }
        *flowBound() {
            return this
        }
    }

    const t1 = new Test()
    const t2 = new Test()

    // Make sure flow is actually bindable
    expect(
        await flow(function* () {
            return this
        }).bind(t1)()
    ).toBe(t1)

    expect(t1.hasOwnProperty("flowBound")).toBe(true)
    expect(t2.hasOwnProperty("flowBound")).toBe(true)

    expect(t1.flowBound !== t2.flowBound).toBe(true)

    expect(await t1.flowBound.call(null)).toBe(t1)
    expect(await t2.flowBound.call(null)).toBe(t2)
})



================================================
FILE: packages/mobx/__tests__/v5/base/makereactive.js
================================================
const { isAction, isObservable, isObservableProp } = require("../../../src/mobx")
const mobx = require("../../../src/mobx.ts")
const m = mobx
const o = mobx.observable
const { makeObservable } = mobx

function buffer() {
    const b = []
    const res = function (x) {
        b.push(x)
    }
    res.toArray = function () {
        return b
    }
    return res
}

test("isObservable", function () {
    function Order() {}

    function ReactiveOrder(price) {
        m.extendObservable(this, {
            price: price
        })
    }
    expect(m.isObservable(null)).toBe(false)
    expect(m.isObservable(null)).toBe(false)

    expect(m.isObservable(m.observable([]))).toBe(true)
    expect(m.isObservable(m.observable({}))).toBe(true)
    expect(m.isObservable(m.observable.box(function () {}))).toBe(true)
    expect(m.isObservable(m.computed(function () {}))).toBe(true)

    expect(m.isObservable([])).toBe(false)
    expect(m.isObservable({})).toBe(false)
    expect(m.isObservable(function () {})).toBe(false)

    expect(m.isObservable(new Order())).toBe(false)
    expect(m.isObservable(m.observable.box(new Order()))).toBe(true)

    expect(m.isObservable(new ReactiveOrder())).toBe(true)
    expect(m.isObservable(m.observable.box(3))).toBe(true)

    const obj = {}
    expect(m.isObservable(obj)).toBe(false)

    expect(m.isObservable(m.observable.box(function () {}))).toBe(true)
    expect(m.isObservable(m.autorun(function () {}))).toBe(true)

    expect(m.isObservableProp(m.observable({ a: 1 }), "a")).toBe(true)
    expect(m.isObservableProp(m.observable({ a: 1 }), "b")).toBe(false)

    expect(m.isObservable(m.observable.map())).toBe(true)

    const base = { a: 3 }
    const obs = m.observable(base)
    expect(m.isObservable(base)).toBe(false)
    expect(m.isObservableProp(base, "a")).toBe(false)
    expect(m.isObservable(obs)).toBe(true)
    expect(m.isObservableProp(obs, "a")).toBe(true)
})

test("isBoxedObservable", function () {
    expect(m.isBoxedObservable(m.observable({}))).toBe(false)
    expect(m.isBoxedObservable(m.computed(() => 3))).toBe(false)
    expect(m.isBoxedObservable(m.observable.box(3))).toBe(true)
    expect(m.isBoxedObservable(m.observable.box(3))).toBe(true)
    expect(m.isBoxedObservable(m.observable.box({}))).toBe(true)
    expect(m.isBoxedObservable(m.observable.box({}, { deep: false }))).toBe(true)
})

test("observable1", function () {
    m._resetGlobalState()

    // recursive structure
    const x = m.observable({
        a: {
            b: {
                c: 3
            }
        }
    })
    const b = buffer()
    m.autorun(function () {
        b(x.a.b.c)
    })
    x.a = { b: { c: 4 } }
    x.a.b.c = 5 // new structure was reactive as well
    expect(b.toArray()).toEqual([3, 4, 5])

    // recursive structure, but asReference passed in
    expect(m.isObservable(x.a.b)).toBe(true)
    const x2 = m.observable.object(
        {
            a: {
                b: {
                    c: 3
                }
            }
        },
        {
            a: m.observable.ref
        }
    )

    expect(m.isObservable(x2)).toBe(true)
    expect(m.isObservable(x2.a)).toBe(false)
    expect(m.isObservable(x2.a.b)).toBe(false)

    const b2 = buffer()
    m.autorun(function () {
        b2(x2.a.b.c)
    })
    x2.a = { b: { c: 4 } }
    x2.a.b.c = 5 // not picked up, not reactive, since passed as reference
    expect(b2.toArray()).toEqual([3, 4])

    // non recursive structure
    const x3 = o.object(
        {
            a: {
                b: {
                    c: 3
                }
            }
        },
        {},
        { deep: false }
    )
    const b3 = buffer()
    m.autorun(function () {
        b3(x3.a.b.c)
    })
    x3.a = { b: { c: 4 } }
    x3.a.b.c = 5 // sub structure not reactive
    expect(b3.toArray()).toEqual([3, 4])
})

test("observable3", function () {
    function Order(price) {
        this.price = price
    }

    const x = m.observable({
        orders: [new Order(1), new Order(2)]
    })

    const b = buffer()
    m.autorun(function () {
        b(x.orders.length)
    })

    expect(m.isObservable(x.orders)).toBe(true)
    expect(m.isObservable(x.orders[0])).toBe(false)
    x.orders[2] = new Order(3)
    x.orders = []
    expect(m.isObservable(x.orders)).toBe(true)
    x.orders[0] = new Order(2)
    expect(b.toArray()).toEqual([2, 3, 0, 1])
})

test("observable4", function () {
    const x = m.observable([{ x: 1 }, { x: 2 }])

    const b = buffer()
    m.observe(
        m.computed(function () {
            return x.map(function (d) {
                return d.x
            })
        }),
        x => b(x.newValue),
        true
    )

    x[0].x = 3
    x.shift()
    x.push({ x: 5 })
    expect(b.toArray()).toEqual([[1, 2], [3, 2], [2], [2, 5]])

    // non recursive
    const x2 = o.array([{ x: 1 }, { x: 2 }], { deep: false })

    const b2 = buffer()
    m.observe(
        m.computed(function () {
            return x2.map(function (d) {
                return d.x
            })
        }),
        x => b2(x.newValue),
        true
    )

    x2[0].x = 3
    x2.shift()
    x2.push({ x: 5 })
    expect(b2.toArray()).toEqual([[1, 2], [2], [2, 5]])
})

test("observable5", function () {
    let x = m.computed(function () {})
    expect(function () {
        x.set(7) // set not allowed
    }).toThrow(/It is not possible to assign a new value to a computed value/)

    let f = m._autoAction(function () {})
    const x2 = m.observable.box(f)
    expect(x2.get()).toBe(f)
    x2.set(null) // allowed

    f = function () {
        return this.price
    }
    x = m.observable(
        {
            price: 17,
            get reactive() {
                return this.price
            },
            nonReactive: f
        },
        {
            nonReactive: false
        }
    )

    const b = buffer()
    m.autorun(function () {
        b([x.reactive, x.nonReactive, x.nonReactive()])
    })

    x.price = 18
    const three = function () {
        return 3
    }
    // 20.12.2020 @urugator:
    // Since https://github.com/mobxjs/mobx/pull/2641
    // the non-observable field won't become suddenly observable on assigment.
    // Firstly it doesn't make sense,
    // secondly it's inconsistent - it works like this only for proxies/object api.
    x.nonReactive = three
    expect(b.toArray()).toEqual([
        [17, f, 17],
        [18, f, 18]
        //[18, three, 3]
    ])
})

test("flat array", function () {
    const x = m.observable.object(
        {
            x: [
                {
                    a: 1
                }
            ]
        },
        { x: m.observable.shallow }
    )

    let result
    let updates = 0
    m.autorun(function () {
        updates++
        result = JSON.stringify(mobx.toJS(x))
    })

    expect(result).toEqual(JSON.stringify({ x: [{ a: 1 }] }))
    expect(updates).toBe(1)

    x.x[0].a = 2 // not picked up; object is not made reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 1 }] }))
    expect(updates).toBe(1)

    x.x.push({ a: 3 }) // picked up, array is reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 2 }, { a: 3 }] }))
    expect(updates).toBe(2)

    x.x[0] = { a: 4 } // picked up, array is reactive
    expect(result).toEqual(JSON.stringify({ x: [{ a: 4 }, { a: 3 }] }))
    expect(updates).toBe(3)

    x.x[1].a = 6 // not picked up
    expect(result).toEqual(JSON.stringify({ x: [{ a: 4 }, { a: 3 }] }))
    expect(updates).toBe(3)
})

test("flat object", function () {
    const y = m.observable.object(
        {
            x: { z: 3 }
        },
        {},
        { deep: false }
    )

    let result
    let updates = 0
    m.autorun(function () {
        updates++
        result = JSON.stringify(mobx.toJS(y))
    })

    expect(result).toEqual(JSON.stringify({ x: { z: 3 } }))
    expect(updates).toBe(1)

    y.x.z = 4 // not picked up
    expect(result).toEqual(JSON.stringify({ x: { z: 3 } }))
    expect(updates).toBe(1)

    y.x = { z: 5 }
    expect(result).toEqual(JSON.stringify({ x: { z: 5 } }))
    expect(updates).toBe(2)

    y.x.z = 6 // not picked up
    expect(result).toEqual(JSON.stringify({ x: { z: 5 } }))
    expect(updates).toBe(2)
})

test("as structure", function () {
    const x = m.observable.object(
        {
            x: null
        },
        {
            x: m.observable.struct
        }
    )

    let changed = 0
    const dis = m.autorun(function () {
        changed++
        JSON.stringify(x)
    })

    function c() {
        expect(changed).toBe(1)
        if (changed !== 1) console.trace()
        changed = 0
    }

    function nc() {
        expect(changed).toBe(0)
        if (changed !== 0) console.trace()
        changed = 0
    }

    // nc = no change, c = changed.
    c()
    x.x = null
    nc()
    x.x = undefined
    c()
    x.x = 3
    c()
    x.x = 1 * x.x
    nc()
    x.x = "3"
    c()

    x.x = {
        y: 3
    }
    c()
    x.x.y = 3
    nc()
    x.x = {
        y: 3
    }
    nc()
    x.x = {
        y: 4
    }
    c()
    x.x = {
        y: 3
    }
    c()
    x.x = {
        y: {
            y: 3
        }
    }
    c()
    x.x.y.y = 3
    nc()
    x.x.y = { y: 3 }
    nc()
    x.x = { y: { y: 3 } }
    nc()
    x.x = { y: { y: 4 } }
    c()
    x.x = {}
    c()
    x.x = {}
    nc()

    x.x = []
    c()
    x.x = []
    nc()
    x.x = [3, 2, 1]
    c()
    x.x.sort()
    nc()
    x.x.sort()
    nc()
    x.x[1] = 2
    nc()
    x.x[0] = 0
    nc() // not detected

    dis()
})

test("as structure view", function () {
    const x = m.observable.object(
        {
            a: 1,
            aa: 1,
            get b() {
                this.a
                return { a: this.aa }
            },
            get c() {
                this.b
                return { a: this.aa }
            }
        },
        {
            c: m.computed({ compareStructural: true })
        }
    )

    let bc = 0
    m.autorun(function () {
        x.b
        bc++
    })
    expect(bc).toBe(1)

    let cc = 0
    m.autorun(function () {
        x.c
        cc++
    })
    expect(cc).toBe(1)

    x.a = 2
    x.a = 3
    expect(bc).toBe(3)
    expect(cc).toBe(1)
    x.aa = 3
    expect(bc).toBe(4)
    expect(cc).toBe(2)
})

test("540 - extendobservable should not report cycles", function () {
    expect(() => m.extendObservable(Object.freeze({}), {})).toThrowError(
        /Cannot make the designated object observable/
    )

    const objWrapper = mobx.observable({
        value: null
    })

    const obj = {
        name: "Hello"
    }

    objWrapper.value = obj
    expect(mobx.isObservable(objWrapper.value)).toBeTruthy()
    expect(() => {
        mobx.extendObservable(objWrapper, objWrapper.value)
    }).toThrowError(/Extending an object with another observable \(object\) is not supported/)
})

test("mobx 3", () => {
    const x = mobx.observable({ a: 1 })

    expect(x === mobx.observable(x)).toBeTruthy()

    const y = mobx.observable.box(null, { deep: false })
    const obj = { a: 2 }
    y.set(obj)
    expect(y.get() === obj).toBeTruthy()
    expect(mobx.isObservable(y.get())).toBe(false)
})

test("computed value", () => {
    mobx._getGlobalState().mobxGuid = 0
    const c = mobx.computed(() => 3)

    expect(0 + c).toBe(3)
    expect(mobx.isComputed(c)).toBe(true)
    expect(c.toString()).toMatchSnapshot()
})

test("boxed value json", () => {
    const a = mobx.observable.box({ x: 1 })
    expect(a.get().x).toEqual(1)
    a.set(3)
    expect(a.get()).toEqual(3)
    expect("" + a).toBe("3")
    expect(a.toJSON()).toBe(3)
})

test("computed value scope", () => {
    const a = mobx.observable({
        x: 1,
        get y() {
            return this.x * 2
        },
        set y(v) {
            this.x = v
        }
    })

    expect(a.y).toBe(2)
    a.x = 2
    expect(a.y).toBe(4)
    a.y = 3
    expect(a.y).toBe(6)
})

test("shallow array", () => {
    const a = mobx.observable.array([], { deep: false })
    a.push({ x: 1 }, [], 2, mobx.observable({ y: 3 }))

    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservable(a[0])).toBe(false)
    expect(mobx.isObservable(a[1])).toBe(false)
    expect(mobx.isObservable(a[2])).toBe(false)
    expect(mobx.isObservable(a[3])).toBe(true)
})

test("761 - deeply nested modifiers work", () => {
    const a = {}
    mobx.extendObservable(a, {
        someKey: mobx.observable.object(
            {
                someNestedKey: []
            },
            {
                someNestedKey: mobx.observable.ref
            }
        )
    })

    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservableProp(a, "someKey")).toBe(true)
    expect(mobx.isObservable(a.someKey)).toBe(true)
    expect(mobx.isObservableProp(a.someKey, "someNestedKey")).toBe(true)
    expect(mobx.isObservable(a.someKey.someNestedKey)).toBe(false)
    expect(Array.isArray(a.someKey.someNestedKey)).toBe(true)

    Object.assign(a, { someKey: { someNestedKey: [1, 2, 3] } })
    expect(mobx.isObservable(a)).toBe(true)
    expect(mobx.isObservableProp(a, "someKey")).toBe(true)
    expect(mobx.isObservable(a.someKey)).toBe(true)
    expect(mobx.isObservableProp(a.someKey, "someNestedKey")).toBe(true)
    expect(mobx.isObservable(a.someKey.someNestedKey)).toBe(true) // Too bad: no deep merge with Object.assign! someKey object gets replaced in its entirity
    expect(Array.isArray(a.someKey.someNestedKey)).toBe(true)
})

test("compare structurally, ref", () => {
    const a = mobx.observable.object(
        {
            x: undefined
        },
        {
            x: mobx.observable.struct
        }
    )

    let changed = 0
    const d = mobx.autorun(() => {
        mobx.toJS(a)
        changed++
    })

    expect(changed).toBe(1)
    a.x = { y: 2 }
    expect(changed).toBe(2)
    a.x.y = 3
    expect(mobx.isObservable(a.x)).toBe(false)
    expect(changed).toBe(2)

    a.x = { y: 3 }
    expect(changed).toBe(2)

    a.x = { y: 4 }
    expect(changed).toBe(3)
    a.x = { y: 4 }
    expect(changed).toBe(3)

    d()
})

test("double declare property", () => {
    const o = {}
    mobx.extendObservable(o, {
        a: 5
    })
    expect(() => {
        mobx.extendObservable(
            o,
            { a: 2 },
            {
                a: mobx.observable.ref
            }
        )
    }).toThrow(/The field is already annotated/)
})

test("structural collections", () => {
    const o = mobx.observable(
        {
            x: [1, 2, 3]
        },
        {
            x: mobx.observable.struct
        }
    )

    expect(mobx.isObservable(o.x)).toBeFalsy()
    const x = o.x
    o.x = [1, 2, 3]
    expect(o.x).toBe(x)
    expect(() => {
        o.x = mobx.observable([1, 2, 3])
    }).toThrow("observable.struct should not be used with observable values")
})

test("jest is behaving correctly", () => {
    const symbol = Symbol("test")
    const a = []
    const b = []
    const c = []
    a[symbol] = 1
    b[symbol] = 1
    c[symbol] = 2
    expect(a).toEqual(b)
    expect(a).not.toEqual(c)
})

test("All non-enumerables should be treated equally!", () => {
    const actual1 = {
        x: 3
    }
    Object.defineProperty(actual1, "test", {
        enumerable: false,
        value: 5
    })

    const actual2 = {
        x: 3
    }
    const mySymbol = Symbol("test")
    Object.defineProperty(actual2, mySymbol, {
        enumerable: false,
        value: 5
    })

    expect(actual1).toEqual({ x: 3 })
    expect(actual2).toEqual({ x: 3 })
})

test("jest object equals issue - reference", () => {
    class Store {
        constructor() {
            mobx.extendObservable(this, { x: 3 })
        }
    }

    const store = new Store()
    expect(store).toEqual(new Store())
})

test("jest object equals issue", () => {
    class Store {
        x = 2

        constructor() {
            makeObservable(this, {
                x: mobx.observable
            })

            this.x = 3
        }
    }

    const store = new Store()
    expect(store).toEqual(new Store())
})

test("jest array equals issue", () => {
    class Store {
        things = []

        constructor() {
            makeObservable(this, {
                things: mobx.observable
            })
        }
    }

    const store = new Store()
    expect(store.things).toEqual([])
})

test("#1650, toString is not treated correctly", () => {
    const o = { a: "a", toString: "toString" }
    const oo = mobx.observable(o)
    expect(oo.toString).toBe("toString")
})



================================================
FILE: packages/mobx/__tests__/v5/base/map.js
================================================
"use strict"

import * as mobx from "../../../src/mobx.ts"
import {
    observable,
    autorun,
    makeObservable,
    computed,
    action,
    when,
    runInAction,
    configure,
    _resetGlobalState
} from "../../../src/mobx.ts"

const map = mobx.observable.map
const iterall = require("iterall")
import { grabConsole } from "../../v5/utils/test-utils"

test("map crud", function () {
    mobx._getGlobalState().mobxGuid = 0 // hmm dangerous reset?

    const events = []
    const m = map({ 1: "a" })
    mobx.observe(m, function (change) {
        events.push(change)
        expect(change.observableKind).toBe("map")
        delete change.observableKind
        delete change.debugObjectName
    })

    expect(m.has("1")).toBe(true)
    expect(m.has(1)).toBe(false)
    expect(m.get("1")).toBe("a")
    expect(m.get("b")).toBe(undefined)
    expect(m.size).toBe(1)

    m.set("1", "aa")
    m.set(1, "b")
    expect(m.has("1")).toBe(true)
    expect(m.get("1")).toBe("aa")
    expect(m.get(1)).toBe("b")

    const k = ["arr"]
    m.set(k, "arrVal")
    expect(m.has(k)).toBe(true)
    expect(m.get(k)).toBe("arrVal")

    const s = Symbol("test")
    expect(m.has(s)).toBe(false)
    expect(m.get(s)).toBe(undefined)
    m.set(s, "symbol-value")
    expect(m.get(s)).toBe("symbol-value")
    expect(m.get(s.toString())).toBe(undefined)

    expect(mobx.keys(m)).toEqual(["1", 1, k, s])
    expect(mobx.values(m)).toEqual(["aa", "b", "arrVal", "symbol-value"])
    expect(Array.from(m)).toEqual([
        ["1", "aa"],
        [1, "b"],
        [k, "arrVal"],
        [s, "symbol-value"]
    ])
    expect(new Map(m)).toEqual(
        new Map([
            ["1", "aa"],
            [1, "b"],
            [k, "arrVal"],
            [s, "symbol-value"]
        ])
    )
    expect(JSON.stringify(m)).toMatchInlineSnapshot(
        `"[["1","aa"],[1,"b"],[["arr"],"arrVal"],[null,"symbol-value"]]"`
    )
    expect(m.toString()).toBe("[object ObservableMap]")
    expect(m.size).toBe(4)

    m.clear()
    expect(mobx.keys(m)).toEqual([])
    expect(mobx.values(m)).toEqual([])
    expect(m.toJSON()).toEqual([])
    expect(m.size).toBe(0)

    expect(m.has("a")).toBe(false)
    expect(m.has("b")).toBe(false)
    expect(m.get("a")).toBe(undefined)
    expect(m.get("b")).toBe(undefined)

    expect(events).toEqual([
        { object: m, name: "1", newValue: "aa", oldValue: "a", type: "update" },
        { object: m, name: 1, newValue: "b", type: "add" },
        { object: m, name: ["arr"], newValue: "arrVal", type: "add" },
        { object: m, name: s, newValue: "symbol-value", type: "add" },
        { object: m, name: "1", oldValue: "aa", type: "delete" },
        { object: m, name: 1, oldValue: "b", type: "delete" },
        { object: m, name: ["arr"], oldValue: "arrVal", type: "delete" },
        { object: m, name: s, oldValue: "symbol-value", type: "delete" }
    ])

    expect(JSON.stringify(m)).toBe("[]")
})

test("map merge", function () {
    const a = map({ a: 1, b: 2, c: 2 })
    const b = map({ c: 3, d: 4 })
    a.merge(b)
    expect(a.toJSON()).toEqual([
        ["a", 1],
        ["b", 2],
        ["c", 3],
        ["d", 4]
    ])
})

test("observe value", function () {
    const a = map()
    let hasX = false
    let valueX = undefined
    let valueY = undefined

    autorun(function () {
        hasX = a.has("x")
    })

    autorun(function () {
        valueX = a.get("x")
    })

    autorun(function () {
        valueY = a.get("y")
    })

    expect(hasX).toBe(false)
    expect(valueX).toBe(undefined)

    a.set("x", 3)
    expect(hasX).toBe(true)
    expect(valueX).toBe(3)

    a.set("x", 4)
    expect(hasX).toBe(true)
    expect(valueX).toBe(4)

    a.delete("x")
    expect(hasX).toBe(false)
    expect(valueX).toBe(undefined)

    a.set("x", 5)
    expect(hasX).toBe(true)
    expect(valueX).toBe(5)

    expect(valueY).toBe(undefined)
    a.merge({ y: "hi" })
    expect(valueY).toBe("hi")
    a.merge({ y: "hello" })
    expect(valueY).toBe("hello")

    a.replace({ y: "stuff", z: "zoef" })
    expect(valueY).toBe("stuff")
    expect(mobx.keys(a)).toEqual(["y", "z"])
})

test("initialize with entries", function () {
    const thing = [{ x: 3 }]
    const a = map([
        ["a", 1],
        [thing, 2]
    ])
    expect(Array.from(a)).toEqual([
        ["a", 1],
        [thing, 2]
    ])
})

test("initialize with empty value", function () {
    const a = map()
    const b = map({})
    const c = map([])

    a.set("0", 0)
    b.set("0", 0)
    c.set("0", 0)

    expect(a.toJSON()).toEqual([["0", 0]])
    expect(b.toJSON()).toEqual([["0", 0]])
    expect(c.toJSON()).toEqual([["0", 0]])
})

test("observe collections", function () {
    const x = map()
    let keys, values, entries

    autorun(function () {
        keys = mobx.keys(x)
    })
    autorun(function () {
        values = iteratorToArray(x.values())
    })
    autorun(function () {
        entries = iteratorToArray(x.entries())
    })

    x.set("a", 1)
    expect(keys).toEqual(["a"])
    expect(values).toEqual([1])
    expect(entries).toEqual([["a", 1]])

    // should not retrigger:
    keys = null
    values = null
    entries = null
    x.set("a", 1)
    expect(keys).toEqual(null)
    expect(values).toEqual(null)
    expect(entries).toEqual(null)

    x.set("a", 2)
    expect(values).toEqual([2])
    expect(entries).toEqual([["a", 2]])

    x.set("b", 3)
    expect(keys).toEqual(["a", "b"])
    expect(values).toEqual([2, 3])
    expect(entries).toEqual([
        ["a", 2],
        ["b", 3]
    ])

    x.has("c")
    expect(keys).toEqual(["a", "b"])
    expect(values).toEqual([2, 3])
    expect(entries).toEqual([
        ["a", 2],
        ["b", 3]
    ])

    x.delete("a")
    expect(keys).toEqual(["b"])
    expect(values).toEqual([3])
    expect(entries).toEqual([["b", 3]])
})

test("cleanup", function () {
    const x = map({ a: 1 })

    let aValue
    const disposer = autorun(function () {
        aValue = x.get("a")
    })

    let observable = x.data_.get("a")

    expect(aValue).toBe(1)
    expect(observable.observers_.size).toBe(1)
    expect(x.hasMap_.get("a").observers_.size).toBe(1)

    expect(x.delete("a")).toBe(true)
    expect(x.delete("not-existing")).toBe(false)

    expect(aValue).toBe(undefined)
    expect(observable.observers_.size).toBe(0)
    expect(x.hasMap_.get("a").observers_.size).toBe(1)

    x.set("a", 2)
    observable = x.data_.get("a")

    expect(aValue).toBe(2)
    expect(observable.observers_.size).toBe(1)
    expect(x.hasMap_.get("a").observers_.size).toBe(1)

    disposer()
    expect(aValue).toBe(2)
    expect(observable.observers_.size).toBe(0)
    expect(x.hasMap_.has("a")).toBe(false)
})

test("getAtom encapsulation leak test", function () {
    const x = map({})

    let disposer = autorun(function () {
        x.has("a")
    })

    let atom = mobx.getAtom(x, "a")

    disposer()

    expect(x.hasMap_.get("a")).toBe(undefined)

    disposer = autorun(function () {
        x.has("a")
        atom && atom.reportObserved()
    })

    expect(x.hasMap_.get("a")).not.toBe(atom)
})

test("strict", function () {
    const x = map()
    autorun(function () {
        x.get("y") // should not throw
    })
})

test("issue 100", function () {
    const that = {}
    mobx.extendObservable(that, {
        myMap: map()
    })
    expect(mobx.isObservableMap(that.myMap)).toBe(true)
})

test("issue 119 - unobserve before delete", function () {
    const propValues = []
    const myObservable = mobx.observable({
        myMap: map()
    })
    myObservable.myMap.set("myId", {
        myProp: "myPropValue",
        get myCalculatedProp() {
            if (myObservable.myMap.has("myId"))
                return myObservable.myMap.get("myId").myProp + " calculated"
            return undefined
        }
    })
    // the error only happens if the value is observed
    mobx.autorun(function () {
        mobx.values(myObservable.myMap).forEach(function (value) {
            propValues.push(value.myCalculatedProp)
        })
    })
    myObservable.myMap.delete("myId")

    expect(propValues).toEqual(["myPropValue calculated"])
})

test("issue 116 - has should not throw on invalid keys", function () {
    const x = map()
    expect(x.has(undefined)).toBe(false)
    expect(x.has({})).toBe(false)
    expect(x.get({})).toBe(undefined)
    expect(x.get(undefined)).toBe(undefined)
})

test("map modifier", () => {
    let x = mobx.observable.map({ a: 1 })
    expect(mobx.isObservableMap(x)).toBe(true)
    expect(x.get("a")).toBe(1)
    x.set("b", {})
    expect(mobx.isObservableObject(x.get("b"))).toBe(true)

    x = mobx.observable.map([["a", 1]])
    expect(x.get("a")).toBe(1)

    x = mobx.observable.map()
    expect(mobx.keys(x)).toEqual([])

    x = mobx.observable({ a: mobx.observable.map({ b: { c: 3 } }) })
    expect(mobx.isObservableObject(x)).toBe(true)
    expect(mobx.isObservableObject(x.a)).toBe(false)
    expect(mobx.isObservableMap(x.a)).toBe(true)
    expect(mobx.isObservableObject(x.a.get("b"))).toBe(true)
})

test("map modifier with modifier", () => {
    let x = mobx.observable.map({ a: { c: 3 } })
    expect(mobx.isObservableObject(x.get("a"))).toBe(true)
    x.set("b", { d: 4 })
    expect(mobx.isObservableObject(x.get("b"))).toBe(true)

    x = mobx.observable.map({ a: { c: 3 } }, { deep: false })
    expect(mobx.isObservableObject(x.get("a"))).toBe(false)
    x.set("b", { d: 4 })
    expect(mobx.isObservableObject(x.get("b"))).toBe(false)

    x = mobx.observable({ a: mobx.observable.map({ b: {} }, { deep: false }) })
    expect(mobx.isObservableObject(x)).toBe(true)
    expect(mobx.isObservableMap(x.a)).toBe(true)
    expect(mobx.isObservableObject(x.a.get("b"))).toBe(false)
    x.a.set("e", {})
    expect(mobx.isObservableObject(x.a.get("e"))).toBe(false)
})

test("256, map.clear should not be tracked", () => {
    const x = mobx.observable.map({ a: 3 })
    let c = 0
    const d = mobx.autorun(() => {
        c++
        x.clear()
    })

    expect(c).toBe(1)
    x.set("b", 3)
    expect(c).toBe(1)

    d()
})

test("256, map.merge should be not be tracked for target", () => {
    const x = mobx.observable.map({ a: 3 })
    const y = mobx.observable.map({ b: 3 })
    let c = 0

    const d = mobx.autorun(() => {
        c++
        x.merge(y)
    })

    expect(c).toBe(1)
    expect(mobx.keys(x)).toEqual(["a", "b"])

    y.set("c", 4)
    expect(c).toBe(2)
    expect(mobx.keys(x)).toEqual(["a", "b", "c"])

    x.set("d", 5)
    expect(c).toBe(2)
    expect(mobx.keys(x)).toEqual(["a", "b", "c", "d"])

    d()
})

test("308, map keys should be coerced to strings correctly", () => {
    const m = mobx.observable.map()
    m.set(1, true)
    m.delete(1)
    expect(mobx.keys(m)).toEqual([])

    m.set(1, true)
    m.set("1", false)
    m.set(0, true)
    m.set(-0, false)
    expect(Array.from(mobx.keys(m))).toEqual([1, "1", 0])
    expect(m.get(-0)).toBe(false)
    expect(m.get(1)).toBe(true)

    m.delete("1")
    expect(Array.from(mobx.keys(m))).toEqual([1, 0])

    m.delete(1)
    expect(mobx.keys(m)).toEqual([0])

    m.set(true, true)
    expect(m.get("true")).toBe(undefined)
    expect(m.get(true)).toBe(true)
    m.delete(true)
    expect(mobx.keys(m)).toEqual([0])
})

test("map should support iterall / iterable ", () => {
    const a = mobx.observable.map({ a: 1, b: 2 })

    function leech(iter) {
        const values = []
        let v
        do {
            v = iter.next()
            if (!v.done) values.push(v.value)
        } while (!v.done)
        return values
    }

    expect(iterall.isIterable(a)).toBe(true)

    expect(leech(iterall.getIterator(a))).toEqual([
        ["a", 1],
        ["b", 2]
    ])

    expect(leech(a.entries())).toEqual([
        ["a", 1],
        ["b", 2]
    ])

    expect(leech(a.keys())).toEqual(["a", "b"])
    expect(leech(a.values())).toEqual([1, 2])
})

test("support for ES6 Map", () => {
    const x = new Map()
    x.set("x", 3)
    x.set("y", 2)

    const m = mobx.observable(x)
    expect(mobx.isObservableMap(m)).toBe(true)
    expect(Array.from(m)).toEqual([
        ["x", 3],
        ["y", 2]
    ])

    const x2 = new Map()
    x2.set("y", 4)
    x2.set("z", 5)
    m.merge(x2)
    expect(m.get("z")).toEqual(5)

    const x3 = new Map()
    x3.set({ y: 2 }, { z: 4 })
})

test("deepEqual map", () => {
    const x = new Map()
    x.set("x", 3)
    x.set("y", { z: 2 })

    const x2 = mobx.observable.map()
    x2.set("x", 3)
    x2.set("y", { z: 3 })

    expect(mobx.comparer.structural(x, x2)).toBe(false)
    x2.get("y").z = 2
    expect(mobx.comparer.structural(x, x2)).toBe(true)

    x2.set("z", 1)
    expect(mobx.comparer.structural(x, x2)).toBe(false)
    x2.delete("z")
    expect(mobx.comparer.structural(x, x2)).toBe(true)
    x2.delete("y")
    expect(mobx.comparer.structural(x, x2)).toBe(false)
})

test("798, cannot return observable map from computed prop", () => {
    // MWE: this is an anti pattern, yet should be possible in certain cases nonetheless..?
    // https://jsfiddle.net/7e6Ltscr/

    const form = function () {
        const form = mobx.observable({
            reactPropsMap: mobx.observable.map({
                onSubmit: function () {}
            }),
            model: {
                value: "TEST"
            }
        })

        form.reactPropsMap.set("onSubmit", function () {})

        return form
    }

    const customerSearchStore = function () {
        const customerSearchStore = mobx.observable({
            customerType: "RUBY",
            searchTypeFormStore() {
                return form(customerSearchStore.customerType)
            },
            customerSearchType() {
                return form(customerSearchStore.searchTypeFormStore.model.value)
            }
        })
        return customerSearchStore
    }
    const cs = customerSearchStore()

    expect(() => {
        Object.assign({}, cs.customerSearchType)
    }).not.toThrow()
})

test("869, deeply observable map should make added items observables as well", () => {
    const store = {
        map_deep1: mobx.observable(new Map()),
        map_deep2: mobx.observable.map()
    }

    expect(mobx.isObservable(store.map_deep1)).toBeTruthy()
    expect(mobx.isObservableMap(store.map_deep1)).toBeTruthy()
    expect(mobx.isObservable(store.map_deep2)).toBeTruthy()
    expect(mobx.isObservableMap(store.map_deep2)).toBeTruthy()

    store.map_deep2.set("a", [])
    expect(mobx.isObservable(store.map_deep2.get("a"))).toBeTruthy()

    store.map_deep1.set("a", [])
    expect(mobx.isObservable(store.map_deep1.get("a"))).toBeTruthy()
})

test("using deep map", () => {
    const store = {
        map_deep: mobx.observable(new Map())
    }
    const seen = []

    // Creating autorun triggers one observation, hence -1
    let observed = -1
    mobx.autorun(function () {
        // Use the map, to observe all changes
        seen.push(store.map_deep.toJSON())
        // JSON.stringify(store.map_deep)
        observed++
    })

    store.map_deep.set("shoes", [])
    expect(observed).toBe(1)
    expect(seen).toEqual([[], [["shoes", []]]])

    store.map_deep.get("shoes").push({ color: "black" })
    expect(seen).toEqual([
        [],
        // N.B. although the referred array changed, it didn't trigger a change in the map itself,
        // and is hence not observed by the autorun!
        [["shoes", [{ color: "black" }]]]
    ])

    expect(observed).toBe(1)

    store.map_deep.get("shoes")[0].color = "red"
    // see above comment
    expect(seen).toEqual([[], [["shoes", [{ color: "red" }]]]])
    expect(observed).toBe(1)
})

test("using deep map - toJS", () => {
    const store = {
        map_deep: mobx.observable(new Map())
    }
    const seen = []

    // Creating autorun triggers one observation, hence -1
    let observed = -1
    mobx.autorun(function () {
        // Use the map, to observe all changes
        seen.push(mobx.toJS(store.map_deep))
        // JSON.stringify(store.map_deep)
        observed++
    })

    store.map_deep.set("shoes", [])
    expect(observed).toBe(1)
    expect(seen).toEqual([new Map(), new Map([["shoes", []]])])

    store.map_deep.get("shoes").push({ color: "black" })
    expect(seen).toEqual([
        new Map([]),
        new Map([["shoes", []]]),
        new Map([["shoes", [{ color: "black" }]]])
    ])

    expect(observed).toBe(2)
    store.map_deep.get("shoes")[0].color = "red"
    // see above comment
    expect(seen).toEqual([
        new Map([]),
        new Map([["shoes", []]]),
        new Map([["shoes", [{ color: "black" }]]]),
        new Map([["shoes", [{ color: "red" }]]])
    ])
    expect(observed).toBe(3)
})

test("issue 893", () => {
    const m = mobx.observable.map()
    const keys = ["constructor", "toString", "assertValidKey", "isValidKey", "toJSON", "toJS"]
    for (let key of keys) {
        expect(m.get(key)).toBe(undefined)
    }
})

test("work with 'toString' key", () => {
    const m = mobx.observable.map()
    expect(m.get("toString")).toBe(undefined)
    m.set("toString", "test")
    expect(m.get("toString")).toBe("test")
})

test("issue 940, should not be possible to change maps outside strict mode", () => {
    mobx.configure({ enforceActions: "observed" })

    try {
        const m = mobx.observable.map()
        const d = mobx.autorun(() => mobx.values(m))

        expect(
            grabConsole(() => {
                m.set("x", 1)
            })
        ).toMatchInlineSnapshot(
            `"<STDOUT> [MobX] Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: ObservableMap@56.keys()"`
        )

        expect(
            grabConsole(() => {
                m.set("x", 2)
            })
        ).toMatchInlineSnapshot(
            `"<STDOUT> [MobX] Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: ObservableMap@56.x"`
        )

        expect(
            grabConsole(() => {
                m.delete("x")
            })
        ).toMatchInlineSnapshot(
            `"<STDOUT> [MobX] Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: ObservableMap@56.keys()"`
        )

        d()
    } finally {
        mobx.configure({ enforceActions: "never" })
    }
})

test("issue 1243, .replace should not trigger change on unchanged values", () => {
    const m = mobx.observable.map({ a: 1, b: 2, c: 3 })

    let recomputeCount = 0
    const computedValue = mobx.computed(() => {
        recomputeCount++
        return m.get("a")
    })

    const d = mobx.autorun(() => {
        computedValue.get()
    })

    // recompute should happen once by now, due to the autorun
    expect(recomputeCount).toBe(1)

    // a hasn't changed, recompute should not happen
    m.replace({ a: 1, d: 5 })

    expect(recomputeCount).toBe(1)

    // this should cause a recompute
    m.replace({ a: 2 })
    expect(recomputeCount).toBe(2)

    // this should remove key a and cause a recompute
    m.replace({ b: 2 })
    expect(recomputeCount).toBe(3)

    m.replace([["a", 1]])
    expect(recomputeCount).toBe(4)

    const nativeMap = new Map()
    nativeMap.set("a", 2)
    m.replace(nativeMap)
    expect(recomputeCount).toBe(5)

    expect(() => {
        m.replace("not-an-object")
    }).toThrow("[MobX] Cannot convert to map from 'not-an-object'")

    d()
})

test("#1980 .replace should not breaks entities order!", () => {
    const original = mobx.observable.map([
        ["a", "first"],
        ["b", "second"]
    ])
    const replacement = new Map([
        ["b", "first"],
        ["a", "second"]
    ])
    original.replace(replacement)
    const newKeys = Array.from(replacement)
    const originalKeys = Array.from(replacement)
    for (let i = 0; i < newKeys.length; i++) {
        expect(newKeys[i]).toEqual(originalKeys[i])
    }
})

test("#1980 .replace should invoke autorun", () => {
    const original = mobx.observable.map({ a: "a", b: "b" })
    const replacement = { b: "b", a: "a" }
    let numOfInvokes = 0
    autorun(() => {
        numOfInvokes = numOfInvokes + 1
        return original.entries().next()
    })
    original.replace(replacement)
    const orgKeys = Array.from(original.keys())
    const newKeys = Object.keys(replacement)
    for (let i = 0; i < newKeys.length; i++) {
        expect(newKeys[i]).toEqual(orgKeys[i])
    }
    expect(numOfInvokes).toBe(2)
})

test("#1980 .replace should not report changed unnecessarily", () => {
    const mapArray = [
        ["swappedA", "swappedA"],
        ["swappedB", "swappedB"],
        ["removed", "removed"]
    ]
    const replacementArray = [mapArray[1], mapArray[0], ["added", "added"]]
    const map = mobx.observable.map(mapArray)
    let autorunInvocationCount = 0
    autorun(() => {
        map.get("swappedA")
        map.get("swappedB")
        autorunInvocationCount++
    })
    map.replace(replacementArray)
    expect(Array.from(map.entries())).toEqual(replacementArray)
    expect(autorunInvocationCount).toBe(1)
})

test("#1258 cannot replace maps anymore", () => {
    const items = mobx.observable.map()
    items.replace(mobx.observable.map())
})

test("can iterate maps", () => {
    const x = mobx.observable.map()
    const y = []
    const d = mobx.reaction(
        () => Array.from(x),
        items => y.push(items),
        { fireImmediately: true }
    )

    x.set("a", "A")
    x.set("b", "B")
    expect(y).toEqual([
        [],
        [["a", "A"]],
        [
            ["a", "A"],
            ["b", "B"]
        ]
    ])
    d()
})

function iteratorToArray(it) {
    const res = []
    while (true) {
        const r = it.next()
        if (!r.done) {
            res.push(r.value)
        } else {
            break
        }
    }
    return res
}

test("can iterate map - entries", () => {
    const x = mobx.observable.map()
    const y = []
    const d = mobx.reaction(
        () => iteratorToArray(x.entries()),
        items => y.push(items),
        {
            fireImmediately: true
        }
    )

    x.set("a", "A")
    x.set("b", "B")
    expect(y).toEqual([
        [],
        [["a", "A"]],
        [
            ["a", "A"],
            ["b", "B"]
        ]
    ])
    d()
})

test("can iterate map - keys", () => {
    const x = mobx.observable.map()
    const y = []
    const d = mobx.reaction(
        () => iteratorToArray(x.keys()),
        items => y.push(items),
        {
            fireImmediately: true
        }
    )

    x.set("a", "A")
    x.set("b", "B")
    expect(y).toEqual([[], ["a"], ["a", "b"]])
    d()
})

test("can iterate map - values", () => {
    const x = mobx.observable.map()
    const y = []
    const d = mobx.reaction(
        () => iteratorToArray(x.values()),
        items => y.push(items),
        {
            fireImmediately: true
        }
    )

    x.set("a", "A")
    x.set("b", "B")
    expect(y).toEqual([[], ["A"], ["A", "B"]])
    d()
})

test("NaN as map key", function () {
    const a = map(new Map([[NaN, 0]]))
    expect(a.has(NaN)).toBe(true)
    expect(a.get(NaN)).toBe(0)
    a.set(NaN, 1)
    a.merge(map(new Map([[NaN, 2]])))
    expect(a.get(NaN)).toBe(2)
    expect(a.size).toBe(1)
})

test("maps.values, keys and maps.entries are iterables", () => {
    const x = mobx.observable.map({ x: 1, y: 2 })
    expect(Array.from(x.entries())).toEqual([
        ["x", 1],
        ["y", 2]
    ])
    expect(Array.from(x.values())).toEqual([1, 2])
    expect(Array.from(x.keys())).toEqual(["x", "y"])
})

// Test support for [iterator-helpers](https://github.com/tc39/proposal-iterator-helpers)
test("esnext iterator helpers support", () => {
    const map = mobx.observable(
        new Map([
            ["x", [1, 2]],
            ["y", [3, 4]]
        ])
    )

    expect(Array.from(map.keys().map(value => value))).toEqual(["x", "y"])
    expect(Array.from(map.values().map(value => value))).toEqual([
        [1, 2],
        [3, 4]
    ])
    expect(Array.from(map.entries().map(([, value]) => value))).toEqual([
        [1, 2],
        [3, 4]
    ])

    expect(Array.from(map.entries().take(1))).toEqual([["x", [1, 2]]])
    expect(Array.from(map.entries().drop(1))).toEqual([["y", [3, 4]]])
    expect(Array.from(map.entries().filter(([key]) => key === "y"))).toEqual([["y", [3, 4]]])
    expect(Array.from(map.entries().find(([key]) => key === "y"))).toEqual(["y", [3, 4]])
    expect(map.entries().toArray()).toEqual(Array.from(map))

    expect(map.entries().toString()).toEqual("[object MapIterator]")
})

test("toStringTag", () => {
    const x = mobx.observable.map({ x: 1, y: 2 })
    expect(x[Symbol.toStringTag]).toBe("Map")
    expect(Object.prototype.toString.call(x)).toBe("[object Map]")
})

test("#1583 map.size not reactive", () => {
    const map = mobx.observable(new Map())
    const sizes = []

    const d = autorun(() => {
        sizes.push(map.size)
    })

    map.set(1, 1)
    map.set(2, 2)
    d()
    map.set(3, 3)
    expect(sizes).toEqual([0, 1, 2])
})

test("#1858 Map should not be inherited", () => {
    class MyMap extends Map {}

    const map = new MyMap()
    expect(() => {
        mobx.observable.map(map)
    }).toThrow("Cannot initialize from classes that inherit from Map: MyMap")
})

test("#2274", () => {
    const myMap = mobx.observable.map()
    myMap.set(1, 1)
    myMap.set(2, 1)
    myMap.set(3, 1)

    const newMap = mobx.observable.map()
    newMap.set(4, 1)
    newMap.set(5, 1)
    newMap.set(6, 1)

    myMap.replace(newMap)

    expect(Array.from(myMap.data_.keys())).toEqual([4, 5, 6])
    expect(myMap.has(2)).toBe(false)
})

test(".forEach() subscribes for key changes", () => {
    const map = mobx.observable.map()
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        map.forEach(_ => {})
    })

    map.set(1, 1)
    map.set(2, 2)
    map.delete(1)

    expect(autorunInvocationCount).toBe(4)
})

test(".keys() subscribes for key changes", () => {
    const map = mobx.observable.map()
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.keys()) {
            // empty
        }
    })

    map.set(1, 1)
    map.set(2, 2)
    map.delete(1)

    expect(autorunInvocationCount).toBe(4)
})

test(".values() subscribes for key changes", () => {
    const map = mobx.observable.map()
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.values()) {
            // empty
        }
    })

    map.set(1, 1)
    map.set(2, 2)
    map.delete(1)

    expect(autorunInvocationCount).toBe(4)
})

test(".entries() subscribes for key changes", () => {
    const map = mobx.observable.map()
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.entries()) {
            // empty
        }
    })

    map.set(1, 1)
    map.set(2, 2)
    map.delete(1)

    expect(autorunInvocationCount).toBe(4)
})

test(".toJSON() subscribes for key changes", () => {
    const map = mobx.observable.map()
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        map.toJSON()
    })

    map.set(1, 1)
    map.set(2, 2)
    map.delete(1)

    expect(autorunInvocationCount).toBe(4)
})

test(".entries() subscribes for value changes", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.entries()) {
            // empty
        }
    })

    map.set(1, 11)
    map.set(2, 22)
    map.set(3, 33)

    expect(autorunInvocationCount).toBe(4)
})

test(".values() subscribes for value changes", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.values()) {
            // empty
        }
    })

    map.set(1, 11)
    map.set(2, 22)
    map.set(3, 33)

    expect(autorunInvocationCount).toBe(4)
})

test(".forEach() subscribes for value changes", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        map.forEach(_ => {})
    })

    map.set(1, 11)
    map.set(2, 22)
    map.set(3, 33)

    expect(autorunInvocationCount).toBe(4)
})

test(".toJSON() subscribes for value changes", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        map.toJSON()
    })

    map.set(1, 11)
    map.set(2, 22)
    map.set(3, 33)

    expect(autorunInvocationCount).toBe(4)
})

test(".keys() does NOT subscribe for value changes", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.keys()) {
            // empty
        }
    })

    map.set(1, 11)
    map.set(2, 22)
    map.set(3, 33)

    expect(autorunInvocationCount).toBe(1)
})

test("noop mutations do NOT reportChanges", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    let autorunInvocationCount = 0

    autorun(() => {
        autorunInvocationCount++
        map.forEach(_ => {})
    })

    map.set(1, 1)
    map.set(2, 2)
    map.set(3, 3)
    map.delete("NOT IN MAP")
    map.merge([])
    map.merge([
        [1, 1],
        [3, 3]
    ])
    map.merge([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    map.replace([
        [1, 1],
        [2, 2],
        [3, 3]
    ])

    expect(autorunInvocationCount).toBe(1)
})

test(".replace() calls and respects interceptors", () => {
    const map = mobx.observable.map([
        [0, 0],
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    const replacementMap = [
        [3, 33],
        [4, 44],
        [5, 55],
        [0, 0]
    ]
    const expectedMap = [
        [2, 2],
        [3, 3],
        [5, 55],
        [0, 0]
    ]

    mobx.intercept(map, change => {
        // cancel delete 2
        if (change.type === "delete" && change.name === 2) {
            return null
        }
        // cancel update 3
        if (change.type === "update" && change.name === 3) {
            return null
        }
        // cancel add 4
        if (change.type === "add" && change.name === 4) {
            return null
        }
        return change
    })

    map.replace(replacementMap)

    expect(Array.from(map)).toEqual(expectedMap)
})

test(".replace() should reportChanged on key order change", () => {
    const map = mobx.observable.map([
        [1, 1],
        [2, 2],
        [3, 3]
    ])
    const replacementMap = [
        [4, 44],
        [3, 33],
        [2, 22]
    ]
    const expectedMap = [
        [1, 1],
        [3, 33],
        [2, 22]
    ]
    let autorunInvocationCount = 0

    mobx.intercept(map, change => {
        // cancel delete 1
        if (change.type === "delete" && change.name === 1) {
            return null
        }
        // cancel add 4
        if (change.type === "add" && change.name === 4) {
            return null
        }
        return change
    })

    autorun(() => {
        autorunInvocationCount++
        for (const _ of map.keys()) {
            // empty
        }
    })

    map.replace(replacementMap)

    expect(Array.from(map)).toEqual(expectedMap)
    expect(autorunInvocationCount).toBe(2)
})

test("#2112 - iterators should be resilient to concurrent delete operation", () => {
    function testIterator(method) {
        const map = mobx.observable.map([
            [1, 1],
            [2, 2],
            [3, 3]
        ])
        const expectedMap = mobx.observable.map(map)
        for (const entry of map[method]()) {
            const key = Array.isArray(entry) ? entry[0] : entry
            const deleted1 = map.delete(key)
            const deleted2 = expectedMap.delete(key)
            expect(deleted1).toBe(true)
            expect(deleted2).toBe(true)
            expect(map.size).toBe(expectedMap.size)
            expect(Array.from(map)).toEqual(Array.from(expectedMap))
        }
    }

    testIterator("keys")
    testIterator("values")
    testIterator("entries")
})

test("2346 - subscribe to not yet existing map keys", async () => {
    const events = observable([])

    class Compute {
        values = observable.map()

        @computed get get42() {
            return this.get(42)
        }

        constructor() {
            makeObservable(this)
        }

        get(k) {
            if (this.values.has(k)) return this.values.get(k)
            this.fetchValue(k)
            return this.values.get(k)
        }

        fetchValue = action(k => {
            let v = k
            this.values.set(k, k)
            setImmediate(() =>
                runInAction(() => {
                    v *= 2
                    this.values.set(k, v)
                })
            )
        })
    }

    const c = new Compute()

    autorun(() => events.push(c.get42))

    await when(() => events.length > 1)
    expect(events).toEqual([42, 84])
})

test('initialization should not violate `enforceActions: "always"` - discussion #3255', async () => {
    const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {
        throw new Error("console.warn called")
    })
    configure({ enforceActions: "always" })
    observable(new Map([["x", "x"]]))
    _resetGlobalState()
    consoleWarnSpy.mockRestore()
})



================================================
FILE: packages/mobx/__tests__/v5/base/nested.js
================================================
"use strict"

import { extendObservable, observable, autorun, computed, runInAction } from "../../../src/mobx"

test("nested computeds should not run unnecessary", () => {
    function Item(name) {
        extendObservable(this, {
            name: name,
            get index() {
                const i = store.items.indexOf(this)
                if (i === -1) throw "not found"
                return i
            }
        })
    }

    const store = observable({
        items: [],
        get asString() {
            return this.items.map(item => item.index + ":" + item.name).join(",")
        }
    })
    store.items.push(new Item("item1"))

    const values = []
    autorun(() => {
        values.push(store.asString)
    })

    store.items.replace([new Item("item2")])

    expect(values).toEqual(["0:item1", "0:item2"])
})

test("fix #1535: stale observables", cb => {
    // see https://codesandbox.io/s/k92o2jmz63
    const snapshots = []

    const x = observable.box(1)

    // Depends on observable x
    const derived1 = computed(() => {
        return x.get() + 1
    })

    // Depends on computed derived1
    const derived2 = computed(() => {
        return derived1.get() + 1
    })

    function increment() {
        runInAction(() => {
            x.set(x.get() + 1)
            // No problems here
            derived1.get()
            derived2.get()
        })
    }

    function brokenIncrement() {
        runInAction(() => x.set(x.get() + 1))
        // Acessing computed outside of action causes staleness
        // NOTE IT DOESN'T MATTER WHICH COMPUTED IS ACCESSED
        // derived1.get();
        derived2.get()
    }

    autorun(
        () => {
            snapshots.push(`${x.get()}, ${derived1.get()}, ${derived2.get()}`)
        },
        {
            scheduler(f) {
                setImmediate(f)
            }
        }
    )

    increment()
    setTimeout(() => {
        brokenIncrement()
    }, 100)
    setTimeout(() => {
        expect(snapshots).toEqual(["2, 3, 4", "3, 4, 5"])
        cb()
    }, 1000)
})



================================================
FILE: packages/mobx/__tests__/v5/base/object-api-proxy.js
================================================
const mobx = require("../../../src/mobx")
const { has, autorun, when, runInAction, reaction, observable } = mobx

test("keys should be observable when extending", () => {
    const todos = observable({})

    const todoTitles = []
    reaction(
        () => Object.keys(todos).map(key => `${key}: ${todos[key]}`),
        titles => todoTitles.push(titles.join(","))
    )

    runInAction(() => {
        Object.assign(todos, {
            lewis: "Read Lewis",
            chesterton: "Be mind blown by Chesterton"
        })
    })
    expect(todoTitles).toEqual(["lewis: Read Lewis,chesterton: Be mind blown by Chesterton"])

    Object.assign(todos, { lewis: "Read Lewis twice" })
    Object.assign(todos, { coffee: "Grab coffee" })
    expect(todoTitles).toEqual([
        "lewis: Read Lewis,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton,coffee: Grab coffee"
    ])
})

test("toJS respects key changes", () => {
    const todos = observable({})

    const serialized = []
    mobx.autorun(() => {
        serialized.push(JSON.stringify(mobx.toJS(todos)))
    })

    runInAction(() => {
        Object.assign(todos, {
            lewis: "Read Lewis",
            chesterton: "Be mind blown by Chesterton"
        })
    })
    Object.assign(todos, { lewis: "Read Lewis twice" })
    Object.assign(todos, { coffee: "Grab coffee" })
    expect(serialized).toEqual([
        "{}",
        '{"lewis":"Read Lewis","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton","coffee":"Grab coffee"}'
    ])
})

test("keys(object), values(object), entries(object)", () => {
    const todos = observable({})
    const plain = {}
    const keysSnapshots = []
    const valuesSnapshots = []
    const entriesSnapshots = []
    const expectedKeysSnapshots = []
    const expectedValuesSnapshots = []
    const expectedEntriesSnapshots = []

    const s1 = Symbol()
    const s2 = Symbol()

    function expectEquality() {
        expect(todos).toEqual(plain)
    }

    function expectKeysReaction() {
        expectedKeysSnapshots.push(Object.keys(plain))
    }

    function expectValuesReaction() {
        expectedValuesSnapshots.push(Object.values(plain))
    }

    function expectEntriesReaction() {
        expectedEntriesSnapshots.push(Object.entries(plain))
    }

    reaction(
        () => Object.keys(todos),
        result => keysSnapshots.push(result)
    )

    reaction(
        () => Object.values(todos),
        result => valuesSnapshots.push(result)
    )

    reaction(
        () => Object.entries(todos),
        result => entriesSnapshots.push(result)
    )

    expectEquality()
    // add
    todos["k1"] = 1
    plain["k1"] = 1
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add symbol
    todos[s1] = 2
    plain[s1] = 2
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete non-existent
    delete todos["-"]
    delete plain["-"]
    expectEquality()
    // delete non-existent symbol
    delete todos[Symbol()]
    delete plain[Symbol()]
    expectEquality()
    // add second
    todos["k2"] = 3
    plain["k2"] = 3
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add second symbol
    todos[s2] = 4
    plain[s2] = 4
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // update
    todos["k1"] = 11
    plain["k1"] = 11
    expectEquality()
    expectValuesReaction()
    expectEntriesReaction()
    // update symbol
    todos[s1] = 22
    plain[s1] = 22
    expectEquality()
    // delete
    delete todos["k1"]
    delete plain["k1"]
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete symbol
    delete todos[s1]
    delete plain[s1]
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()

    expect(keysSnapshots).toEqual(expectedKeysSnapshots)
    expect(valuesSnapshots).toEqual(expectedValuesSnapshots)
    expect(entriesSnapshots).toEqual(expectedEntriesSnapshots)
})

test("dynamically adding properties should preserve the original modifiers of an object", () => {
    const todos = observable.object(
        {
            a: { title: "get coffee" }
        },
        {},
        { deep: false }
    )
    expect(mobx.isObservable(todos.a)).toBe(false)
    Object.assign(todos, { b: { title: "get tea" } })
    expect(mobx.isObservable(todos.b)).toBe(false)
})

test("has and get are reactive", async () => {
    const todos = observable({})

    const p1 = when(() => {
        return "x" in todos
    })
    const p2 = when(() => {
        return todos.y === 3
    })

    setTimeout(() => {
        Object.assign(todos, { x: false, y: 3 })
    }, 100)

    await p1
    await p2
})

test("computed props are considered part of collections", () => {
    const x = observable({
        get y() {
            return 3
        }
    })
    expect(mobx.isComputedProp(x, "y")).toBe(true)
    expect(x.y).toBe(3)
    expect("y" in x).toBe(true) // `in` also checks proto type, so should return true!
    expect(Object.keys(x)).toEqual([])
    expect(Object.values(x)).toEqual([])
    expect(Object.entries(x)).toEqual([])
})

test("#1739 - delete and undelete should work", () => {
    const x = observable({})

    const events = []
    autorun(() => {
        // events.push("a" in x)
        events.push(has(x, "a"))
    })

    x.a = 1
    x.a++
    delete x.a
    x.a = 5
    delete x.a
    x.a = 5
    expect(events).toEqual([false, true, false, true, false, true])
})

test("defineProperty - configurable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: false,
        writable: true,
        value: 0
    }
    Object.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    obj.foo++
    expect(obj.foo).toBe(1)
    expect(() => mobx.extendObservable(obj, { foo: 0 })).toThrow(TypeError)
    expect(() => mobx.makeObservable(obj, { foo: mobx.observable })).toThrow(TypeError)
    expect(() => Object.defineProperty(obj, "foo", { configurable: false })).toThrow(TypeError)
})

test("defineProperty - writable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    Object.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(() => obj.foo++).toThrow(TypeError)
    mobx.extendObservable(obj, { foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    obj.foo++
    expect(obj.foo).toBe(1)
})

test("defineProperty - redefine observable", () => {
    const obj = mobx.observable({ foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    Object.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
})

test("defineProperty notifies keys observers", () => {
    const obj = mobx.observable({})
    let reactionCount = 0
    reaction(
        () => Object.keys(obj),
        () => reactionCount++
    )

    const desc = {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
    }
    Object.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(reactionCount).toBe(1)
    delete obj.foo
    expect(obj.hasOwnProperty("foo")).toBe(false)
    expect(reactionCount).toBe(2)
})



================================================
FILE: packages/mobx/__tests__/v5/base/object-api.js
================================================
const mobx = require("../../../src/mobx")
const { autorun, keys, when, set, remove, values, entries, reaction, observable, has, get } = mobx

test("keys should be observable when extending", () => {
    const todos = observable({})

    const todoTitles = []
    reaction(
        () => keys(todos).map(key => `${key}: ${todos[key]}`),
        titles => todoTitles.push(titles.join(","))
    )

    mobx.set(todos, {
        lewis: "Read Lewis",
        chesterton: "Be mind blown by Chesterton"
    })
    expect(todoTitles).toEqual(["lewis: Read Lewis,chesterton: Be mind blown by Chesterton"])

    mobx.set(todos, { lewis: "Read Lewis twice" })
    mobx.set(todos, { coffee: "Grab coffee" })
    expect(todoTitles).toEqual([
        "lewis: Read Lewis,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton",
        "lewis: Read Lewis twice,chesterton: Be mind blown by Chesterton,coffee: Grab coffee"
    ])
})

test("toJS respects key changes", () => {
    const todos = observable({})

    const serialized = []
    mobx.autorun(() => {
        serialized.push(JSON.stringify(mobx.toJS(todos)))
    })

    mobx.set(todos, {
        lewis: "Read Lewis",
        chesterton: "Be mind blown by Chesterton"
    })
    mobx.set(todos, { lewis: "Read Lewis twice" })
    mobx.set(todos, { coffee: "Grab coffee" })
    expect(serialized).toEqual([
        "{}",
        '{"lewis":"Read Lewis","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton"}',
        '{"lewis":"Read Lewis twice","chesterton":"Be mind blown by Chesterton","coffee":"Grab coffee"}'
    ])
})

test("keys(object), values(object), entries(object)", () => {
    const todos = observable({})
    const plain = {}
    const keysSnapshots = []
    const valuesSnapshots = []
    const entriesSnapshots = []
    const expectedKeysSnapshots = []
    const expectedValuesSnapshots = []
    const expectedEntriesSnapshots = []

    const s1 = Symbol()
    const s2 = Symbol()

    function expectEquality() {
        expect(todos).toEqual(plain)
    }

    function expectKeysReaction() {
        expectedKeysSnapshots.push(Object.keys(plain))
    }

    function expectValuesReaction() {
        expectedValuesSnapshots.push(Object.values(plain))
    }

    function expectEntriesReaction() {
        expectedEntriesSnapshots.push(Object.entries(plain))
    }

    reaction(
        () => keys(todos),
        result => keysSnapshots.push(result)
    )

    reaction(
        () => values(todos),
        result => valuesSnapshots.push(result)
    )

    reaction(
        () => entries(todos),
        result => entriesSnapshots.push(result)
    )

    expectEquality()
    // add
    set(todos, "k1", 1)
    plain["k1"] = 1
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add symbol
    set(todos, s1, 2)
    plain[s1] = 2
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete non-existent
    remove(todos, "-")
    delete plain["-"]
    expectEquality()
    // delete non-existent symbol
    remove(todos, Symbol())
    delete plain[Symbol()]
    expectEquality()
    // add second
    set(todos, "k2", 3)
    plain["k2"] = 3
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // add second symbol
    set(todos, s2, 4)
    plain[s2] = 4
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // update
    set(todos, "k1", 11)
    plain["k1"] = 11
    expectEquality()
    expectValuesReaction()
    expectEntriesReaction()
    // update symbol
    set(todos, s1, 22)
    plain[s1] = 22
    expectEquality()
    // delete
    remove(todos, "k1")
    delete plain["k1"]
    expectEquality()
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()
    // delete symbol
    remove(todos, s1)
    delete plain[s1]
    expectEquality()
    // see ObservableObjectAdministration.keys() for explanation
    expectKeysReaction()
    expectValuesReaction()
    expectEntriesReaction()

    expect(keysSnapshots).toEqual(expectedKeysSnapshots)
    expect(valuesSnapshots).toEqual(expectedValuesSnapshots)
    expect(entriesSnapshots).toEqual(expectedEntriesSnapshots)
})

test("values(map)", () => {
    const todos = observable.map({})
    const snapshots = []

    reaction(
        () => values(todos),
        values => snapshots.push(values)
    )

    expect(has(todos, "x")).toBe(false)
    expect(get(todos, "x")).toBe(undefined)
    set(todos, "x", 3)
    expect(has(todos, "x")).toBe(true)
    expect(get(todos, "x")).toBe(3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")

    expect(snapshots).toEqual([[3], [3, 4], [5, 4], [5]])
})

test("values(map) - symbols", () => {
    const todos = observable.map({})
    const snapshots = []
    const x = Symbol()
    const y = Symbol()
    const z = Symbol("z")

    reaction(
        () => values(todos),
        values => snapshots.push(values)
    )

    expect(has(todos, x)).toBe(false)
    expect(get(todos, x)).toBe(undefined)
    set(todos, x, 3)
    expect(has(todos, x)).toBe(true)
    expect(get(todos, x)).toBe(3)
    remove(todos, y)
    set(todos, z, 4)
    set(todos, x, 5)
    remove(todos, z)

    expect(snapshots).toEqual([[3], [3, 4], [5, 4], [5]])
})

test("entries(map)", () => {
    const todos = observable.map({})
    const snapshots = []

    reaction(
        () => entries(todos),
        entries => snapshots.push(entries)
    )

    expect(has(todos, "x")).toBe(false)
    expect(get(todos, "x")).toBe(undefined)
    set(todos, "x", 3)
    expect(has(todos, "x")).toBe(true)
    expect(get(todos, "x")).toBe(3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")

    expect(snapshots).toEqual([
        [["x", 3]],
        [
            ["x", 3],
            ["z", 4]
        ],
        [
            ["x", 5],
            ["z", 4]
        ],
        [["x", 5]]
    ])
})

test("entries(map) - symbols", () => {
    const todos = observable.map({})
    const snapshots = []
    const x = Symbol()
    const y = Symbol()
    const z = Symbol("z")

    reaction(
        () => entries(todos),
        entries => snapshots.push(entries)
    )

    expect(has(todos, x)).toBe(false)
    expect(get(todos, x)).toBe(undefined)
    set(todos, x, 3)
    expect(has(todos, x)).toBe(true)
    expect(get(todos, x)).toBe(3)
    remove(todos, y)
    set(todos, z, 4)
    set(todos, x, 5)
    remove(todos, z)

    expect(snapshots).toEqual([
        [[x, 3]],
        [
            [x, 3],
            [z, 4]
        ],
        [
            [x, 5],
            [z, 4]
        ],
        [[x, 5]]
    ])
})

test("keys(map)", () => {
    const todos = observable.map({ a: 3 })
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, "x", 3)
    remove(todos, "y")
    set(todos, "z", 4)
    set(todos, "x", 5)
    remove(todos, "z")
    remove(todos, "a")

    expect(snapshots).toEqual([["a", "x"], ["a", "x", "z"], ["a", "x"], ["x"]])
})

test("keys(map) - symbols", () => {
    const snapshots = []
    const x = Symbol()
    const y = Symbol()
    const z = Symbol("z")
    const a = Symbol()
    const todos = observable.map({ [a]: 3 })

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, x, 3)
    remove(todos, y)
    set(todos, z, 4)
    set(todos, x, 5)
    remove(todos, z)
    remove(todos, a)

    expect(snapshots).toEqual([[a, x], [a, x, z], [a, x], [x]])
})

test("values(array)", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => values(todos),
        values => snapshots.push(values)
    )

    expect(has(todos, 0)).toBe(false)
    expect(get(todos, 0)).toBe(undefined)
    set(todos, 0, 2)
    expect(has(todos, 0)).toBe(true)
    expect(get(todos, 0)).toBe(2)

    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([
        [2],
        [2, 4],
        [2, 4, undefined, 4],
        [2, 3, undefined, 4],
        [2, 3, 4],
        [3, 4]
    ])
})

test("entries(array)", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => entries(todos),
        entries => snapshots.push(entries)
    )

    expect(has(todos, 0)).toBe(false)
    expect(get(todos, 0)).toBe(undefined)
    set(todos, 0, 2)
    expect(has(todos, 0)).toBe(true)
    expect(get(todos, 0)).toBe(2)

    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([
        [[0, 2]],
        [
            [0, 2],
            [1, 4]
        ],
        [
            [0, 2],
            [1, 4],
            [2, undefined],
            [3, 4]
        ],
        [
            [0, 2],
            [1, 3],
            [2, undefined],
            [3, 4]
        ],
        [
            [0, 2],
            [1, 3],
            [2, 4]
        ],
        [
            [0, 3],
            [1, 4]
        ]
    ])
})

test("keys(array)", () => {
    const todos = observable.array()
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, 0, 2)
    set(todos, "1", 4)
    set(todos, 3, 4)
    set(todos, 1, 3)
    remove(todos, 2)
    remove(todos, "0")

    expect(snapshots).toEqual([[0], [0, 1], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2], [0, 1]])
})

test("observe & intercept", () => {
    let events = []
    const todos = observable(
        {
            a: { title: "get coffee" }
        },
        {},
        {
            deep: false,
            name: "TestObject" // stable name for snapshot
        }
    )
    mobx.observe(todos, c => {
        events.push({ observe: { ...c, object: "skip" } })
    })
    const d = mobx.intercept(todos, c => {
        events.push({ intercept: { ...c, object: "skip" } })
        return null // no addition!
    })

    set(todos, { b: { title: "get tea" } })
    remove(todos, "a")
    expect(events).toMatchSnapshot()
    expect(mobx.toJS(todos)).toEqual({
        a: { title: "get coffee" }
    })

    events.splice(0)
    d()
    set(todos, { b: { title: "get tea" } })
    remove(todos, "a")
    expect(events).toMatchSnapshot()
    expect(mobx.toJS(todos)).toEqual({
        b: { title: "get tea" }
    })
})

test("observe & intercept set called multiple times", () => {
    const a = mobx.observable({}, {}, { name: "TestObject" }) // stable name for snapshot
    const interceptLogs = []
    const observeLogs = []

    mobx.intercept(a, change => {
        interceptLogs.push(`${change.name}: ${change.newValue}`)
        return change
    })
    mobx.observe(a, change => observeLogs.push(`${change.name}: ${change.newValue}`))

    mobx.set(a, "x", 0)
    a.x = 1
    mobx.set(a, "x", 2)

    expect(interceptLogs).toEqual(["x: 0", "x: 1", "x: 2"])
    expect(observeLogs).toEqual(["x: 0", "x: 1", "x: 2"])
})

test("dynamically adding properties should preserve the original modifiers of an object", () => {
    const todos = observable.object(
        {
            a: { title: "get coffee" }
        },
        {},
        { deep: false }
    )
    expect(mobx.isObservable(todos.a)).toBe(false)
    set(todos, { b: { title: "get tea" } })
    expect(mobx.isObservable(todos.b)).toBe(false)
})

test("has and get are reactive", async () => {
    const todos = observable({})

    const p1 = when(() => has(todos, "x"))
    const p2 = when(() => get(todos, "y") === 3)

    setTimeout(() => {
        set(todos, { x: false, y: 3 })
    }, 100)

    await p1
    await p2
})

test("computed props are considered part of collections", () => {
    const x = observable({
        get y() {
            return 3
        }
    })
    expect(mobx.isComputedProp(x, "y")).toBe(true)
    expect(x.y).toBe(3)
    expect(has(x, "y")).toBe(true)
    expect(get(x, "y")).toBe(3)
    expect(keys(x)).toEqual([])
    expect(values(x)).toEqual([])
    expect(entries(x)).toEqual([])
})

test("#1739 - delete and undelete should work", () => {
    const x = observable({})

    const events = []
    autorun(() => {
        events.push(has(x, "a"))
    })

    set(x, "a", 1)
    set(x, "a", 2)
    remove(x, "a")
    set(x, "a", 2)
    remove(x, "a")
    set(x, "a", 3)
    expect(events).toEqual([false, true, false, true, false, true])
})

test("keys(set)", () => {
    const todos = observable.set([1])
    const snapshots = []

    reaction(
        () => keys(todos),
        keys => snapshots.push(keys)
    )

    set(todos, 2)
    remove(todos, 2)
    set(todos, 3)
    set(todos, 4)
    remove(todos, 3)

    expect(snapshots).toEqual([[1, 2], [1], [1, 3], [1, 3, 4], [1, 4]])
})

test("defineProperty - configurable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: false,
        writable: true,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    obj.foo++
    expect(obj.foo).toBe(1)
    expect(() => mobx.extendObservable(obj, { foo: 0 })).toThrow(TypeError)
    expect(() => mobx.makeObservable(obj, { foo: mobx.observable })).toThrow(TypeError)
    expect(() => mobx.defineProperty(obj, "foo", { configurable: false })).toThrow(TypeError)
})

test("defineProperty - writable: false", () => {
    const obj = mobx.observable({})
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(() => obj.foo++).toThrow(TypeError)
    mobx.extendObservable(obj, { foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    obj.foo++
    expect(obj.foo).toBe(1)
})

test("defineProperty - redefine observable", () => {
    const obj = mobx.observable({ foo: 0 })
    expect(mobx.isObservableProp(obj, "foo")).toBe(true)
    const desc = {
        enumerable: true,
        configurable: true,
        writable: false,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
})

test("defineProperty notifies keys observers", () => {
    const obj = mobx.observable({})
    let reactionCount = 0
    reaction(
        () => mobx.keys(obj),
        () => reactionCount++
    )

    const desc = {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
    }
    mobx.defineProperty(obj, "foo", desc)
    expect(Object.getOwnPropertyDescriptor(obj, "foo")).toEqual(desc)
    expect(mobx.isObservableProp(obj, "foo")).toBe(false)
    expect(reactionCount).toBe(1)
    mobx.remove(obj, 'foo');
    expect(obj.hasOwnProperty("foo")).toBe(false)
    expect(reactionCount).toBe(2)
})



================================================
FILE: packages/mobx/__tests__/v5/base/observe.ts
================================================
import { observable, observe, computed } from "../../../src/mobx"

test("observe object and map properties", () => {
    const map = observable.map({ a: 1 })
    const events: any[] = []

    expect(() => observe(map, "b", () => {})).toThrow(
        /the entry 'b' does not exist in the observable map/
    )

    const d1 = observe(map, "a", e => events.push([e.newValue, e.oldValue]))

    map.set("a", 2)
    map.set("a", 3)
    d1()
    map.set("a", 4)

    const o = observable({ a: 5 })

    expect(() => observe(o, "b" as any, () => {})).toThrow(
        /no observable property 'b' found on the observable object/
    )
    const d2 = observe(o, "a", e => events.push([e.newValue, e.oldValue]))

    o.a = 6
    o.a = 7
    d2()
    o.a = 8

    expect(events).toEqual([
        [2, 1],
        [3, 2],
        [6, 5],
        [7, 6]
    ])
})

test("observe computed values", () => {
    const events: any[] = []

    const v = observable.box(0)
    const f = observable.box(0)
    const c = computed(() => v.get())

    observe(c, e => {
        v.get()
        f.get()
        events.push([e.newValue, e.oldValue])
    })

    v.set(6)
    f.set(10)

    expect(events).toEqual([[6, 0]])
})



================================================
FILE: packages/mobx/__tests__/v5/base/proxies.js
================================================
import {
    computed,
    isComputedProp,
    isAction,
    isObservableProp,
    autorun,
    observable,
    action,
    reaction,
    extendObservable,
    keys,
    makeObservable
} from "../../../src/mobx"

import { stripAdminFromDescriptors } from "../utils/test-utils"

test("should react to key removal (unless reconfiguraing to empty) - 1", () => {
    const events = []
    const x = observable.object({
        y: 1,
        z: 1
    })

    reaction(
        () => Object.keys(x),
        keys => events.push(keys.join(",")),
        { fireImmediately: true }
    )
    expect(events).toEqual(["y,z"])
    delete x.y
    expect(events).toEqual(["y,z", "z"])
    // should not trigger another time..
    delete x.y
    expect(events).toEqual(["y,z", "z"])
})

test("should react to key removal (unless reconfiguraing to empty) - 2", () => {
    const events = []
    const x = observable.object({
        y: 1,
        z: 1
    })

    reaction(
        () => x.z,
        v => events.push(v)
    )

    delete x.z
    expect(events).toEqual([undefined])
})

test("should react to key removal (unless reconfiguraing to empty) - 2", () => {
    const events = []
    const x = observable.object({
        y: 1,
        z: undefined
    })

    reaction(
        () => x.z,
        v => events.push(v)
    )

    delete x.z
    expect(events).toEqual([])
})

test("should react to future key additions - 1", () => {
    const events = []
    const x = observable.object({})

    reaction(
        () => Object.keys(x),
        keys => events.push(keys.join(","))
    )

    x.y = undefined
    expect(events).toEqual(["y"])
})

test("should react to future key additions - 2", () => {
    const events = []
    const x = observable.object({})

    reaction(
        () => {
            return x.z
        },
        v => {
            events.push(v)
        }
    )

    x.z = undefined
    expect(Object.keys(x)).toEqual(["z"])
    x.y = 3
    expect(events).toEqual([])
    delete x.y
    expect(events).toEqual([])
    x.z = 4
    expect(events).toEqual([4])
})

test("correct keys are reported", () => {
    const x = observable.object({
        x: 1,
        get y() {
            return 2
        }
    })
    x.z = 3
    extendObservable(x, {
        a: 4,
        get b() {
            return 5
        }
    })
    x.y
    x.b // make sure it is read

    expect(Object.keys(x)).toEqual(["x", "z", "a"])
    expect(Object.values(x)).toEqual([1, 3, 4])
    expect(Object.entries(x)).toEqual([
        ["x", 1],
        ["z", 3],
        ["a", 4]
    ])

    expect(Object.getOwnPropertyNames(x)).toEqual(["x", "y", "z", "a", "b"])
    expect(keys(x)).toEqual(["x", "z", "a"])

    delete x.x
    expect(Object.keys(x)).toEqual(["z", "a"])
    expect(Object.getOwnPropertyNames(x)).toEqual(["y", "z", "a", "b"])
    expect(keys(x)).toEqual(["z", "a"])
})

test("in operator", () => {
    const x = observable.object({
        x: 1,
        get y() {
            return 2
        }
    })
    x.z = 3
    extendObservable(x, {
        a: 4,
        get b() {
            return 5
        }
    })
    expect("x" in x).toBeTruthy()
    expect("y" in x).toBeTruthy()
    expect("a" in x).toBeTruthy()
    expect("b" in x).toBeTruthy()
    expect("z" in x).toBeTruthy()
    expect("c" in x).toBeFalsy()
    expect("c" in x).toBeFalsy() // not accidentally create
    delete x.x
    expect("x" in x).toBeFalsy()
})

test("for-in operator", () => {
    const x = observable.object({
        x: 1,
        get y() {
            return 2
        }
    })
    x.z = 3
    extendObservable(x, {
        a: 4,
        get b() {
            return 5
        }
    })

    function computeKeys() {
        const res = []
        for (let key in x) res.push(key)
        return res
    }

    expect(computeKeys(x)).toEqual(["x", "z", "a"])
    delete x.x
    expect(computeKeys(x)).toEqual(["z", "a"])
})

test("type coercion doesn't break", () => {
    const x = observable({})
    expect("" + x).toBe("[object Object]")
    expect(42 * x).toBeNaN()
})

test("adding a different key doesn't trigger a pending key", () => {
    const x = observable({})
    let counter = 0

    const d = autorun(() => {
        x.x
        counter++
    })
    expect(counter).toBe(1)

    x.y = 3
    expect(counter).toBe(1)

    x.x = 3
    expect(counter).toBe(2)

    d()
})

test("proxy false reverts to original behavior", () => {
    const x = observable({ x: 3 }, {}, { proxy: false })
    x.y = 3
    expect(isObservableProp(x, "x")).toBe(true)
    expect(isObservableProp(x, "y")).toBe(false)
})

test("ownKeys invariant not broken - 1", () => {
    const a = observable({ x: 3, get y() {} })
    expect(() => {
        Object.freeze(a)
    }).toThrow("cannot be frozen")
})

test("ownKeys invariant not broken - 2", () => {
    const a = observable([2])
    expect(() => {
        Object.freeze(a)
    }).toThrow("cannot be frozen")
})

test("non-proxied object", () => {
    const a = observable({ x: 3 }, {}, { proxy: false })
    a.b = 4
    extendObservable(
        a,
        {
            double() {
                this.x = this.x * 2
            },
            get y() {
                return this.x * 2
            }
        },
        {
            double: action
        }
    )

    expect(a.y).toBe(6)
    a.double()
    expect(a.y).toBe(12)
    expect(isComputedProp(a, "y")).toBe(true)
    expect(isAction(a.double)).toBe(true)
    expect(stripAdminFromDescriptors(Object.getOwnPropertyDescriptors(a))).toMatchSnapshot()
    expect(Object.keys(a)).toEqual(["x", "b"])
})

test("extend proxies", () => {
    const a = observable({ x: 3 })
    a.b = 4
    extendObservable(
        a,
        {
            double() {
                this.x = this.x * 2
            },
            get y() {
                return this.x * 2
            }
        },
        {
            double: action
        }
    )

    expect(a.y).toBe(6)
    a.double()
    expect(a.y).toBe(12)
    expect(isComputedProp(a, "y")).toBe(true)
    expect(isAction(a.double)).toBe(true)
    expect(stripAdminFromDescriptors(Object.getOwnPropertyDescriptors(a))).toMatchSnapshot()
    expect(Object.keys(a)).toEqual(["x", "b"])
})

test("decorate proxies", () => {
    const a = observable({ x: 3 })
    a.b = 4
    extendObservable(
        a,
        {
            double() {
                this.x = this.x * 2
            },
            get y() {
                return this.x * 2
            }
        },
        {
            double: action
        }
    )

    expect(a.y).toBe(6)
    a.double()
    expect(a.y).toBe(12)
    expect(isComputedProp(a, "y")).toBe(true)
    expect(isAction(a.double)).toBe(true)
    expect(stripAdminFromDescriptors(Object.getOwnPropertyDescriptors(a))).toMatchSnapshot()
    expect(Object.keys(a)).toEqual(["x", "b"])
})

test("predictable 'this' - 1", () => {
    const a = observable.object(
        {
            a0() {
                return this
            },
            a1() {
                return this
            },
            a2() {
                return this
            },
            get computed() {
                return this
            }
        },
        {
            a1: action,
            a2: action.bound
        }
    )

    expect(a.a0()).toBe(a)
    expect(a.a1()).toBe(a)
    expect(a.a2()).toBe(a) // pre-bound!
    expect(a.computed).toBe(a)
})

test("predictable 'this' - 2", () => {
    class A {
        constructor() {
            makeObservable(this, {
                a1: action,
                a2: action.bound,
                computed: computed
            })
        }

        a0() {
            return this
        }

        a1() {
            return this
        }

        a2() {
            return this
        }

        get computed() {
            return this
        }
    }

    const a = new A()

    expect(a.a0()).toBe(a)
    expect(a.a1()).toBe(a)
    expect(a.a2()).toBe(a)
    expect(a.computed).toBe(a)
})

test("1796 - delete -> recreate observable prop", () => {
    let value = observable({
        foo: undefined // if foo is something like 'abc', it works.
    })

    const events = []

    autorun(() => {
        events.push(value.foo)
    })
    delete value.foo
    value.foo = "def"
    expect(events).toEqual([
        undefined,
        undefined, // ideally  not, but ok..
        "def"
    ])
})

test("1796 - delete -> recreate computed prop", () => {
    let value = observable({
        foo: undefined,
        get bar() {
            return this.foo
        }
    })

    expect(isComputedProp(value, "bar")).toBe(true)

    const events = []

    autorun(() => {
        events.push(value.bar)
    })
    delete value.bar
    value.bar = "def"
    expect(isObservableProp(value, "bar")).toBe(true)
    expect(isComputedProp(value, "bar")).toBe(false)

    expect(events).toEqual([undefined, undefined, "def"])
})



================================================
FILE: packages/mobx/__tests__/v5/base/reaction.js
================================================
/**
 * @type {typeof import("./../../../src/v5/mobx")}
 */
const mobx = require("../../../src/mobx.ts")
const reaction = mobx.reaction
const $mobx = mobx.$mobx
const utils = require("../../v5/utils/test-utils")

test("basic", () => {
    const a = mobx.observable.box(1)
    const values = []

    const d = reaction(
        () => a.get(),
        (newValue, oldValue) => {
            values.push([newValue, oldValue])
        }
    )

    a.set(2)
    a.set(3)
    d()
    a.set(4)

    expect(values).toEqual([
        [2, 1],
        [3, 2]
    ])
})

test("effect fireImmediately is honored", () => {
    const a = mobx.observable.box(1)
    const values = []

    const d = reaction(
        () => a.get(),
        newValue => {
            values.push(newValue)
        },
        { fireImmediately: true }
    )

    a.set(2)
    a.set(3)
    d()
    a.set(4)

    expect(values).toEqual([1, 2, 3])
})

test("effect is untracked", () => {
    const a = mobx.observable.box(1)
    const b = mobx.observable.box(2)
    const values = []

    const d = reaction(
        () => a.get(),
        newValue => {
            values.push(newValue * b.get())
        },
        { fireImmediately: true }
    )

    a.set(2)
    b.set(7) // shoudn't trigger a new change
    a.set(3)
    d()
    a.set(4)

    expect(values).toEqual([2, 4, 21])
})

let TIME_AMPLIFIER = 1
if (process.env.CI === "true") {
    console.log("Amplifying time")
    jest.setTimeout(50 * 1000)
    TIME_AMPLIFIER = 10
}

test("effect debounce is honored", () => {
    expect.assertions(2)

    return new Promise((resolve, reject) => {
        const a = mobx.observable.box(1)
        const values = []
        let exprCount = 0

        const d = reaction(
            () => {
                exprCount++
                return a.get()
            },
            newValue => {
                values.push(newValue)
            },
            {
                delay: 150 * TIME_AMPLIFIER,
                fireImmediately: false
            }
        )

        setTimeout(() => a.set(2), 40 * TIME_AMPLIFIER)
        setTimeout(() => {
            a.set(3) // should not be visible, combined with the next
            setImmediate(() => {
                a.set(4)
            })
        }, 300 * TIME_AMPLIFIER)
        setTimeout(() => a.set(5), 600 * TIME_AMPLIFIER)
        setTimeout(() => {
            d()
            a.set(6)
        }, 1000 * TIME_AMPLIFIER)

        setTimeout(() => {
            try {
                expect(values).toEqual([2, 4, 5])
                expect(exprCount).toBe(4)
                resolve()
            } catch (e) {
                reject(e)
            }
        }, 1200 * TIME_AMPLIFIER)
    })
})

test("effect debounce + fire immediately is honored", () => {
    expect.assertions(2)
    return new Promise((resolve, reject) => {
        const a = mobx.observable.box(1)
        const values = []
        let exprCount = 0

        const d = reaction(
            () => {
                exprCount++
                return a.get()
            },
            newValue => {
                values.push(newValue)
            },
            {
                fireImmediately: true,
                delay: 100 * TIME_AMPLIFIER
            }
        )

        setTimeout(() => a.set(3), 150 * TIME_AMPLIFIER)
        setTimeout(() => a.set(4), 300 * TIME_AMPLIFIER)

        setTimeout(() => {
            try {
                d()
                expect(values).toEqual([1, 3, 4])
                expect(exprCount).toBe(3)
                resolve()
            } catch (e) {
                reject(e)
            }
        }, 500 * TIME_AMPLIFIER)
    })
})

test("passes Reaction as an argument to expression function", () => {
    const a = mobx.observable.box(1)
    const values = []

    reaction(
        r => {
            if (a.get() === "pleaseDispose") r.dispose()
            return a.get()
        },
        newValue => {
            values.push(newValue)
        },
        { fireImmediately: true }
    )

    a.set(2)
    a.set(2)
    a.set("pleaseDispose")
    a.set(3)
    a.set(4)

    expect(values).toEqual([1, 2, "pleaseDispose"])
})

test("passes Reaction as an argument to effect function", () => {
    const a = mobx.observable.box(1)
    const values = []

    reaction(
        () => a.get(),
        (newValue, _oldValue, r) => {
            if (a.get() === "pleaseDispose") r.dispose()
            values.push(newValue)
        },
        { fireImmediately: true }
    )

    a.set(2)
    a.set(2)
    a.set("pleaseDispose")
    a.set(3)
    a.set(4)

    expect(values).toEqual([1, 2, "pleaseDispose"])
})

test("can dispose reaction on first run", () => {
    const a = mobx.observable.box(1)

    const valuesExpr1st = []
    reaction(
        () => a.get(),
        (newValue, oldValue, r) => {
            r.dispose()
            valuesExpr1st.push([newValue, oldValue])
        },
        { fireImmediately: true }
    )

    const valuesEffect1st = []
    reaction(
        r => {
            r.dispose()
            return a.get()
        },
        (newValue, oldValue) => {
            valuesEffect1st.push([newValue, oldValue])
        },
        { fireImmediately: true }
    )

    const valuesExpr = []
    reaction(
        () => a.get(),
        (newValue, oldValue, r) => {
            r.dispose()
            valuesExpr.push([newValue, oldValue])
        }
    )

    const valuesEffect = []
    reaction(
        r => {
            r.dispose()
            return a.get()
        },
        (newValue, oldValue) => {
            valuesEffect.push([newValue, oldValue])
        }
    )

    a.set(2)
    a.set(3)

    expect(valuesExpr1st).toEqual([[1, undefined]])
    expect(valuesEffect1st).toEqual([[1, undefined]])
    expect(valuesExpr).toEqual([[2, 1]])
    expect(valuesEffect).toEqual([])
})

test("can dispose reaction with AbortSignal", () => {
    const a = mobx.observable.box(1)
    const ac = new AbortController()
    const values = []

    reaction(
        () => a.get(),
        (newValue, oldValue) => {
            values.push([newValue, oldValue])
        },
        { signal: ac.signal }
    )

    a.set(2)
    a.set(3)
    ac.abort()
    a.set(4)

    expect(values).toEqual([
        [2, 1],
        [3, 2]
    ])
})

test("fireImmediately should not be honored when passed already aborted AbortSignal", () => {
    const a = mobx.observable.box(1)
    const ac = new AbortController()
    const values = []

    ac.abort()

    reaction(
        () => a.get(),
        (newValue) => {
            values.push(newValue)
        },
        { signal: ac.signal, fireImmediately: true }
    )

    expect(values).toEqual([])
})

test("#278 do not rerun if expr output doesn't change", () => {
    const a = mobx.observable.box(1)
    const values = []

    const d = reaction(
        () => (a.get() < 10 ? a.get() : 11),
        newValue => {
            values.push(newValue)
        }
    )

    a.set(2)
    a.set(3)
    a.set(10)
    a.set(11)
    a.set(12)
    a.set(4)
    a.set(5)
    a.set(13)

    d()
    a.set(4)

    expect(values).toEqual([2, 3, 11, 4, 5, 11])
})

test("#278 do not rerun if expr output doesn't change structurally", () => {
    const users = mobx.observable([
        {
            name: "jan",
            get uppername() {
                return this.name.toUpperCase()
            }
        },
        {
            name: "piet",
            get uppername() {
                return this.name.toUpperCase()
            }
        }
    ])
    const values = []

    const d = reaction(
        () => users.map(user => user.uppername),
        newValue => {
            values.push(newValue)
        },
        {
            fireImmediately: true,
            compareStructural: true
        }
    )

    users[0].name = "john"
    users[0].name = "JoHn"
    users[0].name = "jOHN"
    users[1].name = "johan"

    d()
    users[1].name = "w00t"

    expect(values).toEqual([
        ["JAN", "PIET"],
        ["JOHN", "PIET"],
        ["JOHN", "JOHAN"]
    ])
})

test("do not rerun if prev & next expr output is NaN", () => {
    const v = mobx.observable.box("a")
    const values = []
    const valuesS = []

    const d = reaction(
        () => v.get(),
        newValue => {
            values.push(String(newValue))
        },
        { fireImmediately: true }
    )
    const dd = reaction(
        () => v.get(),
        newValue => {
            valuesS.push(String(newValue))
        },
        { fireImmediately: true, compareStructural: true }
    )

    v.set(NaN)
    v.set(NaN)
    v.set(NaN)
    v.set("b")

    d()
    dd()

    expect(values).toEqual(["a", "NaN", "b"])
    expect(valuesS).toEqual(["a", "NaN", "b"])
})

test("reaction uses equals", () => {
    const o = mobx.observable.box("a")
    const values = []
    const disposeReaction = mobx.reaction(
        () => o.get(),
        value => values.push(value.toLowerCase()),
        { equals: (from, to) => from.toUpperCase() === to.toUpperCase(), fireImmediately: true }
    )
    expect(values).toEqual(["a"])
    o.set("A")
    expect(values).toEqual(["a"])
    o.set("B")
    expect(values).toEqual(["a", "b"])
    o.set("A")
    expect(values).toEqual(["a", "b", "a"])

    disposeReaction()
})

test("reaction equals function only invoked when necessary", () => {
    utils.supressConsole(() => {
        const comparisons = []
        const loggingComparer = (from, to) => {
            comparisons.push({ from, to })
            return from === to
        }

        const left = mobx.observable.box("A")
        const right = mobx.observable.box("B")

        const values = []
        const disposeReaction = mobx.reaction(
            // Note: exceptions thrown here are intentional!
            () => left.get().toLowerCase() + right.get().toLowerCase(),
            value => values.push(value),
            { equals: loggingComparer, fireImmediately: true }
        )

        // No comparison should be made on the first value
        expect(comparisons).toEqual([])

        // First change will cause a comparison
        left.set("C")
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Exception in the reaction expression won't cause a comparison
        left.set(null)
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Another exception in the reaction expression won't cause a comparison
        right.set(null)
        expect(comparisons).toEqual([{ from: "ab", to: "cb" }])

        // Transition from exception in the expression will cause a comparison with the last valid value
        left.set("D")
        right.set("E")
        expect(comparisons).toEqual([
            { from: "ab", to: "cb" },
            { from: "cb", to: "de" }
        ])

        // Another value change will cause a comparison
        right.set("F")
        expect(comparisons).toEqual([
            { from: "ab", to: "cb" },
            { from: "cb", to: "de" },
            { from: "de", to: "df" }
        ])

        expect(values).toEqual(["ab", "cb", "de", "df"])

        disposeReaction()
    })
})

test("issue #1148", () => {
    const a = mobx.observable.box(1)
    let called = 0
    const dispose = reaction(
        () => a.get(),
        () => {
            called++
        },
        { delay: 1 }
    )
    a.set(2)
    dispose()
    expect(called).toBe(0)
})

test("Introduce custom onError for - autorun - 1", () => {
    let error = ""
    let globalHandlerCalled = false
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    expect(() => {
        mobx.autorun(
            () => {
                throw "OOPS"
            },
            {
                onError(e) {
                    error = e
                }
            }
        )
    }).not.toThrow()
    expect(error).toBe("OOPS")
    expect(globalHandlerCalled).toBe(false)
    d()
})

test("Introduce custom onError for - autorun - 2", done => {
    let globalHandlerCalled = false
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    expect(() => {
        mobx.autorun(
            () => {
                throw "OOPS"
            },
            {
                delay: 5,
                onError(error) {
                    setImmediate(() => {
                        expect(error).toBe("OOPS")
                        expect(globalHandlerCalled).toBe(false)
                        d()
                        done()
                    })
                }
            }
        )
    }).not.toThrow()
})

test("Introduce custom onError for - reaction - 1", () => {
    let error = ""
    let globalHandlerCalled = false
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    expect(() => {
        mobx.reaction(
            () => {
                throw "OOPS"
            },
            () => {},
            {
                onError(e) {
                    error = e
                }
            }
        )
    }).not.toThrow()
    expect(error).toBe("OOPS")
    expect(globalHandlerCalled).toBe(false)
    d()
})

test("Introduce custom onError for - reaction - 2", () => {
    let error = ""
    let globalHandlerCalled = false
    let box = mobx.observable.box(1)
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    mobx.reaction(
        () => box.get(),
        () => {
            throw "OOPS"
        },
        {
            onError(e) {
                error = e
            }
        }
    )
    expect(() => {
        box.set(2)
    }).not.toThrow()
    expect(error).toBe("OOPS")
    expect(globalHandlerCalled).toBe(false)
    d()
})

test("Introduce custom onError for - reaction - 3", done => {
    let globalHandlerCalled = false
    let box = mobx.observable.box(1)
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    mobx.reaction(
        () => box.get(),
        () => {
            throw "OOPS"
        },
        {
            delay: 5,
            onError(e) {
                expect(e).toBe("OOPS")
                setImmediate(() => {
                    expect(globalHandlerCalled).toBe(false)
                    d()
                    done()
                })
            }
        }
    )
    expect(() => {
        box.set(2)
    }).not.toThrow()
})

test("Introduce custom onError for - when - 1", () => {
    let error = ""
    let globalHandlerCalled = false
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    expect(() => {
        mobx.when(
            () => {
                throw "OOPS"
            },
            () => {},
            {
                onError(e) {
                    error = e
                }
            }
        )
    }).not.toThrow()
    expect(error).toBe("OOPS")
    expect(globalHandlerCalled).toBe(false)
    d()
})

test("Introduce custom onError for - when - 2", () => {
    let error = ""
    let globalHandlerCalled = false
    let box = mobx.observable.box(1)
    const d = mobx.onReactionError(() => {
        globalHandlerCalled = true
    })
    mobx.when(
        () => box.get() === 2,
        () => {
            throw "OOPS"
        },
        {
            onError(e) {
                error = e
            }
        }
    )
    expect(() => {
        box.set(2)
    }).not.toThrow()
    expect(error).toBe("OOPS")
    expect(globalHandlerCalled).toBe(false)
    d()
})

describe("reaction opts requiresObservable", () => {
    test("warn when no observable", () => {
        utils.consoleWarn(() => {
            const disposer = mobx.reaction(
                () => 2,
                () => 1,
                {
                    requiresObservable: true
                }
            )

            disposer()
        }, /is created\/updated without reading any observable value/)
    })

    test("Don't warn when observable", () => {
        const obsr = mobx.observable({
            x: 1
        })

        const messages = utils.supressConsole(() => {
            const disposer = mobx.reaction(
                () => obsr.x,
                () => 1,
                {
                    requiresObservable: true
                }
            )

            disposer()
        })

        expect(messages.length).toBe(0)
    })
})

describe("explicit resource management", () => {
    Symbol.dispose ??= Symbol("Symbol.dispose")

    test("reaction has [Symbol.dispose] and calling it disposes of reaction", () => {
        const a = mobx.observable.box(1)
        const values = []

        const disposeReaction = reaction(
            () => a.get(),
            newValue => {
                values.push(newValue)
            }
        )

        expect(disposeReaction[Symbol.dispose]).toBeInstanceOf(Function)

        disposeReaction[Symbol.dispose]()
        a.set(2)

        expect(values).toEqual([])
        expect(disposeReaction[$mobx].isDisposed).toBe(true)
    })
})



================================================
FILE: packages/mobx/__tests__/v5/base/set.js
================================================
"use strict"

const mobx = require("../../../src/mobx.ts")
const set = mobx.observable.set
const autorun = mobx.autorun
const iterall = require("iterall")

test("set crud", function () {
    const events = []
    const s = set([1])

    mobx.observe(s, change => {
        expect(change.observableKind).toEqual("set")
        delete change.observableKind
        delete change.debugObjectName
        events.push(change)
    })

    expect(s.has(1)).toBe(true)
    expect(s.has("1")).toBe(false)
    expect(s.size).toBe(1)

    s.add("2")

    expect(s.has("2")).toBe(true)
    expect(s.size).toBe(2)
    expect(mobx.keys(s)).toEqual([1, "2"])
    expect(mobx.values(s)).toEqual([1, "2"])
    expect(mobx.entries(s)).toEqual([
        [1, 1],
        ["2", "2"]
    ])
    expect(Array.from(s)).toEqual([1, "2"])
    // TODO: fix! expect(mobx.toJS(s)).toEqual(new Set([1, "2"]))
    expect(s.toJSON()).toEqual([1, "2"])
    expect(s.toString()).toBe("[object ObservableSet]")

    s.replace(new Set([3]))

    expect(mobx.keys(s)).toEqual([3])
    expect(mobx.values(s)).toEqual([3])
    expect(s.size).toBe(1)
    expect(s.has(1)).toBe(false)
    expect(s.has("2")).toBe(false)
    expect(s.has(3)).toBe(true)

    s.replace(set([4]))

    expect(mobx.keys(s)).toEqual([4])
    expect(mobx.values(s)).toEqual([4])
    expect(s.size).toBe(1)
    expect(s.has(1)).toBe(false)
    expect(s.has("2")).toBe(false)
    expect(s.has(3)).toBe(false)
    expect(s.has(4)).toBe(true)

    expect(() => {
        s.replace("")
    }).toThrow(/Cannot initialize set from/)

    s.clear()
    expect(mobx.keys(s)).toEqual([])
    expect(mobx.values(s)).toEqual([])
    expect(s.size).toBe(0)
    expect(s.has(1)).toBe(false)
    expect(s.has("2")).toBe(false)
    expect(s.has(3)).toBe(false)
    expect(s.has(4)).toBe(false)

    expect(events).toEqual([
        { object: s, newValue: "2", type: "add" },
        { object: s, oldValue: 1, type: "delete" },
        { object: s, oldValue: "2", type: "delete" },
        { object: s, newValue: 3, type: "add" },
        { object: s, oldValue: 3, type: "delete" },
        { object: s, newValue: 4, type: "add" },
        { object: s, oldValue: 4, type: "delete" }
    ])
})

test("observe value", function () {
    const s = set()
    let hasX = false
    let hasY = false

    autorun(function () {
        hasX = s.has("x")
    })
    autorun(function () {
        hasY = s.has("y")
    })

    expect(hasX).toBe(false)

    s.add("x")
    expect(hasX).toBe(true)

    s.delete("x")
    expect(hasX).toBe(false)

    s.replace(["y"])
    expect(hasX).toBe(false)
    expect(hasY).toBe(true)
    expect(mobx.values(s)).toEqual(["y"])
})

test("observe collections", function () {
    const x = set()
    let keys, values, entries

    autorun(function () {
        keys = mobx.keys(x)
    })
    autorun(function () {
        values = Array.from(x.values())
    })
    autorun(function () {
        entries = Array.from(x.entries())
    })

    x.add("a")
    expect(keys).toEqual(["a"])
    expect(values).toEqual(["a"])
    expect(entries).toEqual([["a", "a"]])

    x.forEach(value => {
        expect(x.has(value)).toBe(true)
    })

    // should not retrigger:
    keys = null
    values = null
    entries = null
    x.add("a")
    expect(keys).toEqual(null)
    expect(values).toEqual(null)
    expect(entries).toEqual(null)

    x.add("b")
    expect(keys).toEqual(["a", "b"])
    expect(values).toEqual(["a", "b"])
    expect(entries).toEqual([
        ["a", "a"],
        ["b", "b"]
    ])

    x.delete("a")
    expect(keys).toEqual(["b"])
    expect(values).toEqual(["b"])
    expect(entries).toEqual([["b", "b"]])
})

test("set modifier", () => {
    const x = set([{ a: 1 }])
    const y = mobx.observable({ a: x })

    expect(mobx.isObservableSet(x)).toBe(true)
    expect(mobx.isObservableObject(y)).toBe(true)
    expect(mobx.isObservableObject(y.a)).toBe(false)
    expect(mobx.isObservableSet(y.a)).toBe(true)
})

test("cleanup", function () {
    const s = set(["a"])

    let hasA

    autorun(function () {
        hasA = s.has("a")
    })

    expect(hasA).toBe(true)
    expect(s.delete("a")).toBe(true)
    expect(s.delete("not-existing")).toBe(false)
    expect(hasA).toBe(false)
})

test("set should support iterall / iterable ", () => {
    const a = set([1, 2])

    function leech(iter) {
        const values = []
        let v
        do {
            v = iter.next()
            if (!v.done) values.push(v.value)
        } while (!v.done)
        return values
    }

    expect(iterall.isIterable(a)).toBe(true)

    expect(leech(iterall.getIterator(a))).toEqual([1, 2])

    expect(leech(a.entries())).toEqual([
        [1, 1],
        [2, 2]
    ])

    expect(leech(a.keys())).toEqual([1, 2])
    expect(leech(a.values())).toEqual([1, 2])
})

// Test support for [iterator-helpers](https://github.com/tc39/proposal-iterator-helpers)
test("esnext iterator helpers support", () => {
    const set = mobx.observable(
        new Set([
            [1, 2],
            [3, 4]
        ])
    )

    expect(Array.from(set.values().map(value => value))).toEqual([
        [1, 2],
        [3, 4]
    ])

    expect(Array.from(set.entries().map(([, value]) => value))).toEqual([
        [1, 2],
        [3, 4]
    ])

    expect(Array.from(set.values().take(1))).toEqual([[1, 2]])
    expect(Array.from(set.values().drop(1))).toEqual([[3, 4]])
    expect(Array.from(set.values().filter(value => value[0] === 3))).toEqual([[3, 4]])
    expect(Array.from(set.values().find(value => value[0] === 3))).toEqual([3, 4])
    expect(Array.from(set.values().flatMap(value => value))).toEqual([1, 2, 3, 4])

    expect(set.entries().toString()).toEqual("[object SetIterator]")
})

test("support for ES6 Set", () => {
    const x = new Set()
    x.add(1)
    x.add(2)

    const s = mobx.observable(x)
    expect(mobx.isObservableSet(s)).toBe(true)
    expect(Array.from(s)).toEqual([1, 2])
})

test("deepEqual set", () => {
    const x = new Set()
    x.add(1)
    x.add({ z: 1 })

    const x2 = mobx.observable.set()
    x2.add(1)
    x2.add({ z: 2 })

    expect(mobx.comparer.structural(x, x2)).toBe(false)
    x2.replace([1, { z: 1 }])
    expect(mobx.comparer.structural(x, x2)).toBe(true)
})

test("set.clear should not be tracked", () => {
    const x = set([1])
    let c = 0
    const d = mobx.autorun(() => {
        c++
        x.clear()
    })

    expect(c).toBe(1)
    x.add(2)
    expect(c).toBe(1)

    d()
})

test("toStringTag", () => {
    const x = set()
    expect(x[Symbol.toStringTag]).toBe("Set")
    expect(Object.prototype.toString.call(x)).toBe("[object Set]")
})

test("getAtom", () => {
    const x = set([1])
    expect(mobx.getAtom(x)).toBeTruthy()

    expect(mobx.isObservableSet(x)).toBeTruthy()
    expect(mobx.isObservable(x)).toBeTruthy()
})

test("observe", () => {
    const vals = []
    const x = set([1])
    mobx.observe(x, change => {
        delete change.debugObjectName
        vals.push(change)
    })
    x.add(2)
    x.add(1)
    expect(vals).toEqual([{ newValue: 2, object: x, type: "add", observableKind: "set" }])
})

test("toJS", () => {
    const x = mobx.observable({ x: 1 })
    const y = set([x, 1])

    const z = mobx.toJS(y)
    expect(z).toEqual(new Set([{ x: 1 }, 1]))
    expect(z.x).not.toBe(x)
    expect(mobx.isObservable(z.x)).toBeFalsy()
})

test("set.forEach is reactive", () => {
    let c = 0
    const s = set()

    autorun(() => {
        s.forEach(() => {})
        c++
    })

    s.add(1)
    s.add(2)
    expect(c).toBe(3)
})

describe("The Set object methods do what they are supposed to do", () => {
    const reactiveSet = set([1, 2, 3, 4, 5])

    test("with native Set", () => {
        const intersectionObservableResult = reactiveSet.intersection(new Set([1, 2, 6]))
        const unionObservableResult = reactiveSet.union(new Set([1, 2, 6]))
        const differenceObservableResult = reactiveSet.difference(new Set([1, 2, 3, 4, 5, 6, 7]))
        const symmetricDifferenceObservableResult = reactiveSet.symmetricDifference(new Set([3, 4]))
        const isSubsetOfObservableResult = reactiveSet.isSubsetOf(new Set([1, 2, 3]))
        const isSupersetOfObservableResult = reactiveSet.isSupersetOf(new Set([1, 2, 3, 4, 5, 6]))
        const isDisjointFromObservableResult = reactiveSet.isDisjointFrom(new Set([6, 7]))

        expect(intersectionObservableResult).toEqual(new Set([1, 2]))
        expect(unionObservableResult).toEqual(new Set([1, 2, 3, 4, 5, 6]))
        expect(differenceObservableResult).toEqual(new Set())
        expect(symmetricDifferenceObservableResult).toEqual(new Set([1, 2, 5]))
        expect(isSubsetOfObservableResult).toBeFalsy()
        expect(isSupersetOfObservableResult).toBeFalsy()
        expect(isDisjointFromObservableResult).toBeTruthy()
    })

    test("with ObservableSet #3919", () => {
        const intersectionObservableResult = reactiveSet.intersection(set([1, 2, 6]))
        const unionObservableResult = reactiveSet.union(set([1, 2, 6]))
        const differenceObservableResult = reactiveSet.difference(set([1, 2, 3, 4, 5, 6, 7]))
        const symmetricDifferenceObservableResult = reactiveSet.symmetricDifference(set([3, 4]))
        const isSubsetOfObservableResult = reactiveSet.isSubsetOf(set([1, 2, 3]))
        const isSupersetOfObservableResult = reactiveSet.isSupersetOf(set([1, 2, 3, 4, 5, 6]))
        const isDisjointFromObservableResult = reactiveSet.isDisjointFrom(set([6, 7]))

        expect(intersectionObservableResult).toEqual(new Set([1, 2]))
        expect(unionObservableResult).toEqual(new Set([1, 2, 3, 4, 5, 6]))
        expect(differenceObservableResult).toEqual(new Set())
        expect(symmetricDifferenceObservableResult).toEqual(new Set([1, 2, 5]))
        expect(isSubsetOfObservableResult).toBeFalsy()
        expect(isSupersetOfObservableResult).toBeFalsy()
        expect(isDisjointFromObservableResult).toBeTruthy()
    })

    test("with Set-like", () => {
        const intersectionObservableResult = reactiveSet.intersection(
            new Map([1, 2, 6].map(i => [i, i]))
        )
        const unionObservableResult = reactiveSet.union(new Map([1, 2, 6].map(i => [i, i])))
        const differenceObservableResult = reactiveSet.difference(
            new Map([1, 2, 3, 4, 5, 6, 7].map(i => [i, i]))
        )
        const symmetricDifferenceObservableResult = reactiveSet.symmetricDifference(
            new Map([3, 4].map(i => [i, i]))
        )
        const isSubsetOfObservableResult = reactiveSet.isSubsetOf(
            new Map([1, 2, 3].map(i => [i, i]))
        )
        const isSupersetOfObservableResult = reactiveSet.isSupersetOf(
            new Map([1, 2, 3, 4, 5, 6].map(i => [i, i]))
        )
        const isDisjointFromObservableResult = reactiveSet.isDisjointFrom(
            new Map([6, 7].map(i => [i, i]))
        )

        expect(intersectionObservableResult).toEqual(new Set([1, 2]))
        expect(unionObservableResult).toEqual(new Set([1, 2, 3, 4, 5, 6]))
        expect(differenceObservableResult).toEqual(new Set())
        expect(symmetricDifferenceObservableResult).toEqual(new Set([1, 2, 5]))
        expect(isSubsetOfObservableResult).toBeFalsy()
        expect(isSupersetOfObservableResult).toBeFalsy()
        expect(isDisjointFromObservableResult).toBeTruthy()
    })
})

describe("Observable Set methods are reactive", () => {
    let c = 0
    let s = set()

    beforeEach(() => {
        c = 0
        s = set()
    })

    test("Intersection method is reactive", () => {
        autorun(() => {
            s.intersection(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("Union method is reactive", () => {
        autorun(() => {
            s.union(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("Difference method is reactive", () => {
        autorun(() => {
            s.difference(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("symmetricDifference method is reactive", () => {
        autorun(() => {
            s.symmetricDifference(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("isSubsetOf method is reactive", () => {
        autorun(() => {
            s.isSubsetOf(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("isSupersetOf method is reactive", () => {
        autorun(() => {
            s.isSupersetOf(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })

    test("isDisjointFrom method is reactive", () => {
        autorun(() => {
            s.isDisjointFrom(new Set())
            c++
        })

        s.add(1)
        s.add(2)
        expect(c).toBe(3)
    })
})


describe("Observable Set interceptors", () => {

    let s = set()

    beforeEach(() => {
        s = set()
    })

    test("Add does not add value if interceptor returned no change", () => {
        mobx.intercept(s, (change) => {
            if(change.type === 'add' && change.newValue === 2) {
                return undefined;
            }

            return change;
        })

        s.add(1);
        s.add(2);

        expect([...s]).toStrictEqual([1]);


    })

    test("Add respects newValue from interceptor", () => {

        mobx.intercept(s, (change) => {
            if(change.type === 'add' && change.newValue === 2) {
                change.newValue = 10;
            }

            return change;
        })

        s.add(1);
        s.add(2);

        expect([...s]).toStrictEqual([1, 10])
    })


})


================================================
FILE: packages/mobx/__tests__/v5/base/spy.js
================================================
"use strict"
const mobx = require("../../../src/mobx.ts")
const utils = require("../../v5/utils/test-utils")

test("spy output", () => {
    const events = []

    const stop = mobx.spy(c => events.push(c))

    doStuff()

    stop()

    doStuff()

    events.forEach(ev => {
        delete ev.object
        delete ev.fn
        delete ev.time
    })

    expect(events).toMatchSnapshot()
})

function doStuff() {
    const a = mobx.observable.box(2)
    a.set(3)

    const b = mobx.observable({
        c: 4
    })
    b.c = 5
    mobx.extendObservable(b, { d: 6 })
    b.d = 7

    const e = mobx.observable([1, 2])
    e.push(3, 4)
    e.shift()
    e[2] = 5

    const f = mobx.observable.map({ g: 1 })
    f.delete("h")
    f.delete("g")
    f.set("i", 5)
    f.set("i", 6)

    const j = mobx.computed(() => a.get() * 2)

    mobx.autorun(() => {
        j.get()
    })

    a.set(4)

    mobx.transaction(function myTransaction() {
        a.set(5)
        a.set(6)
    })

    mobx.action("myTestAction", newValue => {
        a.set(newValue)
    }).call({}, 7)
}

test("spy error", () => {
    utils.supressConsole(() => {
        mobx._getGlobalState().mobxGuid = 0

        const a = mobx.observable({
            x: 2,
            get y() {
                if (this.x === 3) throw "Oops"
                return this.x * 2
            },
            setX: mobx.action(function setX(x) {
                this.x = x
            })
        })

        const events = []
        const stop = mobx.spy(c => events.push(c))

        const d = mobx.autorun(() => a.y, { name: "autorun" })

        a.x = 3
        a.setX(4)
        const actionEvents = events.filter(event => event.type === "action")
        const isActionsTypeofObservable = actionEvents.reduce(
            (ret, action) => ret && action.object === a,
            true
        )
        events.forEach(x => {
            delete x.fn
            delete x.object
            delete x.time
        })
        expect(isActionsTypeofObservable).toBe(true)
        expect(events).toMatchSnapshot()

        d()
        stop()
    })
})

test("spy stop listen from handler, #1459", () => {
    const stop = mobx.spy(() => stop())
    mobx.spy(() => { })
    doStuff()
})

test("bound actions report correct object (discussions/3140)", () => {
    class AppState {
        constructor() {
            mobx.makeAutoObservable(this, {
                actionBound: mobx.action.bound,
            }, { autoBind: true });
        }

        actionBound() { }
        autoActionBound() { }
    }

    const appState = new AppState();
    const { actionBound, autoActionBound } = appState;

    let events = [];
    const disposeSpy = mobx.spy((event) => {
        if (event.type !== 'action') return;
        events.push(event);
    });

    try {
        actionBound();
        expect(events.pop().object).toBe(appState)
        autoActionBound();
        expect(events.pop().object).toBe(appState)
    } finally {
        disposeSpy();
    }
})

test("computed shouldn't report update unless the value changed #3109", () => {
    const number = mobx.observable({
        value: 0,
        get isEven() {
            return (this.value % 2) === 0;
        }
    })

    const events = [];
    const disposeSpy = mobx.spy(event => {
        if (event.observableKind === 'computed' && event.type === 'update') {
            events.push(event);
        };
    });

    const disposeAutorun = mobx.autorun(() => number.isEven);

    try {
        expect(events.pop()).toMatchObject({ oldValue: { cause: null }, newValue: true });
        number.value++; // 1        
        expect(events.pop()).toMatchObject({ oldValue: true, newValue: false });
        number.value++; // 2   
        expect(events.pop()).toMatchObject({ oldValue: false, newValue: true });
        number.value += 2; // 4       
        expect(events.pop()).toBe(undefined);
        number.value += 2; // 6
        expect(events.pop()).toBe(undefined);
    } finally {
        disposeSpy();
        disposeAutorun();
    }
})



================================================
FILE: packages/mobx/__tests__/v5/base/strict-mode.js
================================================
/**
 * @type {typeof import("../../../src/v5/mobx")}
 */
const mobx = require("../../../src/mobx.ts")
const utils = require("../../v5/utils/test-utils")
const { makeObservable } = mobx

const strictError =
    "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed."

beforeEach(() => {
    mobx.configure({ enforceActions: "observed" })
})

test("strict mode should not allow changes outside action", () => {
    const a = mobx.observable.box(2)
    mobx.configure({ enforceActions: "observed" })

    // allowed, a is not observed
    a.set(3)

    const d = mobx.autorun(() => a.get())
    // not-allowed, a is observed
    expect(utils.grabConsole(() => a.set(3))).toMatch(strictError)
    d()

    mobx.configure({ enforceActions: "never" })
    a.set(4)
    expect(a.get()).toBe(4)
})

test("actions can modify observed state in strict mode", () => {
    const a = mobx.observable.box(2)
    const d = mobx.autorun(() => a.get())

    mobx.configure({ enforceActions: "observed" })
    mobx.action(() => {
        a.set(3)
        mobx.observable.box(4)
    })()

    mobx.configure({ enforceActions: "never" })
    d()
})

test("actions can modify non-observed state in strict mode", () => {
    const a = mobx.observable.box(2)

    mobx.configure({ enforceActions: "observed" })
    mobx.action(() => {
        a.set(3)
        mobx.observable.box(4)
    })()

    mobx.configure({ enforceActions: "never" })
})

test("reactions cannot modify state in strict mode", () => {
    const a = mobx.observable.box(3)
    const b = mobx.observable.box(4)
    mobx.configure({ enforceActions: "observed" })
    mobx._resetGlobalState() // should preserve strict mode

    const bd = mobx.autorun(() => {
        b.get() // make sure it is observed
    })

    let d = mobx.autorun(() => {
        expect(
            utils.grabConsole(() => {
                a.get()
                b.set(3)
            })
        ).toMatch(strictError)
    })

    d = mobx.autorun(() => {
        if (a.get() > 5) b.set(7)
    })

    mobx.action(() => a.set(4))() // ok

    expect(utils.grabConsole(() => a.set(5))).toMatch(strictError)

    mobx.configure({ enforceActions: "never" })
    d()
    bd()
})

test("action inside reaction in strict mode can modify state", () => {
    const a = mobx.observable.box(1)
    const b = mobx.observable.box(2)

    const bd = mobx.autorun(() => {
        b.get() // make sure it is observed
    })

    mobx.configure({ enforceActions: "observed" })
    const act = mobx.action(() => b.set(b.get() + 1))

    const d = mobx.autorun(() => {
        if (a.get() % 2 === 0) act()
        if (a.get() == 16) {
            expect(utils.grabConsole(() => b.set(55))).toMatch(strictError)
        }
    })

    const setA = mobx.action(val => a.set(val))
    expect(b.get()).toBe(2)
    setA(4)
    expect(b.get()).toBe(3)
    setA(5)
    expect(b.get()).toBe(3)
    setA(16)
    expect(b.get()).toBe(55)

    mobx.configure({ enforceActions: "never" })
    bd()
    d()
})

test("cannot create or modify objects in strict mode without action", () => {
    const obj = mobx.observable({ a: 2 })
    /*const ar = */ mobx.observable([1])
    /*const map = */ mobx.observable.map({ a: 2 })

    mobx.configure({ enforceActions: "observed" })

    // introducing new observables is ok!
    // mobx.observable({ a: 2, b: function() { return this.a }});
    // mobx.observable({ b: function() { return this.a } });
    // mobx.observable.map({ a: 2});
    // mobx.observable([1, 2, 3]);
    // mobx.extendObservable(obj, { b: 4});

    // t.throws(() => obj.a = 3, strictError);
    // t.throws(() => ar[0] = 2, strictError);
    // t.throws(() => ar.push(3), strictError);
    // t.throws(() => map.set("a", 3), strictError);
    // t.throws(() => map.set("b", 4), strictError);
    // t.throws(() => map.delete("a"), strictError);

    mobx.configure({ enforceActions: "never" })

    // can modify again
    obj.a = 42
})

test("can create objects in strict mode with action", () => {
    const obj = mobx.observable({ a: 2 })
    const ar = mobx.observable([1])
    const map = mobx.observable.map({ a: 2 })

    mobx.configure({ enforceActions: "observed" })

    mobx.action(() => {
        mobx.observable({
            a: 2,
            b: function () {
                return this.a
            }
        })
        mobx.observable.map({ a: 2 })
        mobx.observable([1, 2, 3])

        obj.a = 3
        mobx.extendObservable(obj, { b: 4 })
        ar[0] = 2
        ar.push(3)
        map.set("a", 3)
        map.set("b", 4)
        map.delete("a")
    })()
})

test("strict mode checks", function () {
    mobx.configure({
        enforceActions: "never"
    })
    const x = mobx.observable.box(3)
    const d = mobx.autorun(() => x.get())

    mobx._allowStateChanges(false, function () {
        x.get()
    })

    mobx._allowStateChanges(true, function () {
        x.set(7)
    })

    expect(
        utils.grabConsole(function () {
            mobx._allowStateChanges(false, function () {
                x.set(4)
            })
        })
    ).toMatch(/Side effects like changing state are not allowed at this point/)

    mobx._resetGlobalState()
    d()
})

test("enforceActions 'strict' does not allow changing unobserved observables", () => {
    try {
        mobx.configure({ enforceActions: "always" })
        const x = mobx.observable({
            a: 1,
            b: 2
        })
        const d = mobx.autorun(() => {
            x.a
        })

        expect(
            utils.grabConsole(() => {
                x.a = 2
            })
        ).toMatch(/Since strict-mode is enabled/)
        expect(
            utils.grabConsole(() => {
                x.b = 2
            })
        ).toMatch(/Since strict-mode is enabled/)

        d()
    } finally {
        mobx.configure({ enforceActions: "never" })
    }
})

test("enforceActions 'strict' should not throw exception while observable array initialization", () => {
    try {
        mobx.configure({ enforceActions: "always" })

        expect(() => {
            mobx.observable({
                a: [1, 2]
            })
        }).not.toThrow(/Since strict-mode is enabled/)
    } finally {
        mobx.configure({ enforceActions: "never" })
    }
})

test("warn on unsafe reads of computed", function () {
    try {
        mobx.configure({ computedRequiresReaction: true })
        const x = mobx.observable({
            y: 3,
            get yy() {
                return this.y * 2
            }
        })
        utils.consoleWarn(() => {
            x.yy
        }, /being read outside a reactive context/)
    } finally {
        mobx.configure({ computedRequiresReaction: false })
    }
})

describe("observableRequiresReaction", function () {
    test("warn on unsafe reads of observable", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                y: 3
            })
            utils.consoleWarn(() => {
                x.y
            }, /being read outside a reactive context/)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("warn on unsafe reads of observable also when there are other subscriptions", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                y: 3
            })

            const dispose = mobx.autorun(() => x.y)

            utils.consoleWarn(() => {
                x.y
            }, /being read outside a reactive context/)

            dispose()
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("warn on unsafe reads of observable array", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                arr: [1, 2, 3]
            })
            utils.consoleWarn(() => {
                x.arr[1]
            }, /being read outside a reactive context/)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })
    test("don't warn on reads inside a computed", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                y: 1
            })

            const fooComputed = mobx.computed(() => x.y + 1)

            const messages = utils.supressConsole(() => {
                const dispose = mobx.autorun(() => fooComputed.get())
                dispose()
            })

            expect(messages.length).toBe(0)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("don't warn on autorun tracks invalidation of unbound dependencies", function () {
        // #2195
        try {
            mobx.configure({ observableRequiresReaction: true, enforceActions: "never" })
            const a = mobx.observable.box(0)
            const b = mobx.observable.box(0)
            const c = mobx.computed(() => a.get() + b.get())
            const values = []

            mobx.autorun(() => {
                values.push(c.get())
                b.set(100)
            })

            const messages = utils.supressConsole(() => {
                a.set(1)
            })

            expect(messages.length).toBe(0)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("don't warn on autorun tracks invalidation of unbound dependencies - also with action", function () {
        // #2195
        try {
            mobx.configure({ observableRequiresReaction: true, enforceActions: "never" })
            const a = mobx.observable.box(0)
            const b = mobx.observable.box(0)
            const c = mobx.computed(() => a.get() + b.get())
            const values = []

            mobx.autorun(() => {
                values.push(c.get())
                b.set(100)
            })

            const messages = utils.supressConsole(
                mobx.action(() => {
                    a.set(1)
                })
            )

            expect(messages.length).toBe(0)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("don't warn on reads inside an action", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                y: 1
            })

            const fooAction = mobx.action(() => x.y)

            const messages = utils.supressConsole(() => {
                fooAction()
            })

            expect(messages.length).toBe(0)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })

    test("warn on reads inside a transaction", function () {
        try {
            mobx.configure({ observableRequiresReaction: true })
            const x = mobx.observable({
                y: 1
            })

            utils.consoleWarn(() => {
                mobx.transaction(() => x.y)
            }, /being read outside a reactive context/)
        } finally {
            mobx.configure({ observableRequiresReaction: false })
        }
    })
})

describe("reactionRequiresObservable", function () {
    test("warn on reaction creation without dependencies", function () {
        try {
            mobx.configure({ reactionRequiresObservable: true })

            utils.consoleWarn(() => {
                const dispose = mobx.reaction(
                    () => "plain value",
                    newValue => newValue
                )

                dispose()
            }, /is created\/updated without reading any observable value/)
        } finally {
            mobx.configure({ reactionRequiresObservable: false })
        }
    })
})

test("#1869", function () {
    const x = mobx.observable.box(3)
    mobx.configure({ enforceActions: "always", isolateGlobalState: true })
    expect(
        utils.grabConsole(() => {
            x.set(4)
        })
    ).toMatch("Since strict-mode is enabled")
    mobx._resetGlobalState() // should preserve strict mode
})



================================================
FILE: packages/mobx/__tests__/v5/base/tojs.js
================================================
"use strict"

const mobx = require("../../../src/mobx.ts")
const m = mobx
const observable = mobx.observable

test("json1", function () {
    mobx._resetGlobalState()

    const todos = observable([
        {
            title: "write blog"
        },
        {
            title: "improve coverge"
        }
    ])

    let output
    mobx.autorun(function () {
        output = todos
            .map(function (todo) {
                return todo.title
            })
            .join(", ")
    })

    todos[1].title = "improve coverage" // prints: write blog, improve coverage
    expect(output).toBe("write blog, improve coverage")
    todos.push({ title: "take a nap" }) // prints: write blog, improve coverage, take a nap
    expect(output).toBe("write blog, improve coverage, take a nap")
})

test("json2", function () {
    const source = {
        todos: [
            {
                title: "write blog",
                tags: ["react", "frp"],
                details: {
                    url: "somewhere"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh"],
                details: {
                    url: "here"
                }
            }
        ]
    }

    const o = mobx.observable(JSON.parse(JSON.stringify(source)))

    expect(mobx.toJS(o)).toEqual(source)

    const analyze = mobx.computed(function () {
        return [o.todos.length, o.todos[1].details.url]
    })

    const alltags = mobx.computed(function () {
        return o.todos
            .map(function (todo) {
                return todo.tags.join(",")
            })
            .join(",")
    })

    let ab = []
    let tb = []

    m.observe(
        analyze,
        function (d) {
            ab.push(d.newValue)
        },
        true
    )
    m.observe(
        alltags,
        function (d) {
            tb.push(d.newValue)
        },
        true
    )

    o.todos[0].details.url = "boe"
    o.todos[1].details.url = "ba"
    o.todos[0].tags[0] = "reactjs"
    o.todos[1].tags.push("pff")

    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh", "pff"],
                details: {
                    url: "ba"
                }
            }
        ]
    })
    expect(ab).toEqual([
        [2, "here"],
        [2, "ba"]
    ])
    expect(tb).toEqual(["react,frp,mweh", "reactjs,frp,mweh", "reactjs,frp,mweh,pff"])
    ab = []
    tb = []

    o.todos.push(
        mobx.observable({
            title: "test",
            tags: ["x"]
        })
    )

    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "do the dishes",
                tags: ["mweh", "pff"],
                details: {
                    url: "ba"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(ab).toEqual([[3, "ba"]])
    expect(tb).toEqual(["reactjs,frp,mweh,pff,x"])
    ab = []
    tb = []

    o.todos[1] = mobx.observable({
        title: "clean the attic",
        tags: ["needs sabbatical"],
        details: {
            url: "booking.com"
        }
    })
    expect(JSON.parse(JSON.stringify(o))).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "clean the attic",
                tags: ["needs sabbatical"],
                details: {
                    url: "booking.com"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(ab).toEqual([[3, "booking.com"]])
    expect(tb).toEqual(["reactjs,frp,needs sabbatical,x"])
    ab = []
    tb = []

    o.todos[1].details = mobx.observable({ url: "google" })
    o.todos[1].tags = ["foo", "bar"]
    expect(mobx.toJS(o)).toEqual({
        todos: [
            {
                title: "write blog",
                tags: ["reactjs", "frp"],
                details: {
                    url: "boe"
                }
            },
            {
                title: "clean the attic",
                tags: ["foo", "bar"],
                details: {
                    url: "google"
                }
            },
            {
                title: "test",
                tags: ["x"]
            }
        ]
    })
    expect(mobx.toJS(o)).toEqual(mobx.toJS(o))
    expect(ab).toEqual([[3, "google"]])
    expect(tb).toEqual(["reactjs,frp,foo,bar,x"])
})

test("toJS handles dates", () => {
    const a = observable({
        d: new Date()
    })

    const b = mobx.toJS(a)
    expect(b.d instanceof Date).toBe(true)
    expect(a.d === b.d).toBe(true)
})

test("toJS handles symbol keys in objects and maps", () => {
    const key = Symbol("key")
    const a = observable({
        [key]: 42
    })

    expect(a[key]).toBe(42)
    const b = mobx.toJS(a)
    expect(b[key]).toBe(42)

    const x = observable.map({
        [key]: 43
    })

    const y = mobx.toJS(x)
    expect(y.get(key)).toBe(43)
})

test("json cycles", function () {
    const a = observable({
        b: 1,
        c: [2],
        d: mobx.observable.map()
    })

    a.e = a
    a.c.push(a, a.d)
    a.d.set("f", a)
    a.d.set("d", a.d)
    a.d.set("c", a.c)

    const cloneA = mobx.toJS(a)
    const cloneC = cloneA.c
    const cloneD = cloneA.d

    expect(cloneA.b).toBe(1)
    expect(cloneA.c[0]).toBe(2)
    expect(cloneA.c[1]).toBe(cloneA)
    expect(cloneA.c[2]).toBe(cloneD)
    expect(cloneD.get("f")).toBe(cloneA)
    expect(cloneD.get("d")).toBe(cloneD)
    expect(cloneD.get("c")).toBe(cloneC)
    expect(cloneA.e).toBe(cloneA)
})

test("#285 class instances with toJS", () => {
    function Person() {
        this.firstName = "michel"
        mobx.extendObservable(this, {
            lastName: "weststrate",
            tags: ["user", "mobx-member"],
            get fullName() {
                return this.firstName + this.lastName
            }
        })
    }

    const p1 = new Person()
    // check before lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: "weststrate",
        tags: ["user", "mobx-member"]
    })

    // check after lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: "weststrate",
        tags: ["user", "mobx-member"]
    })
})

test("#285 non-mobx class instances with toJS", () => {
    const nameObservable = mobx.observable.box("weststrate")
    function Person() {
        this.firstName = "michel"
        this.lastName = nameObservable
    }

    const p1 = new Person()
    // check before lazy initialization
    expect(mobx.toJS(p1)).toEqual({
        firstName: "michel",
        lastName: nameObservable // toJS doesn't recurse into non observable objects!
    })
})

test("verify #566 solution", () => {
    function MyClass() {}
    const a = new MyClass()
    const b = mobx.observable({ x: 3 })
    const c = mobx.observable({ a: a, b: b })

    expect(mobx.toJS(c).a === a).toBeTruthy() // true
    expect(mobx.toJS(c).b !== b).toBeTruthy() // false, cloned
    expect(mobx.toJS(c).b.x === b.x).toBeTruthy() // true, both 3
})

test("verify already seen", () => {
    const a = mobx.observable({ x: null, y: 3 })
    a.x = a

    const res = mobx.toJS(a)
    expect(res.y).toBe(3)
    expect(res.x === res).toBeTruthy()
    expect(res.x === a).toBeFalsy()
})

test("json cycles when exporting maps as maps", function () {
    const a = observable({
        b: 1,
        c: [2],
        d: mobx.observable.map()
    })

    a.e = a
    a.c.push(a, a.d)
    a.d.set("f", a)
    a.d.set("d", a.d)
    a.d.set("c", a.c)

    const cloneA = mobx.toJS(a)
    const cloneC = cloneA.c
    const cloneD = cloneA.d

    expect(cloneA.b).toBe(1)
    expect(cloneA.c[0]).toBe(2)
    expect(cloneA.c[1]).toBe(cloneA)
    expect(cloneA.c[2]).toBe(cloneD)
    expect(cloneD).toBeInstanceOf(Map)
    expect(cloneD.get("f")).toBe(cloneA)
    expect(cloneD.get("d")).toBe(cloneD)
    expect(cloneD.get("c")).toBe(cloneC)
    expect(cloneA.e).toBe(cloneA)
})

describe("recurseEverything set to true", function () {
    test("recurseEverything is no longer supported", () => {
        expect(() => mobx.toJS({}, { recurseEverything: true })).toThrowErrorMatchingInlineSnapshot(
            `"[MobX] toJS no longer supports options"`
        )
    })
})

test("Does not throw on object with configure({ useProxies: 'ifavailable'}) #2871", () => {
    const { useProxies } = mobx._resetGlobalState
    mobx.configure({ useProxies: "ifavailable" })
    expect(() => {
        const o = mobx.observable({ key: "value" })
        const dispose = mobx.autorun(() => mobx.toJS(o))
        dispose()
    }).not.toThrow()
    mobx.configure({ useProxies })
})

test("Correctly converts observable objects with computed values", () => {
    const a = observable({ key: "value" })
    const c = observable({ computedValue: mobx.computed(() => a.key) })

    const j = mobx.toJS(c)
    expect(j).toMatchObject({ computedValue: "value" })
})



================================================
FILE: packages/mobx/__tests__/v5/base/trace.ts
================================================
"use strict"

import * as mobx from "../../../src/mobx"

describe("trace", () => {
    let consoleLogSpy
    beforeEach(() => {
        mobx._resetGlobalState()
        consoleLogSpy = jest.spyOn(console, "log").mockImplementation()
    })
    afterEach(() => {
        consoleLogSpy.mockRestore()
    })

    test("simple", () => {
        const expectedLogCalls: Array<any> = []
        const x = mobx.observable(
            {
                firstname: "Michel",
                lastname: "Weststrate",
                get fullname() {
                    /* test multi line comment
                    (run this unit test from VS code, and pass 'true'  as third argument to trace below to verify)
                */
                    const res = this.firstname + " " + this.lastname
                    mobx.trace(this, "fullname")
                    return res
                }
            },
            {},
            { name: "x" }
        )
        x.fullname
        expectedLogCalls.push(["[mobx.trace] 'x.fullname' tracing enabled"])

        x.fullname
        expectedLogCalls.push([
            "[mobx.trace] Computed value 'x.fullname' is being read outside a reactive context. Doing a full recompute."
        ])

        const dispose = mobx.autorun(
            () => {
                x.fullname
                mobx.trace()
            },
            { name: "autorun" }
        )
        expectedLogCalls.push(["[mobx.trace] 'autorun' tracing enabled"])

        mobx.transaction(() => {
            x.firstname = "John"
            expectedLogCalls.push([
                "[mobx.trace] 'x.fullname' is invalidated due to a change in: 'x.firstname'"
            ])
            x.lastname = "Doe"
        })

        expectedLogCalls.push([
            "[mobx.trace] 'autorun' is invalidated due to a change in: 'x.fullname'"
        ])

        dispose()

        expectedLogCalls.push([
            "[mobx.trace] Computed value 'x.fullname' was suspended and it will recompute on the next access."
        ])

        expect(expectedLogCalls).toEqual(consoleLogSpy.mock.calls)
    })

    test("Log only if derivation is actually about to re-run #2859", () => {
        const expectedLogCalls: Array<any> = []
        const x = mobx.observable(
            {
                foo: 0,
                get fooIsGreaterThan5() {
                    return this.foo > 5
                }
            },
            {},
            { name: "x" }
        )
        mobx.trace(x, "fooIsGreaterThan5")
        expectedLogCalls.push(["[mobx.trace] 'x.fooIsGreaterThan5' tracing enabled"])

        x.fooIsGreaterThan5
        expectedLogCalls.push([
            "[mobx.trace] Computed value 'x.fooIsGreaterThan5' is being read outside a reactive context. Doing a full recompute."
        ])

        const dispose = mobx.autorun(
            () => {
                mobx.trace(true)
                x.fooIsGreaterThan5
            },
            { name: "autorun" }
        )
        expectedLogCalls.push(["[mobx.trace] 'autorun' tracing enabled"])

        mobx.transaction(() => {
            x.foo = 1
            expectedLogCalls.push([
                "[mobx.trace] 'x.fooIsGreaterThan5' is invalidated due to a change in: 'x.foo'"
            ])
        })

        mobx.transaction(() => {
            x.foo = 6
            expectedLogCalls.push([
                "[mobx.trace] 'x.fooIsGreaterThan5' is invalidated due to a change in: 'x.foo'"
            ])
        })

        expectedLogCalls.push([
            "[mobx.trace] 'autorun' is invalidated due to a change in: 'x.fooIsGreaterThan5'"
        ])

        dispose()

        expectedLogCalls.push([
            "[mobx.trace] Computed value 'x.fooIsGreaterThan5' was suspended and it will recompute on the next access."
        ])

        expect(expectedLogCalls).toEqual(consoleLogSpy.mock.calls)
    })

    test("1850", () => {
        const x = mobx.observable({
            firstname: "Michel",
            lastname: "Weststrate",
            get fullname() {
                /* test multi line comment
                        (run this unit test from VS code, to manually verify serialization)
                    */
                const res = this.firstname + " " + this.lastname
                mobx.trace(this, "fullname", true)
                return res
            }
        })

        mobx.autorun(() => {
            x.fullname
        })
        expect(() => {
            x.firstname += "!"
        }).not.toThrow("Unexpected identifier")
    })
})



================================================
FILE: packages/mobx/__tests__/v5/base/typescript-decorators.ts
================================================
"use strict"

import {
    observe,
    computed,
    observable,
    autorun,
    extendObservable,
    action,
    IObservableArray,
    IArrayWillChange,
    IArrayWillSplice,
    IObservableValue,
    isObservable,
    isObservableProp,
    isObservableObject,
    transaction,
    IObjectDidChange,
    spy,
    configure,
    isAction,
    IAtom,
    createAtom,
    runInAction,
    makeObservable,
    flow,
    flowResult
} from "../../../src/mobx"
import * as mobx from "../../../src/mobx"

const testFunction = function (a: any) {}

// lazy wrapper around yest

const t = {
    equal(a: any, b: any) {
        expect(a).toBe(b)
    },
    deepEqual(a: any, b: any) {
        expect(a).toEqual(b)
    },
    notEqual(a: any, b: any) {
        expect(a).not.toEqual(b)
    },

    throws(a: any, b: any) {
        expect(a).toThrow(b)
    }
}

test("decorators", () => {
    class Order {
        @observable price: number = 3
        @observable amount: number = 2
        @observable orders: string[] = []
        @observable aFunction = testFunction

        @computed
        get total() {
            return this.amount * this.price * (1 + this.orders.length)
        }

        constructor() {
            makeObservable(this)
        }

        @flow
        *testDouble(n: number): Generator<number, number> {
            yield 3
            return n * 2
        }

        async run() {
            const x: number = await flowResult(this.testDouble(2))
        }
    }

    const o = new Order()
    t.equal(isObservableObject(o), true)
    t.equal(isObservableProp(o, "amount"), true)
    t.equal(isObservableProp(o, "total"), true)

    const events: any[] = []
    const d1 = observe(o, (ev: IObjectDidChange) => events.push(ev.name, (ev as any).oldValue))
    const d2 = observe(o, "price", ev => events.push(ev.newValue, ev.oldValue))
    const d3 = observe(o, "total", ev => events.push(ev.newValue, ev.oldValue))

    o.price = 4

    d1()
    d2()
    d3()

    o.price = 5

    t.deepEqual(events, [
        8, // new total
        6, // old total
        4, // new price
        3, // old price
        "price", // event name
        3 // event oldValue
    ])
})

test("annotations", () => {
    const fn0 = () => 0
    class Order {
        @observable price: number = 3
        @observable amount: number = 2
        @observable orders: string[] = []
        @observable aFunction = fn0

        @computed
        get total() {
            return this.amount * this.price * (1 + this.orders.length)
        }

        constructor() {
            makeObservable(this)
        }
    }

    const order1totals: number[] = []
    const order1 = new Order()
    const order2 = new Order()

    const disposer = autorun(() => {
        order1totals.push(order1.total)
    })

    order2.price = 4
    order1.amount = 1

    t.equal(order1.price, 3)
    t.equal(order1.total, 3)
    t.equal(order2.total, 8)
    order2.orders.push("bla")
    t.equal(order2.total, 16)

    order1.orders.splice(0, 0, "boe", "hoi")
    t.deepEqual(order1totals, [6, 3, 9])

    disposer()
    order1.orders.pop()
    t.equal(order1.total, 6)
    t.deepEqual(order1totals, [6, 3, 9])
    expect(isAction(order1.aFunction)).toBe(true)
    expect(order1.aFunction()).toBe(0)
    order1.aFunction = () => 1
    expect(isAction(order1.aFunction)).toBe(true)
    expect(order1.aFunction()).toBe(1)
})

test("box", () => {
    class Box {
        @observable uninitialized: any
        @observable height = 20
        @observable sizes = [2]
        @observable
        someFunc = function () {
            return 2
        }
        @computed
        get width() {
            return this.height * this.sizes.length * this.someFunc() * (this.uninitialized ? 2 : 1)
        }
        @action("test")
        addSize() {
            this.sizes.push(3)
            this.sizes.push(4)
        }

        constructor() {
            makeObservable(this)
        }
    }

    const box = new Box()

    const ar: number[] = []

    autorun(() => {
        ar.push(box.width)
    })

    t.deepEqual(ar.slice(), [40])
    box.height = 10
    t.deepEqual(ar.slice(), [40, 20])
    box.sizes.push(3, 4)
    t.deepEqual(ar.slice(), [40, 20, 60])
    box.someFunc = () => 7
    t.deepEqual(ar.slice(), [40, 20, 60, 210])
    box.uninitialized = true
    t.deepEqual(ar.slice(), [40, 20, 60, 210, 420])
    box.addSize()
    expect(ar.slice()).toEqual([40, 20, 60, 210, 420, 700])
})

test("computed setter should succeed", () => {
    class Bla {
        @observable a = 3
        @computed
        get propX() {
            return this.a * 2
        }
        set propX(v) {
            this.a = v
        }

        constructor() {
            makeObservable(this)
        }
    }

    const b = new Bla()
    t.equal(b.propX, 6)
    b.propX = 4
    t.equal(b.propX, 8)
})

test("typescript: parameterized computed decorator", () => {
    class TestClass {
        @observable x = 3
        @observable y = 3
        @computed.struct
        get boxedSum() {
            return { sum: Math.round(this.x) + Math.round(this.y) }
        }
        constructor() {
            makeObservable(this)
        }
    }

    const t1 = new TestClass()
    const changes: { sum: number }[] = []
    const d = autorun(() => changes.push(t1.boxedSum))

    t1.y = 4 // change
    t.equal(changes.length, 2)
    t1.y = 4.2 // no change
    t.equal(changes.length, 2)
    transaction(() => {
        t1.y = 3
        t1.x = 4
    }) // no change
    t.equal(changes.length, 2)
    t1.x = 6 // change
    t.equal(changes.length, 3)
    d()

    t.deepEqual(changes, [{ sum: 6 }, { sum: 7 }, { sum: 9 }])
})

test("issue 165", () => {
    function report<T>(msg: string, value: T) {
        // console.log(msg, ":", value)
        return value
    }

    class Card {
        constructor(public game: Game, public id: number) {
            makeObservable(this)
        }

        @computed
        get isWrong() {
            return report(
                "Computing isWrong for card " + this.id,
                this.isSelected && this.game.isMatchWrong
            )
        }

        @computed
        get isSelected() {
            return report(
                "Computing isSelected for card" + this.id,
                this.game.firstCardSelected === this || this.game.secondCardSelected === this
            )
        }
    }

    class Game {
        @observable firstCardSelected: Card | null = null
        @observable secondCardSelected: Card | null = null

        @computed
        get isMatchWrong() {
            return report(
                "Computing isMatchWrong",
                this.secondCardSelected !== null &&
                    this.firstCardSelected!.id !== this.secondCardSelected.id
            )
        }

        constructor() {
            makeObservable(this)
        }
    }

    let game = new Game()
    let card1 = new Card(game, 1),
        card2 = new Card(game, 2)

    autorun(() => {
        card1.isWrong
        card2.isWrong
        // console.log("card1.isWrong =", card1.isWrong)
        // console.log("card2.isWrong =", card2.isWrong)
        // console.log("------------------------------")
    })

    // console.log("Selecting first card")
    game.firstCardSelected = card1
    // console.log("Selecting second card")
    game.secondCardSelected = card2

    t.equal(card1.isWrong, true)
    t.equal(card2.isWrong, true)
})

test("issue 191 - shared initializers (ts)", () => {
    class Test {
        @observable obj = { a: 1 }
        @observable array = [2]
        constructor() {
            makeObservable(this)
        }
    }

    const t1 = new Test()
    t1.obj.a = 2
    t1.array.push(3)

    const t2 = new Test()
    t2.obj.a = 3
    t2.array.push(4)

    t.notEqual(t1.obj, t2.obj)
    t.notEqual(t1.array, t2.array)
    t.equal(t1.obj.a, 2)
    t.equal(t2.obj.a, 3)

    t.deepEqual(t1.array.slice(), [2, 3])
    t.deepEqual(t2.array.slice(), [2, 4])
})

function normalizeSpyEvents(events: any[]) {
    events.forEach(ev => {
        delete ev.fn
        delete ev.time
    })
    return events
}

test("action decorator (typescript)", () => {
    class Store {
        constructor(private multiplier: number) {
            makeObservable(this)
        }

        @action
        add(a: number, b: number): number {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(2, 2), 12)
    t.equal(store1.add(1, 1), 4)

    t.deepEqual(normalizeSpyEvents(events), [
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [1, 1], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator (typescript)", () => {
    class Store {
        constructor(private multiplier: number) {
            makeObservable(this)
        }

        @action("zoem zoem")
        add(a: number, b: number): number {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(3)
    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(2, 2), 12)
    t.equal(store1.add(1, 1), 4)

    t.deepEqual(normalizeSpyEvents(events), [
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [1, 1],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("action decorator on field (typescript)", () => {
    class Store {
        constructor(private multiplier: number) {
            makeObservable(this)
        }

        @action
        add = (a: number, b: number) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)
    expect(store1.add).not.toEqual(store2.add)

    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(4, 5), 63)
    t.equal(store1.add(2, 2), 8)

    t.deepEqual(normalizeSpyEvents(events), [
        { arguments: [3, 4], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [4, 5], name: "add", spyReportStart: true, object: store2, type: "action" },
        { type: "report-end", spyReportEnd: true },
        { arguments: [2, 2], name: "add", spyReportStart: true, object: store1, type: "action" },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("custom action decorator on field (typescript)", () => {
    class Store {
        constructor(private multiplier: number) {
            makeObservable(this)
        }

        @action("zoem zoem")
        add = (a: number, b: number) => {
            return (a + b) * this.multiplier
        }
    }

    const store1 = new Store(2)
    const store2 = new Store(7)

    const events: any[] = []
    const d = spy(events.push.bind(events))
    t.equal(store1.add(3, 4), 14)
    t.equal(store2.add(4, 5), 63)
    t.equal(store1.add(2, 2), 8)

    t.deepEqual(normalizeSpyEvents(events), [
        {
            arguments: [3, 4],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [4, 5],
            name: "zoem zoem",
            spyReportStart: true,
            object: store2,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true },
        {
            arguments: [2, 2],
            name: "zoem zoem",
            spyReportStart: true,
            object: store1,
            type: "action"
        },
        { type: "report-end", spyReportEnd: true }
    ])

    d()
})

test("267 (typescript) should be possible to declare properties observable outside strict mode", () => {
    configure({ enforceActions: "observed" })

    class Store {
        @observable timer: number | null = null

        constructor() {
            makeObservable(this)
        }
    }

    configure({ enforceActions: "never" })
})

test("288 atom not detected for object property", () => {
    class Store {
        @observable foo = ""

        constructor() {
            makeObservable(this)
        }
    }

    const store = new Store()

    mobx.observe(
        store,
        "foo",
        () => {
            // console.log("Change observed")
        },
        true
    )
})

test.skip("observable performance - ts - decorators", () => {
    const AMOUNT = 100000

    class A {
        @observable a = 1
        @observable b = 2
        @observable c = 3
        @computed
        get d() {
            return this.a + this.b + this.c
        }
        constructor() {
            makeObservable(this)
        }
    }

    const objs: any[] = []
    const start = Date.now()

    for (let i = 0; i < AMOUNT; i++) objs.push(new A())

    console.log("created in ", Date.now() - start)

    for (let j = 0; j < 4; j++) {
        for (let i = 0; i < AMOUNT; i++) {
            const obj = objs[i]
            obj.a += 3
            obj.b *= 4
            obj.c = obj.b - obj.a
            obj.d
        }
    }

    console.log("changed in ", Date.now() - start)
})

test("unbound methods", () => {
    class A {
        // shared across all instances
        @action
        m1() {}

        // per instance
        @action m2 = () => {}
        constructor() {
            makeObservable(this)
        }
    }

    const a1 = new A()
    const a2 = new A()

    t.equal(a1.m1, a2.m1)
    t.notEqual(a1.m2, a2.m2)
    t.equal(Object.hasOwnProperty.call(a1, "m1"), false)
    t.equal(Object.hasOwnProperty.call(a1, "m2"), true)
    t.equal(Object.hasOwnProperty.call(a2, "m1"), false)
    t.equal(Object.hasOwnProperty.call(a2, "m2"), true)
})

test("inheritance", () => {
    class A {
        @observable a = 2
        constructor() {
            makeObservable(this)
        }
    }

    class B extends A {
        @observable b = 3
        @computed
        get c() {
            return this.a + this.b
        }
        constructor() {
            super()
            makeObservable(this)
        }
    }
    const b1 = new B()
    const b2 = new B()
    const values: any[] = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    t.deepEqual(values, [10, 11, 12, 14, 18])
})

test("inheritance overrides observable", () => {
    class A {
        @observable a = 2
        constructor() {
            makeObservable(this)
        }
    }

    class B {
        @observable a = 5
        @observable b = 3
        @computed
        get c() {
            return this.a + this.b
        }
        constructor() {
            makeObservable(this)
        }
    }

    const b1 = new B()
    const b2 = new B()
    const values: any[] = []
    mobx.autorun(() => values.push(b1.c + b2.c))

    b1.a = 3
    b1.b = 4
    b2.b = 5
    b2.a = 6

    t.deepEqual(values, [16, 14, 15, 17, 18])
})

test("reusing initializers", () => {
    class A {
        @observable a = 3
        @observable b = this.a + 2
        @computed
        get c() {
            return this.a + this.b
        }
        @computed
        get d() {
            return this.c + 1
        }
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const values: any[] = []
    mobx.autorun(() => values.push(a.d))

    a.a = 4
    t.deepEqual(values, [9, 10])
})

test("enumerability", () => {
    class A {
        @observable a = 1 // enumerable, on proto
        @computed
        get b() {
            return this.a
        } // non-enumerable, (and, ideally, on proto)
        @action
        m() {} // non-enumerable, on proto
        @action m2 = () => {} // non-enumerable, on self
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()

    // not initialized yet
    let ownProps = Object.keys(a)
    let props: string[] = []
    for (const key in a) props.push(key)

    t.deepEqual(ownProps, [
        "a" // yeej!
    ])

    t.deepEqual(props, [
        // also 'a' would be ok
        "a"
    ])

    t.equal("a" in a, true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("a"), true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("b"), true) // false would be slightly better, true also ok-ish, and, see #1777
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m2"), true)

    t.equal(mobx.isAction(a.m), true)
    t.equal(mobx.isAction(a.m2), true)

    // after initialization
    a.a
    a.b
    a.m
    a.m2

    ownProps = Object.keys(a)
    props = []
    for (const key in a) props.push(key)

    t.deepEqual(ownProps, ["a"])

    t.deepEqual(props, ["a"])

    t.equal("a" in a, true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("a"), true)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("b"), true) // false would be slightly better, true also ok-ish, and, see #1777
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m"), false)
    // eslint-disable-next-line
    t.equal(a.hasOwnProperty("m2"), true)
})

test("issue 285 (typescript)", () => {
    const { observable, toJS } = mobx

    class Todo {
        id = 1
        @observable title: string
        @observable finished = false
        @observable childThings = [1, 2, 3]
        constructor(title: string) {
            makeObservable(this)
            this.title = title
        }
    }

    const todo = new Todo("Something to do")

    t.deepEqual(toJS(todo), {
        id: 1,
        title: "Something to do",
        finished: false,
        childThings: [1, 2, 3]
    })
})

test("verify object assign (typescript)", () => {
    class Todo {
        @observable title = "test"
        @computed
        get upperCase() {
            return this.title.toUpperCase()
        }
        constructor() {
            makeObservable(this)
        }
    }

    t.deepEqual((Object as any).assign({}, new Todo()), {
        title: "test"
    })
})

test("379, inheritable actions (typescript)", () => {
    class A {
        @action
        method() {
            return 42
        }
        constructor() {
            makeObservable(this)
        }
    }

    class B extends A {
        method() {
            return super.method() * 2
        }
        constructor() {
            super()
            makeObservable(this)
        }
    }

    class C extends B {
        method() {
            return super.method() + 3
        }
        constructor() {
            super()
            makeObservable(this)
        }
    }

    const b = new B()
    t.equal(b.method(), 84)
    t.equal(isAction(b.method), true)

    const a = new A()
    t.equal(a.method(), 42)
    t.equal(isAction(a.method), true)

    const c = new C()
    t.equal(c.method(), 87)
    t.equal(isAction(c.method), true)
})

test("373 - fix isObservable for unused computed", () => {
    class Bla {
        @computed
        get computedVal() {
            return 3
        }
        constructor() {
            makeObservable(this)
            t.equal(isObservableProp(this, "computedVal"), true)
            this.computedVal
            t.equal(isObservableProp(this, "computedVal"), true)
        }
    }

    new Bla()
})

test("505, don't throw when accessing subclass fields in super constructor (typescript)", () => {
    const values: any = {}
    class A {
        @observable a = 1
        constructor() {
            makeObservable(this)
            values.b = (this as any)["b"]
            values.a = this.a
        }
    }

    class B extends A {
        @observable b = 2

        constructor() {
            super()
            makeObservable(this)
        }
    }

    new B()
    t.deepEqual(values, { a: 1, b: undefined }) // undefined, as A constructor runs before B constructor
})

test("705 - setter undoing caching (typescript)", () => {
    let recomputes = 0
    let autoruns = 0

    class Person {
        @observable name: string = ""
        @observable title: string = ""

        // Typescript bug: if fullName is before the getter, the property is defined twice / incorrectly, see #705
        // set fullName(val) {
        // 	// Noop
        // }
        @computed
        get fullName() {
            recomputes++
            return this.title + " " + this.name
        }
        // Should also be possible to define the setter _before_ the fullname
        set fullName(val) {
            // Noop
        }
        constructor() {
            makeObservable(this)
        }
    }

    let p1 = new Person()
    p1.name = "Tom Tank"
    p1.title = "Mr."

    t.equal(recomputes, 0)
    t.equal(autoruns, 0)

    const d1 = autorun(() => {
        autoruns++
        p1.fullName
    })

    const d2 = autorun(() => {
        autoruns++
        p1.fullName
    })

    t.equal(recomputes, 1)
    t.equal(autoruns, 2)

    p1.title = "Master"
    t.equal(recomputes, 2)
    t.equal(autoruns, 4)

    d1()
    d2()
})

test("@observable.ref (TS)", () => {
    class A {
        @observable.ref ref = { a: 3 }
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    t.equal(a.ref.a, 3)
    t.equal(mobx.isObservable(a.ref), false)
    t.equal(mobx.isObservableProp(a, "ref"), true)
})

test("@observable.shallow (TS)", () => {
    class A {
        @observable.shallow arr = [{ todo: 1 }]
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)
    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr[0]), false)
    t.equal(mobx.isObservable(a.arr[1]), false)
    t.equal(a.arr[1] === todo2, true)
})

test("@observable.shallow - 2 (TS)", () => {
    class A {
        @observable.shallow arr: Record<string, any> = { x: { todo: 1 } }
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.y = todo2
    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr.x), false)
    t.equal(mobx.isObservable(a.arr.y), false)
    t.equal(a.arr.y === todo2, true)
})

test("@observable.deep (TS)", () => {
    class A {
        @observable.deep arr = [{ todo: 1 }]
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const todo2 = { todo: 2 }
    a.arr.push(todo2)

    t.equal(mobx.isObservable(a.arr), true)
    t.equal(mobx.isObservableProp(a, "arr"), true)
    t.equal(mobx.isObservable(a.arr[0]), true)
    t.equal(mobx.isObservable(a.arr[1]), true)
    t.equal(a.arr[1] !== todo2, true)
    t.equal(isObservable(todo2), false)
})

test("action.bound binds (TS)", () => {
    class A {
        @observable x = 0
        @action.bound
        inc(value: number) {
            this.x += value
        }
        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    const runner = a.inc
    runner(2)

    t.equal(a.x, 2)
})

test("@computed.equals (TS)", () => {
    const sameTime = (from: Time, to: Time) => from.hour === to.hour && from.minute === to.minute
    class Time {
        constructor(hour: number, minute: number) {
            makeObservable(this)
            this.hour = hour
            this.minute = minute
        }

        @observable public hour: number
        @observable public minute: number

        @computed({ equals: sameTime })
        public get time() {
            return { hour: this.hour, minute: this.minute }
        }
    }
    const time = new Time(9, 0)

    const changes: Array<{ hour: number; minute: number }> = []
    const disposeAutorun = autorun(() => changes.push(time.time))

    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.hour = 9
    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.minute = 0
    t.deepEqual(changes, [{ hour: 9, minute: 0 }])
    time.hour = 10
    t.deepEqual(changes, [
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 }
    ])
    time.minute = 30
    t.deepEqual(changes, [
        { hour: 9, minute: 0 },
        { hour: 10, minute: 0 },
        { hour: 10, minute: 30 }
    ])

    disposeAutorun()
})

test("1072 - @observable without initial value and observe before first access", () => {
    class User {
        @observable loginCount?: number

        constructor() {
            makeObservable(this)
        }
    }

    const user = new User()
    observe(user, "loginCount", () => {})
})

test("unobserved computed reads should warn with requiresReaction enabled", () => {
    const consoleWarn = console.warn
    const warnings: string[] = []
    console.warn = function (...args) {
        warnings.push(...args)
    }
    try {
        const expectedWarnings: string[] = []

        class A {
            @observable x = 0

            @computed({ requiresReaction: true })
            get y() {
                return this.x * 2
            }
            constructor() {
                makeObservable(this, undefined, { name: "a" })
            }
        }

        const a = new A()

        a.y
        expectedWarnings.push(
            `[mobx] Computed value 'a.y' is being read outside a reactive context. Doing a full recompute.`
        )

        const d = mobx.reaction(
            () => a.y,
            () => {}
        )

        a.y

        d()

        a.y
        expectedWarnings.push(
            `[mobx] Computed value 'a.y' is being read outside a reactive context. Doing a full recompute.`
        )

        expect(warnings).toEqual(expectedWarnings)
    } finally {
        console.warn = consoleWarn
    }
})

test("multiple inheritance should work", () => {
    class A {
        @observable x = 1

        constructor() {
            makeObservable(this)
        }
    }

    class B extends A {
        @observable y = 1

        constructor() {
            super()
            makeObservable(this)
        }
    }

    expect(mobx.keys(new B())).toEqual(["x", "y"])
})

// 19.12.2020 @urugator:
// All annotated non-observable fields are not writable.
// All annotated fields of non-plain objects are non-configurable.
// https://github.com/mobxjs/mobx/pull/2641
test.skip("actions are reassignable", () => {
    // See #1398 and #1545, make actions reassignable to support stubbing
    class A {
        @action
        m1() {}
        @action m2 = () => {}
        @action.bound
        m3() {}
        @action.bound m4 = () => {}

        constructor() {
            makeObservable(this)
        }
    }

    const a = new A()
    expect(isAction(a.m1)).toBe(true)
    expect(isAction(a.m2)).toBe(true)
    expect(isAction(a.m3)).toBe(true)
    expect(isAction(a.m4)).toBe(true)
    a.m1 = () => {}
    expect(isAction(a.m1)).toBe(false)
    a.m2 = () => {}
    expect(isAction(a.m2)).toBe(false)
    a.m3 = () => {}
    expect(isAction(a.m3)).toBe(false)
    a.m4 = () => {}
    expect(isAction(a.m4)).toBe(false)
})

test("it should support asyncAction as decorator (ts)", async () => {
    mobx.configure({ enforceActions: "observed" })

    class X {
        @observable a = 1

        f = mobx.flow(function* f(this: X, initial: number) {
            this.a = initial // this runs in action
            this.a += yield Promise.resolve(5) as any
            this.a = this.a * 2
            return this.a
        })

        constructor() {
            makeObservable(this)
        }
    }

    const x = new X()

    expect(await x.f(3)).toBe(16)
})

test("toJS bug #1413 (TS)", () => {
    class X {
        @observable
        test = {
            test1: 1
        }

        constructor() {
            makeObservable(this)
        }
    }

    const x = new X()
    const res = mobx.toJS(x.test) as any
    expect(res).toEqual({ test1: 1 })
    expect(res.__mobxDidRunLazyInitializers).toBe(undefined)
})

test("#2159 - computed property keys", () => {
    const testSymbol = Symbol("test symbol")
    const testString = "testString"

    class TestClass {
        @observable [testSymbol] = "original symbol value";
        @observable [testString] = "original string value"

        constructor() {
            makeObservable(this)
        }
    }

    const o = new TestClass()

    const events: any[] = []
    observe(o, testSymbol, ev => events.push(ev.newValue, ev.oldValue))
    observe(o, testString, ev => events.push(ev.newValue, ev.oldValue))

    runInAction(() => {
        o[testSymbol] = "new symbol value"
        o[testString] = "new string value"
    })

    t.deepEqual(events, [
        "new symbol value", // new symbol
        "original symbol value", // original symbol
        "new string value", // new string
        "original string value" // original string
    ])
})



================================================
FILE: packages/mobx/__tests__/v5/base/untracked.ts
================================================
import { autorun, observable, computed, untracked } from "../../../src/mobx"

test("untracked 1", () => {
    let cCalcs = 0,
        dCalcs = 0
    const a = observable.box(1)
    const b = observable.box(2)
    const c = computed(() => {
        cCalcs++
        return a.get() + untracked(() => b.get())
    })
    let result

    autorun(() => {
        dCalcs++
        result = c.get()
    })

    expect(result).toBe(3)
    expect(cCalcs).toBe(1)
    expect(dCalcs).toBe(1)

    b.set(3)
    expect(result).toBe(3)
    expect(cCalcs).toBe(1)
    expect(dCalcs).toBe(1)

    a.set(2)
    expect(result).toBe(5)
    expect(cCalcs).toBe(2)
    expect(dCalcs).toBe(2)
})



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/action.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`error logging, #1836 - 1 1`] = `
[
  "<STDOUT> [mobx] (error in reaction 'Autorun@44' suppressed, fix error of causing action below)",
  "<STDERR> Error: Action error",
]
`;

exports[`error logging, #1836 - 2 1`] = `
[
  "<STDERR> [mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: 'Reaction[Autorun@46]'",
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/extras.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`spy 1 1`] = `
[
  {
    "debugObjectName": "ObservableValue@5",
    "newValue": 4,
    "observableKind": "value",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ComputedValue@6",
    "newValue": 8,
    "observableKind": "computed",
    "oldValue": 6,
    "type": "update",
  },
  {
    "name": "Autorun@7",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/flow.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`it should support logging 1`] = `
[
  {
    "arguments": [
      2,
    ],
    "name": "myaction - runid: 6 - init",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      undefined,
    ],
    "name": "myaction - runid: 6 - yield 0",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableObject@7",
    "name": "a",
    "newValue": 2,
    "observableKind": "object",
    "oldValue": 1,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      5,
    ],
    "name": "myaction - runid: 6 - yield 1",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableObject@7",
    "name": "a",
    "newValue": 5,
    "observableKind": "object",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@7",
    "name": "a",
    "newValue": 4,
    "observableKind": "object",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      3,
    ],
    "name": "myaction - runid: 6 - yield 2",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableObject@7",
    "name": "a",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/makereactive.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`computed value 1`] = `"ComputedValue@1[() => 3]"`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/object-api.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`observe & intercept 1`] = `
[
  {
    "intercept": {
      "name": "b",
      "newValue": {
        "title": "get tea",
      },
      "object": "skip",
      "type": "add",
    },
  },
  {
    "intercept": {
      "name": "a",
      "object": "skip",
      "type": "remove",
    },
  },
]
`;

exports[`observe & intercept 2`] = `
[
  {
    "observe": {
      "debugObjectName": "TestObject",
      "name": "b",
      "newValue": {
        "title": "get tea",
      },
      "object": "skip",
      "observableKind": "object",
      "type": "add",
    },
  },
  {
    "observe": {
      "debugObjectName": "TestObject",
      "name": "a",
      "object": "skip",
      "observableKind": "object",
      "oldValue": {
        "title": "get coffee",
      },
      "type": "remove",
    },
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/observables.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`delay autorun until end of transaction 1`] = `
[
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 4,
    "observableKind": "object",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "end1",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 5,
    "observableKind": "object",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "end2",
  {
    "name": "test",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  "calc y",
  {
    "debugObjectName": "ObservableObject@1.b",
    "newValue": 5,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans1",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 6,
    "observableKind": "object",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  "calc y",
  {
    "debugObjectName": "ObservableObject@1.b",
    "newValue": 6,
    "observableKind": "computed",
    "oldValue": 5,
    "type": "update",
  },
  {
    "name": "test",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans2",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "post trans3",
]
`;

exports[`issue 50 1`] = `
[
  "auto",
  "calc c",
  "transstart",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "a",
    "newValue": false,
    "observableKind": "object",
    "oldValue": true,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "b",
    "newValue": true,
    "observableKind": "object",
    "oldValue": false,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpreend",
  {
    "name": "ar",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  "calc c",
  {
    "debugObjectName": "ObservableObject@1.c",
    "newValue": true,
    "observableKind": "computed",
    "oldValue": false,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpostend",
]
`;

exports[`verify transaction events 1`] = `
[
  "auto",
  "calc c",
  "transstart",
  {
    "debugObjectName": "ObservableObject@1",
    "name": "b",
    "newValue": 2,
    "observableKind": "object",
    "oldValue": 1,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpreend",
  "calc c",
  {
    "debugObjectName": "ObservableObject@1.c",
    "newValue": 2,
    "observableKind": "computed",
    "oldValue": 1,
    "type": "update",
  },
  {
    "name": "ar",
    "spyReportStart": true,
    "type": "reaction",
  },
  "auto",
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  "transpostend",
]
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/proxies.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`decorate proxies 1`] = `
{
  "b": {
    "configurable": true,
    "enumerable": true,
    "get": [Function],
    "set": [Function],
  },
  "double": {
    "configurable": true,
    "enumerable": false,
    "value": [Function],
    "writable": false,
  },
  "x": {
    "configurable": true,
    "enumerable": true,
    "get": [Function],
    "set": [Function],
  },
  "y": {
    "configurable": true,
    "enumerable": false,
    "get": [Function],
    "set": [Function],
  },
  Symbol(mobx administration): {
    "configurable": true,
    "enumerable": false,
    "value": "(omitted)",
    "writable": true,
  },
}
`;

exports[`extend proxies 1`] = `
{
  "b": {
    "configurable": true,
    "enumerable": true,
    "get": [Function],
    "set": [Function],
  },
  "double": {
    "configurable": true,
    "enumerable": false,
    "value": [Function],
    "writable": false,
  },
  "x": {
    "configurable": true,
    "enumerable": true,
    "get": [Function],
    "set": [Function],
  },
  "y": {
    "configurable": true,
    "enumerable": false,
    "get": [Function],
    "set": [Function],
  },
  Symbol(mobx administration): {
    "configurable": true,
    "enumerable": false,
    "value": "(omitted)",
    "writable": true,
  },
}
`;

exports[`non-proxied object 1`] = `
{
  "b": {
    "configurable": true,
    "enumerable": true,
    "value": 4,
    "writable": true,
  },
  "double": {
    "configurable": true,
    "enumerable": false,
    "value": [Function],
    "writable": false,
  },
  "x": {
    "configurable": true,
    "enumerable": true,
    "get": [Function],
    "set": [Function],
  },
  "y": {
    "configurable": true,
    "enumerable": false,
    "get": [Function],
    "set": [Function],
  },
  Symbol(mobx administration): {
    "configurable": true,
    "enumerable": false,
    "value": "(omitted)",
    "writable": true,
  },
}
`;



================================================
FILE: packages/mobx/__tests__/v5/base/__snapshots__/spy.js.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`spy error 1`] = `
[
  {
    "name": "autorun",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "debugObjectName": "ObservableObject@1.y",
    "newValue": 4,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "x",
    "newValue": 3,
    "observableKind": "object",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ObservableObject@1.y",
    "newValue": CaughtException {
      "cause": "Oops",
    },
    "observableKind": "computed",
    "oldValue": 4,
    "type": "update",
  },
  {
    "name": "autorun",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "error": "Oops",
    "message": "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: 'Reaction[autorun]'",
    "name": "autorun",
    "type": "error",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      4,
    ],
    "name": "setX",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableObject@1",
    "name": "x",
    "newValue": 4,
    "observableKind": "object",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@1.y",
    "newValue": 8,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": "Oops",
    },
    "type": "update",
  },
  {
    "name": "autorun",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;

exports[`spy output 1`] = `
[
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": "2",
    "observableKind": "value",
    "type": "create",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 3,
    "observableKind": "value",
    "oldValue": 2,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "c",
    "newValue": 4,
    "observableKind": "object",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "c",
    "newValue": 5,
    "observableKind": "object",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "d",
    "newValue": 6,
    "observableKind": "object",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableObject@2",
    "name": "d",
    "newValue": 7,
    "observableKind": "object",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [
      1,
      2,
    ],
    "addedCount": 2,
    "debugObjectName": "ObservableArray@3",
    "index": 0,
    "observableKind": "array",
    "removed": [],
    "removedCount": 0,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [
      3,
      4,
    ],
    "addedCount": 2,
    "debugObjectName": "ObservableArray@3",
    "index": 2,
    "observableKind": "array",
    "removed": [],
    "removedCount": 0,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "added": [],
    "addedCount": 0,
    "debugObjectName": "ObservableArray@3",
    "index": 0,
    "observableKind": "array",
    "removed": [
      1,
    ],
    "removedCount": 1,
    "spyReportStart": true,
    "type": "splice",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableArray@3",
    "index": 2,
    "newValue": 5,
    "observableKind": "array",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "g",
    "newValue": 1,
    "observableKind": "map",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "g",
    "observableKind": "map",
    "oldValue": 1,
    "spyReportStart": true,
    "type": "delete",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "i",
    "newValue": 5,
    "observableKind": "map",
    "spyReportStart": true,
    "type": "add",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableMap@4",
    "name": "i",
    "newValue": 6,
    "observableKind": "map",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 6,
    "observableKind": "computed",
    "oldValue": CaughtException {
      "cause": null,
    },
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 4,
    "observableKind": "value",
    "oldValue": 3,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 8,
    "observableKind": "computed",
    "oldValue": 6,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 5,
    "observableKind": "value",
    "oldValue": 4,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 6,
    "observableKind": "value",
    "oldValue": 5,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 12,
    "observableKind": "computed",
    "oldValue": 8,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "arguments": [
      7,
    ],
    "name": "myTestAction",
    "spyReportStart": true,
    "type": "action",
  },
  {
    "debugObjectName": "ObservableValue@1",
    "newValue": 7,
    "observableKind": "value",
    "oldValue": 6,
    "spyReportStart": true,
    "type": "update",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "debugObjectName": "ComputedValue@5",
    "newValue": 14,
    "observableKind": "computed",
    "oldValue": 12,
    "type": "update",
  },
  {
    "name": "Autorun@6",
    "spyReportStart": true,
    "type": "reaction",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
  {
    "spyReportEnd": true,
    "type": "report-end",
  },
]
`;



================================================
FILE: packages/mobx/__tests__/v5/flow/test.js
================================================
//@flow

import type { IObservableValue, IObservableArray, IComputedValue } from "../../../dist/index.js"
import * as mobx from "../../../dist/index.js"

const action = mobx.action(() => console.log(1))
// $ExpectError
const isAction: string = mobx.isAction(action)

const observableValue: IObservableValue<number> = mobx.observable.box(1)
// $ExpectError
const initialValue: string = observableValue.get()

const observableArray: IObservableArray<number> = mobx.observable([1, 2, 3])
// $ExpectError
const initialArray: Array<string> = observableArray.peek()

const sum: IComputedValue<number> = mobx.computed(() => {
    return observableArray.reduce((a: number, b: number): number => {
        return a + b
    }, 0)
})

const observableObject = mobx.observable({
    a: true
})
// $ExpectError
observableObject.a = 12
// $ExpectError
observableObject.b = 12
observableObject.a = false

const extendedObservableObject = mobx.extendObservable(mobx.observable({}), { a: true })
// $ExpectError
const x: string = extendedObservableObject.a

const disposer = mobx.autorun(() => console.log(sum.get()))
disposer()

const emptyArray = observable([])
const arr = observable([1])
const object = observable.map({
    nestedValue: arr
})

object.get("nestedValue").push(1)
const y: number = object.get("nestedValue")[0]



================================================
FILE: packages/mobx/__tests__/v5/utils/test-utils.ts
================================================
// @ts-nocheck
import { $mobx } from "../../../src/mobx"

export function consoleError(block, regex) {
    let messages = ""
    const orig = console.error
    console.error = function () {
        Object.keys(arguments).forEach(key => {
            messages += ", " + arguments[key]
        })
        messages += "\n"
    }
    try {
        block()
    } finally {
        console.error = orig
    }
    expect(messages.length).toBeGreaterThan(0)
    if (regex) expect(messages).toMatch(regex)
    return messages
}

export function consoleWarn(block, regex) {
    let messages = ""
    const orig = console.warn
    console.warn = function () {
        Object.keys(arguments).forEach(key => {
            messages += ", " + arguments[key]
        })
        messages += "\n"
    }
    try {
        block()
    } finally {
        console.warn = orig
    }
    expect(messages.length).toBeGreaterThan(0)
    expect(messages).toMatch(regex)
}

export function supressConsole(block) {
    const messages = []
    const { warn, error } = console
    Object.assign(console, {
        warn(e) {
            messages.push("<STDOUT> " + e)
        },
        error(e) {
            messages.push("<STDERR> " + e)
        }
    })
    try {
        block()
    } finally {
        Object.assign(console, { warn, error })
    }
    return messages
}

export function stripAdminFromDescriptors(snapshot) {
    const mobxProperty = snapshot[$mobx]
    expect(mobxProperty).toBeTruthy()
    return { ...snapshot, [$mobx]: { ...mobxProperty, value: "(omitted)" } }
}

export function grabConsole(block) {
    return supressConsole(block).join("\n")
}



================================================
FILE: packages/mobx/flow-typed/mobx.js
================================================
// @flow

export type IObservableMapInitialValues<K, V> = IMapEntries<K, V> | KeyValueMap<V> | IMap<K, V>

export interface IMobxConfigurationOptions {
    +enforceActions?: "never" | "always" | "observed";
    computedRequiresReaction?: boolean;
    /**
     * (Experimental)
     * Warn if you try to create to derivation / reactive context without accessing any observable.
     */
    reactionRequiresObservable?: boolean;
    /**
     * (Experimental)
     * Warn if observables are accessed outside a reactive context
     */
    observableRequiresReaction?: boolean;
    isolateGlobalState?: boolean;
    disableErrorBoundaries?: boolean;
    reactionScheduler?: (f: () => void) => void;
    useProxies?: "always" | "never" | "ifavailable";
}

declare export function configure(options: IMobxConfigurationOptions): void

export interface IAutorunOptions {
    delay?: number;
    name?: string;
    /**
     *  warn if the derivation has no dependencies after creation/update
     */
    requiresObservable?: boolean;
    scheduler?: (callback: () => void) => any;
    onError?: (error: any) => void;
}

export interface IReactionOptions extends IAutorunOptions {
    fireImmediately?: boolean;
    equals?: IEqualsComparer<any>;
}

export interface IInterceptable<T> {
    interceptors: IInterceptor<T>[] | any;
    intercept(handler: IInterceptor<T>): Lambda;
}

export type IEqualsComparer<T> = (a: T, b: T) => boolean

export type IInterceptor<T> = (change: T) => T

export type IMapEntry<K, V> = [K, V]

export type IMapEntries<K, V> = IMapEntry<K, V>[]

export interface IMap<K, V> {
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, index: K, map: IMap<K, V>) => void, thisArg?: any): void;
    get(key: K): V | any;
    has(key: K): boolean;
    set(key: K, value?: V): any;
    size: number;
}

declare export function isObservableMap(x: any): boolean

export interface IComputedValueOptions<T> {
    get?: () => T;
    set?: (value: T) => void;
    name?: string;
    equals?: IEqualsComparer<T>;
    context?: any;
}

type PropertyDescriptor<T> = {
    enumerable?: boolean,
    configurable?: boolean,
    writable?: boolean,
    value?: T,
    get?: () => T,
    set?: (value: T) => void
}

export interface IComputed {
    <T>(func: () => T, setter?: (value: T) => void): IComputedValue<T>;
    <T>(func: () => T, options: IComputedValueOptions<T>): IComputedValue<T>;
    (target: Object, key: string, baseDescriptor?: PropertyDescriptor<*>): void;
    struct(target: Object, key: string, baseDescriptor?: PropertyDescriptor<*>): void;
}

export interface IDependencyTree {
    name: string;
    dependencies?: IDependencyTree[];
}

export interface IObserverTree {
    name: string;
    observers?: IObserverTree[];
}

export interface IAtom {
    reportObserved: () => void;
    reportChanged: () => void;
}

export interface IComputedValue<T> {
    get(): T;
    set(value: T): void;
    observe(listener: (newValue: T, oldValue: T) => void, fireImmediately?: boolean): Lambda;
}

export interface IObservable {}

export interface IDepTreeNode {
    name: string;
    observing?: IObservable[];
}

export interface IDerivation {
    name: string;
}

export interface IReactionPublic {
    dispose: () => void;
    trace: (enterBreakPoint?: boolean) => void;
}

declare export class IListenable {
    observe(handler: (change: any, oldValue?: any) => void, fireImmediately?: boolean): Lambda;
}

export interface IObservableArray<T> extends Array<T> {
    spliceWithArray(index: number, deleteCount?: number, newItems?: T[]): T[];
    observe(
        listener: (changeData: IArrayChange<T> | IArraySplice<T>) => void,
        fireImmediately?: boolean
    ): Lambda;
    intercept(handler: IInterceptor<IArrayWillChange<T> | IArrayWillSplice<T>>): Lambda;
    intercept(handler: IInterceptor<IArrayChange<T> | IArraySplice<T>>): Lambda; // TODO: remove in 4.0
    intercept<T>(handler: IInterceptor<IArrayChange<T> | IArraySplice<T>>): Lambda; // TODO: remove in 4.0
    clear(): T[];
    peek(): T[];
    replace(newItems: T[]): T[];
    find(
        predicate: (item: T, index: number, array: Array<T>) => mixed,
        thisArg?: any,
        fromIndex?: number
    ): T | any;
    findIndex(
        predicate: (item: T, index: number, array: Array<T>) => mixed,
        thisArg?: any,
        fromIndex?: number
    ): number;
    remove(value: T): boolean;
}

export interface IArrayChange<T> {
    type: "update";
    object: IObservableArray<T>;
    index: number;
    newValue: T;
    oldValue: T;
}

export interface IArraySplice<T> {
    type: "splice";
    object: IObservableArray<T>;
    index: number;
    added: T[];
    addedCount: number;
    removed: T[];
    removedCount: number;
}

export interface IArrayWillChange<T> {
    type: "update";
    object: IObservableArray<T>;
    index: number;
    newValue: T;
}

export interface IArrayWillSplice<T> {
    type: "splice";
    object: IObservableArray<T>;
    index: number;
    added: T[];
    removedCount: number;
}

export type KeyValueMap<V> = {
    [key: string]: V
}

export interface IMapChange<K, T> {
    object: ObservableMap<K, T>;
    type: "update" | "add" | "delete";
    name: K;
    newValue?: any;
    oldValue?: any;
}

export interface IMapWillChange<K, T> {
    object: ObservableMap<K, T>;
    type: "update" | "add" | "delete";
    name: K;
    newValue?: any;
}

export interface IObservableObject {}

export interface IObjectChange {
    name: string;
    object: any;
    type: "update" | "add" | "remove";
    oldValue?: any;
    newValue: any;
}

export interface IObjectWillChange {
    object: any;
    type: "update" | "add" | "remove";
    name: string;
    newValue: any;
}

export interface IValueWillChange<T> {
    object: any;
    type: "update";
    newValue: T;
}

export interface IValueDidChange<T> extends IValueWillChange<T> {
    oldValue: ?T;
}

export interface IObservableValue<T> {
    get(): T;
    set(value: T): void;
    intercept(handler: IInterceptor<IValueWillChange<T>>): Lambda;
    observe(listener: (change: IValueDidChange<T>) => void, fireImmediately?: boolean): Lambda;
}

export interface IEnhancer<T> {
    (newValue: T, oldValue: T | void, name: string): T;
}

export interface IObservableFactory {
    // observable overloads
    (target: Object, key: string, baseDescriptor?: PropertyDescriptor<*>): any;
    <T>(value: Array<T>): IObservableArray<T>;
    <T>(value: null | void): IObservableValue<T>;
    (value: null | void): IObservableValue<any>;
    <T>(value: IMap<string | number | boolean, T>): ObservableMap<T>;
    <T: Object>(value: T): T;
}

export type IObservableDecorator = {
    (target: Object, property: string, descriptor?: PropertyDescriptor<*>): void,
    enhancer: IEnhancer<any>
}

export type CreateObservableOptions = {
    name?: string,
    deep?: boolean,
    defaultDecorator?: IObservableDecorator
}

declare export class IObservableFactories {
    box<T>(value?: T, options?: CreateObservableOptions): IObservableValue<T>;
    array<T>(initialValues?: T[], options?: CreateObservableOptions): IObservableArray<T>;
    set<V>(initialValues?: V[], options?: CreateObservableOptions): Set<V>;
    map<K, V>(
        initialValues?: IObservableMapInitialValues<K, V>,
        options?: CreateObservableOptions
    ): ObservableMap<K, V>;
    object<T>(props: T, options?: CreateObservableOptions): T & IObservableObject;
    ref(
        target: Object,
        property?: string,
        descriptor?: PropertyDescriptor<*>
    ): IObservableDecorator;
    shallow(
        target: Object,
        property?: string,
        descriptor?: PropertyDescriptor<*>
    ): IObservableDecorator;
    deep(
        target: Object,
        property?: string,
        descriptor?: PropertyDescriptor<*>
    ): IObservableDecorator;
    struct(
        target: Object,
        property?: string,
        descriptor?: PropertyDescriptor<*>
    ): IObservableDecorator;
}

export interface Lambda {
    (): void;
    name?: string;
}

export interface IActionFactory {
    (a1: any, a2?: any, a3?: any, a4?: any, a6?: any): any;
    bound(target: Object, propertyKey: string, descriptor?: PropertyDescriptor<*>): void;
}

declare export class ObservableMap<K, V> {
    constructor(initialData?: IMapEntries<K, V> | KeyValueMap<V>, valueModeFunc?: Function): this;
    has(key: K): boolean;
    set(key: K, value: V): void;
    delete(key: K): boolean;
    get(key: K): V;
    keys(): Iterator<K>;
    values(): Iterator<V>;
    entries(): IMapEntries<K, V> & Iterator<IMapEntry<K, V>>;
    forEach(callback: (value: V, key: K, object: KeyValueMap<K, V>) => void, thisArg?: any): void;
    merge(other: ObservableMap<K, V> | KeyValueMap<K, V>): ObservableMap<K, V>;
    clear(): void;
    replace(other: ObservableMap<K, V> | KeyValueMap<K, V>): ObservableMap<K, V>;
    size: number;
    toJS(): Map<K, V>;
    toPOJO(): KeyValueMap<V>;
    toJSON(): KeyValueMap<V>;
    toString(): string;
    observe(listener: (changes: IMapChange<K, V>) => void, fireImmediately?: boolean): Lambda;
    intercept(handler: IInterceptor<IMapWillChange<K, V>>): Lambda;
}

declare export function action(
    targetOrName: any,
    propertyKeyOrFuc?: any,
    descriptor?: PropertyDescriptor<*>
): any
declare export function action<T>(name: string, func: T): T
declare export function action<T>(func: T): T

declare export function runInAction<T>(name: string, block: () => T): T
declare export function runInAction<T>(block: () => T): T
declare export function isAction(thing: any): boolean
declare export function autorun(
    nameOrFunction: string | ((r: IReactionPublic) => any),
    options?: IAutorunOptions
): any
declare export function reaction<T>(
    expression: (r: IReactionPublic) => T,
    effect: (arg: T, r: IReactionPublic) => void,
    opts?: IReactionOptions
): () => mixed

export interface IWhenOptions {
    name?: string;
    timeout?: number;
    onError?: (error: any) => void;
    /**
     *  warn if the derivation has no dependencies after creation/update
     */
    requiresObservable?: boolean;
}

declare export function when(
    cond: () => boolean,
    effect: Lambda,
    options?: IWhenOptions
): () => mixed
declare export function when(cond: () => boolean, options?: IWhenOptions): Promise<any>

declare export function computed<T>(
    target: any,
    key?: string,
    baseDescriptor?: PropertyDescriptor<*>
): any

declare export function extendObservable<A, B>(
    target: A,
    properties: B,
    decorators?: any,
    options?: any
): A & B

declare export function makeObservable<A>(target: A, annotations?: any, options: any): A

declare export function makeAutoObservable<A>(target: A, exceptions?: any, options: any): A

declare export function intercept(
    object: Object,
    property: string,
    handler: IInterceptor<any>
): Lambda

declare export function isComputed(value: any): boolean
declare export function isComputedProp(value: any, property: string): boolean

declare export function isObservable(value: any): boolean
declare export function isObservableProp(value: any, property: string): boolean

declare export var comparer: {
    identity: IEqualsComparer<any>,
    structural: IEqualsComparer<any>,
    default: IEqualsComparer<any>
}

declare export var observable: IObservableFactory &
    IObservableFactories & {
        deep: {
            struct<T>(initialValue?: T): T
        },
        ref: {
            struct<T>(initialValue?: T): T
        }
    }

declare export function observe<T>(
    value: IObservableValue<T> | IComputedValue<T>,
    listener: (change: IValueDidChange<T>) => void,
    fireImmediately?: boolean
): Lambda
declare export function observe<T>(
    observableArray: IObservableArray<T>,
    listener: (change: IArrayChange<T> | IArraySplice<T>) => void,
    fireImmediately?: boolean
): Lambda
declare export function observe<K, T>(
    observableMap: ObservableMap<K, T>,
    listener: (change: IMapChange<K, T>) => void,
    fireImmediately?: boolean
): Lambda
declare export function observe<K, T>(
    observableMap: ObservableMap<K, T>,
    property: string,
    listener: (change: IValueDidChange<K, T>) => void,
    fireImmediately?: boolean
): Lambda
declare export function observe(
    object: any,
    listener: (change: IObjectChange) => void,
    fireImmediately?: boolean
): Lambda
declare export function observe(
    object: any,
    property: string,
    listener: (change: IValueDidChange<any>) => void,
    fireImmediately?: boolean
): Lambda

declare export function toJS<T>(source: T): T

declare export function untracked<T>(action: () => T): T

declare export function spy(listener: (change: any) => void): Lambda

declare export function transaction<T>(action: () => T, thisArg?: any, report?: boolean): T

declare export function isObservableArray(thing: any): boolean

declare export function isObservableObject<T>(thing: T): boolean

declare export class Reaction {
    name: string;
    isDisposed: boolean;
    constructor(name: string, onInvalidate: () => void): this;
    schedule(): void;
    isScheduled(): boolean;
    track(fn: () => void): void;
    dispose(): void;
    getDisposer(): Lambda & {
        $mosbservable: Reaction
    };
    toString(): string;
    trace(enterBreakPoint?: boolean): void;
}

declare export function createAtom(
    name: string,
    onBecomeObservedHandler?: () => void,
    onBecomeUnobservedHandler?: () => void
): IAtom

declare export function decorate<T>(target: T, decorators: any): T

export type CancellablePromise<T> = Promise<T> & { cancel: () => void }

declare export function flow<T>(
    fn: () => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): () => CancellablePromise<T>
declare export function flow<T, A>(
    fn: (A) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): A => CancellablePromise<T>
declare export function flow<T, A, B>(
    fn: (A, B) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B) => CancellablePromise<T>
declare export function flow<T, A, B, C>(
    fn: (A, B, C) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B, C) => CancellablePromise<T>
declare export function flow<T, A, B, C, D>(
    fn: (
        A,
        B,
        C,
        D
    ) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B, C, D) => CancellablePromise<T>
declare export function flow<T, A, B, C, D, E>(
    fn: (
        A,
        B,
        C,
        D,
        E
    ) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B, C, D, E) => CancellablePromise<T>
declare export function flow<T, A, B, C, D, E, F>(
    fn: (
        A,
        B,
        C,
        D,
        E,
        F
    ) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B, C, D, E, F) => CancellablePromise<T>
declare export function flow<T, A, B, C, D, E, F, G, H>(
    fn: (
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H
    ) => Generator<any, T | Promise<T>, any> | AsyncGenerator<any, T | Promise<T>, any>
): (A, B, C, D, E, F, G, H) => CancellablePromise<T>

declare export function isFlowCancellationError(error: Error): boolean
declare export class FlowCancellationError extends Error {}

declare export function keys<K>(map: ObservableMap<K, any>): K[]
declare export function keys(obj: any): string[]

declare export function values<K, T>(map: ObservableMap<K, T>): T[]
declare export function values<T>(ar: IObservableArray<T>): T[]
declare export function values(obj: any): any[]

declare export function set<V>(obj: ObservableMap<string, V>, values: { [key: string]: V }): void
declare export function set<K, V>(obj: ObservableMap<K, V>, key: K, value: V): void
declare export function set<T>(obj: IObservableArray<T>, index: number, value: T): void
declare export function set(obj: any, values: { [key: string]: any }): void
declare export function set(obj: any, key: string, value: any): void

declare export function remove<K, V>(obj: ObservableMap<K, V>, key: K): void
declare export function remove<T>(obj: IObservableArray<T>, index: number): void
declare export function remove(obj: any, key: string): void

declare export function has<K>(obj: ObservableMap<K, any>, key: K): boolean
declare export function has<T>(obj: IObservableArray<T>, index: number): boolean
declare export function has(obj: any, key: string): boolean

declare export function get<K, V>(obj: ObservableMap<K, V>, key: K): V | void
declare export function get<T>(obj: IObservableArray<T>, index: number): T | void
declare export function get(obj: any, key: string): any

declare export function onReactionError(
    handler: (error: any, derivation: IDerivation) => void
): () => void

declare export function onBecomeObserved(
    value: IObservable | IComputedValue<any> | IObservableArray<any> | ObservableMap<any, any>,
    listener: Lambda
): Lambda
declare export function onBecomeObserved<K>(
    value: ObservableMap<K, any> | Object,
    property: K,
    listener: Lambda
): Lambda

declare export function onBecomeUnobserved(
    value: IObservable | IComputedValue<any> | IObservableArray<any> | ObservableMap<any, any>,
    listener: Lambda
): Lambda
declare export function onBecomeUnobserved<K>(
    value: ObservableMap<K, any> | Object,
    property: K,
    listener: Lambda
): Lambda

declare export function getAtom(thing: any, property?: string): IDepTreeNode
declare export function getDebugName(thing: any, property?: string): string
declare export function getDependencyTree(thing: any, property?: string): IDependencyTree
declare export function getObserverTree(thing: any, property?: string): IObserverTree



================================================
FILE: packages/mobx/scripts/perf.sh
================================================
#!/bin/bash

time node --expose-gc ./__tests__/perf/index.js $1


================================================
FILE: packages/mobx/scripts/prepublish.js
================================================
const fs = require("fs-extra")
const path = require("path")
const execa = require("execa")

const run = () => {
    fs.copySync("flow-typed/mobx.js", "dist/index.js.flow")
    fs.copySync("../../README.md", "./README.md")
    fs.copySync("../../LICENSE", "./LICENSE")
}

run()



================================================
FILE: packages/mobx/src/errors.ts
================================================
const niceErrors = {
    0: `Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'`,
    1(annotationType, key: PropertyKey) {
        return `Cannot apply '${annotationType}' to '${key.toString()}': Field not found.`
    },
    /*
    2(prop) {
        return `invalid decorator for '${prop.toString()}'`
    },
    3(prop) {
        return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
    },
    4(prop) {
        return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
    },
    */
    5: "'keys()' can only be used on observable objects, arrays, sets and maps",
    6: "'values()' can only be used on observable objects, arrays, sets and maps",
    7: "'entries()' can only be used on observable objects, arrays and maps",
    8: "'set()' can only be used on observable objects, arrays and maps",
    9: "'remove()' can only be used on observable objects, arrays and maps",
    10: "'has()' can only be used on observable objects, arrays and maps",
    11: "'get()' can only be used on observable objects, arrays and maps",
    12: `Invalid annotation`,
    13: `Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)`,
    14: "Intercept handlers should return nothing or a change object",
    15: `Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)`,
    16: `Modification exception: the internal structure of an observable array was changed.`,
    17(index, length) {
        return `[mobx.array] Index out of bounds, ${index} is larger than ${length}`
    },
    18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
    19(other) {
        return "Cannot initialize from classes that inherit from Map: " + other.constructor.name
    },
    20(other) {
        return "Cannot initialize map from " + other
    },
    21(dataStructure) {
        return `Cannot convert to map from '${dataStructure}'`
    },
    22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
    23: "It is not possible to get index atoms from arrays",
    24(thing) {
        return "Cannot obtain administration from " + thing
    },
    25(property, name) {
        return `the entry '${property}' does not exist in the observable map '${name}'`
    },
    26: "please specify a property",
    27(property, name) {
        return `no observable property '${property.toString()}' found on the observable object '${name}'`
    },
    28(thing) {
        return "Cannot obtain atom from " + thing
    },
    29: "Expecting some object",
    30: "invalid action stack. did you forget to finish an action?",
    31: "missing option for computed: get",
    32(name, derivation) {
        return `Cycle detected in computation ${name}: ${derivation}`
    },
    33(name) {
        return `The setter of computed value '${name}' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?`
    },
    34(name) {
        return `[ComputedValue '${name}'] It is not possible to assign a new value to a computed value.`
    },
    35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
    36: "isolateGlobalState should be called before MobX is running any reactions",
    37(method) {
        return `[mobx] \`observableArray.${method}()\` mutates the array in-place, which is not allowed inside a derivation. Use \`array.slice().${method}()\` instead`
    },
    38: "'ownKeys()' can only be used on observable objects",
    39: "'defineProperty()' can only be used on observable objects"
} as const

const errors: typeof niceErrors = __DEV__ ? niceErrors : ({} as any)

export function die(error: string | keyof typeof errors, ...args: any[]): never {
    if (__DEV__) {
        let e: any = typeof error === "string" ? error : errors[error]
        if (typeof e === "function") e = e.apply(null, args as any)
        throw new Error(`[MobX] ${e}`)
    }
    throw new Error(
        typeof error === "number"
            ? `[MobX] minified error nr: ${error}${
                  args.length ? " " + args.map(String).join(",") : ""
              }. Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts`
            : `[MobX] ${error}`
    )
}



================================================
FILE: packages/mobx/src/global.d.ts
================================================
declare const __DEV__: boolean



================================================
FILE: packages/mobx/src/internal.ts
================================================
/*
The only reason for this file to exist is pure horror:
Without it rollup can make the bundling fail at any point in time; when it rolls up the files in the wrong order
it will cause undefined errors (for example because super classes or local variables not being hoisted).
With this file that will still happen,
but at least in this file we can magically reorder the imports with trial and error until the build succeeds again.
*/
export * from "./utils/global"
export * from "./errors"
export * from "./utils/utils"
export * from "./api/decorators"
export * from "./core/atom"
export * from "./utils/comparer"
export * from "./types/modifiers"
export * from "./types/overrideannotation"
export * from "./types/actionannotation"
export * from "./types/flowannotation"
export * from "./types/computedannotation"
export * from "./types/observableannotation"
export * from "./types/autoannotation"
export * from "./types/generic-abort-signal"
export * from "./api/observable"
export * from "./api/computed"
export * from "./core/action"
export * from "./types/observablevalue"
export * from "./core/computedvalue"
export * from "./core/derivation"
export * from "./core/globalstate"
export * from "./core/observable"
export * from "./core/reaction"
export * from "./core/spy"
export * from "./api/action"
export * from "./api/autorun"
export * from "./api/become-observed"
export * from "./api/configure"
export * from "./api/extendobservable"
export * from "./api/extras"
export * from "./api/flow"
export * from "./api/intercept-read"
export * from "./api/intercept"
export * from "./api/iscomputed"
export * from "./api/isobservable"
export * from "./api/object-api"
export * from "./api/observe"
export * from "./api/tojs"
export * from "./api/trace"
export * from "./api/transaction"
export * from "./api/when"
export * from "./types/dynamicobject"
export * from "./types/intercept-utils"
export * from "./types/listen-utils"
export * from "./api/makeObservable"
export * from "./types/observablearray"
export * from "./types/observablemap"
export * from "./types/observableset"
export * from "./types/observableobject"
export * from "./types/legacyobservablearray"
export * from "./types/type-utils"
export * from "./utils/eq"
export * from "./utils/iterable"
export * from "./api/annotation"



================================================
FILE: packages/mobx/src/mobx.ts
================================================
/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get a global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
import { die } from "./errors"
import { getGlobal } from "./utils/global"
;["Symbol", "Map", "Set"].forEach(m => {
    let g = getGlobal()
    if (typeof g[m] === "undefined") {
        die(`MobX requires global '${m}' to be available or polyfilled`)
    }
})

import { spy, getDebugName, $mobx } from "./internal"

export {
    IObservable,
    IDepTreeNode,
    Reaction,
    IReactionPublic,
    IReactionDisposer,
    untracked,
    IAtom,
    createAtom,
    spy,
    IComputedValue,
    IEqualsComparer,
    comparer,
    IEnhancer,
    IInterceptable,
    IInterceptor,
    IListenable,
    IObjectWillChange,
    IObjectDidChange,
    isObservableObject,
    IValueDidChange,
    IValueWillChange,
    IObservableValue,
    isObservableValue as isBoxedObservable,
    IObservableArray,
    IArrayWillChange,
    IArrayWillSplice,
    IArraySplice,
    IArrayUpdate,
    IArrayDidChange,
    isObservableArray,
    IKeyValueMap,
    ObservableMap,
    IMapEntries,
    IMapEntry,
    IMapWillChange,
    IMapDidChange,
    isObservableMap,
    IObservableMapInitialValues,
    ObservableSet,
    isObservableSet,
    ISetDidChange,
    ISetWillChange,
    IObservableSetInitialValues,
    transaction,
    observable,
    IObservableFactory,
    CreateObservableOptions,
    computed,
    IComputedFactory,
    isObservable,
    isObservableProp,
    isComputed,
    isComputedProp,
    extendObservable,
    observe,
    intercept,
    autorun,
    IAutorunOptions,
    reaction,
    IReactionOptions,
    when,
    IWhenOptions,
    action,
    isAction,
    runInAction,
    IActionFactory,
    keys,
    values,
    entries,
    set,
    remove,
    has,
    get,
    apiOwnKeys as ownKeys,
    apiDefineProperty as defineProperty,
    configure,
    onBecomeObserved,
    onBecomeUnobserved,
    flow,
    isFlow,
    flowResult,
    FlowCancellationError,
    isFlowCancellationError,
    toJS,
    trace,
    IObserverTree,
    IDependencyTree,
    getDependencyTree,
    getObserverTree,
    resetGlobalState as _resetGlobalState,
    getGlobalState as _getGlobalState,
    getDebugName,
    getAtom,
    getAdministration as _getAdministration,
    allowStateChanges as _allowStateChanges,
    runInAction as _allowStateChangesInsideComputed, // This has become the default behavior in Mobx 6
    Lambda,
    $mobx,
    isComputingDerivation as _isComputingDerivation,
    onReactionError,
    interceptReads as _interceptReads,
    IComputedValueOptions,
    IActionRunInfo,
    _startAction,
    _endAction,
    allowStateReadsStart as _allowStateReadsStart,
    allowStateReadsEnd as _allowStateReadsEnd,
    makeObservable,
    makeAutoObservable,
    autoAction as _autoAction,
    AnnotationsMap,
    AnnotationMapEntry,
    override
} from "./internal"

// Devtools support
declare const __MOBX_DEVTOOLS_GLOBAL_HOOK__: { injectMobx: (any) => void }
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    // See: https://github.com/andykog/mobx-devtools/
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
        spy,
        extras: {
            getDebugName
        },
        $mobx
    })
}



================================================
FILE: packages/mobx/src/api/action.ts
================================================
import {
    createAction,
    executeAction,
    Annotation,
    storeAnnotation,
    die,
    isFunction,
    isStringish,
    createDecoratorAnnotation,
    createActionAnnotation,
    is20223Decorator
} from "../internal"

import type { ClassFieldDecorator, ClassMethodDecorator } from "../types/decorator_fills"

export const ACTION = "action"
export const ACTION_BOUND = "action.bound"
export const AUTOACTION = "autoAction"
export const AUTOACTION_BOUND = "autoAction.bound"

const DEFAULT_ACTION_NAME = "<unnamed action>"

const actionAnnotation = createActionAnnotation(ACTION)
const actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
    bound: true
})
const autoActionAnnotation = createActionAnnotation(AUTOACTION, {
    autoAction: true
})
const autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
    autoAction: true,
    bound: true
})

export interface IActionFactory
    extends Annotation,
        PropertyDecorator,
        ClassMethodDecorator,
        ClassFieldDecorator {
    // nameless actions
    <T extends Function | undefined | null>(fn: T): T
    // named actions
    <T extends Function | undefined | null>(name: string, fn: T): T

    // named decorator
    (customName: string): PropertyDecorator &
        Annotation &
        ClassMethodDecorator &
        ClassFieldDecorator

    // decorator (name no longer supported)
    bound: Annotation & PropertyDecorator & ClassMethodDecorator & ClassFieldDecorator
}

function createActionFactory(autoAction: boolean): IActionFactory {
    const res: IActionFactory = function action(arg1, arg2?): any {
        // action(fn() {})
        if (isFunction(arg1)) {
            return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction)
        }
        // action("name", fn() {})
        if (isFunction(arg2)) {
            return createAction(arg1, arg2, autoAction)
        }
        // @action (2022.3 Decorators)
        if (is20223Decorator(arg2)) {
            return (autoAction ? autoActionAnnotation : actionAnnotation).decorate_20223_(
                arg1,
                arg2
            )
        }
        // @action
        if (isStringish(arg2)) {
            return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation)
        }
        // action("name") & @action("name")
        if (isStringish(arg1)) {
            return createDecoratorAnnotation(
                createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
                    name: arg1,
                    autoAction
                })
            )
        }

        if (__DEV__) {
            die("Invalid arguments for `action`")
        }
    } as IActionFactory
    return res
}

export const action: IActionFactory = createActionFactory(false)
Object.assign(action, actionAnnotation)
export const autoAction: IActionFactory = createActionFactory(true)
Object.assign(autoAction, autoActionAnnotation)

action.bound = createDecoratorAnnotation(actionBoundAnnotation)
autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation)

export function runInAction<T>(fn: () => T): T {
    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined)
}

export function isAction(thing: any) {
    return isFunction(thing) && thing.isMobxAction === true
}



================================================
FILE: packages/mobx/src/api/annotation.ts
================================================
import { ObservableObjectAdministration, isFunction } from "../internal"

export const enum MakeResult {
    Cancel,
    Break,
    Continue
}

export type Annotation = {
    annotationType_: string
    make_(
        adm: ObservableObjectAdministration,
        key: PropertyKey,
        descriptor: PropertyDescriptor,
        source: object
    ): MakeResult
    extend_(
        adm: ObservableObjectAdministration,
        key: PropertyKey,
        descriptor: PropertyDescriptor,
        proxyTrap: boolean
    ): boolean | null
    decorate_20223_(value: any, context: DecoratorContext)
    options_?: any
}

export type AnnotationMapEntry =
    | Annotation
    | true /* follow the default decorator, usually deep */
    | false /* don't decorate this property */

// AdditionalFields can be used to declare additional keys that can be used, for example to be able to
// declare annotations for private/ protected members, see #2339
export type AnnotationsMap<T, AdditionalFields extends PropertyKey> = {
    [P in Exclude<keyof T, "toString">]?: AnnotationMapEntry
} & Record<AdditionalFields, AnnotationMapEntry>

export function isAnnotation(thing: any) {
    return (
        // Can be function
        thing instanceof Object &&
        typeof thing.annotationType_ === "string" &&
        isFunction(thing.make_) &&
        isFunction(thing.extend_)
    )
}

export function isAnnotationMapEntry(thing: any) {
    return typeof thing === "boolean" || isAnnotation(thing)
}



================================================
FILE: packages/mobx/src/api/autorun.ts
================================================
import {
    EMPTY_OBJECT,
    IEqualsComparer,
    IReactionDisposer,
    IReactionPublic,
    Lambda,
    Reaction,
    action,
    comparer,
    getNextId,
    isAction,
    isFunction,
    isPlainObject,
    die,
    allowStateChanges,
    GenericAbortSignal
} from "../internal"

export interface IAutorunOptions {
    delay?: number
    name?: string
    /**
     * Experimental.
     * Warns if the view doesn't track observables
     */
    requiresObservable?: boolean
    scheduler?: (callback: () => void) => any
    onError?: (error: any) => void
    signal?: GenericAbortSignal
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */
export function autorun(
    view: (r: IReactionPublic) => any,
    opts: IAutorunOptions = EMPTY_OBJECT
): IReactionDisposer {
    if (__DEV__) {
        if (!isFunction(view)) {
            die("Autorun expects a function as first argument")
        }
        if (isAction(view)) {
            die("Autorun does not accept actions since actions are untrackable")
        }
    }

    const name: string =
        opts?.name ?? (__DEV__ ? (view as any).name || "Autorun@" + getNextId() : "Autorun")
    const runSync = !opts.scheduler && !opts.delay
    let reaction: Reaction

    if (runSync) {
        // normal autorun
        reaction = new Reaction(
            name,
            function (this: Reaction) {
                this.track(reactionRunner)
            },
            opts.onError,
            opts.requiresObservable
        )
    } else {
        const scheduler = createSchedulerFromOptions(opts)
        // debounced autorun
        let isScheduled = false

        reaction = new Reaction(
            name,
            () => {
                if (!isScheduled) {
                    isScheduled = true
                    scheduler(() => {
                        isScheduled = false
                        if (!reaction.isDisposed) {
                            reaction.track(reactionRunner)
                        }
                    })
                }
            },
            opts.onError,
            opts.requiresObservable
        )
    }

    function reactionRunner() {
        view(reaction)
    }

    if (!opts?.signal?.aborted) {
        reaction.schedule_()
    }
    return reaction.getDisposer_(opts?.signal)
}

export type IReactionOptions<T, FireImmediately extends boolean> = IAutorunOptions & {
    fireImmediately?: FireImmediately
    equals?: IEqualsComparer<T>
}

const run = (f: Lambda) => f()

function createSchedulerFromOptions(opts: IAutorunOptions) {
    return opts.scheduler
        ? opts.scheduler
        : opts.delay
        ? (f: Lambda) => setTimeout(f, opts.delay!)
        : run
}

export function reaction<T, FireImmediately extends boolean = false>(
    expression: (r: IReactionPublic) => T,
    effect: (
        arg: T,
        prev: FireImmediately extends true ? T | undefined : T,
        r: IReactionPublic
    ) => void,
    opts: IReactionOptions<T, FireImmediately> = EMPTY_OBJECT
): IReactionDisposer {
    if (__DEV__) {
        if (!isFunction(expression) || !isFunction(effect)) {
            die("First and second argument to reaction should be functions")
        }
        if (!isPlainObject(opts)) {
            die("Third argument of reactions should be an object")
        }
    }
    const name = opts.name ?? (__DEV__ ? "Reaction@" + getNextId() : "Reaction")
    const effectAction = action(
        name,
        opts.onError ? wrapErrorHandler(opts.onError, effect) : effect
    )
    const runSync = !opts.scheduler && !opts.delay
    const scheduler = createSchedulerFromOptions(opts)

    let firstTime = true
    let isScheduled = false
    let value: T

    const equals: IEqualsComparer<T> = (opts as any).compareStructural
        ? comparer.structural
        : opts.equals || comparer.default

    const r = new Reaction(
        name,
        () => {
            if (firstTime || runSync) {
                reactionRunner()
            } else if (!isScheduled) {
                isScheduled = true
                scheduler!(reactionRunner)
            }
        },
        opts.onError,
        opts.requiresObservable
    )

    function reactionRunner() {
        isScheduled = false
        if (r.isDisposed) {
            return
        }
        let changed: boolean = false
        const oldValue = value
        r.track(() => {
            const nextValue = allowStateChanges(false, () => expression(r))
            changed = firstTime || !equals(value, nextValue)
            value = nextValue
        })

        // This casting is nesessary as TS cannot infer proper type in current function implementation
        type OldValue = FireImmediately extends true ? T | undefined : T
        if (firstTime && opts.fireImmediately!) {
            effectAction(value, oldValue as OldValue, r)
        } else if (!firstTime && changed) {
            effectAction(value, oldValue as OldValue, r)
        }
        firstTime = false
    }

    if (!opts?.signal?.aborted) {
        r.schedule_()
    }
    return r.getDisposer_(opts?.signal)
}

function wrapErrorHandler(errorHandler, baseFn) {
    return function () {
        try {
            return baseFn.apply(this, arguments)
        } catch (e) {
            errorHandler.call(this, e)
        }
    }
}



================================================
FILE: packages/mobx/src/api/become-observed.ts
================================================
import {
    IComputedValue,
    IObservable,
    IObservableArray,
    Lambda,
    ObservableMap,
    getAtom,
    ObservableSet,
    isFunction,
    IObservableValue
} from "../internal"

const ON_BECOME_OBSERVED = "onBO"
const ON_BECOME_UNOBSERVED = "onBUO"

export function onBecomeObserved(
    value:
        | IObservable
        | IComputedValue<any>
        | IObservableArray<any>
        | ObservableMap<any, any>
        | ObservableSet<any>
        | IObservableValue<any>,
    listener: Lambda
): Lambda
export function onBecomeObserved<K, V = any>(
    value: ObservableMap<K, V> | Object,
    property: K,
    listener: Lambda
): Lambda
export function onBecomeObserved(thing, arg2, arg3?): Lambda {
    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3)
}

export function onBecomeUnobserved(
    value:
        | IObservable
        | IComputedValue<any>
        | IObservableArray<any>
        | ObservableMap<any, any>
        | ObservableSet<any>
        | IObservableValue<any>,
    listener: Lambda
): Lambda
export function onBecomeUnobserved<K, V = any>(
    value: ObservableMap<K, V> | Object,
    property: K,
    listener: Lambda
): Lambda
export function onBecomeUnobserved(thing, arg2, arg3?): Lambda {
    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3)
}

function interceptHook(hook: "onBO" | "onBUO", thing, arg2, arg3) {
    const atom: IObservable =
        typeof arg3 === "function" ? getAtom(thing, arg2) : (getAtom(thing) as any)
    const cb = isFunction(arg3) ? arg3 : arg2
    const listenersKey = `${hook}L` as "onBOL" | "onBUOL"

    if (atom[listenersKey]) {
        atom[listenersKey]!.add(cb)
    } else {
        atom[listenersKey] = new Set<Lambda>([cb])
    }

    return function () {
        const hookListeners = atom[listenersKey]
        if (hookListeners) {
            hookListeners.delete(cb)
            if (hookListeners.size === 0) {
                delete atom[listenersKey]
            }
        }
    }
}



================================================
FILE: packages/mobx/src/api/computed.ts
================================================
import {
    ComputedValue,
    IComputedValueOptions,
    Annotation,
    storeAnnotation,
    createDecoratorAnnotation,
    isStringish,
    isPlainObject,
    isFunction,
    die,
    IComputedValue,
    createComputedAnnotation,
    comparer,
    is20223Decorator
} from "../internal"

import type { ClassGetterDecorator } from "../types/decorator_fills"

export const COMPUTED = "computed"
export const COMPUTED_STRUCT = "computed.struct"

export interface IComputedFactory extends Annotation, PropertyDecorator, ClassGetterDecorator {
    // @computed(opts)
    <T>(options: IComputedValueOptions<T>): Annotation & PropertyDecorator & ClassGetterDecorator
    // computed(fn, opts)
    <T>(func: () => T, options?: IComputedValueOptions<T>): IComputedValue<T>

    struct: Annotation & PropertyDecorator & ClassGetterDecorator
}

const computedAnnotation = createComputedAnnotation(COMPUTED)
const computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
    equals: comparer.structural
})

/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */
export const computed: IComputedFactory = function computed(arg1, arg2) {
    if (is20223Decorator(arg2)) {
        // @computed (2022.3 Decorators)
        return computedAnnotation.decorate_20223_(arg1, arg2)
    }
    if (isStringish(arg2)) {
        // @computed
        return storeAnnotation(arg1, arg2, computedAnnotation)
    }
    if (isPlainObject(arg1)) {
        // @computed({ options })
        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1))
    }

    // computed(expr, options?)
    if (__DEV__) {
        if (!isFunction(arg1)) {
            die("First argument to `computed` should be an expression.")
        }
        if (isFunction(arg2)) {
            die(
                "A setter as second argument is no longer supported, use `{ set: fn }` option instead"
            )
        }
    }
    const opts: IComputedValueOptions<any> = isPlainObject(arg2) ? arg2 : {}
    opts.get = arg1
    opts.name ||= arg1.name || "" /* for generated name */

    return new ComputedValue(opts)
} as any

Object.assign(computed, computedAnnotation)

computed.struct = createDecoratorAnnotation(computedStructAnnotation)



================================================
FILE: packages/mobx/src/api/configure.ts
================================================
import { globalState, isolateGlobalState, setReactionScheduler } from "../internal"

const NEVER = "never"
const ALWAYS = "always"
const OBSERVED = "observed"
// const IF_AVAILABLE = "ifavailable"

export function configure(options: {
    enforceActions?: "never" | "always" | "observed"
    computedRequiresReaction?: boolean
    /**
     * Warn if you try to create to derivation / reactive context without accessing any observable.
     */
    reactionRequiresObservable?: boolean
    /**
     * Warn if observables are accessed outside a reactive context
     */
    observableRequiresReaction?: boolean
    isolateGlobalState?: boolean
    disableErrorBoundaries?: boolean
    safeDescriptors?: boolean
    reactionScheduler?: (f: () => void) => void
    useProxies?: "always" | "never" | "ifavailable"
}): void {
    if (options.isolateGlobalState === true) {
        isolateGlobalState()
    }
    const { useProxies, enforceActions } = options
    if (useProxies !== undefined) {
        globalState.useProxies =
            useProxies === ALWAYS
                ? true
                : useProxies === NEVER
                ? false
                : typeof Proxy !== "undefined"
    }
    if (useProxies === "ifavailable") {
        globalState.verifyProxies = true
    }
    if (enforceActions !== undefined) {
        const ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED
        globalState.enforceActions = ea
        globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true
    }
    ;[
        "computedRequiresReaction",
        "reactionRequiresObservable",
        "observableRequiresReaction",
        "disableErrorBoundaries",
        "safeDescriptors"
    ].forEach(key => {
        if (key in options) {
            globalState[key] = !!options[key]
        }
    })
    globalState.allowStateReads = !globalState.observableRequiresReaction
    if (__DEV__ && globalState.disableErrorBoundaries === true) {
        console.warn(
            "WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled."
        )
    }
    if (options.reactionScheduler) {
        setReactionScheduler(options.reactionScheduler)
    }
}



================================================
FILE: packages/mobx/src/api/decorators.ts
================================================
import { Annotation, addHiddenProp, AnnotationsMap, hasProp, die, isOverride } from "../internal"

import type { Decorator } from "../types/decorator_fills"

export const storedAnnotationsSymbol = Symbol("mobx-stored-annotations")

/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */
export function createDecoratorAnnotation<D extends Decorator = Decorator>(
    annotation: Annotation
): PropertyDecorator & Annotation & D {
    function decorator(target, property) {
        if (is20223Decorator(property)) {
            return annotation.decorate_20223_(target, property)
        } else {
            storeAnnotation(target, property, annotation)
        }
    }
    return Object.assign(decorator, annotation) as any
}

/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */
export function storeAnnotation(prototype: any, key: PropertyKey, annotation: Annotation) {
    if (!hasProp(prototype, storedAnnotationsSymbol)) {
        addHiddenProp(prototype, storedAnnotationsSymbol, {
            // Inherit annotations
            ...prototype[storedAnnotationsSymbol]
        })
    }
    // @override must override something
    if (__DEV__ && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
        const fieldName = `${prototype.constructor.name}.prototype.${key.toString()}`
        die(
            `'${fieldName}' is decorated with 'override', ` +
                `but no such decorated member was found on prototype.`
        )
    }
    // Cannot re-decorate
    assertNotDecorated(prototype, annotation, key)

    // Ignore override
    if (!isOverride(annotation)) {
        prototype[storedAnnotationsSymbol][key] = annotation
    }
}

function assertNotDecorated(prototype: object, annotation: Annotation, key: PropertyKey) {
    if (__DEV__ && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
        const fieldName = `${prototype.constructor.name}.prototype.${key.toString()}`
        const currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_
        const requestedAnnotationType = annotation.annotationType_
        die(
            `Cannot apply '@${requestedAnnotationType}' to '${fieldName}':` +
                `\nThe field is already decorated with '@${currentAnnotationType}'.` +
                `\nRe-decorating fields is not allowed.` +
                `\nUse '@override' decorator for methods overridden by subclass.`
        )
    }
}

/**
 * Collects annotations from prototypes and stores them on target (instance)
 */
export function collectStoredAnnotations(target): AnnotationsMap<any, any> {
    if (!hasProp(target, storedAnnotationsSymbol)) {
        // if (__DEV__ && !target[storedAnnotationsSymbol]) {
        //     die(
        //         `No annotations were passed to makeObservable, but no decorated members have been found either`
        //     )
        // }
        // We need a copy as we will remove annotation from the list once it's applied.
        addHiddenProp(target, storedAnnotationsSymbol, { ...target[storedAnnotationsSymbol] })
    }
    return target[storedAnnotationsSymbol]
}

export function is20223Decorator(context): context is DecoratorContext {
    return typeof context == "object" && typeof context["kind"] == "string"
}

export function assert20223DecoratorType(
    context: DecoratorContext,
    types: DecoratorContext["kind"][]
) {
    if (__DEV__ && !types.includes(context.kind)) {
        die(
            `The decorator applied to '${String(context.name)}' cannot be used on a ${
                context.kind
            } element`
        )
    }
}



================================================
FILE: packages/mobx/src/api/extendobservable.ts
================================================
import {
    CreateObservableOptions,
    isObservableMap,
    AnnotationsMap,
    asObservableObject,
    isPlainObject,
    ObservableObjectAdministration,
    isObservable,
    die,
    getOwnPropertyDescriptors,
    $mobx,
    ownKeys,
    initObservable
} from "../internal"

export function extendObservable<A extends Object, B extends Object>(
    target: A,
    properties: B,
    annotations?: AnnotationsMap<B, never>,
    options?: CreateObservableOptions
): A & B {
    if (__DEV__) {
        if (arguments.length > 4) {
            die("'extendObservable' expected 2-4 arguments")
        }
        if (typeof target !== "object") {
            die("'extendObservable' expects an object as first argument")
        }
        if (isObservableMap(target)) {
            die("'extendObservable' should not be used on maps, use map.merge instead")
        }
        if (!isPlainObject(properties)) {
            die(`'extendObservable' only accepts plain objects as second argument`)
        }
        if (isObservable(properties) || isObservable(annotations)) {
            die(`Extending an object with another observable (object) is not supported`)
        }
    }
    // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)
    const descriptors = getOwnPropertyDescriptors(properties)

    initObservable(() => {
        const adm: ObservableObjectAdministration = asObservableObject(target, options)[$mobx]
        ownKeys(descriptors).forEach(key => {
            adm.extend_(
                key,
                descriptors[key as any],
                // must pass "undefined" for { key: undefined }
                !annotations ? true : key in annotations ? annotations[key] : true
            )
        })
    })

    return target as any
}



================================================
FILE: packages/mobx/src/api/extras.ts
================================================
import { IDepTreeNode, getAtom, getObservers, hasObservers } from "../internal"

export interface IDependencyTree {
    name: string
    dependencies?: IDependencyTree[]
}

export interface IObserverTree {
    name: string
    observers?: IObserverTree[]
}

export function getDependencyTree(thing: any, property?: string): IDependencyTree {
    return nodeToDependencyTree(getAtom(thing, property))
}

function nodeToDependencyTree(node: IDepTreeNode): IDependencyTree {
    const result: IDependencyTree = {
        name: node.name_
    }
    if (node.observing_ && node.observing_.length > 0) {
        result.dependencies = unique(node.observing_).map(nodeToDependencyTree)
    }
    return result
}

export function getObserverTree(thing: any, property?: string): IObserverTree {
    return nodeToObserverTree(getAtom(thing, property))
}

function nodeToObserverTree(node: IDepTreeNode): IObserverTree {
    const result: IObserverTree = {
        name: node.name_
    }
    if (hasObservers(node as any)) {
        result.observers = Array.from(<any>getObservers(node as any)).map(<any>nodeToObserverTree)
    }
    return result
}

function unique<T>(list: T[]): T[] {
    return Array.from(new Set(list))
}



================================================
FILE: packages/mobx/src/api/flow.ts
================================================
import {
    action,
    noop,
    die,
    isFunction,
    Annotation,
    isStringish,
    storeAnnotation,
    createFlowAnnotation,
    createDecoratorAnnotation,
    is20223Decorator
} from "../internal"

import type { ClassMethodDecorator } from "../types/decorator_fills"

export const FLOW = "flow"

let generatorId = 0

export function FlowCancellationError() {
    this.message = "FLOW_CANCELLED"
}
FlowCancellationError.prototype = Object.create(Error.prototype)

export function isFlowCancellationError(error: Error) {
    return error instanceof FlowCancellationError
}

export type CancellablePromise<T> = Promise<T> & { cancel(): void }

interface Flow extends Annotation, PropertyDecorator, ClassMethodDecorator {
    <R, Args extends any[]>(
        generator: (...args: Args) => Generator<any, R, any> | AsyncGenerator<any, R, any>
    ): (...args: Args) => CancellablePromise<R>
    bound: Annotation & PropertyDecorator & ClassMethodDecorator
}

const flowAnnotation = createFlowAnnotation("flow")
const flowBoundAnnotation = createFlowAnnotation("flow.bound", { bound: true })

export const flow: Flow = Object.assign(
    function flow(arg1, arg2?) {
        // @flow (2022.3 Decorators)
        if (is20223Decorator(arg2)) {
            return flowAnnotation.decorate_20223_(arg1, arg2)
        }
        // @flow
        if (isStringish(arg2)) {
            return storeAnnotation(arg1, arg2, flowAnnotation)
        }
        // flow(fn)
        if (__DEV__ && arguments.length !== 1) {
            die(`Flow expects single argument with generator function`)
        }
        const generator = arg1
        const name = generator.name || "<unnamed flow>"

        // Implementation based on https://github.com/tj/co/blob/master/index.js
        const res = function () {
            const ctx = this
            const args = arguments
            const runId = ++generatorId
            const gen = action(`${name} - runid: ${runId} - init`, generator).apply(ctx, args)
            let rejector: (error: any) => void
            let pendingPromise: CancellablePromise<any> | undefined = undefined

            const promise = new Promise(function (resolve, reject) {
                let stepId = 0
                rejector = reject

                function onFulfilled(res: any) {
                    pendingPromise = undefined
                    let ret
                    try {
                        ret = action(
                            `${name} - runid: ${runId} - yield ${stepId++}`,
                            gen.next
                        ).call(gen, res)
                    } catch (e) {
                        return reject(e)
                    }

                    next(ret)
                }

                function onRejected(err: any) {
                    pendingPromise = undefined
                    let ret
                    try {
                        ret = action(
                            `${name} - runid: ${runId} - yield ${stepId++}`,
                            gen.throw!
                        ).call(gen, err)
                    } catch (e) {
                        return reject(e)
                    }
                    next(ret)
                }

                function next(ret: any) {
                    if (isFunction(ret?.then)) {
                        // an async iterator
                        ret.then(next, reject)
                        return
                    }
                    if (ret.done) {
                        return resolve(ret.value)
                    }
                    pendingPromise = Promise.resolve(ret.value) as any
                    return pendingPromise!.then(onFulfilled, onRejected)
                }

                onFulfilled(undefined) // kick off the process
            }) as any

            promise.cancel = action(`${name} - runid: ${runId} - cancel`, function () {
                try {
                    if (pendingPromise) {
                        cancelPromise(pendingPromise)
                    }
                    // Finally block can return (or yield) stuff..
                    const res = gen.return!(undefined as any)
                    // eat anything that promise would do, it's cancelled!
                    const yieldedPromise = Promise.resolve(res.value)
                    yieldedPromise.then(noop, noop)
                    cancelPromise(yieldedPromise) // maybe it can be cancelled :)
                    // reject our original promise
                    rejector(new FlowCancellationError())
                } catch (e) {
                    rejector(e) // there could be a throwing finally block
                }
            })
            return promise
        }
        res.isMobXFlow = true
        return res
    } as any,
    flowAnnotation
)

flow.bound = createDecoratorAnnotation(flowBoundAnnotation)

function cancelPromise(promise) {
    if (isFunction(promise.cancel)) {
        promise.cancel()
    }
}

export function flowResult<T>(
    result: T
): T extends Generator<any, infer R, any>
    ? CancellablePromise<R>
    : T extends CancellablePromise<any>
    ? T
    : never {
    return result as any // just tricking TypeScript :)
}

export function isFlow(fn: any): boolean {
    return fn?.isMobXFlow === true
}



================================================
FILE: packages/mobx/src/api/intercept-read.ts
================================================
import {
    IObservableArray,
    IObservableValue,
    Lambda,
    ObservableMap,
    getAdministration,
    isObservableArray,
    isObservableMap,
    isObservableObject,
    isObservableValue,
    ObservableSet,
    die,
    isStringish
} from "../internal"

export type ReadInterceptor<T> = (value: any) => T

/** Experimental feature right now, tested indirectly via Mobx-State-Tree */
export function interceptReads<T>(value: IObservableValue<T>, handler: ReadInterceptor<T>): Lambda
export function interceptReads<T>(
    observableArray: IObservableArray<T>,
    handler: ReadInterceptor<T>
): Lambda
export function interceptReads<K, V>(
    observableMap: ObservableMap<K, V>,
    handler: ReadInterceptor<V>
): Lambda
export function interceptReads<V>(
    observableSet: ObservableSet<V>,
    handler: ReadInterceptor<V>
): Lambda
export function interceptReads(
    object: Object,
    property: string,
    handler: ReadInterceptor<any>
): Lambda
export function interceptReads(thing, propOrHandler?, handler?): Lambda {
    let target
    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
        target = getAdministration(thing)
    } else if (isObservableObject(thing)) {
        if (__DEV__ && !isStringish(propOrHandler)) {
            return die(
                `InterceptReads can only be used with a specific property, not with an object in general`
            )
        }
        target = getAdministration(thing, propOrHandler)
    } else if (__DEV__) {
        return die(`Expected observable map, object or array as first array`)
    }
    if (__DEV__ && target.dehancer !== undefined) {
        return die(`An intercept reader was already established`)
    }
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler
    return () => {
        target.dehancer = undefined
    }
}



================================================
FILE: packages/mobx/src/api/intercept.ts
================================================
import {
    IArrayWillChange,
    IArrayWillSplice,
    IInterceptor,
    IMapWillChange,
    IObjectWillChange,
    IObservableArray,
    IObservableValue,
    IValueWillChange,
    Lambda,
    ObservableMap,
    getAdministration,
    ObservableSet,
    ISetWillChange,
    isFunction
} from "../internal"

export function intercept<T>(
    value: IObservableValue<T>,
    handler: IInterceptor<IValueWillChange<T>>
): Lambda
export function intercept<T>(
    observableArray: IObservableArray<T> | Array<T>,
    handler: IInterceptor<IArrayWillChange<T> | IArrayWillSplice<T>>
): Lambda
export function intercept<K, V>(
    observableMap: ObservableMap<K, V> | Map<K, V>,
    handler: IInterceptor<IMapWillChange<K, V>>
): Lambda
export function intercept<V>(
    observableSet: ObservableSet<V> | Set<V>,
    handler: IInterceptor<ISetWillChange<V>>
): Lambda
export function intercept<K, V>(
    observableMap: ObservableMap<K, V> | Map<K, V>,
    property: K,
    handler: IInterceptor<IValueWillChange<V>>
): Lambda
export function intercept(object: object, handler: IInterceptor<IObjectWillChange>): Lambda
export function intercept<T extends object, K extends keyof T>(
    object: T,
    property: K,
    handler: IInterceptor<IValueWillChange<T[K]>>
): Lambda
export function intercept(thing, propOrHandler?, handler?): Lambda {
    if (isFunction(handler)) {
        return interceptProperty(thing, propOrHandler, handler)
    } else {
        return interceptInterceptable(thing, propOrHandler)
    }
}

function interceptInterceptable(thing, handler) {
    return getAdministration(thing).intercept_(handler)
}

function interceptProperty(thing, property, handler) {
    return getAdministration(thing, property).intercept_(handler)
}



================================================
FILE: packages/mobx/src/api/iscomputed.ts
================================================
import { $mobx, getAtom, isComputedValue, isObservableObject, die, isStringish } from "../internal"

export function _isComputed(value, property?: PropertyKey): boolean {
    if (property === undefined) {
        return isComputedValue(value)
    }
    if (isObservableObject(value) === false) {
        return false
    }
    if (!value[$mobx].values_.has(property)) {
        return false
    }
    const atom = getAtom(value, property)
    return isComputedValue(atom)
}

export function isComputed(value: any): boolean {
    if (__DEV__ && arguments.length > 1) {
        return die(
            `isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property`
        )
    }
    return _isComputed(value)
}

export function isComputedProp(value: any, propName: PropertyKey): boolean {
    if (__DEV__ && !isStringish(propName)) {
        return die(`isComputed expected a property name as second argument`)
    }
    return _isComputed(value, propName)
}



================================================
FILE: packages/mobx/src/api/isobservable.ts
================================================
import {
    $mobx,
    isAtom,
    isComputedValue,
    isObservableArray,
    isObservableMap,
    isObservableObject,
    isReaction,
    die,
    isStringish
} from "../internal"

function _isObservable(value, property?: PropertyKey): boolean {
    if (!value) {
        return false
    }
    if (property !== undefined) {
        if (__DEV__ && (isObservableMap(value) || isObservableArray(value))) {
            return die(
                "isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead."
            )
        }
        if (isObservableObject(value)) {
            return value[$mobx].values_.has(property)
        }
        return false
    }
    // For first check, see #701
    return (
        isObservableObject(value) ||
        !!value[$mobx] ||
        isAtom(value) ||
        isReaction(value) ||
        isComputedValue(value)
    )
}

export function isObservable(value: any): boolean {
    if (__DEV__ && arguments.length !== 1) {
        die(
            `isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property`
        )
    }
    return _isObservable(value)
}

export function isObservableProp(value: any, propName: PropertyKey): boolean {
    if (__DEV__ && !isStringish(propName)) {
        return die(`expected a property name as second argument`)
    }
    return _isObservable(value, propName)
}



================================================
FILE: packages/mobx/src/api/makeObservable.ts
================================================
import {
    $mobx,
    asObservableObject,
    AnnotationsMap,
    CreateObservableOptions,
    ObservableObjectAdministration,
    collectStoredAnnotations,
    isPlainObject,
    isObservableObject,
    die,
    ownKeys,
    extendObservable,
    addHiddenProp,
    storedAnnotationsSymbol,
    initObservable
} from "../internal"

// Hack based on https://github.com/Microsoft/TypeScript/issues/14829#issuecomment-322267089
// We need this, because otherwise, AdditionalKeys is going to be inferred to be any
// set of superfluous keys. But, we rather want to get a compile error unless AdditionalKeys is
// _explicity_ passed as generic argument
// Fixes: https://github.com/mobxjs/mobx/issues/2325#issuecomment-691070022
type NoInfer<T> = [T][T extends any ? 0 : never]

type MakeObservableOptions = Omit<CreateObservableOptions, "proxy">

export function makeObservable<T extends object, AdditionalKeys extends PropertyKey = never>(
    target: T,
    annotations?: AnnotationsMap<T, NoInfer<AdditionalKeys>>,
    options?: MakeObservableOptions
): T {
    initObservable(() => {
        const adm: ObservableObjectAdministration = asObservableObject(target, options)[$mobx]
        if (__DEV__ && annotations && target[storedAnnotationsSymbol]) {
            die(
                `makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.`
            )
        }
        // Default to decorators
        annotations ??= collectStoredAnnotations(target)

        // Annotate
        ownKeys(annotations).forEach(key => adm.make_(key, annotations![key]))
    })
    return target
}

// proto[keysSymbol] = new Set<PropertyKey>()
const keysSymbol = Symbol("mobx-keys")

export function makeAutoObservable<T extends object, AdditionalKeys extends PropertyKey = never>(
    target: T,
    overrides?: AnnotationsMap<T, NoInfer<AdditionalKeys>>,
    options?: MakeObservableOptions
): T {
    if (__DEV__) {
        if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {
            die(`'makeAutoObservable' can only be used for classes that don't have a superclass`)
        }
        if (isObservableObject(target)) {
            die(`makeAutoObservable can only be used on objects not already made observable`)
        }
    }

    // Optimization: avoid visiting protos
    // Assumes that annotation.make_/.extend_ works the same for plain objects
    if (isPlainObject(target)) {
        return extendObservable(target, target, overrides, options)
    }

    initObservable(() => {
        const adm: ObservableObjectAdministration = asObservableObject(target, options)[$mobx]

        // Optimization: cache keys on proto
        // Assumes makeAutoObservable can be called only once per object and can't be used in subclass
        if (!target[keysSymbol]) {
            const proto = Object.getPrototypeOf(target)
            const keys = new Set([...ownKeys(target), ...ownKeys(proto)])
            keys.delete("constructor")
            keys.delete($mobx)
            addHiddenProp(proto, keysSymbol, keys)
        }

        target[keysSymbol].forEach(key =>
            adm.make_(
                key,
                // must pass "undefined" for { key: undefined }
                !overrides ? true : key in overrides ? overrides[key] : true
            )
        )
    })

    return target
}



================================================
FILE: packages/mobx/src/api/object-api.ts
================================================
import {
    $mobx,
    IIsObservableObject,
    IObservableArray,
    ObservableMap,
    ObservableSet,
    ObservableObjectAdministration,
    endBatch,
    isObservableArray,
    isObservableMap,
    isObservableSet,
    isObservableObject,
    startBatch,
    die
} from "../internal"

export function keys<K>(map: ObservableMap<K, any>): ReadonlyArray<K>
export function keys<T>(ar: IObservableArray<T>): ReadonlyArray<number>
export function keys<T>(set: ObservableSet<T>): ReadonlyArray<T>
export function keys<T extends Object>(obj: T): ReadonlyArray<PropertyKey>
export function keys(obj: any): any {
    if (isObservableObject(obj)) {
        return (
            (obj as any as IIsObservableObject)[$mobx] as ObservableObjectAdministration
        ).keys_()
    }
    if (isObservableMap(obj) || isObservableSet(obj)) {
        return Array.from(obj.keys())
    }
    if (isObservableArray(obj)) {
        return obj.map((_, index) => index)
    }
    die(5)
}

export function values<K, T>(map: ObservableMap<K, T>): ReadonlyArray<T>
export function values<T>(set: ObservableSet<T>): ReadonlyArray<T>
export function values<T>(ar: IObservableArray<T>): ReadonlyArray<T>
export function values<T = any>(obj: T): ReadonlyArray<T extends object ? T[keyof T] : any>
export function values(obj: any): string[] {
    if (isObservableObject(obj)) {
        return keys(obj).map(key => obj[key])
    }
    if (isObservableMap(obj)) {
        return keys(obj).map(key => obj.get(key))
    }
    if (isObservableSet(obj)) {
        return Array.from(obj.values())
    }
    if (isObservableArray(obj)) {
        return obj.slice()
    }
    die(6)
}

export function entries<K, T>(map: ObservableMap<K, T>): ReadonlyArray<[K, T]>
export function entries<T>(set: ObservableSet<T>): ReadonlyArray<[T, T]>
export function entries<T>(ar: IObservableArray<T>): ReadonlyArray<[number, T]>
export function entries<T = any>(
    obj: T
): ReadonlyArray<[string, T extends object ? T[keyof T] : any]>
export function entries(obj: any): any {
    if (isObservableObject(obj)) {
        return keys(obj).map(key => [key, obj[key]])
    }
    if (isObservableMap(obj)) {
        return keys(obj).map(key => [key, obj.get(key)])
    }
    if (isObservableSet(obj)) {
        return Array.from(obj.entries())
    }
    if (isObservableArray(obj)) {
        return obj.map((key, index) => [index, key])
    }
    die(7)
}

export function set<V>(obj: ObservableMap<PropertyKey, V>, values: { [key: string]: V })
export function set<K, V>(obj: ObservableMap<K, V>, key: K, value: V)
export function set<T>(obj: ObservableSet<T>, value: T)
export function set<T>(obj: IObservableArray<T>, index: number, value: T)
export function set<T extends Object>(obj: T, values: { [key: string]: any })
export function set<T extends Object>(obj: T, key: PropertyKey, value: any)
export function set(obj: any, key: any, value?: any): void {
    if (arguments.length === 2 && !isObservableSet(obj)) {
        startBatch()
        const values = key
        try {
            for (let key in values) {
                set(obj, key, values[key])
            }
        } finally {
            endBatch()
        }
        return
    }
    if (isObservableObject(obj)) {
        ;(obj as any as IIsObservableObject)[$mobx].set_(key, value)
    } else if (isObservableMap(obj)) {
        obj.set(key, value)
    } else if (isObservableSet(obj)) {
        obj.add(key)
    } else if (isObservableArray(obj)) {
        if (typeof key !== "number") {
            key = parseInt(key, 10)
        }
        if (key < 0) {
            die(`Invalid index: '${key}'`)
        }
        startBatch()
        if (key >= obj.length) {
            obj.length = key + 1
        }
        obj[key] = value
        endBatch()
    } else {
        die(8)
    }
}

export function remove<K, V>(obj: ObservableMap<K, V>, key: K)
export function remove<T>(obj: ObservableSet<T>, key: T)
export function remove<T>(obj: IObservableArray<T>, index: number)
export function remove<T extends Object>(obj: T, key: string)
export function remove(obj: any, key: any): void {
    if (isObservableObject(obj)) {
        ;(obj as any as IIsObservableObject)[$mobx].delete_(key)
    } else if (isObservableMap(obj)) {
        obj.delete(key)
    } else if (isObservableSet(obj)) {
        obj.delete(key)
    } else if (isObservableArray(obj)) {
        if (typeof key !== "number") {
            key = parseInt(key, 10)
        }
        obj.splice(key, 1)
    } else {
        die(9)
    }
}

export function has<K>(obj: ObservableMap<K, any>, key: K): boolean
export function has<T>(obj: ObservableSet<T>, key: T): boolean
export function has<T>(obj: IObservableArray<T>, index: number): boolean
export function has<T extends Object>(obj: T, key: string): boolean
export function has(obj: any, key: any): boolean {
    if (isObservableObject(obj)) {
        return (obj as any as IIsObservableObject)[$mobx].has_(key)
    } else if (isObservableMap(obj)) {
        return obj.has(key)
    } else if (isObservableSet(obj)) {
        return obj.has(key)
    } else if (isObservableArray(obj)) {
        return key >= 0 && key < obj.length
    }
    die(10)
}

export function get<K, V>(obj: ObservableMap<K, V>, key: K): V | undefined
export function get<T>(obj: IObservableArray<T>, index: number): T | undefined
export function get<T extends Object>(obj: T, key: string): any
export function get(obj: any, key: any): any {
    if (!has(obj, key)) {
        return undefined
    }
    if (isObservableObject(obj)) {
        return (obj as any as IIsObservableObject)[$mobx].get_(key)
    } else if (isObservableMap(obj)) {
        return obj.get(key)
    } else if (isObservableArray(obj)) {
        return obj[key]
    }
    die(11)
}

export function apiDefineProperty(obj: Object, key: PropertyKey, descriptor: PropertyDescriptor) {
    if (isObservableObject(obj)) {
        return (obj as any as IIsObservableObject)[$mobx].defineProperty_(key, descriptor)
    }
    die(39)
}

export function apiOwnKeys(obj: Object) {
    if (isObservableObject(obj)) {
        return (obj as any as IIsObservableObject)[$mobx].ownKeys_()
    }
    die(38)
}



================================================
FILE: packages/mobx/src/api/observable.ts
================================================
import {
    IEnhancer,
    IEqualsComparer,
    IObservableArray,
    IObservableMapInitialValues,
    IObservableSetInitialValues,
    IObservableValue,
    ObservableMap,
    ObservableSet,
    ObservableValue,
    asDynamicObservableObject,
    createObservableArray,
    deepEnhancer,
    extendObservable,
    isES6Map,
    isES6Set,
    isObservable,
    isPlainObject,
    referenceEnhancer,
    Annotation,
    shallowEnhancer,
    refStructEnhancer,
    AnnotationsMap,
    asObservableObject,
    storeAnnotation,
    createDecoratorAnnotation,
    createLegacyArray,
    globalState,
    assign,
    isStringish,
    createObservableAnnotation,
    createAutoAnnotation,
    is20223Decorator,
    initObservable
} from "../internal"

import type { ClassAccessorDecorator, ClassFieldDecorator } from "../types/decorator_fills"

export const OBSERVABLE = "observable"
export const OBSERVABLE_REF = "observable.ref"
export const OBSERVABLE_SHALLOW = "observable.shallow"
export const OBSERVABLE_STRUCT = "observable.struct"

export type CreateObservableOptions = {
    name?: string
    equals?: IEqualsComparer<any>
    deep?: boolean
    defaultDecorator?: Annotation
    proxy?: boolean
    autoBind?: boolean
}

// Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases
export const defaultCreateObservableOptions: CreateObservableOptions = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined,
    proxy: true
}
Object.freeze(defaultCreateObservableOptions)

export function asCreateObservableOptions(thing: any): CreateObservableOptions {
    return thing || defaultCreateObservableOptions
}

const observableAnnotation = createObservableAnnotation(OBSERVABLE)
const observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {
    enhancer: referenceEnhancer
})
const observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {
    enhancer: shallowEnhancer
})
const observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {
    enhancer: refStructEnhancer
})
const observableDecoratorAnnotation =
    createDecoratorAnnotation<ClassAccessorDecorator>(observableAnnotation)

export function getEnhancerFromOptions(options: CreateObservableOptions): IEnhancer<any> {
    return options.deep === true
        ? deepEnhancer
        : options.deep === false
        ? referenceEnhancer
        : getEnhancerFromAnnotation(options.defaultDecorator)
}

export function getAnnotationFromOptions(
    options?: CreateObservableOptions
): Annotation | undefined {
    return options ? options.defaultDecorator ?? createAutoAnnotation(options) : undefined
}

export function getEnhancerFromAnnotation(annotation?: Annotation): IEnhancer<any> {
    return !annotation ? deepEnhancer : annotation.options_?.enhancer ?? deepEnhancer
}

/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */
function createObservable(v: any, arg2?: any, arg3?: any) {
    // @observable someProp; (2022.3 Decorators)
    if (is20223Decorator(arg2)) {
        return observableAnnotation.decorate_20223_(v, arg2)
    }

    // @observable someProp;
    if (isStringish(arg2)) {
        storeAnnotation(v, arg2, observableAnnotation)
        return
    }

    // already observable - ignore
    if (isObservable(v)) {
        return v
    }

    // plain object
    if (isPlainObject(v)) {
        return observable.object(v, arg2, arg3)
    }

    // Array
    if (Array.isArray(v)) {
        return observable.array(v, arg2)
    }

    // Map
    if (isES6Map(v)) {
        return observable.map(v, arg2)
    }

    // Set
    if (isES6Set(v)) {
        return observable.set(v, arg2)
    }

    // other object - ignore
    if (typeof v === "object" && v !== null) {
        return v
    }

    // anything else
    return observable.box(v, arg2)
}
assign(createObservable, observableDecoratorAnnotation)

export interface IObservableValueFactory {
    <T>(value: T, options?: CreateObservableOptions): IObservableValue<T>
    <T>(value?: T, options?: CreateObservableOptions): IObservableValue<T | undefined>
}

export interface IObservableFactory
    extends Annotation,
        PropertyDecorator,
        ClassAccessorDecorator,
        ClassFieldDecorator {
    // TODO: remove ClassFieldDecorator, this is only temporarily support for legacy decorators
    <T = any>(value: T[], options?: CreateObservableOptions): IObservableArray<T>
    <T = any>(value: Set<T>, options?: CreateObservableOptions): ObservableSet<T>
    <K = any, V = any>(value: Map<K, V>, options?: CreateObservableOptions): ObservableMap<K, V>
    <T extends object>(
        value: T,
        decorators?: AnnotationsMap<T, never>,
        options?: CreateObservableOptions
    ): T

    box: IObservableValueFactory
    array: <T = any>(initialValues?: T[], options?: CreateObservableOptions) => IObservableArray<T>
    set: <T = any>(
        initialValues?: IObservableSetInitialValues<T>,
        options?: CreateObservableOptions
    ) => ObservableSet<T>
    map: <K = any, V = any>(
        initialValues?: IObservableMapInitialValues<K, V>,
        options?: CreateObservableOptions
    ) => ObservableMap<K, V>
    object: <T = any>(
        props: T,
        decorators?: AnnotationsMap<T, never>,
        options?: CreateObservableOptions
    ) => T

    /**
     * Decorator that creates an observable that only observes the references, but doesn't try to turn the assigned value into an observable.ts.
     */
    ref: Annotation & PropertyDecorator & ClassAccessorDecorator & ClassFieldDecorator
    /**
     * Decorator that creates an observable converts its value (objects, maps or arrays) into a shallow observable structure
     */
    shallow: Annotation & PropertyDecorator & ClassAccessorDecorator & ClassFieldDecorator
    deep: Annotation & PropertyDecorator & ClassAccessorDecorator & ClassFieldDecorator
    struct: Annotation & PropertyDecorator & ClassAccessorDecorator & ClassFieldDecorator
}

const observableFactories: IObservableFactory = {
    box<T = any>(value: T, options?: CreateObservableOptions): IObservableValue<T> {
        const o = asCreateObservableOptions(options)
        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals)
    },
    array<T = any>(initialValues?: T[], options?: CreateObservableOptions): IObservableArray<T> {
        const o = asCreateObservableOptions(options)
        return (
            globalState.useProxies === false || o.proxy === false
                ? createLegacyArray
                : createObservableArray
        )(initialValues, getEnhancerFromOptions(o), o.name)
    },
    map<K = any, V = any>(
        initialValues?: IObservableMapInitialValues<K, V>,
        options?: CreateObservableOptions
    ): ObservableMap<K, V> {
        const o = asCreateObservableOptions(options)
        return new ObservableMap<K, V>(initialValues, getEnhancerFromOptions(o), o.name)
    },
    set<T = any>(
        initialValues?: IObservableSetInitialValues<T>,
        options?: CreateObservableOptions
    ): ObservableSet<T> {
        const o = asCreateObservableOptions(options)
        return new ObservableSet<T>(initialValues, getEnhancerFromOptions(o), o.name)
    },
    object<T extends object = any>(
        props: T,
        decorators?: AnnotationsMap<T, never>,
        options?: CreateObservableOptions
    ): T {
        return initObservable(() =>
            extendObservable(
                globalState.useProxies === false || options?.proxy === false
                    ? asObservableObject({}, options)
                    : asDynamicObservableObject({}, options),
                props,
                decorators
            )
        )
    },
    ref: createDecoratorAnnotation(observableRefAnnotation),
    shallow: createDecoratorAnnotation(observableShallowAnnotation),
    deep: observableDecoratorAnnotation,
    struct: createDecoratorAnnotation(observableStructAnnotation)
} as any

// eslint-disable-next-line
export var observable: IObservableFactory = assign(createObservable, observableFactories)



================================================
FILE: packages/mobx/src/api/observe.ts
================================================
import {
    IArrayDidChange,
    IComputedValue,
    IMapDidChange,
    IObjectDidChange,
    IObservableArray,
    IObservableValue,
    IValueDidChange,
    Lambda,
    ObservableMap,
    getAdministration,
    ObservableSet,
    ISetDidChange,
    isFunction
} from "../internal"

export function observe<T>(
    value: IObservableValue<T> | IComputedValue<T>,
    listener: (change: IValueDidChange<T>) => void,
    fireImmediately?: boolean
): Lambda
export function observe<T>(
    observableArray: IObservableArray<T> | Array<T>,
    listener: (change: IArrayDidChange<T>) => void,
    fireImmediately?: boolean
): Lambda
export function observe<V>(
    // ObservableSet/ObservableMap are required despite they implement Set/Map: https://github.com/mobxjs/mobx/pull/3180#discussion_r746542929
    observableSet: ObservableSet<V> | Set<V>,
    listener: (change: ISetDidChange<V>) => void,
    fireImmediately?: boolean
): Lambda
export function observe<K, V>(
    observableMap: ObservableMap<K, V> | Map<K, V>,
    listener: (change: IMapDidChange<K, V>) => void,
    fireImmediately?: boolean
): Lambda
export function observe<K, V>(
    observableMap: ObservableMap<K, V> | Map<K, V>,
    property: K,
    listener: (change: IValueDidChange<V>) => void,
    fireImmediately?: boolean
): Lambda
export function observe(
    object: Object,
    listener: (change: IObjectDidChange) => void,
    fireImmediately?: boolean
): Lambda
export function observe<T, K extends keyof T>(
    object: T,
    property: K,
    listener: (change: IValueDidChange<T[K]>) => void,
    fireImmediately?: boolean
): Lambda
export function observe(thing, propOrCb?, cbOrFire?, fireImmediately?): Lambda {
    if (isFunction(cbOrFire)) {
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately)
    } else {
        return observeObservable(thing, propOrCb, cbOrFire)
    }
}

function observeObservable(thing, listener, fireImmediately: boolean) {
    return getAdministration(thing).observe_(listener, fireImmediately)
}

function observeObservableProperty(thing, property, listener, fireImmediately: boolean) {
    return getAdministration(thing, property).observe_(listener, fireImmediately)
}



================================================
FILE: packages/mobx/src/api/tojs.ts
================================================
import {
    isObservable,
    isObservableArray,
    isObservableValue,
    isObservableMap,
    isObservableSet,
    isComputedValue,
    die,
    apiOwnKeys,
    objectPrototype
} from "../internal"

function cache<K, V>(map: Map<any, any>, key: K, value: V): V {
    map.set(key, value)
    return value
}

function toJSHelper(source, __alreadySeen: Map<any, any>) {
    if (
        source == null ||
        typeof source !== "object" ||
        source instanceof Date ||
        !isObservable(source)
    ) {
        return source
    }

    if (isObservableValue(source) || isComputedValue(source)) {
        return toJSHelper(source.get(), __alreadySeen)
    }
    if (__alreadySeen.has(source)) {
        return __alreadySeen.get(source)
    }
    if (isObservableArray(source)) {
        const res = cache(__alreadySeen, source, new Array(source.length))
        source.forEach((value, idx) => {
            res[idx] = toJSHelper(value, __alreadySeen)
        })
        return res
    }
    if (isObservableSet(source)) {
        const res = cache(__alreadySeen, source, new Set())
        source.forEach(value => {
            res.add(toJSHelper(value, __alreadySeen))
        })
        return res
    }
    if (isObservableMap(source)) {
        const res = cache(__alreadySeen, source, new Map())
        source.forEach((value, key) => {
            res.set(key, toJSHelper(value, __alreadySeen))
        })
        return res
    } else {
        // must be observable object
        const res = cache(__alreadySeen, source, {})
        apiOwnKeys(source).forEach((key: any) => {
            if (objectPrototype.propertyIsEnumerable.call(source, key)) {
                res[key] = toJSHelper(source[key], __alreadySeen)
            }
        })
        return res
    }
}

/**
 * Recursively converts an observable to it's non-observable native counterpart.
 * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.
 * Computed and other non-enumerable properties are completely ignored.
 * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.
 */
export function toJS<T>(source: T, options?: any): T {
    if (__DEV__ && options) {
        die("toJS no longer supports options")
    }
    return toJSHelper(source, new Map())
}



================================================
FILE: packages/mobx/src/api/trace.ts
================================================
import { TraceMode, die, getAtom, globalState } from "../internal"

export function trace(thing?: any, prop?: string, enterBreakPoint?: boolean): void
export function trace(thing?: any, enterBreakPoint?: boolean): void
export function trace(enterBreakPoint?: boolean): void
export function trace(...args: any[]): void {
    if (!__DEV__) {
        return
    }
    let enterBreakPoint = false
    if (typeof args[args.length - 1] === "boolean") {
        enterBreakPoint = args.pop()
    }
    const derivation = getAtomFromArgs(args)
    if (!derivation) {
        return die(
            `'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly`
        )
    }
    if (derivation.isTracing_ === TraceMode.NONE) {
        console.log(`[mobx.trace] '${derivation.name_}' tracing enabled`)
    }
    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG
}

function getAtomFromArgs(args): any {
    switch (args.length) {
        case 0:
            return globalState.trackingDerivation
        case 1:
            return getAtom(args[0])
        case 2:
            return getAtom(args[0], args[1])
    }
}



================================================
FILE: packages/mobx/src/api/transaction.ts
================================================
import { endBatch, startBatch } from "../internal"

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */
export function transaction<T>(action: () => T, thisArg = undefined): T {
    startBatch()
    try {
        return action.apply(thisArg)
    } finally {
        endBatch()
    }
}



================================================
FILE: packages/mobx/src/api/when.ts
================================================
import {
    $mobx,
    IReactionDisposer,
    Lambda,
    autorun,
    createAction,
    getNextId,
    die,
    allowStateChanges,
    GenericAbortSignal
} from "../internal"

export interface IWhenOptions {
    name?: string
    timeout?: number
    onError?: (error: any) => void
    signal?: GenericAbortSignal
}

export function when(
    predicate: () => boolean,
    opts?: IWhenOptions
): Promise<void> & { cancel(): void }
export function when(
    predicate: () => boolean,
    effect: Lambda,
    opts?: IWhenOptions
): IReactionDisposer
export function when(predicate: any, arg1?: any, arg2?: any): any {
    if (arguments.length === 1 || (arg1 && typeof arg1 === "object")) {
        return whenPromise(predicate, arg1)
    }
    return _when(predicate, arg1, arg2 || {})
}

function _when(predicate: () => boolean, effect: Lambda, opts: IWhenOptions): IReactionDisposer {
    let timeoutHandle: any
    if (typeof opts.timeout === "number") {
        const error = new Error("WHEN_TIMEOUT")
        timeoutHandle = setTimeout(() => {
            if (!disposer[$mobx].isDisposed) {
                disposer()
                if (opts.onError) {
                    opts.onError(error)
                } else {
                    throw error
                }
            }
        }, opts.timeout)
    }

    opts.name = __DEV__ ? opts.name || "When@" + getNextId() : "When"
    const effectAction = createAction(
        __DEV__ ? opts.name + "-effect" : "When-effect",
        effect as Function
    )
    // eslint-disable-next-line
    var disposer = autorun(r => {
        // predicate should not change state
        let cond = allowStateChanges(false, predicate)
        if (cond) {
            r.dispose()
            if (timeoutHandle) {
                clearTimeout(timeoutHandle)
            }
            effectAction()
        }
    }, opts)
    return disposer
}

function whenPromise(
    predicate: () => boolean,
    opts?: IWhenOptions
): Promise<void> & { cancel(): void } {
    if (__DEV__ && opts && opts.onError) {
        return die(`the options 'onError' and 'promise' cannot be combined`)
    }
    if (opts?.signal?.aborted) {
        return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), { cancel: () => null })
    }
    let cancel
    let abort
    const res = new Promise((resolve, reject) => {
        let disposer = _when(predicate, resolve as Lambda, { ...opts, onError: reject })
        cancel = () => {
            disposer()
            reject(new Error("WHEN_CANCELLED"))
        }
        abort = () => {
            disposer()
            reject(new Error("WHEN_ABORTED"))
        }
        opts?.signal?.addEventListener?.("abort", abort)
    }).finally(() => opts?.signal?.removeEventListener?.("abort", abort))
    ;(res as any).cancel = cancel
    return res as any
}



================================================
FILE: packages/mobx/src/core/action.ts
================================================
import {
    IDerivation,
    endBatch,
    globalState,
    isSpyEnabled,
    spyReportEnd,
    spyReportStart,
    startBatch,
    untrackedEnd,
    untrackedStart,
    isFunction,
    allowStateReadsStart,
    allowStateReadsEnd,
    ACTION,
    EMPTY_ARRAY,
    die,
    getDescriptor,
    defineProperty
} from "../internal"

// we don't use globalState for these in order to avoid possible issues with multiple
// mobx versions
let currentActionId = 0
let nextActionId = 1
const isFunctionNameConfigurable = getDescriptor(() => {}, "name")?.configurable ?? false

// we can safely recycle this object
const tmpNameDescriptor: PropertyDescriptor = {
    value: "action",
    configurable: true,
    writable: false,
    enumerable: false
}

export function createAction(
    actionName: string,
    fn: Function,
    autoAction: boolean = false,
    ref?: Object
): Function {
    if (__DEV__) {
        if (!isFunction(fn)) {
            die("`action` can only be invoked on functions")
        }
        if (typeof actionName !== "string" || !actionName) {
            die(`actions should have valid names, got: '${actionName}'`)
        }
    }
    function res() {
        return executeAction(actionName, autoAction, fn, ref || this, arguments)
    }
    res.isMobxAction = true
    res.toString = () => fn.toString()
    if (isFunctionNameConfigurable) {
        tmpNameDescriptor.value = actionName
        defineProperty(res, "name", tmpNameDescriptor)
    }
    return res
}

export function executeAction(
    actionName: string,
    canRunAsDerivation: boolean,
    fn: Function,
    scope?: any,
    args?: IArguments
) {
    const runInfo = _startAction(actionName, canRunAsDerivation, scope, args)
    try {
        return fn.apply(scope, args)
    } catch (err) {
        runInfo.error_ = err
        throw err
    } finally {
        _endAction(runInfo)
    }
}

export interface IActionRunInfo {
    prevDerivation_: IDerivation | null
    prevAllowStateChanges_: boolean
    prevAllowStateReads_: boolean
    notifySpy_: boolean
    startTime_: number
    error_?: any
    parentActionId_: number
    actionId_: number
    runAsAction_?: boolean
}

export function _startAction(
    actionName: string,
    canRunAsDerivation: boolean, // true for autoAction
    scope: any,
    args?: IArguments
): IActionRunInfo {
    const notifySpy_ = __DEV__ && isSpyEnabled() && !!actionName
    let startTime_: number = 0
    if (__DEV__ && notifySpy_) {
        startTime_ = Date.now()
        const flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY
        spyReportStart({
            type: ACTION,
            name: actionName,
            object: scope,
            arguments: flattenedArgs
        })
    }
    const prevDerivation_ = globalState.trackingDerivation
    const runAsAction = !canRunAsDerivation || !prevDerivation_
    startBatch()
    let prevAllowStateChanges_ = globalState.allowStateChanges // by default preserve previous allow
    if (runAsAction) {
        untrackedStart()
        prevAllowStateChanges_ = allowStateChangesStart(true)
    }
    const prevAllowStateReads_ = allowStateReadsStart(true)
    const runInfo = {
        runAsAction_: runAsAction,
        prevDerivation_,
        prevAllowStateChanges_,
        prevAllowStateReads_,
        notifySpy_,
        startTime_,
        actionId_: nextActionId++,
        parentActionId_: currentActionId
    }
    currentActionId = runInfo.actionId_
    return runInfo
}

export function _endAction(runInfo: IActionRunInfo) {
    if (currentActionId !== runInfo.actionId_) {
        die(30)
    }
    currentActionId = runInfo.parentActionId_

    if (runInfo.error_ !== undefined) {
        globalState.suppressReactionErrors = true
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges_)
    allowStateReadsEnd(runInfo.prevAllowStateReads_)
    endBatch()
    if (runInfo.runAsAction_) {
        untrackedEnd(runInfo.prevDerivation_)
    }
    if (__DEV__ && runInfo.notifySpy_) {
        spyReportEnd({ time: Date.now() - runInfo.startTime_ })
    }
    globalState.suppressReactionErrors = false
}

export function allowStateChanges<T>(allowStateChanges: boolean, func: () => T): T {
    const prev = allowStateChangesStart(allowStateChanges)
    try {
        return func()
    } finally {
        allowStateChangesEnd(prev)
    }
}

export function allowStateChangesStart(allowStateChanges: boolean) {
    const prev = globalState.allowStateChanges
    globalState.allowStateChanges = allowStateChanges
    return prev
}

export function allowStateChangesEnd(prev: boolean) {
    globalState.allowStateChanges = prev
}



================================================
FILE: packages/mobx/src/core/atom.ts
================================================
import {
    IDerivationState_,
    IObservable,
    IDerivation,
    createInstanceofPredicate,
    endBatch,
    getNextId,
    noop,
    onBecomeObserved,
    onBecomeUnobserved,
    propagateChanged,
    reportObserved,
    startBatch,
    Lambda
} from "../internal"

import { getFlag, setFlag } from "../utils/utils"

export const $mobx = Symbol("mobx administration")

export interface IAtom extends IObservable {
    reportObserved(): boolean
    reportChanged(): void
}

export class Atom implements IAtom {
    private static readonly isBeingObservedMask_ = 0b001
    private static readonly isPendingUnobservationMask_ = 0b010
    private static readonly diffValueMask_ = 0b100
    private flags_ = 0b000

    observers_ = new Set<IDerivation>()

    lastAccessedBy_ = 0
    lowestObserverState_ = IDerivationState_.NOT_TRACKING_
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */
    constructor(public name_ = __DEV__ ? "Atom@" + getNextId() : "Atom") {}

    // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
    get isBeingObserved(): boolean {
        return getFlag(this.flags_, Atom.isBeingObservedMask_)
    }
    set isBeingObserved(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Atom.isBeingObservedMask_, newValue)
    }

    get isPendingUnobservation(): boolean {
        return getFlag(this.flags_, Atom.isPendingUnobservationMask_)
    }
    set isPendingUnobservation(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Atom.isPendingUnobservationMask_, newValue)
    }

    get diffValue(): 0 | 1 {
        return getFlag(this.flags_, Atom.diffValueMask_) ? 1 : 0
    }
    set diffValue(newValue: 0 | 1) {
        this.flags_ = setFlag(this.flags_, Atom.diffValueMask_, newValue === 1 ? true : false)
    }

    // onBecomeObservedListeners
    public onBOL: Set<Lambda> | undefined
    // onBecomeUnobservedListeners
    public onBUOL: Set<Lambda> | undefined

    public onBO() {
        if (this.onBOL) {
            this.onBOL.forEach(listener => listener())
        }
    }

    public onBUO() {
        if (this.onBUOL) {
            this.onBUOL.forEach(listener => listener())
        }
    }

    /**
     * Invoke this method to notify mobx that your atom has been used somehow.
     * Returns true if there is currently a reactive context.
     */
    public reportObserved(): boolean {
        return reportObserved(this)
    }

    /**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */
    public reportChanged() {
        startBatch()
        propagateChanged(this)
        endBatch()
    }

    toString() {
        return this.name_
    }
}

export const isAtom = createInstanceofPredicate("Atom", Atom)

export function createAtom(
    name: string,
    onBecomeObservedHandler: () => void = noop,
    onBecomeUnobservedHandler: () => void = noop
): IAtom {
    const atom = new Atom(name)
    // default `noop` listener will not initialize the hook Set
    if (onBecomeObservedHandler !== noop) {
        onBecomeObserved(atom, onBecomeObservedHandler)
    }

    if (onBecomeUnobservedHandler !== noop) {
        onBecomeUnobserved(atom, onBecomeUnobservedHandler)
    }
    return atom
}



================================================
FILE: packages/mobx/src/core/computedvalue.ts
================================================
import {
    CaughtException,
    IDerivation,
    IDerivationState_,
    IEqualsComparer,
    IObservable,
    Lambda,
    TraceMode,
    autorun,
    clearObserving,
    comparer,
    createAction,
    createInstanceofPredicate,
    endBatch,
    getNextId,
    globalState,
    isCaughtException,
    isSpyEnabled,
    propagateChangeConfirmed,
    propagateMaybeChanged,
    reportObserved,
    shouldCompute,
    spyReport,
    startBatch,
    toPrimitive,
    trackDerivedFunction,
    untrackedEnd,
    untrackedStart,
    UPDATE,
    die,
    allowStateChangesStart,
    allowStateChangesEnd
} from "../internal"

import { getFlag, setFlag } from "../utils/utils"

export interface IComputedValue<T> {
    get(): T
    set(value: T): void
}

export interface IComputedValueOptions<T> {
    get?: () => T
    set?: (value: T) => void
    name?: string
    equals?: IEqualsComparer<T>
    context?: any
    requiresReaction?: boolean
    keepAlive?: boolean
}

export type IComputedDidChange<T = any> = {
    type: "update"
    observableKind: "computed"
    object: unknown
    debugObjectName: string
    newValue: T
    oldValue: T | undefined
}

/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */
export class ComputedValue<T> implements IObservable, IComputedValue<T>, IDerivation {
    dependenciesState_ = IDerivationState_.NOT_TRACKING_
    observing_: IObservable[] = [] // nodes we are looking at. Our value depends on these nodes
    newObserving_ = null // during tracking it's an array with new observed observers
    observers_ = new Set<IDerivation>()
    runId_ = 0
    lastAccessedBy_ = 0
    lowestObserverState_ = IDerivationState_.UP_TO_DATE_
    unboundDepsCount_ = 0
    protected value_: T | undefined | CaughtException = new CaughtException(null)
    name_: string
    triggeredBy_?: string

    private static readonly isComputingMask_ = 0b00001
    private static readonly isRunningSetterMask_ = 0b00010
    private static readonly isBeingObservedMask_ = 0b00100
    private static readonly isPendingUnobservationMask_ = 0b01000
    private static readonly diffValueMask_ = 0b10000
    private flags_ = 0b00000

    derivation: () => T // N.B: unminified as it is used by MST
    setter_?: (value: T) => void
    isTracing_: TraceMode = TraceMode.NONE
    scope_: Object | undefined
    private equals_: IEqualsComparer<any>
    private requiresReaction_: boolean | undefined
    keepAlive_: boolean

    /**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce a new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */
    constructor(options: IComputedValueOptions<T>) {
        if (!options.get) {
            die(31)
        }
        this.derivation = options.get!
        this.name_ = options.name || (__DEV__ ? "ComputedValue@" + getNextId() : "ComputedValue")
        if (options.set) {
            this.setter_ = createAction(
                __DEV__ ? this.name_ + "-setter" : "ComputedValue-setter",
                options.set
            ) as any
        }
        this.equals_ =
            options.equals ||
            ((options as any).compareStructural || (options as any).struct
                ? comparer.structural
                : comparer.default)
        this.scope_ = options.context
        this.requiresReaction_ = options.requiresReaction
        this.keepAlive_ = !!options.keepAlive
    }

    onBecomeStale_() {
        propagateMaybeChanged(this)
    }

    public onBOL: Set<Lambda> | undefined
    public onBUOL: Set<Lambda> | undefined

    public onBO() {
        if (this.onBOL) {
            this.onBOL.forEach(listener => listener())
        }
    }

    public onBUO() {
        if (this.onBUOL) {
            this.onBUOL.forEach(listener => listener())
        }
    }

    // to check for cycles
    private get isComputing(): boolean {
        return getFlag(this.flags_, ComputedValue.isComputingMask_)
    }
    private set isComputing(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, ComputedValue.isComputingMask_, newValue)
    }

    private get isRunningSetter(): boolean {
        return getFlag(this.flags_, ComputedValue.isRunningSetterMask_)
    }
    private set isRunningSetter(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, ComputedValue.isRunningSetterMask_, newValue)
    }

    get isBeingObserved(): boolean {
        return getFlag(this.flags_, ComputedValue.isBeingObservedMask_)
    }
    set isBeingObserved(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, ComputedValue.isBeingObservedMask_, newValue)
    }

    get isPendingUnobservation(): boolean {
        return getFlag(this.flags_, ComputedValue.isPendingUnobservationMask_)
    }
    set isPendingUnobservation(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, ComputedValue.isPendingUnobservationMask_, newValue)
    }

    get diffValue(): 0 | 1 {
        return getFlag(this.flags_, ComputedValue.diffValueMask_) ? 1 : 0
    }
    set diffValue(newValue: 0 | 1) {
        this.flags_ = setFlag(
            this.flags_,
            ComputedValue.diffValueMask_,
            newValue === 1 ? true : false
        )
    }

    /**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */
    public get(): T {
        if (this.isComputing) {
            die(32, this.name_, this.derivation)
        }
        if (
            globalState.inBatch === 0 &&
            // !globalState.trackingDerivatpion &&
            this.observers_.size === 0 &&
            !this.keepAlive_
        ) {
            if (shouldCompute(this)) {
                this.warnAboutUntrackedRead_()
                startBatch() // See perf test 'computed memoization'
                this.value_ = this.computeValue_(false)
                endBatch()
            }
        } else {
            reportObserved(this)
            if (shouldCompute(this)) {
                let prevTrackingContext = globalState.trackingContext
                if (this.keepAlive_ && !prevTrackingContext) {
                    globalState.trackingContext = this
                }
                if (this.trackAndCompute()) {
                    propagateChangeConfirmed(this)
                }
                globalState.trackingContext = prevTrackingContext
            }
        }
        const result = this.value_!

        if (isCaughtException(result)) {
            throw result.cause
        }
        return result
    }

    public set(value: T) {
        if (this.setter_) {
            if (this.isRunningSetter) {
                die(33, this.name_)
            }
            this.isRunningSetter = true
            try {
                this.setter_.call(this.scope_, value)
            } finally {
                this.isRunningSetter = false
            }
        } else {
            die(34, this.name_)
        }
    }

    trackAndCompute(): boolean {
        // N.B: unminified as it is used by MST
        const oldValue = this.value_
        const wasSuspended =
            /* see #1208 */ this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
        const newValue = this.computeValue_(true)

        const changed =
            wasSuspended ||
            isCaughtException(oldValue) ||
            isCaughtException(newValue) ||
            !this.equals_(oldValue, newValue)

        if (changed) {
            this.value_ = newValue

            if (__DEV__ && isSpyEnabled()) {
                spyReport({
                    observableKind: "computed",
                    debugObjectName: this.name_,
                    object: this.scope_,
                    type: "update",
                    oldValue,
                    newValue
                } as IComputedDidChange)
            }
        }

        return changed
    }

    computeValue_(track: boolean) {
        this.isComputing = true
        // don't allow state changes during computation
        const prev = allowStateChangesStart(false)
        let res: T | CaughtException
        if (track) {
            res = trackDerivedFunction(this, this.derivation, this.scope_)
        } else {
            if (globalState.disableErrorBoundaries === true) {
                res = this.derivation.call(this.scope_)
            } else {
                try {
                    res = this.derivation.call(this.scope_)
                } catch (e) {
                    res = new CaughtException(e)
                }
            }
        }
        allowStateChangesEnd(prev)
        this.isComputing = false
        return res
    }

    suspend_() {
        if (!this.keepAlive_) {
            clearObserving(this)
            this.value_ = undefined // don't hold on to computed value!
            if (__DEV__ && this.isTracing_ !== TraceMode.NONE) {
                console.log(
                    `[mobx.trace] Computed value '${this.name_}' was suspended and it will recompute on the next access.`
                )
            }
        }
    }

    observe_(listener: (change: IComputedDidChange<T>) => void, fireImmediately?: boolean): Lambda {
        let firstTime = true
        let prevValue: T | undefined = undefined
        return autorun(() => {
            // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
            let newValue = this.get()
            if (!firstTime || fireImmediately) {
                const prevU = untrackedStart()
                listener({
                    observableKind: "computed",
                    debugObjectName: this.name_,
                    type: UPDATE,
                    object: this,
                    newValue,
                    oldValue: prevValue
                })
                untrackedEnd(prevU)
            }
            firstTime = false
            prevValue = newValue
        })
    }

    warnAboutUntrackedRead_() {
        if (!__DEV__) {
            return
        }
        if (this.isTracing_ !== TraceMode.NONE) {
            console.log(
                `[mobx.trace] Computed value '${this.name_}' is being read outside a reactive context. Doing a full recompute.`
            )
        }
        if (
            typeof this.requiresReaction_ === "boolean"
                ? this.requiresReaction_
                : globalState.computedRequiresReaction
        ) {
            console.warn(
                `[mobx] Computed value '${this.name_}' is being read outside a reactive context. Doing a full recompute.`
            )
        }
    }

    toString() {
        return `${this.name_}[${this.derivation.toString()}]`
    }

    valueOf(): T {
        return toPrimitive(this.get())
    }

    [Symbol.toPrimitive]() {
        return this.valueOf()
    }
}

export const isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue)



================================================
FILE: packages/mobx/src/core/derivation.ts
================================================
import {
    IAtom,
    IDepTreeNode,
    IObservable,
    addObserver,
    globalState,
    isComputedValue,
    removeObserver
} from "../internal"

export enum IDerivationState_ {
    // before being run or (outside batch and not being observed)
    // at this point derivation is not holding any data about dependency tree
    NOT_TRACKING_ = -1,
    // no shallow dependency changed since last computation
    // won't recalculate derivation
    // this is what makes mobx fast
    UP_TO_DATE_ = 0,
    // some deep dependency changed, but don't know if shallow dependency changed
    // will require to check first if UP_TO_DATE or POSSIBLY_STALE
    // currently only ComputedValue will propagate POSSIBLY_STALE
    //
    // having this state is second big optimization:
    // don't have to recompute on every dependency change, but only when it's needed
    POSSIBLY_STALE_ = 1,
    // A shallow dependency has changed since last computation and the derivation
    // will need to recompute when it's needed next.
    STALE_ = 2
}

export enum TraceMode {
    NONE,
    LOG,
    BREAK
}

/**
 * A derivation is everything that can be derived from the state (all the atoms) in a pure manner.
 * See https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 */
export interface IDerivation extends IDepTreeNode {
    observing_: IObservable[]
    newObserving_: null | IObservable[]
    dependenciesState_: IDerivationState_
    /**
     * Id of the current run of a derivation. Each time the derivation is tracked
     * this number is increased by one. This number is globally unique
     */
    runId_: number
    /**
     * amount of dependencies used by the derivation in this run, which has not been bound yet.
     */
    unboundDepsCount_: number
    onBecomeStale_(): void
    isTracing_: TraceMode

    /**
     *  warn if the derivation has no dependencies after creation/update
     */
    requiresObservable_?: boolean
}

export class CaughtException {
    constructor(public cause: any) {
        // Empty
    }
}

export function isCaughtException(e: any): e is CaughtException {
    return e instanceof CaughtException
}

/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */
export function shouldCompute(derivation: IDerivation): boolean {
    switch (derivation.dependenciesState_) {
        case IDerivationState_.UP_TO_DATE_:
            return false
        case IDerivationState_.NOT_TRACKING_:
        case IDerivationState_.STALE_:
            return true
        case IDerivationState_.POSSIBLY_STALE_: {
            // state propagation can occur outside of action/reactive context #2195
            const prevAllowStateReads = allowStateReadsStart(true)
            const prevUntracked = untrackedStart() // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
            const obs = derivation.observing_,
                l = obs.length
            for (let i = 0; i < l; i++) {
                const obj = obs[i]
                if (isComputedValue(obj)) {
                    if (globalState.disableErrorBoundaries) {
                        obj.get()
                    } else {
                        try {
                            obj.get()
                        } catch (e) {
                            // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                            untrackedEnd(prevUntracked)
                            allowStateReadsEnd(prevAllowStateReads)
                            return true
                        }
                    }
                    // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
                    // and `derivation` is an observer of `obj`
                    // invariantShouldCompute(derivation)
                    if ((derivation.dependenciesState_ as any) === IDerivationState_.STALE_) {
                        untrackedEnd(prevUntracked)
                        allowStateReadsEnd(prevAllowStateReads)
                        return true
                    }
                }
            }
            changeDependenciesStateTo0(derivation)
            untrackedEnd(prevUntracked)
            allowStateReadsEnd(prevAllowStateReads)
            return false
        }
    }
}

export function isComputingDerivation() {
    return globalState.trackingDerivation !== null // filter out actions inside computations
}

export function checkIfStateModificationsAreAllowed(atom: IAtom) {
    if (!__DEV__) {
        return
    }
    const hasObservers = atom.observers_.size > 0
    // Should not be possible to change observed state outside strict mode, except during initialization, see #563
    if (
        !globalState.allowStateChanges &&
        (hasObservers || globalState.enforceActions === "always")
    ) {
        console.warn(
            "[MobX] " +
                (globalState.enforceActions
                    ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: "
                    : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") +
                atom.name_
        )
    }
}

export function checkIfStateReadsAreAllowed(observable: IObservable) {
    if (__DEV__ && !globalState.allowStateReads && globalState.observableRequiresReaction) {
        console.warn(
            `[mobx] Observable '${observable.name_}' being read outside a reactive context.`
        )
    }
}

/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */
export function trackDerivedFunction<T>(derivation: IDerivation, f: () => T, context: any) {
    const prevAllowStateReads = allowStateReadsStart(true)
    changeDependenciesStateTo0(derivation)
    // Preallocate array; will be trimmed by bindDependencies.
    derivation.newObserving_ = new Array(
        // Reserve constant space for initial dependencies, dynamic space otherwise.
        // See https://github.com/mobxjs/mobx/pull/3833
        derivation.runId_ === 0 ? 100 : derivation.observing_.length
    )
    derivation.unboundDepsCount_ = 0
    derivation.runId_ = ++globalState.runId
    const prevTracking = globalState.trackingDerivation
    globalState.trackingDerivation = derivation
    globalState.inBatch++
    let result
    if (globalState.disableErrorBoundaries === true) {
        result = f.call(context)
    } else {
        try {
            result = f.call(context)
        } catch (e) {
            result = new CaughtException(e)
        }
    }
    globalState.inBatch--
    globalState.trackingDerivation = prevTracking
    bindDependencies(derivation)

    warnAboutDerivationWithoutDependencies(derivation)
    allowStateReadsEnd(prevAllowStateReads)
    return result
}

function warnAboutDerivationWithoutDependencies(derivation: IDerivation) {
    if (!__DEV__) {
        return
    }

    if (derivation.observing_.length !== 0) {
        return
    }

    if (
        typeof derivation.requiresObservable_ === "boolean"
            ? derivation.requiresObservable_
            : globalState.reactionRequiresObservable
    ) {
        console.warn(
            `[mobx] Derivation '${derivation.name_}' is created/updated without reading any observable value.`
        )
    }
}

/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */
function bindDependencies(derivation: IDerivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    const prevObserving = derivation.observing_
    const observing = (derivation.observing_ = derivation.newObserving_!)
    let lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_

    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    let i0 = 0,
        l = derivation.unboundDepsCount_
    for (let i = 0; i < l; i++) {
        const dep = observing[i]
        if (dep.diffValue === 0) {
            dep.diffValue = 1
            if (i0 !== i) {
                observing[i0] = dep
            }
            i0++
        }

        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if ((dep as any as IDerivation).dependenciesState_ > lowestNewObservingDerivationState) {
            lowestNewObservingDerivationState = (dep as any as IDerivation).dependenciesState_
        }
    }
    observing.length = i0

    derivation.newObserving_ = null // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)

    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    l = prevObserving.length
    while (l--) {
        const dep = prevObserving[l]
        if (dep.diffValue === 0) {
            removeObserver(dep, derivation)
        }
        dep.diffValue = 0
    }

    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    while (i0--) {
        const dep = observing[i0]
        if (dep.diffValue === 1) {
            dep.diffValue = 0
            addObserver(dep, derivation)
        }
    }

    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
        derivation.dependenciesState_ = lowestNewObservingDerivationState
        derivation.onBecomeStale_()
    }
}

export function clearObserving(derivation: IDerivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
    const obs = derivation.observing_
    derivation.observing_ = []
    let i = obs.length
    while (i--) {
        removeObserver(obs[i], derivation)
    }

    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_
}

export function untracked<T>(action: () => T): T {
    const prev = untrackedStart()
    try {
        return action()
    } finally {
        untrackedEnd(prev)
    }
}

export function untrackedStart(): IDerivation | null {
    const prev = globalState.trackingDerivation
    globalState.trackingDerivation = null
    return prev
}

export function untrackedEnd(prev: IDerivation | null) {
    globalState.trackingDerivation = prev
}

export function allowStateReadsStart(allowStateReads: boolean) {
    const prev = globalState.allowStateReads
    globalState.allowStateReads = allowStateReads
    return prev
}

export function allowStateReadsEnd(prev: boolean) {
    globalState.allowStateReads = prev
}

/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */
export function changeDependenciesStateTo0(derivation: IDerivation) {
    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        return
    }
    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_

    const obs = derivation.observing_
    let i = obs.length
    while (i--) {
        obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_
    }
}



================================================
FILE: packages/mobx/src/core/globalstate.ts
================================================
import { IDerivation, IObservable, Reaction, die, getGlobal } from "../internal"
import { ComputedValue } from "./computedvalue"

/**
 * These values will persist if global state is reset
 */
const persistentKeys: (keyof MobXGlobals)[] = [
    "mobxGuid",
    "spyListeners",
    "enforceActions",
    "computedRequiresReaction",
    "reactionRequiresObservable",
    "observableRequiresReaction",
    "allowStateReads",
    "disableErrorBoundaries",
    "runId",
    "UNCHANGED",
    "useProxies"
]

export type IUNCHANGED = {}

export class MobXGlobals {
    /**
     * MobXGlobals version.
     * MobX compatiblity with other versions loaded in memory as long as this version matches.
     * It indicates that the global state still stores similar information
     *
     * N.B: this version is unrelated to the package version of MobX, and is only the version of the
     * internal state storage of MobX, and can be the same across many different package versions
     */
    version = 6

    /**
     * globally unique token to signal unchanged
     */
    UNCHANGED: IUNCHANGED = {}

    /**
     * Currently running derivation
     */
    trackingDerivation: IDerivation | null = null

    /**
     * Currently running reaction. This determines if we currently have a reactive context.
     * (Tracking derivation is also set for temporal tracking of computed values inside actions,
     * but trackingReaction can only be set by a form of Reaction)
     */
    trackingContext: Reaction | ComputedValue<any> | null = null

    /**
     * Each time a derivation is tracked, it is assigned a unique run-id
     */
    runId = 0

    /**
     * 'guid' for general purpose. Will be persisted amongst resets.
     */
    mobxGuid = 0

    /**
     * Are we in a batch block? (and how many of them)
     */
    inBatch: number = 0

    /**
     * Observables that don't have observers anymore, and are about to be
     * suspended, unless somebody else accesses it in the same batch
     *
     * @type {IObservable[]}
     */
    pendingUnobservations: IObservable[] = []

    /**
     * List of scheduled, not yet executed, reactions.
     */
    pendingReactions: Reaction[] = []

    /**
     * Are we currently processing reactions?
     */
    isRunningReactions = false

    /**
     * Is it allowed to change observables at this point?
     * In general, MobX doesn't allow that when running computations and React.render.
     * To ensure that those functions stay pure.
     */
    allowStateChanges = false

    /**
     * Is it allowed to read observables at this point?
     * Used to hold the state needed for `observableRequiresReaction`
     */
    allowStateReads = true

    /**
     * If strict mode is enabled, state changes are by default not allowed
     */
    enforceActions: boolean | "always" = true

    /**
     * Spy callbacks
     */
    spyListeners: { (change: any): void }[] = []

    /**
     * Globally attached error handlers that react specifically to errors in reactions
     */
    globalReactionErrorHandlers: ((error: any, derivation: IDerivation) => void)[] = []

    /**
     * Warn if computed values are accessed outside a reactive context
     */
    computedRequiresReaction = false

    /**
     * (Experimental)
     * Warn if you try to create to derivation / reactive context without accessing any observable.
     */
    reactionRequiresObservable = false

    /**
     * (Experimental)
     * Warn if observables are accessed outside a reactive context
     */
    observableRequiresReaction = false

    /*
     * Don't catch and rethrow exceptions. This is useful for inspecting the state of
     * the stack when an exception occurs while debugging.
     */
    disableErrorBoundaries = false

    /*
     * If true, we are already handling an exception in an action. Any errors in reactions should be suppressed, as
     * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
     */
    suppressReactionErrors = false

    useProxies = true
    /*
     * print warnings about code that would fail if proxies weren't available
     */
    verifyProxies = false

    /**
     * False forces all object's descriptors to
     * writable: true
     * configurable: true
     */
    safeDescriptors = true
}

let canMergeGlobalState = true
let isolateCalled = false

export let globalState: MobXGlobals = (function () {
    let global = getGlobal()
    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {
        canMergeGlobalState = false
    }
    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {
        canMergeGlobalState = false
    }

    if (!canMergeGlobalState) {
        // Because this is a IIFE we need to let isolateCalled a chance to change
        // so we run it after the event loop completed at least 1 iteration
        setTimeout(() => {
            if (!isolateCalled) {
                die(35)
            }
        }, 1)
        return new MobXGlobals()
    } else if (global.__mobxGlobals) {
        global.__mobxInstanceCount += 1
        if (!global.__mobxGlobals.UNCHANGED) {
            global.__mobxGlobals.UNCHANGED = {}
        } // make merge backward compatible
        return global.__mobxGlobals
    } else {
        global.__mobxInstanceCount = 1
        return (global.__mobxGlobals = new MobXGlobals())
    }
})()

export function isolateGlobalState() {
    if (
        globalState.pendingReactions.length ||
        globalState.inBatch ||
        globalState.isRunningReactions
    ) {
        die(36)
    }
    isolateCalled = true
    if (canMergeGlobalState) {
        let global = getGlobal()
        if (--global.__mobxInstanceCount === 0) {
            global.__mobxGlobals = undefined
        }
        globalState = new MobXGlobals()
    }
}

export function getGlobalState(): any {
    return globalState
}

/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */
export function resetGlobalState() {
    const defaultGlobals = new MobXGlobals()
    for (let key in defaultGlobals) {
        if (persistentKeys.indexOf(key as any) === -1) {
            globalState[key] = defaultGlobals[key]
        }
    }
    globalState.allowStateChanges = !globalState.enforceActions
}



================================================
FILE: packages/mobx/src/core/observable.ts
================================================
import {
    Lambda,
    ComputedValue,
    IDependencyTree,
    IDerivation,
    IDerivationState_,
    TraceMode,
    getDependencyTree,
    globalState,
    runReactions,
    checkIfStateReadsAreAllowed
} from "../internal"

export interface IDepTreeNode {
    name_: string
    observing_?: IObservable[]
}

export interface IObservable extends IDepTreeNode {
    diffValue: number
    /**
     * Id of the derivation *run* that last accessed this observable.
     * If this id equals the *run* id of the current derivation,
     * the dependency is already established
     */
    lastAccessedBy_: number
    isBeingObserved: boolean

    lowestObserverState_: IDerivationState_ // Used to avoid redundant propagations
    isPendingUnobservation: boolean // Used to push itself to global.pendingUnobservations at most once per batch.

    observers_: Set<IDerivation>

    onBUO(): void
    onBO(): void

    onBUOL: Set<Lambda> | undefined
    onBOL: Set<Lambda> | undefined
}

export function hasObservers(observable: IObservable): boolean {
    return observable.observers_ && observable.observers_.size > 0
}

export function getObservers(observable: IObservable): Set<IDerivation> {
    return observable.observers_
}

// function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }
export function addObserver(observable: IObservable, node: IDerivation) {
    // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
    // invariantObservers(observable);

    observable.observers_.add(node)
    if (observable.lowestObserverState_ > node.dependenciesState_) {
        observable.lowestObserverState_ = node.dependenciesState_
    }

    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}

export function removeObserver(observable: IObservable, node: IDerivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
    // invariantObservers(observable);
    observable.observers_.delete(node)
    if (observable.observers_.size === 0) {
        // deleting last observer
        queueForUnobservation(observable)
    }
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}

export function queueForUnobservation(observable: IObservable) {
    if (observable.isPendingUnobservation === false) {
        // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
        observable.isPendingUnobservation = true
        globalState.pendingUnobservations.push(observable)
    }
}

/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */
export function startBatch() {
    globalState.inBatch++
}

export function endBatch() {
    if (--globalState.inBatch === 0) {
        runReactions()
        // the batch is actually about to finish, all unobserving should happen here.
        const list = globalState.pendingUnobservations
        for (let i = 0; i < list.length; i++) {
            const observable = list[i]
            observable.isPendingUnobservation = false
            if (observable.observers_.size === 0) {
                if (observable.isBeingObserved) {
                    // if this observable had reactive observers, trigger the hooks
                    observable.isBeingObserved = false
                    observable.onBUO()
                }
                if (observable instanceof ComputedValue) {
                    // computed values are automatically teared down when the last observer leaves
                    // this process happens recursively, this computed might be the last observabe of another, etc..
                    observable.suspend_()
                }
            }
        }
        globalState.pendingUnobservations = []
    }
}

export function reportObserved(observable: IObservable): boolean {
    checkIfStateReadsAreAllowed(observable)

    const derivation = globalState.trackingDerivation
    if (derivation !== null) {
        /**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */
        if (derivation.runId_ !== observable.lastAccessedBy_) {
            observable.lastAccessedBy_ = derivation.runId_
            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...
            derivation.newObserving_![derivation.unboundDepsCount_++] = observable
            if (!observable.isBeingObserved && globalState.trackingContext) {
                observable.isBeingObserved = true
                observable.onBO()
            }
        }
        return observable.isBeingObserved
    } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
        queueForUnobservation(observable)
    }

    return false
}

// function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */

// Called by Atom when its value changes
export function propagateChanged(observable: IObservable) {
    // invariantLOS(observable, "changed start");
    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
        return
    }
    observable.lowestObserverState_ = IDerivationState_.STALE_

    // Ideally we use for..of here, but the downcompiled version is really slow...
    observable.observers_.forEach(d => {
        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
            if (__DEV__ && d.isTracing_ !== TraceMode.NONE) {
                logTraceInfo(d, observable)
            }
            d.onBecomeStale_()
        }
        d.dependenciesState_ = IDerivationState_.STALE_
    })
    // invariantLOS(observable, "changed end");
}

// Called by ComputedValue when it recalculate and its value changed
export function propagateChangeConfirmed(observable: IObservable) {
    // invariantLOS(observable, "confirmed start");
    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
        return
    }
    observable.lowestObserverState_ = IDerivationState_.STALE_

    observable.observers_.forEach(d => {
        if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
            d.dependenciesState_ = IDerivationState_.STALE_
            if (__DEV__ && d.isTracing_ !== TraceMode.NONE) {
                logTraceInfo(d, observable)
            }
        } else if (
            d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
        ) {
            observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_
        }
    })
    // invariantLOS(observable, "confirmed end");
}

// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
export function propagateMaybeChanged(observable: IObservable) {
    // invariantLOS(observable, "maybe start");
    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
        return
    }
    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_

    observable.observers_.forEach(d => {
        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_
            d.onBecomeStale_()
        }
    })
    // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation: IDerivation, observable: IObservable) {
    console.log(
        `[mobx.trace] '${derivation.name_}' is invalidated due to a change in: '${observable.name_}'`
    )
    if (derivation.isTracing_ === TraceMode.BREAK) {
        const lines = []
        printDepTree(getDependencyTree(derivation), lines, 1)

        // prettier-ignore
        new Function(
`debugger;
/*
Tracing '${derivation.name_}'

You are entering this break point because derivation '${derivation.name_}' is being traced and '${observable.name_}' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

${derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : ""}

The dependencies for this derivation are:

${lines.join("\n")}
*/
    `)()
    }
}

function printDepTree(tree: IDependencyTree, lines: string[], depth: number) {
    if (lines.length >= 1000) {
        lines.push("(and many more)")
        return
    }
    lines.push(`${"\t".repeat(depth - 1)}${tree.name}`)
    if (tree.dependencies) {
        tree.dependencies.forEach(child => printDepTree(child, lines, depth + 1))
    }
}



================================================
FILE: packages/mobx/src/core/reaction.ts
================================================
import {
    $mobx,
    IDerivation,
    IDerivationState_,
    IObservable,
    Lambda,
    TraceMode,
    clearObserving,
    createInstanceofPredicate,
    endBatch,
    getNextId,
    globalState,
    isCaughtException,
    isSpyEnabled,
    shouldCompute,
    spyReport,
    spyReportEnd,
    spyReportStart,
    startBatch,
    trace,
    trackDerivedFunction,
    GenericAbortSignal
} from "../internal"

import { getFlag, setFlag } from "../utils/utils"

/**
 * Reactions are a special kind of derivations. Several things distinguishes them from normal reactive computations
 *
 * 1) They will always run, whether they are used by other computations or not.
 * This means that they are very suitable for triggering side effects like logging, updating the DOM and making network requests.
 * 2) They are not observable themselves
 * 3) They will always run after any 'normal' derivations
 * 4) They are allowed to change the state and thereby triggering themselves again, as long as they make sure the state propagates to a stable state in a reasonable amount of iterations.
 *
 * The state machine of a Reaction is as follows:
 *
 * 1) after creating, the reaction should be started by calling `runReaction` or by scheduling it (see also `autorun`)
 * 2) the `onInvalidate` handler should somehow result in a call to `this.track(someFunction)`
 * 3) all observables accessed in `someFunction` will be observed by this reaction.
 * 4) as soon as some of the dependencies has changed the Reaction will be rescheduled for another run (after the current mutation or transaction). `isScheduled` will yield true once a dependency is stale and during this period
 * 5) `onInvalidate` will be called, and we are back at step 1.
 *
 */

export interface IReactionPublic {
    dispose(): void
    trace(enterBreakPoint?: boolean): void
}

export interface IReactionDisposer {
    (): void
    [$mobx]: Reaction
}

export class Reaction implements IDerivation, IReactionPublic {
    observing_: IObservable[] = [] // nodes we are looking at. Our value depends on these nodes
    newObserving_: IObservable[] = []
    dependenciesState_ = IDerivationState_.NOT_TRACKING_
    runId_ = 0
    unboundDepsCount_ = 0

    private static readonly isDisposedMask_ = 0b00001
    private static readonly isScheduledMask_ = 0b00010
    private static readonly isTrackPendingMask_ = 0b00100
    private static readonly isRunningMask_ = 0b01000
    private static readonly diffValueMask_ = 0b10000
    private flags_ = 0b00000

    isTracing_: TraceMode = TraceMode.NONE

    constructor(
        public name_: string = __DEV__ ? "Reaction@" + getNextId() : "Reaction",
        private onInvalidate_: () => void,
        private errorHandler_?: (error: any, derivation: IDerivation) => void,
        public requiresObservable_?
    ) {}

    get isDisposed() {
        return getFlag(this.flags_, Reaction.isDisposedMask_)
    }
    set isDisposed(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Reaction.isDisposedMask_, newValue)
    }

    get isScheduled() {
        return getFlag(this.flags_, Reaction.isScheduledMask_)
    }
    set isScheduled(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Reaction.isScheduledMask_, newValue)
    }

    get isTrackPending() {
        return getFlag(this.flags_, Reaction.isTrackPendingMask_)
    }
    set isTrackPending(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Reaction.isTrackPendingMask_, newValue)
    }

    get isRunning() {
        return getFlag(this.flags_, Reaction.isRunningMask_)
    }
    set isRunning(newValue: boolean) {
        this.flags_ = setFlag(this.flags_, Reaction.isRunningMask_, newValue)
    }

    get diffValue(): 0 | 1 {
        return getFlag(this.flags_, Reaction.diffValueMask_) ? 1 : 0
    }
    set diffValue(newValue: 0 | 1) {
        this.flags_ = setFlag(this.flags_, Reaction.diffValueMask_, newValue === 1 ? true : false)
    }

    onBecomeStale_() {
        this.schedule_()
    }

    schedule_() {
        if (!this.isScheduled) {
            this.isScheduled = true
            globalState.pendingReactions.push(this)
            runReactions()
        }
    }

    /**
     * internal, use schedule() if you intend to kick off a reaction
     */
    runReaction_() {
        if (!this.isDisposed) {
            startBatch()
            this.isScheduled = false
            const prev = globalState.trackingContext
            globalState.trackingContext = this
            if (shouldCompute(this)) {
                this.isTrackPending = true

                try {
                    this.onInvalidate_()
                    if (__DEV__ && this.isTrackPending && isSpyEnabled()) {
                        // onInvalidate didn't trigger track right away..
                        spyReport({
                            name: this.name_,
                            type: "scheduled-reaction"
                        })
                    }
                } catch (e) {
                    this.reportExceptionInDerivation_(e)
                }
            }
            globalState.trackingContext = prev
            endBatch()
        }
    }

    track(fn: () => void) {
        if (this.isDisposed) {
            return
            // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
        }
        startBatch()
        const notify = isSpyEnabled()
        let startTime
        if (__DEV__ && notify) {
            startTime = Date.now()
            spyReportStart({
                name: this.name_,
                type: "reaction"
            })
        }
        this.isRunning = true
        const prevReaction = globalState.trackingContext // reactions could create reactions...
        globalState.trackingContext = this
        const result = trackDerivedFunction(this, fn, undefined)
        globalState.trackingContext = prevReaction
        this.isRunning = false
        this.isTrackPending = false
        if (this.isDisposed) {
            // disposed during last run. Clean up everything that was bound after the dispose call.
            clearObserving(this)
        }
        if (isCaughtException(result)) {
            this.reportExceptionInDerivation_(result.cause)
        }
        if (__DEV__ && notify) {
            spyReportEnd({
                time: Date.now() - startTime
            })
        }
        endBatch()
    }

    reportExceptionInDerivation_(error: any) {
        if (this.errorHandler_) {
            this.errorHandler_(error, this)
            return
        }

        if (globalState.disableErrorBoundaries) {
            throw error
        }

        const message = __DEV__
            ? `[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '${this}'`
            : `[mobx] uncaught error in '${this}'`
        if (!globalState.suppressReactionErrors) {
            console.error(message, error)
            /** If debugging brought you here, please, read the above message :-). Tnx! */
        } else if (__DEV__) { console.warn(`[mobx] (error in reaction '${this.name_}' suppressed, fix error of causing action below)`) } // prettier-ignore

        if (__DEV__ && isSpyEnabled()) {
            spyReport({
                type: "error",
                name: this.name_,
                message,
                error: "" + error
            })
        }

        globalState.globalReactionErrorHandlers.forEach(f => f(error, this))
    }

    dispose() {
        if (!this.isDisposed) {
            this.isDisposed = true
            if (!this.isRunning) {
                // if disposed while running, clean up later. Maybe not optimal, but rare case
                startBatch()
                clearObserving(this)
                endBatch()
            }
        }
    }

    getDisposer_(abortSignal?: GenericAbortSignal): IReactionDisposer {
        const dispose = (() => {
            this.dispose()
            abortSignal?.removeEventListener?.("abort", dispose)
        }) as IReactionDisposer
        abortSignal?.addEventListener?.("abort", dispose)
        dispose[$mobx] = this

        if ("dispose" in Symbol && typeof Symbol.dispose === "symbol") {
            dispose[Symbol.dispose] = dispose
        }

        return dispose
    }

    toString() {
        return `Reaction[${this.name_}]`
    }

    trace(enterBreakPoint: boolean = false) {
        trace(this, enterBreakPoint)
    }
}

export function onReactionError(handler: (error: any, derivation: IDerivation) => void): Lambda {
    globalState.globalReactionErrorHandlers.push(handler)
    return () => {
        const idx = globalState.globalReactionErrorHandlers.indexOf(handler)
        if (idx >= 0) {
            globalState.globalReactionErrorHandlers.splice(idx, 1)
        }
    }
}

/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */
const MAX_REACTION_ITERATIONS = 100

let reactionScheduler: (fn: () => void) => void = f => f()

export function runReactions() {
    // Trampolining, if runReactions are already running, new reactions will be picked up
    if (globalState.inBatch > 0 || globalState.isRunningReactions) {
        return
    }
    reactionScheduler(runReactionsHelper)
}

function runReactionsHelper() {
    globalState.isRunningReactions = true
    const allReactions = globalState.pendingReactions
    let iterations = 0

    // While running reactions, new reactions might be triggered.
    // Hence we work with two variables and check whether
    // we converge to no remaining reactions after a while.
    while (allReactions.length > 0) {
        if (++iterations === MAX_REACTION_ITERATIONS) {
            console.error(
                __DEV__
                    ? `Reaction doesn't converge to a stable state after ${MAX_REACTION_ITERATIONS} iterations.` +
                          ` Probably there is a cycle in the reactive function: ${allReactions[0]}`
                    : `[mobx] cycle in reaction: ${allReactions[0]}`
            )
            allReactions.splice(0) // clear reactions
        }
        let remainingReactions = allReactions.splice(0)
        for (let i = 0, l = remainingReactions.length; i < l; i++) {
            remainingReactions[i].runReaction_()
        }
    }
    globalState.isRunningReactions = false
}

export const isReaction = createInstanceofPredicate("Reaction", Reaction)

export function setReactionScheduler(fn: (f: () => void) => void) {
    const baseScheduler = reactionScheduler
    reactionScheduler = f => fn(() => baseScheduler(f))
}



================================================
FILE: packages/mobx/src/core/spy.ts
================================================
import { IComputedDidChange } from "./computedvalue"
import { IValueDidChange, IBoxDidChange } from "./../types/observablevalue"
import { IObjectDidChange } from "./../types/observableobject"
import { IArrayDidChange } from "./../types/observablearray"
import { Lambda, globalState, once, ISetDidChange, IMapDidChange } from "../internal"

export function isSpyEnabled() {
    return __DEV__ && !!globalState.spyListeners.length
}

export type PureSpyEvent =
    | { type: "action"; name: string; object: unknown; arguments: unknown[] }
    | { type: "scheduled-reaction"; name: string }
    | { type: "reaction"; name: string }
    | { type: "error"; name: string; message: string; error: string }
    | IComputedDidChange<unknown>
    | IObjectDidChange<unknown>
    | IArrayDidChange<unknown>
    | IMapDidChange<unknown, unknown>
    | ISetDidChange<unknown>
    | IValueDidChange<unknown>
    | IBoxDidChange<unknown>
    | { type: "report-end"; spyReportEnd: true; time?: number }

type SpyEvent = PureSpyEvent & { spyReportStart?: true }

export function spyReport(event: SpyEvent) {
    if (!__DEV__) {
        return
    } // dead code elimination can do the rest
    if (!globalState.spyListeners.length) {
        return
    }
    const listeners = globalState.spyListeners
    for (let i = 0, l = listeners.length; i < l; i++) {
        listeners[i](event)
    }
}

export function spyReportStart(event: PureSpyEvent) {
    if (!__DEV__) {
        return
    }
    const change = { ...event, spyReportStart: true as const }
    spyReport(change)
}

const END_EVENT: SpyEvent = { type: "report-end", spyReportEnd: true }

export function spyReportEnd(change?: { time?: number }) {
    if (!__DEV__) {
        return
    }
    if (change) {
        spyReport({ ...change, type: "report-end", spyReportEnd: true })
    } else {
        spyReport(END_EVENT)
    }
}

export function spy(listener: (change: SpyEvent) => void): Lambda {
    if (!__DEV__) {
        console.warn(`[mobx.spy] Is a no-op in production builds`)
        return function () {}
    } else {
        globalState.spyListeners.push(listener)
        return once(() => {
            globalState.spyListeners = globalState.spyListeners.filter(l => l !== listener)
        })
    }
}



================================================
FILE: packages/mobx/src/types/actionannotation.ts
================================================
import {
    ObservableObjectAdministration,
    createAction,
    isAction,
    defineProperty,
    die,
    isFunction,
    Annotation,
    globalState,
    MakeResult,
    assert20223DecoratorType
} from "../internal"

export function createActionAnnotation(name: string, options?: object): Annotation {
    return {
        annotationType_: name,
        options_: options,
        make_,
        extend_,
        decorate_20223_
    }
}

function make_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    source: object
): MakeResult {
    // bound
    if (this.options_?.bound) {
        return this.extend_(adm, key, descriptor, false) === null
            ? MakeResult.Cancel
            : MakeResult.Break
    }
    // own
    if (source === adm.target_) {
        return this.extend_(adm, key, descriptor, false) === null
            ? MakeResult.Cancel
            : MakeResult.Continue
    }
    // prototype
    if (isAction(descriptor.value)) {
        // A prototype could have been annotated already by other constructor,
        // rest of the proto chain must be annotated already
        return MakeResult.Break
    }
    const actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false)
    defineProperty(source, key, actionDescriptor)
    return MakeResult.Continue
}

function extend_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    proxyTrap: boolean
): boolean | null {
    const actionDescriptor = createActionDescriptor(adm, this, key, descriptor)
    return adm.defineProperty_(key, actionDescriptor, proxyTrap)
}

function decorate_20223_(this: Annotation, mthd, context: DecoratorContext) {
    if (__DEV__) {
        assert20223DecoratorType(context, ["method", "field"])
    }
    const { kind, name, addInitializer } = context
    const ann = this

    const _createAction = m =>
        createAction(ann.options_?.name ?? name!.toString(), m, ann.options_?.autoAction ?? false)

    if (kind == "field") {
        return function (initMthd) {
            let mthd = initMthd
            if (!isAction(mthd)) {
                mthd = _createAction(mthd)
            }
            if (ann.options_?.bound) {
                mthd = mthd.bind(this)
                mthd.isMobxAction = true
            }
            return mthd
        }
    }

    if (kind == "method") {
        if (!isAction(mthd)) {
            mthd = _createAction(mthd)
        }

        if (this.options_?.bound) {
            addInitializer(function () {
                const self = this as any
                const bound = self[name].bind(self)
                bound.isMobxAction = true
                self[name] = bound
            })
        }

        return mthd
    }

    die(
        `Cannot apply '${ann.annotationType_}' to '${String(name)}' (kind: ${kind}):` +
            `\n'${ann.annotationType_}' can only be used on properties with a function value.`
    )
}

function assertActionDescriptor(
    adm: ObservableObjectAdministration,
    { annotationType_ }: Annotation,
    key: PropertyKey,
    { value }: PropertyDescriptor
) {
    if (__DEV__ && !isFunction(value)) {
        die(
            `Cannot apply '${annotationType_}' to '${adm.name_}.${key.toString()}':` +
                `\n'${annotationType_}' can only be used on properties with a function value.`
        )
    }
}

export function createActionDescriptor(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    // provides ability to disable safeDescriptors for prototypes
    safeDescriptors: boolean = globalState.safeDescriptors
) {
    assertActionDescriptor(adm, annotation, key, descriptor)
    let { value } = descriptor
    if (annotation.options_?.bound) {
        value = value.bind(adm.proxy_ ?? adm.target_)
    }
    return {
        value: createAction(
            annotation.options_?.name ?? key.toString(),
            value,
            annotation.options_?.autoAction ?? false,
            // https://github.com/mobxjs/mobx/discussions/3140
            annotation.options_?.bound ? adm.proxy_ ?? adm.target_ : undefined
        ),
        // Non-configurable for classes
        // prevents accidental field redefinition in subclass
        configurable: safeDescriptors ? adm.isPlainObject_ : true,
        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
        enumerable: false,
        // Non-obsevable, therefore non-writable
        // Also prevents rewriting in subclass constructor
        writable: safeDescriptors ? false : true
    }
}



================================================
FILE: packages/mobx/src/types/autoannotation.ts
================================================
import {
    ObservableObjectAdministration,
    observable,
    Annotation,
    defineProperty,
    createAction,
    globalState,
    flow,
    computed,
    autoAction,
    isGenerator,
    MakeResult,
    die,
    isAction
} from "../internal"

const AUTO = "true"

export const autoAnnotation: Annotation = createAutoAnnotation()

export function createAutoAnnotation(options?: object): Annotation {
    return {
        annotationType_: AUTO,
        options_: options,
        make_,
        extend_,
        decorate_20223_
    }
}

function make_(
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    source: object
): MakeResult {
    // getter -> computed
    if (descriptor.get) {
        return computed.make_(adm, key, descriptor, source)
    }
    // lone setter -> action setter
    if (descriptor.set) {
        // TODO make action applicable to setter and delegate to action.make_
        const set = isAction(descriptor.set)
            ? descriptor.set // See #4553
            : (createAction(key.toString(), descriptor.set) as (v: any) => void)
        // own
        if (source === adm.target_) {
            return adm.defineProperty_(key, {
                configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
                set
            }) === null
                ? MakeResult.Cancel
                : MakeResult.Continue
        }
        // proto
        defineProperty(source, key, {
            configurable: true,
            set
        })
        return MakeResult.Continue
    }
    // function on proto -> autoAction/flow
    if (source !== adm.target_ && typeof descriptor.value === "function") {
        if (isGenerator(descriptor.value)) {
            const flowAnnotation = this.options_?.autoBind ? flow.bound : flow
            return flowAnnotation.make_(adm, key, descriptor, source)
        }
        const actionAnnotation = this.options_?.autoBind ? autoAction.bound : autoAction
        return actionAnnotation.make_(adm, key, descriptor, source)
    }
    // other -> observable
    // Copy props from proto as well, see test:
    // "decorate should work with Object.create"
    let observableAnnotation = this.options_?.deep === false ? observable.ref : observable
    // if function respect autoBind option
    if (typeof descriptor.value === "function" && this.options_?.autoBind) {
        descriptor.value = descriptor.value.bind(adm.proxy_ ?? adm.target_)
    }
    return observableAnnotation.make_(adm, key, descriptor, source)
}

function extend_(
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    proxyTrap: boolean
): boolean | null {
    // getter -> computed
    if (descriptor.get) {
        return computed.extend_(adm, key, descriptor, proxyTrap)
    }
    // lone setter -> action setter
    if (descriptor.set) {
        // TODO make action applicable to setter and delegate to action.extend_
        return adm.defineProperty_(
            key,
            {
                configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
                set: createAction(key.toString(), descriptor.set) as (v: any) => void
            },
            proxyTrap
        )
    }
    // other -> observable
    // if function respect autoBind option
    if (typeof descriptor.value === "function" && this.options_?.autoBind) {
        descriptor.value = descriptor.value.bind(adm.proxy_ ?? adm.target_)
    }
    let observableAnnotation = this.options_?.deep === false ? observable.ref : observable
    return observableAnnotation.extend_(adm, key, descriptor, proxyTrap)
}

function decorate_20223_(this: Annotation, desc, context: ClassGetterDecoratorContext) {
    die(`'${this.annotationType_}' cannot be used as a decorator`)
}



================================================
FILE: packages/mobx/src/types/computedannotation.ts
================================================
import {
    ObservableObjectAdministration,
    die,
    Annotation,
    MakeResult,
    assert20223DecoratorType,
    $mobx,
    asObservableObject,
    ComputedValue
} from "../internal"

export function createComputedAnnotation(name: string, options?: object): Annotation {
    return {
        annotationType_: name,
        options_: options,
        make_,
        extend_,
        decorate_20223_
    }
}

function make_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor
): MakeResult {
    return this.extend_(adm, key, descriptor, false) === null ? MakeResult.Cancel : MakeResult.Break
}

function extend_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    proxyTrap: boolean
): boolean | null {
    assertComputedDescriptor(adm, this, key, descriptor)
    return adm.defineComputedProperty_(
        key,
        {
            ...this.options_,
            get: descriptor.get,
            set: descriptor.set
        },
        proxyTrap
    )
}

function decorate_20223_(this: Annotation, get, context: ClassGetterDecoratorContext) {
    if (__DEV__) {
        assert20223DecoratorType(context, ["getter"])
    }
    const ann = this
    const { name: key, addInitializer } = context

    addInitializer(function () {
        const adm: ObservableObjectAdministration = asObservableObject(this)[$mobx]
        const options = {
            ...ann.options_,
            get,
            context: this
        }
        options.name ||= __DEV__
            ? `${adm.name_}.${key.toString()}`
            : `ObservableObject.${key.toString()}`
        adm.values_.set(key, new ComputedValue(options))
    })

    return function () {
        return this[$mobx].getObservablePropValue_(key)
    }
}

function assertComputedDescriptor(
    adm: ObservableObjectAdministration,
    { annotationType_ }: Annotation,
    key: PropertyKey,
    { get }: PropertyDescriptor
) {
    if (__DEV__ && !get) {
        die(
            `Cannot apply '${annotationType_}' to '${adm.name_}.${key.toString()}':` +
                `\n'${annotationType_}' can only be used on getter(+setter) properties.`
        )
    }
}



================================================
FILE: packages/mobx/src/types/decorator_fills.ts
================================================
// Hopefully these will be main-lined into Typescipt, but at the moment TS only declares the Contexts

export type ClassAccessorDecorator<This = any, Value = any> = (
    value: ClassAccessorDecoratorTarget<This, Value>,
    context: ClassAccessorDecoratorContext
) => ClassAccessorDecoratorResult<This, Value> | void

export type ClassGetterDecorator<This = any, Value = any> = (
    value: (this: This) => Value,
    context: ClassGetterDecoratorContext
) => ((this: This) => Value) | void

export type ClassSetterDecorator<This = any, Value = any> = (
    value: (this: This, value: Value) => void,
    context: ClassSetterDecoratorContext
) => ((this: This, value: Value) => void) | void

export type ClassMethodDecorator<This = any, Value extends (...p: any[]) => any = any> = (
    value: Value,
    context: ClassMethodDecoratorContext<This, Value>
) => Value | void

export type ClassFieldDecorator<This = any, Value extends (...p: any[]) => any = any> = (
    value: Value,
    context: ClassFieldDecoratorContext<This, Value>
) => Value | void

export type Decorator =
    | ClassAccessorDecorator
    | ClassGetterDecorator
    | ClassSetterDecorator
    | ClassMethodDecorator
    | ClassFieldDecorator



================================================
FILE: packages/mobx/src/types/dynamicobject.ts
================================================
import {
    $mobx,
    IIsObservableObject,
    ObservableObjectAdministration,
    warnAboutProxyRequirement,
    assertProxies,
    die,
    isStringish,
    globalState,
    CreateObservableOptions,
    asObservableObject
} from "../internal"

function getAdm(target): ObservableObjectAdministration {
    return target[$mobx]
}

// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!
const objectProxyTraps: ProxyHandler<any> = {
    has(target: IIsObservableObject, name: PropertyKey): boolean {
        if (__DEV__ && globalState.trackingDerivation) {
            warnAboutProxyRequirement(
                "detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."
            )
        }
        return getAdm(target).has_(name)
    },
    get(target: IIsObservableObject, name: PropertyKey): any {
        return getAdm(target).get_(name)
    },
    set(target: IIsObservableObject, name: PropertyKey, value: any): boolean {
        if (!isStringish(name)) {
            return false
        }
        if (__DEV__ && !getAdm(target).values_.has(name)) {
            warnAboutProxyRequirement(
                "add a new observable property through direct assignment. Use 'set' from 'mobx' instead."
            )
        }
        // null (intercepted) -> true (success)
        return getAdm(target).set_(name, value, true) ?? true
    },
    deleteProperty(target: IIsObservableObject, name: PropertyKey): boolean {
        if (__DEV__) {
            warnAboutProxyRequirement(
                "delete properties from an observable object. Use 'remove' from 'mobx' instead."
            )
        }
        if (!isStringish(name)) {
            return false
        }
        // null (intercepted) -> true (success)
        return getAdm(target).delete_(name, true) ?? true
    },
    defineProperty(
        target: IIsObservableObject,
        name: PropertyKey,
        descriptor: PropertyDescriptor
    ): boolean {
        if (__DEV__) {
            warnAboutProxyRequirement(
                "define property on an observable object. Use 'defineProperty' from 'mobx' instead."
            )
        }
        // null (intercepted) -> true (success)
        return getAdm(target).defineProperty_(name, descriptor) ?? true
    },
    ownKeys(target: IIsObservableObject): ArrayLike<string | symbol> {
        if (__DEV__ && globalState.trackingDerivation) {
            warnAboutProxyRequirement(
                "iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."
            )
        }
        return getAdm(target).ownKeys_()
    },
    preventExtensions(target) {
        die(13)
    }
}

export function asDynamicObservableObject(
    target: any,
    options?: CreateObservableOptions
): IIsObservableObject {
    assertProxies()
    target = asObservableObject(target, options)
    return (target[$mobx].proxy_ ??= new Proxy(target, objectProxyTraps))
}



================================================
FILE: packages/mobx/src/types/flowannotation.ts
================================================
import {
    ObservableObjectAdministration,
    Annotation,
    defineProperty,
    die,
    flow,
    isFlow,
    isFunction,
    globalState,
    MakeResult,
    hasProp,
    assert20223DecoratorType
} from "../internal"

export function createFlowAnnotation(name: string, options?: object): Annotation {
    return {
        annotationType_: name,
        options_: options,
        make_,
        extend_,
        decorate_20223_
    }
}

function make_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    source: object
): MakeResult {
    // own
    if (source === adm.target_) {
        return this.extend_(adm, key, descriptor, false) === null
            ? MakeResult.Cancel
            : MakeResult.Continue
    }
    // prototype
    // bound - must annotate protos to support super.flow()
    if (this.options_?.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
        if (this.extend_(adm, key, descriptor, false) === null) {
            return MakeResult.Cancel
        }
    }
    if (isFlow(descriptor.value)) {
        // A prototype could have been annotated already by other constructor,
        // rest of the proto chain must be annotated already
        return MakeResult.Break
    }
    const flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false)
    defineProperty(source, key, flowDescriptor)
    return MakeResult.Continue
}

function extend_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    proxyTrap: boolean
): boolean | null {
    const flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, this.options_?.bound)
    return adm.defineProperty_(key, flowDescriptor, proxyTrap)
}

function decorate_20223_(this: Annotation, mthd, context: ClassMethodDecoratorContext) {
    if (__DEV__) {
        assert20223DecoratorType(context, ["method"])
    }
    const { name, addInitializer } = context

    if (!isFlow(mthd)) {
        mthd = flow(mthd)
    }

    if (this.options_?.bound) {
        addInitializer(function () {
            const self = this as any
            const bound = self[name].bind(self)
            bound.isMobXFlow = true
            self[name] = bound
        })
    }

    return mthd
}

function assertFlowDescriptor(
    adm: ObservableObjectAdministration,
    { annotationType_ }: Annotation,
    key: PropertyKey,
    { value }: PropertyDescriptor
) {
    if (__DEV__ && !isFunction(value)) {
        die(
            `Cannot apply '${annotationType_}' to '${adm.name_}.${key.toString()}':` +
                `\n'${annotationType_}' can only be used on properties with a generator function value.`
        )
    }
}

function createFlowDescriptor(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    bound: boolean,
    // provides ability to disable safeDescriptors for prototypes
    safeDescriptors: boolean = globalState.safeDescriptors
): PropertyDescriptor {
    assertFlowDescriptor(adm, annotation, key, descriptor)
    let { value } = descriptor
    // In case of flow.bound, the descriptor can be from already annotated prototype
    if (!isFlow(value)) {
        value = flow(value)
    }
    if (bound) {
        // We do not keep original function around, so we bind the existing flow
        value = value.bind(adm.proxy_ ?? adm.target_)
        // This is normally set by `flow`, but `bind` returns new function...
        value.isMobXFlow = true
    }
    return {
        value,
        // Non-configurable for classes
        // prevents accidental field redefinition in subclass
        configurable: safeDescriptors ? adm.isPlainObject_ : true,
        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
        enumerable: false,
        // Non-obsevable, therefore non-writable
        // Also prevents rewriting in subclass constructor
        writable: safeDescriptors ? false : true
    }
}



================================================
FILE: packages/mobx/src/types/generic-abort-signal.ts
================================================
// https://github.com/mobxjs/mobx/issues/3582
export interface GenericAbortSignal {
    readonly aborted: boolean
    onabort?: ((...args: any) => any) | null
    addEventListener?: (...args: any) => any
    removeEventListener?: (...args: any) => any
}



================================================
FILE: packages/mobx/src/types/intercept-utils.ts
================================================
import { Lambda, once, untrackedEnd, untrackedStart, die } from "../internal"

export type IInterceptor<T> = (change: T) => T | null

export interface IInterceptable<T> {
    interceptors_: IInterceptor<T>[] | undefined
}

export function hasInterceptors(interceptable: IInterceptable<any>) {
    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0
}

export function registerInterceptor<T>(
    interceptable: IInterceptable<T>,
    handler: IInterceptor<T>
): Lambda {
    const interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = [])
    interceptors.push(handler)
    return once(() => {
        const idx = interceptors.indexOf(handler)
        if (idx !== -1) {
            interceptors.splice(idx, 1)
        }
    })
}

export function interceptChange<T>(
    interceptable: IInterceptable<T | null>,
    change: T | null
): T | null {
    const prevU = untrackedStart()
    try {
        // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
        const interceptors = [...(interceptable.interceptors_ || [])]
        for (let i = 0, l = interceptors.length; i < l; i++) {
            change = interceptors[i](change)
            if (change && !(change as any).type) {
                die(14)
            }
            if (!change) {
                break
            }
        }
        return change
    } finally {
        untrackedEnd(prevU)
    }
}



================================================
FILE: packages/mobx/src/types/legacyobservablearray.ts
================================================
import {
    getNextId,
    addHiddenFinalProp,
    makeIterable,
    addHiddenProp,
    ObservableArrayAdministration,
    $mobx,
    arrayExtensions,
    IEnhancer,
    isObservableArray,
    IObservableArray,
    defineProperty,
    initObservable
} from "../internal"

// Bug in safari 9.* (or iOS 9 safari mobile). See #364
const ENTRY_0 = createArrayEntryDescriptor(0)

const safariPrototypeSetterInheritanceBug = (() => {
    let v = false
    const p = {}
    Object.defineProperty(p, "0", {
        set: () => {
            v = true
        }
    })
    Object.create(p)["0"] = 1
    return v === false
})()

/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */
let OBSERVABLE_ARRAY_BUFFER_SIZE = 0

// Typescript workaround to make sure ObservableArray extends Array
class StubArray {}
function inherit(ctor, proto) {
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(ctor.prototype, proto)
    } else if (ctor.prototype.__proto__ !== undefined) {
        ctor.prototype.__proto__ = proto
    } else {
        ctor.prototype = proto
    }
}
inherit(StubArray, Array.prototype)

// Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

export class LegacyObservableArray<T> extends StubArray {
    constructor(
        initialValues: T[] | undefined,
        enhancer: IEnhancer<T>,
        name = __DEV__ ? "ObservableArray@" + getNextId() : "ObservableArray",
        owned = false
    ) {
        super()
        initObservable(() => {
            const adm = new ObservableArrayAdministration(name, enhancer, owned, true)
            adm.proxy_ = this as any
            addHiddenFinalProp(this, $mobx, adm)

            if (initialValues && initialValues.length) {
                // @ts-ignore
                this.spliceWithArray(0, 0, initialValues)
            }

            if (safariPrototypeSetterInheritanceBug) {
                // Seems that Safari won't use numeric prototype setter until any * numeric property is
                // defined on the instance. After that it works fine, even if this property is deleted.
                Object.defineProperty(this, "0", ENTRY_0)
            }
        })
    }

    concat(...arrays: T[][]): T[] {
        ;(this[$mobx] as ObservableArrayAdministration).atom_.reportObserved()
        return Array.prototype.concat.apply(
            (this as any).slice(),
            //@ts-ignore
            arrays.map(a => (isObservableArray(a) ? a.slice() : a))
        )
    }

    get length(): number {
        return (this[$mobx] as ObservableArrayAdministration).getArrayLength_()
    }

    set length(newLength: number) {
        ;(this[$mobx] as ObservableArrayAdministration).setArrayLength_(newLength)
    }

    get [Symbol.toStringTag]() {
        return "Array"
    }

    [Symbol.iterator]() {
        const self = this
        let nextIndex = 0
        return makeIterable({
            next() {
                return nextIndex < self.length
                    ? { value: self[nextIndex++], done: false }
                    : { done: true, value: undefined }
            }
        })
    }
}

Object.entries(arrayExtensions).forEach(([prop, fn]) => {
    if (prop !== "concat") {
        addHiddenProp(LegacyObservableArray.prototype, prop, fn)
    }
})

function createArrayEntryDescriptor(index: number) {
    return {
        enumerable: false,
        configurable: true,
        get: function () {
            return this[$mobx].get_(index)
        },
        set: function (value) {
            this[$mobx].set_(index, value)
        }
    }
}

function createArrayBufferItem(index: number) {
    defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index))
}

export function reserveArrayBuffer(max: number) {
    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
        for (let index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
            createArrayBufferItem(index)
        }
        OBSERVABLE_ARRAY_BUFFER_SIZE = max
    }
}

reserveArrayBuffer(1000)

export function createLegacyArray<T>(
    initialValues: T[] | undefined,
    enhancer: IEnhancer<T>,
    name?: string
): IObservableArray<T> {
    return new LegacyObservableArray(initialValues, enhancer, name) as any
}



================================================
FILE: packages/mobx/src/types/listen-utils.ts
================================================
import { Lambda, once, untrackedEnd, untrackedStart } from "../internal"

export interface IListenable {
    changeListeners_: Function[] | undefined
}

export function hasListeners(listenable: IListenable) {
    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0
}

export function registerListener(listenable: IListenable, handler: Function): Lambda {
    const listeners = listenable.changeListeners_ || (listenable.changeListeners_ = [])
    listeners.push(handler)
    return once(() => {
        const idx = listeners.indexOf(handler)
        if (idx !== -1) {
            listeners.splice(idx, 1)
        }
    })
}

export function notifyListeners<T>(listenable: IListenable, change: T) {
    const prevU = untrackedStart()
    let listeners = listenable.changeListeners_
    if (!listeners) {
        return
    }
    listeners = listeners.slice()
    for (let i = 0, l = listeners.length; i < l; i++) {
        listeners[i](change)
    }
    untrackedEnd(prevU)
}



================================================
FILE: packages/mobx/src/types/modifiers.ts
================================================
import {
    deepEqual,
    isES6Map,
    isES6Set,
    isObservable,
    isObservableArray,
    isObservableMap,
    isObservableSet,
    isObservableObject,
    isPlainObject,
    observable,
    die,
    isAction,
    autoAction,
    flow,
    isFlow,
    isGenerator
} from "../internal"

export interface IEnhancer<T> {
    (newValue: T, oldValue: T | undefined, name: string): T
}

export function deepEnhancer(v, _, name) {
    // it is an observable already, done
    if (isObservable(v)) {
        return v
    }

    // something that can be converted and mutated?
    if (Array.isArray(v)) {
        return observable.array(v, { name })
    }
    if (isPlainObject(v)) {
        return observable.object(v, undefined, { name })
    }
    if (isES6Map(v)) {
        return observable.map(v, { name })
    }
    if (isES6Set(v)) {
        return observable.set(v, { name })
    }
    if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
        if (isGenerator(v)) {
            return flow(v)
        } else {
            return autoAction(name, v)
        }
    }
    return v
}

export function shallowEnhancer(v, _, name): any {
    if (v === undefined || v === null) {
        return v
    }
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
        return v
    }
    if (Array.isArray(v)) {
        return observable.array(v, { name, deep: false })
    }
    if (isPlainObject(v)) {
        return observable.object(v, undefined, { name, deep: false })
    }
    if (isES6Map(v)) {
        return observable.map(v, { name, deep: false })
    }
    if (isES6Set(v)) {
        return observable.set(v, { name, deep: false })
    }

    if (__DEV__) {
        die(
            "The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets"
        )
    }
}

export function referenceEnhancer(newValue?) {
    // never turn into an observable
    return newValue
}

export function refStructEnhancer(v, oldValue): any {
    if (__DEV__ && isObservable(v)) {
        die(`observable.struct should not be used with observable values`)
    }
    if (deepEqual(v, oldValue)) {
        return oldValue
    }
    return v
}



================================================
FILE: packages/mobx/src/types/observableannotation.ts
================================================
import {
    ObservableObjectAdministration,
    deepEnhancer,
    die,
    Annotation,
    MakeResult,
    assert20223DecoratorType,
    ObservableValue,
    asObservableObject,
    $mobx
} from "../internal"

export function createObservableAnnotation(name: string, options?: object): Annotation {
    return {
        annotationType_: name,
        options_: options,
        make_,
        extend_,
        decorate_20223_
    }
}

function make_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor
): MakeResult {
    return this.extend_(adm, key, descriptor, false) === null ? MakeResult.Cancel : MakeResult.Break
}

function extend_(
    this: Annotation,
    adm: ObservableObjectAdministration,
    key: PropertyKey,
    descriptor: PropertyDescriptor,
    proxyTrap: boolean
): boolean | null {
    assertObservableDescriptor(adm, this, key, descriptor)
    return adm.defineObservableProperty_(
        key,
        descriptor.value,
        this.options_?.enhancer ?? deepEnhancer,
        proxyTrap
    )
}

function decorate_20223_(
    this: Annotation,
    desc,
    context: ClassAccessorDecoratorContext | ClassFieldDecoratorContext
) {
    if (__DEV__) {
        if (context.kind === "field") {
            throw die(
                `Please use \`@observable accessor ${String(
                    context.name
                )}\` instead of \`@observable ${String(context.name)}\``
            )
        }
        assert20223DecoratorType(context, ["accessor"])
    }

    const ann = this
    const { kind, name } = context

    // The laziness here is not ideal... It's a workaround to how 2022.3 Decorators are implemented:
    //   `addInitializer` callbacks are executed _before_ any accessors are defined (instead of the ideal-for-us right after each).
    //   This means that, if we were to do our stuff in an `addInitializer`, we'd attempt to read a private slot
    //   before it has been initialized. The runtime doesn't like that and throws a `Cannot read private member
    //   from an object whose class did not declare it` error.
    // TODO: it seems that this will not be required anymore in the final version of the spec
    // See TODO: link
    const initializedObjects = new WeakSet()

    function initializeObservable(target, value) {
        const adm: ObservableObjectAdministration = asObservableObject(target)[$mobx]
        const observable = new ObservableValue(
            value,
            ann.options_?.enhancer ?? deepEnhancer,
            __DEV__ ? `${adm.name_}.${name.toString()}` : `ObservableObject.${name.toString()}`,
            false
        )
        adm.values_.set(name, observable)
        initializedObjects.add(target)
    }

    if (kind == "accessor") {
        return {
            get() {
                if (!initializedObjects.has(this)) {
                    initializeObservable(this, desc.get.call(this))
                }
                return this[$mobx].getObservablePropValue_(name)
            },
            set(value) {
                if (!initializedObjects.has(this)) {
                    initializeObservable(this, value)
                }
                return this[$mobx].setObservablePropValue_(name, value)
            },
            init(value) {
                if (!initializedObjects.has(this)) {
                    initializeObservable(this, value)
                }
                return value
            }
        }
    }

    return
}

function assertObservableDescriptor(
    adm: ObservableObjectAdministration,
    { annotationType_ }: Annotation,
    key: PropertyKey,
    descriptor: PropertyDescriptor
) {
    if (__DEV__ && !("value" in descriptor)) {
        die(
            `Cannot apply '${annotationType_}' to '${adm.name_}.${key.toString()}':` +
                `\n'${annotationType_}' cannot be used on getter/setter properties`
        )
    }
}



================================================
FILE: packages/mobx/src/types/observablearray.ts
================================================
import {
    $mobx,
    Atom,
    EMPTY_ARRAY,
    IAtom,
    IEnhancer,
    IInterceptable,
    IInterceptor,
    IListenable,
    Lambda,
    addHiddenFinalProp,
    checkIfStateModificationsAreAllowed,
    createInstanceofPredicate,
    getNextId,
    hasInterceptors,
    hasListeners,
    interceptChange,
    isObject,
    isSpyEnabled,
    notifyListeners,
    registerInterceptor,
    registerListener,
    spyReportEnd,
    spyReportStart,
    assertProxies,
    reserveArrayBuffer,
    hasProp,
    die,
    globalState,
    initObservable
} from "../internal"

const SPLICE = "splice"
export const UPDATE = "update"
export const MAX_SPLICE_SIZE = 10000 // See e.g. https://github.com/mobxjs/mobx/issues/859

export interface IObservableArray<T = any> extends Array<T> {
    spliceWithArray(index: number, deleteCount?: number, newItems?: T[]): T[]
    clear(): T[]
    replace(newItems: T[]): T[]
    remove(value: T): boolean
    toJSON(): T[]
}

interface IArrayBaseChange<T> {
    object: IObservableArray<T>
    observableKind: "array"
    debugObjectName: string
    index: number
}

export type IArrayDidChange<T = any> = IArrayUpdate<T> | IArraySplice<T>

export interface IArrayUpdate<T = any> extends IArrayBaseChange<T> {
    type: "update"
    newValue: T
    oldValue: T
}

export interface IArraySplice<T = any> extends IArrayBaseChange<T> {
    type: "splice"
    added: T[]
    addedCount: number
    removed: T[]
    removedCount: number
}

export interface IArrayWillChange<T = any> {
    object: IObservableArray<T>
    index: number
    type: "update"
    newValue: T
}

export interface IArrayWillSplice<T = any> {
    object: IObservableArray<T>
    index: number
    type: "splice"
    added: T[]
    removedCount: number
}

const arrayTraps = {
    get(target, name) {
        const adm: ObservableArrayAdministration = target[$mobx]
        if (name === $mobx) {
            return adm
        }
        if (name === "length") {
            return adm.getArrayLength_()
        }
        if (typeof name === "string" && !isNaN(name as any)) {
            return adm.get_(parseInt(name))
        }
        if (hasProp(arrayExtensions, name)) {
            return arrayExtensions[name]
        }
        return target[name]
    },
    set(target, name, value): boolean {
        const adm: ObservableArrayAdministration = target[$mobx]
        if (name === "length") {
            adm.setArrayLength_(value)
        }
        if (typeof name === "symbol" || isNaN(name)) {
            target[name] = value
        } else {
            // numeric string
            adm.set_(parseInt(name), value)
        }
        return true
    },
    preventExtensions() {
        die(15)
    }
}

export class ObservableArrayAdministration
    implements IInterceptable<IArrayWillChange<any> | IArrayWillSplice<any>>, IListenable
{
    atom_: IAtom
    readonly values_: any[] = [] // this is the prop that gets proxied, so can't replace it!
    interceptors_
    changeListeners_
    enhancer_: (newV: any, oldV: any | undefined) => any
    dehancer: any
    proxy_!: IObservableArray<any>
    lastKnownLength_ = 0

    constructor(
        name = __DEV__ ? "ObservableArray@" + getNextId() : "ObservableArray",
        enhancer: IEnhancer<any>,
        public owned_: boolean,
        public legacyMode_: boolean
    ) {
        this.atom_ = new Atom(name)
        this.enhancer_ = (newV, oldV) =>
            enhancer(newV, oldV, __DEV__ ? name + "[..]" : "ObservableArray[..]")
    }

    dehanceValue_(value: any): any {
        if (this.dehancer !== undefined) {
            return this.dehancer(value)
        }
        return value
    }

    dehanceValues_(values: any[]): any[] {
        if (this.dehancer !== undefined && values.length > 0) {
            return values.map(this.dehancer) as any
        }
        return values
    }

    intercept_(handler: IInterceptor<IArrayWillChange<any> | IArrayWillSplice<any>>): Lambda {
        return registerInterceptor<IArrayWillChange<any> | IArrayWillSplice<any>>(this, handler)
    }

    observe_(
        listener: (changeData: IArrayDidChange<any>) => void,
        fireImmediately = false
    ): Lambda {
        if (fireImmediately) {
            listener(<IArraySplice<any>>{
                observableKind: "array",
                object: this.proxy_ as any,
                debugObjectName: this.atom_.name_,
                type: "splice",
                index: 0,
                added: this.values_.slice(),
                addedCount: this.values_.length,
                removed: [],
                removedCount: 0
            })
        }
        return registerListener(this, listener)
    }

    getArrayLength_(): number {
        this.atom_.reportObserved()
        return this.values_.length
    }

    setArrayLength_(newLength: number) {
        if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
            die("Out of range: " + newLength)
        }
        let currentLength = this.values_.length
        if (newLength === currentLength) {
            return
        } else if (newLength > currentLength) {
            const newItems = new Array(newLength - currentLength)
            for (let i = 0; i < newLength - currentLength; i++) {
                newItems[i] = undefined
            } // No Array.fill everywhere...
            this.spliceWithArray_(currentLength, 0, newItems)
        } else {
            this.spliceWithArray_(newLength, currentLength - newLength)
        }
    }

    updateArrayLength_(oldLength: number, delta: number) {
        if (oldLength !== this.lastKnownLength_) {
            die(16)
        }
        this.lastKnownLength_ += delta
        if (this.legacyMode_ && delta > 0) {
            reserveArrayBuffer(oldLength + delta + 1)
        }
    }

    spliceWithArray_(index: number, deleteCount?: number, newItems?: any[]): any[] {
        checkIfStateModificationsAreAllowed(this.atom_)
        const length = this.values_.length

        if (index === undefined) {
            index = 0
        } else if (index > length) {
            index = length
        } else if (index < 0) {
            index = Math.max(0, length + index)
        }

        if (arguments.length === 1) {
            deleteCount = length - index
        } else if (deleteCount === undefined || deleteCount === null) {
            deleteCount = 0
        } else {
            deleteCount = Math.max(0, Math.min(deleteCount, length - index))
        }

        if (newItems === undefined) {
            newItems = EMPTY_ARRAY
        }

        if (hasInterceptors(this)) {
            const change = interceptChange<IArrayWillSplice<any>>(this as any, {
                object: this.proxy_ as any,
                type: SPLICE,
                index,
                removedCount: deleteCount,
                added: newItems
            })
            if (!change) {
                return EMPTY_ARRAY
            }
            deleteCount = change.removedCount
            newItems = change.added
        }

        newItems =
            newItems.length === 0 ? newItems : newItems.map(v => this.enhancer_(v, undefined))
        if (this.legacyMode_ || __DEV__) {
            const lengthDelta = newItems.length - deleteCount
            this.updateArrayLength_(length, lengthDelta) // checks if internal array wasn't modified
        }
        const res = this.spliceItemsIntoValues_(index, deleteCount, newItems)

        if (deleteCount !== 0 || newItems.length !== 0) {
            this.notifyArraySplice_(index, newItems, res)
        }
        return this.dehanceValues_(res)
    }

    spliceItemsIntoValues_(index: number, deleteCount: number, newItems: any[]): any[] {
        if (newItems.length < MAX_SPLICE_SIZE) {
            return this.values_.splice(index, deleteCount, ...newItems)
        } else {
            // The items removed by the splice
            const res = this.values_.slice(index, index + deleteCount)
            // The items that that should remain at the end of the array
            let oldItems = this.values_.slice(index + deleteCount)
            // New length is the previous length + addition count - deletion count
            this.values_.length += newItems.length - deleteCount
            for (let i = 0; i < newItems.length; i++) {
                this.values_[index + i] = newItems[i]
            }
            for (let i = 0; i < oldItems.length; i++) {
                this.values_[index + newItems.length + i] = oldItems[i]
            }
            return res
        }
    }

    notifyArrayChildUpdate_(index: number, newValue: any, oldValue: any) {
        const notifySpy = !this.owned_ && isSpyEnabled()
        const notify = hasListeners(this)
        const change: IArrayDidChange | null =
            notify || notifySpy
                ? ({
                      observableKind: "array",
                      object: this.proxy_,
                      type: UPDATE,
                      debugObjectName: this.atom_.name_,
                      index,
                      newValue,
                      oldValue
                  } as const)
                : null

        // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
        // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled
        if (__DEV__ && notifySpy) {
            spyReportStart(change!)
        }
        this.atom_.reportChanged()
        if (notify) {
            notifyListeners(this, change)
        }
        if (__DEV__ && notifySpy) {
            spyReportEnd()
        }
    }

    notifyArraySplice_(index: number, added: any[], removed: any[]) {
        const notifySpy = !this.owned_ && isSpyEnabled()
        const notify = hasListeners(this)
        const change: IArraySplice | null =
            notify || notifySpy
                ? ({
                      observableKind: "array",
                      object: this.proxy_,
                      debugObjectName: this.atom_.name_,
                      type: SPLICE,
                      index,
                      removed,
                      added,
                      removedCount: removed.length,
                      addedCount: added.length
                  } as const)
                : null

        if (__DEV__ && notifySpy) {
            spyReportStart(change!)
        }
        this.atom_.reportChanged()
        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        if (notify) {
            notifyListeners(this, change)
        }
        if (__DEV__ && notifySpy) {
            spyReportEnd()
        }
    }

    get_(index: number): any | undefined {
        if (this.legacyMode_ && index >= this.values_.length) {
            console.warn(
                __DEV__
                    ? `[mobx.array] Attempt to read an array index (${index}) that is out of bounds (${this.values_.length}). Please check length first. Out of bound indices will not be tracked by MobX`
                    : `[mobx] Out of bounds read: ${index}`
            )
            return undefined
        }
        this.atom_.reportObserved()
        return this.dehanceValue_(this.values_[index])
    }

    set_(index: number, newValue: any) {
        const values = this.values_
        if (this.legacyMode_ && index > values.length) {
            // out of bounds
            die(17, index, values.length)
        }
        if (index < values.length) {
            // update at index in range
            checkIfStateModificationsAreAllowed(this.atom_)
            const oldValue = values[index]
            if (hasInterceptors(this)) {
                const change = interceptChange<IArrayWillChange<any>>(this as any, {
                    type: UPDATE,
                    object: this.proxy_ as any, // since "this" is the real array we need to pass its proxy
                    index,
                    newValue
                })
                if (!change) {
                    return
                }
                newValue = change.newValue
            }
            newValue = this.enhancer_(newValue, oldValue)
            const changed = newValue !== oldValue
            if (changed) {
                values[index] = newValue
                this.notifyArrayChildUpdate_(index, newValue, oldValue)
            }
        } else {
            // For out of bound index, we don't create an actual sparse array,
            // but rather fill the holes with undefined (same as setArrayLength_).
            // This could be considered a bug.
            const newItems = new Array(index + 1 - values.length)
            for (let i = 0; i < newItems.length - 1; i++) {
                newItems[i] = undefined
            } // No Array.fill everywhere...
            newItems[newItems.length - 1] = newValue
            this.spliceWithArray_(values.length, 0, newItems)
        }
    }
}

export function createObservableArray<T>(
    initialValues: T[] | undefined,
    enhancer: IEnhancer<T>,
    name = __DEV__ ? "ObservableArray@" + getNextId() : "ObservableArray",
    owned = false
): IObservableArray<T> {
    assertProxies()
    return initObservable(() => {
        const adm = new ObservableArrayAdministration(name, enhancer, owned, false)
        addHiddenFinalProp(adm.values_, $mobx, adm)
        const proxy = new Proxy(adm.values_, arrayTraps) as any
        adm.proxy_ = proxy
        if (initialValues && initialValues.length) {
            adm.spliceWithArray_(0, 0, initialValues)
        }
        return proxy
    })
}

// eslint-disable-next-line
export var arrayExtensions = {
    clear(): any[] {
        return this.splice(0)
    },

    replace(newItems: any[]) {
        const adm: ObservableArrayAdministration = this[$mobx]
        return adm.spliceWithArray_(0, adm.values_.length, newItems)
    },

    // Used by JSON.stringify
    toJSON(): any[] {
        return this.slice()
    },

    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    splice(index: number, deleteCount?: number, ...newItems: any[]): any[] {
        const adm: ObservableArrayAdministration = this[$mobx]
        switch (arguments.length) {
            case 0:
                return []
            case 1:
                return adm.spliceWithArray_(index)
            case 2:
                return adm.spliceWithArray_(index, deleteCount)
        }
        return adm.spliceWithArray_(index, deleteCount, newItems)
    },

    spliceWithArray(index: number, deleteCount?: number, newItems?: any[]): any[] {
        return (this[$mobx] as ObservableArrayAdministration).spliceWithArray_(
            index,
            deleteCount,
            newItems
        )
    },

    push(...items: any[]): number {
        const adm: ObservableArrayAdministration = this[$mobx]
        adm.spliceWithArray_(adm.values_.length, 0, items)
        return adm.values_.length
    },

    pop() {
        return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0]
    },

    shift() {
        return this.splice(0, 1)[0]
    },

    unshift(...items: any[]): number {
        const adm: ObservableArrayAdministration = this[$mobx]
        adm.spliceWithArray_(0, 0, items)
        return adm.values_.length
    },

    reverse(): any[] {
        // reverse by default mutates in place before returning the result
        // which makes it both a 'derivation' and a 'mutation'.
        if (globalState.trackingDerivation) {
            die(37, "reverse")
        }
        this.replace(this.slice().reverse())
        return this
    },

    sort(): any[] {
        // sort by default mutates in place before returning the result
        // which goes against all good practices. Let's not change the array in place!
        if (globalState.trackingDerivation) {
            die(37, "sort")
        }
        const copy = this.slice()
        copy.sort.apply(copy, arguments)
        this.replace(copy)
        return this
    },

    remove(value: any): boolean {
        const adm: ObservableArrayAdministration = this[$mobx]
        const idx = adm.dehanceValues_(adm.values_).indexOf(value)
        if (idx > -1) {
            this.splice(idx, 1)
            return true
        }
        return false
    }
}

/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */
addArrayExtension("at", simpleFunc)
addArrayExtension("concat", simpleFunc)
addArrayExtension("flat", simpleFunc)
addArrayExtension("includes", simpleFunc)
addArrayExtension("indexOf", simpleFunc)
addArrayExtension("join", simpleFunc)
addArrayExtension("lastIndexOf", simpleFunc)
addArrayExtension("slice", simpleFunc)
addArrayExtension("toString", simpleFunc)
addArrayExtension("toLocaleString", simpleFunc)
addArrayExtension("toSorted", simpleFunc)
addArrayExtension("toSpliced", simpleFunc)
addArrayExtension("with", simpleFunc)
// map
addArrayExtension("every", mapLikeFunc)
addArrayExtension("filter", mapLikeFunc)
addArrayExtension("find", mapLikeFunc)
addArrayExtension("findIndex", mapLikeFunc)
addArrayExtension("findLast", mapLikeFunc)
addArrayExtension("findLastIndex", mapLikeFunc)
addArrayExtension("flatMap", mapLikeFunc)
addArrayExtension("forEach", mapLikeFunc)
addArrayExtension("map", mapLikeFunc)
addArrayExtension("some", mapLikeFunc)
addArrayExtension("toReversed", mapLikeFunc)
// reduce
addArrayExtension("reduce", reduceLikeFunc)
addArrayExtension("reduceRight", reduceLikeFunc)

function addArrayExtension(funcName, funcFactory) {
    if (typeof Array.prototype[funcName] === "function") {
        arrayExtensions[funcName] = funcFactory(funcName)
    }
}

// Report and delegate to dehanced array
function simpleFunc(funcName) {
    return function () {
        const adm: ObservableArrayAdministration = this[$mobx]
        adm.atom_.reportObserved()
        const dehancedValues = adm.dehanceValues_(adm.values_)
        return dehancedValues[funcName].apply(dehancedValues, arguments)
    }
}

// Make sure callbacks receive correct array arg #2326
function mapLikeFunc(funcName) {
    return function (callback, thisArg) {
        const adm: ObservableArrayAdministration = this[$mobx]
        adm.atom_.reportObserved()
        const dehancedValues = adm.dehanceValues_(adm.values_)
        return dehancedValues[funcName]((element, index) => {
            return callback.call(thisArg, element, index, this)
        })
    }
}

// Make sure callbacks receive correct array arg #2326
function reduceLikeFunc(funcName) {
    return function () {
        const adm: ObservableArrayAdministration = this[$mobx]
        adm.atom_.reportObserved()
        const dehancedValues = adm.dehanceValues_(adm.values_)
        // #2432 - reduce behavior depends on arguments.length
        const callback = arguments[0]
        arguments[0] = (accumulator, currentValue, index) => {
            return callback(accumulator, currentValue, index, this)
        }
        return dehancedValues[funcName].apply(dehancedValues, arguments)
    }
}

const isObservableArrayAdministration = createInstanceofPredicate(
    "ObservableArrayAdministration",
    ObservableArrayAdministration
)

export function isObservableArray(thing): thing is IObservableArray<any> {
    return isObject(thing) && isObservableArrayAdministration(thing[$mobx])
}



================================================
FILE: packages/mobx/src/types/observablemap.ts
================================================
import {
    $mobx,
    IEnhancer,
    IInterceptable,
    IInterceptor,
    IListenable,
    Lambda,
    ObservableValue,
    checkIfStateModificationsAreAllowed,
    createAtom,
    createInstanceofPredicate,
    makeIterable,
    deepEnhancer,
    getNextId,
    getPlainObjectKeys,
    hasInterceptors,
    hasListeners,
    interceptChange,
    isES6Map,
    isPlainES6Map,
    isPlainObject,
    isSpyEnabled,
    notifyListeners,
    referenceEnhancer,
    registerInterceptor,
    registerListener,
    spyReportEnd,
    spyReportStart,
    stringifyKey,
    transaction,
    untracked,
    onBecomeUnobserved,
    globalState,
    die,
    isFunction,
    UPDATE,
    IAtom,
    PureSpyEvent,
    initObservable
} from "../internal"

export interface IKeyValueMap<V = any> {
    [key: string]: V
}

export type IMapEntry<K = any, V = any> = [K, V]
export type IReadonlyMapEntry<K = any, V = any> = readonly [K, V]
export type IMapEntries<K = any, V = any> = IMapEntry<K, V>[]
export type IReadonlyMapEntries<K = any, V = any> = IReadonlyMapEntry<K, V>[]

export type IMapDidChange<K = any, V = any> = { observableKind: "map"; debugObjectName: string } & (
    | {
          object: ObservableMap<K, V>
          name: K // actual the key or index, but this is based on the ancient .observe proposal for consistency
          type: "update"
          newValue: V
          oldValue: V
      }
    | {
          object: ObservableMap<K, V>
          name: K
          type: "add"
          newValue: V
      }
    | {
          object: ObservableMap<K, V>
          name: K
          type: "delete"
          oldValue: V
      }
)

export interface IMapWillChange<K = any, V = any> {
    object: ObservableMap<K, V>
    type: "update" | "add" | "delete"
    name: K
    newValue?: V
}

const ObservableMapMarker = {}

export const ADD = "add"
export const DELETE = "delete"

export type IObservableMapInitialValues<K = any, V = any> =
    | IMapEntries<K, V>
    | IReadonlyMapEntries<K, V>
    | IKeyValueMap<V>
    | Map<K, V>

// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556
export class ObservableMap<K = any, V = any>
    implements Map<K, V>, IInterceptable<IMapWillChange<K, V>>, IListenable
{
    [$mobx] = ObservableMapMarker
    data_!: Map<K, ObservableValue<V>>
    hasMap_!: Map<K, ObservableValue<boolean>> // hasMap, not hashMap >-).
    keysAtom_!: IAtom
    interceptors_
    changeListeners_
    dehancer: any

    constructor(
        initialData?: IObservableMapInitialValues<K, V>,
        public enhancer_: IEnhancer<V> = deepEnhancer,
        public name_ = __DEV__ ? "ObservableMap@" + getNextId() : "ObservableMap"
    ) {
        if (!isFunction(Map)) {
            die(18)
        }
        initObservable(() => {
            this.keysAtom_ = createAtom(__DEV__ ? `${this.name_}.keys()` : "ObservableMap.keys()")
            this.data_ = new Map()
            this.hasMap_ = new Map()
            if (initialData) {
                this.merge(initialData)
            }
        })
    }

    private has_(key: K): boolean {
        return this.data_.has(key)
    }

    has(key: K): boolean {
        if (!globalState.trackingDerivation) {
            return this.has_(key)
        }

        let entry = this.hasMap_.get(key)
        if (!entry) {
            const newEntry = (entry = new ObservableValue(
                this.has_(key),
                referenceEnhancer,
                __DEV__ ? `${this.name_}.${stringifyKey(key)}?` : "ObservableMap.key?",
                false
            ))
            this.hasMap_.set(key, newEntry)
            onBecomeUnobserved(newEntry, () => this.hasMap_.delete(key))
        }

        return entry.get()
    }

    set(key: K, value: V) {
        const hasKey = this.has_(key)
        if (hasInterceptors(this)) {
            const change = interceptChange<IMapWillChange<K, V>>(this, {
                type: hasKey ? UPDATE : ADD,
                object: this,
                newValue: value,
                name: key
            })
            if (!change) {
                return this
            }
            value = change.newValue!
        }
        if (hasKey) {
            this.updateValue_(key, value)
        } else {
            this.addValue_(key, value)
        }
        return this
    }

    delete(key: K): boolean {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        if (hasInterceptors(this)) {
            const change = interceptChange<IMapWillChange<K, V>>(this, {
                type: DELETE,
                object: this,
                name: key
            })
            if (!change) {
                return false
            }
        }
        if (this.has_(key)) {
            const notifySpy = isSpyEnabled()
            const notify = hasListeners(this)
            const change: IMapDidChange<K, V> | null =
                notify || notifySpy
                    ? {
                          observableKind: "map",
                          debugObjectName: this.name_,
                          type: DELETE,
                          object: this,
                          oldValue: (<any>this.data_.get(key)).value_,
                          name: key
                      }
                    : null

            if (__DEV__ && notifySpy) {
                spyReportStart(change! as PureSpyEvent)
            } // TODO fix type
            transaction(() => {
                this.keysAtom_.reportChanged()
                this.hasMap_.get(key)?.setNewValue_(false)
                const observable = this.data_.get(key)!
                observable.setNewValue_(undefined as any)
                this.data_.delete(key)
            })
            if (notify) {
                notifyListeners(this, change)
            }
            if (__DEV__ && notifySpy) {
                spyReportEnd()
            }
            return true
        }
        return false
    }

    private updateValue_(key: K, newValue: V | undefined) {
        const observable = this.data_.get(key)!
        newValue = (observable as any).prepareNewValue_(newValue) as V
        if (newValue !== globalState.UNCHANGED) {
            const notifySpy = isSpyEnabled()
            const notify = hasListeners(this)
            const change: IMapDidChange<K, V> | null =
                notify || notifySpy
                    ? {
                          observableKind: "map",
                          debugObjectName: this.name_,
                          type: UPDATE,
                          object: this,
                          oldValue: (observable as any).value_,
                          name: key,
                          newValue
                      }
                    : null
            if (__DEV__ && notifySpy) {
                spyReportStart(change! as PureSpyEvent)
            } // TODO fix type
            observable.setNewValue_(newValue as V)
            if (notify) {
                notifyListeners(this, change)
            }
            if (__DEV__ && notifySpy) {
                spyReportEnd()
            }
        }
    }

    private addValue_(key: K, newValue: V) {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        transaction(() => {
            const observable = new ObservableValue(
                newValue,
                this.enhancer_,
                __DEV__ ? `${this.name_}.${stringifyKey(key)}` : "ObservableMap.key",
                false
            )
            this.data_.set(key, observable)
            newValue = (observable as any).value_ // value might have been changed
            this.hasMap_.get(key)?.setNewValue_(true)
            this.keysAtom_.reportChanged()
        })
        const notifySpy = isSpyEnabled()
        const notify = hasListeners(this)
        const change: IMapDidChange<K, V> | null =
            notify || notifySpy
                ? {
                      observableKind: "map",
                      debugObjectName: this.name_,
                      type: ADD,
                      object: this,
                      name: key,
                      newValue
                  }
                : null
        if (__DEV__ && notifySpy) {
            spyReportStart(change! as PureSpyEvent)
        } // TODO fix type
        if (notify) {
            notifyListeners(this, change)
        }
        if (__DEV__ && notifySpy) {
            spyReportEnd()
        }
    }

    get(key: K): V | undefined {
        if (this.has(key)) {
            return this.dehanceValue_(this.data_.get(key)!.get())
        }
        return this.dehanceValue_(undefined)
    }

    private dehanceValue_<X extends V | undefined>(value: X): X {
        if (this.dehancer !== undefined) {
            return this.dehancer(value)
        }
        return value
    }

    keys(): MapIterator<K> {
        this.keysAtom_.reportObserved()
        return this.data_.keys()
    }

    values(): MapIterator<V> {
        const self = this
        const keys = this.keys()
        return makeIterableForMap({
            next() {
                const { done, value } = keys.next()
                return {
                    done,
                    value: done ? (undefined as any) : self.get(value)
                }
            }
        })
    }

    entries(): MapIterator<IMapEntry<K, V>> {
        const self = this
        const keys = this.keys()
        return makeIterableForMap({
            next() {
                const { done, value } = keys.next()
                return {
                    done,
                    value: done ? (undefined as any) : ([value, self.get(value)!] as [K, V])
                }
            }
        })
    }

    [Symbol.iterator]() {
        return this.entries()
    }

    forEach(callback: (value: V, key: K, object: Map<K, V>) => void, thisArg?) {
        for (const [key, value] of this) {
            callback.call(thisArg, value, key, this)
        }
    }

    /** Merge another object into this object, returns this. */
    merge(other?: IObservableMapInitialValues<K, V>): ObservableMap<K, V> {
        if (isObservableMap(other)) {
            other = new Map(other)
        }
        transaction(() => {
            if (isPlainObject(other)) {
                getPlainObjectKeys(other).forEach((key: any) =>
                    this.set(key as K, (other as IKeyValueMap)[key])
                )
            } else if (Array.isArray(other)) {
                other.forEach(([key, value]) => this.set(key, value))
            } else if (isES6Map(other)) {
                if (!isPlainES6Map(other)) {
                    die(19, other)
                }
                other.forEach((value, key) => this.set(key, value))
            } else if (other !== null && other !== undefined) {
                die(20, other)
            }
        })
        return this
    }

    clear() {
        transaction(() => {
            untracked(() => {
                for (const key of this.keys()) {
                    this.delete(key)
                }
            })
        })
    }

    replace(values: IObservableMapInitialValues<K, V>): ObservableMap<K, V> {
        // Implementation requirements:
        // - respect ordering of replacement map
        // - allow interceptors to run and potentially prevent individual operations
        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
        // - note that result map may differ from replacement map due to the interceptors
        transaction(() => {
            // Convert to map so we can do quick key lookups
            const replacementMap = convertToMap(values)
            const orderedData = new Map()
            // Used for optimization
            let keysReportChangedCalled = false
            // Delete keys that don't exist in replacement map
            // if the key deletion is prevented by interceptor
            // add entry at the beginning of the result map
            for (const key of this.data_.keys()) {
                // Concurrently iterating/deleting keys
                // iterator should handle this correctly
                if (!replacementMap.has(key)) {
                    const deleted = this.delete(key)
                    // Was the key removed?
                    if (deleted) {
                        // _keysAtom.reportChanged() was already called
                        keysReportChangedCalled = true
                    } else {
                        // Delete prevented by interceptor
                        const value = this.data_.get(key)
                        orderedData.set(key, value)
                    }
                }
            }
            // Merge entries
            for (const [key, value] of replacementMap.entries()) {
                // We will want to know whether a new key is added
                const keyExisted = this.data_.has(key)
                // Add or update value
                this.set(key, value)
                // The addition could have been prevent by interceptor
                if (this.data_.has(key)) {
                    // The update could have been prevented by interceptor
                    // and also we want to preserve existing values
                    // so use value from _data map (instead of replacement map)
                    const value = this.data_.get(key)
                    orderedData.set(key, value)
                    // Was a new key added?
                    if (!keyExisted) {
                        // _keysAtom.reportChanged() was already called
                        keysReportChangedCalled = true
                    }
                }
            }
            // Check for possible key order change
            if (!keysReportChangedCalled) {
                if (this.data_.size !== orderedData.size) {
                    // If size differs, keys are definitely modified
                    this.keysAtom_.reportChanged()
                } else {
                    const iter1 = this.data_.keys()
                    const iter2 = orderedData.keys()
                    let next1 = iter1.next()
                    let next2 = iter2.next()
                    while (!next1.done) {
                        if (next1.value !== next2.value) {
                            this.keysAtom_.reportChanged()
                            break
                        }
                        next1 = iter1.next()
                        next2 = iter2.next()
                    }
                }
            }
            // Use correctly ordered map
            this.data_ = orderedData
        })
        return this
    }

    get size(): number {
        this.keysAtom_.reportObserved()
        return this.data_.size
    }

    toString(): string {
        return "[object ObservableMap]"
    }

    toJSON(): [K, V][] {
        return Array.from(this)
    }

    get [Symbol.toStringTag]() {
        return "Map"
    }

    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    observe_(listener: (changes: IMapDidChange<K, V>) => void, fireImmediately?: boolean): Lambda {
        if (__DEV__ && fireImmediately === true) {
            die("`observe` doesn't support fireImmediately=true in combination with maps.")
        }
        return registerListener(this, listener)
    }

    intercept_(handler: IInterceptor<IMapWillChange<K, V>>): Lambda {
        return registerInterceptor(this, handler)
    }
}

// eslint-disable-next-line
export var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap) as (
    thing: any
) => thing is ObservableMap<any, any>

function makeIterableForMap<T>(iterator: Iterator<T>): MapIterator<T> {
    iterator[Symbol.toStringTag] = "MapIterator"
    return makeIterable<T, BuiltinIteratorReturn>(iterator)
}

function convertToMap(dataStructure: any): Map<any, any> {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
        return dataStructure
    } else if (Array.isArray(dataStructure)) {
        return new Map(dataStructure)
    } else if (isPlainObject(dataStructure)) {
        const map = new Map()
        for (const key in dataStructure) {
            map.set(key, dataStructure[key])
        }
        return map
    } else {
        return die(21, dataStructure)
    }
}



================================================
FILE: packages/mobx/src/types/observableobject.ts
================================================
import {
    CreateObservableOptions,
    getAnnotationFromOptions,
    propagateChanged,
    isAnnotation,
    $mobx,
    Atom,
    Annotation,
    ComputedValue,
    IAtom,
    IComputedValueOptions,
    IEnhancer,
    IInterceptable,
    IListenable,
    Lambda,
    ObservableValue,
    addHiddenProp,
    createInstanceofPredicate,
    endBatch,
    getNextId,
    hasInterceptors,
    hasListeners,
    interceptChange,
    isObject,
    isPlainObject,
    isSpyEnabled,
    notifyListeners,
    referenceEnhancer,
    registerInterceptor,
    registerListener,
    spyReportEnd,
    spyReportStart,
    startBatch,
    stringifyKey,
    globalState,
    ADD,
    UPDATE,
    die,
    hasProp,
    getDescriptor,
    storedAnnotationsSymbol,
    ownKeys,
    isOverride,
    defineProperty,
    autoAnnotation,
    getAdministration,
    getDebugName,
    objectPrototype,
    MakeResult,
    checkIfStateModificationsAreAllowed
} from "../internal"

const descriptorCache = Object.create(null)

export type IObjectDidChange<T = any> = {
    observableKind: "object"
    name: PropertyKey
    object: T
    debugObjectName: string
} & (
    | {
          type: "add"
          newValue: any
      }
    | {
          type: "update"
          oldValue: any
          newValue: any
      }
    | {
          type: "remove"
          oldValue: any
      }
)

export type IObjectWillChange<T = any> =
    | {
          object: T
          type: "update" | "add"
          name: PropertyKey
          newValue: any
      }
    | {
          object: T
          type: "remove"
          name: PropertyKey
      }

const REMOVE = "remove"

export class ObservableObjectAdministration
    implements IInterceptable<IObjectWillChange>, IListenable
{
    keysAtom_: IAtom
    changeListeners_
    interceptors_
    proxy_: any
    isPlainObject_: boolean
    appliedAnnotations_?: object
    private pendingKeys_: undefined | Map<PropertyKey, ObservableValue<boolean>>

    constructor(
        public target_: any,
        public values_ = new Map<PropertyKey, ObservableValue<any> | ComputedValue<any>>(),
        public name_: string,
        // Used anytime annotation is not explicitely provided
        public defaultAnnotation_: Annotation = autoAnnotation
    ) {
        this.keysAtom_ = new Atom(__DEV__ ? `${this.name_}.keys` : "ObservableObject.keys")
        // Optimization: we use this frequently
        this.isPlainObject_ = isPlainObject(this.target_)
        if (__DEV__ && !isAnnotation(this.defaultAnnotation_)) {
            die(`defaultAnnotation must be valid annotation`)
        }
        if (__DEV__) {
            // Prepare structure for tracking which fields were already annotated
            this.appliedAnnotations_ = {}
        }
    }

    getObservablePropValue_(key: PropertyKey): any {
        return this.values_.get(key)!.get()
    }

    setObservablePropValue_(key: PropertyKey, newValue): boolean | null {
        const observable = this.values_.get(key)
        if (observable instanceof ComputedValue) {
            observable.set(newValue)
            return true
        }

        // intercept
        if (hasInterceptors(this)) {
            const change = interceptChange<IObjectWillChange>(this, {
                type: UPDATE,
                object: this.proxy_ || this.target_,
                name: key,
                newValue
            })
            if (!change) {
                return null
            }
            newValue = (change as any).newValue
        }
        newValue = (observable as any).prepareNewValue_(newValue)

        // notify spy & observers
        if (newValue !== globalState.UNCHANGED) {
            const notify = hasListeners(this)
            const notifySpy = __DEV__ && isSpyEnabled()
            const change: IObjectDidChange | null =
                notify || notifySpy
                    ? {
                          type: UPDATE,
                          observableKind: "object",
                          debugObjectName: this.name_,
                          object: this.proxy_ || this.target_,
                          oldValue: (observable as any).value_,
                          name: key,
                          newValue
                      }
                    : null

            if (__DEV__ && notifySpy) {
                spyReportStart(change!)
            }
            ;(observable as ObservableValue<any>).setNewValue_(newValue)
            if (notify) {
                notifyListeners(this, change)
            }
            if (__DEV__ && notifySpy) {
                spyReportEnd()
            }
        }
        return true
    }

    get_(key: PropertyKey): any {
        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
            // Key doesn't exist yet, subscribe for it in case it's added later
            this.has_(key)
        }
        return this.target_[key]
    }

    /**
     * @param {PropertyKey} key
     * @param {any} value
     * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
     * @param {boolean} proxyTrap whether it's called from proxy trap
     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
     */
    set_(key: PropertyKey, value: any, proxyTrap: boolean = false): boolean | null {
        // Don't use .has(key) - we care about own
        if (hasProp(this.target_, key)) {
            // Existing prop
            if (this.values_.has(key)) {
                // Observable (can be intercepted)
                return this.setObservablePropValue_(key, value)
            } else if (proxyTrap) {
                // Non-observable - proxy
                return Reflect.set(this.target_, key, value)
            } else {
                // Non-observable
                this.target_[key] = value
                return true
            }
        } else {
            // New prop
            return this.extend_(
                key,
                { value, enumerable: true, writable: true, configurable: true },
                this.defaultAnnotation_,
                proxyTrap
            )
        }
    }

    // Trap for "in"
    has_(key: PropertyKey): boolean {
        if (!globalState.trackingDerivation) {
            // Skip key subscription outside derivation
            return key in this.target_
        }
        this.pendingKeys_ ||= new Map()
        let entry = this.pendingKeys_.get(key)
        if (!entry) {
            entry = new ObservableValue(
                key in this.target_,
                referenceEnhancer,
                __DEV__ ? `${this.name_}.${stringifyKey(key)}?` : "ObservableObject.key?",
                false
            )
            this.pendingKeys_.set(key, entry)
        }
        return entry.get()
    }

    /**
     * @param {PropertyKey} key
     * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
     */
    make_(key: PropertyKey, annotation: Annotation | boolean): void {
        if (annotation === true) {
            annotation = this.defaultAnnotation_
        }
        if (annotation === false) {
            return
        }
        assertAnnotable(this, annotation, key)
        if (!(key in this.target_)) {
            // Throw on missing key, except for decorators:
            // Decorator annotations are collected from whole prototype chain.
            // When called from super() some props may not exist yet.
            // However we don't have to worry about missing prop,
            // because the decorator must have been applied to something.
            if (this.target_[storedAnnotationsSymbol]?.[key]) {
                return // will be annotated by subclass constructor
            } else {
                die(1, annotation.annotationType_, `${this.name_}.${key.toString()}`)
            }
        }
        let source = this.target_
        while (source && source !== objectPrototype) {
            const descriptor = getDescriptor(source, key)
            if (descriptor) {
                const outcome = annotation.make_(this, key, descriptor, source)
                if (outcome === MakeResult.Cancel) {
                    return
                }
                if (outcome === MakeResult.Break) {
                    break
                }
            }
            source = Object.getPrototypeOf(source)
        }
        recordAnnotationApplied(this, annotation, key)
    }

    /**
     * @param {PropertyKey} key
     * @param {PropertyDescriptor} descriptor
     * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
     * @param {boolean} proxyTrap whether it's called from proxy trap
     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
     */
    extend_(
        key: PropertyKey,
        descriptor: PropertyDescriptor,
        annotation: Annotation | boolean,
        proxyTrap: boolean = false
    ): boolean | null {
        if (annotation === true) {
            annotation = this.defaultAnnotation_
        }
        if (annotation === false) {
            return this.defineProperty_(key, descriptor, proxyTrap)
        }
        assertAnnotable(this, annotation, key)
        const outcome = annotation.extend_(this, key, descriptor, proxyTrap)
        if (outcome) {
            recordAnnotationApplied(this, annotation, key)
        }
        return outcome
    }

    /**
     * @param {PropertyKey} key
     * @param {PropertyDescriptor} descriptor
     * @param {boolean} proxyTrap whether it's called from proxy trap
     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
     */
    defineProperty_(
        key: PropertyKey,
        descriptor: PropertyDescriptor,
        proxyTrap: boolean = false
    ): boolean | null {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        try {
            startBatch()

            // Delete
            const deleteOutcome = this.delete_(key)
            if (!deleteOutcome) {
                // Failure or intercepted
                return deleteOutcome
            }

            // ADD interceptor
            if (hasInterceptors(this)) {
                const change = interceptChange<IObjectWillChange>(this, {
                    object: this.proxy_ || this.target_,
                    name: key,
                    type: ADD,
                    newValue: descriptor.value
                })
                if (!change) {
                    return null
                }
                const { newValue } = change as any
                if (descriptor.value !== newValue) {
                    descriptor = {
                        ...descriptor,
                        value: newValue
                    }
                }
            }

            // Define
            if (proxyTrap) {
                if (!Reflect.defineProperty(this.target_, key, descriptor)) {
                    return false
                }
            } else {
                defineProperty(this.target_, key, descriptor)
            }

            // Notify
            this.notifyPropertyAddition_(key, descriptor.value)
        } finally {
            endBatch()
        }
        return true
    }

    // If original descriptor becomes relevant, move this to annotation directly
    defineObservableProperty_(
        key: PropertyKey,
        value: any,
        enhancer: IEnhancer<any>,
        proxyTrap: boolean = false
    ): boolean | null {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        try {
            startBatch()

            // Delete
            const deleteOutcome = this.delete_(key)
            if (!deleteOutcome) {
                // Failure or intercepted
                return deleteOutcome
            }

            // ADD interceptor
            if (hasInterceptors(this)) {
                const change = interceptChange<IObjectWillChange>(this, {
                    object: this.proxy_ || this.target_,
                    name: key,
                    type: ADD,
                    newValue: value
                })
                if (!change) {
                    return null
                }
                value = (change as any).newValue
            }

            const cachedDescriptor = getCachedObservablePropDescriptor(key)
            const descriptor = {
                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
                enumerable: true,
                get: cachedDescriptor.get,
                set: cachedDescriptor.set
            }

            // Define
            if (proxyTrap) {
                if (!Reflect.defineProperty(this.target_, key, descriptor)) {
                    return false
                }
            } else {
                defineProperty(this.target_, key, descriptor)
            }

            const observable = new ObservableValue(
                value,
                enhancer,
                __DEV__ ? `${this.name_}.${key.toString()}` : "ObservableObject.key",
                false
            )

            this.values_.set(key, observable)

            // Notify (value possibly changed by ObservableValue)
            this.notifyPropertyAddition_(key, observable.value_)
        } finally {
            endBatch()
        }
        return true
    }

    // If original descriptor becomes relevant, move this to annotation directly
    defineComputedProperty_(
        key: PropertyKey,
        options: IComputedValueOptions<any>,
        proxyTrap: boolean = false
    ): boolean | null {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        try {
            startBatch()

            // Delete
            const deleteOutcome = this.delete_(key)
            if (!deleteOutcome) {
                // Failure or intercepted
                return deleteOutcome
            }

            // ADD interceptor
            if (hasInterceptors(this)) {
                const change = interceptChange<IObjectWillChange>(this, {
                    object: this.proxy_ || this.target_,
                    name: key,
                    type: ADD,
                    newValue: undefined
                })
                if (!change) {
                    return null
                }
            }
            options.name ||= __DEV__ ? `${this.name_}.${key.toString()}` : "ObservableObject.key"
            options.context = this.proxy_ || this.target_
            const cachedDescriptor = getCachedObservablePropDescriptor(key)
            const descriptor = {
                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
                enumerable: false,
                get: cachedDescriptor.get,
                set: cachedDescriptor.set
            }

            // Define
            if (proxyTrap) {
                if (!Reflect.defineProperty(this.target_, key, descriptor)) {
                    return false
                }
            } else {
                defineProperty(this.target_, key, descriptor)
            }

            this.values_.set(key, new ComputedValue(options))

            // Notify
            this.notifyPropertyAddition_(key, undefined)
        } finally {
            endBatch()
        }
        return true
    }

    /**
     * @param {PropertyKey} key
     * @param {PropertyDescriptor} descriptor
     * @param {boolean} proxyTrap whether it's called from proxy trap
     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
     */
    delete_(key: PropertyKey, proxyTrap: boolean = false): boolean | null {
        checkIfStateModificationsAreAllowed(this.keysAtom_)
        // No such prop
        if (!hasProp(this.target_, key)) {
            return true
        }

        // Intercept
        if (hasInterceptors(this)) {
            const change = interceptChange<IObjectWillChange>(this, {
                object: this.proxy_ || this.target_,
                name: key,
                type: REMOVE
            })
            // Cancelled
            if (!change) {
                return null
            }
        }

        // Delete
        try {
            startBatch()
            const notify = hasListeners(this)
            const notifySpy = __DEV__ && isSpyEnabled()
            const observable = this.values_.get(key)
            // Value needed for spies/listeners
            let value = undefined
            // Optimization: don't pull the value unless we will need it
            if (!observable && (notify || notifySpy)) {
                value = getDescriptor(this.target_, key)?.value
            }
            // delete prop (do first, may fail)
            if (proxyTrap) {
                if (!Reflect.deleteProperty(this.target_, key)) {
                    return false
                }
            } else {
                delete this.target_[key]
            }
            // Allow re-annotating this field
            if (__DEV__) {
                delete this.appliedAnnotations_![key]
            }
            // Clear observable
            if (observable) {
                this.values_.delete(key)
                // for computed, value is undefined
                if (observable instanceof ObservableValue) {
                    value = observable.value_
                }
                // Notify: autorun(() => obj[key]), see #1796
                propagateChanged(observable)
            }
            // Notify "keys/entries/values" observers
            this.keysAtom_.reportChanged()

            // Notify "has" observers
            // "in" as it may still exist in proto
            this.pendingKeys_?.get(key)?.set(key in this.target_)

            // Notify spies/listeners
            if (notify || notifySpy) {
                const change: IObjectDidChange = {
                    type: REMOVE,
                    observableKind: "object",
                    object: this.proxy_ || this.target_,
                    debugObjectName: this.name_,
                    oldValue: value,
                    name: key
                }
                if (__DEV__ && notifySpy) {
                    spyReportStart(change!)
                }
                if (notify) {
                    notifyListeners(this, change)
                }
                if (__DEV__ && notifySpy) {
                    spyReportEnd()
                }
            }
        } finally {
            endBatch()
        }
        return true
    }

    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    observe_(callback: (changes: IObjectDidChange) => void, fireImmediately?: boolean): Lambda {
        if (__DEV__ && fireImmediately === true) {
            die("`observe` doesn't support the fire immediately property for observable objects.")
        }
        return registerListener(this, callback)
    }

    intercept_(handler): Lambda {
        return registerInterceptor(this, handler)
    }

    notifyPropertyAddition_(key: PropertyKey, value: any) {
        const notify = hasListeners(this)
        const notifySpy = __DEV__ && isSpyEnabled()
        if (notify || notifySpy) {
            const change: IObjectDidChange | null =
                notify || notifySpy
                    ? ({
                          type: ADD,
                          observableKind: "object",
                          debugObjectName: this.name_,
                          object: this.proxy_ || this.target_,
                          name: key,
                          newValue: value
                      } as const)
                    : null

            if (__DEV__ && notifySpy) {
                spyReportStart(change!)
            }
            if (notify) {
                notifyListeners(this, change)
            }
            if (__DEV__ && notifySpy) {
                spyReportEnd()
            }
        }

        this.pendingKeys_?.get(key)?.set(true)

        // Notify "keys/entries/values" observers
        this.keysAtom_.reportChanged()
    }

    ownKeys_(): Array<string | symbol> {
        this.keysAtom_.reportObserved()
        return ownKeys(this.target_)
    }

    keys_(): PropertyKey[] {
        // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
        // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
        // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
        // We choose to over-report in Object.keys(object), because:
        // - typically it's used with simple data objects
        // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
        this.keysAtom_.reportObserved()
        return Object.keys(this.target_)
    }
}

export interface IIsObservableObject {
    [$mobx]: ObservableObjectAdministration
}

export function asObservableObject(
    target: any,
    options?: CreateObservableOptions
): IIsObservableObject {
    if (__DEV__ && options && isObservableObject(target)) {
        die(`Options can't be provided for already observable objects.`)
    }

    if (hasProp(target, $mobx)) {
        if (__DEV__ && !(getAdministration(target) instanceof ObservableObjectAdministration)) {
            die(
                `Cannot convert '${getDebugName(target)}' into observable object:` +
                    `\nThe target is already observable of different type.` +
                    `\nExtending builtins is not supported.`
            )
        }
        return target
    }

    if (__DEV__ && !Object.isExtensible(target)) {
        die("Cannot make the designated object observable; it is not extensible")
    }

    const name =
        options?.name ??
        (__DEV__
            ? `${
                  isPlainObject(target) ? "ObservableObject" : target.constructor.name
              }@${getNextId()}`
            : "ObservableObject")

    const adm = new ObservableObjectAdministration(
        target,
        new Map(),
        String(name),
        getAnnotationFromOptions(options)
    )

    addHiddenProp(target, $mobx, adm)

    return target
}

const isObservableObjectAdministration = createInstanceofPredicate(
    "ObservableObjectAdministration",
    ObservableObjectAdministration
)

function getCachedObservablePropDescriptor(key) {
    return (
        descriptorCache[key] ||
        (descriptorCache[key] = {
            get() {
                return this[$mobx].getObservablePropValue_(key)
            },
            set(value) {
                return this[$mobx].setObservablePropValue_(key, value)
            }
        })
    )
}

export function isObservableObject(thing: any): boolean {
    if (isObject(thing)) {
        return isObservableObjectAdministration((thing as any)[$mobx])
    }
    return false
}

export function recordAnnotationApplied(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey
) {
    if (__DEV__) {
        adm.appliedAnnotations_![key] = annotation
    }
    // Remove applied decorator annotation so we don't try to apply it again in subclass constructor
    delete adm.target_[storedAnnotationsSymbol]?.[key]
}

function assertAnnotable(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey
) {
    // Valid annotation
    if (__DEV__ && !isAnnotation(annotation)) {
        die(`Cannot annotate '${adm.name_}.${key.toString()}': Invalid annotation.`)
    }

    /*
    // Configurable, not sealed, not frozen
    // Possibly not needed, just a little better error then the one thrown by engine.
    // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
    if (__DEV__) {
        const configurable = getDescriptor(adm.target_, key)?.configurable
        const frozen = Object.isFrozen(adm.target_)
        const sealed = Object.isSealed(adm.target_)
        if (!configurable || frozen || sealed) {
            const fieldName = `${adm.name_}.${key.toString()}`
            const requestedAnnotationType = annotation.annotationType_
            let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
            if (frozen) {
                error += `\nObject is frozen.`
            }
            if (sealed) {
                error += `\nObject is sealed.`
            }
            if (!configurable) {
                error += `\nproperty is not configurable.`
                // Mention only if caused by us to avoid confusion
                if (hasProp(adm.appliedAnnotations!, key)) {
                    error += `\nTo prevent accidental re-definition of a field by a subclass, `
                    error += `all annotated fields of non-plain objects (classes) are not configurable.`
                }
            }
            die(error)
        }
    }
    */

    // Not annotated
    if (__DEV__ && !isOverride(annotation) && hasProp(adm.appliedAnnotations_!, key)) {
        const fieldName = `${adm.name_}.${key.toString()}`
        const currentAnnotationType = adm.appliedAnnotations_![key].annotationType_
        const requestedAnnotationType = annotation.annotationType_
        die(
            `Cannot apply '${requestedAnnotationType}' to '${fieldName}':` +
                `\nThe field is already annotated with '${currentAnnotationType}'.` +
                `\nRe-annotating fields is not allowed.` +
                `\nUse 'override' annotation for methods overridden by subclass.`
        )
    }
}



================================================
FILE: packages/mobx/src/types/observableset.ts
================================================
import {
    $mobx,
    createAtom,
    deepEnhancer,
    getNextId,
    IEnhancer,
    isSpyEnabled,
    hasListeners,
    IListenable,
    registerListener,
    Lambda,
    spyReportStart,
    notifyListeners,
    spyReportEnd,
    createInstanceofPredicate,
    makeIterable,
    hasInterceptors,
    interceptChange,
    IInterceptable,
    IInterceptor,
    registerInterceptor,
    checkIfStateModificationsAreAllowed,
    untracked,
    transaction,
    isES6Set,
    IAtom,
    DELETE,
    ADD,
    die,
    isFunction,
    initObservable
} from "../internal"

const ObservableSetMarker = {}

export type IObservableSetInitialValues<T> = Set<T> | readonly T[]

export type ISetDidChange<T = any> =
    | {
          object: ObservableSet<T>
          observableKind: "set"
          debugObjectName: string
          type: "add"
          newValue: T
      }
    | {
          object: ObservableSet<T>
          observableKind: "set"
          debugObjectName: string
          type: "delete"
          oldValue: T
      }

export type ISetWillDeleteChange<T = any> = {
    type: "delete"
    object: ObservableSet<T>
    oldValue: T
};
export type ISetWillAddChange<T = any> = {
    type: "add"
    object: ObservableSet<T>
    newValue: T
};

export type ISetWillChange<T = any> =
    | ISetWillDeleteChange<T>
    | ISetWillAddChange<T>

export class ObservableSet<T = any> implements Set<T>, IInterceptable<ISetWillChange>, IListenable {
    [$mobx] = ObservableSetMarker
    private data_: Set<any> = new Set()
    atom_!: IAtom
    changeListeners_
    interceptors_
    dehancer: any
    enhancer_: (newV: any, oldV: any | undefined) => any

    constructor(
        initialData?: IObservableSetInitialValues<T>,
        enhancer: IEnhancer<T> = deepEnhancer,
        public name_ = __DEV__ ? "ObservableSet@" + getNextId() : "ObservableSet"
    ) {
        if (!isFunction(Set)) {
            die(22)
        }
        this.enhancer_ = (newV, oldV) => enhancer(newV, oldV, name_)
        initObservable(() => {
            this.atom_ = createAtom(this.name_)
            if (initialData) {
                this.replace(initialData)
            }
        })
    }

    private dehanceValue_<X extends T | undefined>(value: X): X {
        if (this.dehancer !== undefined) {
            return this.dehancer(value)
        }
        return value
    }

    clear() {
        transaction(() => {
            untracked(() => {
                for (const value of this.data_.values()) {
                    this.delete(value)
                }
            })
        })
    }

    forEach(callbackFn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any) {
        for (const value of this) {
            callbackFn.call(thisArg, value, value, this)
        }
    }

    get size() {
        this.atom_.reportObserved()
        return this.data_.size
    }

    add(value: T) {
        checkIfStateModificationsAreAllowed(this.atom_)
        if (hasInterceptors(this)) {
            const change = interceptChange<ISetWillAddChange<T>>(this, {
                type: ADD,
                object: this,
                newValue: value
            })
            if (!change) {
                return this
            }

            // implemented reassignment same as it's done for ObservableMap
            value = change.newValue!;

        }
        if (!this.has(value)) {
            transaction(() => {
                this.data_.add(this.enhancer_(value, undefined))
                this.atom_.reportChanged()
            })
            const notifySpy = __DEV__ && isSpyEnabled()
            const notify = hasListeners(this)
            const change =
                notify || notifySpy
                    ? <ISetDidChange<T>>{
                          observableKind: "set",
                          debugObjectName: this.name_,
                          type: ADD,
                          object: this,
                          newValue: value
                      }
                    : null
            if (notifySpy && __DEV__) {
                spyReportStart(change!)
            }
            if (notify) {
                notifyListeners(this, change)
            }
            if (notifySpy && __DEV__) {
                spyReportEnd()
            }
        }

        return this
    }

    delete(value: T) {
        if (hasInterceptors(this)) {
            const change = interceptChange<ISetWillDeleteChange<T>>(this, {
                type: DELETE,
                object: this,
                oldValue: value
            })
            if (!change) {
                return false
            }
        }
        if (this.has(value)) {
            const notifySpy = __DEV__ && isSpyEnabled()
            const notify = hasListeners(this)
            const change =
                notify || notifySpy
                    ? <ISetDidChange<T>>{
                          observableKind: "set",
                          debugObjectName: this.name_,
                          type: DELETE,
                          object: this,
                          oldValue: value
                      }
                    : null

            if (notifySpy && __DEV__) {
                spyReportStart(change!)
            }
            transaction(() => {
                this.atom_.reportChanged()
                this.data_.delete(value)
            })
            if (notify) {
                notifyListeners(this, change)
            }
            if (notifySpy && __DEV__) {
                spyReportEnd()
            }
            return true
        }
        return false
    }

    has(value: T) {
        this.atom_.reportObserved()
        return this.data_.has(this.dehanceValue_(value))
    }

    entries() {
        const values = this.values()
        return makeIterableForSet<[T, T]>({
            next() {
                const { value, done } = values.next()
                return !done ? { value: [value, value], done } : { value: undefined, done }
            }
        })
    }

    keys(): SetIterator<T> {
        return this.values()
    }

    values(): SetIterator<T> {
        this.atom_.reportObserved()
        const self = this
        const values = this.data_.values()
        return makeIterableForSet({
            next() {
                const { value, done } = values.next()
                return !done
                    ? { value: self.dehanceValue_(value), done }
                    : { value: undefined, done }
            }
        })
    }

    intersection<U>(otherSet: ReadonlySetLike<U> | Set<U>): Set<T & U> {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
            return otherSet.intersection(this)
        } else {
            const dehancedSet = new Set(this)
            return dehancedSet.intersection(otherSet)
        }
    }

    union<U>(otherSet: ReadonlySetLike<U> | Set<U>): Set<T | U> {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
            return otherSet.union(this)
        } else {
            const dehancedSet = new Set(this)
            return dehancedSet.union(otherSet)
        }
    }

    difference<U>(otherSet: ReadonlySetLike<U>): Set<T> {
        return new Set(this).difference(otherSet)
    }

    symmetricDifference<U>(otherSet: ReadonlySetLike<U> | Set<U>): Set<T | U> {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
            return otherSet.symmetricDifference(this)
        } else {
            const dehancedSet = new Set(this)
            return dehancedSet.symmetricDifference(otherSet)
        }
    }

    isSubsetOf(otherSet: ReadonlySetLike<unknown>): boolean {
        return new Set(this).isSubsetOf(otherSet)
    }

    isSupersetOf(otherSet: ReadonlySetLike<unknown>): boolean {
        return new Set(this).isSupersetOf(otherSet)
    }

    isDisjointFrom(otherSet: ReadonlySetLike<unknown> | Set<unknown>): boolean {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
            return otherSet.isDisjointFrom(this)
        } else {
            const dehancedSet = new Set(this)
            return dehancedSet.isDisjointFrom(otherSet)
        }
    }

    replace(other: ObservableSet<T> | IObservableSetInitialValues<T>): ObservableSet<T> {
        if (isObservableSet(other)) {
            other = new Set(other)
        }

        transaction(() => {
            if (Array.isArray(other)) {
                this.clear()
                other.forEach(value => this.add(value))
            } else if (isES6Set(other)) {
                this.clear()
                other.forEach(value => this.add(value))
            } else if (other !== null && other !== undefined) {
                die("Cannot initialize set from " + other)
            }
        })

        return this
    }
    observe_(listener: (changes: ISetDidChange<T>) => void, fireImmediately?: boolean): Lambda {
        // ... 'fireImmediately' could also be true?
        if (__DEV__ && fireImmediately === true) {
            die("`observe` doesn't support fireImmediately=true in combination with sets.")
        }
        return registerListener(this, listener)
    }

    intercept_(handler: IInterceptor<ISetWillChange<T>>): Lambda {
        return registerInterceptor(this, handler)
    }

    toJSON(): T[] {
        return Array.from(this)
    }

    toString(): string {
        return "[object ObservableSet]"
    }

    [Symbol.iterator]() {
        return this.values()
    }

    get [Symbol.toStringTag]() {
        return "Set"
    }
}

// eslint-disable-next-line
export var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet) as (
    thing: any
) => thing is ObservableSet<any>

function makeIterableForSet<T>(iterator: Iterator<T>): SetIterator<T> {
    iterator[Symbol.toStringTag] = "SetIterator"
    return makeIterable<T, BuiltinIteratorReturn>(iterator)
}



================================================
FILE: packages/mobx/src/types/observablevalue.ts
================================================
import {
    Atom,
    IEnhancer,
    IInterceptable,
    IEqualsComparer,
    IInterceptor,
    IListenable,
    Lambda,
    checkIfStateModificationsAreAllowed,
    comparer,
    createInstanceofPredicate,
    getNextId,
    hasInterceptors,
    hasListeners,
    interceptChange,
    isSpyEnabled,
    notifyListeners,
    registerInterceptor,
    registerListener,
    spyReport,
    spyReportEnd,
    spyReportStart,
    toPrimitive,
    globalState,
    IUNCHANGED,
    UPDATE
} from "../internal"

export interface IValueWillChange<T> {
    object: IObservableValue<T>
    type: "update"
    newValue: T
}

export type IValueDidChange<T = any> = {
    type: "update"
    observableKind: "value"
    object: IObservableValue<T>
    debugObjectName: string
    newValue: T
    oldValue: T | undefined
}
export type IBoxDidChange<T = any> =
    | {
          type: "create"
          observableKind: "value"
          object: IObservableValue<T>
          debugObjectName: string
          newValue: T
      }
    | IValueDidChange<T>

export interface IObservableValue<T> {
    get(): T
    set(value: T): void
}

const CREATE = "create"

export class ObservableValue<T>
    extends Atom
    implements IObservableValue<T>, IInterceptable<IValueWillChange<T>>, IListenable
{
    hasUnreportedChange_ = false
    interceptors_
    changeListeners_
    value_
    dehancer: any

    constructor(
        value: T,
        public enhancer: IEnhancer<T>,
        public name_ = __DEV__ ? "ObservableValue@" + getNextId() : "ObservableValue",
        notifySpy = true,
        private equals: IEqualsComparer<any> = comparer.default
    ) {
        super(name_)
        this.value_ = enhancer(value, undefined, name_)
        if (__DEV__ && notifySpy && isSpyEnabled()) {
            // only notify spy if this is a stand-alone observable
            spyReport({
                type: CREATE,
                object: this,
                observableKind: "value",
                debugObjectName: this.name_,
                newValue: "" + this.value_?.toString()
            })
        }
    }

    private dehanceValue(value: T): T {
        if (this.dehancer !== undefined) {
            return this.dehancer(value)
        }
        return value
    }

    public set(newValue: T) {
        const oldValue = this.value_
        newValue = this.prepareNewValue_(newValue) as any
        if (newValue !== globalState.UNCHANGED) {
            const notifySpy = isSpyEnabled()
            if (__DEV__ && notifySpy) {
                spyReportStart({
                    type: UPDATE,
                    object: this,
                    observableKind: "value",
                    debugObjectName: this.name_,
                    newValue,
                    oldValue
                })
            }
            this.setNewValue_(newValue)
            if (__DEV__ && notifySpy) {
                spyReportEnd()
            }
        }
    }

    private prepareNewValue_(newValue): T | IUNCHANGED {
        checkIfStateModificationsAreAllowed(this)
        if (hasInterceptors(this)) {
            const change = interceptChange<IValueWillChange<T>>(this, {
                object: this,
                type: UPDATE,
                newValue
            })
            if (!change) {
                return globalState.UNCHANGED
            }
            newValue = change.newValue
        }
        // apply modifier
        newValue = this.enhancer(newValue, this.value_, this.name_)
        return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue
    }

    setNewValue_(newValue: T) {
        const oldValue = this.value_
        this.value_ = newValue
        this.reportChanged()
        if (hasListeners(this)) {
            notifyListeners(this, {
                type: UPDATE,
                object: this,
                newValue,
                oldValue
            })
        }
    }

    public get(): T {
        this.reportObserved()
        return this.dehanceValue(this.value_)
    }

    intercept_(handler: IInterceptor<IValueWillChange<T>>): Lambda {
        return registerInterceptor(this, handler)
    }

    observe_(listener: (change: IValueDidChange<T>) => void, fireImmediately?: boolean): Lambda {
        if (fireImmediately) {
            listener({
                observableKind: "value",
                debugObjectName: this.name_,
                object: this,
                type: UPDATE,
                newValue: this.value_,
                oldValue: undefined
            })
        }
        return registerListener(this, listener)
    }

    raw() {
        // used by MST ot get undehanced value
        return this.value_
    }

    toJSON() {
        return this.get()
    }

    toString() {
        return `${this.name_}[${this.value_}]`
    }

    valueOf(): T {
        return toPrimitive(this.get())
    }

    [Symbol.toPrimitive]() {
        return this.valueOf()
    }
}

export const isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue) as (
    x: any
) => x is IObservableValue<any>



================================================
FILE: packages/mobx/src/types/overrideannotation.ts
================================================
import {
    die,
    Annotation,
    hasProp,
    createDecoratorAnnotation,
    ObservableObjectAdministration,
    MakeResult
} from "../internal"

import type { ClassMethodDecorator } from "./decorator_fills"

const OVERRIDE = "override"

export const override: Annotation & PropertyDecorator & ClassMethodDecorator =
    createDecoratorAnnotation({
        annotationType_: OVERRIDE,
        make_,
        extend_,
        decorate_20223_
    })

export function isOverride(annotation: Annotation): boolean {
    return annotation.annotationType_ === OVERRIDE
}

function make_(this: Annotation, adm: ObservableObjectAdministration, key): MakeResult {
    // Must not be plain object
    if (__DEV__ && adm.isPlainObject_) {
        die(
            `Cannot apply '${this.annotationType_}' to '${adm.name_}.${key.toString()}':` +
                `\n'${this.annotationType_}' cannot be used on plain objects.`
        )
    }
    // Must override something
    if (__DEV__ && !hasProp(adm.appliedAnnotations_!, key)) {
        die(
            `'${adm.name_}.${key.toString()}' is annotated with '${this.annotationType_}', ` +
                `but no such annotated member was found on prototype.`
        )
    }
    return MakeResult.Cancel
}

function extend_(this: Annotation, adm, key, descriptor, proxyTrap): boolean {
    die(`'${this.annotationType_}' can only be used with 'makeObservable'`)
}

function decorate_20223_(this: Annotation, desc, context: DecoratorContext) {
    console.warn(`'${this.annotationType_}' cannot be used with decorators - this is a no-op`)
}



================================================
FILE: packages/mobx/src/types/type-utils.ts
================================================
import { isAction } from "../api/action"
import {
    $mobx,
    IDepTreeNode,
    isAtom,
    isComputedValue,
    isObservableArray,
    isObservableMap,
    isObservableObject,
    isReaction,
    isObservableSet,
    die,
    isFunction,
    allowStateChangesStart,
    untrackedStart,
    allowStateChangesEnd,
    untrackedEnd,
    startBatch,
    endBatch
} from "../internal"

export function getAtom(thing: any, property?: PropertyKey): IDepTreeNode {
    if (typeof thing === "object" && thing !== null) {
        if (isObservableArray(thing)) {
            if (property !== undefined) {
                die(23)
            }
            return (thing as any)[$mobx].atom_
        }
        if (isObservableSet(thing)) {
            return thing.atom_
        }
        if (isObservableMap(thing)) {
            if (property === undefined) {
                return thing.keysAtom_
            }
            const observable = thing.data_.get(property) || thing.hasMap_.get(property)
            if (!observable) {
                die(25, property, getDebugName(thing))
            }
            return observable
        }
        if (property && !thing[$mobx]) {
            thing[property]
        } // See #1072
        if (isObservableObject(thing)) {
            if (!property) {
                return die(26)
            }
            const observable = (thing as any)[$mobx].values_.get(property)
            if (!observable) {
                die(27, property, getDebugName(thing))
            }
            return observable
        }
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
            return thing
        }
    } else if (isFunction(thing)) {
        if (isReaction(thing[$mobx])) {
            // disposer function
            return thing[$mobx]
        }
    }
    die(28)
}

export function getAdministration(thing: any, property?: string) {
    if (!thing) {
        die(29)
    }
    if (property !== undefined) {
        return getAdministration(getAtom(thing, property))
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
        return thing
    }
    if (isObservableMap(thing) || isObservableSet(thing)) {
        return thing
    }
    if (thing[$mobx]) {
        return thing[$mobx]
    }
    die(24, thing)
}

export function getDebugName(thing: any, property?: string): string {
    let named
    if (property !== undefined) {
        named = getAtom(thing, property)
    } else if (isAction(thing)) {
        return thing.name
    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
        named = getAdministration(thing)
    } else {
        // valid for arrays as well
        named = getAtom(thing)
    }
    return named.name_
}

/**
 * Helper function for initializing observable structures, it applies:
 * 1. allowStateChanges so we don't violate enforceActions.
 * 2. untracked so we don't accidentaly subscribe to anything observable accessed during init in case the observable is created inside derivation.
 * 3. batch to avoid state version updates
 */
export function initObservable<T>(cb: () => T): T {
    const derivation = untrackedStart()
    const allowStateChanges = allowStateChangesStart(true)
    startBatch()
    try {
        return cb()
    } finally {
        endBatch()
        allowStateChangesEnd(allowStateChanges)
        untrackedEnd(derivation)
    }
}



================================================
FILE: packages/mobx/src/utils/comparer.ts
================================================
import { deepEqual } from "../internal"

export interface IEqualsComparer<T> {
    (a: T, b: T): boolean
}

function identityComparer(a: any, b: any): boolean {
    return a === b
}

function structuralComparer(a: any, b: any): boolean {
    return deepEqual(a, b)
}

function shallowComparer(a: any, b: any): boolean {
    return deepEqual(a, b, 1)
}

function defaultComparer(a: any, b: any): boolean {
    if (Object.is) {
        return Object.is(a, b)
    }

    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b
}

export const comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    default: defaultComparer,
    shallow: shallowComparer
}



================================================
FILE: packages/mobx/src/utils/eq.ts
================================================
import {
    isES6Map,
    isObservableArray,
    isObservableMap,
    isES6Set,
    isObservableSet,
    hasProp,
    isFunction,
    objectPrototype
} from "../internal"

declare const Symbol
const toString = objectPrototype.toString

export function deepEqual(a: any, b: any, depth: number = -1): boolean {
    return eq(a, b, depth)
}

// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Modified: "Deep compare objects" part to iterate over keys in forward order instead of reverse order.
//
// Internal recursive comparison function for `isEqual`.
function eq(a: any, b: any, depth: number, aStack?: any[], bStack?: any[]) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
        return a !== 0 || 1 / a === 1 / b
    }
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) {
        return false
    }
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) {
        return b !== b
    }
    // Exhaust primitive checks
    const type = typeof a
    if (type !== "function" && type !== "object" && typeof b != "object") {
        return false
    }

    // Compare `[[Class]]` names.
    const className = toString.call(a)
    if (className !== toString.call(b)) {
        return false
    }
    switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case "[object RegExp]":
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case "[object String]":
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return "" + a === "" + b
        case "[object Number]":
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) {
                return +b !== +b
            }
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b
        case "[object Date]":
        case "[object Boolean]":
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b
        case "[object Symbol]":
            return (
                typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b)
            )
        case "[object Map]":
        case "[object Set]":
            // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
            // Hide this extra level by increasing the depth.
            if (depth >= 0) {
                depth++
            }
            break
    }
    // Unwrap any wrapped objects.
    a = unwrap(a)
    b = unwrap(b)

    const areArrays = className === "[object Array]"
    if (!areArrays) {
        if (typeof a != "object" || typeof b != "object") {
            return false
        }

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        const aCtor = a.constructor,
            bCtor = b.constructor
        if (
            aCtor !== bCtor &&
            !(
                isFunction(aCtor) &&
                aCtor instanceof aCtor &&
                isFunction(bCtor) &&
                bCtor instanceof bCtor
            ) &&
            "constructor" in a &&
            "constructor" in b
        ) {
            return false
        }
    }

    if (depth === 0) {
        return false
    } else if (depth < 0) {
        depth = -1
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || []
    bStack = bStack || []
    let length = aStack.length
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) {
            return bStack[length] === b
        }
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a)
    bStack.push(b)

    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length
        if (length !== b.length) {
            return false
        }
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
                return false
            }
        }
    } else {
        // Deep compare objects.
        const keys = Object.keys(a)
        const length = keys.length
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (Object.keys(b).length !== length) {
            return false
        }
        for (let i = 0; i < length; i++) {
            // Deep compare each member
            const key = keys[i]
            if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
                return false
            }
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop()
    bStack.pop()
    return true
}

function unwrap(a: any) {
    if (isObservableArray(a)) {
        return a.slice()
    }
    if (isES6Map(a) || isObservableMap(a)) {
        return Array.from(a.entries())
    }
    if (isES6Set(a) || isObservableSet(a)) {
        return Array.from(a.entries())
    }
    return a
}



================================================
FILE: packages/mobx/src/utils/global.ts
================================================
declare const window: any
declare const self: any

const mockGlobal = {}

export function getGlobal() {
    if (typeof globalThis !== "undefined") {
        return globalThis
    }
    if (typeof window !== "undefined") {
        return window
    }
    if (typeof global !== "undefined") {
        return global
    }
    if (typeof self !== "undefined") {
        return self
    }
    return mockGlobal
}



================================================
FILE: packages/mobx/src/utils/iterable.ts
================================================
import { getGlobal } from "../internal"

// safely get iterator prototype if available
const maybeIteratorPrototype = getGlobal().Iterator?.prototype || {}

export function makeIterable<T, TReturn = unknown>(
    iterator: Iterator<T>
): IteratorObject<T, TReturn> {
    iterator[Symbol.iterator] = getSelf
    return Object.assign(Object.create(maybeIteratorPrototype), iterator)
}

function getSelf() {
    return this
}



================================================
FILE: packages/mobx/src/utils/utils.ts
================================================
import { globalState, die } from "../internal"

// We shorten anything used > 5 times
export const assign = Object.assign
export const getDescriptor = Object.getOwnPropertyDescriptor
export const defineProperty = Object.defineProperty
export const objectPrototype = Object.prototype

export const EMPTY_ARRAY = []
Object.freeze(EMPTY_ARRAY)

export const EMPTY_OBJECT = {}
Object.freeze(EMPTY_OBJECT)

export interface Lambda {
    (): void
    name?: string
}

const hasProxy = typeof Proxy !== "undefined"
const plainObjectString = Object.toString()

export function assertProxies() {
    if (!hasProxy) {
        die(
            __DEV__
                ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`"
                : "Proxy not available"
        )
    }
}

export function warnAboutProxyRequirement(msg: string) {
    if (__DEV__ && globalState.verifyProxies) {
        die(
            "MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " +
                msg
        )
    }
}

export function getNextId() {
    return ++globalState.mobxGuid
}

/**
 * Makes sure that the provided function is invoked at most once.
 */
export function once(func: Lambda): Lambda {
    let invoked = false
    return function () {
        if (invoked) {
            return
        }
        invoked = true
        return (func as any).apply(this, arguments)
    }
}

export const noop = () => {}

export function isFunction(fn: any): fn is Function {
    return typeof fn === "function"
}

export function isString(value: any): value is string {
    return typeof value === "string"
}

export function isStringish(value: any): value is string | number | symbol {
    const t = typeof value
    switch (t) {
        case "string":
        case "symbol":
        case "number":
            return true
    }
    return false
}

export function isObject(value: any): value is Object {
    return value !== null && typeof value === "object"
}

export function isPlainObject(value: any) {
    if (!isObject(value)) {
        return false
    }
    const proto = Object.getPrototypeOf(value)
    if (proto == null) {
        return true
    }
    const protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor
    return (
        typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString
    )
}

// https://stackoverflow.com/a/37865170
export function isGenerator(obj: any): boolean {
    const constructor = obj?.constructor
    if (!constructor) {
        return false
    }
    if (
        "GeneratorFunction" === constructor.name ||
        "GeneratorFunction" === constructor.displayName
    ) {
        return true
    }
    return false
}

export function addHiddenProp(object: any, propName: PropertyKey, value: any) {
    defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value
    })
}

export function addHiddenFinalProp(object: any, propName: PropertyKey, value: any) {
    defineProperty(object, propName, {
        enumerable: false,
        writable: false,
        configurable: true,
        value
    })
}

export function createInstanceofPredicate<T>(
    name: string,
    theClass: new (...args: any[]) => T
): (x: any) => x is T {
    const propName = "isMobX" + name
    theClass.prototype[propName] = true
    return function (x) {
        return isObject(x) && x[propName] === true
    } as any
}

/**
 * Yields true for both native and observable Map, even across different windows.
 */
export function isES6Map(thing: unknown): thing is Map<any, any> {
    return thing != null && Object.prototype.toString.call(thing) === "[object Map]"
}

/**
 * Makes sure a Map is an instance of non-inherited native or observable Map.
 */
export function isPlainES6Map(thing: Map<unknown, unknown>): boolean {
    const mapProto = Object.getPrototypeOf(thing)
    const objectProto = Object.getPrototypeOf(mapProto)
    const nullProto = Object.getPrototypeOf(objectProto)
    return nullProto === null
}

/**
 * Yields true for both native and observable Set, even across different windows.
 */
export function isES6Set(thing: unknown): thing is Set<any> {
    return thing != null && Object.prototype.toString.call(thing) === "[object Set]"
}

const hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined"

/**
 * Returns the following: own enumerable keys and symbols.
 */
export function getPlainObjectKeys(object: any) {
    const keys = Object.keys(object)
    // Not supported in IE, so there are not going to be symbol props anyway...
    if (!hasGetOwnPropertySymbols) {
        return keys
    }
    const symbols = Object.getOwnPropertySymbols(object)
    if (!symbols.length) {
        return keys
    }
    return [...keys, ...symbols.filter(s => objectPrototype.propertyIsEnumerable.call(object, s))]
}

// From Immer utils
// Returns all own keys, including non-enumerable and symbolic
export const ownKeys: (target: any) => Array<string | symbol> =
    typeof Reflect !== "undefined" && Reflect.ownKeys
        ? Reflect.ownKeys
        : hasGetOwnPropertySymbols
        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)
        : /* istanbul ignore next */ Object.getOwnPropertyNames

export function stringifyKey(key: any): string {
    if (typeof key === "string") {
        return key
    }
    if (typeof key === "symbol") {
        return key.toString()
    }
    return new String(key).toString()
}

export function toPrimitive(value: any) {
    return value === null ? null : typeof value === "object" ? "" + value : value
}

export function hasProp(target: Object, prop: PropertyKey): boolean {
    return objectPrototype.hasOwnProperty.call(target, prop)
}

// From Immer utils
export const getOwnPropertyDescriptors =
    Object.getOwnPropertyDescriptors ||
    function getOwnPropertyDescriptors(target: any) {
        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
        const res: any = {}
        // Note: without polyfill for ownKeys, symbols won't be picked up
        ownKeys(target).forEach(key => {
            res[key] = getDescriptor(target, key)
        })
        return res
    }

export function getFlag(flags: number, mask: number) {
    return !!(flags & mask)
}

export function setFlag(flags: number, mask: number, newValue: boolean): number {
    if (newValue) {
        flags |= mask
    } else {
        flags &= ~mask
    }
    return flags
}



================================================
FILE: packages/mobx-react/README.md
================================================
# mobx-react

[![CircleCI](https://circleci.com/gh/mobxjs/mobx-react.svg?style=svg)](https://circleci.com/gh/mobxjs/mobx-react)
[![CDNJS](https://img.shields.io/cdnjs/v/mobx-react.svg)](https://cdnjs.com/libraries/mobx-react)
[![Minzipped size](https://img.shields.io/bundlephobia/minzip/mobx-react.svg)](https://bundlephobia.com/result?p=mobx-react)
[![Discuss on Github](https://img.shields.io/badge/discuss%20on-GitHub-orange)](https://github.com/mobxjs/mobx/discussions)
[![View changelog](https://img.shields.io/badge/changelogs.xyz-Explore%20Changelog-brightgreen)](https://changelogs.xyz/mobx-react)

Package with React component wrapper for combining React with MobX.
Exports the `observer` decorator and other utilities.
For documentation, see the [MobX](https://mobx.js.org) project.
This package supports both React and React Native.

## Compatibility matrix

Only the latest version is actively maintained. If you're missing a fix or a feature in older version, consider upgrading or using [patch-package](https://www.npmjs.com/package/patch-package)

| NPM Version | Support MobX version | Supported React versions | Added support for:                                                               |
| ----------- | -------------------- | ------------------------ | -------------------------------------------------------------------------------- |
| v9          | 6.\*                 | >16.8                    | Hooks, React 18.2 in strict mode                                                 |
| v7          | 6.\*                 | >16.8 < 18.2             | Hooks                                                                            |
| v6          | 4.\* / 5.\*          | >16.8 <17                | Hooks                                                                            |
| v5          | 4.\* / 5.\*          | >0.13 <17                | No, but it is possible to use `<Observer>` sections inside hook based components |

mobx-react 6 / 7 is a repackage of the smaller [mobx-react-lite](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite) package + following features from the `mobx-react@5` package added:

-   Support for class based components for `observer` and `@observer`
-   `Provider / inject` to pass stores around (but consider to use `React.createContext` instead)
-   `PropTypes` to describe observable based property checkers (but consider to use TypeScript instead)
-   The `disposeOnUnmount` utility / decorator to easily clean up resources such as reactions created in your class based components.

## Installation

`npm install mobx-react --save`

Or CDN: https://unpkg.com/mobx-react (UMD namespace: `mobxReact`)

```javascript
import { observer } from "mobx-react"
```

This package provides the bindings for MobX and React.
See the [official documentation](https://mobx.js.org/react-integration.html) for how to get started.

For greenfield projects you might want to consider to use [mobx-react-lite](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite), if you intend to only use function based components. `React.createContext` can be used to pass stores around.

## API documentation

Please check [mobx.js.org](https://mobx.js.org/) for the general documentation. The documentation below highlights some specifics.

### `observer(component)`

Function (and decorator) that converts a React component definition, React component class, or stand-alone render function, into a reactive component. A converted component will track which observables are used by its effective `render` and automatically re-render the component when one of these values changes.

#### Functional Components

`React.memo` is automatically applied to functional components provided to `observer`. `observer` does not accept a functional component already wrapped in `React.memo`, or an `observer`, in order to avoid consequences that might arise as a result of wrapping it twice.

#### Class Components

`shouldComponentUpdate` is not supported. As such, it is recommended that class components extend `React.PureComponent`. The `observer` will automatically patch non-pure class components with an internal implementation of `React.PureComponent` if necessary.

Extending `observer` class components is not supported. Always apply `observer` only on the last class in the inheritance chain.

See the [MobX](https://mobx.js.org/react-integration.html#react-integration) documentation for more details.

```javascript
import { observer } from "mobx-react"

// ---- ES6 syntax ----
const TodoView = observer(
    class TodoView extends React.Component {
        render() {
            return <div>{this.props.todo.title}</div>
        }
    }
)

// ---- ESNext syntax with decorator syntax enabled ----
@observer
class TodoView extends React.Component {
    render() {
        return <div>{this.props.todo.title}</div>
    }
}

// ---- or just use function components: ----
const TodoView = observer(({ todo }) => <div>{todo.title}</div>)
```

##### Note on using props and state in derivations

`mobx-react` version 6 and lower would automatically turn `this.state` and `this.props` into observables.
This has the benefit that computed properties and reactions were able to observe those.
However, since this pattern is fundamentally incompatible with `StrictMode` in React 18.2 and higher, this behavior has been removed in React 18.

As a result, we recommend to no longer mark properties as `@computed` in observer components if they depend on `this.state` or `this.props`.

```javascript
@observer
class Doubler extends React.Component<{ counter: number }> {
    @computed // BROKEN! <-- @computed should be removed in mobx-react > 7
    get doubleValue() {
        // Changes to this.props will no longer be detected properly, to fix it,
        // remove the @computed annotation.
        return this.props * 2
    }

    render() {
        return <div>{this.doubleValue}</div>
    }
}
```

Similarly, reactions will no longer respond to `this.state` / `this.props`. This can be overcome by creating an observable copy:

```javascript
@observer
class Alerter extends React.Component<{ counter: number }> {
    @observable observableCounter: number
    reactionDisposer

    constructor(props) {
        this.observableCounter = counter
    }

    componentDidMount() {
        // set up a reaction, by observing the observable,
        // rather than the prop which is non-reactive:
        this.reactionDisposer = autorun(() => {
            if (this.observableCounter > 10) {
                alert("Reached 10!")
            }
        })
    }

    componentDidUpdate() {
        // sync the observable from props
        this.observableCounter = this.props.counter
    }

    componentWillUnmount() {
        this.reactionDisposer()
    }

    render() {
        return <div>{this.props.counter}</div>
    }
}
```

MobX-react will try to detect cases where `this.props`, `this.state` or `this.context` are used by any other derivation than the `render` method of the owning component and throw.
This is to make sure that neither computed properties, nor reactions, nor other components accidentally rely on those fields to be reactive.

This includes cases where a render callback is passed to a child, that will read from the props or state of a parent component.
As a result, passing a function that might later read a property of a parent in a reactive context will throw as well.
Instead, when using a callback function that is being passed to an `observer` based child, the capture should be captured locally first:

```javascript
@observer
class ChildWrapper extends React.Component<{ counter: number }> {
    render() {
        // Collapsible is an observer component that should respond to this.counter,
        // if it is expanded

        // BAD:
        return <Collapsible onRenderContent={() => <h1>{this.props.counter}</h1>} />

        // GOOD: (causes to pass down a fresh callback whenever counter changes,
        // that doesn't depend on its parents props)
        const counter = this.props.counter
        return <Collapsible onRenderContent={() => <h1>{counter}</h1>} />
    }
}
```

### `Observer`

`Observer` is a React component, which applies `observer` to an anonymous region in your component.
It takes as children a single, argumentless function which should return exactly one React component.
The rendering in the function will be tracked and automatically re-rendered when needed.
This can come in handy when needing to pass render function to external components (for example the React Native listview), or if you
dislike the `observer` decorator / function.

```javascript
class App extends React.Component {
    render() {
        return (
            <div>
                {this.props.person.name}
                <Observer>{() => <div>{this.props.person.name}</div>}</Observer>
            </div>
        )
    }
}

const person = observable({ name: "John" })

ReactDOM.render(<App person={person} />, document.body)
person.name = "Mike" // will cause the Observer region to re-render
```

In case you are a fan of render props, you can use that instead of children. Be advised, that you cannot use both approaches at once, children have a precedence.
Example

```javascript
class App extends React.Component {
    render() {
        return (
            <div>
                {this.props.person.name}
                <Observer render={() => <div>{this.props.person.name}</div>} />
            </div>
        )
    }
}

const person = observable({ name: "John" })

ReactDOM.render(<App person={person} />, document.body)
person.name = "Mike" // will cause the Observer region to re-render
```

### `useLocalObservable` hook

Local observable state can be introduced by using the `useLocalObservable` hook, that runs once to create an observable store. A quick example would be:

```javascript
import { useLocalObservable, Observer } from "mobx-react-lite"

const Todo = () => {
    const todo = useLocalObservable(() => ({
        title: "Test",
        done: true,
        toggle() {
            this.done = !this.done
        }
    }))

    return (
        <Observer>
            {() => (
                <h1 onClick={todo.toggle}>
                    {todo.title} {todo.done ? "[DONE]" : "[TODO]"}
                </h1>
            )}
        </Observer>
    )
}
```

When using `useLocalObservable`, all properties of the returned object will be made observable automatically, getters will be turned into computed properties, and methods will be bound to the store and apply mobx transactions automatically. If new class instances are returned from the initializer, they will be kept as is.

It is important to realize that the store is created only once! It is not possible to specify dependencies to force re-creation, _nor should you directly be referring to props for the initializer function_, as changes in those won't propagate.

Instead, if your store needs to refer to props (or `useState` based local state), the `useLocalObservable` should be combined with the `useAsObservableSource` hook, see below.

Note that in many cases it is possible to extract the initializer function to a function outside the component definition. Which makes it possible to test the store itself in a more straight-forward manner, and avoids creating the initializer closure on each re-render.

_Note: using `useLocalObservable` is mostly beneficial for really complex local state, or to obtain more uniform code base. Note that using a local store might conflict with future React features like concurrent rendering._

### Server Side Rendering with `enableStaticRendering`

When using server side rendering, normal lifecycle hooks of React components are not fired, as the components are rendered only once.
Since components are never unmounted, `observer` components would in this case leak memory when being rendered server side.
To avoid leaking memory, call `enableStaticRendering(true)` when using server side rendering.

```javascript
import { enableStaticRendering } from "mobx-react"

enableStaticRendering(true)
```

This makes sure the component won't try to react to any future data changes.

### Which components should be marked with `observer`?

The simple rule of thumb is: _all components that render observable data_.
If you don't want to mark a component as observer, for example to reduce the dependencies of a generic component package, make sure you only pass it plain data.

### Enabling decorators (optional)

Decorators are currently a stage-2 ESNext feature. How to enable them is documented [here](https://mobx.js.org/enabling-decorators.html#enabling-decorators-).

### Should I still use smart and dumb components?

See this [thread](https://www.reddit.com/r/reactjs/comments/4vnxg5/free_eggheadio_course_learn_mobx_react_in_30/d61oh0l).
TL;DR: the conceptual distinction makes a lot of sense when using MobX as well, but use `observer` on all components.

### `PropTypes`

MobX-react provides the following additional `PropTypes` which can be used to validate against MobX structures:

-   `observableArray`
-   `observableArrayOf(React.PropTypes.number)`
-   `observableMap`
-   `observableObject`
-   `arrayOrObservableArray`
-   `arrayOrObservableArrayOf(React.PropTypes.number)`
-   `objectOrObservableObject`

Use `import { PropTypes } from "mobx-react"` to import them, then use for example `PropTypes.observableArray`

### `Provider` and `inject`

_Note: usually there is no need anymore to use `Provider` / `inject` in new code bases; most of its features are now covered by `React.createContext`._

`Provider` is a component that can pass stores (or other stuff) using React's context mechanism to child components.
This is useful if you have things that you don't want to pass through multiple layers of components explicitly.

`inject` can be used to pick up those stores. It is a higher order component that takes a list of strings and makes those stores available to the wrapped component.

Example (based on the official [context docs](https://facebook.github.io/react/docs/context.html#passing-info-automatically-through-a-tree)):

```javascript
@inject("color")
@observer
class Button extends React.Component {
    render() {
        return <button style={{ background: this.props.color }}>{this.props.children}</button>
    }
}

class Message extends React.Component {
    render() {
        return (
            <div>
                {this.props.text} <Button>Delete</Button>
            </div>
        )
    }
}

class MessageList extends React.Component {
    render() {
        const children = this.props.messages.map(message => <Message text={message.text} />)
        return (
            <Provider color="red">
                <div>{children}</div>
            </Provider>
        )
    }
}
```

Notes:

-   It is possible to read the stores provided by `Provider` using `React.useContext`, by using the `MobXProviderContext` context that can be imported from `mobx-react`.
-   If a component asks for a store and receives a store via a property with the same name, the property takes precedence. Use this to your advantage when testing!
-   When using both `@inject` and `@observer`, make sure to apply them in the correct order: `observer` should be the inner decorator, `inject` the outer. There might be additional decorators in between.
-   The original component wrapped by `inject` is available as the `wrappedComponent` property of the created higher order component.

#### "The set of provided stores has changed" error

Values provided through `Provider` should be final. Make sure that if you put things in `context` that might change over time, that they are `@observable` or provide some other means to listen to changes, like callbacks. However, if your stores will change over time, like an observable value of another store, MobX will throw an error.
This restriction exists mainly for legacy reasons. If you have a scenario where you need to modify the set of stores, please leave a comment about it in this issue https://github.com/mobxjs/mobx-react/issues/745. Or a preferred way is to [use React Context](https://reactjs.org/docs/context.html) directly which does not have this restriction.

#### Inject as function

The above example in ES5 would start like:

```javascript
var Button = inject("color")(
    observer(
        class Button extends Component {
            /* ... etc ... */
        }
    )
)
```

A functional stateless component would look like:

```javascript
var Button = inject("color")(
    observer(({ color }) => {
        /* ... etc ... */
    })
)
```

#### Customizing inject

Instead of passing a list of store names, it is also possible to create a custom mapper function and pass it to inject.
The mapper function receives all stores as argument, the properties with which the components are invoked and the context, and should produce a new set of properties,
that are mapped into the original:

`mapperFunction: (allStores, props, context) => additionalProps`

Since version 4.0 the `mapperFunction` itself is tracked as well, so it is possible to do things like:

```javascript
const NameDisplayer = ({ name }) => <h1>{name}</h1>

const UserNameDisplayer = inject(stores => ({
    name: stores.userStore.name
}))(NameDisplayer)

const user = mobx.observable({
    name: "Noa"
})

const App = () => (
    <Provider userStore={user}>
        <UserNameDisplayer />
    </Provider>
)

ReactDOM.render(<App />, document.body)
```

_N.B. note that in this *specific* case neither `NameDisplayer` nor `UserNameDisplayer` needs to be decorated with `observer`, since the observable dereferencing is done in the mapper function_

#### Using `PropTypes` and `defaultProps` and other static properties in combination with `inject`

Inject wraps a new component around the component you pass into it.
This means that assigning a static property to the resulting component, will be applied to the HoC, and not to the original component.
So if you take the following example:

```javascript
const UserName = inject("userStore")(({ userStore, bold }) => someRendering())

UserName.propTypes = {
    bold: PropTypes.boolean.isRequired,
    userStore: PropTypes.object.isRequired // will always fail
}
```

The above propTypes are incorrect, `bold` needs to be provided by the caller of the `UserName` component and is checked by React.
However, `userStore` does not need to be required! Although it is required for the original stateless function component, it is not
required for the resulting inject component. After all, the whole point of that component is to provide that `userStore` itself.

So if you want to make assertions on the data that is being injected (either stores or data resulting from a mapper function), the propTypes
should be defined on the _wrapped_ component. Which is available through the static property `wrappedComponent` on the inject component:

```javascript
const UserName = inject("userStore")(({ userStore, bold }) => someRendering())

UserName.propTypes = {
    bold: PropTypes.boolean.isRequired // could be defined either here ...
}

UserName.wrappedComponent.propTypes = {
    // ... or here
    userStore: PropTypes.object.isRequired // correct
}
```

The same principle applies to `defaultProps` and other static React properties.
Note that it is not allowed to redefine `contextTypes` on `inject` components (but is possible to define it on `wrappedComponent`)

Finally, mobx-react will automatically move non React related static properties from wrappedComponent to the inject component so that all static fields are
actually available to the outside world without needing `.wrappedComponent`.

#### Strongly typing inject

##### With TypeScript

`inject` also accepts a function (`(allStores, nextProps, nextContext) => additionalProps`) that can be used to pick all the desired stores from the available stores like this.
The `additionalProps` will be merged into the original `nextProps` before being provided to the next component.

```typescript
import { IUserStore } from "myStore"

@inject(allStores => ({
    userStore: allStores.userStore as IUserStore
}))
class MyComponent extends React.Component<{ userStore?: IUserStore; otherProp: number }, {}> {
    /* etc */
}
```

Make sure to mark `userStore` as an optional property. It should not (necessarily) be passed in by parent components at all!

Note: If you have strict null checking enabled, you could muffle the nullable type by using the `!` operator:

```
public render() {
   const {a, b} = this.store!
   // ...
}
```

#### Testing store injection

It is allowed to pass any declared store in directly as a property as well. This makes it easy to set up individual component tests without a provider.

So if you have in your app something like:

```javascript
<Provider profile={profile}>
    <Person age={"30"} />
</Provider>
```

In your test you can easily test the `Person` component by passing the necessary store as prop directly:

```
const profile = new Profile()
const mountedComponent = mount(
   <Person age={'30'} profile={profile} />
)
```

Bear in mind that using shallow rendering won't provide any useful results when testing injected components; only the injector will be rendered.
To test with shallow rendering, instantiate the `wrappedComponent` instead: `shallow(<Person.wrappedComponent />)`

### disposeOnUnmount(componentInstance, propertyKey | function | function[])

Function (and decorator) that makes sure a function (usually a disposer such as the ones returned by `reaction`, `autorun`, etc.) is automatically executed as part of the componentWillUnmount lifecycle event.

```javascript
import { disposeOnUnmount } from "mobx-react"

class SomeComponent extends React.Component {
    // decorator version
    @disposeOnUnmount
    someReactionDisposer = reaction(...)

    // decorator version with arrays
    @disposeOnUnmount
    someReactionDisposers = [
        reaction(...),
        reaction(...)
    ]


    // function version over properties
    someReactionDisposer = disposeOnUnmount(this, reaction(...))

    // function version inside methods
    componentDidMount() {
        // single function
        disposeOnUnmount(this, reaction(...))

        // or function array
        disposeOnUnmount(this, [
            reaction(...),
            reaction(...)
        ])
    }
}
```

## DevTools

`mobx-react@6` and higher are no longer compatible with the mobx-react-devtools.
That is, the MobX react devtools will no longer show render timings or dependency trees of the component.
The reason is that the standard React devtools are also capable of highlighting re-rendering components.
And the dependency tree of a component can now be inspected by the standard devtools as well, as shown in the image below:

![hooks.png](hooks.png)

## FAQ

**Should I use `observer` for each component?**

You should use `observer` on every component that displays observable data.
Even the small ones. `observer` allows components to render independently from their parent and in general this means that
the more you use `observer`, the better the performance become.
The overhead of `observer` itself is negligible.
See also [Do child components need `@observer`?](https://github.com/mobxjs/mobx/issues/101)

**I see React warnings about `forceUpdate` / `setState` from React**

The following warning will appear if you trigger a re-rendering between instantiating and rendering a component:

```

Warning: forceUpdate(...): Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.`

```

-- or --

```

Warning: setState(...): Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`.

```

Usually this means that (another) component is trying to modify observables used by this components in their `constructor` or `getInitialState` methods.
This violates the React Lifecycle, `componentWillMount` should be used instead if state needs to be modified before mounting.



================================================
FILE: packages/mobx-react/batchingForReactDom.js
================================================
require("mobx-react-lite/batchingForReactDom")



================================================
FILE: packages/mobx-react/batchingForReactNative.js
================================================
require("mobx-react-lite/batchingForReactNative")



================================================
FILE: packages/mobx-react/batchingOptOut.js
================================================
require("mobx-react-lite/batchingOptOut")



================================================
FILE: packages/mobx-react/CHANGELOG.md
================================================
# mobx-react

## 9.2.0

### Minor Changes

-   [`2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0`](https://github.com/mobxjs/mobx/commit/2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0) [#3985](https://github.com/mobxjs/mobx/pull/3985) Thanks [@imjordanxd](https://github.com/imjordanxd)! - \* Added React 19 support, fixes #3986

### Patch Changes

-   Updated dependencies [[`2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0`](https://github.com/mobxjs/mobx/commit/2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0)]:
    -   mobx-react-lite@4.1.0

## 9.1.1

### Patch Changes

-   [`61abc53f`](https://github.com/mobxjs/mobx/commit/61abc53ff10554d1d5ce3e85466f6beda4d63fa2) [#3852](https://github.com/mobxjs/mobx/pull/3852) Thanks [@mweststrate](https://github.com/mweststrate)! - Patched the release process, forcing release to get everything in pristine state.

-   Updated dependencies [[`61abc53f`](https://github.com/mobxjs/mobx/commit/61abc53ff10554d1d5ce3e85466f6beda4d63fa2), [`7bbb523a`](https://github.com/mobxjs/mobx/commit/7bbb523a7b81229570e0e2a176b989bfc74c4634)]:
    -   mobx-react-lite@4.0.7

## 9.1.0

### Minor Changes

-   [`c9260974`](https://github.com/mobxjs/mobx/commit/c9260974f726f58de0fd4974ea024c644d9b7c6f) [#3790](https://github.com/mobxjs/mobx/pull/3790) Thanks [@mweststrate](https://github.com/mweststrate)! - Added support for modern 2022.3 Decorators. [#3790](https://github.com/mobxjs/mobx/pull/3790)
    -   [Installation / usage instruction](https://mobx.js.org/enabling-decorators.html).
    -   [Introduction announcement](https://michel.codes/blogs/mobx-decorators)
    -   Original PR by [@Matchlighter](https://github.com/Matchlighter) in [#3638](https://github.com/mobxjs/mobx/pull/3638),

## 9.0.2

### Patch Changes

-   [`5063c38e`](https://github.com/mobxjs/mobx/commit/5063c38ead557624321e2bbeb1aff905438564b0) [#3776](https://github.com/mobxjs/mobx/pull/3776) Thanks [@wbercx](https://github.com/wbercx)! - Fixed premature disposal of class component observers.

## 9.0.1

### Patch Changes

-   [`d813746c`](https://github.com/mobxjs/mobx/commit/d813746cfaa18d80daddee3724562fed6b307c0a) [#3731](https://github.com/mobxjs/mobx/pull/3731) Thanks [@urugator](https://github.com/urugator)! - fix #3730: class component does not react to state changes performed before mount

-   Updated dependencies [[`3ceeb865`](https://github.com/mobxjs/mobx/commit/3ceeb8651e328c4c7211c875696b3f5269fea834)]:
    -   mobx-react-lite@4.0.4

## 9.0.0

### Major Changes

-   [`473cb3f5`](https://github.com/mobxjs/mobx/commit/473cb3f5fc8bf43abdd1c9c7857fe2820d2291fe) [#3718](https://github.com/mobxjs/mobx/pull/3718) Thanks [@mweststrate](https://github.com/mweststrate)! - - Fixed `observer` in `StrictMode` #3671
    -   **[BREAKING CHANGE]** Class component's `props`/`state`/`context` are no longer observable. Attempt to use these in any derivation other than component's `render` throws and error. For details see https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations
    -   Extending or applying `observer` classes is now explicitly forbidden

### Patch Changes

-   Updated dependencies [[`58bb052c`](https://github.com/mobxjs/mobx/commit/58bb052ca41b8592e5bd5c3003b68ec52da53f33), [`473cb3f5`](https://github.com/mobxjs/mobx/commit/473cb3f5fc8bf43abdd1c9c7857fe2820d2291fe)]:
    -   mobx-react-lite@4.0.3

## 8.0.0

### Major Changes

-   [`44a2cf42`](https://github.com/mobxjs/mobx/commit/44a2cf42dec7635f639ddbfb19202ebc710bac54) [#3590](https://github.com/mobxjs/mobx/pull/3590) Thanks [@urugator](https://github.com/urugator)! - Functional components now use `useSyncExternalStore`, which should prevent tearing - you have to update mobx, otherwise it should behave as previously.<br>
    Improved displayName/name handling of functional components as discussed in #3438.<br>
    Reactions of uncommited class components are now correctly disposed, fixes #3492.<br>
    Reactions don't notify uncommited class components, avoiding the warning, fixes #3492.<br>
    Removed symbol "polyfill" and replaced with actual Symbols.<br>
    Removed `this.render` replacement detection + warning. `this.render` is no longer configurable/writable (possibly BC).<br>
    Class component instance is no longer exposed as `component[$mobx]["reactcomponent"]` (possibly BC).<br>
    Deprecated `disposeOnUnmount`, it's not compatible with remounting.<br>

### Patch Changes

-   Updated dependencies [[`44a2cf42`](https://github.com/mobxjs/mobx/commit/44a2cf42dec7635f639ddbfb19202ebc710bac54)]:
    -   mobx-react-lite@4.0.0

## 7.6.0

### Minor Changes

-   [`7aab223e`](https://github.com/mobxjs/mobx/commit/7aab223e99bdd453365103782dba2047e77e41d0) [#3565](https://github.com/mobxjs/mobx/pull/3565) Thanks [@kubk](https://github.com/kubk)! - Make mobx-react compatible with TS 4.8+

## 7.5.3

### Patch Changes

-   [`78d1aa23`](https://github.com/mobxjs/mobx/commit/78d1aa2362b4dc5d521518688d6ac7e2d4f7ad3a) [#3458](https://github.com/mobxjs/mobx/pull/3458) Thanks [@egilll](https://github.com/egilll)! - A slight revamp of the README, wording, and clearer links

## 7.5.2

### Patch Changes

-   [`a23aaf3f`](https://github.com/mobxjs/mobx/commit/a23aaf3ff50217c40729e0d58c85767911323ebe) [#3452](https://github.com/mobxjs/mobx/pull/3452) Thanks [@urugator](https://github.com/urugator)! - fix #3448 regression: static rendering + class component

## 7.5.1

### Patch Changes

-   [`bbcb12dc`](https://github.com/mobxjs/mobx/commit/bbcb12dc754524552181b177a52ffdbe80ecb953) [#3434](https://github.com/mobxjs/mobx/pull/3434) Thanks [@urugator](https://github.com/urugator)! - Support re-mounting of class components. Fixes #3395: observer not working with React@18 &lt;StrictMode&gt;.

## 7.5.0

### Minor Changes

-   [`1470b8e4`](https://github.com/mobxjs/mobx/commit/1470b8e4273d6b4046f3107b7f6c30fcffc70eeb) [#3404](https://github.com/mobxjs/mobx/pull/3404) Thanks [@pixelkritzel](https://github.com/pixelkritzel)! - `this.context` is observable if static contextType is set

## 7.4.0

### Minor Changes

-   [`4c5e75cd`](https://github.com/mobxjs/mobx/commit/4c5e75cdfec08c04ad774c70dca0629bd2c77016) [#3382](https://github.com/mobxjs/mobx/pull/3382) Thanks [@iChenLei](https://github.com/iChenLei)! - replace the deprecated react type definition with recommended type definition

*   [`bd4b70d8`](https://github.com/mobxjs/mobx/commit/bd4b70d8ded29673af8161aa42fb88dc4ad4420e) [#3387](https://github.com/mobxjs/mobx/pull/3387) Thanks [@mweststrate](https://github.com/mweststrate)! - Added experimental / poor man's support for React 18. Fixes #3363, #2526. Supersedes #3005

    -   Updated tests, test / build infra, peerDependencies to React 18
    -   **[breaking icmw upgrading to React 18]** Already deprecated hooks like `useMutableSource` will trigger warnings in React 18, which is correct and those shouldn't be used anymore.
    -   **[breaking icmw upgrading to React 18]** When using React 18, it is important that `act` is used in **unit tests** around every programmatic mutation. Without it, changes won't propagate!
    -   The React 18 support is poor man's support; that is, we don't do anything yet to play nicely with Suspense features. Although e.g. [startTransition](https://github.com/mweststrate/platform-app/commit/bdd995773ddc6551235a4d2b0a4c9bd57d30510e) basically works, MobX as is doesn't respect the Suspense model and will always reflect the latest state that is being rendered with, so tearing might occur. I think this is in theoretically addressable by using `useSyncExternalStore` and capturing the current values together with the dependency tree of every component instance. However that isn't included in this pull request 1) it would be a breaking change, whereas the current change is still compatible with React 16 and 17. 2) I want to collect use cases where the tearing leads to problems first to build a better problem understanding. If you run into the problem, please submit an issue describing your scenario, and a PR with a unit tests demonstrating the problem in simplified form. For further discussion see #2526, #3005

### Patch Changes

-   Updated dependencies [[`4c5e75cd`](https://github.com/mobxjs/mobx/commit/4c5e75cdfec08c04ad774c70dca0629bd2c77016), [`bd4b70d8`](https://github.com/mobxjs/mobx/commit/bd4b70d8ded29673af8161aa42fb88dc4ad4420e)]:
    -   mobx-react-lite@3.4.0

## 7.3.0

### Minor Changes

-   [`59b42c28`](https://github.com/mobxjs/mobx/commit/59b42c2826208435353ce6bf154ae59077edcc05) [#3282](https://github.com/mobxjs/mobx/pull/3282) Thanks [@urugator](https://github.com/urugator)! - `observer(forwardRef(fn))` no longer generates extra `<Observer>` element and applies `memo` correctly

### Patch Changes

-   Updated dependencies [[`59b42c28`](https://github.com/mobxjs/mobx/commit/59b42c2826208435353ce6bf154ae59077edcc05)]:
    -   mobx-react-lite@3.3.0

## 7.2.1

### Patch Changes

-   [`8a1ff856`](https://github.com/mobxjs/mobx/commit/8a1ff856043d59396f623f8ca209822b1331d85f) [#3103](https://github.com/mobxjs/mobx/pull/3103) Thanks [@urugator](https://github.com/urugator)! - Missing `render` on component prototype throws.

## 7.2.0

### Minor Changes

-   [`87b3e1de`](https://github.com/mobxjs/mobx/commit/87b3e1de58069617a39552d71a4d5c5c134cbbaf) [#2930](https://github.com/mobxjs/mobx/pull/2930) Thanks [@vkrol](https://github.com/vkrol)! - inject shouldn't change original displayName of component that uses forwardRef

## 7.1.0

### Patch Changes

-   Updated dependencies [[`28f8a11d`](https://github.com/mobxjs/mobx/commit/28f8a11d8b94f1aca2eec4ae9c5f45c5ea2f4362)]:
    -   mobx@6.1.0
    -   mobx-react-lite@4.0.0

## 7.0.6

### Patch Changes

-   [`592e6e99`](https://github.com/mobxjs/mobx/commit/592e6e996c2d5264e162cfb0921a071c1d815c92) [#2743](https://github.com/mobxjs/mobx/pull/2743) Thanks [@vkrol](https://github.com/vkrol)! - Remove `sideEffects` section in `mobx-react-lite` `package.json`

-   Updated dependencies [[`6b304232`](https://github.com/mobxjs/mobx/commit/6b30423266e5418a3f20389d0bd0eae31f3384d2), [`83b84fd3`](https://github.com/mobxjs/mobx/commit/83b84fd354f2253fdd8ea556e217a92fc2633c00), [`65c7b73b`](https://github.com/mobxjs/mobx/commit/65c7b73b7f0b1a69a1a2786b5f484419d129d10b), [`989390d4`](https://github.com/mobxjs/mobx/commit/989390d46bbe9941b61ac6c6d1292f96445e7cc3), [`dea1cf18`](https://github.com/mobxjs/mobx/commit/dea1cf189b0f43929f4f626229d34a80bd10212e), [`592e6e99`](https://github.com/mobxjs/mobx/commit/592e6e996c2d5264e162cfb0921a071c1d815c92)]:
    -   mobx@6.0.5
    -   mobx-react-lite@3.1.7

## 7.0.5

### Patch Changes

-   [`2f3dcb27`](https://github.com/mobxjs/mobx/commit/2f3dcb274f795ffca4ae724b6b4795958620838d) Thanks [@FredyC](https://github.com/FredyC)! - Fix names of UMD exports [#2517](https://github.com/mobxjs/mobx/issues/2617)

-   Updated dependencies [[`2f3dcb27`](https://github.com/mobxjs/mobx/commit/2f3dcb274f795ffca4ae724b6b4795958620838d), [`79a09f49`](https://github.com/mobxjs/mobx/commit/79a09f49a9f2baddbab8d89e9a7ac07cffadf624)]:
    -   mobx-react-lite@3.1.6
    -   mobx@6.0.4

## 7.0.4

### Patch Changes

-   [`8bbbc7c0`](https://github.com/mobxjs/mobx/commit/8bbbc7c0df77cd79530add5db2d6a04cfe6d84b1) Thanks [@FredyC](https://github.com/FredyC)! - Fix names of dist files (for real now). Third time is the charm ğŸ˜…

-   Updated dependencies [[`8bbbc7c0`](https://github.com/mobxjs/mobx/commit/8bbbc7c0df77cd79530add5db2d6a04cfe6d84b1)]:
    -   mobx-react-lite@3.1.4

## 7.0.3

### Patch Changes

-   [`b7aa9d35`](https://github.com/mobxjs/mobx/commit/b7aa9d35432888ee5dd80a6c9dcbc18b04a0346c) Thanks [@FredyC](https://github.com/FredyC)! - Fixed wrong package name for dist files

-   Updated dependencies [[`b7aa9d35`](https://github.com/mobxjs/mobx/commit/b7aa9d35432888ee5dd80a6c9dcbc18b04a0346c)]:
    -   mobx-react-lite@3.1.3

## 7.0.2

### Patch Changes

-   [`5239db80`](https://github.com/mobxjs/mobx/commit/5239db80cf000026906c28a035725933d4dd6823) Thanks [@FredyC](https://github.com/FredyC)! - Fixed release with missing dist files

-   Updated dependencies [[`5239db80`](https://github.com/mobxjs/mobx/commit/5239db80cf000026906c28a035725933d4dd6823)]:
    -   mobx-react-lite@3.1.2

## 7.0.1

### Patch Changes

-   [`81a2f865`](https://github.com/mobxjs/mobx/commit/81a2f8654d9656e2e831176e45cbf926fbc364e0) Thanks [@FredyC](https://github.com/FredyC)! - ESM bundles without NODE_ENV present are available in dist folder. This useful for consumption in browser environment that supports ESM Choose either `esm.production.min.js` or `esm.development.js` from `dist` folder.

-   Updated dependencies [[`81a2f865`](https://github.com/mobxjs/mobx/commit/81a2f8654d9656e2e831176e45cbf926fbc364e0)]:
    -   mobx-react-lite@3.1.1

## 7.0.0

Release for compatibility with MobX v6

## 6.3.1

### Patch Changes

-   [`aa780c0`](https://github.com/mobxjs/mobx-react/commit/aa780c07162be99e198e7bbdbd6465c1f451f1d6) [#908](https://github.com/mobxjs/mobx-react/pull/908) Thanks [@FredyC](https://github.com/FredyC)! - Initial setup of [changesets](https://github.com/atlassian/changesets). No code changes present.

## 6.3.0

-   Updated mobx-react-lite to 2.2.0 which removes the need to manually configure batching. Fixes [#859](https://github.com/mobxjs/mobx-react/issues/859)

## 6.2.4

-   Fix error thrown in the already defined observer class component warning message when attempting to get the components display name. [#887](https://github.com/mobxjs/mobx-react/issues/887)

## 6.2.3

-   Log warning if class component is already an observer to prevent memory leaks. [#839](https://github.com/mobxjs/mobx-react/issues/839)
-   Fix disposeOnUnmount when using react-hot-loader. [#725](https://github.com/mobxjs/mobx-react/issues/725)

## 6.2.2

-   Observer batching imports are kept in production builds as side effects ([see issue](https://github.com/mobxjs/mobx-react-lite/issues/273))

## 6.2.1

-   Remove auto configured observer batching using react-dom. Fixes: [#852](https://github.com/mobxjs/mobx-react/issues/852).

## 6.2.0

-   Updated to latest mobx-react-lite V2 for compatibility with `React.StrictMode`.
-   Observer batching (see more [in the docs](https://github.com/mobxjs/mobx-react-lite/#observer-batching)).
-   Possibly breaking change, the `dist/mobxreact.rn.module.js` is no longer available, use `dist/mobxreact.esm.js` instead.

## 6.1.6 / 6.1.7

-   Fix an issue with class components & observableRequiresReaction. [#806](https://github.com/mobxjs/mobx-react/issues/806) through [#829](https://github.com/mobxjs/mobx-react/pull/829)
-   Use TSDX for building to mitigate issues with accessing `process.env` [#821](https://github.com/mobxjs/mobx-react/pull/821)

## 6.1.5

-   Added check if `process.env` is available, fixes [#801](https://github.com/mobxjs/mobx-react/issues/801) through [#812](https://github.com/mobxjs/mobx-react/pull/812) by [@ynejati](https://github.com/ynejati)
-   Added warning if component's `render` method is accidentally overwritten. [#799](https://github.com/mobxjs/mobx-react/pull/799) by [@Venryx](https://github.com/Venryx). Helps prevent memory leaks as in: [#797](https://github.com/mobxjs/mobx-react/issues/797)

## 6.1.4

-   Update dependency mobx-react-lite@1.4.2 which includes fix for [RN Fast Refresh](https://github.com/mobxjs/mobx-react-lite/issues/226)

## 6.1.2 / 6.1.3

-   Add reexport of `useObserver` from `mobx-react-lite` [#734](https://github.com/mobxjs/mobx-react/issues/734)
-   Add the ability to pass multiple children to Provider
-   Fixed [#717](https://github.com/mobxjs/mobx-react/issues/717). Now `inject` works correctly with components that use `React.forwardRef`
-   Observer checks for use of React.memo [#720](https://github.com/mobxjs/mobx-react/issues/720)
-   Get rid of the redundant Injector wrapper [#716](https://github.com/mobxjs/mobx-react/pull/716)

## 6.1.1

-   Fixed issue where combining `@disposeOnUnmount` with `disposeOnUnmount` didn't clean up everything. Fixes [#666](https://github.com/mobxjs/mobx-react/issues/666) trough [#671](https://github.com/mobxjs/mobx-react/pull/671) by [@JabX](https://github.com/JabX)

## 6.1.0

-   Restored the classic implementation of `observer`: class based components are patched again, rather than wrapping them in `<Observer>`, see [#703](https://github.com/mobxjs/mobx-react/pull/703). Fixes:
    -   `componentDidUpdate` not being triggered after a reactive render [#692](https://github.com/mobxjs/mobx-react/issues/692)
    -   The appearance of an additional `<Observer>` component in the component tree, which complicates shallow testing [#699](https://github.com/mobxjs/mobx-react/issues/699)
    -   Some regressions in `disposeOnUnmount` [#702](https://github.com/mobxjs/mobx-react/issues/702)
    -   Note that dev tool support, and other constraints mentioned in the 6.0.0 release notes have not been restored.
-   The function `useStaticRendering(value: boolean): void` from mobx-react-lite is now exposed

## 6.0.4

-   Fixed IE 11 compatibility which was accidentally broken. Fixes [#698](https://github.com/mobxjs/mobx-react/issues/698)

## 6.0.3

-   `disposeOnUnmount` now supports initializing it with an array of disposers. Fixes [#637](https://github.com/mobxjs/mobx-react/pull/637) through [#641](https://github.com/mobxjs/mobx-react/pull/641) by [@Amareis](https://github.com/Amareis)
-   Fixed hoisting of statically declared members. Fixes [#678](https://github.com/mobxjs/mobx-react/issues/678) through [#682](https://github.com/mobxjs/mobx-react/pull/682) by [@meabed](https://github.com/meabed)

## 6.0.2

-   Added missing types for `MobXProviderContext`, `useLocalStore` and `useAsObservableSource`. Fixes #679.

## 6.0.0

**Breaking changes**

-   The minimal supported version of React is 16.8.0
-   Killed the possibility to directly pass store names to `observer`. Always use `inject` instead. (This was deprecated for a long time already). `observer(["a", "b"], component)` should now be written as `inject("a", "b")(component)`.
-   `observer` components no longer automatically recover from errors (to prevent potential memory leaks). Instead, this is the responsibility of error boundaries.
-   `inject` now supports ref forwarding. As such, the `.wrappedInstance` property has been removed since refs can be used instead. (Fixes [#616](https://github.com/mobxjs/mobx-react/issues/616) (See also [#619](https://github.com/mobxjs/mobx-react/pull/619) by [42shadow42](https://github.com/42shadow42))
-   Changing the set of stores in `Provider` is no longer supported and while throw a hard error (this was a warning before), as the model of `Provider` / `inject` has always been designed to inject final values into the tree. (That is, constanted references, the injected objects themselves can be stateful without problem). If you want to dynamically swap what is provided into the tree, use `React.createContext` instead of `Provider` / `inject`. The suppressChangedStoreWarning`flag for`Provider` has been dropped.
-   The third argument of custom `storesToProps` functions passed to `inject` is no longer available.
-   `<Observer>` no longer supports the deprecated `inject` property.
-   Defining `shouldComponentUpdate` on `observer` based components is no longer supported
-   `propTypes` is no longer exposed, use `PropTypes` instead
-   `disposeOnUnmount` now only supports direct subclasses of `React.Component` and `React.PureComponent`. This prevents several unreliable edge cases that silently leaked memory before. Either only extend React.(Pure)Component when using `disposeOnUnmount`, or manually clean up stuff in `componentWillUnmount`.
-   The `onError` global error handler has been removed. Use error boundaries instead.
-   Improved dev tool names for `inject` wrapped components, see [#472](https://github.com/mobxjs/mobx-react/pull/472) by [SimeonC](https://github.com/SimeonC). Fixes [#466](https://github.com/mobxjs/mobx-react/issues/466)
-   Dropped support for a build of mobx-react that doesn't target either `react-dom` or `react-native`. mobx-react doesn't need `react-dom` to be present, but to make sure your build tools don't fail, you might want to stub `react-dom` as an empty module.
-   The `componentWillReact` has been dropped
-   The MobX-react devtools (either as package or browser plugin) are no longer supported. Instead, the following tools can be analyzed to analyze your mobx-react application:
    -   Visualizing re-rendering of components is now part of the standard React devtools
    -   The dependency tree of a compent tree can be inspected by showing the state of the `useObserver` hook in the React devtools (at the time of this release it displays as just `Object`, but the next iteration of the React devtools will support those properly)
    -   Spying on events can still be done with the [MobX-react browser plugin](https://github.com/mobxjs/mobx-devtools), through the [mobx-logger](https://github.com/winterbe/mobx-logger) package or manually by using the `spy` or `trace` utility from the mobx package.

**Improvements**

-   Hook based components are now supported by mobx-react (in fact, the package is now implemented using hooks)
-   Class based `observer` components are now _recommended_ to extend `React.PureComponent`. Functional `observer` components are now automatically wrapped in `React.memo` internally. See section in [README](https://mobx.js.org/README.html#observercomponentclass) for more details.
-   For `observer` based components, there will now be an additional `Observer` component in the tree.
-   Two new hooks have been exposed, in case you want to manage local state in observable: `useLocalStore` and `useAsObservableSource`.
-   `MobXProviderContext` is now exposed from the package, in case you want to consume the context used by `Provider` with a `useContext` hook.

## 5.4.3

-   Fixed [#612](https://github.com/mobxjs/mobx-react/issues/612), `contextType` was hoisted by `inject`, which shouldn't the case.

## 5.4.1 / 5.4.2

-   Fixed issue where `react-is` wasn't properly rolled-up into the package. Fixes [#608](https://github.com/mobxjs/mobx-react/issues/608)

## 5.4.0

-   Added support for forward refs, fixes [#602](https://github.com/mobxjs/mobx-react/issues/602)

## 5.3.6

-   Fixed some additional issues around life-cycle patching, take 3. See [#536](https://github.com/mobxjs/mobx-react/pull/586) by [@xaviergonz](https://github.com/xaviergonz). Fixed [#579](https://github.com/mobxjs/mobx-react/issues/579)

## 5.3.5

-   Fixed some additional issues around life-cycle patching, see [#583](https://github.com/mobxjs/mobx-react/pull/583) by [@xaviergonz](https://github.com/xaviergonz). Fixed [#581](https://github.com/mobxjs/mobx-react/issues/581)

## 5.3.4

-   Fixed unending recursing as a result of lifecylce patching. Fixes [#579](https://github.com/mobxjs/mobx-react/issues/579) through [#582](https://github.com/mobxjs/mobx-react/pull/582) by [@xaviergonz](https://github.com/xaviergonz)

## 5.3.3

-   Fixed `Cannot read property 'forEach' of undefined` exception if `disposeOnUnmount` was called conditionally. [#578](https://github.com/mobxjs/mobx-react/pull/578) by [Jef Hellemans](https://github.com/JefHellemans)

## 5.3.2

-   Fixed: "process not defined", [#574](https://github.com/mobxjs/mobx-react/pull/574/) through [#576](https://github.com/mobxjs/mobx-react/pull/576/) by [@xaviergonz](https://github.com/xaviergonz)

## 5.3.0 / 5.3.1

_5.3.0 was retracted as files were not generated correctly during publish_

-   Added `disposeOnUnmount` utility / decorator to call disposable properties (reaction, autorun, etc) automatically on `componentWillUnmount`
-   Introduced new method to patch lifecycle methods which should be more compatible with for example arrow functions.

## 5.2.8

-   Make sure `mobx-react` doesn't require `Object.assign` polyfill

## 5.2.7

-   Fixed issue where React 16.5 printed a warning when using `Provider`, fixes [#545](https://github.com/mobxjs/mobx-react/issues/545)

## 5.2.6

-   Fixed bug in defining properties (although the bug had no known observable effect). Fixes [#540](https://github.com/mobxjs/mobx-react/issues/540)

## 5.2.4 / 5.2.5

-   Improved compatibility with React-Hot-Loader, see [#522](https://github.com/mobxjs/mobx-react/pull/522) by [theKashey](https://github.com/theKashey). Fixes [#500](https://github.com/mobxjs/mobx-react/issues/500)

## 5.2.3

-   Fixed problem with `Symbol` feature detection. By [@Strate](https://github.com/Strate) through [#501](https://github.com/mobxjs/mobx-react/pull/501). Fixes [#498](https://github.com/mobxjs/mobx-react/issues/498) and [#503](https://github.com/mobxjs/mobx-react/issues/503).

## 5.2.2

-   Polyfill `Symbol` if it doesn't exist. By [@Strate](https://github.com/Strate) through [#499](https://github.com/mobxjs/mobx-react/pull/499).

## 5.2.1

-   Component `props` and `state` properties are now made observable during the instance creation. This restores the behavior from before 5.1.0 where `props` and `state` could safely be observed during mount. Actually it is now possible to do similar things in constructors as well. Fixes [#478](https://github.com/mobxjs/mobx-react/issues/478). Thanks [@Strate](https://github.com/Strate) for the idea and PR! [#496](https://github.com/mobxjs/mobx-react/pull/496).

## 5.2.0

-   Added backward compatible support for MobX 5.
-   Fixed components sometimes being displayed as `undefined` in mobx-devtools. See [#470](https://github.com/mobxjs/mobx-react/pull/470) by [@MauricioAndrades](https://github.com/MauricioAndrades)
-   Removed unnecessary warning `@observer` was used both on a sub and super class. See [#492](https://github.com/mobxjs/mobx-react/pull/476) by [@skiritsis](https://github.com/skiritsis). _N.B. putting `@observer` on a super and subclass is still not an supported pattern, use @observer on subclasses only!_

## 5.1.2

-   Fixed regression bug in integration with devtools. Fixed through [#465](https://github.com/mobxjs/mobx-react/pull/465) by @le0nik

## 5.1.0

-   Added support for React 16.3, including support for the `getDerivedStateFromProps` life-cycle hook. MobX will no longer use `componentWillMount` hook internally, so that it can be used in `StrictMode` react as well. Fixes [#447](https://github.com/mobxjs/mobx-react/issues/447)
-   Static properties of a function component are now automatically hoisted when the component is wrapped by `observer`. Implements [#427](https://github.com/mobxjs/mobx-react/pull/427)
-   Misspelled export `componentByNodeRegistery` is now properly export as `componentByNodeRegistry` as well, please update consumers, the mispelled version will be dropped in the next major. Fixes [#421](https://github.com/mobxjs/mobx-react/issues/421)
-   Deprecated the support for the `inject` property on `Observer`, it is fundamentally broken and should not be used. Use `inject` on the enclosing component instead and grab the necessary stores from the closure. Fixes [#423](https://github.com/mobxjs/mobx-react/issues/423)
-   Added warning about using `observer` on a React.PureComponent, this will become an exception in the next major. Fixes [#309](https://github.com/mobxjs/mobx-react/issues/309)
-   Mobx-react will now print a warning when combining `observer` with a custom `shouldComponentUpdate` implementation. Fixes [#417](https://github.com/mobxjs/mobx-react/issues/417)

## 5.0.0

-   Added compatibility with MobX 4.x. This version is not compatible with older Mobx versions

## 4.4.3

-   The exposed React Native build now uses commonjs, to prevent the need of further transpilation. Fixes [#428](https://github.com/mobxjs/mobx-react/issues/428)

## 4.4.2

-   Fixed issue with mobx-react not compiling on react-native due to the presence of a `.babelrc` file. Fixes [#415](https://github.com/mobxjs/mobx-react/issues/415) by [Ryan Rampersad](https://github.com/ryanmr) through [#416](https://github.com/mobxjs/mobx-react/pull/416)

## 4.4.1

-   Fixed syntax error in 4.4.0 that escaped

## 4.4.0

-   `Observer` now supports render props, `render` and `inject`. See the updated readme. By [ZiYingMai](https://github.com/Sunshine168) through [#403](https://github.com/mobxjs/mobx-react/pull/403)
-   Fixed: `NaN` is now considered to be equal to `NaN` when doing reconciliation. Fixes [#363](https://github.com/mobxjs/mobx-react/issues/363), by [Andrew Branch](https://github.com/andrewbranch) through [#402](https://github.com/mobxjs/mobx-react/pull/402)
-   Improved typings of `Observer` component, by [RafaÅ‚ Filipek](https://github.com/RafalFilipek) through [#376](https://github.com/mobxjs/mobx-react/pull/376)
-   Fixed incorrect generation of component name, by [Andy Kogut](https://github.com/andykog) through [#368](https://github.com/mobxjs/mobx-react/pull/368)
-   Lot of internal repo upgrades: Test suite is now in Jest, Prettier is used etc.

## 4.3.5

Fixed some issues with the typescript typings. See for example #353

## 4.3.4

Improved typescript typings, including support for `strict` mode in TS 2.6. Fixes

## 4.3.3

Added support for React 16. (No changes)

## 4.3.2

Killed accidentally exposed default exports.

If you are still using `import mobxReact from "mobx-react"`, use `import * as mobxReact from "mobx-react"`, or better `import { whatYouNeed } from "mobx-react"` instead.

## 4.3.1

## 4.3.0 (unpublished)

Improved module rollup setup, enabling better tree shaking. See #324 / #328

## 4.2.2

-   Fixed check for stateless components, by @leader22, see #280

## 4.2.1

_Note: Due to pull / rebase issue the release commit is incorrect. This is the released [commit](https://github.com/mobxjs/mobx-react/commit/f1b3eefc5239cb451b317204fa8aad94b4dcfc2f)_

-   Reduced module size by 31% (switched to rollup.js). See #244 by @rossipedia
-   Skip creation of `.wrappedInstance` reference for stateless components. See #254 by @farwayer
-   Introduced global `onError` handler hook to be notified on errors thrown by `@observer` components. See #262 by @andykog
-   Improved typescript typings of the exposed `propTypes`, See #263 by @panjiesw

## 4.2.0

-   Same as 4.2.1, but contained build issue and is unpublished

## 4.1.8

-   Undid change introduced in 4.1.4 where the lifecycle hooks were protected, as this breaks react-hot-loader.... Fixes #231

## 4.1.7

-   Added support for React 15.5 (no deprecation warnings) and 16.0 (no proptypes / createClass), by @andykog, see #238. Fixes #233, #237

## 4.1.5

-   Improved typescript typings, fixes #223

## 4.1.4

-   Made lifecycle hooks used by mobx-react read-only to make sure they are not accidentally overwritten in component instances. Fixes, #195, #202. Note that they can still be defined, just make sure to define them on the prototype (`componentWillMount() {}`) instead of the instance (`componentWillMount = () => {}`). Which is best practice anyway.

## 4.1.3

-   Fixed `ReactDOM.findDOMNode` exception when using react-test-runner, #216

## 4.1.2

-   Exceptions caught during render are now rethrown with proper stack, fixes #206

## 4.1.1

-   Exposed `wrappedInstance` and `wrappedComponent` in typings
-   Fixed accidental use of `default` import from `mobx` package.

## 4.1.0

-   Added support for MobX3. Note that using MobX3 changes the error semantics. If an `observer` component throws, it will no longer crash the app, but just log the exceptions instead.

## 4.0.4

-   Introduced `suppressChangedStoreWarning` to optionally supresss change store warnings, by @dropfen, see #182, #183

## 4.0.3

-   Fixed issue where userland componentWilMount was run before observer componentWillMount

## 4.0.2

-   Fixed order of `inject` overloads, see #169
-   Fixed import of `mobx` when using Webpack without commonjs plugin, see: #168

## 4.0.1

-   Improved typings, by @timmolendijk, fixes #164, #166
-   Fixed `inject` signature in readme, by @farwayer

## 4.0.0

### `observer` now uses shallow comparision for all props _(Breaking change)_

`observer` used to compare all properties shallow in the built-in _shouldComponentUpdate_, except when it received
non-observable data structures.
Because mobx-react cannot know whether a non observable has been deeply modified, it took no chances and just re-renders.

However, the downside of this when an unchanged, non-observable object is passed in to an observer component again, it would still cause a re-render.
Objects such as styling etc. To fix this mobx-react will now always compare all properties in a pure manner.
In general this should cause no trouble, as typically mutable data in mobx based objects is captured in observable objects, which will still cause components to re-render if needed.

If you need to pass in a deeply modified object and still want to make sure to cause a re-render, either

-   make sure the object / array is an observable
-   do not decorate your component with `observer`, but use `Observer` regions instead (see below)

See [#160](https://github.com/mobxjs/mobx-react/issues/160) for more details.

### `inject(fn)(component)` will now track `fn` as well

`inject(func)` is now reactive as well, that means that transformations in the selector function will be tracked, see [#111](https://github.com/mobxjs/mobx-react/issues/111)

```javascript
const NameDisplayer = ({ name }) => <h1>{name}</h1>

const UserNameDisplayer = inject(stores => ({
    name: stores.userStore.name
}))(NameDisplayer)

const user = mobx.observable({
    name: "Noa"
})

const App = () => (
    <Provider userStore={user}>
        <UserNameDisplayer />
    </Provider>
)

ReactDOM.render(<App />, document.body)
```

_N.B. note that in this specific case NameDisplayer doesn't have to be an `observer`, as it doesn't receive observables, but just plain data from the transformer function._

### `this.props` and `this.state` in React components are now observables as well

A common cause of confusion were cases like:

```javascript
@observer class MyComponent() {
    @computed upperCaseName() {
        return this.props.user.name.toUpperCase()
    }

    render() {
        return <h1>{this.upperCaseName}</h1>
    }
}
```

This component would re-render if `user.name` was modified, but it would still render the previous user's name if a complete new user was received!
The reason for that is that in the above example the only observable tracked by the computed value is `user.name`, but not `this.props.user`.
So a change to the first would be picked up, but a change in `props` itself, assigning a new user, not.

Although this is technically correct, it was a source of confusion.
For that reason `this.state` and `this.props` are now automatically converted to observables in any `observer` based react component.
For more details, see [#136](https://github.com/mobxjs/mobx-react/pull/136) by @Strate

### Better support for Server Side Rendering

Introduced `useStaticRendering(boolean)` to better support server-side rendering scenarios. See [#140](https://github.com/mobxjs/mobx-react/issues/140)

### Introduced `Observer` as alternative syntax to the `observer` decorator.

_This feature is still experimental and might change in the next minor release, or be deprecated_

Introduced `Observer`. Can be used as alternative to the `observer` decorator. Marks a component region as reactive.
See the Readme / [#138](https://github.com/mobxjs/mobx-react/issues/138)
Example:

```javascript
const UserNameDisplayer = ({ user }) => <Observer>{() => <div>{user.name}</div>}</Observer>
```

### Using `observer` to inject stores is deprecated

The fact that `observer` could inject stores as well caused quite some confusion.
Because in some cases `observer` would return the original component (when not inject), but it would return a HoC when injecting.
To make this more consistent, you should always use `inject` to inject stores into a component. So use:

```
@inject("store1", "store2") @observer
class MyComponent extends React.Component {
```

or:

```
const MyComponent = inject("store1", "store2")(observer(props => rendering))
```

For more info see the related [discussion](https://github.com/mobxjs/mobx-react/commit/666577b41b7af8209839e7b243064a31c9951632#commitcomment-19773706)

### Other improvements

-   If `mobx` and `mobx-react` are used in combination, all reactions are run as part of React's batched updates. This minimizes the work of the reconciler, guarantees optimal rendering order of components (if the rendering was not triggered from within a React event). Tnx @gkaemmer for the suggestion.
-   It is now possible to directly define `propTypes` and `defaultProps` on components wrapped with `inject` (or `observer(["stores"])`) again, see #120, #142. Removed the warnings for this, and instead improved the docs.
-   Clean up data subscriptions if an error is thrown by an `observer` component, see [#134](https://github.com/mobxjs/mobx-react/pull/134) by @andykog
-   export `PropTypes` as well in typescript typings, fixes #153
-   Add react as a peer dependency
-   Added minified browser build: `index.min.js`, fixes #147
-   Generate better component names when using `inject`

---

## 3.5.9

-   Print warning when `inject` and `observer` are used in the wrong order, see #146, by @delaetthomas

## 3.5.8

-   Fixed issue where `props` where not passed properly to components in very rare cases. Also fixed #115

## 3.5.7

-   Bundles are no longer minified, fixes #127

## 3.5.6

-   Export `propTypes` as `PropTypes`, like React (@andykog, ##117)

## 3.5.5

-   Removed `experimental` status of `inject` / `Provider`. Official feature now.
-   Fixed hot-reloading issue, #101

## 3.5.4

-   Introduced `wrappedInstance` by @rossipedia on `inject` decorated HOC's, see https://github.com/mobxjs/mobx-react/pull/90/
-   print warnings when assign values to `propTypes`, `defaultProps`, or `contextTypes` of a HOC. (by @jtraub, see https://github.com/mobxjs/mobx-react/pull/88/)
-   Static properties are now hoisted to HoC components when, #92
-   If `inject` is used incombination with a function, the object return from the function will now be merged into the `nextProps` instead of replacing them, #80
-   Always do propType checking untracked, partially fixes #56, #305

## 3.5.3

-   Fixed error `Cannot read property 'renderReporter' of undefined` (#96)

## 3.5.2

-   Added propTypes.observableArrayOf and propTypes.arrayOrObservableArrayOf (#91)

## 3.5.1

-   Fixed regression #85, changes caused by the constructor results in inconsistent rendering (N.B.: that is un-idiomatic React usage and React will warn about this!)

## 3.5.0

-   Introduced `inject("store1", "store2")(component)` as alternative syntax to inject stores. Should address #77, #70
-   Introduced the `wrappedComponent` property on injected higher order components, addresses #70, #72
-   Fixed #76: error when no stores are provided through context
-   Added typings for devTools related features (@benjamingr).
-   Added MobX specific propTypes (@mattruby)
-   Merged #44, fixes #73: don't re-render if component was somehow unmounted

## 3.4.0

-   Introduced `Provider` / context support (#53 / MobX #300)
-   Fixed issues when using devtools with IE. #66 (By @pvasek)

## 3.3.1

-   Added typescript typings form `mobx-react/native` and `mobx-react/custom`
-   Fixed #63: error when using stateless function components when using babel and typescript

## 3.3.0

-   Upgraded to MobX 2.2.0

## 3.2.0

-   Added support for react-native 0.25 and higher. By @danieldunderfelt.

## 3.1.0

-   Added support for custom renderers (without DOM), use: `mobx-react/custom` as import fixes #42
-   Fixed some issues with rollup #43
-   Minor optimization

## 3.0.5

Introduced `componentWillReact`

## 3.0.4

The debug name stateless function components of babel transpiled jsx are now properly picked up if the wrapper is applied after defining the component:

```javascript
const MyComponent = () => <span>hi</span>

export default observer(MyComponent)
```

## 3.0.3

Removed peer dependencies, React 15 (and 0.13) are supported as well. By @bkniffler

## 3.0.2

Removed the warning introduced in 3.0.1. It triggered always when using shallow rendering (when using shallow rendering `componentDidMount` won't fire. See https://github.com/facebook/react/issues/4919).

## 3.0.1

Added warning when changing state in `getInitialState` / `constructor`.

## 3.0.0

Upgraded to MobX 2.0.0

## 2.1.5

Improved typescript typings overloads of `observer`

## 2.1.4

Added empty 'dependencies' section to package.json, fixes #26

## 2.1.3

Added support for context to stateless components. (by Kosta-Github).

## 2.1.1

Fixed #12: fixed React warning when a component was unmounted after scheduling a re-render but before executing it.

## 2.1.0

Upped dependency of mobx to 1.1.1.

## 2.0.1

It is now possible to define `propTypes` and `getDefaultProps` on a stateless component:

```javascript
const myComponent = props => {
    // render
}

myComponent.propTypes = {
    name: React.PropTypes.string
}

myComponent.defaultProps = {
    name: "World"
}

export default observer(myComponent)
```

All credits to Jiri Spac for this contribution!

## 2.0.0

Use React 0.14 instead of React 0.13. For React 0.13, use version `mobx-react@1.0.2` or higher.

## 1.0.2

Minor fixes and improvements

## 1.0.1

Fixed issue with typescript typings. An example project with MobX, React, Typescript, TSX can be found here: https://github.com/mobxjs/mobx-react-typescript

## 1.0.0

`reactiveComponent` has been renamed to `observer`

### 0.2.3

Added separte import for react-native: use `var reactiveComponent = require('mobx-react/native').reactiveComponent` for native support; webpack clients will refuse to build otherwise.

### 0.2.2

Added react-native as dependency, so that the package works with either `react` or `react-native`.

### 0.2.0

Upgraded to MobX 0.7.0

### 0.1.7

Fixed issue where Babel generated component classes where not properly picked up.

### 0.1.6

`observer` now accepts a pure render function as argument, besides constructor function. For example:

```javascript
var TodoItem = observer(function TodoItem(props) {
    var todo = props.todo
    return <li>{todo.task}</li>
})
```

### 0.1.5

observer is now defined in terms of side effects.

### 0.1.4

Added support for React 0.14(RC) by dropping peer dependency



================================================
FILE: packages/mobx-react/jest.config.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    testRegex: "__tests__/.*\\.tsx$",
    setupFilesAfterEnv: [`<rootDir>/jest.setup.ts`],
    testPathIgnorePatterns: ["node_modules", "<rootDir>/__tests__/utils"]
})



================================================
FILE: packages/mobx-react/jest.setup.ts
================================================
import "@testing-library/jest-dom/extend-expect"
import { configure } from "mobx"

global.setImmediate = global.setImmediate || ((fn, ...args) => global.setTimeout(fn, 0, ...args))

configure({ enforceActions: "never" })

// @ts-ignore
global.__DEV__ = true



================================================
FILE: packages/mobx-react/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 Michel Weststrate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: packages/mobx-react/package.json
================================================
{
    "name": "mobx-react",
    "version": "9.2.0",
    "description": "React bindings for MobX. Create fully reactive components.",
    "source": "src/index.ts",
    "main": "dist/index.js",
    "umd:main": "dist/mobxreact.umd.production.min.js",
    "unpkg": "dist/mobxreact.umd.production.min.js",
    "jsdelivr": "dist/mobxreact.umd.production.min.js",
    "jsnext:main": "dist/mobxreact.esm.js",
    "module": "dist/mobxreact.esm.js",
    "react-native": "dist/mobxreact.esm.js",
    "types": "dist/index.d.ts",
    "typings": "dist/index.d.ts",
    "files": [
        "src",
        "dist",
        "LICENSE",
        "CHANGELOG.md",
        "README.md",
        "batching*"
    ],
    "sideEffects": false,
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git"
    },
    "author": "Michel Weststrate",
    "license": "MIT",
    "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mobx"
    },
    "bugs": {
        "url": "https://github.com/mobxjs/mobx/issues"
    },
    "homepage": "https://mobx.js.org",
    "dependencies": {
        "mobx-react-lite": "^4.1.0"
    },
    "peerDependencies": {
        "mobx": "^6.9.0",
        "react": "^16.8.0 || ^17 || ^18 || ^19"
    },
    "peerDependenciesMeta": {
        "react-dom": {
            "optional": true
        },
        "react-native": {
            "optional": true
        }
    },
    "devDependencies": {
        "mobx": "^6.12.2",
        "mobx-react-lite": "^4.1.0",
        "expose-gc": "^1.0.0"
    },
    "keywords": [
        "mobx",
        "mobservable",
        "react-component",
        "react",
        "reactjs",
        "reactive"
    ],
    "scripts": {
        "lint": "eslint src/**/* --ext .js,.ts,.tsx",
        "build": "node ../../scripts/build.js mobxReact",
        "build:test": "yarn build --target test",
        "test": "jest",
        "test:size": "yarn import-size --report . observer",
        "test:types": "tsc --noEmit",
        "test:check": "yarn test:types",
        "prepublishOnly": "yarn build --target publish"
    }
}



================================================
FILE: packages/mobx-react/tsconfig.json
================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
        "rootDir": "src",
        "lib": ["es6", "DOM"]
    },
    "include": ["src"]
}



================================================
FILE: packages/mobx-react/tsconfig.test.json
================================================
{
    "extends": "../../tsconfig.test.json",
    "compilerOptions": {
        "lib": ["esnext", "dom"]
    }
}



================================================
FILE: packages/mobx-react/tsdx.config.js
================================================
module.exports = {
    rollup(config) {
        return {
            ...config,
            output: {
                ...config.output,
                globals: {
                    react: "React",
                    mobx: "mobx",
                    "react-dom": "ReactDOM",
                    "mobx-react-lite": "mobxReactLite"
                }
            }
        }
    }
}



================================================
FILE: packages/mobx-react/.browserlistrc
================================================
{
    "targets": {
        "chrome": "58",
        "ie": "9"
    }
}



================================================
FILE: packages/mobx-react/__mocks__/react-native.js
================================================
[Empty file]


================================================
FILE: packages/mobx-react/__tests__/context.test.tsx
================================================
import React from "react"
import { observable } from "mobx"
import { Provider, observer, inject } from "../src"
import { withConsole } from "./utils/withConsole"
import { render, act } from "@testing-library/react"
import { any } from "prop-types"

test("no warnings in modern react", () => {
    const box = observable.box(3)
    const Child = inject("store")(
        observer(
            class Child extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            {this.props.store} + {box.get()}
                        </div>
                    )
                }
            }
        )
    )

    class App extends React.Component {
        render() {
            return (
                <div>
                    <React.StrictMode>
                        <Provider store="42">
                            <Child />
                        </Provider>
                    </React.StrictMode>
                </div>
            )
        }
    }

    const { container } = render(<App />)
    expect(container).toHaveTextContent("42 + 3")

    withConsole(["info", "warn", "error"], () => {
        act(() => {
            box.set(4)
        })
        expect(container).toHaveTextContent("42 + 4")

        expect(console.info).not.toHaveBeenCalled()
        expect(console.warn).not.toHaveBeenCalled()
        expect(console.error).not.toHaveBeenCalled()
    })
})

test("getDerivedStateFromProps works #447", () => {
    class Main extends React.Component<any, any> {
        static getDerivedStateFromProps(nextProps, prevState) {
            return {
                count: prevState.count + 1
            }
        }

        state = {
            count: 0
        }

        render() {
            return (
                <div>
                    <h2>{`${this.state.count ? "One " : "No "}${this.props.thing}`}</h2>
                </div>
            )
        }
    }

    const MainInjected = inject(({ store }: { store: { thing: number } }) => ({ thing: store.thing }))(Main)

    const store = { thing: 3 }

    const App = () => (
        <Provider store={store}>
            <MainInjected />
        </Provider>
    )

    const { container } = render(<App />)
    expect(container).toHaveTextContent("One 3")
})

test("no double runs for getDerivedStateFromProps", () => {
    let derived = 0
    @observer
    class Main extends React.Component<any, any> {
        state = {
            activePropertyElementMap: {}
        }

        constructor(props) {
            // console.log("CONSTRUCTOR")
            super(props)
        }

        static getDerivedStateFromProps() {
            derived++
            // console.log("PREVSTATE", nextProps)
            return null
        }

        render() {
            return <div>Test-content</div>
        }
    }
    // This results in
    //PREVSTATE
    //CONSTRUCTOR
    //PREVSTATE
    let MainInjected = inject(() => ({
        componentProp: "def"
    }))(Main)
    // Uncomment the following line to see default behaviour (without inject)
    //CONSTRUCTOR
    //PREVSTATE
    //MainInjected = Main;

    const store = {}

    const App = () => (
        <Provider store={store}>
            <MainInjected injectedProp={"abc"} />
        </Provider>
    )

    const { container } = render(<App />)
    expect(container).toHaveTextContent("Test-content")
    expect(derived).toBe(1)
})



================================================
FILE: packages/mobx-react/__tests__/disposeOnUnmount.test.tsx
================================================
import React from "react"
import { disposeOnUnmount, observer } from "../src"
import { render } from "@testing-library/react"
import { MockedComponentClass } from "react-dom/test-utils"

interface ClassC extends MockedComponentClass {
    methodA?: any
    methodB?: any
    methodC?: any
    methodD?: any
}

function testComponent(C: ClassC, afterMount?: Function, afterUnmount?: Function) {
    const ref = React.createRef<ClassC>()
    const { unmount } = render(<C ref={ref} />)

    let cref = ref.current
    expect(cref?.methodA).not.toHaveBeenCalled()
    expect(cref?.methodB).not.toHaveBeenCalled()
    if (afterMount) {
        afterMount(cref)
    }

    unmount()

    expect(cref?.methodA).toHaveBeenCalledTimes(1)
    expect(cref?.methodB).toHaveBeenCalledTimes(1)
    if (afterUnmount) {
        afterUnmount(cref)
    }
}

describe("without observer", () => {
    test("class without componentWillUnmount", async () => {
        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }
        }

        testComponent(C)
    })

    test("class with componentWillUnmount in the prototype", () => {
        let called = 0

        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }

            componentWillUnmount() {
                called++
            }
        }

        testComponent(
            C,
            () => {
                expect(called).toBe(0)
            },
            () => {
                expect(called).toBe(1)
            }
        )
    })

    test.skip("class with componentWillUnmount as an arrow function", () => {
        let called = 0

        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }

            componentWillUnmount = () => {
                called++
            }
        }

        testComponent(
            C,
            () => {
                expect(called).toBe(0)
            },
            () => {
                expect(called).toBe(1)
            }
        )
    })

    test("class without componentWillUnmount using non decorator version", () => {
        let methodC = jest.fn()
        let methodD = jest.fn()
        class C extends React.Component {
            render() {
                return null
            }

            methodA = disposeOnUnmount(this, jest.fn())
            methodB = disposeOnUnmount(this, jest.fn())

            constructor(props) {
                super(props)
                disposeOnUnmount(this, [methodC, methodD])
            }
        }

        testComponent(
            C,
            () => {
                expect(methodC).not.toHaveBeenCalled()
                expect(methodD).not.toHaveBeenCalled()
            },
            () => {
                expect(methodC).toHaveBeenCalledTimes(1)
                expect(methodD).toHaveBeenCalledTimes(1)
            }
        )
    })
})

describe("with observer", () => {
    test("class without componentWillUnmount", () => {
        @observer
        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }
        }

        testComponent(C)
    })

    test("class with componentWillUnmount in the prototype", () => {
        let called = 0

        @observer
        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }

            componentWillUnmount() {
                called++
            }
        }

        testComponent(
            C,
            () => {
                expect(called).toBe(0)
            },
            () => {
                expect(called).toBe(1)
            }
        )
    })

    test.skip("class with componentWillUnmount as an arrow function", () => {
        let called = 0

        @observer
        class C extends React.Component {
            @disposeOnUnmount
            methodA = jest.fn()
            @disposeOnUnmount
            methodB = jest.fn()
            @disposeOnUnmount
            methodC = null
            @disposeOnUnmount
            methodD = undefined

            render() {
                return null
            }

            componentWillUnmount = () => {
                called++
            }
        }

        testComponent(
            C,
            () => {
                expect(called).toBe(0)
            },
            () => {
                expect(called).toBe(1)
            }
        )
    })

    test("class without componentWillUnmount using non decorator version", () => {
        let methodC = jest.fn()
        let methodD = jest.fn()

        @observer
        class C extends React.Component {
            render() {
                return null
            }

            methodA = disposeOnUnmount(this, jest.fn())
            methodB = disposeOnUnmount(this, jest.fn())

            constructor(props) {
                super(props)
                disposeOnUnmount(this, [methodC, methodD])
            }
        }

        testComponent(
            C,
            () => {
                expect(methodC).not.toHaveBeenCalled()
                expect(methodD).not.toHaveBeenCalled()
            },
            () => {
                expect(methodC).toHaveBeenCalledTimes(1)
                expect(methodD).toHaveBeenCalledTimes(1)
            }
        )
    })
})

it("componentDidMount should be different between components", () => {
    function doTest(withObserver) {
        const events: Array<string> = []

        class A extends React.Component {
            didMount
            willUnmount

            componentDidMount() {
                this.didMount = "A"
                events.push("mountA")
            }

            componentWillUnmount() {
                this.willUnmount = "A"
                events.push("unmountA")
            }

            render() {
                return null
            }
        }

        class B extends React.Component {
            didMount
            willUnmount

            componentDidMount() {
                this.didMount = "B"
                events.push("mountB")
            }

            componentWillUnmount() {
                this.willUnmount = "B"
                events.push("unmountB")
            }

            render() {
                return null
            }
        }

        if (withObserver) {
            // @ts-ignore
            // eslint-disable-next-line no-class-assign
            A = observer(A)
            // @ts-ignore
            // eslint-disable-next-line no-class-assign
            B = observer(B)
        }

        const aRef = React.createRef<A>()
        const { rerender, unmount } = render(<A ref={aRef} />)
        const caRef = aRef.current

        expect(caRef?.didMount).toBe("A")
        expect(caRef?.willUnmount).toBeUndefined()
        expect(events).toEqual(["mountA"])

        const bRef = React.createRef<B>()
        rerender(<B ref={bRef} />)
        const cbRef = bRef.current

        expect(caRef?.didMount).toBe("A")
        expect(caRef?.willUnmount).toBe("A")

        expect(cbRef?.didMount).toBe("B")
        expect(cbRef?.willUnmount).toBeUndefined()
        expect(events).toEqual(["mountA", "unmountA", "mountB"])

        unmount()

        expect(caRef?.didMount).toBe("A")
        expect(caRef?.willUnmount).toBe("A")

        expect(cbRef?.didMount).toBe("B")
        expect(cbRef?.willUnmount).toBe("B")
        expect(events).toEqual(["mountA", "unmountA", "mountB", "unmountB"])
    }

    doTest(true)
    doTest(false)
})

test("base cWU should not be called if overridden", () => {
    let baseCalled = 0
    let dCalled = 0
    let oCalled = 0

    class C extends React.Component {
        componentWillUnmount() {
            baseCalled++
        }

        constructor(props) {
            super(props)
            this.componentWillUnmount = () => {
                oCalled++
            }
        }

        render() {
            return null
        }

        @disposeOnUnmount
        fn() {
            dCalled++
        }
    }
    const { unmount } = render(<C />)
    unmount()
    expect(dCalled).toBe(1)
    expect(oCalled).toBe(1)
    expect(baseCalled).toBe(0)
})

test("should error on inheritance", () => {
    class C extends React.Component {
        render() {
            return null
        }
    }

    expect(() => {
        // eslint-disable-next-line no-unused-vars
        class B extends C {
            @disposeOnUnmount
            fn() {}
        }
    }).toThrow("disposeOnUnmount only supports direct subclasses")
})

test("should error on inheritance - 2", () => {
    class C extends React.Component {
        render() {
            return null
        }
    }

    class B extends C {
        fn
        constructor(props) {
            super(props)
            expect(() => {
                this.fn = disposeOnUnmount(this, function () {})
            }).toThrow("disposeOnUnmount only supports direct subclasses")
        }
    }

    render(<B />)
})

describe("should work with arrays", () => {
    test("as a function", () => {
        class C extends React.Component {
            methodA = jest.fn()
            methodB = jest.fn()

            componentDidMount() {
                disposeOnUnmount(this, [this.methodA, this.methodB])
            }

            render() {
                return null
            }
        }

        testComponent(C)
    })

    test("as a decorator", () => {
        class C extends React.Component {
            methodA = jest.fn()
            methodB = jest.fn()

            @disposeOnUnmount
            disposers = [this.methodA, this.methodB]

            render() {
                return null
            }
        }

        testComponent(C)
    })
})

it("runDisposersOnUnmount only runs disposers from the declaring instance", () => {
    class A extends React.Component {
        @disposeOnUnmount
        a = jest.fn()

        b = jest.fn()

        constructor(props) {
            super(props)
            disposeOnUnmount(this, this.b)
        }

        render() {
            return null
        }
    }

    const ref1 = React.createRef<A>()
    const ref2 = React.createRef<A>()
    const { unmount } = render(<A ref={ref1} />)
    render(<A ref={ref2} />)
    const inst1 = ref1.current
    const inst2 = ref2.current
    unmount()

    expect(inst1?.a).toHaveBeenCalledTimes(1)
    expect(inst1?.b).toHaveBeenCalledTimes(1)
    expect(inst2?.a).toHaveBeenCalledTimes(0)
    expect(inst2?.b).toHaveBeenCalledTimes(0)
})



================================================
FILE: packages/mobx-react/__tests__/finalizationRegistry.tsx
================================================
import { cleanup, render, waitFor } from "@testing-library/react"
import * as mobx from "mobx"
import * as React from "react"

// @ts-ignore
import gc from "expose-gc/function"
import { observer } from "../src"

afterEach(cleanup)

test("should not prevent GC of uncomitted components", async () => {
    expect(typeof globalThis.FinalizationRegistry).toBe("function")

    // This specific setup causes first instance of A not being commited.
    // This is checked by comparing constructor and componentDidMount invocation counts.
    // There is no profound reason why that's the case, if you know a simpler or more robust setup
    // feel free to change this.

    const o = mobx.observable({ x: 0 })
    let aConstructorCount = 0
    let aMountCount = 0

    let firstARef: WeakRef<React.Component>

    @observer
    class A extends React.Component<any> {
        constructor(props) {
            super(props)
            if (aConstructorCount === 0) {
                firstARef = new WeakRef(this)
            }
            aConstructorCount++
        }
        componentDidMount(): void {
            aMountCount++
        }
        render() {
            return (
                <React.Suspense fallback="fallback">
                    <LazyB />
                    {o.x}
                </React.Suspense>
            )
        }
    }

    class B extends React.Component {
        render() {
            return "B"
        }
    }

    const LazyA = React.lazy(() => Promise.resolve({ default: A }))
    const LazyB = React.lazy(() => Promise.resolve({ default: B }))

    function App() {
        return (
            <React.Suspense fallback="fallback">
                <LazyA />
            </React.Suspense>
        )
    }

    const { unmount, container } = render(<App />)

    expect(container).toHaveTextContent("fallback")
    await waitFor(() => expect(container).toHaveTextContent("B0"))
    expect(aConstructorCount).toBe(2)
    expect(aMountCount).toBe(1)

    await Promise.resolve()
    gc()
    await waitFor(() => expect(firstARef!.deref()).toBeUndefined(), {
        timeout: 10_000,
        interval: 150
    })

    unmount()
})



================================================
FILE: packages/mobx-react/__tests__/hooks.test.tsx
================================================
import React from "react"
import { observer, Observer, useLocalStore, useAsObservableSource } from "../src"
import { render, act } from "@testing-library/react"

afterEach(() => {
    jest.useRealTimers()
})

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

test("computed properties react to props when using hooks", async () => {
    jest.useFakeTimers()
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

    const seen: Array<string> = []

    const Child = ({ x }) => {
        const props = useAsObservableSource({ x })
        const store = useLocalStore(() => ({
            get getPropX() {
                return props.x
            }
        }))

        return (
            <Observer>{() => (seen.push(store.getPropX), (<div>{store.getPropX}</div>))}</Observer>
        )
    }

    const Parent = () => {
        const [state, setState] = React.useState({ x: 0 })
        seen.push("parent")
        React.useEffect(() => {
            setTimeout(() => {
                act(() => {
                    setState({ x: 2 })
                })
            })
        }, [])
        return <Child x={state.x} />
    }

    const { container } = render(<Parent />)
    expect(container).toHaveTextContent("0")

    act(() => {
        jest.runAllTimers()
    })
    expect(seen).toEqual(["parent", 0, "parent", 2, 2])
    expect(container).toHaveTextContent("2")
    expect(consoleWarnMock).toMatchSnapshot()
})

test("computed properties result in double render when using observer instead of Observer", async () => {
    jest.useFakeTimers()

    const seen: Array<string> = []

    const Child = observer(({ x }) => {
        const props = useAsObservableSource({ x })
        const store = useLocalStore(() => ({
            get getPropX() {
                return props.x
            }
        }))

        seen.push(store.getPropX)
        return <div>{store.getPropX}</div>
    })

    const Parent = () => {
        const [state, setState] = React.useState({ x: 0 })
        seen.push("parent")
        React.useEffect(() => {
            setTimeout(() => {
                act(() => {
                    setState({ x: 2 })
                })
            }, 100)
        }, [])
        return <Child x={state.x} />
    }

    const { container } = render(<Parent />)
    expect(container).toHaveTextContent("0")

    act(() => {
        jest.runAllTimers()
    })
    expect(seen).toEqual([
        "parent",
        0,
        "parent",
        2, // props changed
        2 // observable source changed (setState during render)
    ])
    expect(container).toHaveTextContent("2")
})



================================================
FILE: packages/mobx-react/__tests__/inject.test.tsx
================================================
import React from "react"
import PropTypes from "prop-types"
import { action, observable, makeObservable } from "mobx"
import { observer, inject, Provider } from "../src"
import { IValueMap } from "../src/types/IValueMap"
import { render, act } from "@testing-library/react"
import { withConsole } from "./utils/withConsole"
import { IReactComponent } from "../src/types/IReactComponent"

describe("inject based context", () => {
    test("basic context", () => {
        const C = inject("foo")(
            observer(
                class X extends React.Component<any, any> {
                    render() {
                        return (
                            <div>
                                context:
                                {this.props.foo}
                            </div>
                        )
                    }
                }
            )
        )
        const B = () => <C />
        const A = () => (
            <Provider foo="bar">
                <B />
            </Provider>
        )
        const { container } = render(<A />)
        expect(container).toHaveTextContent("context:bar")
    })

    test("props override context", () => {
        const C = inject("foo")(
            class T extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        const B = () => <C foo={42} />
        const A = class T extends React.Component<any, any> {
            render() {
                return (
                    <Provider foo="bar">
                        <B />
                    </Provider>
                )
            }
        }
        const { container } = render(<A />)
        expect(container).toHaveTextContent("context:42")
    })

    test("wraps displayName of original component", () => {
        const A: React.ComponentClass = inject("foo")(
            class ComponentA extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        const B: React.ComponentClass = inject()(
            class ComponentB extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        const C: React.ComponentClass = inject(() => ({}))(
            class ComponentC extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        expect(A.displayName).toBe("inject-with-foo(ComponentA)")
        expect(B.displayName).toBe("inject(ComponentB)")
        expect(C.displayName).toBe("inject(ComponentC)")
    })

    test("shouldn't change original displayName of component that uses forwardRef", () => {
        const FancyComp = React.forwardRef((_: any, ref: React.Ref<HTMLDivElement>) => {
            return <div ref={ref} />
        })
        FancyComp.displayName = "FancyComp"

        inject("bla")(FancyComp)

        expect(FancyComp.displayName).toBe("FancyComp")
    })

    // FIXME: see other comments related to error catching in React
    // test does work as expected when running manually
    test("store should be available", () => {
        const C = inject("foo")(
            observer(
                class C extends React.Component<any, any> {
                    render() {
                        return (
                            <div>
                                context:
                                {this.props.foo}
                            </div>
                        )
                    }
                }
            )
        )
        const B = () => <C />
        const A = class A extends React.Component<any, any> {
            render() {
                return (
                    <Provider baz={42}>
                        <B />
                    </Provider>
                )
            }
        }

        withConsole(() => {
            expect(() => render(<A />)).toThrow(
                /Store 'foo' is not available! Make sure it is provided by some Provider/
            )
        })
    })

    test("store is not required if prop is available", () => {
        const C = inject("foo")(
            observer(
                class C extends React.Component<any, any> {
                    render() {
                        return (
                            <div>
                                context:
                                {this.props.foo}
                            </div>
                        )
                    }
                }
            )
        )
        const B = () => <C foo="bar" />
        const { container } = render(<B />)
        expect(container).toHaveTextContent("context:bar")
    })

    test("inject merges (and overrides) props", () => {
        const C = inject(() => ({ a: 1 }))(
            observer(
                class C extends React.Component<any, any> {
                    render() {
                        expect(this.props).toEqual({ a: 1, b: 2 })
                        return null
                    }
                }
            )
        )
        const B = () => <C a={2} b={2} />
        render(<B />)
    })

    test("custom storesToProps", () => {
        const C = inject((stores: IValueMap, props: any) => {
            expect(stores).toEqual({ foo: "bar" })
            expect(props).toEqual({ baz: 42 })
            return {
                zoom: stores.foo,
                baz: props.baz * 2
            }
        })(
            observer(
                class C extends React.Component<any, any> {
                    render() {
                        return (
                            <div>
                                context:
                                {this.props.zoom}
                                {this.props.baz}
                            </div>
                        )
                    }
                }
            )
        )
        const B = class B extends React.Component<any, any> {
            render() {
                return <C baz={42} />
            }
        }
        const A = () => (
            <Provider foo="bar">
                <B />
            </Provider>
        )
        const { container } = render(<A />)
        expect(container).toHaveTextContent("context:bar84")
    })

    test("inject forwards ref", () => {
        class FancyComp extends React.Component<any, any> {
            didRender
            render() {
                this.didRender = true
                return null
            }

            doSomething() {}
        }

        const ref = React.createRef<FancyComp>()
        render(<FancyComp ref={ref} />)
        expect(typeof ref.current?.doSomething).toBe("function")
        expect(ref.current?.didRender).toBe(true)

        const InjectedFancyComp = inject("bla")(FancyComp)
        const ref2 = React.createRef<FancyComp>()

        render(
            <Provider bla={42}>
                <InjectedFancyComp ref={ref2} />
            </Provider>
        )

        expect(typeof ref2.current?.doSomething).toBe("function")
        expect(ref2.current?.didRender).toBe(true)
    })

    test("inject should work with components that use forwardRef", () => {
        const FancyComp = React.forwardRef((_: any, ref: React.Ref<HTMLDivElement>) => {
            return <div ref={ref} />
        })

        const InjectedFancyComp = inject("bla")(FancyComp)
        const ref = React.createRef<HTMLDivElement>()

        render(
            <Provider bla={42}>
                <InjectedFancyComp ref={ref} />
            </Provider>
        )

        expect(ref.current).not.toBeNull()
        expect(ref.current).toBeInstanceOf(HTMLDivElement)
    })

    test("support static hoisting, wrappedComponent and ref forwarding", () => {
        class B extends React.Component<any, any> {
            static foo
            static bar
            testField

            render() {
                this.testField = 1
                return null
            }
        }
        ;(B as React.ComponentClass).propTypes = {
            x: PropTypes.object
        }
        B.foo = 17
        B.bar = {}
        const C = inject("booh")(B)
        expect(C.wrappedComponent).toBe(B)
        expect(B.foo).toBe(17)
        expect(C.foo).toBe(17)
        expect(C.bar === B.bar).toBeTruthy()
        expect(Object.keys(C.wrappedComponent.propTypes!)).toEqual(["x"])

        const ref = React.createRef<B>()

        render(<C booh={42} ref={ref} />)
        expect(ref.current?.testField).toBe(1)
    })

    // skipping because `propTypes` and `defaultProps` are dropped in React 19
    test.skip("propTypes and defaultProps are forwarded", () => {
        const msg: Array<string> = []
        const baseError = console.error
        console.error = m => msg.push(m)

        const C: React.ComponentClass<any> = inject("foo")(
            class C extends React.Component<any, any> {
                render() {
                    expect(this.props.y).toEqual(3)

                    expect(this.props.x).toBeUndefined()
                    return null
                }
            }
        )
        C.propTypes = {
            x: PropTypes.func.isRequired,
            z: PropTypes.string.isRequired
        }
        // @ts-ignore
        C.wrappedComponent.propTypes = {
            a: PropTypes.func.isRequired
        }
        C.defaultProps = {
            y: 3
        }
        const B = () => <C z="test" />
        const A = () => (
            <Provider foo="bar">
                <B />
            </Provider>
        )
        render(<A />)
        expect(msg.length).toBe(2)
        // ! Somehow this got broken with upgraded deps and wasn't worth fixing it :)
        // expect(msg[0].split("\n")[0]).toBe(
        //     "Warning: Failed prop type: The prop `x` is marked as required in `inject-with-foo(C)`, but its value is `undefined`."
        // )
        // expect(msg[1].split("\n")[0]).toBe(
        //     "Warning: Failed prop type: The prop `a` is marked as required in `C`, but its value is `undefined`."
        // )
        console.error = baseError
    })

    test("warning is not printed when attaching propTypes to injected component", () => {
        let msg = []
        const baseWarn = console.warn
        console.warn = m => (msg = m)

        const C: React.ComponentClass = inject("foo")(
            class C extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        C.propTypes = {}

        expect(msg.length).toBe(0)
        console.warn = baseWarn
    })

    test("warning is not printed when attaching propTypes to wrappedComponent", () => {
        let msg = []
        const baseWarn = console.warn
        console.warn = m => (msg = m)
        const C = inject("foo")(
            class C extends React.Component<any, any> {
                render() {
                    return (
                        <div>
                            context:
                            {this.props.foo}
                        </div>
                    )
                }
            }
        )
        C.wrappedComponent.propTypes = {}
        expect(msg.length).toBe(0)
        console.warn = baseWarn
    })

    test("using a custom injector is reactive", () => {
        const user = observable({ name: "Noa" })
        const mapper = stores => ({ name: stores.user.name })
        const DisplayName = props => <h1>{props.name}</h1>
        const User = inject(mapper)(DisplayName)
        const App = () => (
            <Provider user={user}>
                <User />
            </Provider>
        )
        const { container } = render(<App />)
        expect(container).toHaveTextContent("Noa")

        act(() => {
            user.name = "Veria"
        })
        expect(container).toHaveTextContent("Veria")
    })

    test("using a custom injector is not too reactive", () => {
        let listRender = 0
        let itemRender = 0
        let injectRender = 0

        function connect() {
            const args = arguments
            return (component: IReactComponent) =>
                // @ts-ignore
                inject.apply(this, args)(observer(component))
        }

        class State {
            @observable
            highlighted = null
            isHighlighted(item) {
                return this.highlighted == item
            }

            @action
            highlight = item => {
                this.highlighted = item
            }

            constructor() {
                makeObservable(this)
            }
        }

        const items = observable([
            { title: "ItemA" },
            { title: "ItemB" },
            { title: "ItemC" },
            { title: "ItemD" },
            { title: "ItemE" },
            { title: "ItemF" }
        ])

        const state = new State()

        class ListComponent extends React.PureComponent<any> {
            render() {
                listRender++
                const { items } = this.props

                return (
                    <ul>
                        {items.map(item => (
                            <ItemComponent key={item.title} item={item} />
                        ))}
                    </ul>
                )
            }
        }

        // @ts-ignore
        @connect(({ state }, { item }) => {
            injectRender++
            if (injectRender > 6) {
                // debugger;
            }
            return {
                // Using
                // highlighted: expr(() => state.isHighlighted(item)) // seems to fix the problem
                highlighted: state.isHighlighted(item),
                highlight: state.highlight
            }
        })
        class ItemComponent extends React.PureComponent<any> {
            highlight = () => {
                const { item, highlight } = this.props
                highlight(item)
            }

            render() {
                itemRender++
                const { highlighted, item } = this.props
                return (
                    <li className={"hl_" + item.title} onClick={this.highlight}>
                        {item.title} {highlighted ? "(highlighted)" : ""}{" "}
                    </li>
                )
            }
        }

        const { container } = render(
            <Provider state={state}>
                <ListComponent items={items} />
            </Provider>
        )

        expect(listRender).toBe(1)
        expect(injectRender).toBe(6)
        expect(itemRender).toBe(6)

        act(() => {
            container
                .querySelectorAll(".hl_ItemB")
                .forEach((e: Element) => (e as HTMLElement).click())
        })

        expect(listRender).toBe(1)
        expect(injectRender).toBe(12) // ideally, 7
        expect(itemRender).toBe(7)
        act(() => {
            container
                .querySelectorAll(".hl_ItemF")
                .forEach((e: Element) => (e as HTMLElement).click())
        })

        expect(listRender).toBe(1)
        expect(injectRender).toBe(18) // ideally, 9
        expect(itemRender).toBe(9)
    })
})

test("#612 - mixed context types", () => {
    const SomeContext = React.createContext(true)

    class MainCompClass extends React.Component<any, any> {
        static contextType = SomeContext
        render() {
            let active = this.context
            return active ? this.props.value : "Inactive"
        }
    }

    const MainComp = inject((stores: any) => ({
        value: stores.appState.value
    }))(MainCompClass)

    const appState = observable({
        value: "Something"
    })

    function App() {
        return (
            <Provider appState={appState}>
                <SomeContext.Provider value={true}>
                    <MainComp />
                </SomeContext.Provider>
            </Provider>
        )
    }

    render(<App />)
})



================================================
FILE: packages/mobx-react/__tests__/issue21.test.tsx
================================================
import React, { createElement } from "react"
import {
    computed,
    isObservable,
    observable,
    reaction,
    transaction,
    IReactionDisposer,
    makeObservable
} from "mobx"
import { observer } from "../src"
import _ from "lodash"
import { act, render } from "@testing-library/react"

let topRenderCount = 0

const wizardModel = observable(
    {
        steps: [
            {
                title: "Size",
                active: true
            },
            {
                title: "Fabric",
                active: false
            },
            {
                title: "Finish",
                active: false
            }
        ],
        get activeStep() {
            return _.find(this.steps, "active")
        },
        activateNextStep: function () {
            const nextStep = this.steps[_.findIndex(this.steps, "active") + 1]
            if (!nextStep) {
                return false
            }
            this.setActiveStep(nextStep)
            return true
        },
        setActiveStep(modeToActivate) {
            const self = this
            transaction(() => {
                _.find(self.steps, "active").active = false
                modeToActivate.active = true
            })
        }
    } as any,
    {
        activateNextStep: observable.ref
    }
)

/** RENDERS **/

const Wizard = observer(
    class Wizard extends React.Component<any, any> {
        render() {
            return createElement(
                "div",
                null,
                <div>
                    <h1>Active Step: </h1>
                    <WizardStep step={this.props.model.activeStep} key="activeMode" tester />
                </div>,
                <div>
                    <h1>All Step: </h1>
                    <p>
                        Clicking on these steps will render the active step just once. This is what
                        I expected.
                    </p>
                    <WizardStep step={this.props.model.steps} key="modeList" />
                </div>
            )
        }
    }
)

const WizardStep = observer(
    class WizardStep extends React.Component<any, any> {
        renderCount = 0
        componentWillUnmount() {
            // console.log("Unmounting!")
        }
        render() {
            // weird test hack:
            if (this.props.tester === true) {
                topRenderCount++
            }
            return createElement(
                "div",
                { onClick: this.modeClickHandler },
                "RenderCount: " +
                    this.renderCount++ +
                    " " +
                    this.props.step.title +
                    ": isActive:" +
                    this.props.step.active
            )
        }
        modeClickHandler = () => {
            var step = this.props.step
            wizardModel.setActiveStep(step)
        }
    }
)

/** END RENDERERS **/

const changeStep = stepNumber => act(() => wizardModel.setActiveStep(wizardModel.steps[stepNumber]))

test("verify issue 21", () => {
    render(<Wizard model={wizardModel} />)
    expect(topRenderCount).toBe(1)
    changeStep(0)
    expect(topRenderCount).toBe(2)
    changeStep(2)
    expect(topRenderCount).toBe(3)
})

test("verify prop changes are picked up", () => {
    function createItem(subid, label) {
        const res = observable(
            {
                subid,
                id: 1,
                label: label,
                get text() {
                    events.push(["compute", this.subid])
                    return (
                        this.id +
                        "." +
                        this.subid +
                        "." +
                        this.label +
                        "." +
                        data.items.indexOf(this as any)
                    )
                }
            },
            {},
            { proxy: false }
        )
        res.subid = subid // non reactive
        return res
    }
    const data = observable({
        items: [createItem(1, "hi")]
    })
    const events: Array<any> = []
    const Child = observer(
        class Child extends React.Component<any, any> {
            componentDidUpdate(prevProps) {
                events.push(["update", prevProps.item.subid, this.props.item.subid])
            }
            render() {
                events.push(["render", this.props.item.subid, this.props.item.text])
                return <span>{this.props.item.text}</span>
            }
        }
    )

    const Parent = observer(
        class Parent extends React.Component<any, any> {
            render() {
                return (
                    <div onClick={changeStuff.bind(this)} id="testDiv">
                        {data.items.map(item => (
                            <Child key="fixed" item={item} />
                        ))}
                    </div>
                )
            }
        }
    )

    const Wrapper = () => <Parent />

    function changeStuff() {
        act(() => {
            transaction(() => {
                data.items[0].label = "hello" // schedules state change for Child
                data.items[0] = createItem(2, "test") // Child should still receive new prop!
            })

            // @ts-ignore
            this.setState({}) // trigger update
        })
    }

    const { container } = render(<Wrapper />)
    expect(events.sort()).toEqual(
        [
            ["compute", 1],
            ["render", 1, "1.1.hi.0"]
        ].sort()
    )
    events.splice(0)
    let testDiv = container.querySelector("#testDiv")! as HTMLElement
    testDiv.click()
    expect(events.sort()).toEqual(
        [
            ["compute", 1],
            ["update", 1, 2],
            ["compute", 2],
            ["render", 2, "1.2.test.0"]
        ].sort()
    )
    expect(container.textContent).toMatchInlineSnapshot(`"1.2.test.0"`)
})

test("no re-render for shallow equal props", async () => {
    function createItem(subid, label) {
        const res = observable({
            subid,
            id: 1,
            label: label
        })
        res.subid = subid // non reactive
        return res
    }

    const data = observable({
        items: [createItem(1, "hi")],
        parentValue: 0
    })
    const events: Array<Array<any>> = []

    const Child = observer(
        class Child extends React.Component<any, any> {
            componentDidMount() {
                events.push(["mount"])
            }
            componentDidUpdate(prevProps) {
                events.push(["update", prevProps.item.subid, this.props.item.subid])
            }
            render() {
                events.push(["render", this.props.item.subid, this.props.item.label])
                return <span>{this.props.item.label}</span>
            }
        }
    )

    const Parent = observer(
        class Parent extends React.Component<any, any> {
            render() {
                // "object has become observable!"
                expect(isObservable(this.props.nonObservable)).toBeFalsy()
                events.push(["parent render", data.parentValue])
                return (
                    <div onClick={changeStuff.bind(this)} id="testDiv">
                        {data.items.map(item => (
                            <Child key="fixed" item={item} value={5} />
                        ))}
                    </div>
                )
            }
        }
    )

    const Wrapper = () => <Parent nonObservable={{}} />

    function changeStuff() {
        act(() => {
            data.items[0].label = "hi" // no change.
            data.parentValue = 1 // rerender parent
        })
    }

    const { container } = render(<Wrapper />)
    expect(events.sort()).toEqual([["parent render", 0], ["mount"], ["render", 1, "hi"]].sort())
    events.splice(0)
    let testDiv = container.querySelector("#testDiv") as HTMLElement
    testDiv.click()
    expect(events.sort()).toEqual([["parent render", 1]].sort())
})

test("lifecycle callbacks called with correct arguments", () => {
    var Comp = observer(
        class Comp extends React.Component<any, any> {
            componentDidUpdate(prevProps) {
                expect(prevProps.counter).toBe(0)
                expect(this.props.counter).toBe(1)
            }
            render() {
                return (
                    <div>
                        <span key="1">{[this.props.counter]}</span>
                        <button key="2" id="testButton" onClick={this.props.onClick} />
                    </div>
                )
            }
        }
    )
    const Root = class T extends React.Component<any, any> {
        state = { counter: 0 }
        onButtonClick = () => {
            act(() => this.setState({ counter: (this.state.counter || 0) + 1 }))
        }
        render() {
            return <Comp counter={this.state.counter || 0} onClick={this.onButtonClick} />
        }
    }
    const { container } = render(<Root />)
    let testButton = container.querySelector("#testButton") as HTMLElement
    testButton.click()
})



================================================
FILE: packages/mobx-react/__tests__/issue806.test.tsx
================================================
import React from "react"
import { configure, observable } from "mobx"
import { observer } from "../src"
import { render } from "@testing-library/react"
import { withConsole } from "./utils/withConsole"

@observer
class Issue806Component extends React.Component<any> {
    render() {
        return (
            <span>
                {this.props.a}
                <Issue806Component2 propA={this.props.a} propB={this.props.b} />
            </span>
        )
    }
}

@observer
class Issue806Component2 extends React.Component<any> {
    render() {
        return (
            <span>
                {this.props.propA} - {this.props.propB}
            </span>
        )
    }
}

test("verify issue 806", () => {
    configure({
        observableRequiresReaction: true
    })

    const x = observable({
        a: 1
    })

    withConsole(["warn"], () => {
        render(<Issue806Component a={"a prop value"} b={"b prop value"} x={x} />)
        expect(console.warn).not.toHaveBeenCalled()
    })

    // make sure observableRequiresReaction is still working outside component
    withConsole(["warn"], () => {
        x.a.toString()
        expect(console.warn).toBeCalledTimes(1)
        expect(console.warn).toHaveBeenCalledWith(
            "[mobx] Observable 'ObservableObject@1.a' being read outside a reactive context."
        )
    })
})



================================================
FILE: packages/mobx-react/__tests__/misc.test.tsx
================================================
import React from "react"
import { extendObservable, observable } from "mobx"
import { observer } from "../src"
import { act, render } from "@testing-library/react"

test("issue mobx 405", () => {
    function ExampleState() {
        // @ts-ignore
        extendObservable(this, {
            name: "test",
            get greetings() {
                return "Hello my name is " + this.name
            }
        })
    }

    const ExampleView = observer(
        class T extends React.Component<any, any> {
            render() {
                return (
                    <div>
                        <input
                            type="text"
                            onChange={e => (this.props.exampleState.name = e.target.value)}
                            value={this.props.exampleState.name}
                        />
                        <span>{this.props.exampleState.greetings}</span>
                    </div>
                )
            }
        }
    )

    const exampleState = new ExampleState()
    const { container } = render(<ExampleView exampleState={exampleState} />)
    expect(container).toMatchInlineSnapshot(`
<div>
  <div>
    <input
      type="text"
      value="test"
    />
    <span>
      Hello my name is test
    </span>
  </div>
</div>
`)
})

test("#85 Should handle state changing in constructors", () => {
    const a = observable.box(2)
    const Child = observer(
        class Child extends React.Component {
            constructor(p) {
                super(p)
                a.set(3) // one shouldn't do this!
                this.state = {}
            }
            render() {
                return (
                    <div>
                        child:
                        {a.get()} -{" "}
                    </div>
                )
            }
        }
    )
    const ParentWrapper = observer(function Parent() {
        return (
            <span>
                <Child />
                parent:
                {a.get()}
            </span>
        )
    })
    const { container } = render(<ParentWrapper />)
    expect(container).toHaveTextContent("child:3 - parent:3")

    act(() => a.set(5))
    expect(container).toHaveTextContent("child:5 - parent:5")

    act(() => a.set(7))
    expect(container).toHaveTextContent("child:7 - parent:7")
})



================================================
FILE: packages/mobx-react/__tests__/observer.test.tsx
================================================
import React, { StrictMode, Suspense } from "react"
import { inject, observer, Observer, enableStaticRendering } from "../src"
import { render, act, waitFor } from "@testing-library/react"
import {
    getObserverTree,
    _getGlobalState,
    _resetGlobalState,
    action,
    computed,
    observable,
    transaction,
    makeObservable,
    autorun,
    IReactionDisposer,
    reaction,
    configure
} from "mobx"
import { withConsole } from "./utils/withConsole"
import { shallowEqual } from "../src/utils/utils"
/**
 *  some test suite is too tedious
 */

afterEach(() => {
    jest.useRealTimers()
})

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

/*
 use TestUtils.renderIntoDocument will re-mounted the component with different props
 some misunderstanding will be causeï¼Ÿ
*/
describe("nestedRendering", () => {
    let store

    let todoItemRenderings
    const TodoItem = observer(function TodoItem(props) {
        todoItemRenderings++
        return <li>|{props.todo.title}</li>
    })

    let todoListRenderings
    const TodoList = observer(
        class TodoList extends React.Component {
            render() {
                todoListRenderings++
                const todos = store.todos
                return (
                    <div>
                        <span>{todos.length}</span>
                        {todos.map((todo, idx) => (
                            <TodoItem key={idx} todo={todo} />
                        ))}
                    </div>
                )
            }
        }
    )

    beforeEach(() => {
        todoItemRenderings = 0
        todoListRenderings = 0
        store = observable({
            todos: [
                {
                    title: "a",
                    completed: false
                }
            ]
        })
    })

    test("first rendering", () => {
        const { container } = render(<TodoList />)

        expect(todoListRenderings).toBe(1)
        expect(container.querySelectorAll("li").length).toBe(1)
        expect(container.querySelector("li")).toHaveTextContent("|a")
        expect(todoItemRenderings).toBe(1)
    })

    test("second rendering with inner store changed", () => {
        render(<TodoList />)

        act(() => {
            store.todos[0].title += "a"
        })

        expect(todoListRenderings).toBe(1)
        expect(todoItemRenderings).toBe(2)
        expect(getObserverTree(store, "todos").observers!.length).toBe(1)
        expect(getObserverTree(store.todos[0], "title").observers!.length).toBe(1)
    })

    test("rerendering with outer store added", () => {
        const { container } = render(<TodoList />)

        act(() => {
            store.todos.push({
                title: "b",
                completed: true
            })
        })

        expect(container.querySelectorAll("li").length).toBe(2)
        expect(
            Array.from(container.querySelectorAll("li"))
                .map((e: any) => e.innerHTML)
                .sort()
        ).toEqual(["|a", "|b"].sort())
        expect(todoListRenderings).toBe(2)
        expect(todoItemRenderings).toBe(2)
        expect(getObserverTree(store.todos[1], "title").observers!.length).toBe(1)
        expect(getObserverTree(store.todos[1], "completed").observers).toBe(undefined)
    })

    test("rerendering with outer store pop", () => {
        const { container } = render(<TodoList />)

        let oldTodo
        act(() => (oldTodo = store.todos.pop()))

        expect(todoListRenderings).toBe(2)
        expect(todoItemRenderings).toBe(1)
        expect(container.querySelectorAll("li").length).toBe(0)
        expect(getObserverTree(oldTodo, "title").observers).toBe(undefined)
        expect(getObserverTree(oldTodo, "completed").observers).toBe(undefined)
    })
})

describe("isObjectShallowModified detects when React will update the component", () => {
    const store = observable({ count: 0 })
    let counterRenderings = 0
    const Counter: React.FunctionComponent<any> = observer(function TodoItem() {
        counterRenderings++
        return <div>{store.count}</div>
    })

    test("does not assume React will update due to NaN prop", () => {
        render(<Counter value={NaN} />)

        act(() => {
            store.count++
        })

        expect(counterRenderings).toBe(2)
    })
})

describe("keep views alive", () => {
    let yCalcCount
    let data
    const TestComponent = observer(function testComponent() {
        return (
            <div>
                {data.z}
                {data.y}
            </div>
        )
    })

    beforeEach(() => {
        yCalcCount = 0
        data = observable({
            x: 3,
            get y() {
                yCalcCount++
                return this.x * 2
            },
            z: "hi"
        })
    })

    test("init state", () => {
        const { container } = render(<TestComponent />)

        expect(yCalcCount).toBe(1)
        expect(container).toHaveTextContent("hi6")
    })

    test("rerender should not need a recomputation of data.y", () => {
        const { container } = render(<TestComponent />)

        act(() => {
            data.z = "hello"
        })

        expect(yCalcCount).toBe(1)
        expect(container).toHaveTextContent("hello6")
    })
})

describe("does not views alive when using static rendering", () => {
    let renderCount
    let data

    const TestComponent = observer(function testComponent() {
        renderCount++
        return <div>{data.z}</div>
    })

    beforeAll(() => {
        enableStaticRendering(true)
    })

    beforeEach(() => {
        renderCount = 0
        data = observable({
            z: "hi"
        })
    })

    afterAll(() => {
        enableStaticRendering(false)
    })

    test("init state is correct", () => {
        const { container } = render(<TestComponent />)

        expect(renderCount).toBe(1)
        expect(container).toHaveTextContent("hi")
    })

    test("no re-rendering on static rendering", () => {
        const { container } = render(<TestComponent />)

        act(() => {
            data.z = "hello"
        })

        expect(getObserverTree(data, "z").observers).toBe(undefined)
        expect(renderCount).toBe(1)
        expect(container).toHaveTextContent("hi")
    })
})

test("issue 12", () => {
    const events: Array<any> = []
    const data = observable({
        selected: "coffee",
        items: [
            {
                name: "coffee"
            },
            {
                name: "tea"
            }
        ]
    })

    /** Row Class */
    class Row extends React.Component<any, any> {
        constructor(props) {
            super(props)
        }

        render() {
            events.push("row: " + this.props.item.name)
            return (
                <span>
                    {this.props.item.name}
                    {data.selected === this.props.item.name ? "!" : ""}
                </span>
            )
        }
    }
    /** table stateles component */
    const Table = observer(function table() {
        events.push("table")
        JSON.stringify(data)
        return (
            <div>
                {data.items.map(item => (
                    <Row key={item.name} item={item} />
                ))}
            </div>
        )
    })

    const { container } = render(<Table />)
    expect(container).toMatchSnapshot()

    act(() => {
        transaction(() => {
            data.items[1].name = "boe"
            data.items.splice(0, 2, { name: "soup" })
            data.selected = "tea"
        })
    })
    expect(container).toMatchSnapshot()
    expect(events).toEqual(["table", "row: coffee", "row: tea", "table", "row: soup"])
})

test("changing state in render should fail", () => {
    const data = observable.box(2)
    const Comp = observer(() => {
        if (data.get() === 3) {
            try {
                data.set(4) // wouldn't throw first time for lack of observers.. (could we tighten this?)
            } catch (err) {
                expect(err).toBeInstanceOf(Error)
                expect(err).toMatch(
                    /Side effects like changing state are not allowed at this point/
                )
            }
        }
        return <div>{data.get()}</div>
    })
    render(<Comp />)

    act(() => data.set(3))
    _resetGlobalState()
})

test("observer component can be injected", () => {
    const msg: Array<any> = []
    const baseWarn = console.warn
    console.warn = m => msg.push(m)

    inject("foo")(
        observer(
            class T extends React.Component {
                render() {
                    return null
                }
            }
        )
    )

    // N.B, the injected component will be observer since mobx-react 4.0!
    inject(() => ({}))(
        observer(
            class T extends React.Component {
                render() {
                    return null
                }
            }
        )
    )

    expect(msg.length).toBe(0)
    console.warn = baseWarn
})

test("correctly wraps display name of child component", () => {
    const A = observer(
        class ObserverClass extends React.Component {
            render() {
                return null
            }
        }
    )
    const B: React.FunctionComponent<any> = observer(function StatelessObserver() {
        return null
    })

    expect(A.name).toEqual("ObserverClass")
    expect((B as any).type.name).toEqual("StatelessObserver")
    expect((B as any).type.displayName).toEqual(undefined)
})

describe("124 - react to changes in this.props via computed", () => {
    class T extends React.Component<any, any> {
        @computed
        get computedProp() {
            return this.props.x
        }
        render() {
            return (
                <span>
                    x:
                    {this.computedProp}
                </span>
            )
        }
    }

    const Comp = observer(T)

    class Parent extends React.Component {
        state = { v: 1 }
        render() {
            return (
                <div onClick={() => this.setState({ v: 2 })}>
                    <Comp x={this.state.v} />
                </div>
            )
        }
    }

    test("init state is correct", () => {
        const { container } = render(<Parent />)

        expect(container).toHaveTextContent("x:1")
    })

    test("change after click", () => {
        const { container } = render(<Parent />)

        act(() => container.querySelector("div")!.click())
        expect(container).toHaveTextContent("x:2")
    })
})

// Test on skip: since all reactions are now run in batched updates, the original issues can no longer be reproduced
//this test case should be deprecated?
test("should stop updating if error was thrown in render (#134)", () => {
    const data = observable.box(0)
    let renderingsCount = 0
    let lastOwnRenderCount = 0
    const errors: Array<any> = []

    class Outer extends React.Component<any> {
        state = { hasError: false }

        render() {
            return this.state.hasError ? <div>Error!</div> : <div>{this.props.children}</div>
        }

        static getDerivedStateFromError() {
            return { hasError: true }
        }

        componentDidCatch(error, info) {
            errors.push(error.toString().split("\n")[0], info)
        }
    }

    const Comp = observer(
        class X extends React.Component {
            ownRenderCount = 0

            render() {
                lastOwnRenderCount = ++this.ownRenderCount
                renderingsCount++
                if (data.get() === 2) {
                    throw new Error("Hello")
                }
                return <div />
            }
        }
    )
    render(
        <Outer>
            <Comp />
        </Outer>
    )

    // Check this
    // @ts-ignore
    expect(getObserverTree(data).observers!.length).toBe(1)
    act(() => data.set(1))
    expect(renderingsCount).toBe(2)
    expect(lastOwnRenderCount).toBe(2)
    withConsole(() => {
        act(() => data.set(2))
    })

    // @ts-ignore
    expect(getObserverTree(data).observers).toBe(undefined)
    act(() => {
        data.set(3)
        data.set(4)
        data.set(2)
        data.set(5)
    })
    // MWE: not sure if these numbers make sense. Nor whether it really matters
    expect(lastOwnRenderCount).toBe(4)
    expect(renderingsCount).toBe(4)
})

describe("should render component even if setState called with exactly the same props", () => {
    let renderCount
    const Comp = observer(
        class T extends React.Component {
            onClick = () => {
                this.setState({})
            }
            render() {
                renderCount++
                return <div onClick={this.onClick} id="clickableDiv" />
            }
        }
    )

    beforeEach(() => {
        renderCount = 0
    })

    test("renderCount === 1", () => {
        render(<Comp />)

        expect(renderCount).toBe(1)
    })

    test("after click once renderCount === 2", () => {
        const { container } = render(<Comp />)
        const clickableDiv = container.querySelector("#clickableDiv") as HTMLElement

        act(() => clickableDiv.click())

        expect(renderCount).toBe(2)
    })

    test("after click twice renderCount === 3", () => {
        const { container } = render(<Comp />)
        const clickableDiv = container.querySelector("#clickableDiv") as HTMLElement

        act(() => clickableDiv.click())
        act(() => clickableDiv.click())

        expect(renderCount).toBe(3)
    })
})

test("it rerenders correctly if some props are non-observables - 1", () => {
    let odata = observable({ x: 1 })
    let data = { y: 1 }

    @observer
    class Comp extends React.Component<any, any> {
        @computed
        get computed() {
            // n.b: data.y would not rerender! shallowly new equal props are not stored
            return this.props.odata.x
        }
        render() {
            return (
                <span onClick={stuff}>
                    {this.props.odata.x}-{this.props.data.y}-{this.computed}
                </span>
            )
        }
    }

    const Parent = observer(
        class Parent extends React.Component<any, any> {
            render() {
                // this.props.odata.x;
                return <Comp data={this.props.data} odata={this.props.odata} />
            }
        }
    )

    function stuff() {
        act(() => {
            data.y++
            odata.x++
        })
    }

    const { container } = render(<Parent odata={odata} data={data} />)

    expect(container).toHaveTextContent("1-1-1")
    stuff()
    expect(container).toHaveTextContent("2-2-2")
    stuff()
    expect(container).toHaveTextContent("3-3-3")
})

test("it rerenders correctly if some props are non-observables - 2", () => {
    let renderCount = 0
    let odata = observable({ x: 1 })

    @observer
    class Component extends React.PureComponent<any, any> {
        @computed
        get computed() {
            return this.props.data.y // should recompute, since props.data is changed
        }

        render() {
            renderCount++
            return (
                <span onClick={stuff}>
                    {this.props.data.y}-{this.computed}
                </span>
            )
        }
    }

    const Parent = observer(props => {
        let data = { y: props.odata.x }
        return <Component data={data} odata={props.odata} />
    })

    function stuff() {
        odata.x++
    }

    const { container } = render(<Parent odata={odata} />)

    expect(renderCount).toBe(1)
    expect(container).toHaveTextContent("1-1")

    act(() => stuff())
    expect(renderCount).toBe(2)
    expect(container).toHaveTextContent("2-2")

    act(() => stuff())
    expect(renderCount).toBe(3)
    expect(container).toHaveTextContent("3-3")
})

describe("Observer regions should react", () => {
    let data
    const Comp = () => (
        <div>
            <Observer>{() => <span data-testid="inside-of-observer">{data.get()}</span>}</Observer>
            <span data-testid="outside-of-observer">{data.get()}</span>
        </div>
    )

    beforeEach(() => {
        data = observable.box("hi")
    })

    test("init state is correct", () => {
        const { queryByTestId } = render(<Comp />)

        expect(queryByTestId("inside-of-observer")).toHaveTextContent("hi")
        expect(queryByTestId("outside-of-observer")).toHaveTextContent("hi")
    })

    test("set the data to hello", () => {
        const { queryByTestId } = render(<Comp />)

        act(() => data.set("hello"))

        expect(queryByTestId("inside-of-observer")).toHaveTextContent("hello")
        expect(queryByTestId("outside-of-observer")).toHaveTextContent("hi")
    })
})

test("Observer should not re-render on shallow equal new props", () => {
    let childRendering = 0
    let parentRendering = 0
    const data = { x: 1 }
    const odata = observable({ y: 1 })

    const Child = observer(({ data }) => {
        childRendering++
        return <span>{data.x}</span>
    })
    const Parent = observer(() => {
        parentRendering++
        odata.y /// depend
        return <Child data={data} />
    })

    const { container } = render(<Parent />)

    expect(parentRendering).toBe(1)
    expect(childRendering).toBe(1)
    expect(container).toHaveTextContent("1")

    act(() => {
        odata.y++
    })
    expect(parentRendering).toBe(2)
    expect(childRendering).toBe(1)
    expect(container).toHaveTextContent("1")
})

test("parent / childs render in the right order", () => {
    // See: https://jsfiddle.net/gkaemmer/q1kv7hbL/13/
    let events: Array<any> = []

    class User {
        @observable
        name = "User's name"
    }

    class Store {
        @observable
        user: User | null = new User()
        @action
        logout() {
            this.user = null
        }
        constructor() {
            makeObservable(this)
        }
    }

    function tryLogout() {
        try {
            // ReactDOM.unstable_batchedUpdates(() => {
            store.logout()
            expect(true).toBeTruthy()
            // });
        } catch (e) {
            // t.fail(e)
        }
    }

    const store = new Store()

    const Parent = observer(() => {
        events.push("parent")
        if (!store.user) return <span>Not logged in.</span>
        return (
            <div>
                <Child />
                <button onClick={tryLogout}>Logout</button>
            </div>
        )
    })

    const Child = observer(() => {
        events.push("child")
        return <span>Logged in as: {store.user?.name}</span>
    })

    render(<Parent />)

    act(() => tryLogout())
    expect(events).toEqual(["parent", "child", "parent"])
})

describe("use Observer inject and render sugar should work  ", () => {
    test("use render without inject should be correct", () => {
        const Comp = () => (
            <div>
                <Observer render={() => <span>{123}</span>} />
            </div>
        )
        const { container } = render(<Comp />)
        expect(container).toHaveTextContent("123")
    })

    test("use children without inject should be correct", () => {
        const Comp = () => (
            <div>
                <Observer>{() => <span>{123}</span>}</Observer>
            </div>
        )
        const { container } = render(<Comp />)
        expect(container).toHaveTextContent("123")
    })

    test("show error when using children and render at same time ", () => {
        const msg: Array<any> = []
        const baseError = console.error
        console.error = m => msg.push(m)

        const Comp = () => (
            <div>
                <Observer render={() => <span>{123}</span>}>{() => <span>{123}</span>}</Observer>
            </div>
        )

        render(<Comp />)
        expect(msg.length).toBe(1)
        console.error = baseError
    })
})

test("use PureComponent", () => {
    const msg: Array<any> = []
    const baseWarn = console.warn
    console.warn = m => msg.push(m)

    try {
        observer(
            class X extends React.PureComponent {
                render() {
                    return <div />
                }
            }
        )

        expect(msg).toEqual([])
    } finally {
        console.warn = baseWarn
    }
})

test("static on function components are hoisted", () => {
    const Comp = () => <div />
    Comp.foo = 3

    const Comp2 = observer(Comp)

    expect(Comp2.foo).toBe(3)
})

test("computed properties react to props", () => {
    jest.useFakeTimers()

    const seen: Array<any> = []
    @observer
    class Child extends React.Component<any, any> {
        @computed
        get getPropX() {
            return this.props.x
        }

        render() {
            seen.push(this.getPropX)
            return <div>{this.getPropX}</div>
        }
    }

    class Parent extends React.Component {
        state = { x: 0 }
        render() {
            seen.push("parent")
            return <Child x={this.state.x} />
        }

        componentDidMount() {
            setTimeout(() => this.setState({ x: 2 }), 100)
        }
    }

    const { container } = render(<Parent />)
    expect(container).toHaveTextContent("0")

    act(() => {
        jest.runAllTimers()
    })
    expect(container).toHaveTextContent("2")

    expect(seen).toEqual(["parent", 0, "parent", 2])
})

test("#692 - componentDidUpdate is triggered", () => {
    jest.useFakeTimers()

    let cDUCount = 0

    @observer
    class Test extends React.Component<any, any> {
        @observable
        counter = 0

        @action
        inc = () => this.counter++

        constructor(props) {
            super(props)
            makeObservable(this)
            setTimeout(() => this.inc(), 300)
        }

        render() {
            return <p>{this.counter}</p>
        }

        componentDidUpdate() {
            cDUCount++
        }
    }
    render(<Test />)
    expect(cDUCount).toBe(0)

    act(() => {
        jest.runAllTimers()
    })
    expect(cDUCount).toBe(1)
})

// Not possible to properly test error catching (see ErrorCatcher)
test.skip("#709 - applying observer on React.memo component", () => {
    const WithMemo = React.memo(() => {
        return null
    })

    const Observed = observer(WithMemo)
    // @ts-ignore
    // eslint-disable-next-line no-undef
    render(<Observed />, { wrapper: ErrorCatcher })
})

test("Redeclaring an existing observer component as an observer should throw", () => {
    @observer
    class AlreadyObserver extends React.Component<any, any> {
        render() {
            return <div />
        }
    }

    expect(() => observer(AlreadyObserver)).toThrowErrorMatchingSnapshot()
})

test("Missing render should throw", () => {
    class Component extends React.Component<any, any> {
        render = function () {
            return <div />
        }
    }
    expect(() => observer(Component)).toThrow()
})

test("class observer supports re-mounting #3395", () => {
    const state = observable.box(1)
    let mountCounter = 0

    @observer
    class TestCmp extends React.Component<any> {
        componentDidMount() {
            mountCounter++
        }
        render() {
            return state.get()
        }
    }

    const app = (
        <StrictMode>
            <TestCmp />
        </StrictMode>
    )

    const { unmount, container } = render(app)

    expect(mountCounter).toBe(2)
    expect(container).toHaveTextContent("1")
    act(() => {
        state.set(2)
    })
    expect(mountCounter).toBe(2)
    expect(container).toHaveTextContent("2")

    unmount()
})

test("SSR works #3448", () => {
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

    @observer
    class TestCmp extends React.Component<any> {
        render() {
            return ":)"
        }
    }

    const app = <TestCmp />

    enableStaticRendering(true)
    const { unmount, container } = render(app)
    expect(container).toHaveTextContent(":)")
    unmount()
    enableStaticRendering(false)

    expect(consoleWarnMock).toMatchSnapshot()
})

test("#3492 should not cause warning by calling forceUpdate on uncommited components", async () => {
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

    const o = observable({ x: 0 })
    let aConstructorCount = 0
    let aMountCount = 0
    let aRenderCount = 0

    @observer
    class A extends React.Component<any> {
        constructor(props) {
            super(props)
            aConstructorCount++
        }
        componentDidMount(): void {
            aMountCount++
        }
        render() {
            aRenderCount++
            return (
                <Suspense fallback="fallback">
                    <LazyB />
                    {o.x}
                </Suspense>
            )
        }
    }

    class B extends React.Component {
        render() {
            return "B"
        }
    }

    const LazyA = React.lazy(() => Promise.resolve({ default: A }))
    const LazyB = React.lazy(() => Promise.resolve({ default: B }))

    function App() {
        return (
            <Suspense fallback="fallback">
                <LazyA />
            </Suspense>
        )
    }

    const { unmount, container } = render(<App />)

    expect(container).toHaveTextContent("fallback")
    await waitFor(() => expect(container).toHaveTextContent("B0"))
    act(() => {
        o.x++
    })
    expect(container).toHaveTextContent("B1")
    // React throws away the first instance, therefore the mismatch
    expect(aConstructorCount).toBe(2)
    expect(aMountCount).toBe(1)
    expect(aRenderCount).toBe(3)
    unmount()
    expect(consoleWarnMock).toMatchSnapshot()
})
;["props", "state", "context"].forEach(key => {
    test(`using ${key} in computed throws`, () => {
        // React prints errors even if we catch em
        const consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})

        const TestCmp = observer(
            class TestCmp extends React.Component {
                render() {
                    computed(() => this[key]).get()
                    return ""
                }
            }
        )

        expect(() => render(<TestCmp />)).toThrowError(
            new RegExp(`^\\[mobx-react\\] Cannot read "TestCmp.${key}" in a reactive context`)
        )

        consoleErrorSpy.mockRestore()
    })

    test(`using ${key} in autorun throws`, () => {
        // React prints errors even if we catch em
        const consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})

        let caughtError

        const TestCmp = observer(
            class TestCmp extends React.Component {
                disposeAutorun: IReactionDisposer | undefined

                componentDidMount(): void {
                    this.disposeAutorun = autorun(() => this[key], {
                        onError: error => (caughtError = error)
                    })
                }

                componentWillUnmount(): void {
                    this.disposeAutorun?.()
                }

                render() {
                    return ""
                }
            }
        )

        render(<TestCmp />)
        expect(caughtError?.message).toMatch(
            new RegExp(`^\\[mobx-react\\] Cannot read "TestCmp.${key}" in a reactive context`)
        )

        consoleErrorSpy.mockRestore()
    })
})

test(`Component react's to observable changes in componenDidMount #3691`, () => {
    const o = observable.box(0)

    const TestCmp = observer(
        class TestCmp extends React.Component {
            componentDidMount(): void {
                o.set(o.get() + 1)
            }

            render() {
                return o.get()
            }
        }
    )

    const { container, unmount } = render(<TestCmp />)
    expect(container).toHaveTextContent("1")
    unmount()
})

test(`Observable changes in componenWillUnmount don't cause any warnings or errors`, () => {
    const consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})
    const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {})
    const o = observable.box(0)

    const TestCmp = observer(
        class TestCmp extends React.Component {
            componentWillUnmount(): void {
                o.set(o.get() + 1)
            }

            render() {
                return o.get()
            }
        }
    )

    const { container, unmount } = render(<TestCmp />)
    expect(container).toHaveTextContent("0")
    unmount()

    expect(consoleErrorSpy).not.toBeCalled()
    expect(consoleWarnSpy).not.toBeCalled()

    consoleErrorSpy.mockRestore()
    consoleWarnSpy.mockRestore()
})

test(`Observable prop workaround`, () => {
    configure({
        enforceActions: "observed"
    })

    const propValues: Array<any> = []

    const TestCmp = observer(
        class TestCmp extends React.Component<{ prop: number }> {
            disposeReaction: IReactionDisposer | undefined
            observableProp: number

            get computed() {
                return this.observableProp + 100
            }

            constructor(props) {
                super(props)
                // Synchronize our observableProp with the actual prop on the first render.
                this.observableProp = this.props.prop
                makeObservable(this, {
                    observableProp: observable,
                    computed: computed,
                    // Mutates observable therefore must be action
                    componentDidUpdate: action
                })
            }

            componentDidMount(): void {
                // Reactions/autoruns must be created in componenDidMount (not in constructor).
                this.disposeReaction = reaction(
                    () => this.observableProp,
                    prop => propValues.push(prop),
                    {
                        fireImmediately: true
                    }
                )
            }

            componentDidUpdate(): void {
                // Synchronize our observableProp with the actual prop on every update.
                this.observableProp = this.props.prop
            }

            componentWillUnmount(): void {
                this.disposeReaction?.()
            }

            render() {
                return this.computed
            }
        }
    )

    const { container, unmount, rerender } = render(<TestCmp prop={1} />)
    expect(container).toHaveTextContent("101")
    rerender(<TestCmp prop={2} />)
    expect(container).toHaveTextContent("102")
    rerender(<TestCmp prop={3} />)
    expect(container).toHaveTextContent("103")
    rerender(<TestCmp prop={4} />)
    expect(container).toHaveTextContent("104")
    expect(propValues).toEqual([1, 2, 3, 4])
    unmount()
})

test(`Observable props/state/context workaround`, () => {
    configure({
        enforceActions: "observed"
    })

    const reactionResults: Array<string> = []

    const ContextType = React.createContext(0)

    const TestCmp = observer(
        class TestCmp extends React.Component<any, any> {
            static contextType = ContextType

            disposeReaction: IReactionDisposer | undefined
            observableProps: any
            observableState: any
            observableContext: any

            constructor(props, context) {
                super(props, context)
                this.state = {
                    x: 0
                }
                this.observableState = this.state
                this.observableProps = this.props
                this.observableContext = this.context
                makeObservable(this, {
                    observableProps: observable,
                    observableState: observable,
                    observableContext: observable,
                    computed: computed,
                    componentDidUpdate: action
                })
            }

            get computed() {
                return `${this.observableProps?.x}${this.observableState?.x}${this.observableContext}`
            }

            componentDidMount(): void {
                this.disposeReaction = reaction(
                    () => this.computed,
                    prop => reactionResults.push(prop),
                    {
                        fireImmediately: true
                    }
                )
            }

            componentDidUpdate(): void {
                // Props are different object with every update
                if (!shallowEqual(this.observableProps, this.props)) {
                    this.observableProps = this.props
                }
                if (!shallowEqual(this.observableState, this.state)) {
                    this.observableState = this.state
                }
                if (!shallowEqual(this.observableContext, this.context)) {
                    this.observableContext = this.context
                }
            }

            componentWillUnmount(): void {
                this.disposeReaction?.()
            }

            render() {
                return (
                    <span
                        id="updateState"
                        onClick={() => this.setState(state => ({ x: state.x + 1 }))}
                    >
                        {this.computed}
                    </span>
                )
            }
        }
    )

    const App = () => {
        const [context, setContext] = React.useState(0)
        const [prop, setProp] = React.useState(0)
        return (
            <ContextType.Provider value={context}>
                <span id="updateContext" onClick={() => setContext(val => val + 1)}></span>
                <span id="updateProp" onClick={() => setProp(val => val + 1)}></span>
                <TestCmp x={prop}></TestCmp>
            </ContextType.Provider>
        )
    }

    const { container, unmount } = render(<App />)

    const updateProp = () =>
        act(() => (container.querySelector("#updateProp") as HTMLElement).click())
    const updateState = () =>
        act(() => (container.querySelector("#updateState") as HTMLElement).click())
    const updateContext = () =>
        act(() => (container.querySelector("#updateContext") as HTMLElement).click())

    expect(container).toHaveTextContent("000")
    updateProp()
    expect(container).toHaveTextContent("100")
    updateState()
    expect(container).toHaveTextContent("110")
    updateContext()
    expect(container).toHaveTextContent("111")

    expect(reactionResults).toEqual(["000", "100", "110", "111"])
    unmount()
})

test("Class observer can react to changes made before mount #3730", () => {
    const o = observable.box(0)

    @observer
    class Child extends React.Component {
        componentDidMount(): void {
            o.set(1)
        }
        render() {
            return ""
        }
    }

    @observer
    class Parent extends React.Component {
        render() {
            return (
                <span>
                    {o.get()}
                    <Child />
                </span>
            )
        }
    }

    const { container, unmount } = render(<Parent />)
    expect(container).toHaveTextContent("1")
    unmount()
})



================================================
FILE: packages/mobx-react/__tests__/propTypes.test.ts
================================================
import PropTypes from "prop-types"
import { PropTypes as MRPropTypes } from "../src"
import { observable } from "mobx"

// Cause `checkPropTypes` caches errors and doesn't print them twice....
// https://github.com/facebook/prop-types/issues/91
let testComponentId = 0

function typeCheckFail(declaration, value, message) {
    const baseError = console.error
    let error = ""
    console.error = msg => {
        error = msg
    }

    const props = { testProp: value }
    const propTypes = { testProp: declaration }

    const compId = "testComponent" + ++testComponentId
    PropTypes.checkPropTypes(propTypes, props, "prop", compId)

    error = error.replace(compId, "testComponent")
    expect(error).toBe("Warning: Failed prop type: " + message)
    console.error = baseError
}

function typeCheckFailRequiredValues(declaration) {
    const baseError = console.error
    let error = ""
    console.error = msg => {
        error = msg
    }

    const propTypes = { testProp: declaration }
    const specifiedButIsNullMsg = /but its value is `null`\./
    const unspecifiedMsg = /but its value is `undefined`\./

    const props1 = { testProp: null }
    PropTypes.checkPropTypes(propTypes, props1, "testProp", "testComponent" + ++testComponentId)
    expect(specifiedButIsNullMsg.test(error)).toBeTruthy()

    error = ""
    const props2 = { testProp: undefined }
    PropTypes.checkPropTypes(propTypes, props2, "testProp", "testComponent" + ++testComponentId)
    expect(unspecifiedMsg.test(error)).toBeTruthy()

    error = ""
    const props3 = {}
    PropTypes.checkPropTypes(propTypes, props3, "testProp", "testComponent" + ++testComponentId)
    expect(unspecifiedMsg.test(error)).toBeTruthy()

    console.error = baseError
}

function typeCheckPass(declaration: any, value?: any) {
    const props = { testProp: value }
    const error = PropTypes.checkPropTypes(
        { testProp: declaration },
        props,
        "testProp",
        "testComponent" + ++testComponentId
    )
    expect(error).toBeUndefined()
}

test("Valid values", () => {
    typeCheckPass(MRPropTypes.observableArray, observable([]))
    typeCheckPass(MRPropTypes.observableArrayOf(PropTypes.string), observable([""]))
    typeCheckPass(MRPropTypes.arrayOrObservableArray, observable([]))
    typeCheckPass(MRPropTypes.arrayOrObservableArray, [])
    typeCheckPass(MRPropTypes.arrayOrObservableArrayOf(PropTypes.string), observable([""]))
    typeCheckPass(MRPropTypes.arrayOrObservableArrayOf(PropTypes.string), [""])
    typeCheckPass(MRPropTypes.observableObject, observable({}))
    typeCheckPass(MRPropTypes.objectOrObservableObject, {})
    typeCheckPass(MRPropTypes.objectOrObservableObject, observable({}))
    typeCheckPass(MRPropTypes.observableMap, observable(observable.map({}, { deep: false })))
})

test("should be implicitly optional and not warn", () => {
    typeCheckPass(MRPropTypes.observableArray)
    typeCheckPass(MRPropTypes.observableArrayOf(PropTypes.string))
    typeCheckPass(MRPropTypes.arrayOrObservableArray)
    typeCheckPass(MRPropTypes.arrayOrObservableArrayOf(PropTypes.string))
    typeCheckPass(MRPropTypes.observableObject)
    typeCheckPass(MRPropTypes.objectOrObservableObject)
    typeCheckPass(MRPropTypes.observableMap)
})

test("should warn for missing required values, function (test)", () => {
    typeCheckFailRequiredValues(MRPropTypes.observableArray.isRequired)
    typeCheckFailRequiredValues(MRPropTypes.observableArrayOf(PropTypes.string).isRequired)
    typeCheckFailRequiredValues(MRPropTypes.arrayOrObservableArray.isRequired)
    typeCheckFailRequiredValues(MRPropTypes.arrayOrObservableArrayOf(PropTypes.string).isRequired)
    typeCheckFailRequiredValues(MRPropTypes.observableObject.isRequired)
    typeCheckFailRequiredValues(MRPropTypes.objectOrObservableObject.isRequired)
    typeCheckFailRequiredValues(MRPropTypes.observableMap.isRequired)
})

test("should fail date and regexp correctly", () => {
    typeCheckFail(
        MRPropTypes.observableObject,
        new Date(),
        "Invalid prop `testProp` of type `date` supplied to " +
            "`testComponent`, expected `mobx.ObservableObject`."
    )
    typeCheckFail(
        MRPropTypes.observableArray,
        /please/,
        "Invalid prop `testProp` of type `regexp` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray`."
    )
})

test("observableArray", () => {
    typeCheckFail(
        MRPropTypes.observableArray,
        [],
        "Invalid prop `testProp` of type `array` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray`."
    )
    typeCheckFail(
        MRPropTypes.observableArray,
        "",
        "Invalid prop `testProp` of type `string` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray`."
    )
})

test("arrayOrObservableArray", () => {
    typeCheckFail(
        MRPropTypes.arrayOrObservableArray,
        "",
        "Invalid prop `testProp` of type `string` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray` or javascript `array`."
    )
})

test("observableObject", () => {
    typeCheckFail(
        MRPropTypes.observableObject,
        {},
        "Invalid prop `testProp` of type `object` supplied to " +
            "`testComponent`, expected `mobx.ObservableObject`."
    )
    typeCheckFail(
        MRPropTypes.observableObject,
        "",
        "Invalid prop `testProp` of type `string` supplied to " +
            "`testComponent`, expected `mobx.ObservableObject`."
    )
})

test("objectOrObservableObject", () => {
    typeCheckFail(
        MRPropTypes.objectOrObservableObject,
        "",
        "Invalid prop `testProp` of type `string` supplied to " +
            "`testComponent`, expected `mobx.ObservableObject` or javascript `object`."
    )
})

test("observableMap", () => {
    typeCheckFail(
        MRPropTypes.observableMap,
        {},
        "Invalid prop `testProp` of type `object` supplied to " +
            "`testComponent`, expected `mobx.ObservableMap`."
    )
})

test("observableArrayOf", () => {
    typeCheckFail(
        MRPropTypes.observableArrayOf(PropTypes.string),
        2,
        "Invalid prop `testProp` of type `number` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray`."
    )
    typeCheckFail(
        MRPropTypes.observableArrayOf(PropTypes.string),
        observable([2]),
        "Invalid prop `testProp[0]` of type `number` supplied to " +
            "`testComponent`, expected `string`."
    )
    typeCheckFail(
        MRPropTypes.observableArrayOf({ foo: (MRPropTypes as any).string } as any),
        { foo: "bar" },
        "Property `testProp` of component `testComponent` has invalid PropType notation."
    )
})

test("arrayOrObservableArrayOf", () => {
    typeCheckFail(
        MRPropTypes.arrayOrObservableArrayOf(PropTypes.string),
        2,
        "Invalid prop `testProp` of type `number` supplied to " +
            "`testComponent`, expected `mobx.ObservableArray` or javascript `array`."
    )
    typeCheckFail(
        MRPropTypes.arrayOrObservableArrayOf(PropTypes.string),
        observable([2]),
        "Invalid prop `testProp[0]` of type `number` supplied to " +
            "`testComponent`, expected `string`."
    )
    typeCheckFail(
        MRPropTypes.arrayOrObservableArrayOf(PropTypes.string),
        [2],
        "Invalid prop `testProp[0]` of type `number` supplied to " +
            "`testComponent`, expected `string`."
    )
    // TODO:
    typeCheckFail(
        MRPropTypes.arrayOrObservableArrayOf({ foo: (MRPropTypes as any).string } as any),
        { foo: "bar" },
        "Property `testProp` of component `testComponent` has invalid PropType notation."
    )
})



================================================
FILE: packages/mobx-react/__tests__/Provider.test.tsx
================================================
import React from "react"
import { Provider } from "../src"
import { render } from "@testing-library/react"
import { MobXProviderContext } from "../src/Provider"
import { withConsole } from "./utils/withConsole"

describe("Provider", () => {
    it("should work in a simple case", () => {
        function A() {
            return (
                <Provider foo="bar">
                    <MobXProviderContext.Consumer>{({ foo }) => foo}</MobXProviderContext.Consumer>
                </Provider>
            )
        }

        const { container } = render(<A />)
        expect(container).toHaveTextContent("bar")
    })

    it("should not provide the children prop", () => {
        function A() {
            return (
                <Provider>
                    <MobXProviderContext.Consumer>
                        {stores =>
                            Reflect.has(stores, "children")
                                ? "children was provided"
                                : "children was not provided"
                        }
                    </MobXProviderContext.Consumer>
                </Provider>
            )
        }

        const { container } = render(<A />)
        expect(container).toHaveTextContent("children was not provided")
    })

    it("supports overriding stores", () => {
        function B() {
            return (
                <MobXProviderContext.Consumer>
                    {({ overridable, nonOverridable }) => `${overridable} ${nonOverridable}`}
                </MobXProviderContext.Consumer>
            )
        }

        function A() {
            return (
                <Provider overridable="original" nonOverridable="original">
                    <B />
                    <Provider overridable="overridden">
                        <B />
                    </Provider>
                </Provider>
            )
        }
        const { container } = render(<A />)
        expect(container).toMatchInlineSnapshot(`
<div>
  original original
  overridden original
</div>
`)
    })

    it("should throw an error when changing stores", () => {
        function A({ foo }) {
            return (
                <Provider foo={foo}>
                    <MobXProviderContext.Consumer>{({ foo }) => foo}</MobXProviderContext.Consumer>
                </Provider>
            )
        }

        const { rerender } = render(<A foo={1} />)

        withConsole(() => {
            expect(() => {
                rerender(<A foo={2} />)
            }).toThrow("The set of provided stores has changed.")
        })
    })
})



================================================
FILE: packages/mobx-react/__tests__/stateless.test.tsx
================================================
import React from "react"
import PropTypes from "prop-types"
import { observer, PropTypes as MRPropTypes } from "../src"
import { render, act } from "@testing-library/react"
import { observable } from "mobx"

const StatelessComp = ({ testProp }) => <div>result: {testProp}</div>

StatelessComp.propTypes = {
    testProp: PropTypes.string
}
StatelessComp.defaultProps = {
    testProp: "default value for prop testProp"
}

// skipping because `propTypes` and `defaultProps` are dropped in React 19
describe.skip("stateless component with propTypes", () => {
    const StatelessCompObserver: React.FunctionComponent<any> = observer(StatelessComp)

    test("default property value should be propagated", () => {
        expect(StatelessComp.defaultProps.testProp).toBe("default value for prop testProp")
        expect(StatelessCompObserver.defaultProps!.testProp).toBe("default value for prop testProp")
    })

    const originalConsoleError = console.error
    let beenWarned = false
    console.error = () => (beenWarned = true)
    // eslint-disable-next-line no-unused-vars
    const wrapper = <StatelessCompObserver testProp={10} />
    console.error = originalConsoleError

    test("an error should be logged with a property type warning", () => {
        expect(beenWarned).toBeTruthy()
    })

    test("render test correct", async () => {
        const { container } = render(<StatelessCompObserver testProp="hello world" />)
        expect(container.textContent).toBe("result: hello world")
    })
})

test("stateless component with context support", () => {
    const C = React.createContext<any>({})

    const StateLessCompWithContext = () => (
        <C.Consumer>{value => <div>context: {value.testContext}</div>}</C.Consumer>
    )

    const StateLessCompWithContextObserver = observer(StateLessCompWithContext)

    const ContextProvider = () => (
        <C.Provider value={{ testContext: "hello world" }}>
            <StateLessCompWithContextObserver />
        </C.Provider>
    )

    const { container } = render(<ContextProvider />)
    expect(container.textContent).toBe("context: hello world")
})

// propTypes validation seems to have been removed from class components in React 19: https://react.dev/reference/react/Component
test.skip("component with observable propTypes", () => {
    class Comp extends React.Component {
        render() {
            return null
        }
        static propTypes = {
            a1: MRPropTypes.observableArray,
            a2: MRPropTypes.arrayOrObservableArray
        }
    }
    const originalConsoleError = console.error
    const warnings: Array<any> = []
    console.error = msg => warnings.push(msg)
    // eslint-disable-next-line no-unused-vars
    const firstWrapper = <Comp a1={[]} a2={[]} />
    expect(warnings.length).toBe(1)
    // eslint-disable-next-line no-unused-vars
    const secondWrapper = <Comp a1={observable([])} a2={observable([])} />
    expect(warnings.length).toBe(1)
    console.error = originalConsoleError
})

describe("stateless component with forwardRef", () => {
    const a = observable({
        x: 1
    })
    const ForwardRefCompObserver: React.ForwardRefExoticComponent<any> = observer(
        React.forwardRef(({ testProp }, ref) => {
            return (
                <div>
                    result: {testProp}, {ref ? "got ref" : "no ref"}, a.x: {a.x}
                </div>
            )
        })
    )

    test("render test correct", () => {
        const { container } = render(
            <ForwardRefCompObserver testProp="hello world" ref={React.createRef()} />
        )
        expect(container).toMatchSnapshot()
    })

    test("is reactive", () => {
        const { container } = render(
            <ForwardRefCompObserver testProp="hello world" ref={React.createRef()} />
        )
        act(() => {
            a.x++
        })
        expect(container).toMatchSnapshot()
    })
})



================================================
FILE: packages/mobx-react/__tests__/timerBasedFinalizationRegistry.tsx
================================================
import "./utils/killFinalizationRegistry"
import { cleanup, render, act } from "@testing-library/react"
import * as mobx from "mobx"
import * as React from "react"
import { observer } from "../src"
import { clearTimers } from "mobx-react-lite"

expect(globalThis.FinalizationRegistry).toBeUndefined()

afterEach(cleanup)

test("should unregister from FinalizationRegistry once commited #3776", async () => {
    const o = mobx.observable({ x: 0 })

    @observer
    class TestCmp extends React.Component<any> {
        render() {
            return o.x
        }
    }

    const { unmount, container } = render(<TestCmp />)

    expect(container).toHaveTextContent("0")

    // If not unregistered, clearTimes disposes reaction
    clearTimers()

    act(() => {
        o.x++
    })

    expect(container).toHaveTextContent("1")

    unmount()
})



================================================
FILE: packages/mobx-react/__tests__/transactions.test.tsx
================================================
import React from "react"
import { autorun, computed, observable, transaction } from "mobx"
import { observer } from "../src"
import { render, act } from "@testing-library/react"

test("mobx issue 50", async () => {
    const foo = {
        a: observable.box(true),
        b: observable.box(false),
        c: computed(function () {
            // console.log("evaluate c")
            return foo.b.get()
        })
    }
    function flipStuff() {
        transaction(() => {
            foo.a.set(!foo.a.get())
            foo.b.set(!foo.b.get())
        })
    }
    let asText = ""
    autorun(() => (asText = [foo.a.get(), foo.b.get(), foo.c.get()].join(":")))
    const Test = observer(
        class Test extends React.Component {
            render() {
                return <div id="x">{[foo.a.get(), foo.b.get(), foo.c.get()].join(",")}</div>
            }
        }
    )

    render(<Test />)

    // Flip a and b. This will change c.
    act(() => flipStuff())

    expect(asText).toBe("false:true:true")
    expect(document.getElementById("x")!.innerHTML).toBe("false,true,true")
})

test("ReactDOM.render should respect transaction", () => {
    const a = observable.box(2)
    const loaded = observable.box(false)
    const valuesSeen: Array<number> = []

    const Component = observer(() => {
        valuesSeen.push(a.get())
        if (loaded.get()) return <div>{a.get()}</div>
        else return <div>loading</div>
    })

    const { container } = render(<Component />)

    act(() =>
        transaction(() => {
            a.set(3)
            a.set(4)
            loaded.set(true)
        })
    )

    expect(container.textContent).toBe("4")
    expect(valuesSeen.sort()).toEqual([2, 4].sort())
})



================================================
FILE: packages/mobx-react/__tests__/tsconfig.json
================================================
{
    "extends": "../tsconfig.test.json"
}



================================================
FILE: packages/mobx-react/__tests__/.eslintrc.yaml
================================================
env:
    jest: true
rules:
    "react/display-name": "off"
    "react/prop-types": "off"



================================================
FILE: packages/mobx-react/__tests__/__snapshots__/hooks.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`computed properties react to props when using hooks 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.",
    ],
    [
      "[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;



================================================
FILE: packages/mobx-react/__tests__/__snapshots__/observer.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`#3492 should not cause warning by calling forceUpdate on uncommited components 1`] = `[MockFunction]`;

exports[`Redeclaring an existing observer component as an observer should throw 1`] = `"The provided component class (AlreadyObserver) has already been declared as an observer component."`;

exports[`SSR works #3448 1`] = `[MockFunction]`;

exports[`issue 12 1`] = `
<div>
  <div>
    <span>
      coffee
      !
    </span>
    <span>
      tea
    </span>
  </div>
</div>
`;

exports[`issue 12 2`] = `
<div>
  <div>
    <span>
      soup
    </span>
  </div>
</div>
`;



================================================
FILE: packages/mobx-react/__tests__/__snapshots__/stateless.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`stateless component with forwardRef is reactive 1`] = `
<div>
  <div>
    result: 
    hello world
    , 
    got ref
    , a.x: 
    2
  </div>
</div>
`;

exports[`stateless component with forwardRef render test correct 1`] = `
<div>
  <div>
    result: 
    hello world
    , 
    got ref
    , a.x: 
    1
  </div>
</div>
`;



================================================
FILE: packages/mobx-react/__tests__/utils/compile-ts.tsx
================================================
import React from "react"
import ReactDOM from "react-dom"
import PropTypes from "prop-types"
import {
    observer,
    Provider,
    inject,
    Observer,
    disposeOnUnmount,
    PropTypes as MRPropTypes,
    useLocalStore
} from "../src"

@observer
class T1 extends React.Component<{ pizza: number }, {}> {
    render() {
        return <div>{this.props.pizza}</div>
    }
}

const T2 = observer(
    class T2 extends React.Component<{ cake: number; zoem: any[] }> {
        defaultProps = { cake: 7 }
        render() {
            return (
                <div>
                    <T1 pizza={this.props.cake} />
                </div>
            )
        }
        static propTypes = {
            zoem: MRPropTypes.arrayOrObservableArray
        }
    }
)

const T3 = observer((props: { hamburger: number }) => {
    return <T2 cake={props.hamburger} zoem={[]} />
})

const T4 = ({ sandwich }: { sandwich: number }) => (
    <div>
        <T3 hamburger={sandwich} />
    </div>
)

const T5 = observer(() => {
    return <T3 hamburger={17} />
})

@observer
class T6 extends React.Component<{}, {}> {
    render() {
        return (
            <span>
                <T3 hamburger={6} />
                {/* doesn't work with tsc 1.7.5: https://github.com/Microsoft/TypeScript/issues/5675 */}
                {/*<T4 sandwich={5} />*/}
                <T5 />
            </span>
        )
    }
}

const x = React.createElement(T3, { hamburger: 4 })

class T7 extends React.Component<{ pizza: number }, {}> {
    render() {
        return <div>{this.props.pizza}</div>
    }
}
React.createElement(observer(T7), { pizza: 4 })

ReactDOM.render(<T5 />, document.body)

class ProviderTest extends React.Component<any, any> {
    render() {
        return (
            <Provider foo={32}>
                <div>hi</div>
            </Provider>
        )
    }
}

@inject(() => ({ x: 3 }))
class T11 extends React.Component<{ pizza: number; x?: number }, {}> {
    render() {
        return (
            <div>
                {this.props.pizza}
                {this.props.x}
            </div>
        )
    }
}

class T15 extends React.Component<{ pizza: number; x?: number }, {}> {
    render() {
        return (
            <div>
                {this.props.pizza}
                {this.props.x}
            </div>
        )
    }
}
const T16 = inject(() => ({ x: 3 }))(T15)

class T17 extends React.Component<{}, {}> {
    render() {
        return (
            <div>
                <T11 pizza={3} x={1} />
                <T15 pizza={3} x={1} />
                <T16 pizza={4} x={2} />
                <T11 pizza={3} />
                <T15 pizza={3} />
                <T16 pizza={4} />
            </div>
        )
    }
}

@inject("a", "b")
class T12 extends React.Component<{ pizza: number }, {}> {
    render() {
        return <div>{this.props.pizza}</div>
    }
}

@inject("a", "b")
@observer
class T13 extends React.Component<{ pizza: number }, {}> {
    render() {
        return <div>{this.props.pizza}</div>
    }
}

const LoginContainer = inject((allStores, props) => ({
    store: { y: true, z: 2 },
    z: 7
}))(
    observer(
        class _LoginContainer extends React.Component<
            {
                x: string
                store?: { y: boolean; z: number }
            },
            {}
        > {
            static contextTypes: React.ValidationMap<any> = {
                router: PropTypes.func.isRequired
            }

            render() {
                return (
                    <div>
                        Hello!
                        {this.props.x}
                        {this.props.store!.y}
                    </div>
                )
            }
        }
    )
)
ReactDOM.render(<LoginContainer x="test" />, document.body)

@inject(allStores => ({
    store: { y: true, z: 2 }
}))
@observer
class LoginContainer2 extends React.Component<
    {
        x: string
        store?: { y: boolean }
    },
    {}
> {
    static contextTypes: React.ValidationMap<any> = {
        router: PropTypes.func.isRequired
    }

    render() {
        return (
            <div>
                Hello!
                {this.props.x}
                {this.props.store!.y}
            </div>
        )
    }
}

ReactDOM.render(<LoginContainer2 x="test" />, document.body)

class ObserverTest extends React.Component<any, any> {
    render() {
        return <Observer>{() => <div>test</div>}</Observer>
    }
}

class ObserverTest2 extends React.Component<any, any> {
    render() {
        return <Observer render={() => <div>test</div>} />
    }
}

@observer
class ComponentWithoutPropsAndState extends React.Component<{}, {}> {
    componentDidUpdate() {}

    render() {
        return <div>Hello!</div>
    }
}

const AppInner = observer((props: { a: number }) => {
    return (
        <div>
            <h1>Hello</h1>
            {props.a}
        </div>
    )
})

const App = inject("store")(AppInner)

App.wrappedComponent

@inject("store")
@observer
class App2 extends React.Component<{ a: number }, {}> {}

class InjectSomeStores extends React.Component<{ x: any }, {}> {
    render() {
        return <div>Hello World</div>
    }
}

inject(({ x }) => ({ x }))(InjectSomeStores)

{
    class T extends React.Component<{ x: number }> {
        render() {
            return <div />
        }
    }

    const Injected = inject("test")(T)
    ;<Injected.wrappedComponent x={3} />
}

{
    // just to make sure it compiles
    class DisposeOnUnmountComponent extends React.Component<{}> {
        @disposeOnUnmount
        methodA = () => {}

        methodB = disposeOnUnmount(this, () => {})
        manyMethods = disposeOnUnmount(this, [() => {}, () => {}])
    }

    // manual tests: this should not compile when the decorator is not applied over a react component class
    /*
    class DisposeOnUnmountNotAComponent {
        @disposeOnUnmount
        methodA = () => {}

        methodB = disposeOnUnmount(this, () => {})
    }
    */
}

{
    const TestComponent = () => {
        const observable = useLocalStore(() => ({
            test: 3
        }))

        return <h1>{observable.test * 2}</h1>
    }
    ;<TestComponent />
}

test("ok", () => {
    // just to satisfy jest
})



================================================
FILE: packages/mobx-react/__tests__/utils/ErrorCatcher.tsx
================================================
import React from "react"

interface ErrorCatcherState {
    hasError: boolean
}

// FIXME: saddly, this does not work as hoped, see: https://github.com/facebook/react/issues/10474#issuecomment-332810203
export default class ErrorCatcher extends React.Component<any, Readonly<ErrorCatcherState>> {
    static lastError
    static getError
    constructor(props) {
        super(props)
        this.state = { hasError: false }
    }

    componentDidCatch(error, info) {
        console.error("Caught react error", error, info)
        ErrorCatcher.lastError = "" + error
        this.setState({ hasError: true })
    }

    render() {
        if (this.state.hasError) {
            return null
        }
        return this.props.children
    }
}

ErrorCatcher.lastError = ""
ErrorCatcher.getError = function () {
    const res = ErrorCatcher.lastError
    ErrorCatcher.lastError = ""
    return res
}



================================================
FILE: packages/mobx-react/__tests__/utils/killFinalizationRegistry.ts
================================================
// We want to be able to test reaction cleanup code that based on FinalizationRegistry & timers on the same run
// For that we import this file on the beginning on the timer based test to the feature detection will pick the timers impl
// @ts-ignore
global.FinalizationRegistry = undefined



================================================
FILE: packages/mobx-react/__tests__/utils/withConsole.ts
================================================
import mockConsole, { MockObj } from "jest-mock-console"

export function withConsole(fn: Function): void
export function withConsole(settings: MockObj, fn: Function): void
export function withConsole(props: Array<ConsoleProps>, fn: Function): void

export function withConsole(...args: Array<any>): void {
    let settings
    let fn
    if (typeof args[0] === "function") {
        fn = args[0]
    } else if (Array.isArray(args[0]) || typeof args[0] === "object") {
        settings = args[0]

        if (typeof args[1] === "function") {
            fn = args[1]
        }
    }
    const restoreConsole = mockConsole(settings)
    fn && fn()
    restoreConsole()
}



================================================
FILE: packages/mobx-react/src/disposeOnUnmount.ts
================================================
import React from "react"
import { patch } from "./utils/utils"

const reactMajorVersion = Number.parseInt(React.version.split(".")[0])
let warnedAboutDisposeOnUnmountDeprecated = false

type Disposer = () => void

const protoStoreKey = Symbol("disposeOnUnmountProto")
const instStoreKey = Symbol("disposeOnUnmountInst")

function runDisposersOnWillUnmount() {
    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {
        const prop =
            typeof propKeyOrFunction === "string" ? this[propKeyOrFunction] : propKeyOrFunction
        if (prop !== undefined && prop !== null) {
            if (Array.isArray(prop)) prop.map(f => f())
            else prop()
        }
    })
}

/**
 * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.
 */
export function disposeOnUnmount(target: React.Component<any, any>, propertyKey: PropertyKey): void

/**
 * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.
 */
export function disposeOnUnmount<TF extends Disposer | Array<Disposer>>(
    target: React.Component<any, any>,
    fn: TF
): TF

/**
 * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.
 */
export function disposeOnUnmount(
    target: React.Component<any, any>,
    propertyKeyOrFunction: PropertyKey | Disposer | Array<Disposer>
): PropertyKey | Disposer | Array<Disposer> | void {
    if (Array.isArray(propertyKeyOrFunction)) {
        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))
    }

    if (!warnedAboutDisposeOnUnmountDeprecated) {
        if (reactMajorVersion >= 18) {
            console.error(
                "[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it."
            )
        } else {
            console.warn(
                "[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher."
            )
        }
        warnedAboutDisposeOnUnmountDeprecated = true
    }

    const c = Object.getPrototypeOf(target).constructor
    const c2 = Object.getPrototypeOf(target.constructor)
    // Special case for react-hot-loader
    const c3 = Object.getPrototypeOf(Object.getPrototypeOf(target))
    if (
        !(
            c === React.Component ||
            c === React.PureComponent ||
            c2 === React.Component ||
            c2 === React.PureComponent ||
            c3 === React.Component ||
            c3 === React.PureComponent
        )
    ) {
        throw new Error(
            "[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent."
        )
    }

    if (
        typeof propertyKeyOrFunction !== "string" &&
        typeof propertyKeyOrFunction !== "function" &&
        !Array.isArray(propertyKeyOrFunction)
    ) {
        throw new Error(
            "[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function."
        )
    }

    // decorator's target is the prototype, so it doesn't have any instance properties like props
    const isDecorator = typeof propertyKeyOrFunction === "string"

    // add property key / function we want run (disposed) to the store
    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]
    const store = isDecorator
        ? // decorators are added to the prototype store
          target[protoStoreKey] || (target[protoStoreKey] = [])
        : // functions are added to the instance store
          target[instStoreKey] || (target[instStoreKey] = [])

    store.push(propertyKeyOrFunction)

    // tweak the component class componentWillUnmount if not done already
    if (!componentWasAlreadyModified) {
        patch(target, "componentWillUnmount", runDisposersOnWillUnmount)
    }

    // return the disposer as is if invoked as a non decorator
    if (typeof propertyKeyOrFunction !== "string") {
        return propertyKeyOrFunction
    }
}



================================================
FILE: packages/mobx-react/src/globals.d.ts
================================================
declare const __DEV__: boolean



================================================
FILE: packages/mobx-react/src/index.ts
================================================
import { observable } from "mobx"
import { Component } from "react"

if (!Component) {
    throw new Error("mobx-react requires React to be available")
}

if (!observable) {
    throw new Error("mobx-react requires mobx to be available")
}

export {
    Observer,
    useObserver,
    useAsObservableSource,
    useLocalStore,
    isUsingStaticRendering,
    useStaticRendering,
    enableStaticRendering,
    observerBatching,
    useLocalObservable
} from "mobx-react-lite"

export { observer } from "./observer"

export { MobXProviderContext, Provider, ProviderProps } from "./Provider"
export { inject } from "./inject"
export { disposeOnUnmount } from "./disposeOnUnmount"
export { PropTypes } from "./propTypes"
export { IWrappedComponent } from "./types/IWrappedComponent"



================================================
FILE: packages/mobx-react/src/inject.ts
================================================
import React from "react"
import { observer } from "./observer"
import { copyStaticProperties } from "./utils/utils"
import { MobXProviderContext } from "./Provider"
import { IReactComponent } from "./types/IReactComponent"
import { IValueMap } from "./types/IValueMap"
import { IWrappedComponent } from "./types/IWrappedComponent"
import { IStoresToProps } from "./types/IStoresToProps"

/**
 * Store Injection
 */
function createStoreInjector(
    grabStoresFn: IStoresToProps,
    component: IReactComponent<any>,
    injectNames: string,
    makeReactive: boolean
): IReactComponent<any> {
    // Support forward refs
    let Injector: IReactComponent<any> = React.forwardRef((props, ref) => {
        const newProps = { ...props }
        const context = React.useContext(MobXProviderContext)
        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {})

        if (ref) {
            newProps.ref = ref
        }

        return React.createElement(component, newProps)
    })

    if (makeReactive) Injector = observer(Injector)
    Injector["isMobxInjector"] = true // assigned late to suppress observer warning

    // Static fields from component should be visible on the generated Injector
    copyStaticProperties(component, Injector)
    Injector["wrappedComponent"] = component
    Injector.displayName = getInjectName(component, injectNames)
    return Injector
}

function getInjectName(component: IReactComponent<any>, injectNames: string): string {
    let displayName
    const componentName =
        component.displayName ||
        component.name ||
        (component.constructor && component.constructor.name) ||
        "Component"
    if (injectNames) displayName = "inject-with-" + injectNames + "(" + componentName + ")"
    else displayName = "inject(" + componentName + ")"
    return displayName
}

function grabStoresByName(
    storeNames: Array<string>
): (
    baseStores: IValueMap,
    nextProps: React.ClassAttributes<any>
) => React.PropsWithRef<any> | undefined {
    return function (baseStores, nextProps) {
        storeNames.forEach(function (storeName) {
            if (
                storeName in nextProps // prefer props over stores
            )
                return
            if (!(storeName in baseStores))
                throw new Error(
                    "MobX injector: Store '" +
                        storeName +
                        "' is not available! Make sure it is provided by some Provider"
                )
            nextProps[storeName] = baseStores[storeName]
        })
        return nextProps
    }
}

export function inject(
    ...stores: Array<string>
): <T extends IReactComponent<any>>(
    target: T
) => T & (T extends IReactComponent<infer P> ? IWrappedComponent<P> : never)
export function inject<S extends IValueMap = {}, P extends IValueMap = {}, I extends IValueMap = {}, C extends IValueMap = {}>(
    fn: IStoresToProps<S, P, I, C>
): <T extends IReactComponent>(target: T) => T & IWrappedComponent<P>

/**
 * higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */
export function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames: Array<any>) {
    if (typeof arguments[0] === "function") {
        let grabStoresFn = arguments[0]
        return (componentClass: React.ComponentClass<any, any>) =>
            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)
    } else {
        return (componentClass: React.ComponentClass<any, any>) =>
            createStoreInjector(
                grabStoresByName(storeNames),
                componentClass,
                storeNames.join("-"),
                false
            )
    }
}



================================================
FILE: packages/mobx-react/src/observer.tsx
================================================
import * as React from "react"
import { observer as observerLite } from "mobx-react-lite"

import { makeClassComponentObserver } from "./observerClass"
import { IReactComponent } from "./types/IReactComponent"

/**
 * Observer function / decorator
 */
export function observer<T extends IReactComponent>(component: T, context: ClassDecoratorContext): void
export function observer<T extends IReactComponent>(component: T): T
export function observer<T extends IReactComponent>(component: T, context?: ClassDecoratorContext): T {
    if (context && context.kind !== "class") {
        throw new Error("The @observer decorator can be used on classes only")
    }
    if (component["isMobxInjector"] === true) {
        console.warn(
            "Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`"
        )
    }

    if (
        Object.prototype.isPrototypeOf.call(React.Component, component) ||
        Object.prototype.isPrototypeOf.call(React.PureComponent, component)
    ) {
        // Class component
        return makeClassComponentObserver(component as React.ComponentClass<any, any>) as T
    } else {
        // Function component
        return observerLite(component as React.FunctionComponent<any>) as T
    }
}



================================================
FILE: packages/mobx-react/src/observerClass.ts
================================================
import { PureComponent, Component, ComponentClass, ClassAttributes } from "react"
import {
    _allowStateChanges,
    Reaction,
    _allowStateReadsStart,
    _allowStateReadsEnd,
    _getGlobalState
} from "mobx"
import {
    isUsingStaticRendering,
    _observerFinalizationRegistry as observerFinalizationRegistry
} from "mobx-react-lite"
import { shallowEqual, patch } from "./utils/utils"

const administrationSymbol = Symbol("ObserverAdministration")
const isMobXReactObserverSymbol = Symbol("isMobXReactObserver")

let observablePropDescriptors: PropertyDescriptorMap
if (__DEV__) {
    observablePropDescriptors = {
        props: createObservablePropDescriptor("props"),
        state: createObservablePropDescriptor("state"),
        context: createObservablePropDescriptor("context")
    }
}

type ObserverAdministration = {
    reaction: Reaction | null // also serves as disposed flag
    forceUpdate: Function | null
    mounted: boolean // we could use forceUpdate as mounted flag
    reactionInvalidatedBeforeMount: boolean
    name: string
    // Used only on __DEV__
    props: any
    state: any
    context: any
}

function getAdministration(component: Component): ObserverAdministration {
    // We create administration lazily, because we can't patch constructor
    // and the exact moment of initialization partially depends on React internals.
    // At the time of writing this, the first thing invoked is one of the observable getter/setter (state/props/context).
    return (component[administrationSymbol] ??= {
        reaction: null,
        mounted: false,
        reactionInvalidatedBeforeMount: false,
        forceUpdate: null,
        name: getDisplayName(component.constructor as ComponentClass),
        state: undefined,
        props: undefined,
        context: undefined
    })
}

export function makeClassComponentObserver(
    componentClass: ComponentClass<any, any>
): ComponentClass<any, any> {
    const { prototype } = componentClass

    if (componentClass[isMobXReactObserverSymbol]) {
        const displayName = getDisplayName(componentClass)
        throw new Error(
            `The provided component class (${displayName}) has already been declared as an observer component.`
        )
    } else {
        componentClass[isMobXReactObserverSymbol] = true
    }

    if (prototype.componentWillReact) {
        throw new Error("The componentWillReact life-cycle event is no longer supported")
    }
    if (componentClass["__proto__"] !== PureComponent) {
        if (!prototype.shouldComponentUpdate) {
            prototype.shouldComponentUpdate = observerSCU
        } else if (prototype.shouldComponentUpdate !== observerSCU) {
            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well
            throw new Error(
                "It is not allowed to use shouldComponentUpdate in observer based components."
            )
        }
    }

    if (__DEV__) {
        Object.defineProperties(prototype, observablePropDescriptors)
    }

    const originalRender = prototype.render
    if (typeof originalRender !== "function") {
        const displayName = getDisplayName(componentClass)
        throw new Error(
            `[mobx-react] class component (${displayName}) is missing \`render\` method.` +
                `\n\`observer\` requires \`render\` being a function defined on prototype.` +
                `\n\`render = () => {}\` or \`render = function() {}\` is not supported.`
        )
    }

    prototype.render = function () {
        Object.defineProperty(this, "render", {
            // There is no safe way to replace render, therefore it's forbidden.
            configurable: false,
            writable: false,
            value: isUsingStaticRendering()
                ? originalRender
                : createReactiveRender.call(this, originalRender)
        })
        return this.render()
    }

    const originalComponentDidMount = prototype.componentDidMount
    prototype.componentDidMount = function () {
        if (__DEV__ && this.componentDidMount !== Object.getPrototypeOf(this).componentDidMount) {
            const displayName = getDisplayName(componentClass)
            throw new Error(
                `[mobx-react] \`observer(${displayName}).componentDidMount\` must be defined on prototype.` +
                    `\n\`componentDidMount = () => {}\` or \`componentDidMount = function() {}\` is not supported.`
            )
        }

        // `componentDidMount` may not be called at all. React can abandon the instance after `render`.
        // That's why we use finalization registry to dispose reaction created during render.
        // Happens with `<Suspend>` see #3492
        //
        // `componentDidMount` can be called immediately after `componentWillUnmount` without calling `render` in between.
        // Happens with `<StrictMode>`see #3395.
        //
        // If `componentDidMount` is called, it's guaranteed to run synchronously with render (similary to `useLayoutEffect`).
        // Therefore we don't have to worry about external (observable) state being updated before mount (no state version checking).
        //
        // Things may change: "In the future, React will provide a feature that lets components preserve state between unmounts"

        const admin = getAdministration(this)

        admin.mounted = true

        // Component instance committed, prevent reaction disposal.
        observerFinalizationRegistry.unregister(this)

        // We don't set forceUpdate before mount because it requires a reference to `this`,
        // therefore `this` could NOT be garbage collected before mount,
        // preventing reaction disposal by FinalizationRegistry and leading to memory leak.
        // As an alternative we could have `admin.instanceRef = new WeakRef(this)`, but lets avoid it if possible.
        admin.forceUpdate = () => this.forceUpdate()

        if (!admin.reaction || admin.reactionInvalidatedBeforeMount) {
            // Missing reaction:
            // 1. Instance was unmounted (reaction disposed) and immediately remounted without running render #3395.
            // 2. Reaction was disposed by finalization registry before mount. Shouldn't ever happen for class components:
            // `componentDidMount` runs synchronously after render, but our registry are deferred (can't run in between).
            // In any case we lost subscriptions to observables, so we have to create new reaction and re-render to resubscribe.
            // The reaction will be created lazily by following render.

            // Reaction invalidated before mount:
            // 1. A descendant's `componenDidMount` invalidated it's parent #3730

            admin.forceUpdate()
        }
        return originalComponentDidMount?.apply(this, arguments)
    }

    // TODO@major Overly complicated "patch" is only needed to support the deprecated @disposeOnUnmount
    patch(prototype, "componentWillUnmount", function () {
        if (isUsingStaticRendering()) {
            return
        }
        const admin = getAdministration(this)
        admin.reaction?.dispose()
        admin.reaction = null
        admin.forceUpdate = null
        admin.mounted = false
        admin.reactionInvalidatedBeforeMount = false
    })

    return componentClass
}

// Generates a friendly name for debugging
function getDisplayName(componentClass: ComponentClass) {
    return componentClass.displayName || componentClass.name || "<component>"
}

function createReactiveRender(originalRender: any) {
    const boundOriginalRender = originalRender.bind(this)

    const admin = getAdministration(this)

    function reactiveRender() {
        if (!admin.reaction) {
            // Create reaction lazily to support re-mounting #3395
            admin.reaction = createReaction(admin)
            if (!admin.mounted) {
                // React can abandon this instance and never call `componentDidMount`/`componentWillUnmount`,
                // we have to make sure reaction will be disposed.
                observerFinalizationRegistry.register(this, admin, this)
            }
        }

        let error: unknown = undefined
        let renderResult = undefined
        admin.reaction.track(() => {
            try {
                // TODO@major
                // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)
                renderResult = _allowStateChanges(false, boundOriginalRender)
            } catch (e) {
                error = e
            }
        })
        if (error) {
            throw error
        }
        return renderResult
    }

    return reactiveRender
}

function createReaction(admin: ObserverAdministration) {
    return new Reaction(`${admin.name}.render()`, () => {
        if (!admin.mounted) {
            // This is neccessary to avoid react warning about calling forceUpdate on component that isn't mounted yet.
            // This happens when component is abandoned after render - our reaction is already created and reacts to changes.
            // `componenDidMount` runs synchronously after `render`, so unlike functional component, there is no delay during which the reaction could be invalidated.
            // However `componentDidMount` runs AFTER it's descendants' `componentDidMount`, which CAN invalidate the reaction, see #3730. Therefore remember and forceUpdate on mount.
            admin.reactionInvalidatedBeforeMount = true
            return
        }

        try {
            admin.forceUpdate?.()
        } catch (error) {
            admin.reaction?.dispose()
            admin.reaction = null
        }
    })
}

function observerSCU(nextProps: ClassAttributes<any>, nextState: any): boolean {
    if (isUsingStaticRendering()) {
        console.warn(
            "[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."
        )
    }
    // update on any state changes (as is the default)
    if (this.state !== nextState) {
        return true
    }
    // update if props are shallowly not equal, inspired by PureRenderMixin
    // we could return just 'false' here, and avoid the `skipRender` checks etc
    // however, it is nicer if lifecycle events are triggered like usually,
    // so we return true here if props are shallowly modified.
    return !shallowEqual(this.props, nextProps)
}

function createObservablePropDescriptor(key: "props" | "state" | "context") {
    return {
        configurable: true,
        enumerable: true,
        get() {
            const admin = getAdministration(this)
            const derivation = _getGlobalState().trackingDerivation
            if (derivation && derivation !== admin.reaction) {
                throw new Error(
                    `[mobx-react] Cannot read "${admin.name}.${key}" in a reactive context, as it isn't observable.
                    Please use component lifecycle method to copy the value into a local observable first.
                    See https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations`
                )
            }
            return admin[key]
        },
        set(value) {
            getAdministration(this)[key] = value
        }
    }
}



================================================
FILE: packages/mobx-react/src/propTypes.ts
================================================
import { isObservableArray, isObservableObject, isObservableMap, untracked } from "mobx"

// Copied from React.PropTypes
function createChainableTypeChecker(validator: React.Validator<any>): React.Requireable<any> {
    function checkType(
        isRequired: boolean,
        props: any,
        propName: string,
        componentName: string,
        location: string,
        propFullName: string,
        ...rest: any[]
    ) {
        return untracked(() => {
            componentName = componentName || "<<anonymous>>"
            propFullName = propFullName || propName
            if (props[propName] == null) {
                if (isRequired) {
                    const actual = props[propName] === null ? "null" : "undefined"
                    return new Error(
                        "The " +
                            location +
                            " `" +
                            propFullName +
                            "` is marked as required " +
                            "in `" +
                            componentName +
                            "`, but its value is `" +
                            actual +
                            "`."
                    )
                }
                return null
            } else {
                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise
                return validator(props, propName, componentName, location, propFullName, ...rest)
            }
        })
    }

    const chainedCheckType: any = checkType.bind(null, false)
    // Add isRequired to satisfy Requirable
    chainedCheckType.isRequired = checkType.bind(null, true)
    return chainedCheckType
}

// Copied from React.PropTypes
function isSymbol(propType: any, propValue: any): boolean {
    // Native Symbol.
    if (propType === "symbol") {
        return true
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue["@@toStringTag"] === "Symbol") {
        return true
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true
    }

    return false
}

// Copied from React.PropTypes
function getPropType(propValue: any): string {
    const propType = typeof propValue
    if (Array.isArray(propValue)) {
        return "array"
    }
    if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return "object"
    }
    if (isSymbol(propType, propValue)) {
        return "symbol"
    }
    return propType
}

// This handles more types than `getPropType`. Only used for error messages.
// Copied from React.PropTypes
function getPreciseType(propValue: any): string {
    const propType = getPropType(propValue)
    if (propType === "object") {
        if (propValue instanceof Date) {
            return "date"
        } else if (propValue instanceof RegExp) {
            return "regexp"
        }
    }
    return propType
}

function createObservableTypeCheckerCreator(
    allowNativeType: any,
    mobxType: any
): React.Requireable<any> {
    return createChainableTypeChecker((props, propName, componentName, location, propFullName) => {
        return untracked(() => {
            if (allowNativeType) {
                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null
            }
            let mobxChecker
            switch (mobxType) {
                case "Array":
                    mobxChecker = isObservableArray
                    break
                case "Object":
                    mobxChecker = isObservableObject
                    break
                case "Map":
                    mobxChecker = isObservableMap
                    break
                default:
                    throw new Error(`Unexpected mobxType: ${mobxType}`)
            }
            const propValue = props[propName]
            if (!mobxChecker(propValue)) {
                const preciseType = getPreciseType(propValue)
                const nativeTypeExpectationMessage = allowNativeType
                    ? " or javascript `" + mobxType.toLowerCase() + "`"
                    : ""
                return new Error(
                    "Invalid prop `" +
                        propFullName +
                        "` of type `" +
                        preciseType +
                        "` supplied to" +
                        " `" +
                        componentName +
                        "`, expected `mobx.Observable" +
                        mobxType +
                        "`" +
                        nativeTypeExpectationMessage +
                        "."
                )
            }
            return null
        })
    })
}

function createObservableArrayOfTypeChecker(
    allowNativeType: boolean,
    typeChecker: React.Validator<any>
) {
    return createChainableTypeChecker(
        (props, propName, componentName, location, propFullName, ...rest) => {
            return untracked(() => {
                if (typeof typeChecker !== "function") {
                    return new Error(
                        "Property `" +
                            propFullName +
                            "` of component `" +
                            componentName +
                            "` has " +
                            "invalid PropType notation."
                    )
                } else {
                    let error = createObservableTypeCheckerCreator(allowNativeType, "Array")(
                        props,
                        propName,
                        componentName,
                        location,
                        propFullName
                    )

                    if (error instanceof Error) return error
                    const propValue = props[propName]
                    for (let i = 0; i < propValue.length; i++) {
                        error = (typeChecker as React.Validator<any>)(
                            propValue,
                            i as any,
                            componentName,
                            location,
                            propFullName + "[" + i + "]",
                            ...rest
                        )
                        if (error instanceof Error) return error
                    }

                    return null
                }
            })
        }
    )
}

const observableArray = createObservableTypeCheckerCreator(false, "Array")
const observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)
const observableMap = createObservableTypeCheckerCreator(false, "Map")
const observableObject = createObservableTypeCheckerCreator(false, "Object")
const arrayOrObservableArray = createObservableTypeCheckerCreator(true, "Array")
const arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)
const objectOrObservableObject = createObservableTypeCheckerCreator(true, "Object")

export const PropTypes = {
    observableArray,
    observableArrayOf,
    observableMap,
    observableObject,
    arrayOrObservableArray,
    arrayOrObservableArrayOf,
    objectOrObservableObject
}



================================================
FILE: packages/mobx-react/src/Provider.tsx
================================================
import React from "react"
import { shallowEqual } from "./utils/utils"
import { IValueMap } from "./types/IValueMap"

export const MobXProviderContext = React.createContext<IValueMap>({})

export interface ProviderProps extends IValueMap {
    children: React.ReactNode
}

export function Provider(props: ProviderProps) {
    const { children, ...stores } = props
    const parentValue = React.useContext(MobXProviderContext)
    const mutableProviderRef = React.useRef({ ...parentValue, ...stores })
    const value = mutableProviderRef.current

    if (__DEV__) {
        const newValue = { ...value, ...stores } // spread in previous state for the context based stores
        if (!shallowEqual(value, newValue)) {
            throw new Error(
                "MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error."
            )
        }
    }

    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>
}

Provider.displayName = "MobXProvider"



================================================
FILE: packages/mobx-react/src/types/IReactComponent.ts
================================================
export type IReactComponent<P = any> =
    | React.ClassicComponentClass<P>
    | React.ComponentClass<P>
    | React.FunctionComponent<P>
    | React.ForwardRefExoticComponent<P>



================================================
FILE: packages/mobx-react/src/types/IStoresToProps.ts
================================================
import { IValueMap } from "./IValueMap"
export type IStoresToProps<
    S extends IValueMap = {},
    P extends IValueMap = {},
    I extends IValueMap = {},
    C extends IValueMap = {}
> = (stores: S, nextProps: P, context?: C) => I



================================================
FILE: packages/mobx-react/src/types/IValueMap.ts
================================================
export type IValueMap = Record<string, any>



================================================
FILE: packages/mobx-react/src/types/IWrappedComponent.ts
================================================
import { IReactComponent } from "./IReactComponent"
export type IWrappedComponent<P> = {
    wrappedComponent: IReactComponent<P>
}



================================================
FILE: packages/mobx-react/src/utils/utils.ts
================================================
export function shallowEqual(objA: any, objB: any): boolean {
    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (is(objA, objB)) {
        return true
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false
    }
    const keysA = Object.keys(objA)
    const keysB = Object.keys(objB)
    if (keysA.length !== keysB.length) {
        return false
    }
    for (let i = 0; i < keysA.length; i++) {
        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false
        }
    }
    return true
}

function is(x: any, y: any): boolean {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y
    } else {
        return x !== x && y !== y
    }
}

// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js
const hoistBlackList = {
    $$typeof: 1,
    render: 1,
    compare: 1,
    type: 1,
    childContextTypes: 1,
    contextType: 1,
    contextTypes: 1,
    defaultProps: 1,
    getDefaultProps: 1,
    getDerivedStateFromError: 1,
    getDerivedStateFromProps: 1,
    mixins: 1,
    displayName: 1,
    propTypes: 1
}

export function copyStaticProperties(base: object, target: object): void {
    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))
    Object.getOwnPropertyNames(base).forEach(key => {
        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)
        }
    })
}

/**
 * Helper to set `prop` to `this` as non-enumerable (hidden prop)
 * @param target
 * @param prop
 * @param value
 */
export function setHiddenProp(target: object, prop: any, value: any): void {
    if (!Object.hasOwnProperty.call(target, prop)) {
        Object.defineProperty(target, prop, {
            enumerable: false,
            configurable: true,
            writable: true,
            value
        })
    } else {
        target[prop] = value
    }
}

/**
 * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks
 * and the handler provided by mobx-react
 */
const mobxMixins = Symbol("patchMixins")
const mobxPatchedDefinition = Symbol("patchedDefinition")

export interface Mixins extends Record<string, any> {
    locks: number
    methods: Array<Function>
}

function getMixins(target: object, methodName: string): Mixins {
    const mixins = (target[mobxMixins] = target[mobxMixins] || {})
    const methodMixins = (mixins[methodName] = mixins[methodName] || {})
    methodMixins.locks = methodMixins.locks || 0
    methodMixins.methods = methodMixins.methods || []
    return methodMixins
}

function wrapper(realMethod: Function, mixins: Mixins, ...args: Array<any>) {
    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls
    mixins.locks++

    try {
        let retVal
        if (realMethod !== undefined && realMethod !== null) {
            retVal = realMethod.apply(this, args)
        }

        return retVal
    } finally {
        mixins.locks--
        if (mixins.locks === 0) {
            mixins.methods.forEach(mx => {
                mx.apply(this, args)
            })
        }
    }
}

function wrapFunction(realMethod: Function, mixins: Mixins): (...args: Array<any>) => any {
    const fn = function (...args: Array<any>) {
        wrapper.call(this, realMethod, mixins, ...args)
    }
    return fn
}

export function patch(target: object, methodName: string, mixinMethod: Function): void {
    const mixins = getMixins(target, methodName)

    if (mixins.methods.indexOf(mixinMethod) < 0) {
        mixins.methods.push(mixinMethod)
    }

    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)
    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
        // already patched definition, do not repatch
        return
    }

    const originalMethod = target[methodName]
    const newDefinition = createDefinition(
        target,
        methodName,
        oldDefinition ? oldDefinition.enumerable : undefined,
        mixins,
        originalMethod
    )

    Object.defineProperty(target, methodName, newDefinition)
}

function createDefinition(
    target: object,
    methodName: string,
    enumerable: any,
    mixins: Mixins,
    originalMethod: Function
): PropertyDescriptor {
    let wrappedFunc = wrapFunction(originalMethod, mixins)

    return {
        // @ts-ignore
        [mobxPatchedDefinition]: true,
        get: function () {
            return wrappedFunc
        },
        set: function (value) {
            if (this === target) {
                wrappedFunc = wrapFunction(value, mixins)
            } else {
                // when it is an instance of the prototype/a child prototype patch that particular case again separately
                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc
                // e.g. the method for super might not be the same as the method for the prototype which might be not the same
                // as the method for the instance
                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)
                Object.defineProperty(this, methodName, newDefinition)
            }
        },
        configurable: true,
        enumerable: enumerable
    }
}



================================================
FILE: packages/mobx-react-lite/README.md
================================================
# mobx-react-lite

[![CircleCI](https://circleci.com/gh/mobxjs/mobx-react-lite.svg?style=svg)](https://circleci.com/gh/mobxjs/mobx-react-lite)
[![Coverage Status](https://coveralls.io/repos/github/mobxjs/mobx-react-lite/badge.svg)](https://coveralls.io/github/mobxjs/mobx-react-lite)
[![NPM downloads](https://img.shields.io/npm/dm/mobx-react-lite.svg?style=flat)](https://npmjs.com/package/mobx-react-lite)[![Minzipped size](https://img.shields.io/bundlephobia/minzip/mobx-react-lite.svg)](https://bundlephobia.com/result?p=mobx-react-lite)
[![Discuss on Github](https://img.shields.io/badge/discuss%20on-GitHub-orange)](https://github.com/mobxjs/mobx/discussions)
[![View changelog](https://img.shields.io/badge/changelogs.xyz-Explore%20Changelog-brightgreen)](https://changelogs.xyz/mobx-react-lite)

This is a lighter version of [mobx-react](https://github.com/mobxjs/mobx-react) which supports React **functional components only** and as such makes the library slightly faster and smaller (_only 1.5kB gzipped_). Note however that it is possible to use `<Observer>` inside the render of class components.
Unlike `mobx-react`, it doesn't `Provider`/`inject`, as `useContext` can be used instead.

## Compatibility table (major versions)

| mobx | mobx-react-lite | Browser                                        |
| ---- | --------------- | ---------------------------------------------- |
| 6    | 3               | Modern browsers (IE 11+ in compatibility mode) |
| 5    | 2               | Modern browsers                                |
| 4    | 2               | IE 11+, RN w/o Proxy support                   |

`mobx-react-lite` requires React 16.8 or higher.

## User Guide ğŸ‘‰ https://mobx.js.org/react-integration.html

---

## API reference âš’

### **`observer<P>(baseComponent: FunctionComponent<P>): FunctionComponent<P>`**

The observer converts a component into a reactive component, which tracks which observables are used automatically and re-renders the component when one of these values changes.
Can only be used for function components. For class component support see the `mobx-react` package.

### **`<Observer>{renderFn}</Observer>`**

Is a React component, which applies observer to an anonymous region in your component. `<Observer>` can be used both inside class and function components.

### **`useLocalObservable<T>(initializer: () => T, annotations?: AnnotationsMap<T>): T`**

Creates an observable object with the given properties, methods and computed values.

Note that computed values cannot directly depend on non-observable values, but only on observable values, so it might be needed to sync properties into the observable using `useEffect` (see the example below at `useAsObservableSource`).

`useLocalObservable` is a short-hand for:

`const [state] = useState(() => observable(initializer(), annotations, { autoBind: true }))`

### **`enableStaticRendering(enable: true)`**

Call `enableStaticRendering(true)` when running in an SSR environment, in which `observer` wrapped components should never re-render, but cleanup after the first rendering automatically. Use `isUsingStaticRendering()` to inspect the current setting.

---

## Deprecated APIs

### **`useObserver<T>(fn: () => T, baseComponentName = "observed", options?: IUseObserverOptions): T`** (deprecated)

_This API is deprecated in 3.\*. It is often used wrong (e.g. to select data rather than for rendering, and `<Observer>` better decouples the rendering from the component updates_

```ts
interface IUseObserverOptions {
    // optional custom hook that should make a component re-render (or not) upon changes
    // Supported in 2.x only
    useForceUpdate: () => () => void
}
```

It allows you to use an observer like behaviour, but still allowing you to optimize the component in any way you want (e.g. using memo with a custom areEqual, using forwardRef, etc.) and to declare exactly the part that is observed (the render phase).

### **`useLocalStore<T, S>(initializer: () => T, source?: S): T`** (deprecated)

_This API is deprecated in 3.\*. Use `useLocalObservable` instead. They do roughly the same, but `useLocalObservable` accepts an set of annotations as second argument, rather than a `source` object. Using `source` is not recommended, see the deprecation message at `useAsObservableSource` for details_

Local observable state can be introduced by using the useLocalStore hook, that runs its initializer function once to create an observable store and keeps it around for a lifetime of a component.

The annotations are similar to the annotations that are passed in to MobX's [`observable`](https://mobx.js.org/observable.html#available-annotations) API, and can be used to override the automatic member inference of specific fields.

### **`useAsObservableSource<T>(source: T): T`** (deprecated)

The useAsObservableSource hook can be used to turn any set of values into an observable object that has a stable reference (the same object is returned every time from the hook).

_This API is deprecated in 3.\* as it relies on observables to be updated during rendering which is an anti-pattern. Instead, use `useEffect` to synchronize non-observable values with values. Example:_

```javascript
// Before:
function Measurement({ unit }) {
    const observableProps = useAsObservableSource({ unit })
    const state = useLocalStore(() => ({
        length: 0,
        get lengthWithUnit() {
            // lengthWithUnit can only depend on observables, hence the above conversion with `useAsObservableSource`
            return observableProps.unit === "inch"
                ? `${this.length / 2.54} inch`
                : `${this.length} cm`
        }
    }))

    return <h1>{state.lengthWithUnit}</h1>
}

// After:
function Measurement({ unit }) {
    const state = useLocalObservable(() => ({
        unit, // the initial unit
        length: 0,
        get lengthWithUnit() {
            // lengthWithUnit can only depend on observables, hence the above conversion with `useAsObservableSource`
            return this.unit === "inch" ? `${this.length / 2.54} inch` : `${this.length} cm`
        }
    }))

    useEffect(() => {
        // sync the unit from 'props' into the observable 'state'
        state.unit = unit
    }, [unit])

    return <h1>{state.lengthWithUnit}</h1>
}
```

Note that, at your own risk, it is also possible to not use `useEffect`, but do `state.unit = unit` instead in the rendering.
This is closer to the old behavior, but React will warn correctly about this if this would affect the rendering of other components.

## Observer batching (deprecated)

_Note: configuring observer batching is only needed when using `mobx-react-lite` 2.0.* or 2.1.*. From 2.2 onward it will be configured automatically based on the availability of react-dom / react-native packages_

[Check out the elaborate explanation](https://github.com/mobxjs/mobx-react/pull/787#issuecomment-573599793).

In short without observer batching the React doesn't guarantee the order component rendering in some cases. We highly recommend that you configure batching to avoid these random surprises.

Import one of these before any React rendering is happening, typically `index.js/ts`. For Jest tests you can utilize [setupFilesAfterEnv](https://jestjs.io/docs/en/configuration#setupfilesafterenv-array).

**React DOM:**

> import 'mobx-react-lite/batchingForReactDom'

**React Native:**

> import 'mobx-react-lite/batchingForReactNative'

### Opt-out

To opt-out from batching in some specific cases, simply import the following to silence the warning.

> import 'mobx-react-lite/batchingOptOut'

### Custom batched updates

Above imports are for a convenience to utilize standard versions of batching. If you for some reason have customized version of batched updates, you can do the following instead.

```js
import { observerBatching } from "mobx-react-lite"
observerBatching(customBatchedUpdates)
```

## Testing

Running the full test suite now requires node 14+
But the library itself does not have this limitation

In order to avoid memory leaks due to aborted renders from React
fiber handling or React `StrictMode`, on environments that does not support [FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry), this library needs to
run timers to tidy up the remains of the aborted renders.

This can cause issues with test frameworks such as Jest
which require that timers be cleaned up before the tests
can exit.

### **`clearTimers()`**

Call `clearTimers()` in the `afterEach` of your tests to ensure
that `mobx-react-lite` cleans up immediately and allows tests
to exit.



================================================
FILE: packages/mobx-react-lite/batchingForReactDom.js
================================================
if ("production" !== process.env.NODE_ENV) {
    console.warn("[mobx-react-lite] importing batchingForReactDom is no longer needed")
}



================================================
FILE: packages/mobx-react-lite/batchingForReactNative.js
================================================
if ("production" !== process.env.NODE_ENV) {
    console.warn("[mobx-react-lite] importing batchingForReactNative is no longer needed")
}



================================================
FILE: packages/mobx-react-lite/batchingOptOut.js
================================================
if ("production" !== process.env.NODE_ENV) {
    console.warn("[mobx-react-lite] importing batchingOptOut is no longer needed")
}



================================================
FILE: packages/mobx-react-lite/CHANGELOG.md
================================================
# mobx-react-lite

## 4.1.0

### Minor Changes

-   [`2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0`](https://github.com/mobxjs/mobx/commit/2587df31a1a967a6b385b7ab2d9f0d42fc94e4b0) [#3985](https://github.com/mobxjs/mobx/pull/3985) Thanks [@imjordanxd](https://github.com/imjordanxd)! - \* Added React 19 support, fixes #3986

## 4.0.7

### Patch Changes

-   [`61abc53f`](https://github.com/mobxjs/mobx/commit/61abc53ff10554d1d5ce3e85466f6beda4d63fa2) [#3852](https://github.com/mobxjs/mobx/pull/3852) Thanks [@mweststrate](https://github.com/mweststrate)! - Patched the release process, forcing release to get everything in pristine state.

*   [`7bbb523a`](https://github.com/mobxjs/mobx/commit/7bbb523a7b81229570e0e2a176b989bfc74c4634) [#3842](https://github.com/mobxjs/mobx/pull/3842) Thanks [@r0b1n](https://github.com/r0b1n)! - Prevent warnings when using `mobx-react-lite` with Rollup

## 4.0.6

### Patch Changes

-   [`b970cbb4`](https://github.com/mobxjs/mobx/commit/b970cbb4dd2e43516d37f3f01c956cab3540d4d3) [#3830](https://github.com/mobxjs/mobx/pull/3830) Thanks [@dmitrytavern](https://github.com/dmitrytavern)! - fix #3826: components make two renders because of the different state of the snapshots

*   [`1b8ab199`](https://github.com/mobxjs/mobx/commit/1b8ab199df5e73d384cc40ec2d13915a690c14f3) [#3831](https://github.com/mobxjs/mobx/pull/3831) Thanks [@kitsuned](https://github.com/kitsuned)! - fix: ensure observer component name is only set when configurable

## 4.0.5

### Patch Changes

-   [`87e5dfb5`](https://github.com/mobxjs/mobx/commit/87e5dfb52a84869d62b6343887a1c8659aee595d) [#3763](https://github.com/mobxjs/mobx/pull/3763) Thanks [@mweststrate](https://github.com/mweststrate)! - Switched observer implementation from using global to local state version. Fixes #3728

## 4.0.4

### Patch Changes

-   [`3ceeb865`](https://github.com/mobxjs/mobx/commit/3ceeb8651e328c4c7211c875696b3f5269fea834) [#3732](https://github.com/mobxjs/mobx/pull/3732) Thanks [@urugator](https://github.com/urugator)! - fix: #3734: `isolateGlobalState: true` makes observer stop to react to store changes

## 4.0.3

### Patch Changes

-   [`58bb052c`](https://github.com/mobxjs/mobx/commit/58bb052ca41b8592e5bd5c3003b68ec52da53f33) [#3670](https://github.com/mobxjs/mobx/pull/3670) Thanks [@urugator](https://github.com/urugator)! - fix #3669: SSR: `useSyncExternalStore` throws due to missing `getServerSnapshot`

*   [`473cb3f5`](https://github.com/mobxjs/mobx/commit/473cb3f5fc8bf43abdd1c9c7857fe2820d2291fe) [#3718](https://github.com/mobxjs/mobx/pull/3718) Thanks [@mweststrate](https://github.com/mweststrate)! - - Fixed `observer` in `StrictMode` #3671
    -   **[BREAKING CHANGE]** Class component's `props`/`state`/`context` are no longer observable. Attempt to use these in any derivation other than component's `render` throws and error. For details see https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations
    -   Extending or applying `observer` classes is now explicitly forbidden

## 4.0.2

### Patch Changes

-   [`f86df867`](https://github.com/mobxjs/mobx/commit/f86df86784fa92d793ca4d1b97a3dd954355f7dd) [#3667](https://github.com/mobxjs/mobx/pull/3667) Thanks [@tony](https://github.com/tony)! - Fix package dependency for use-sync-external-store.

## 4.0.1

### Patch Changes

-   [`8e58fa95`](https://github.com/mobxjs/mobx/commit/8e58fa958908f632a2c49d22c259fda135781455) [#3664](https://github.com/mobxjs/mobx/pull/3664) Thanks [@mweststrate](https://github.com/mweststrate)! - (Hopefully) fixed release process for mobx-react-lite

## 4.0.0

### Major Changes

-   [`44a2cf42`](https://github.com/mobxjs/mobx/commit/44a2cf42dec7635f639ddbfb19202ebc710bac54) [#3590](https://github.com/mobxjs/mobx/pull/3590) Thanks [@urugator](https://github.com/urugator)! - Components now use `useSyncExternalStore`, which should prevent tearing - you have to update mobx, otherwise it should behave as previously.<br>
    Improved displayName/name handling as discussed in #3438.<br>

## 3.4.3

### Patch Changes

-   [`dfeb1f5d`](https://github.com/mobxjs/mobx/commit/dfeb1f5d18acb8a995d4fa78374173d419fec16e) [#3651](https://github.com/mobxjs/mobx/pull/3651) Thanks [@urugator](https://github.com/urugator)! - fix #3650 regression clearTimers -> clearTimes

## 3.4.2

### Patch Changes

-   [`7acaf305`](https://github.com/mobxjs/mobx/commit/7acaf305f81ac5457a8de272e42dd5634a97eb88) [#3645](https://github.com/mobxjs/mobx/pull/3645) Thanks [@urugator](https://github.com/urugator)! - fix FinalizationRegistry support check #3643

## 3.4.1

### Patch Changes

-   [`4ef8ff3f`](https://github.com/mobxjs/mobx/commit/4ef8ff3f84ec8ae893d8c84031664ea388d78091) [#3598](https://github.com/mobxjs/mobx/pull/3598) Thanks [@urugator](https://github.com/urugator)! - refactor reaction tracking

## 3.4.0

### Minor Changes

-   [`4c5e75cd`](https://github.com/mobxjs/mobx/commit/4c5e75cdfec08c04ad774c70dca0629bd2c77016) [#3382](https://github.com/mobxjs/mobx/pull/3382) Thanks [@iChenLei](https://github.com/iChenLei)! - replace the deprecated react type definition with recommended type definition

*   [`bd4b70d8`](https://github.com/mobxjs/mobx/commit/bd4b70d8ded29673af8161aa42fb88dc4ad4420e) [#3387](https://github.com/mobxjs/mobx/pull/3387) Thanks [@mweststrate](https://github.com/mweststrate)! - Added experimental / poor man's support for React 18. Fixes #3363, #2526. Supersedes #3005

    -   Updated tests, test / build infra, peerDependencies to React 18
    -   **[breaking icmw upgrading to React 18]** Already deprecated hooks like `useMutableSource` will trigger warnings in React 18, which is correct and those shouldn't be used anymore.
    -   **[breaking icmw upgrading to React 18]** When using React 18, it is important that `act` is used in **unit tests** around every programmatic mutation. Without it, changes won't propagate!
    -   The React 18 support is poor man's support; that is, we don't do anything yet to play nicely with Suspense features. Although e.g. [startTransition](https://github.com/mweststrate/platform-app/commit/bdd995773ddc6551235a4d2b0a4c9bd57d30510e) basically works, MobX as is doesn't respect the Suspense model and will always reflect the latest state that is being rendered with, so tearing might occur. I think this is in theoretically addressable by using `useSyncExternalStore` and capturing the current values together with the dependency tree of every component instance. However that isn't included in this pull request 1) it would be a breaking change, whereas the current change is still compatible with React 16 and 17. 2) I want to collect use cases where the tearing leads to problems first to build a better problem understanding. If you run into the problem, please submit an issue describing your scenario, and a PR with a unit tests demonstrating the problem in simplified form. For further discussion see #2526, #3005

## 3.3.0

### Minor Changes

-   [`59b42c28`](https://github.com/mobxjs/mobx/commit/59b42c2826208435353ce6bf154ae59077edcc05) [#3282](https://github.com/mobxjs/mobx/pull/3282) Thanks [@urugator](https://github.com/urugator)! - support `observable(forwardRef(fn))`, deprecate `observable(fn, { forwardRef: true })`, solve #2527, #3267

## 3.2.3

### Patch Changes

-   [`4887d200`](https://github.com/mobxjs/mobx/commit/4887d200ba5e1563717a0b4f55e09b9984437990) [#3192](https://github.com/mobxjs/mobx/pull/3192) Thanks [@urugator](https://github.com/urugator)! - Support customizing `displayName` on anonymous components [#2721](https://github.com/mobxjs/mobx/issues/2721).

## 3.2.2

### Patch Changes

-   [`2dcfec09`](https://github.com/mobxjs/mobx/commit/2dcfec093533bd12bb564580b14ce6037ee1ebac) [#3172](https://github.com/mobxjs/mobx/pull/3172) Thanks [@urugator](https://github.com/urugator)! - support legacy context

## 3.2.1

### Patch Changes

-   [`320544a5`](https://github.com/mobxjs/mobx/commit/320544a5d0defb1a1524c83c7a5d0a9dee9de001) [#2983](https://github.com/mobxjs/mobx/pull/2983) Thanks [@urugator](https://github.com/urugator)! - Allow force update to be called infinitely times

*   [`10c762cc`](https://github.com/mobxjs/mobx/commit/10c762cce4871f3599bac6acc2c56776e0b4badd) [#2995](https://github.com/mobxjs/mobx/pull/2995) Thanks [@Bnaya](https://github.com/Bnaya)! - Reduce useObserver gc pressure

## 3.2.0

### Patch Changes

-   Updated dependencies [[`28f8a11d`](https://github.com/mobxjs/mobx/commit/28f8a11d8b94f1aca2eec4ae9c5f45c5ea2f4362)]:
    -   mobx@6.1.0

## 3.1.7

### Patch Changes

-   [`592e6e99`](https://github.com/mobxjs/mobx/commit/592e6e996c2d5264e162cfb0921a071c1d815c92) [#2743](https://github.com/mobxjs/mobx/pull/2743) Thanks [@vkrol](https://github.com/vkrol)! - Remove `sideEffects` section in `mobx-react-lite` `package.json`

-   Updated dependencies [[`6b304232`](https://github.com/mobxjs/mobx/commit/6b30423266e5418a3f20389d0bd0eae31f3384d2), [`83b84fd3`](https://github.com/mobxjs/mobx/commit/83b84fd354f2253fdd8ea556e217a92fc2633c00), [`65c7b73b`](https://github.com/mobxjs/mobx/commit/65c7b73b7f0b1a69a1a2786b5f484419d129d10b), [`989390d4`](https://github.com/mobxjs/mobx/commit/989390d46bbe9941b61ac6c6d1292f96445e7cc3), [`dea1cf18`](https://github.com/mobxjs/mobx/commit/dea1cf189b0f43929f4f626229d34a80bd10212e), [`592e6e99`](https://github.com/mobxjs/mobx/commit/592e6e996c2d5264e162cfb0921a071c1d815c92)]:
    -   mobx@6.0.5

## 3.1.6

### Patch Changes

-   [`2f3dcb27`](https://github.com/mobxjs/mobx/commit/2f3dcb274f795ffca4ae724b6b4795958620838d) Thanks [@FredyC](https://github.com/FredyC)! - Fix names of UMD exports [#2517](https://github.com/mobxjs/mobx/issues/2617)

-   Updated dependencies [[`79a09f49`](https://github.com/mobxjs/mobx/commit/79a09f49a9f2baddbab8d89e9a7ac07cffadf624)]:
    -   mobx@6.0.4

## 3.1.5

### Patch Changes

-   [`01a050f7`](https://github.com/mobxjs/mobx/commit/01a050f7603183e6833b7fd948adb4fbe1437f5a) Thanks [@FredyC](https://github.com/FredyC)! - Fix use of react-dom vs react-native

    The `es` folder content is compiled only without transpilation to keep `utils/reactBatchedUpdates` which exists in DOM and RN versions. The bundled `esm` is still kept around too, especially the prod/dev ones that should be utilized in modern browser environments.

## 3.1.4

### Patch Changes

-   [`8bbbc7c0`](https://github.com/mobxjs/mobx/commit/8bbbc7c0df77cd79530add5db2d6a04cfe6d84b1) Thanks [@FredyC](https://github.com/FredyC)! - Fix names of dist files (for real now). Third time is the charm ğŸ˜…

## 3.1.3

### Patch Changes

-   [`b7aa9d35`](https://github.com/mobxjs/mobx/commit/b7aa9d35432888ee5dd80a6c9dcbc18b04a0346c) Thanks [@FredyC](https://github.com/FredyC)! - Fixed wrong package name for dist files

## 3.1.2

### Patch Changes

-   [`5239db80`](https://github.com/mobxjs/mobx/commit/5239db80cf000026906c28a035725933d4dd6823) Thanks [@FredyC](https://github.com/FredyC)! - Fixed release with missing dist files

## 3.1.1

### Patch Changes

-   [`81a2f865`](https://github.com/mobxjs/mobx/commit/81a2f8654d9656e2e831176e45cbf926fbc364e0) Thanks [@FredyC](https://github.com/FredyC)! - ESM bundles without NODE_ENV present are available in dist folder. This useful for consumption in browser environment that supports ESM Choose either `esm.production.min.js` or `esm.development.js` from `dist` folder.

## 3.1.0

### Minor Changes

-   [`a0e5fea`](https://github.com/mobxjs/mobx-react-lite/commit/a0e5feaeede68b0bac035f60bf2a7edff3fa1269) [#329](https://github.com/mobxjs/mobx-react-lite/pull/329) Thanks [@RoystonS](https://github.com/RoystonS)! - expose `clearTimers` function to tidy up background timers, allowing test frameworks such as Jest to exit immediately

### Patch Changes

-   [`fafb136`](https://github.com/mobxjs/mobx-react-lite/commit/fafb136cce2847b83174cbd15af803442a9a0023) [#332](https://github.com/mobxjs/mobx-react-lite/pull/332) Thanks [@Bnaya](https://github.com/Bnaya)! - Introduce alternative way for managing cleanup of reactions.
    This is internal change and shouldn't affect functionality of the library.

## 3.0.1

### Patch Changes

-   [`570e8d5`](https://github.com/mobxjs/mobx-react-lite/commit/570e8d594bac415cf9a6c6771080fec043161d0b) [#328](https://github.com/mobxjs/mobx-react-lite/pull/328) Thanks [@mweststrate](https://github.com/mweststrate)! - If observable data changed between mount and useEffect, the render reaction would incorrectly be disposed causing incorrect suspension of upstream computed values

*   [`1d6f0a8`](https://github.com/mobxjs/mobx-react-lite/commit/1d6f0a8dd0ff34d7e7cc71946ed670c31193572d) [#326](https://github.com/mobxjs/mobx-react-lite/pull/326) Thanks [@FredyC](https://github.com/FredyC)! - No important changes, just checking new setup for releases.

> Prior 3.0.0 see GitHub releases for changelog



================================================
FILE: packages/mobx-react-lite/jest.config.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    testRegex: "__tests__/.*\\.tsx?$",
    setupFilesAfterEnv: [`<rootDir>/jest.setup.ts`],
    testPathIgnorePatterns: ["node_modules", "<rootDir>/__tests__/utils"]
})



================================================
FILE: packages/mobx-react-lite/jest.setup.ts
================================================
import "@testing-library/jest-dom/extend-expect"
import { configure } from "mobx"

global.setImmediate = global.setImmediate || ((fn, ...args) => global.setTimeout(fn, 0, ...args))

configure({ enforceActions: "never" })

// @ts-ignore
global.__DEV__ = true



================================================
FILE: packages/mobx-react-lite/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 Michel Weststrate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: packages/mobx-react-lite/package.json
================================================
{
    "name": "mobx-react-lite",
    "version": "4.1.0",
    "description": "Lightweight React bindings for MobX based on React 16.8+ and Hooks",
    "source": "src/index.ts",
    "main": "dist/index.js",
    "umd:main": "dist/mobxreact.umd.production.min.js",
    "unpkg": "dist/mobxreactlite.umd.production.min.js",
    "jsdelivr": "dist/mobxreactlite.umd.production.min.js",
    "jsnext:main": "dist/mobxreactlite.esm.production.min.js",
    "module": "es/index.js",
    "react-native": "es/index.js",
    "types": "dist/index.d.ts",
    "typings": "dist/index.d.ts",
    "files": [
        "src",
        "dist/",
        "lib/",
        "es/",
        "LICENSE",
        "CHANGELOG.md",
        "README.md",
        "batching*"
    ],
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git"
    },
    "author": "Daniel K.",
    "license": "MIT",
    "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mobx"
    },
    "bugs": {
        "url": "https://github.com/mobxjs/mobx/issues"
    },
    "homepage": "https://mobx.js.org",
    "dependencies": {
        "use-sync-external-store": "^1.4.0"
    },
    "peerDependencies": {
        "mobx": "^6.9.0",
        "react": "^16.8.0 || ^17 || ^18 || ^19"
    },
    "peerDependenciesMeta": {
        "react-dom": {
            "optional": true
        },
        "react-native": {
            "optional": true
        }
    },
    "devDependencies": {
        "mobx": "^6.12.2",
        "expose-gc": "^1.0.0"
    },
    "keywords": [
        "mobx",
        "mobservable",
        "react-component",
        "react",
        "reactjs",
        "reactive",
        "hooks",
        "observer",
        "useLocalObservable"
    ],
    "scripts": {
        "lint": "eslint src/**/* --ext .js,.ts,.tsx",
        "build": "node ../../scripts/build.js mobxReactLite",
        "build:test": "yarn build --target test",
        "build:cjs": "tsc --project tsconfig.build.cjs.json",
        "build:es": "tsc --project tsconfig.build.es.json",
        "test": "jest",
        "test:size": "yarn import-size --report . observer useLocalObservable",
        "test:types": "tsc --noEmit",
        "test:check": "yarn test:types",
        "prepublishOnly": "cd ../mobx && yarn build --target publish && cd ../mobx-react-lite && yarn build --target publish && yarn build:cjs && yarn build:es"
    }
}



================================================
FILE: packages/mobx-react-lite/tsconfig.build.cjs.json
================================================
{
    "extends": "./tsconfig.build.json",
    "compilerOptions": {
        "outDir": "lib",
        "module": "CommonJS"
    }
}



================================================
FILE: packages/mobx-react-lite/tsconfig.build.es.json
================================================
{
    "extends": "./tsconfig.build.json",
    "compilerOptions": {
        "outDir": "es",
        "module": "ESNext"
    }
}



================================================
FILE: packages/mobx-react-lite/tsconfig.build.json
================================================
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "esModuleInterop": true,
        "target": "ES5",
        "noEmit": false,
        "declaration": false
    }
}



================================================
FILE: packages/mobx-react-lite/tsconfig.json
================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
        "rootDir": "src",
        "lib": ["ESNext", "DOM"]
    },
    "include": ["src"]
}



================================================
FILE: packages/mobx-react-lite/tsconfig.test.json
================================================
{
    "extends": "../../tsconfig.test.json",
    "compilerOptions": {
        "lib": ["esnext", "dom"]
    }
}



================================================
FILE: packages/mobx-react-lite/tsdx.config.js
================================================
module.exports = {
    rollup(config) {
        return {
            ...config,
            output: {
                ...config.output,
                globals: {
                    react: "React",
                    mobx: "mobx",
                    "react-dom": "ReactDOM"
                }
            }
        }
    }
}



================================================
FILE: packages/mobx-react-lite/.eslintignore
================================================
dist/
lib/
es/



================================================
FILE: packages/mobx-react-lite/__tests__/api.test.ts
================================================
const api = require("../src/index.ts")

test("correct api should be exposed", function () {
    expect(
        Object.keys(api)
            .filter(key => api[key] !== undefined)
            .sort()
    ).toEqual(
        [
            "isUsingStaticRendering",
            "enableStaticRendering",
            "observer",
            "Observer",
            "useLocalObservable",
            "useLocalStore",
            "useAsObservableSource",
            "clearTimers",
            "useObserver",
            "isObserverBatched",
            "observerBatching",
            "useStaticRendering",
            "_observerFinalizationRegistry"
        ].sort()
    )
})



================================================
FILE: packages/mobx-react-lite/__tests__/assertEnvironment.test.ts
================================================
afterEach(() => {
    jest.resetModules()
    jest.resetAllMocks()
})

it("throws if react is not installed", () => {
    jest.mock("react", () => ({}))
    expect(() => require("../src/utils/assertEnvironment.ts")).toThrowErrorMatchingInlineSnapshot(
        `"mobx-react-lite requires React with Hooks support"`
    )
})

it("throws if mobx is not installed", () => {
    jest.mock("react", () => ({ useState: true }))
    jest.mock("mobx", () => ({}))
    expect(() => require("../src/utils/assertEnvironment.ts")).toThrowErrorMatchingInlineSnapshot(
        `"mobx-react-lite@3 requires mobx at least version 6 to be available"`
    )
})

export default "Cannot use import statement outside a module"



================================================
FILE: packages/mobx-react-lite/__tests__/enforceActions.test.tsx
================================================
import * as mobx from "mobx"
import { _resetGlobalState } from "mobx"
import * as React from "react"
import { useEffect } from "react"
import { observer, useLocalObservable } from "mobx-react"
import { render } from "@testing-library/react"

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

afterEach(() => {
    _resetGlobalState()
})

describe("enforcing actions", () => {
    it("'never' should work", () => {
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
        mobx.configure({ enforceActions: "never" })

        const Parent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1
            }))
            useEffect(() => {
                obs.x++
            }, [])

            return <div>{obs.x}</div>
        })

        render(<Parent />)
        expect(consoleWarnMock).not.toBeCalled()
    })

    it("'observed' should work", () => {
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
        mobx.configure({ enforceActions: "observed" })

        const Parent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1
            }))
            useEffect(() => {
                obs.x++
            }, [])

            return <div>{obs.x}</div>
        })

        render(<Parent />)
        expect(consoleWarnMock).toBeCalledTimes(1)
    })

    it("'always' should work", () => {
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
        mobx.configure({ enforceActions: "always" })

        const Parent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1
            }))
            useEffect(() => {
                obs.x++
            }, [])

            return <div>{obs.x}</div>
        })

        render(<Parent />)
        expect(consoleWarnMock).toBeCalledTimes(1)
    })
})



================================================
FILE: packages/mobx-react-lite/__tests__/observer.test.tsx
================================================
import { act, cleanup, fireEvent, render } from "@testing-library/react"
import mockConsole from "jest-mock-console"
import * as mobx from "mobx"
import React from "react"

import { observer, useObserver, isObserverBatched, enableStaticRendering } from "../src"

const getDNode = (obj: any, prop?: string) => mobx.getObserverTree(obj, prop)

afterEach(cleanup)

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

function runTestSuite(mode: "observer" | "useObserver") {
    function obsComponent<P extends object>(
        component: React.FunctionComponent<P>,
        forceMemo = false
    ) {
        if (mode === "observer") {
            return observer(component)
        } else {
            const c = (props: P) => {
                consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
                return useObserver(() => {
                    return component(props)
                })
            }
            return forceMemo ? React.memo(c) : c
        }
    }

    describe(`nestedRendering - ${mode}`, () => {
        const execute = () => {
            // init element
            const store = mobx.observable({
                todos: [
                    {
                        completed: false,
                        title: "a"
                    }
                ]
            })

            const renderings = {
                item: 0,
                list: 0
            }

            const TodoItem = obsComponent(({ todo }: { todo: (typeof store.todos)[0] }) => {
                renderings.item++
                return <li>|{todo.title}</li>
            }, true)

            const TodoList = obsComponent(() => {
                renderings.list++
                return (
                    <div>
                        <span>{store.todos.length}</span>
                        {store.todos.map((todo, idx) => (
                            <TodoItem key={idx} todo={todo} />
                        ))}
                    </div>
                )
            }, true)
            const rendered = render(<TodoList />)
            return { ...rendered, store, renderings }
        }

        test("first rendering", () => {
            const { getAllByText, renderings } = execute()
            expect(renderings.list).toBe(1)
            expect(renderings.item).toBe(1)
            expect(getAllByText("1")).toHaveLength(1)
            expect(getAllByText("|a")).toHaveLength(1)
        })

        test("inner store changed", () => {
            const { store, getAllByText, renderings } = execute()
            act(() => {
                store.todos[0].title += "a"
            })
            expect(renderings.list).toBe(1)
            expect(renderings.item).toBe(2)
            expect(getAllByText("1")).toHaveLength(1)
            expect(getAllByText("|aa")).toHaveLength(1)
            expect(getDNode(store, "todos").observers!.length).toBe(1)
            expect(getDNode(store.todos[0], "title").observers!.length).toBe(1)
        })

        test("rerendering with outer store added", () => {
            const { store, container, getAllByText, renderings } = execute()
            act(() => {
                store.todos.push({
                    completed: true,
                    title: "b"
                })
            })
            expect(container.querySelectorAll("li").length).toBe(2)
            expect(getAllByText("2")).toHaveLength(1)
            expect(getAllByText("|b")).toHaveLength(1)
            expect(renderings.list).toBe(2)
            expect(renderings.item).toBe(2)
            expect(getDNode(store.todos[1], "title").observers!.length).toBe(1)
            expect(getDNode(store.todos[1], "completed").observers).toBeFalsy()
        })

        test("rerendering with outer store pop", () => {
            const { store, container, renderings } = execute()
            let oldTodo
            act(() => {
                oldTodo = store.todos.pop()
            })
            expect(renderings.list).toBe(2)
            expect(renderings.item).toBe(1)
            expect(container.querySelectorAll("li").length).toBe(0)
            expect(getDNode(oldTodo, "title").observers).toBeFalsy()
            expect(getDNode(oldTodo, "completed").observers).toBeFalsy()
        })
    })

    describe("isObjectShallowModified detects when React will update the component", () => {
        const store = mobx.observable({ count: 0 })
        let counterRenderings = 0
        const Counter = obsComponent(function TodoItem() {
            counterRenderings++
            return <div>{store.count}</div>
        })

        test("does not assume React will update due to NaN prop", () => {
            // @ts-ignore Not sure what this test does, the value is not used
            render(<Counter value={NaN} />)
            act(() => {
                store.count++
            })
            expect(counterRenderings).toBe(2)
        })
    })

    describe("keep views alive", () => {
        const execute = () => {
            const data = mobx.observable({
                x: 3,
                yCalcCount: 0,
                get y() {
                    this.yCalcCount++
                    return this.x * 2
                },
                z: "hi"
            })
            const TestComponent = obsComponent(() => {
                return (
                    <div>
                        {data.z}
                        {data.y}
                    </div>
                )
            })
            return { ...render(<TestComponent />), data }
        }

        test("init state", () => {
            const { data, queryByText } = execute()
            expect(data.yCalcCount).toBe(1)
            expect(queryByText("hi6")).toBeTruthy()
        })

        test("rerender should not need a recomputation of data.y", () => {
            const { data, queryByText } = execute()
            act(() => {
                data.z = "hello"
            })
            expect(data.yCalcCount).toBe(1)
            expect(queryByText("hello6")).toBeTruthy()
        })
    })

    describe("does not keep views alive when using static rendering", () => {
        const execute = () => {
            enableStaticRendering(true)
            let renderCount = 0
            const data = mobx.observable({
                z: "hi"
            })

            const TestComponent = obsComponent(() => {
                renderCount++
                return <div>{data.z}</div>
            })

            return { ...render(<TestComponent />), data, getRenderCount: () => renderCount }
        }

        afterEach(() => {
            enableStaticRendering(false)
        })

        test("init state is correct", () => {
            const { getRenderCount, getByText } = execute()
            expect(getRenderCount()).toBe(1)
            expect(getByText("hi")).toBeTruthy()
        })

        test("no re-rendering on static rendering", () => {
            const { getRenderCount, getByText, data } = execute()
            act(() => {
                data.z = "hello"
            })
            expect(getRenderCount()).toBe(1)
            expect(getByText("hi")).toBeTruthy()
            expect(getDNode(data, "z").observers!).toBeFalsy()
        })
    })

    describe("issue 12", () => {
        const createData = () =>
            mobx.observable({
                selected: "coffee",
                items: [
                    {
                        name: "coffee"
                    },
                    {
                        name: "tea"
                    }
                ]
            })

        interface IItem {
            name: string
        }
        interface IRowProps {
            item: IItem
            selected: string
        }
        const Row: React.FC<IRowProps> = props => {
            return (
                <span>
                    {props.item.name}
                    {props.selected === props.item.name ? "!" : ""}
                </span>
            )
        }
        /** table stateles component */
        const Table = obsComponent<{ data: { items: IItem[]; selected: string } }>(props => {
            return (
                <div>
                    {props.data.items.map(item => (
                        <Row key={item.name} item={item} selected={props.data.selected} />
                    ))}
                </div>
            )
        })

        test("init state is correct", () => {
            const data = createData()
            const { container } = render(<Table data={data} />)
            expect(container).toMatchSnapshot()
        })

        test("run transaction", () => {
            const data = createData()
            const { container } = render(<Table data={data} />)
            act(() => {
                mobx.transaction(() => {
                    data.items[1].name = "boe"
                    data.items.splice(0, 2, { name: "soup" })
                    data.selected = "tea"
                })
            })
            expect(container).toMatchSnapshot()
        })
    })

    describe("issue 309", () => {
        test("isObserverBatched is still defined and yields true by default", () => {
            consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
            expect(isObserverBatched()).toBe(true)
            expect(consoleWarnMock).toMatchSnapshot()
        })
    })

    test("changing state in render should fail", () => {
        // This test is most likely obsolete ... exception is not thrown
        const data = mobx.observable.box(2)
        const Comp = obsComponent(() => {
            if (data.get() === 3) {
                try {
                    data.set(4) // wouldn't throw first time for lack of observers.. (could we tighten this?)
                } catch (err) {
                    expect(err).toBeInstanceOf(Error)
                    expect(err).toMatch(
                        /Side effects like changing state are not allowed at this point/
                    )
                }
            }
            return <div>{data.get()}</div>
        })
        const { container } = render(<Comp />)
        act(() => {
            data.set(3)
        })
        expect(container).toMatchSnapshot()
        mobx._resetGlobalState()
    })

    describe("should render component even if setState called with exactly the same props", () => {
        const execute = () => {
            let renderCount = 0
            const Component = obsComponent(() => {
                const [, setState] = React.useState({})
                const onClick = () => {
                    setState({})
                }
                renderCount++
                return <div onClick={onClick} data-testid="clickableDiv" />
            })
            return { ...render(<Component />), getCount: () => renderCount }
        }

        test("renderCount === 1", () => {
            const { getCount } = execute()
            expect(getCount()).toBe(1)
        })

        test("after click once renderCount === 2", async () => {
            const { getCount, getByTestId } = execute()
            fireEvent.click(getByTestId("clickableDiv"))
            expect(getCount()).toBe(2)
        })

        test("after click twice renderCount === 3", async () => {
            const { getCount, getByTestId } = execute()
            fireEvent.click(getByTestId("clickableDiv"))
            fireEvent.click(getByTestId("clickableDiv"))
            expect(getCount()).toBe(3)
        })
    })

    describe("it rerenders correctly when useMemo is wrapping observable", () => {
        const execute = () => {
            let renderCount = 0
            const createProps = () => {
                const odata = mobx.observable({ x: 1 })
                const data = { y: 1 }
                function doStuff() {
                    data.y++
                    odata.x++
                }
                return { odata, data, doStuff }
            }

            const Component = obsComponent((props: any) => {
                const computed = React.useMemo(() => props.odata.x, [props.odata.x])

                renderCount++
                return (
                    <span onClick={props.doStuff}>
                        {props.odata.x}-{props.data.y}-{computed}
                    </span>
                )
            })

            const rendered = render(<Component {...createProps()} />)
            return {
                ...rendered,
                getCount: () => renderCount,
                span: rendered.container.querySelector("span")!
            }
        }

        test("init renderCount === 1", () => {
            const { span, getCount } = execute()
            expect(getCount()).toBe(1)
            expect(span.innerHTML).toBe("1-1-1")
        })

        test("after click renderCount === 2", async () => {
            const { span, getCount } = execute()
            fireEvent.click(span)
            expect(getCount()).toBe(2)
            expect(span.innerHTML).toBe("2-2-2")
        })

        test("after click twice renderCount === 3", async () => {
            const { span, getCount } = execute()
            fireEvent.click(span)
            fireEvent.click(span)
            expect(getCount()).toBe(3)
            expect(span.innerHTML).toBe("3-3-3")
        })
    })

    describe("should not re-render on shallow equal new props", () => {
        const execute = () => {
            const renderings = {
                child: 0,
                parent: 0
            }
            const data = { x: 1 }
            const odata = mobx.observable({ y: 1 })

            const Child = obsComponent((props: any) => {
                renderings.child++
                return <span>{props.data.x}</span>
            }, true)
            const Parent = obsComponent(() => {
                renderings.parent++
                // tslint:disable-next-line no-unused-expression
                odata.y /// depend
                return <Child data={data} />
            }, true)
            return { ...render(<Parent />), renderings, odata }
        }

        test("init state is correct", () => {
            const { container, renderings } = execute()
            expect(renderings.parent).toBe(1)
            expect(renderings.child).toBe(1)
            expect(container.querySelector("span")!.innerHTML).toBe("1")
        })

        test("after odata change", async () => {
            const { container, renderings, odata } = execute()
            act(() => {
                odata.y++
            })
            expect(renderings.parent).toBe(2)
            expect(renderings.child).toBe(1)
            expect(container.querySelector("span")!.innerHTML).toBe("1")
        })
    })

    describe("error handling", () => {
        test("errors should propagate", () => {
            const x = mobx.observable.box(1)
            const errorsSeen: any[] = []

            class ErrorBoundary extends React.Component<{ children: any }> {
                public static getDerivedStateFromError() {
                    return { hasError: true }
                }

                public state = {
                    hasError: false
                }

                public componentDidCatch(error: any, info: any) {
                    errorsSeen.push("" + error)
                }

                public render() {
                    if (this.state.hasError) {
                        return <span>Saw error!</span>
                    }
                    return this.props.children
                }
            }

            const C = obsComponent(() => {
                if (x.get() === 42) {
                    throw new Error("The meaning of life!")
                }
                return <span>{x.get()}</span>
            })

            const restoreConsole = mockConsole()
            try {
                const rendered = render(
                    <ErrorBoundary>
                        <C />
                    </ErrorBoundary>
                )
                expect(rendered.container.querySelector("span")!.innerHTML).toBe("1")
                act(() => {
                    x.set(42)
                })
                expect(errorsSeen).toEqual(["Error: The meaning of life!"])
                expect(rendered.container.querySelector("span")!.innerHTML).toBe("Saw error!")
            } finally {
                restoreConsole()
            }
        })
    })
}

runTestSuite("observer")
runTestSuite("useObserver")

test("observer(cmp, { forwardRef: true }) + useImperativeHandle", () => {
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

    interface IMethods {
        focus(): void
    }

    interface IProps {
        value: string
        ref: React.Ref<IMethods>
    }

    const FancyInput = observer<IProps>(
        (props: IProps, ref: React.Ref<IMethods>) => {
            const inputRef = React.useRef<HTMLInputElement>(null)
            React.useImperativeHandle(
                ref,
                () => ({
                    focus: () => {
                        inputRef.current!.focus()
                    }
                }),
                []
            )
            return <input ref={inputRef} defaultValue={props.value} />
        },
        { forwardRef: true }
    )

    const cr = React.createRef<IMethods>()
    render(<FancyInput ref={cr} value="" />)
    expect(cr).toBeTruthy()
    expect(cr.current).toBeTruthy()
    expect(typeof cr.current!.focus).toBe("function")
    expect(consoleWarnMock).toMatchSnapshot()
})

test("observer(forwardRef(cmp)) + useImperativeHandle", () => {
    interface IMethods {
        focus(): void
    }

    interface IProps {
        value: string
    }

    const FancyInput = observer(
        React.forwardRef((props: IProps, ref: React.Ref<IMethods>) => {
            const inputRef = React.useRef<HTMLInputElement>(null)
            React.useImperativeHandle(
                ref,
                () => ({
                    focus: () => {
                        inputRef.current!.focus()
                    }
                }),
                []
            )
            return <input ref={inputRef} defaultValue={props.value} />
        })
    )

    const cr = React.createRef<IMethods>()
    render(<FancyInput ref={cr} value="" />)
    expect(cr).toBeTruthy()
    expect(cr.current).toBeTruthy()
    expect(typeof cr.current!.focus).toBe("function")
})

test("useImperativeHandle and forwardRef should work with useObserver", () => {
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
    interface IMethods {
        focus(): void
    }

    interface IProps {
        value: string
    }

    const FancyInput = React.memo(
        React.forwardRef((props: IProps, ref: React.Ref<IMethods>) => {
            const inputRef = React.useRef<HTMLInputElement>(null)
            React.useImperativeHandle(
                ref,
                () => ({
                    focus: () => {
                        inputRef.current!.focus()
                    }
                }),
                []
            )
            return useObserver(() => {
                return <input ref={inputRef} defaultValue={props.value} />
            })
        })
    )

    const cr = React.createRef<IMethods>()
    render(<FancyInput ref={cr} value="" />)
    expect(cr).toBeTruthy()
    expect(cr.current).toBeTruthy()
    expect(typeof cr.current!.focus).toBe("function")
    expect(consoleWarnMock).toMatchSnapshot()
})

it("should hoist known statics only", () => {
    function isNumber() {
        return null
    }

    function MyHipsterComponent() {
        return null
    }
    MyHipsterComponent.defaultProps = { x: 3 }
    MyHipsterComponent.propTypes = { x: isNumber }
    MyHipsterComponent.randomStaticThing = 3
    MyHipsterComponent.type = "Nope!"
    MyHipsterComponent.compare = "Nope!"
    MyHipsterComponent.render = "Nope!"

    const wrapped = observer(MyHipsterComponent)
    expect(wrapped.randomStaticThing).toEqual(3)
    expect(wrapped.defaultProps).toEqual({ x: 3 })
    expect(wrapped.propTypes).toEqual({ x: isNumber })
    expect(wrapped.type).toBeInstanceOf(Function) // And not "Nope!"; this is the wrapped component, the property is introduced by memo
    expect(wrapped.compare).toBe(null) // another memo field
    expect(wrapped.render).toBe(undefined)
})

it("should inherit original name/displayName #3438", () => {
    function Name() {
        return null
    }
    Name.displayName = "DisplayName"
    const TestComponent = observer(Name)

    expect((TestComponent as any).type.name).toBe("Name")
    expect((TestComponent as any).type.displayName).toBe("DisplayName")
})

test("parent / childs render in the right order", done => {
    // See: https://jsfiddle.net/gkaemmer/q1kv7hbL/13/
    const events: string[] = []

    class User {
        public name = "User's name"
        constructor() {
            mobx.makeObservable(this, {
                name: mobx.observable
            })
        }
    }

    class Store {
        public user: User | null = new User()
        public logout() {
            this.user = null
        }
        constructor() {
            mobx.makeObservable(this, {
                user: mobx.observable,
                logout: mobx.action
            })
        }
    }

    const store = new Store()

    function tryLogout() {
        try {
            store.logout()
            expect(true).toBeTruthy()
        } catch (e) {
            // t.fail(e)
        }
    }

    const Parent = observer(() => {
        events.push("parent")
        if (!store.user) {
            return <span>Not logged in.</span>
        }
        return (
            <div>
                <Child />
                <button onClick={tryLogout}>Logout</button>
            </div>
        )
    })

    const Child = observer(() => {
        events.push("child")
        if (!store.user) {
            return null
        }
        return <span>Logged in as: {store.user.name}</span>
    })

    render(<Parent />)

    tryLogout()
    expect(events).toEqual(["parent", "child"])
    done()
})

it("should have overload for props with children", () => {
    interface IProps {
        value: string
    }
    const TestComponent = observer<IProps>(({ value }) => {
        return null
    })

    render(<TestComponent value="1" />)

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

it("should have overload for empty options", () => {
    // empty options are not really making sense now, but we shouldn't rely on `forwardRef`
    // being specified in case other options are added in the future

    interface IProps {
        value: string
    }
    const TestComponent = observer<IProps>(({ value }) => {
        return null
    }, {})

    render(<TestComponent value="1" />)

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

it("should have overload for props with children when forwardRef", () => {
    interface IMethods {
        focus(): void
    }

    interface IProps {
        value: string
    }
    const TestComponent = observer<IProps, IMethods>(
        ({ value }, ref) => {
            return null
        },
        { forwardRef: true }
    )

    render(<TestComponent value="1" />)

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

it("should preserve generic parameters", () => {
    interface IColor {
        name: string
        css: string
    }

    interface ITestComponentProps<T> {
        value: T
        callback: (value: T) => void
    }
    const TestComponent = observer(<T extends unknown>(props: ITestComponentProps<T>) => {
        return null
    })

    function callbackString(value: string) {
        return
    }
    function callbackColor(value: IColor) {
        return
    }

    render(<TestComponent value="1" callback={callbackString} />)
    render(
        <TestComponent value={{ name: "red", css: "rgb(255, 0, 0)" }} callback={callbackColor} />
    )

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

it("should preserve generic parameters when forwardRef", () => {
    interface IMethods {
        focus(): void
    }

    interface IColor {
        name: string
        css: string
    }

    interface ITestComponentProps<T> {
        value: T
        callback: (value: T) => void
    }
    const TestComponent = observer(
        <T extends unknown>(props: ITestComponentProps<T>, ref: React.Ref<IMethods>) => {
            return null
        },
        { forwardRef: true }
    )

    function callbackString(value: string) {
        return
    }
    function callbackColor(value: IColor) {
        return
    }

    render(<TestComponent value="1" callback={callbackString} />)
    render(
        <TestComponent value={{ name: "red", css: "rgb(255, 0, 0)" }} callback={callbackColor} />
    )

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

it("should keep original props types", () => {
    interface TestComponentProps {
        a: number
    }

    function TestComponent({ a }: TestComponentProps): JSX.Element | null {
        return null
    }

    const ObserverTestComponent = observer(TestComponent)

    const element = React.createElement(ObserverTestComponent, { a: 1 })
    render(element)

    // this test has no `expect` calls as it verifies whether such component compiles or not
})

// describe("206 - @observer should produce usefull errors if it throws", () => {
//     const data = mobx.observable({ x: 1 })
//     let renderCount = 0

//     const emmitedErrors = []
//     const disposeErrorsHandler = onError(error => {
//         emmitedErrors.push(error)
//     })

//     @observer
//     class Child extends React.Component {
//         render() {
//             renderCount++
//             if (data.x === 42) throw new Error("Oops!")
//             return <span>{data.x}</span>
//         }
//     }

//     beforeAll(async done => {
//         await asyncReactDOMRender(<Child />, testRoot)
//         done()
//     })

//     test("init renderCount should === 1", () => {
//         expect(renderCount).toBe(1)
//     })

//     test("catch exception", () => {
//         expect(() => {
//             withConsole(() => {
//                 data.x = 42
//             })
//         }).toThrow(/Oops!/)
//         expect(renderCount).toBe(3) // React fiber will try to replay the rendering, so the exception gets thrown a second time
//     })

//     test("component recovers!", async () => {
//         await sleepHelper(500)
//         data.x = 3
//         TestUtils.renderIntoDocument(<Child />)
//         expect(renderCount).toBe(4)
//         expect(emmitedErrors).toEqual([new Error("Oops!"), new Error("Oops!")]) // see above comment
//     })
// })

// test("195 - async componentWillMount does not work", async () => {
//     const renderedValues = []

//     @observer
//     class WillMount extends React.Component {
//         @mobx.observable
//         counter = 0

//         @mobx.action
//         inc = () => this.counter++

//         componentWillMount() {
//             setTimeout(() => this.inc(), 300)
//         }

//         render() {
//             renderedValues.push(this.counter)
//             return (
//                 <p>
//                     {this.counter}
//                     <button onClick={this.inc}>+</button>
//                 </p>
//             )
//         }
//     }
//     TestUtils.renderIntoDocument(<WillMount />)

//     await sleepHelper(500)
//     expect(renderedValues).toEqual([0, 1])
// })

// test.skip("195 - should throw if trying to overwrite lifecycle methods", () => {
//     // Test disabled, see #231...

//     @observer
//     class WillMount extends React.Component {
//         componentWillMount = () => {}

//         render() {
//             return null
//         }
//     }
//     expect(TestUtils.renderIntoDocument(<WillMount />)).toThrow(
//         /Cannot assign to read only property 'componentWillMount'/
//     )
// })

it("dependencies should not become temporarily unobserved", async () => {
    jest.spyOn(React, "useEffect")

    let p: Promise<any>[] = []
    const cleanups: any[] = []

    async function runEffects() {
        await Promise.all(p.splice(0))
    }

    // @ts-ignore
    React.useEffect.mockImplementation(effect => {
        p.push(
            new Promise<void>(resolve => {
                setTimeout(() => {
                    act(() => {
                        cleanups.push(effect())
                    })
                    resolve()
                }, 10)
            })
        )
    })

    let computed = 0
    let renders = 0

    const store = mobx.makeAutoObservable({
        x: 1,
        get double() {
            computed++
            return this.x * 2
        },
        inc() {
            this.x++
        }
    })

    const doubleDisposed = jest.fn()
    const reactionFired = jest.fn()

    mobx.onBecomeUnobserved(store, "double", doubleDisposed)

    const TestComponent = observer(() => {
        renders++
        return <div>{store.double}</div>
    })

    const r = render(<TestComponent />)

    expect(computed).toBe(1)
    expect(renders).toBe(1)
    expect(doubleDisposed).toBeCalledTimes(0)

    store.inc()
    expect(computed).toBe(2) // change propagated
    expect(renders).toBe(1) // but not yet rendered
    expect(doubleDisposed).toBeCalledTimes(0) // if we dispose to early, this fails!

    // Bug: change the state, before the useEffect fires, can cause the reaction to be disposed
    mobx.reaction(() => store.x, reactionFired)
    expect(reactionFired).toBeCalledTimes(0)
    expect(computed).toBe(2) // Not 3!
    expect(renders).toBe(1)
    expect(doubleDisposed).toBeCalledTimes(0)

    await runEffects()
    expect(reactionFired).toBeCalledTimes(0)
    expect(computed).toBe(2) // Not 3!
    expect(renders).toBe(2)
    expect(doubleDisposed).toBeCalledTimes(0)

    r.unmount()
    cleanups.filter(Boolean).forEach(f => f())
    expect(reactionFired).toBeCalledTimes(0)
    expect(computed).toBe(2)
    expect(renders).toBe(2)
    expect(doubleDisposed).toBeCalledTimes(1)
})

it.skip("Legacy context support", () => {
    const contextKey = "key"
    const contextValue = "value"

    function ContextConsumer(_, context) {
        expect(context[contextKey]).toBe(contextValue)
        return null
    }

    ContextConsumer.contextTypes = {
        [contextKey]: () => null
    }

    const ObserverContextConsumer = observer(ContextConsumer)

    class ContextProvider extends React.Component {
        getChildContext() {
            return { [contextKey]: contextValue }
        }

        render() {
            return <ObserverContextConsumer />
        }
    }

    ;(ContextProvider as any).childContextTypes = {
        [contextKey]: () => null
    }

    render(<ContextProvider />)
})

it("Throw when trying to set contextType on observer", () => {
    const NamedObserver = observer(function TestCmp() {
        return null
    })
    const AnonymousObserver = observer(() => null)
    expect(() => {
        ;(NamedObserver as any).contextTypes = {}
    }).toThrow(/\[mobx-react-lite\] `TestCmp.contextTypes` must be set before applying `observer`./)
    expect(() => {
        ;(AnonymousObserver as any).contextTypes = {}
    }).toThrow(
        /\[mobx-react-lite\] `Component.contextTypes` must be set before applying `observer`./
    )
})

test("Anonymous component displayName #3192", () => {
    // React prints errors even if we catch em
    const consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})

    // Simulate returning something not renderable:
    // Error: n_a_m_e(...):
    // The point is to get correct displayName in error msg.

    let memoError
    let observerError

    // @ts-ignore
    const MemoCmp = React.memo(() => {
        return { hello: "world" }
    })
    // @ts-ignore
    const ObserverCmp = observer(() => {
        return { hello: "world" }
    })

    ObserverCmp.displayName = MemoCmp.displayName = "n_a_m_e"

    try {
        render(<MemoCmp />)
    } catch (error) {
        memoError = error
    }

    try {
        // @ts-ignore
        render(<ObserverCmp />)
    } catch (error) {
        observerError = error
    }

    expect(memoError).toBeInstanceOf(Error)
    expect(observerError).toBeInstanceOf(Error)

    expect(memoError.message.includes(MemoCmp.displayName))
    expect(MemoCmp.displayName).toEqual(ObserverCmp.displayName)
    expect(observerError.message).toEqual(memoError.message)
    consoleErrorSpy.mockRestore()
})

test("StrictMode #3671", async () => {
    const o = mobx.observable({ x: 0 })

    const Cmp = observer(() => o.x as any)

    const { container, unmount } = render(
        <React.StrictMode>
            <Cmp />
        </React.StrictMode>
    )

    expect(container).toHaveTextContent("0")
    act(
        mobx.action(() => {
            o.x++
        })
    )
    expect(container).toHaveTextContent("1")
})

test("`isolateGlobalState` shouldn't break reactivity #3734", async () => {
    mobx.configure({ isolateGlobalState: true })

    const o = mobx.observable({ x: 0 })

    const Cmp = observer(() => o.x as any)

    const { container, unmount } = render(<Cmp />)

    expect(container).toHaveTextContent("0")
    act(
        mobx.action(() => {
            o.x++
        })
    )
    expect(container).toHaveTextContent("1")
    unmount()

    mobx._resetGlobalState()
})



================================================
FILE: packages/mobx-react-lite/__tests__/ObserverComponent.test.tsx
================================================
import mockConsole from "jest-mock-console"
import * as mobx from "mobx"
import * as React from "react"
import { act, cleanup, render } from "@testing-library/react"

import { Observer } from "../src"

afterEach(cleanup)

describe("regions should rerender component", () => {
    const execute = () => {
        const data = mobx.observable.box("hi")
        const Comp = () => (
            <div>
                <Observer>{() => <span>{data.get()}</span>}</Observer>
                <li>{data.get()}</li>
            </div>
        )
        return { ...render(<Comp />), data }
    }

    test("init state is correct", () => {
        const { container } = execute()
        expect(container.querySelector("span")!.innerHTML).toBe("hi")
        expect(container.querySelector("li")!.innerHTML).toBe("hi")
    })

    test("set the data to hello", async () => {
        const { container, data } = execute()
        act(() => {
            data.set("hello")
        })
        expect(container.querySelector("span")!.innerHTML).toBe("hello")
        expect(container.querySelector("li")!.innerHTML).toBe("hi")
    })
})

it("renders null if no children/render prop is supplied a function", () => {
    const restoreConsole = mockConsole()
    const Comp = () => <Observer />
    const { container } = render(<Comp />)
    expect(container).toMatchInlineSnapshot(`<div />`)
    restoreConsole()
})

it.skip("prop types checks for children/render usage", () => {
    const Comp = () => (
        <Observer render={() => <span>children</span>}>{() => <span>children</span>}</Observer>
    )
    const restoreConsole = mockConsole("error")
    render(<Comp />)
    // tslint:disable-next-line:no-console
    expect(console.error).toHaveBeenCalledWith(
        expect.stringContaining("Do not use children and render in the same time")
    )
    restoreConsole()
})



================================================
FILE: packages/mobx-react-lite/__tests__/printDebugValue.test.ts
================================================
import { $mobx, autorun, observable } from "mobx"
import { printDebugValue } from "../src/utils/printDebugValue"

test("printDebugValue", () => {
    const money = observable({
        euro: 10,
        get pound() {
            return this.euro / 1.15
        }
    })

    const disposer = autorun(() => {
        const { euro, pound } = money
        if (euro === pound) {
            // tslint:disable-next-line: no-console
            console.log("Weird..")
        }
    })

    const value = (disposer as any)[$mobx]

    expect(printDebugValue(value)).toMatchSnapshot()

    disposer()

    expect(printDebugValue(value)).toMatchSnapshot()
})



================================================
FILE: packages/mobx-react-lite/__tests__/strictAndConcurrentMode.test.tsx
================================================
import { act, cleanup, render } from "@testing-library/react"
import mockConsole from "jest-mock-console"
import * as mobx from "mobx"
import * as React from "react"

import { useObserver } from "../src/useObserver"

afterEach(cleanup)

test("uncommitted observing components should not attempt state changes", () => {
    const store = mobx.observable({ count: 0 })

    const TestComponent = () => useObserver(() => <div>{store.count}</div>)

    // Render our observing component wrapped in StrictMode
    const rendering = render(
        <React.StrictMode>
            <TestComponent />
        </React.StrictMode>
    )

    // That will have caused our component to have been rendered
    // more than once, but when we unmount it'll only unmount once.
    rendering.unmount()

    // Trigger a change to the observable. If the reactions were
    // not disposed correctly, we'll see some console errors from
    // React StrictMode because we're calling state mutators to
    // trigger an update.
    const restoreConsole = mockConsole()
    try {
        act(() => {
            store.count++
        })

        // Check to see if any console errors were reported.
        // tslint:disable-next-line: no-console
        expect(console.error).not.toHaveBeenCalled()
    } finally {
        restoreConsole()
    }
})

test(`observable changes before first commit are not lost`, async () => {
    const store = mobx.observable({ value: "initial" })

    const TestComponent = () =>
        useObserver(() => {
            const res = <div>{store.value}</div>
            // Change our observable. This is happening between the initial render of
            // our component and its initial commit, so it isn't fully mounted yet.
            // We want to ensure that the change isn't lost.
            store.value = "changed"
            return res
        })

    const rootNode = document.createElement("div")
    document.body.appendChild(rootNode)

    const rendering = render(
        <React.StrictMode>
            <TestComponent />
        </React.StrictMode>
    )

    expect(rendering.baseElement.textContent).toBe("changed")
})



================================================
FILE: packages/mobx-react-lite/__tests__/strictAndConcurrentModeUsingFinalizationRegistry.test.tsx
================================================
import { cleanup, render, waitFor } from "@testing-library/react"
import * as mobx from "mobx"
import * as React from "react"
import { useObserver } from "../src/useObserver"
import gc from "expose-gc/function"
import { observerFinalizationRegistry } from "../src/utils/observerFinalizationRegistry"

if (typeof globalThis.FinalizationRegistry !== "function") {
    throw new Error("This test must run with node >= 14")
}

expect(observerFinalizationRegistry).toBeInstanceOf(globalThis.FinalizationRegistry)

afterEach(cleanup)

function nextFrame() {
    return new Promise(accept => setTimeout(accept, 1))
}

async function gc_cycle() {
    await nextFrame()
    gc()
    await nextFrame()
}

test("uncommitted components should not leak observations", async () => {
    jest.setTimeout(30_000)
    const store = mobx.observable({ count1: 0, count2: 0 })

    // Track whether counts are observed
    let count1IsObserved = false
    let count2IsObserved = false
    mobx.onBecomeObserved(store, "count1", () => (count1IsObserved = true))
    mobx.onBecomeUnobserved(store, "count1", () => (count1IsObserved = false))
    mobx.onBecomeObserved(store, "count2", () => (count2IsObserved = true))
    mobx.onBecomeUnobserved(store, "count2", () => (count2IsObserved = false))

    const TestComponent1 = () => useObserver(() => <div>{store.count1}</div>)
    const TestComponent2 = () => useObserver(() => <div>{store.count2}</div>)

    // Render, then remove only #2
    const rendering = render(
        <React.StrictMode>
            <TestComponent1 />
            <TestComponent2 />
        </React.StrictMode>
    )
    rendering.rerender(
        <React.StrictMode>
            <TestComponent1 />
        </React.StrictMode>
    )

    // Allow gc to kick in in case to let finalization registry cleanup
    await gc_cycle()

    // Can take a while (especially on CI) before gc actually calls the registry
    await waitFor(
        () => {
            // count1 should still be being observed by Component1,
            // but count2 should have had its reaction cleaned up.
            expect(count1IsObserved).toBeTruthy()
            expect(count2IsObserved).toBeFalsy()
        },
        {
            timeout: 15_000,
            interval: 200
        }
    )
})



================================================
FILE: packages/mobx-react-lite/__tests__/strictAndConcurrentModeUsingTimers.test.tsx
================================================
import "./utils/killFinalizationRegistry"
import { act, cleanup, render } from "@testing-library/react"
import * as mobx from "mobx"
import * as React from "react"
import { useObserver } from "../src/useObserver"
import {
    REGISTRY_FINALIZE_AFTER,
    REGISTRY_SWEEP_INTERVAL
} from "../src/utils/UniversalFinalizationRegistry"
import { observerFinalizationRegistry } from "../src/utils/observerFinalizationRegistry"
import { TimerBasedFinalizationRegistry } from "../src/utils/UniversalFinalizationRegistry"

expect(observerFinalizationRegistry).toBeInstanceOf(TimerBasedFinalizationRegistry)

const registry = observerFinalizationRegistry as TimerBasedFinalizationRegistry<unknown>

afterEach(cleanup)

test("uncommitted components should not leak observations", async () => {
    registry.finalizeAllImmediately()

    // Unfortunately, Jest fake timers don't mock out Date.now, so we fake
    // that out in parallel to Jest useFakeTimers
    let fakeNow = Date.now()
    jest.useFakeTimers()
    jest.spyOn(Date, "now").mockImplementation(() => fakeNow)

    const store = mobx.observable({ count1: 0, count2: 0 })

    // Track whether counts are observed
    let count1IsObserved = false
    let count2IsObserved = false
    mobx.onBecomeObserved(store, "count1", () => (count1IsObserved = true))
    mobx.onBecomeUnobserved(store, "count1", () => (count1IsObserved = false))
    mobx.onBecomeObserved(store, "count2", () => (count2IsObserved = true))
    mobx.onBecomeUnobserved(store, "count2", () => (count2IsObserved = false))

    const TestComponent1 = () => useObserver(() => <div>{store.count1}</div>)
    const TestComponent2 = () => useObserver(() => <div>{store.count2}</div>)

    // Render, then remove only #2
    const rendering = render(
        <React.StrictMode>
            <TestComponent1 />
            <TestComponent2 />
        </React.StrictMode>
    )
    rendering.rerender(
        <React.StrictMode>
            <TestComponent1 />
        </React.StrictMode>
    )

    // Allow any reaction-disposal cleanup timers to run
    const skip = Math.max(REGISTRY_FINALIZE_AFTER, REGISTRY_SWEEP_INTERVAL)
    fakeNow += skip
    jest.advanceTimersByTime(skip)

    // count1 should still be being observed by Component1,
    // but count2 should have had its reaction cleaned up.
    expect(count1IsObserved).toBeTruthy()
    expect(count2IsObserved).toBeFalsy()
})

test("cleanup timer should not clean up recently-pended reactions", () => {
    // If we're not careful with timings, it's possible to get the
    // following scenario:
    // 1. Component instance A is being created; it renders, we put its reaction R1 into the cleanup list
    // 2. Strict/Concurrent mode causes that render to be thrown away
    // 3. Component instance A is being created; it renders, we put its reaction R2 into the cleanup list
    // 4. The MobX reaction timer from 5 seconds ago kicks in and cleans up all reactions from uncommitted
    //    components, including R1 and R2
    // 5. The commit phase runs for component A, but reaction R2 has already been disposed. Game over.

    // This unit test attempts to replicate that scenario:
    registry.finalizeAllImmediately()

    // Unfortunately, Jest fake timers don't mock out Date.now, so we fake
    // that out in parallel to Jest useFakeTimers
    const fakeNow = Date.now()
    jest.useFakeTimers()
    jest.spyOn(Date, "now").mockImplementation(() => fakeNow)

    const store = mobx.observable({ count: 0 })

    // Track whether the count is observed
    let countIsObserved = false
    mobx.onBecomeObserved(store, "count", () => (countIsObserved = true))
    mobx.onBecomeUnobserved(store, "count", () => (countIsObserved = false))

    const TestComponent1 = () => useObserver(() => <div>{store.count}</div>)

    const rendering = render(
        // We use StrictMode here, but it would be helpful to switch this to use real
        // concurrent mode: we don't have a true async render right now so this test
        // isn't as thorough as it could be.
        <React.StrictMode>
            <TestComponent1 />
        </React.StrictMode>
    )

    // We need to trigger our cleanup timer to run. We can't do this simply
    // by running all jest's faked timers as that would allow the scheduled
    // `useEffect` calls to run, and we want to simulate our cleanup timer
    // getting in between those stages.

    // We force our cleanup loop to run even though enough time hasn't _really_
    // elapsed.  In theory, it won't do anything because not enough time has
    // elapsed since the reactions were queued, and so they won't be disposed.
    registry.sweep()

    // Advance time enough to allow any timer-queued effects to run
    jest.advanceTimersByTime(500)

    // Now allow the useEffect calls to run to completion.
    act(() => {
        // no-op, but triggers effect flushing
    })

    // count should still be observed
    expect(countIsObserved).toBeTruthy()
})

// TODO: MWE: disabled during React 18 migration, not sure how to express it icmw with testing-lib,
// and using new React renderRoot will fail icmw JSDOM
test.skip("component should recreate reaction if necessary", () => {
    // There _may_ be very strange cases where the reaction gets tidied up
    // but is actually still needed.  This _really_ shouldn't happen.
    // e.g. if we're using Suspense and the component starts to render,
    // but then gets paused for 60 seconds, and then comes back to life.
    // With the implementation of React at the time of writing this, React
    // will actually fully re-render that component (discarding previous
    // hook slots) before going ahead with a commit, but it's unwise
    // to depend on such an implementation detail.  So we must cope with
    // the component having had its reaction tidied and still going on to
    // be committed.  In that case we recreate the reaction and force
    // an update.

    // This unit test attempts to replicate that scenario:

    registry.finalizeAllImmediately()

    // Unfortunately, Jest fake timers don't mock out Date.now, so we fake
    // that out in parallel to Jest useFakeTimers
    let fakeNow = Date.now()
    jest.useFakeTimers()
    jest.spyOn(Date, "now").mockImplementation(() => fakeNow)

    const store = mobx.observable({ count: 0 })

    // Track whether the count is observed
    let countIsObserved = false
    mobx.onBecomeObserved(store, "count", () => (countIsObserved = true))
    mobx.onBecomeUnobserved(store, "count", () => (countIsObserved = false))

    const TestComponent1 = () => useObserver(() => <div>{store.count}</div>)

    const rendering = render(
        <React.StrictMode>
            <TestComponent1 />
        </React.StrictMode>
    )

    // We need to trigger our cleanup timer to run. We don't want
    // to allow Jest's effects to run, however: we want to simulate the
    // case where the component is rendered, then the reaction gets cleaned up,
    // and _then_ the component commits.

    // Force everything to be disposed.
    const skip = Math.max(REGISTRY_FINALIZE_AFTER, REGISTRY_SWEEP_INTERVAL)
    fakeNow += skip
    registry.sweep()

    // The reaction should have been cleaned up.
    expect(countIsObserved).toBeFalsy()

    // Whilst nobody's looking, change the observable value
    store.count = 42

    // Now allow the useEffect calls to run to completion,
    // re-awakening the component.
    jest.advanceTimersByTime(500)
    act(() => {
        // no-op, but triggers effect flushing
    })

    // count should be observed once more.
    expect(countIsObserved).toBeTruthy()
    // and the component should have rendered enough to
    // show the latest value, which was set whilst it
    // wasn't even looking.
    expect(rendering.baseElement.textContent).toContain("42")
})



================================================
FILE: packages/mobx-react-lite/__tests__/transactions.test.tsx
================================================
import * as mobx from "mobx"
import * as React from "react"
import { act, render } from "@testing-library/react"

import { observer } from "../src"

test("mobx issue 50", done => {
    const foo = {
        a: mobx.observable.box(true),
        b: mobx.observable.box(false),
        c: mobx.computed((): boolean => {
            // console.log("evaluate c")
            return foo.b.get()
        })
    }
    function flipStuff() {
        mobx.transaction(() => {
            foo.a.set(!foo.a.get())
            foo.b.set(!foo.b.get())
        })
    }
    let asText = ""
    let willReactCount = 0
    mobx.autorun(() => (asText = [foo.a.get(), foo.b.get(), foo.c.get()].join(":")))
    const Test = observer(() => {
        willReactCount++
        return <div id="x">{[foo.a.get(), foo.b.get(), foo.c.get()].join(",")}</div>
    })

    render(<Test />)

    setImmediate(() => {
        act(() => {
            flipStuff()
        })
        expect(asText).toBe("false:true:true")
        expect(document.getElementById("x")!.innerHTML).toBe("false,true,true")
        expect(willReactCount).toBe(2)
        done()
    })
})

it("should respect transaction", async () => {
    const a = mobx.observable.box(2)
    const loaded = mobx.observable.box(false)
    const valuesSeen = [] as number[]

    const Component = observer(() => {
        valuesSeen.push(a.get())
        if (loaded.get()) {
            return <div>{a.get()}</div>
        }
        return <div>loading</div>
    })

    const { container } = render(<Component />)

    act(() => {
        mobx.transaction(() => {
            a.set(3)
            a.set(4)
            loaded.set(true)
        })
    })

    expect(container.textContent!.replace(/\s+/g, "")).toBe("4")
    expect(valuesSeen.sort()).toEqual([2, 4].sort())
})



================================================
FILE: packages/mobx-react-lite/__tests__/tsconfig.json
================================================
{
    "extends": "../tsconfig.test.json"
}



================================================
FILE: packages/mobx-react-lite/__tests__/useAsObservableSource.deprecated.test.tsx
================================================
import { act, cleanup, render, renderHook } from "@testing-library/react"
import { autorun, configure, observable } from "mobx"
import * as React from "react"
import { useEffect, useState } from "react"

import { Observer, observer, useAsObservableSource, useLocalStore } from "../src"
import { resetMobx } from "./utils"

afterEach(cleanup)
afterEach(resetMobx)

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

describe("base useAsObservableSource should work", () => {
    it("with <Observer>", () => {
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
        let counterRender = 0
        let observerRender = 0

        function Counter({ multiplier }: { multiplier: number }) {
            counterRender++
            const observableProps = useAsObservableSource({ multiplier })

            const store = useLocalStore(() => ({
                count: 10,
                get multiplied() {
                    return observableProps.multiplier * this.count
                },
                inc() {
                    this.count += 1
                }
            }))

            return (
                <Observer>
                    {() => {
                        observerRender++
                        return (
                            <div>
                                Multiplied count: <span>{store.multiplied}</span>
                                <button id="inc" onClick={store.inc}>
                                    Increment
                                </button>
                            </div>
                        )
                    }}
                </Observer>
            )
        }

        function Parent() {
            const [multiplier, setMultiplier] = useState(1)

            return (
                <div>
                    <Counter multiplier={multiplier} />
                    <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                </div>
            )
        }

        const { container } = render(<Parent />)

        expect(container.querySelector("span")!.innerHTML).toBe("10")
        expect(counterRender).toBe(1)
        expect(observerRender).toBe(1)

        act(() => {
            ;(container.querySelector("#inc")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("11")
        expect(counterRender).toBe(1)
        expect(observerRender).toBe(2)

        act(() => {
            ;(container.querySelector("#incmultiplier")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("22")
        expect(counterRender).toBe(2)
        expect(observerRender).toBe(4)
        expect(consoleWarnMock).toMatchSnapshot()
    })

    it("with observer()", () => {
        let counterRender = 0

        const Counter = observer(({ multiplier }: { multiplier: number }) => {
            counterRender++

            const observableProps = useAsObservableSource({ multiplier })
            const store = useLocalStore(() => ({
                count: 10,
                get multiplied() {
                    return observableProps.multiplier * this.count
                },
                inc() {
                    this.count += 1
                }
            }))

            return (
                <div>
                    Multiplied count: <span>{store.multiplied}</span>
                    <button id="inc" onClick={store.inc}>
                        Increment
                    </button>
                </div>
            )
        })

        function Parent() {
            const [multiplier, setMultiplier] = useState(1)

            return (
                <div>
                    <Counter multiplier={multiplier} />
                    <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                </div>
            )
        }

        const { container } = render(<Parent />)

        expect(container.querySelector("span")!.innerHTML).toBe("10")
        expect(counterRender).toBe(1)

        act(() => {
            ;(container.querySelector("#inc")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("11")
        expect(counterRender).toBe(2)

        act(() => {
            ;(container.querySelector("#incmultiplier")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("22")
        expect(counterRender).toBe(4) // One from props, second from updating local observable (setState during render)
    })
})

test("useAsObservableSource with effects should work", () => {
    const multiplierSeenByEffect: number[] = []
    const valuesSeenByEffect: number[] = []
    const thingsSeenByEffect: Array<[number, number, number]> = []

    function Counter({ multiplier }: { multiplier: number }) {
        const observableProps = useAsObservableSource({ multiplier })
        const store = useLocalStore(() => ({
            count: 10,
            get multiplied() {
                return observableProps.multiplier * this.count
            },
            inc() {
                this.count += 1
            }
        }))

        useEffect(
            () =>
                autorun(() => {
                    multiplierSeenByEffect.push(observableProps.multiplier)
                }),
            []
        )
        useEffect(
            () =>
                autorun(() => {
                    valuesSeenByEffect.push(store.count)
                }),
            []
        )
        useEffect(
            () =>
                autorun(() => {
                    thingsSeenByEffect.push([
                        observableProps.multiplier,
                        store.multiplied,
                        multiplier
                    ]) // multiplier is trapped!
                }),
            []
        )

        return (
            <button id="inc" onClick={store.inc}>
                Increment
            </button>
        )
    }

    function Parent() {
        const [multiplier, setMultiplier] = useState(1)

        return (
            <div>
                <Counter multiplier={multiplier} />
                <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
            </div>
        )
    }

    const { container } = render(<Parent />)

    act(() => {
        ;(container.querySelector("#inc")! as any).click()
    })

    act(() => {
        ;(container.querySelector("#incmultiplier")! as any).click()
    })

    expect(valuesSeenByEffect).toEqual([10, 11])
    expect(multiplierSeenByEffect).toEqual([1, 2])
    expect(thingsSeenByEffect).toEqual([
        [1, 10, 1],
        [1, 11, 1],
        [2, 22, 1]
    ])
})

describe("combining observer with props and stores", () => {
    it("keeps track of observable values", () => {
        const TestComponent = observer((props: any) => {
            const localStore = useLocalStore(() => ({
                get value() {
                    return props.store.x + 5 * props.store.y
                }
            }))

            return <div>{localStore.value}</div>
        })
        const store = observable({ x: 5, y: 1 })
        const { container } = render(<TestComponent store={store} />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("10")
        act(() => {
            store.y = 2
        })
        expect(div.textContent).toBe("15")
        act(() => {
            store.x = 10
        })
        expect(div.textContent).toBe("20")
    })

    it("allows non-observables to be used if specified as as source", () => {
        const renderedValues: number[] = []

        const TestComponent = observer((props: any) => {
            const obsProps = useAsObservableSource({ y: props.y })
            const localStore = useLocalStore(() => ({
                get value() {
                    return props.store.x + 5 * obsProps.y
                }
            }))

            renderedValues.push(localStore.value)
            return <div>{localStore.value}</div>
        })
        const store = observable({ x: 5 })
        const { container, rerender } = render(<TestComponent store={store} y={1} />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("10")
        rerender(<TestComponent store={store} y={2} />)
        expect(div.textContent).toBe("15")
        act(() => {
            store.x = 10
        })

        expect(renderedValues).toEqual([
            10,
            15, // props change
            15, // local observable change (setState during render)
            20
        ])

        // TODO: re-enable this line. When debugging, the correct value is returned from render,
        // which is also visible with renderedValues, however, querying the dom doesn't show the correct result
        // possible a bug with @testing-library/react?
        // expect(container.querySelector("div")!.textContent).toBe("20") // TODO: somehow this change is not visible in the tester!
    })
})

describe("enforcing actions", () => {
    it("'never' should work", () => {
        configure({ enforceActions: "never" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useAsObservableSource({ hello: thing })
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
    it("only when 'observed' should work", () => {
        configure({ enforceActions: "observed" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useAsObservableSource({ hello: thing })
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
    it("'always' should work", () => {
        configure({ enforceActions: "always" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useAsObservableSource({ hello: thing })
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
})



================================================
FILE: packages/mobx-react-lite/__tests__/useAsObservableSource.test.tsx
================================================
import { act, cleanup, render, renderHook } from "@testing-library/react"
import mockConsole from "jest-mock-console"
import { autorun, configure, observable } from "mobx"
import * as React from "react"
import { useEffect, useState } from "react"

import { Observer, observer, useLocalObservable } from "../src"
import { resetMobx } from "./utils"
import { useObserver } from "../src/useObserver"

afterEach(cleanup)
afterEach(resetMobx)

describe("base useAsObservableSource should work", () => {
    it("with useObserver", () => {
        let counterRender = 0
        let observerRender = 0

        function Counter({ multiplier }: { multiplier: number }) {
            counterRender++
            const observableProps = useLocalObservable(() => ({ multiplier }))
            Object.assign(observableProps, { multiplier })
            const store = useLocalObservable(() => ({
                count: 10,
                get multiplied() {
                    return observableProps.multiplier * this.count
                },
                inc() {
                    this.count += 1
                }
            }))

            return useObserver(
                () => (
                    observerRender++,
                    (
                        <div>
                            Multiplied count: <span>{store.multiplied}</span>
                            <button id="inc" onClick={store.inc}>
                                Increment
                            </button>
                        </div>
                    )
                )
            )
        }

        function Parent() {
            const [multiplier, setMultiplier] = useState(1)

            return (
                <div>
                    <Counter multiplier={multiplier} />
                    <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                </div>
            )
        }

        const { container } = render(<Parent />)

        expect(container.querySelector("span")!.innerHTML).toBe("10")
        expect(counterRender).toBe(1)
        expect(observerRender).toBe(1)

        act(() => {
            ;(container.querySelector("#inc")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("11")
        expect(counterRender).toBe(2) // 1 would be better!
        expect(observerRender).toBe(2)

        act(() => {
            ;(container.querySelector("#incmultiplier")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("22")
        expect(counterRender).toBe(4) // TODO: avoid double rendering here!
        expect(observerRender).toBe(4) // TODO: avoid double rendering here!
    })

    it("with <Observer>", () => {
        let counterRender = 0
        let observerRender = 0

        function Counter({ multiplier }: { multiplier: number }) {
            counterRender++
            const store = useLocalObservable(() => ({
                multiplier,
                count: 10,
                get multiplied() {
                    return this.multiplier * this.count
                },
                inc() {
                    this.count += 1
                }
            }))

            useEffect(() => {
                store.multiplier = multiplier
            }, [multiplier])
            return (
                <Observer>
                    {() => {
                        observerRender++
                        return (
                            <div>
                                Multiplied count: <span>{store.multiplied}</span>
                                <button id="inc" onClick={store.inc}>
                                    Increment
                                </button>
                            </div>
                        )
                    }}
                </Observer>
            )
        }

        function Parent() {
            const [multiplier, setMultiplier] = useState(1)

            return (
                <div>
                    <Counter multiplier={multiplier} />
                    <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                </div>
            )
        }

        const { container } = render(<Parent />)

        expect(container.querySelector("span")!.innerHTML).toBe("10")
        expect(counterRender).toBe(1)
        expect(observerRender).toBe(1)

        act(() => {
            ;(container.querySelector("#inc")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("11")
        expect(counterRender).toBe(1)
        expect(observerRender).toBe(2)

        act(() => {
            ;(container.querySelector("#incmultiplier")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("22")
        expect(counterRender).toBe(2)
        expect(observerRender).toBe(4)
    })

    it("with observer()", () => {
        let counterRender = 0

        const Counter = observer(({ multiplier }: { multiplier: number }) => {
            counterRender++

            const store = useLocalObservable(() => ({
                multiplier,
                count: 10,
                get multiplied() {
                    return this.multiplier * this.count
                },
                inc() {
                    this.count += 1
                }
            }))

            useEffect(() => {
                store.multiplier = multiplier
            }, [multiplier])

            return (
                <div>
                    Multiplied count: <span>{store.multiplied}</span>
                    <button id="inc" onClick={store.inc}>
                        Increment
                    </button>
                </div>
            )
        })

        function Parent() {
            const [multiplier, setMultiplier] = useState(1)

            return (
                <div>
                    <Counter multiplier={multiplier} />
                    <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                </div>
            )
        }

        const { container } = render(<Parent />)

        expect(container.querySelector("span")!.innerHTML).toBe("10")
        expect(counterRender).toBe(1)

        act(() => {
            ;(container.querySelector("#inc")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("11")
        expect(counterRender).toBe(2)

        act(() => {
            ;(container.querySelector("#incmultiplier")! as any).click()
        })
        expect(container.querySelector("span")!.innerHTML).toBe("22")
        expect(counterRender).toBe(4) // One from props, second from updating local observable with effect
    })
})

test("useAsObservableSource with effects should work", () => {
    const multiplierSeenByEffect: number[] = []
    const valuesSeenByEffect: number[] = []
    const thingsSeenByEffect: Array<[number, number, number]> = []

    function Counter({ multiplier }: { multiplier: number }) {
        const store = useLocalObservable(() => ({
            multiplier,
            count: 10,
            get multiplied() {
                return this.multiplier * this.count
            },
            inc() {
                this.count += 1
            }
        }))

        useEffect(() => {
            store.multiplier = multiplier
        }, [multiplier])

        useEffect(
            () =>
                autorun(() => {
                    multiplierSeenByEffect.push(store.multiplier)
                }),
            []
        )
        useEffect(
            () =>
                autorun(() => {
                    valuesSeenByEffect.push(store.count)
                }),
            []
        )
        useEffect(
            () =>
                autorun(() => {
                    thingsSeenByEffect.push([store.multiplier, store.multiplied, multiplier]) // multiplier is trapped!
                }),
            []
        )

        return (
            <button id="inc" onClick={store.inc}>
                Increment
            </button>
        )
    }

    function Parent() {
        const [multiplier, setMultiplier] = useState(1)

        return (
            <div>
                <Counter multiplier={multiplier} />
                <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
            </div>
        )
    }

    const { container } = render(<Parent />)

    act(() => {
        ;(container.querySelector("#inc")! as any).click()
    })

    act(() => {
        ;(container.querySelector("#incmultiplier")! as any).click()
    })

    expect(valuesSeenByEffect).toEqual([10, 11])
    expect(multiplierSeenByEffect).toEqual([1, 2])
    expect(thingsSeenByEffect).toEqual([
        [1, 10, 1],
        [1, 11, 1],
        [2, 22, 1]
    ])
})

describe("combining observer with props and stores", () => {
    it("keeps track of observable values", () => {
        const TestComponent = observer((props: any) => {
            const localStore = useLocalObservable(() => ({
                get value() {
                    return props.store.x + 5 * props.store.y
                }
            }))

            return <div>{localStore.value}</div>
        })
        const store = observable({ x: 5, y: 1 })
        const { container } = render(<TestComponent store={store} />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("10")
        act(() => {
            store.y = 2
        })
        expect(div.textContent).toBe("15")
        act(() => {
            store.x = 10
        })
        expect(div.textContent).toBe("20")
    })

    it("allows non-observables to be used if specified as as source", () => {
        const renderedValues: number[] = []

        const TestComponent = observer((props: any) => {
            const localStore = useLocalObservable(() => ({
                y: props.y,
                get value() {
                    return props.store.x + 5 * this.y
                }
            }))
            localStore.y = props.y
            renderedValues.push(localStore.value)
            return <div>{localStore.value}</div>
        })
        const store = observable({ x: 5 })
        const { container, rerender } = render(<TestComponent store={store} y={1} />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("10")
        rerender(<TestComponent store={store} y={2} />)
        expect(div.textContent).toBe("15")
        act(() => {
            store.x = 10
        })

        expect(renderedValues).toEqual([
            10,
            15, // props change
            15, // local observable change during render (localStore.y = props.y)
            20
        ])

        expect(container.querySelector("div")!.textContent).toBe("20")
    })
})

describe("enforcing actions", () => {
    it("'never' should work", () => {
        configure({ enforceActions: "never" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useLocalObservable(() => ({ hello: thing }))
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
    it("only when 'observed' should work", () => {
        configure({ enforceActions: "observed" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useLocalObservable(() => ({ hello: thing }))
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
    it("'always' should work", () => {
        configure({ enforceActions: "always" })
        const onError = jest.fn()
        renderHook(
            () => {
                const [thing, setThing] = React.useState("world")
                useLocalObservable(() => ({ hello: thing }))
                useEffect(() => setThing("react"), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )
        expect(onError).not.toBeCalled()
    })
})

it("doesn't update a component while rendering a different component - #274", () => {
    // https://github.com/facebook/react/pull/17099

    const Parent = observer((props: any) => {
        const observableProps = useLocalObservable(() => props)
        useEffect(() => {
            Object.assign(observableProps, props)
        }, [props])

        return <Child observableProps={observableProps} />
    })

    const Child = observer(({ observableProps }: any) => {
        return observableProps.foo
    })

    const { container, rerender } = render(<Parent foo={1} />)
    expect(container.textContent).toBe("1")

    const restoreConsole = mockConsole()
    rerender(<Parent foo={2} />)
    expect(console.error).not.toHaveBeenCalled()
    restoreConsole()
    expect(container.textContent).toBe("2")
})



================================================
FILE: packages/mobx-react-lite/__tests__/useLocalObservable.test.tsx
================================================
import * as mobx from "mobx"
import * as React from "react"
import { act, cleanup, fireEvent, render, renderHook } from "@testing-library/react"

import { Observer, observer, useLocalObservable } from "../src"
import { useEffect, useState } from "react"
import { autorun } from "mobx"
import { useObserver } from "../src/useObserver"

afterEach(cleanup)

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

test("base useLocalStore should work", () => {
    let counterRender = 0
    let observerRender = 0
    let outerStoreRef: any

    function Counter() {
        counterRender++
        const store = (outerStoreRef = useLocalObservable(() => ({
            count: 0,
            count2: 0, // not used in render
            inc() {
                this.count += 1
            }
        })))

        return useObserver(() => {
            observerRender++
            return (
                <div>
                    Count: <span>{store.count}</span>
                    <button onClick={store.inc}>Increment</button>
                </div>
            )
        })
    }

    const { container } = render(<Counter />)

    expect(container.querySelector("span")!.innerHTML).toBe("0")
    expect(counterRender).toBe(1)
    expect(observerRender).toBe(1)

    act(() => {
        container.querySelector("button")!.click()
    })
    expect(container.querySelector("span")!.innerHTML).toBe("1")
    expect(counterRender).toBe(2)
    expect(observerRender).toBe(2)

    act(() => {
        outerStoreRef.count++
    })
    expect(container.querySelector("span")!.innerHTML).toBe("2")
    expect(counterRender).toBe(3)
    expect(observerRender).toBe(3)

    act(() => {
        outerStoreRef.count2++
    })
    // No re-render!
    expect(container.querySelector("span")!.innerHTML).toBe("2")
    expect(counterRender).toBe(3)
    expect(observerRender).toBe(3)
})

describe("is used to keep observable within component body", () => {
    it("value can be changed over renders", () => {
        const TestComponent = () => {
            const obs = useLocalObservable(() => ({
                x: 1,
                y: 2
            }))
            return (
                <div onClick={() => (obs.x += 1)}>
                    {obs.x}-{obs.y}
                </div>
            )
        }
        const { container, rerender } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        // observer not used, need to render from outside
        rerender(<TestComponent />)
        expect(div.textContent).toBe("2-2")
    })

    it("works with observer as well", () => {
        let renderCount = 0

        const TestComponent = observer(() => {
            renderCount++

            const obs = useLocalObservable(() => ({
                x: 1,
                y: 2
            }))
            return (
                <div onClick={() => (obs.x += 1)}>
                    {obs.x}-{obs.y}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("2-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("3-2")

        expect(renderCount).toBe(3)
    })

    it("actions can be used", () => {
        const TestComponent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1,
                y: 2,
                inc() {
                    obs.x += 1
                }
            }))
            return (
                <div onClick={obs.inc}>
                    {obs.x}-{obs.y}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("2-2")
    })

    it("computed properties works as well", () => {
        const TestComponent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1,
                y: 2,
                get z() {
                    return obs.x + obs.y
                }
            }))
            return <div onClick={() => (obs.x += 1)}>{obs.z}</div>
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("3")
        fireEvent.click(div)
        expect(div.textContent).toBe("4")
    })

    it("computed properties can use local functions", () => {
        const TestComponent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1,
                y: 2,
                getMeThatX() {
                    return this.x
                },
                get z() {
                    return this.getMeThatX() + obs.y
                }
            }))
            return <div onClick={() => (obs.x += 1)}>{obs.z}</div>
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("3")
        fireEvent.click(div)
        expect(div.textContent).toBe("4")
    })

    it("transactions are respected", () => {
        const seen: number[] = []

        const TestComponent = observer(() => {
            const obs = useLocalObservable(() => ({
                x: 1,
                inc(delta: number) {
                    this.x += delta
                    this.x += delta
                }
            }))

            useEffect(
                () =>
                    autorun(() => {
                        seen.push(obs.x)
                    }),
                []
            )

            return (
                <div
                    onClick={() => {
                        obs.inc(2)
                    }}
                >
                    Test
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        fireEvent.click(div)
        expect(seen).toEqual([1, 5]) // No 3!
    })

    it("Map can used instead of object", () => {
        const TestComponent = observer(() => {
            const map = useLocalObservable(() => new Map([["initial", 10]]))
            return (
                <div onClick={() => map.set("later", 20)}>
                    {Array.from(map).map(([key, value]) => (
                        <div key={key}>
                            {key} - {value}
                        </div>
                    ))}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("initial - 10")
        fireEvent.click(div)
        expect(div.textContent).toBe("initial - 10later - 20")
    })

    describe("with props", () => {
        it("and useObserver", () => {
            let counterRender = 0
            let observerRender = 0

            function Counter({ multiplier }: { multiplier: number }) {
                counterRender++

                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])

                return useObserver(
                    () => (
                        observerRender++,
                        (
                            <div>
                                Multiplied count: <span>{store.multiplied}</span>
                                <button id="inc" onClick={store.inc}>
                                    Increment
                                </button>
                            </div>
                        )
                    )
                )
            }

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(2) // 1 would be better!
            expect(observerRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(4) // TODO: avoid double rendering here!
            expect(observerRender).toBe(4) // TODO: avoid double rendering here!
        })

        it("with <Observer>", () => {
            let counterRender = 0
            let observerRender = 0

            function Counter({ multiplier }: { multiplier: number }) {
                counterRender++

                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])

                return (
                    <Observer>
                        {() => {
                            observerRender++
                            return (
                                <div>
                                    Multiplied count: <span>{store.multiplied}</span>
                                    <button id="inc" onClick={store.inc}>
                                        Increment
                                    </button>
                                </div>
                            )
                        }}
                    </Observer>
                )
            }

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(2)
            expect(observerRender).toBe(4)
        })

        it("with observer()", () => {
            let counterRender = 0

            const Counter = observer(({ multiplier }: { multiplier: number }) => {
                counterRender++

                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])
                return (
                    <div>
                        Multiplied count: <span>{store.multiplied}</span>
                        <button id="inc" onClick={store.inc}>
                            Increment
                        </button>
                    </div>
                )
            })

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(4) // One from props, second from updating local observable with effect
        })
    })
})

describe("enforcing actions", () => {
    it("'never' should work", () => {
        mobx.configure({ enforceActions: "never" })
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

        const onError = jest.fn()
        const { result } = renderHook(
            () => {
                const [multiplier, setMultiplier] = React.useState(2)
                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])
                useEffect(() => setMultiplier(3), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )

        expect(onError).not.toBeCalled()
        expect(consoleWarnMock).not.toBeCalled()
    })
    it("only when 'observed' should work", () => {
        mobx.configure({ enforceActions: "observed" })
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

        const onError = jest.fn()
        renderHook(
            () => {
                const [multiplier, setMultiplier] = React.useState(2)
                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])
                useEffect(() => setMultiplier(3), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )

        expect(onError).not.toBeCalled()
        expect(consoleWarnMock).not.toBeCalled()
    })
    it("'always' should work", () => {
        mobx.configure({ enforceActions: "always" })
        consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})

        const onError = jest.fn()
        renderHook(
            () => {
                const [multiplier, setMultiplier] = React.useState(2)
                const store = useLocalObservable(() => ({
                    multiplier,
                    count: 10,
                    get multiplied() {
                        return this.multiplier * this.count
                    },
                    inc() {
                        this.count += 1
                    }
                }))
                useEffect(() => {
                    store.multiplier = multiplier
                }, [multiplier])
                useEffect(() => setMultiplier(3), [])
            },
            {
                wrapper: class extends React.Component<React.PropsWithChildren> {
                    componentDidCatch = onError
                    render() {
                        return this.props.children
                    }
                }
            }
        )

        expect(onError).not.toBeCalled()
        expect(consoleWarnMock).toBeCalledTimes(2)
    })
})



================================================
FILE: packages/mobx-react-lite/__tests__/useLocalStore.deprecated.test.tsx
================================================
import * as React from "react"
import { act, cleanup, fireEvent, render } from "@testing-library/react"

import { Observer, observer, useLocalStore } from "../src"
import { useEffect, useState } from "react"
import { autorun } from "mobx"

afterEach(cleanup)

let consoleWarnMock: jest.SpyInstance | undefined
afterEach(() => {
    consoleWarnMock?.mockRestore()
})

test("base useLocalStore should work", () => {
    consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
    let counterRender = 0
    let observerRender = 0
    let outerStoreRef: any

    function Counter() {
        counterRender++
        const store = (outerStoreRef = useLocalStore(() => ({
            count: 0,
            count2: 0, // not used in render
            inc() {
                this.count += 1
            }
        })))

        return (
            <Observer>
                {() => {
                    observerRender++
                    return (
                        <div>
                            Count: <span>{store.count}</span>
                            <button onClick={store.inc}>Increment</button>
                        </div>
                    )
                }}
            </Observer>
        )
    }

    const { container } = render(<Counter />)

    expect(container.querySelector("span")!.innerHTML).toBe("0")
    expect(counterRender).toBe(1)
    expect(observerRender).toBe(1)

    act(() => {
        container.querySelector("button")!.click()
    })
    expect(container.querySelector("span")!.innerHTML).toBe("1")
    expect(counterRender).toBe(1)
    expect(observerRender).toBe(2)

    act(() => {
        outerStoreRef.count++
    })
    expect(container.querySelector("span")!.innerHTML).toBe("2")
    expect(counterRender).toBe(1)
    expect(observerRender).toBe(3)

    act(() => {
        outerStoreRef.count2++
    })
    // No re-render!
    expect(container.querySelector("span")!.innerHTML).toBe("2")
    expect(counterRender).toBe(1)
    expect(observerRender).toBe(3)
    expect(consoleWarnMock).toMatchSnapshot()
})

describe("is used to keep observable within component body", () => {
    it("value can be changed over renders", () => {
        const TestComponent = () => {
            const obs = useLocalStore(() => ({
                x: 1,
                y: 2
            }))
            return (
                <div onClick={() => (obs.x += 1)}>
                    {obs.x}-{obs.y}
                </div>
            )
        }
        const { container, rerender } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        // observer not used, need to render from outside
        rerender(<TestComponent />)
        expect(div.textContent).toBe("2-2")
    })

    it("works with observer as well", () => {
        let renderCount = 0

        const TestComponent = observer(() => {
            renderCount++

            const obs = useLocalStore(() => ({
                x: 1,
                y: 2
            }))
            return (
                <div onClick={() => (obs.x += 1)}>
                    {obs.x}-{obs.y}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("2-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("3-2")

        expect(renderCount).toBe(3)
    })

    it("actions can be used", () => {
        const TestComponent = observer(() => {
            const obs = useLocalStore(() => ({
                x: 1,
                y: 2,
                inc() {
                    obs.x += 1
                }
            }))
            return (
                <div onClick={obs.inc}>
                    {obs.x}-{obs.y}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("1-2")
        fireEvent.click(div)
        expect(div.textContent).toBe("2-2")
    })

    it("computed properties works as well", () => {
        const TestComponent = observer(() => {
            const obs = useLocalStore(() => ({
                x: 1,
                y: 2,
                get z() {
                    return obs.x + obs.y
                }
            }))
            return <div onClick={() => (obs.x += 1)}>{obs.z}</div>
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("3")
        fireEvent.click(div)
        expect(div.textContent).toBe("4")
    })

    it("computed properties can use local functions", () => {
        const TestComponent = observer(() => {
            const obs = useLocalStore(() => ({
                x: 1,
                y: 2,
                getMeThatX() {
                    return this.x
                },
                get z() {
                    return this.getMeThatX() + obs.y
                }
            }))
            return <div onClick={() => (obs.x += 1)}>{obs.z}</div>
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("3")
        fireEvent.click(div)
        expect(div.textContent).toBe("4")
    })

    it("transactions are respected", () => {
        const seen: number[] = []

        const TestComponent = observer(() => {
            const obs = useLocalStore(() => ({
                x: 1,
                inc(delta: number) {
                    this.x += delta
                    this.x += delta
                }
            }))

            useEffect(
                () =>
                    autorun(() => {
                        seen.push(obs.x)
                    }),
                []
            )

            return (
                <div
                    onClick={() => {
                        obs.inc(2)
                    }}
                >
                    Test
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        fireEvent.click(div)
        expect(seen).toEqual([1, 5]) // No 3!
    })

    it("Map can used instead of object", () => {
        const TestComponent = observer(() => {
            const map = useLocalStore(() => new Map([["initial", 10]]))
            return (
                <div onClick={() => map.set("later", 20)}>
                    {Array.from(map).map(([key, value]) => (
                        <div key={key}>
                            {key} - {value}
                        </div>
                    ))}
                </div>
            )
        })
        const { container } = render(<TestComponent />)
        const div = container.querySelector("div")!
        expect(div.textContent).toBe("initial - 10")
        fireEvent.click(div)
        expect(div.textContent).toBe("initial - 10later - 20")
    })

    describe("with props", () => {
        it("and useObserver", () => {
            consoleWarnMock = jest.spyOn(console, "warn").mockImplementation(() => {})
            let counterRender = 0
            let observerRender = 0

            function Counter({ multiplier }: { multiplier: number }) {
                counterRender++

                const store = useLocalStore(
                    props => ({
                        count: 10,
                        get multiplied() {
                            return props.multiplier * this.count
                        },
                        inc() {
                            this.count += 1
                        }
                    }),
                    { multiplier }
                )

                return (
                    <Observer>
                        {() => (
                            observerRender++,
                            (
                                <div>
                                    Multiplied count: <span>{store.multiplied}</span>
                                    <button id="inc" onClick={store.inc}>
                                        Increment
                                    </button>
                                </div>
                            )
                        )}
                    </Observer>
                )
            }

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(1) // or 2
            expect(observerRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(2)
            expect(observerRender).toBe(4)
            expect(consoleWarnMock).toMatchSnapshot()
        })

        it("with <Observer>", () => {
            let counterRender = 0
            let observerRender = 0

            function Counter({ multiplier }: { multiplier: number }) {
                counterRender++

                const store = useLocalStore(
                    props => ({
                        count: 10,
                        get multiplied() {
                            return props.multiplier * this.count
                        },
                        inc() {
                            this.count += 1
                        }
                    }),
                    { multiplier }
                )

                return (
                    <Observer>
                        {() => {
                            observerRender++
                            return (
                                <div>
                                    Multiplied count: <span>{store.multiplied}</span>
                                    <button id="inc" onClick={store.inc}>
                                        Increment
                                    </button>
                                </div>
                            )
                        }}
                    </Observer>
                )
            }

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(1)
            expect(observerRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(2)
            expect(observerRender).toBe(4)
        })

        it("with observer()", () => {
            let counterRender = 0

            const Counter = observer(({ multiplier }: { multiplier: number }) => {
                counterRender++

                const store = useLocalStore(
                    props => ({
                        count: 10,
                        get multiplied() {
                            return props.multiplier * this.count
                        },
                        inc() {
                            this.count += 1
                        }
                    }),
                    { multiplier }
                )

                return (
                    <div>
                        Multiplied count: <span>{store.multiplied}</span>
                        <button id="inc" onClick={store.inc}>
                            Increment
                        </button>
                    </div>
                )
            })

            function Parent() {
                const [multiplier, setMultiplier] = useState(1)

                return (
                    <div>
                        <Counter multiplier={multiplier} />
                        <button id="incmultiplier" onClick={() => setMultiplier(m => m + 1)} />
                    </div>
                )
            }

            const { container } = render(<Parent />)

            expect(container.querySelector("span")!.innerHTML).toBe("10")
            expect(counterRender).toBe(1)

            act(() => {
                ;(container.querySelector("#inc")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("11")
            expect(counterRender).toBe(2)

            act(() => {
                ;(container.querySelector("#incmultiplier")! as any).click()
            })
            expect(container.querySelector("span")!.innerHTML).toBe("22")
            expect(counterRender).toBe(4) // One from props, second from updating source (setState during render)
        })
    })
})



================================================
FILE: packages/mobx-react-lite/__tests__/utils.ts
================================================
import { configure } from "mobx"

export function resetMobx(): void {
    configure({ enforceActions: "never" })
}

export function enableDevEnvironment() {
    process.env.NODE_ENV === "development"
    return function () {
        process.env.NODE_ENV === "production"
    }
}

export function sleep(time: number) {
    return new Promise<void>(res => {
        setTimeout(res, time)
    })
}



================================================
FILE: packages/mobx-react-lite/__tests__/.eslintrc.yaml
================================================
env:
    jest: true
rules:
    "react/display-name": "off"
    "react/prop-types": "off"



================================================
FILE: packages/mobx-react-lite/__tests__/__snapshots__/observer.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`changing state in render should fail 1`] = `
<div>
  <div>
    4
  </div>
</div>
`;

exports[`changing state in render should fail 2`] = `
<div>
  <div>
    4
  </div>
</div>
`;

exports[`issue 12 init state is correct 1`] = `
<div>
  <div>
    <span>
      coffee
      !
    </span>
    <span>
      tea
    </span>
  </div>
</div>
`;

exports[`issue 12 init state is correct 2`] = `
<div>
  <div>
    <span>
      coffee
      !
    </span>
    <span>
      tea
    </span>
  </div>
</div>
`;

exports[`issue 12 run transaction 1`] = `
<div>
  <div>
    <span>
      soup
    </span>
  </div>
</div>
`;

exports[`issue 12 run transaction 2`] = `
<div>
  <div>
    <span>
      soup
    </span>
  </div>
</div>
`;

exports[`issue 309 isObserverBatched is still defined and yields true by default 1`] = `
[MockFunction] {
  "calls": [
    [
      "[MobX] Deprecated",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;

exports[`issue 309 isObserverBatched is still defined and yields true by default 2`] = `
[MockFunction] {
  "calls": [
    [
      "[MobX] Deprecated",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;

exports[`observer(cmp, { forwardRef: true }) + useImperativeHandle 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx-react-lite] \`observer(fn, { forwardRef: true })\` is deprecated, use \`observer(React.forwardRef(fn))\`",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;

exports[`useImperativeHandle and forwardRef should work with useObserver 1`] = `[MockFunction]`;



================================================
FILE: packages/mobx-react-lite/__tests__/__snapshots__/printDebugValue.test.ts.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`printDebugValue 1`] = `
{
  "dependencies": [
    {
      "name": "ObservableObject@1.euro",
    },
    {
      "dependencies": [
        {
          "name": "ObservableObject@1.euro",
        },
      ],
      "name": "ObservableObject@1.pound",
    },
  ],
  "name": "Autorun@2",
}
`;

exports[`printDebugValue 2`] = `
{
  "name": "Autorun@2",
}
`;



================================================
FILE: packages/mobx-react-lite/__tests__/__snapshots__/useAsObservableSource.deprecated.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`base useAsObservableSource should work with <Observer> 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.",
    ],
    [
      "[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;



================================================
FILE: packages/mobx-react-lite/__tests__/__snapshots__/useLocalStore.deprecated.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`base useLocalStore should work 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;

exports[`is used to keep observable within component body with props and useObserver 1`] = `
[MockFunction] {
  "calls": [
    [
      "[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.",
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;



================================================
FILE: packages/mobx-react-lite/__tests__/utils/killFinalizationRegistry.ts
================================================
// We want to be able to test reaction cleanup code that based on FinalizationRegistry & timers on the same run
// For that we import this file on the beginning on the timer based test to the feature detection will pick the timers impl
// @ts-ignore
global.FinalizationRegistry = undefined



================================================
FILE: packages/mobx-react-lite/src/index.ts
================================================
import "./utils/assertEnvironment"

import { unstable_batchedUpdates as batch } from "./utils/reactBatchedUpdates"
import { observerBatching } from "./utils/observerBatching"
import { useDeprecated } from "./utils/utils"
import { useObserver as useObserverOriginal } from "./useObserver"
import { enableStaticRendering } from "./staticRendering"
import { observerFinalizationRegistry } from "./utils/observerFinalizationRegistry"

observerBatching(batch)

export { isUsingStaticRendering, enableStaticRendering } from "./staticRendering"
export { observer, IObserverOptions } from "./observer"
export { Observer } from "./ObserverComponent"
export { useLocalObservable } from "./useLocalObservable"
export { useLocalStore } from "./useLocalStore"
export { useAsObservableSource } from "./useAsObservableSource"

export { observerFinalizationRegistry as _observerFinalizationRegistry }
export const clearTimers = observerFinalizationRegistry["finalizeAllImmediately"] ?? (() => {})

export function useObserver<T>(fn: () => T, baseComponentName: string = "observed"): T {
    if ("production" !== process.env.NODE_ENV) {
        useDeprecated(
            "[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`."
        )
    }
    return useObserverOriginal(fn, baseComponentName)
}

export { isObserverBatched, observerBatching } from "./utils/observerBatching"

export function useStaticRendering(enable: boolean) {
    if ("production" !== process.env.NODE_ENV) {
        console.warn(
            "[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead"
        )
    }
    enableStaticRendering(enable)
}



================================================
FILE: packages/mobx-react-lite/src/observer.ts
================================================
import { forwardRef, memo } from "react"

import { isUsingStaticRendering } from "./staticRendering"
import { useObserver } from "./useObserver"

let warnObserverOptionsDeprecated = true
let warnLegacyContextTypes = true

const hasSymbol = typeof Symbol === "function" && Symbol.for
const isFunctionNameConfigurable =
    Object.getOwnPropertyDescriptor(() => {}, "name")?.configurable ?? false

// Using react-is had some issues (and operates on elements, not on types), see #608 / #609
const ReactForwardRefSymbol = hasSymbol
    ? Symbol.for("react.forward_ref")
    : typeof forwardRef === "function" && forwardRef((props: any) => null)["$$typeof"]

const ReactMemoSymbol = hasSymbol
    ? Symbol.for("react.memo")
    : typeof memo === "function" && memo((props: any) => null)["$$typeof"]

/**
 * @deprecated Observer options will be removed in the next major version of mobx-react-lite.
 * Look at the individual properties for alternatives.
 */
export interface IObserverOptions {
    /**
     * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object
     * e.g. `observer(React.forwardRef(fn))`
     */
    readonly forwardRef?: boolean
}

export function observer<P extends object, TRef = {}>(
    baseComponent: React.ForwardRefRenderFunction<TRef, P>,
    options: IObserverOptions & {
        /**
         * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object
         * e.g. `observer(React.forwardRef(fn))`
         */
        forwardRef: true
    }
): React.MemoExoticComponent<
    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>
>

export function observer<P extends object, TRef = {}>(
    baseComponent: React.ForwardRefExoticComponent<
        React.PropsWithoutRef<P> & React.RefAttributes<TRef>
    >
): React.MemoExoticComponent<
    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>
>

export function observer<P extends object>(
    baseComponent: React.FunctionComponent<P>,
    options?: IObserverOptions
): React.FunctionComponent<P>

export function observer<
    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,
    Options extends IObserverOptions
>(
    baseComponent: C,
    options?: Options
): Options extends { forwardRef: true }
    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>
        ? C &
              React.MemoExoticComponent<
                  React.ForwardRefExoticComponent<
                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>
                  >
              >
        : never /* forwardRef set for a non forwarding component */
    : C & { displayName: string }

// n.b. base case is not used for actual typings or exported in the typing files
export function observer<P extends object, TRef = {}>(
    baseComponent:
        | React.ForwardRefRenderFunction<TRef, P>
        | React.FunctionComponent<P>
        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,
    // TODO remove in next major
    options?: IObserverOptions
) {
    if (process.env.NODE_ENV !== "production" && warnObserverOptionsDeprecated && options) {
        warnObserverOptionsDeprecated = false
        console.warn(
            `[mobx-react-lite] \`observer(fn, { forwardRef: true })\` is deprecated, use \`observer(React.forwardRef(fn))\``
        )
    }

    if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
        throw new Error(
            `[mobx-react-lite] You are trying to use \`observer\` on a function component wrapped in either another \`observer\` or \`React.memo\`. The observer already applies 'React.memo' for you.`
        )
    }

    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307
    if (isUsingStaticRendering()) {
        return baseComponent
    }

    let useForwardRef = options?.forwardRef ?? false
    let render = baseComponent

    const baseComponentName = baseComponent.displayName || baseComponent.name

    // If already wrapped with forwardRef, unwrap,
    // so we can patch render and apply memo
    if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
        useForwardRef = true
        render = baseComponent["render"]
        if (typeof render !== "function") {
            throw new Error(
                `[mobx-react-lite] \`render\` property of ForwardRef was not a function`
            )
        }
    }

    let observerComponent = (props: any, ref: React.Ref<TRef>) => {
        return useObserver(() => render(props, ref), baseComponentName)
    }

    // Inherit original name and displayName, see #3438
    ;(observerComponent as React.FunctionComponent).displayName = baseComponent.displayName

    if (isFunctionNameConfigurable) {
        Object.defineProperty(observerComponent, "name", {
            value: baseComponent.name,
            writable: true,
            configurable: true
        })
    }

    // Support legacy context: `contextTypes` must be applied before `memo`
    if ((baseComponent as any).contextTypes) {
        ;(observerComponent as React.FunctionComponent).contextTypes = (
            baseComponent as any
        ).contextTypes

        if (process.env.NODE_ENV !== "production" && warnLegacyContextTypes) {
            warnLegacyContextTypes = false
            console.warn(
                `[mobx-react-lite] Support for Legacy Context in function components will be removed in the next major release.`
            )
        }
    }

    if (useForwardRef) {
        // `forwardRef` must be applied prior `memo`
        // `forwardRef(observer(cmp))` throws:
        // "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))"
        observerComponent = forwardRef(observerComponent)
    }

    // memo; we are not interested in deep updates
    // in props; we assume that if deep objects are changed,
    // this is in observables, which would have been tracked anyway
    observerComponent = memo(observerComponent)

    copyStaticProperties(baseComponent, observerComponent)

    if ("production" !== process.env.NODE_ENV) {
        Object.defineProperty(observerComponent, "contextTypes", {
            set() {
                throw new Error(
                    `[mobx-react-lite] \`${
                        this.displayName || this.type?.displayName || this.type?.name || "Component"
                    }.contextTypes\` must be set before applying \`observer\`.`
                )
            }
        })
    }

    return observerComponent
}

// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js
const hoistBlackList: any = {
    $$typeof: true,
    render: true,
    compare: true,
    type: true,
    // Don't redefine `displayName`,
    // it's defined as getter-setter pair on `memo` (see #3192).
    displayName: true
}

function copyStaticProperties(base: any, target: any) {
    Object.keys(base).forEach(key => {
        if (!hoistBlackList[key]) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)
        }
    })
}



================================================
FILE: packages/mobx-react-lite/src/ObserverComponent.ts
================================================
import { useObserver } from "./useObserver"

// TODO: this type could be improved in the next major release:
// type IObserverProps = { children: () => React.ReactNode, render?: never } | { children?: never, render: () => React.ReactNode }
interface IObserverProps {
    children?(): React.ReactElement | null
    render?(): React.ReactElement | null
}

function ObserverComponent({ children, render }: IObserverProps) {
    if (children && render) {
        console.error(
            "MobX Observer: Do not use children and render in the same time in `Observer`"
        )
    }
    const component = children || render
    if (typeof component !== "function") {
        return null
    }
    return useObserver(component)
}
if ("production" !== process.env.NODE_ENV) {
    ObserverComponent.propTypes = {
        children: ObserverPropsCheck,
        render: ObserverPropsCheck
    }
}
ObserverComponent.displayName = "Observer"

export { ObserverComponent as Observer }

function ObserverPropsCheck(
    props: { [k: string]: any },
    key: string,
    componentName: string,
    location: any,
    propFullName: string
) {
    const extraKey = key === "children" ? "render" : "children"
    const hasProp = typeof props[key] === "function"
    const hasExtraProp = typeof props[extraKey] === "function"
    if (hasProp && hasExtraProp) {
        return new Error(
            "MobX Observer: Do not use children and render in the same time in`" + componentName
        )
    }

    if (hasProp || hasExtraProp) {
        return null
    }
    return new Error(
        "Invalid prop `" +
            propFullName +
            "` of type `" +
            typeof props[key] +
            "` supplied to" +
            " `" +
            componentName +
            "`, expected `function`."
    )
}



================================================
FILE: packages/mobx-react-lite/src/staticRendering.ts
================================================
let globalIsUsingStaticRendering = false

export function enableStaticRendering(enable: boolean) {
    globalIsUsingStaticRendering = enable
}

export function isUsingStaticRendering(): boolean {
    return globalIsUsingStaticRendering
}



================================================
FILE: packages/mobx-react-lite/src/useAsObservableSource.ts
================================================
import { useDeprecated } from "./utils/utils"
import { observable, runInAction } from "mobx"
import { useState } from "react"

export function useAsObservableSource<TSource extends object>(current: TSource): TSource {
    if ("production" !== process.env.NODE_ENV)
        useDeprecated(
            "[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples."
        )
    // We're deliberately not using idiomatic destructuring for the hook here.
    // Accessing the state value as an array element prevents TypeScript from generating unnecessary helpers in the resulting code.
    // For further details, please refer to mobxjs/mobx#3842.
    const res = useState(() => observable(current, {}, { deep: false }))[0]
    runInAction(() => {
        Object.assign(res, current)
    })
    return res
}



================================================
FILE: packages/mobx-react-lite/src/useLocalObservable.ts
================================================
import { observable, AnnotationsMap } from "mobx"
import { useState } from "react"

export function useLocalObservable<TStore extends Record<string, any>>(
    initializer: () => TStore,
    annotations?: AnnotationsMap<TStore, never>
): TStore {
    return useState(() => observable(initializer(), annotations, { autoBind: true }))[0]
}



================================================
FILE: packages/mobx-react-lite/src/useLocalStore.ts
================================================
import { observable } from "mobx"
import { useState } from "react"

import { useDeprecated } from "./utils/utils"
import { useAsObservableSource } from "./useAsObservableSource"

export function useLocalStore<TStore extends Record<string, any>>(initializer: () => TStore): TStore
export function useLocalStore<TStore extends Record<string, any>, TSource extends object>(
    initializer: (source: TSource) => TStore,
    current: TSource
): TStore
export function useLocalStore<TStore extends Record<string, any>, TSource extends object>(
    initializer: (source?: TSource) => TStore,
    current?: TSource
): TStore {
    if ("production" !== process.env.NODE_ENV) {
        useDeprecated(
            "[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead."
        )
    }
    const source = current && useAsObservableSource(current)
    return useState(() => observable(initializer(source), undefined, { autoBind: true }))[0]
}



================================================
FILE: packages/mobx-react-lite/src/useObserver.ts
================================================
import { Reaction } from "mobx"
import React from "react"
import { printDebugValue } from "./utils/printDebugValue"
import { isUsingStaticRendering } from "./staticRendering"
import { observerFinalizationRegistry } from "./utils/observerFinalizationRegistry"
import { useSyncExternalStore } from "use-sync-external-store/shim"

// Do not store `admRef` (even as part of a closure!) on this object,
// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.
type ObserverAdministration = {
    reaction: Reaction | null // also serves as disposed flag
    onStoreChange: Function | null // also serves as mounted flag
    // stateVersion that 'ticks' for every time the reaction fires
    // tearing is still present,
    // because there is no cross component synchronization,
    // but we can use `useSyncExternalStore` API.
    // TODO: optimize to use number?
    stateVersion: any
    name: string
    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`
    subscribe: Parameters<typeof React.useSyncExternalStore>[0]
    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]
}

function createReaction(adm: ObserverAdministration) {
    adm.reaction = new Reaction(`observer${adm.name}`, () => {
        adm.stateVersion = Symbol()
        // onStoreChange won't be available until the component "mounts".
        // If state changes in between initial render and mount,
        // `useSyncExternalStore` should handle that by checking the state version and issuing update.
        adm.onStoreChange?.()
    })
}

export function useObserver<T>(render: () => T, baseComponentName: string = "observed"): T {
    if (isUsingStaticRendering()) {
        return render()
    }

    const admRef = React.useRef<ObserverAdministration | null>(null)

    if (!admRef.current) {
        // First render
        const adm: ObserverAdministration = {
            reaction: null,
            onStoreChange: null,
            stateVersion: Symbol(),
            name: baseComponentName,
            subscribe(onStoreChange: () => void) {
                // Do NOT access admRef here!
                observerFinalizationRegistry.unregister(adm)
                adm.onStoreChange = onStoreChange
                if (!adm.reaction) {
                    // We've lost our reaction and therefore all subscriptions, occurs when:
                    // 1. Timer based finalization registry disposed reaction before component mounted.
                    // 2. React "re-mounts" same component without calling render in between (typically <StrictMode>).
                    // We have to recreate reaction and schedule re-render to recreate subscriptions,
                    // even if state did not change.
                    createReaction(adm)
                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.
                    // So we make sure that is not the case
                    adm.stateVersion = Symbol()
                }

                return () => {
                    // Do NOT access admRef here!
                    adm.onStoreChange = null
                    adm.reaction?.dispose()
                    adm.reaction = null
                }
            },
            getSnapshot() {
                // Do NOT access admRef here!
                return adm.stateVersion
            }
        }

        admRef.current = adm
    }

    const adm = admRef.current!

    if (!adm.reaction) {
        // First render or reaction was disposed by registry before subscribe
        createReaction(adm)
        // StrictMode/ConcurrentMode/Suspense may mean that our component is
        // rendered and abandoned multiple times, so we need to track leaked
        // Reactions.
        observerFinalizationRegistry.register(admRef, adm, adm)
    }

    React.useDebugValue(adm.reaction!, printDebugValue)

    useSyncExternalStore(
        // Both of these must be stable, otherwise it would keep resubscribing every render.
        adm.subscribe,
        adm.getSnapshot,
        adm.getSnapshot
    )

    // render the original component, but have the
    // reaction track the observables, so that rendering
    // can be invalidated (see above) once a dependency changes
    let renderResult!: T
    let exception
    adm.reaction!.track(() => {
        try {
            renderResult = render()
        } catch (e) {
            exception = e
        }
    })

    if (exception) {
        throw exception // re-throw any exceptions caught during rendering
    }

    return renderResult
}



================================================
FILE: packages/mobx-react-lite/src/utils/assertEnvironment.ts
================================================
import { makeObservable } from "mobx"
import { useState } from "react"

if (!useState) {
    throw new Error("mobx-react-lite requires React with Hooks support")
}
if (!makeObservable) {
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available")
}



================================================
FILE: packages/mobx-react-lite/src/utils/observerBatching.ts
================================================
import { configure } from "mobx"

export function defaultNoopBatch(callback: () => void) {
    callback()
}

export function observerBatching(reactionScheduler: any) {
    if (!reactionScheduler) {
        reactionScheduler = defaultNoopBatch
        if ("production" !== process.env.NODE_ENV) {
            console.warn(
                "[MobX] Failed to get unstable_batched updates from react-dom / react-native"
            )
        }
    }
    configure({ reactionScheduler })
}

export const isObserverBatched = () => {
    if ("production" !== process.env.NODE_ENV) {
        console.warn("[MobX] Deprecated")
    }

    return true
}



================================================
FILE: packages/mobx-react-lite/src/utils/observerFinalizationRegistry.ts
================================================
import { Reaction } from "mobx"
import { UniversalFinalizationRegistry } from "./UniversalFinalizationRegistry"

export const observerFinalizationRegistry = new UniversalFinalizationRegistry(
    (adm: { reaction: Reaction | null }) => {
        adm.reaction?.dispose()
        adm.reaction = null
    }
)



================================================
FILE: packages/mobx-react-lite/src/utils/printDebugValue.ts
================================================
import { getDependencyTree, Reaction } from "mobx"

export function printDebugValue(v: Reaction) {
    return getDependencyTree(v)
}



================================================
FILE: packages/mobx-react-lite/src/utils/reactBatchedUpdates.native.ts
================================================
// @ts-ignore
export { unstable_batchedUpdates } from "react-native"



================================================
FILE: packages/mobx-react-lite/src/utils/reactBatchedUpdates.ts
================================================
export { unstable_batchedUpdates } from "react-dom"



================================================
FILE: packages/mobx-react-lite/src/utils/UniversalFinalizationRegistry.ts
================================================
export declare class FinalizationRegistryType<T> {
    constructor(finalize: (value: T) => void)
    register(target: object, value: T, token?: object): void
    unregister(token: object): void
}

declare const FinalizationRegistry: typeof FinalizationRegistryType | undefined

export const REGISTRY_FINALIZE_AFTER = 10_000
export const REGISTRY_SWEEP_INTERVAL = 10_000

export class TimerBasedFinalizationRegistry<T> implements FinalizationRegistryType<T> {
    private registrations: Map<unknown, { value: T; registeredAt: number }> = new Map()
    private sweepTimeout: ReturnType<typeof setTimeout> | undefined

    constructor(private readonly finalize: (value: T) => void) {}

    // Token is actually required with this impl
    register(target: object, value: T, token?: object) {
        this.registrations.set(token, {
            value,
            registeredAt: Date.now()
        })
        this.scheduleSweep()
    }

    unregister(token: unknown) {
        this.registrations.delete(token)
    }

    // Bound so it can be used directly as setTimeout callback.
    sweep = (maxAge = REGISTRY_FINALIZE_AFTER) => {
        // cancel timeout so we can force sweep anytime
        clearTimeout(this.sweepTimeout)
        this.sweepTimeout = undefined

        const now = Date.now()
        this.registrations.forEach((registration, token) => {
            if (now - registration.registeredAt >= maxAge) {
                this.finalize(registration.value)
                this.registrations.delete(token)
            }
        })

        if (this.registrations.size > 0) {
            this.scheduleSweep()
        }
    }

    // Bound so it can be exported directly as clearTimers test utility.
    finalizeAllImmediately = () => {
        this.sweep(0)
    }

    private scheduleSweep() {
        if (this.sweepTimeout === undefined) {
            this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL)
        }
    }
}

export const UniversalFinalizationRegistry =
    typeof FinalizationRegistry !== "undefined"
        ? FinalizationRegistry
        : TimerBasedFinalizationRegistry



================================================
FILE: packages/mobx-react-lite/src/utils/utils.ts
================================================
const deprecatedMessages: string[] = []

export function useDeprecated(msg: string) {
    if (!deprecatedMessages.includes(msg)) {
        deprecatedMessages.push(msg)
        console.warn(msg)
    }
}



================================================
FILE: packages/mobx-undecorate/README.md
================================================
# mobx-undecorate

Update MobX 4/5 code to be conformant to MobX 6.

To run this codemod:

-   Go to your source files directory
-   Run `npx mobx-undecorate`

The following MobX 4/5 APIs will be converted to their MobX 6 equivalents:

-   `@computed`
-   `@action`
-   `@observable`
-   `@observer`
-   `@inject`
-   `decorate`

### Options

The following flags are accepted:

-   `--ignoreImports`: normally the codemod will only convert decorators if they are imported from a MobX package, using import statements like `import {observable} from "mobx"`. This flag ignores checking for imports statements and converts all `@computed`, `@action`, `@observable`, `@observer` and `@inject` calls.
-   `--keepDecorators`: don't rewrite decorators but keep them as they are, and generate the required `makeObservable` calls. Use this option if you intend to keep using decorators after updating to MobX 6.
-   `--decoratorsAfterExport`: set this flag only if you have `decoratorsBeforeExport: false` in your Babel configuration, otherwise you will get an error like: `SyntaxError: Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false`.
-   `--parseTsAsNonJsx`: parse ts file as non-jsx, and other file as same as before. see more details -> [mobxjs/mobx#issues2754](https://github.com/mobxjs/mobx/issues/2754)



================================================
FILE: packages/mobx-undecorate/CHANGELOG.md
================================================
# mobx-undecorate

## 1.3.0

### Minor Changes

-   [`c8f3b081`](https://github.com/mobxjs/mobx/commit/c8f3b0817fd74644e285909e2a40cea45a5cc013) [#3478](https://github.com/mobxjs/mobx/pull/3478) Thanks [@urugator](https://github.com/urugator)! - partial fix #3460: replace `action` with `override` if field uses override keyword

### Patch Changes

-   [`988aa3a1`](https://github.com/mobxjs/mobx/commit/988aa3a198f0e0fd33623cb21b33d75db6b2f70a) [#3617](https://github.com/mobxjs/mobx/pull/3617) Thanks [@urugator](https://github.com/urugator)! - fix: preserve non-null assertion operator on undecorated props

## 1.2.0

### Minor Changes

-   [`be5684b2`](https://github.com/mobxjs/mobx/commit/be5684b2421ab7c72bb9a2bdc2f40761e9c53c41) [#3164](https://github.com/mobxjs/mobx/pull/3164) Thanks [@Grsmto](https://github.com/Grsmto)! - add support for default export classes + fix eslint-plugin-react compatibility

## 1.1.1

### Patch Changes

-   [`6273bfb8`](https://github.com/mobxjs/mobx/commit/6273bfb8076347687010cbd046dc740f5744e691) [#3145](https://github.com/mobxjs/mobx/pull/3145) Thanks [@urugator](https://github.com/urugator)! - fix #3142 allow white spaces in cwd

## 1.1.0

### Minor Changes

-   [`737cc0bf`](https://github.com/mobxjs/mobx/commit/737cc0bf7ae787ec6c36e1550772a574f67e87d5) [#2818](https://github.com/mobxjs/mobx/pull/2818) Thanks [@jeremy-coleman](https://github.com/jeremy-coleman)! - modify cli to use system path for jscodeshift instead of relative path

## 1.0.7

### Patch Changes

-   [`c6b1c5d4`](https://github.com/mobxjs/mobx/commit/c6b1c5d4062c332cb09fcb6c64ec1d2dee69a7a2) [#2785](https://github.com/mobxjs/mobx/pull/2785) Thanks [@iChenLei](https://github.com/iChenLei)! - add parseTsAsNonJsx flag for mobx-undecorate

## 1.0.6

### Patch Changes

-   [`3f5087c0`](https://github.com/mobxjs/mobx/commit/3f5087c000cb92ef3c234af365db747e35487c10) [#2767](https://github.com/mobxjs/mobx/pull/2767) Thanks [@iChenLei](https://github.com/iChenLei)! - mobx-undecorate don't crash when node's loc is null

## 1.0.5

### Patch Changes

-   [`695108c3`](https://github.com/mobxjs/mobx/commit/695108c38d60a05cc9cef01b07e06109b1333017) [#2727](https://github.com/mobxjs/mobx/pull/2727) Thanks [@vkrol](https://github.com/vkrol)! - Do not create generic arguments if `keepDecorators` passed

## 1.0.4

### Patch Changes

-   [`88d3e886`](https://github.com/mobxjs/mobx/commit/88d3e88656ad0add08039ede42041102b895a95e) Thanks [@urugator](https://github.com/urugator)! - Fix [#2540](https://github.com/mobxjs/mobx/issues/2540) makeObservable not added to imports

*   [`88d3e886`](https://github.com/mobxjs/mobx/commit/88d3e88656ad0add08039ede42041102b895a95e) Thanks [@urugator](https://github.com/urugator)! - Fix [#2558](https://github.com/mobxjs/mobx/issues/2558) Undecorate removes non-mobx decorator

## 1.0.2

-   Fixed support for JSX



================================================
FILE: packages/mobx-undecorate/cli.js
================================================
#!/usr/bin/env node
const path = require("path")
const cp = require("child_process")
const fs = require("fs")

/**
 * @example getCommandPath("jscodeshift")
 * //-> C:\Users\name\AppData\Local\npm-cache\_npx\234242somehash\node_modules\.bin\jscodeshift.cmd
 * //-> linux/path/npm-cache/_npx/234242somehash/node_modules/.bin/jscodeshift
 */
const getCommandPath = binCommand => {
  const cmd = process.platform === 'win32' ? `${binCommand}.cmd` : binCommand;
  /**
   * Normally, for executing bins from a project you would use path.resolve(__dirname, 'node_modules', '.bin', cmd) 
   * but NPX is wierd. You might think running npx mobx-undecorate installs mobx-undecorate, BUT IT DOESNT. 
   * It creates a randomly hashed folder with an unnamed package.json with mobx-undecorate as its only dependency. 
   * This causes a flattening of all peers in the same node_modules dir.
   * They probably did it this way to dedupe nested deps.
   * 
   * This following logic checks for both folder structure and platform bin file extension.
  */
  let COMMAND_PATH_SIBLING = path.resolve(__dirname, '..', '.bin', cmd)
  let COMMAND_PATH_NESTED = path.resolve(__dirname, 'node_modules', '.bin', cmd)

  var COMMAND_PATH

  if (fs.existsSync(COMMAND_PATH_NESTED)) {
    COMMAND_PATH = COMMAND_PATH_NESTED
  }
  else if (fs.existsSync(COMMAND_PATH_SIBLING)) {
    COMMAND_PATH = COMMAND_PATH_SIBLING
  }
  else {
    throw new Error("cannot find jscodeshift path")
    process.exit(0)
  }
  return COMMAND_PATH

}

const spawnBin = (binCommand, args) => {
  return cp.spawn(getCommandPath(binCommand), args, {
    cwd: path.resolve(__dirname),
    stdio: 'inherit',
    shell: true
  })

}


if (process.argv.includes("--help")) {
  console.log(`[MOBX-UNDECORATE]:
  If experiencing problems, you may also install jscodeshift and mobx-undecorate locally and run 
  npx jscodeshift -t ./node_modules/mobx-undecorate/src/undecorate.ts --extensions=js,jsx,ts,tsx <directory>

[JSCODESHIFT HELP]:
`)
}


function interpret_cli_args() {

  //first 2 args of argv are the node.exe path and the path of this file.
  var USER_ARGS = process.argv.slice(2)

  /**
   * find args that dont include a "=" and set the input to the next index value in process.argv.
   * Gotta do this because process.argv is delimited by spaces, so --dir src is actually 2 separate args
   * so if an arg starts with -- and doesn't include a "=" 
   * we can just search for the arg by its --name and add 1 to the index position for lookup
   * This will return -1 if nothing is found
   */

  let arg_without_equal = USER_ARGS
    .slice()
    .filter(v => !v.includes("="))
    .findIndex(kwarg => (kwarg.includes("--dir") || kwarg.includes("--path")))
    ;

  var arg_with_equal = USER_ARGS
    .slice()
    .find(v => (v.includes("--dir=") || v.includes("--path=")))


  //use cwd as default, but will override it with user args if they exist for --dir or --path
  var PARSED_INPUT = ""

  let is_arg_directory_only = process.argv[2] && fs.existsSync(path.resolve(process.cwd(), (process.argv[2] || "")))

  if (is_arg_directory_only) {
    PARSED_INPUT = process.argv[2]
  }

  if (arg_without_equal > -1) {
    PARSED_INPUT = USER_ARGS[arg_without_equal + 1]
  }

  if (arg_with_equal) {
    PARSED_INPUT = arg_with_equal.split("=")[1]
  }

  return PARSED_INPUT

}


spawnBin("jscodeshift", [
  "--extensions=js,jsx,ts,tsx",
  ...process.argv.filter(arg => arg.startsWith("--")),
  "-t", `"${path.join(__dirname, "src", "undecorate.ts")}"`,

  //this is arg to tell jscodeshift the dir to transform or fallback to process.cwd()
  //originally just hard coded to process.cwd()
  `"${path.join(process.cwd(), interpret_cli_args())}"`

]);





================================================
FILE: packages/mobx-undecorate/jest.config.js
================================================
const buildConfig = require("../../jest.base.config")

module.exports = buildConfig(__dirname, {
    testRegex: "__tests__/.*\\.spec\\.(t|j)sx?$"
})



================================================
FILE: packages/mobx-undecorate/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 Michel Weststrate

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: packages/mobx-undecorate/package.json
================================================
{
    "name": "mobx-undecorate",
    "version": "1.3.0",
    "description": "Migrate MobX 4/5 to MobX 6",
    "bin": "cli.js",
    "repository": {
        "type": "git",
        "url": "https://github.com/mobxjs/mobx.git"
    },
    "author": "Michel Weststrate",
    "license": "MIT",
    "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mobx"
    },
    "bugs": {
        "url": "https://github.com/mobxjs/mobx/issues"
    },
    "files": [
        "cli.js",
        "src",
        "LICENSE",
        "README.md"
    ],
    "homepage": "https://mobx.js.org/",
    "dependencies": {
        "@babel/core": "^7.9.0",
        "@babel/parser": "^7.18.9",
        "@babel/plugin-proposal-class-properties": "^7.8.3",
        "@babel/plugin-proposal-decorators": "^7.8.3",
        "@babel/plugin-transform-runtime": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/runtime": "^7.9.2",
        "dedent-js": "^1.0.1",
        "jscodeshift": "^0.11.0"
    },
    "devDependencies": {
        "@types/jscodeshift": "^0.11.6"
    },
    "keywords": [
        "mobx"
    ],
    "scripts": {
        "test": "jest"
    }
}



================================================
FILE: packages/mobx-undecorate/tsconfig.json
================================================
{
    "extends": "../../tsconfig.json",
    "compilerOptions": {
        "rootDir": "src"
    },
    "include": ["src"]
}



================================================
FILE: packages/mobx-undecorate/__tests__/cli.spec.tsx
================================================
import { execSync } from "child_process"
import { join, dirname } from "path"
import { readFileSync, writeFileSync, mkdirSync } from "fs"
const dedent = require("dedent-js")

test("run cli #2506 #3142", () => {
    // #3142 - the white space must be in cwd
    const cwd = join(__dirname, "fixtures", "some path")
    const testFile = join(cwd, "some file.tsx")
    const baseContent = dedent(`import { observable } from "mobx";
    class Test {
        @observable x = 1;
    }
    `)
    mkdirSync(dirname(testFile), { recursive: true })
    writeFileSync(testFile, baseContent)
    execSync("node ../../../cli.js", { cwd })
    expect(readFileSync(testFile, "utf8")).toMatchInlineSnapshot(`
        "import { observable, makeObservable } from "mobx";
        class Test {
            x = 1;

            constructor() {
                makeObservable(this, {
                    x: observable
                });
            }
        }"
    `)
})

test("run cli with --parseTsAsNonJsx #2754", () => {
    const testNonJsxFile = join(__dirname, "fixtures", "some nonjsx", "some nonjsx.ts")
    const testJsxFile = join(__dirname, "fixtures", "some nonjsx", "some jsx.tsx")
    const nonJsxContent = dedent(`
        import { useSearch } from "./useSearch"
        import { observable } from "mobx"

        class Test {
            @observable x = 1
        }
        
        export function useAlias(): string {
            const parsedSearch = useSearch()
            return (<string>parsedSearch.alias || "").toUpperCase()
        }
    `)
    const jsxContent = dedent(`
        import React from 'react'
        import {observer} from 'mobx-react'
        
        @observer
        class X extends React.Component {
            render() {
                return <div>hi</div>
            }
        }
    `)

    mkdirSync(dirname(testNonJsxFile), { recursive: true })
    writeFileSync(testNonJsxFile, nonJsxContent)
    writeFileSync(testJsxFile, jsxContent)
    execSync("node ../../cli.js --parseTsAsNonJsx", {
        cwd: join(__dirname, "fixtures")
    })
    expect(readFileSync(testNonJsxFile, "utf8")).toMatchInlineSnapshot(`
        "import { useSearch } from "./useSearch"
        import { observable, makeObservable } from "mobx";

        class Test {
            x = 1;

            constructor() {
                makeObservable(this, {
                    x: observable
                });
            }
        }

        export function useAlias(): string {
            const parsedSearch = useSearch()
            return (<string>parsedSearch.alias || "").toUpperCase()
        }"
    `)
    expect(readFileSync(testJsxFile, "utf8")).toMatchInlineSnapshot(`
        "import React from 'react'
        import {observer} from 'mobx-react'

        const X = observer(class X extends React.Component {
            render() {
                return <div>hi</div>
            }
        });"
    `)
})



================================================
FILE: packages/mobx-undecorate/__tests__/tsconfig.json
================================================
{
    "extends": "../../../tsconfig.test.json"
}



================================================
FILE: packages/mobx-undecorate/__tests__/undecorate.spec.ts
================================================
import { applyTransform } from "jscodeshift/dist/testUtils"
const dedent = require("dedent-js")
import * as u from "../src/undecorate"

function convert(
    source: string,
    options: {
        ignoreImports?: boolean
        keepDecorators?: boolean
        decoratorsAfterExport?: boolean
    } = {}
): string {
    return applyTransform(u, options, { source: dedent(source), path: "unittest" }, {})
}

describe("general", () => {
    test("basic observable", () => {
        expect(
            convert(`import { observable } from "mobx"

  class Box {
      /*0*/
      @observable
      /*1*/
      field /*2 */ = /*3*/ 1 /*4*/
  }`)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

            class Box {
                /*0*/
                /*1*/
                field /*2 */ = /*3*/ 1; /*4*/

                constructor() {
                    makeObservable(this, {
                        field: observable
                    });
                }
            }"
        `)
    })

    test("basic observable - skip imports", () => {
        expect(
            convert(
                `
  class Box {
      /*0*/
      @observable
      /*1*/
      field /*2 */ = /*3*/ 1 /*4*/
  }`,
                { ignoreImports: true }
            )
        ).toMatchInlineSnapshot(`
            "class Box {
                /*0*/
                /*1*/
                field /*2 */ = /*3*/ 1; /*4*/

                constructor() {
                    makeObservable(this, {
                        field: observable
                    });
                }
            }"
        `)
    })

    test("basic observable - skip imports - keepDecorators", () => {
        expect(
            convert(
                `
  class Box {
      /*0*/
      @observable
      /*1*/
      field /*2 */ = /*3*/ 1 /*4*/
  }`,
                { ignoreImports: true, keepDecorators: true }
            )
        ).toMatchInlineSnapshot(`
            "class Box {
                /*0*/
                @observable
                /*1*/
                field /*2 */ = /*3*/ 1 /*4*/

                constructor() {
                    makeObservable(this);
                }
            }"
        `)
    })

    test("class with method and extends", () => {
        expect(
            convert(`
          import { observable } from "mobx"

          class ExtendsHasMethod extends Box {
              @observable x = 1

              // test
              method() {
                  console.log("hi")
              }
          }
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

            class ExtendsHasMethod extends Box {
                x = 1;

                constructor() {
                    // TODO: [mobx-undecorate] verify the constructor arguments and the arguments of this automatically generated super call
                    super();

                    makeObservable(this, {
                        x: observable
                    });
                }

                // test
                method() {
                    console.log("hi")
                }
            }"
        `)
    })

    test("class with constructor", () => {
        expect(
            convert(`
          import { observable } from "mobx"

          class ExtendsHasConstructor {
              @observable x = 1

              constructor() {
                  console.log("hi")
              }
          }`)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

            class ExtendsHasConstructor {
                x = 1;

                constructor() {
                    makeObservable(this, {
                        x: observable
                    });

                    console.log("hi")
                }
            }"
        `)
    })

    test("extended class with constructor", () => {
        expect(
            convert(`
          import { observable } from "mobx"

          class ExtendsHasConstructorSuper extends Box {
              @observable x = 1

              constructor() {
                  super()
                  console.log("hi")
              }
          }
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

            class ExtendsHasConstructorSuper extends Box {
                x = 1;

                constructor() {
                    super()

                    makeObservable(this, {
                        x: observable
                    });

                    console.log("hi")
                }
            }"
        `)
    })
})

describe("action", () => {
    test("field - bound - named", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action.bound("test")
                x = (arg: number) => {
                    console.log('hi')
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                x = (arg: number) => {
                    console.log('hi')
                };

                constructor() {
                    makeObservable(this, {
                        x: action.bound("test")
                    });
                }
            }"
        `)
    })

    test("method - bound - named", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action.bound("test")
                async x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: action.bound("test")
                    });
                }

                async x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - bound - named - generator", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action.bound("test")
                * x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: action.bound("test")
                    });
                }

                *x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("field - named", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action("test")
                x = async (arg: number): boolean => {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                x = async (arg: number): boolean => {
                    console.log('hi')
                    return true
                };

                constructor() {
                    makeObservable(this, {
                        x: action("test")
                    });
                }
            }"
        `)
    })

    test("field - unnamed", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action
                x = (arg: number): boolean => {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                x = (arg: number): boolean => {
                    console.log('hi')
                    return true
                };

                constructor() {
                    makeObservable(this, {
                        x: action
                    });
                }
            }"
        `)
    })

    test("method - bound - unnamed", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action.bound
                x (arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: action.bound
                    });
                }

                x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - unbound - named", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action("test")
                x (arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: action("test")
                    });
                }

                x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - unbound - unnamed", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action
                x (arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: action
                    });
                }

                x(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - unbound - computed name", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box {
                @action
                ['x' + 'y'](arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        ['x' + 'y']: action
                    });
                }

                ['x' + 'y'](arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - override", () => {
        expect(
            convert(`
            import { action } from "mobx"

            class Box extends Shape {
                constructor(arg) {
                    super(arg)
                }

                @action
                override method(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { action, override, makeObservable } from "mobx";

            class Box extends Shape {
                constructor(arg) {
                    super(arg)

                    makeObservable(this, {
                        method: override
                    });
                }

                override method(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })

    test("method - override - keepDecorators", () => {
        expect(
            convert(
                `
            import { action } from "mobx"

            class Box extends Shape {
                constructor(arg) {
                    super(arg)
                }

                @action
                override method(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }
            `,
                { keepDecorators: true }
            )
        ).toMatchInlineSnapshot(`
            "import { action, override, makeObservable } from "mobx";

            class Box extends Shape {
                constructor(arg) {
                    super(arg)
                    makeObservable(this);
                }

                @override
                override method(arg: number): boolean {
                    console.log('hi')
                    return true
                }
            }"
        `)
    })
})

describe("observable", () => {
    test("observable ", () => {
        expect(
            convert(`
      import { observable } from "mobx"

      class Box {
          @observable x = 1
      }
    `)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

            class Box {
                x = 1;

                constructor() {
                    makeObservable(this, {
                        x: observable
                    });
                }
            }"
        `)
    })

    test("observable - shallow ", () => {
        expect(
            convert(`
          import { observable } from "mobx"

          class Box {
            @observable.shallow x = 1
        }
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

              class Box {
                x = 1;

                constructor() {
                  makeObservable(this, {
                    x: observable.shallow
                  });
                }
              }"
        `)
    })

    test("observable - shallow - computed name ", () => {
        expect(
            convert(`
              import { observable } from "mobx"

              class Box {
                @observable.shallow ['x'] = 1
            }
            `)
        ).toMatchInlineSnapshot(`
            "import { observable, makeObservable } from "mobx";

              class Box {
                ['x'] = 1;

                constructor() {
                  makeObservable(this, {
                    ["x"]: observable.shallow
                  });
                }
              }"
        `)
    })
})

describe("computed", () => {
    test("computed ", () => {
        expect(
            convert(`
      import { computed } from "mobx"

      class Box {
          @computed get x() {
              return 1;
          }
      }
    `)
        ).toMatchInlineSnapshot(`
            "import { computed, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: computed
                    });
                }

                get x() {
                    return 1;
                }
            }"
        `)
    })

    test("computed - setter", () => {
        expect(
            convert(`
      import { computed } from "mobx"

      class Box {
          @computed get x() {
              return 1;
          }
          set x(v) {
              console.log(v)
          }
      }
    `)
        ).toMatchInlineSnapshot(`
            "import { computed, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: computed
                    });
                }

                get x() {
                    return 1;
                }
                set x(v) {
                    console.log(v)
                }
            }"
        `)
    })

    test("computed - setter - options", () => {
        expect(
            convert(`
      import { computed } from "mobx"

      class Box {
          @computed({ name: "test" }) get x() {
              return 1;
          }
          set y(z) {
              console.log("wrong");
          }
          set x(v) {
              console.log(v)
          }
      }
    `)
        ).toMatchInlineSnapshot(`
            "import { computed, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: computed({ name: "test" })
                    });
                }

                get x() {
                    return 1;
                }
                set y(z) {
                    console.log("wrong");
                }
                set x(v) {
                    console.log(v)
                }
            }"
        `)
    })

    test("computed - setter - struct", () => {
        expect(
            convert(`
      import { computed } from "mobx"

      class Box {
          @computed.struct get x() {
              return 1;
          }
          set x(v) {
              console.log(v)
          }
      }
    `)
        ).toMatchInlineSnapshot(`
            "import { computed, makeObservable } from "mobx";

            class Box {
                constructor() {
                    makeObservable(this, {
                        x: computed.struct
                    });
                }

                get x() {
                    return 1;
                }
                set x(v) {
                    console.log(v)
                }
            }"
        `)
    })
})

describe("decorate", () => {
    test("basic", () => {
        expect(
            convert(`
            import { observable, decorate, computed, action } from "mobx"

            class Box {
                width = 3
                height = 2

                // gets the size of the thing
                get size() {
                    return this.width * this.height
                }

                // make it twice as large
                double() {
                    this.width *= 2;
                }
            }

            decorate(Box, {
                width: observable,
                height: observable.shallow,
                size: computed,
                double: action
            })
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            class Box {
                width = 3
                height = 2

                constructor() {
                    makeObservable(this, {
                        width: observable,
                        height: observable.shallow,
                        size: computed,
                        double: action
                    });
                }

                // gets the size of the thing
                get size() {
                    return this.width * this.height
                }

                // make it twice as large
                double() {
                    this.width *= 2;
                }
            }"
        `)
    })

    test("multiple targets", () => {
        expect(
            convert(`
            import { observable, decorate, computed, action } from "mobx"

            test("a", () => {
                class Box {
                    width = 3
                }

                decorate(Box, {
                    width: observable,
                })
            })

            test("b", () => {
                class Box {
                    method() {}
                }

                decorate(Box, {
                    method: action
                })
            })
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            test("a", () => {
                class Box {
                    width = 3

                    constructor() {
                        makeObservable(this, {
                            width: observable,
                        });
                    }
                }
            })

            test("b", () => {
                class Box {
                    constructor() {
                        makeObservable(this, {
                            method: action
                        });
                    }

                    method() {}
                }
            })"
        `)
    })

    test("handle undeclared observable members", () => {
        expect(
            convert(`
            import { observable, decorate, computed, action } from "mobx"

            class Box {

            }

            decorate(Box, {
                // stuff
                width: observable,
                height: observable.shallow,
            })
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            class Box {
                constructor() {
                    makeObservable(this, {
                        // stuff
                        width: observable,
                        height: observable.shallow,
                    });
                }
            }"
        `)
    })

    test("handle non-classes - 1", () => {
        expect(
            convert(`
            import { observable, decorate, computed, action } from "mobx"

            const box = {

            }

            decorate(box, {
                width: observable,
                height: observable.shallow,
            })
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            const box = {

            }

            makeObservable(box, {
                width: observable,
                height: observable.shallow,
            })"
        `)
    })

    test("handle non-classes - 2", () => {
        expect(
            convert(`
            import { observable, decorate, computed, action } from "mobx"

            decorate({}, {
                width: observable,
                height: observable.shallow,
            })
        `)
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            makeObservable({}, {
                width: observable,
                height: observable.shallow,
            })"
        `)
    })
})

describe("privates", () => {
    test("create generic arguments for makeObservable", () => {
        expect(
            convert(
                `
                import { observable, decorate, computed, action } from "mobx"
    
    class TryToGetThis {
        @observable
        private privateField1: number = 1
        @observable
        protected privateField2 = 1
        @observable
        public publicField: string = "test"
      }
                `
            )
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            class TryToGetThis {
                        private privateField1: number = 1;
                        protected privateField2 = 1;
                        public publicField: string = "test";

                        constructor() {
                                    makeObservable<TryToGetThis, "privateField1" | "privateField2">(this, {
                                                privateField1: observable,
                                                privateField2: observable,
                                                publicField: observable
                                    });
                        }
            }"
        `)
    })

    test("do not create generic arguments for makeObservable - keepDecorators", () => {
        expect(
            convert(
                `
                import { observable, decorate, computed, action } from "mobx"
    
    class TryToGetThis {
        @observable
        private privateField1: number = 1
        @observable
        protected privateField2 = 1
        @observable
        public publicField: string = "test"
      }
                `,
                {
                    keepDecorators: true
                }
            )
        ).toMatchInlineSnapshot(`
            "import { observable, computed, action, makeObservable } from "mobx"

            class TryToGetThis {
                        @observable
                        private privateField1: number = 1
                        @observable
                        protected privateField2 = 1
                        @observable
                        public publicField: string = "test"

                        constructor() {
                                    makeObservable(this);
                        }
            }"
        `)
    })
})

describe("@observer", () => {
    test("class comp", () => {
        expect(
            convert(`
        import {observer} from 'mobx-react'

        /* 1 */
        @observer /* 2 */ class X extends React.Component {
            render() {
                return <div>hi</div>
            }
        }

        `)
        ).toMatchInlineSnapshot(`
            "import {observer} from 'mobx-react'

            /* 1 */
            const X = observer(class /* 2 */ X extends React.Component {
                render() {
                    return <div>hi</div>
                }
            });"
        `)
    })

    test("class comp with export before", () => {
        expect(
            convert(`
        import {observer} from 'mobx-react-lite'


        /* 1 */
        @observer /* 2 */ export /* 3 */ class X extends React.Component {

        }

        `)
        ).toMatchInlineSnapshot(`
            "import {observer} from 'mobx-react-lite'


            /* 1 */
            export const X = observer(class /* 2 */ /* 3 */ X extends React.Component {

            });"
        `)
    })

    test("class comp with export after", () => {
        expect(
            convert(
                `
        import {observer} from 'mobx-react-lite'


        /* 1 */
        export /* 2 */ @observer /* 3 */ class X extends React.Component {

        }

        `,
                { decoratorsAfterExport: true }
            )
        ).toMatchInlineSnapshot(`
            "import {observer} from 'mobx-react-lite'


            /* 1 */
            export const X = observer(class /* 2 */ /* 3 */ X extends React.Component {

            });"
        `)
    })

    test("class comp with inject", () => {
        expect(
            convert(`
        import {observer, inject} from 'mobx-react'


        /* 1 */
        @inject("test") /* 2 */ export /* 3 */ class X extends React.Component {

        }

        `)
        ).toMatchInlineSnapshot(`
            "import {observer, inject} from 'mobx-react'


            /* 1 */
            export const X = inject("test")(class /* 2 */ /* 3 */ X extends React.Component {

            });"
        `)
    })

    test("class comp with inject and observer", () => {
        expect(
            convert(`
        import {observer, inject} from 'mobx-react'


        /* 1 */
        @inject("test") @observer /* 2 */ export /* 3 */ class X extends React.Component {

        }

        `)
        ).toMatchInlineSnapshot(`
            "import {observer, inject} from 'mobx-react'


            /* 1 */
            export const X = inject("test")(observer(class /* 2 */ /* 3 */ X extends React.Component {

            }));"
        `)
    })

    test("class comp with local fields - 1", () => {
        expect(
            convert(
                `
        import {observer, inject} from 'mobx-react'
        import {observable} from "mobx"
        import {Component} from "react"

        @observer class X extends React.Component {
            @observable field =  1
        }

        `,
                { keepDecorators: false }
            )
        ).toMatchInlineSnapshot(`
            "import {observer, inject} from 'mobx-react'
            import { observable, makeObservable } from "mobx";
            import {Component} from "react"

            const X = observer(class X extends React.Component {
                field = 1;

                constructor(props) {
                    super(props);

                    makeObservable(this, {
                        field: observable
                    });
                }
            });"
        `)
    })

    test("class comp with local fields preserves Props generic", () => {
        expect(
            convert(
                `
        import {observer, inject} from 'mobx-react'
        import {observable} from "mobx"
        import {PureComponent} from "react"

        @observer class X extends PureComponent<{x: boolean}> {
            @observable field =  1
        }

        `,
                { keepDecorators: false }
            )
        ).toMatchInlineSnapshot(`
            "import {observer, inject} from 'mobx-react'
            import { observable, makeObservable } from "mobx";
            import {PureComponent} from "react"

            const X = observer(class X extends PureComponent<{x: boolean}> {
                field = 1;

                constructor(props: {x: boolean}) {
                    super(props);

                    makeObservable(this, {
                        field: observable
                    });
                }
            });"
        `)
    })

    test("class comp with local fields preserves Props generic", () => {
        expect(
            convert(
                `
        import {observer, inject} from 'mobx-react'
        import {observable} from "mobx"
        import {PureComponent} from "react"

        @observer class X extends PureComponent<{x: boolean}> {
            @observable field =  1
        }

        `,
                { keepDecorators: true }
            )
        ).toMatchInlineSnapshot(`
            "import {observer, inject} from 'mobx-react'
            import { observable, makeObservable } from "mobx";
            import {PureComponent} from "react"

            @observer class X extends PureComponent<{x: boolean}> {
                @observable field =  1

                constructor(props: {x: boolean}) {
                    super(props);
                    makeObservable(this);
                }
            }"
        `)
    })

    test("makeObservable gets added to the non-type import #2415", () => {
        expect(
            convert(
                `
        import type { IReactionDisposer } from 'mobx';
        import { reaction, observable } from 'mobx';

        export default class Store {
            @observable counter = 0;

            removeReaction: IReactionDisposer;

            constructor() {
                this.removeReaction = reaction(() => this.counter, () => {
                    console.log('it changed');
                });
            }

            cleanup() {
                this.removeReaction();
            }
        }
        `
            )
        ).toMatchInlineSnapshot(`
            "import type { IReactionDisposer } from 'mobx';
            import { reaction, observable, makeObservable } from 'mobx';

            export default class Store {
                counter = 0;

                removeReaction: IReactionDisposer;

                constructor() {
                    makeObservable(this, {
                        counter: observable
                    });

                    this.removeReaction = reaction(() => this.counter, () => {
                        console.log('it changed');
                    });
                }

                cleanup() {
                    this.removeReaction();
                }
            }"
        `)
    })
})

test("weird syntaxes", () => {
    expect(
        convert(`
        import { observable } from 'mobx';

        type NamedTuple = [first: string, other: number, ...rest: Boolean[]]

        class X {
            @observable x = 3;
        }

        class Y {
            async fn() { await tes() }

            *generatorFn() {
                yield 3
            }

            doesJSX() {
                return <hi {...there}>Stuff {/*with comments */}</hi>
            }
        }
        `)
    ).toMatchInlineSnapshot(`
        "import { observable, makeObservable } from 'mobx';

        type NamedTuple = [first: string, other: number, ...rest: Boolean[]]

        class X {
            x = 3;

            constructor() {
                makeObservable(this, {
                    x: observable
                });
            }
        }

        class Y {
            async fn() { await tes() }

            *generatorFn() {
                yield 3
            }

            doesJSX() {
                return <hi {...there}>Stuff {/*with comments */}</hi>
            }
        }"
    `)
})

test("class comp with observer and decorator from another package", () => {
    expect(
        convert(`
    import {observer} from 'mobx-react'
    import {withRouter} from 'react-router-dom'
    /* 1 */
    @withRouter @observer /* 2 */ export /* 3 */ class X extends React.Component {}
    `)
    ).toMatchInlineSnapshot(`
        "import {observer} from 'mobx-react'
        import {withRouter} from 'react-router-dom'
        /* 1 */
        export const X = withRouter(observer(class /* 2 */ /* 3 */ X extends React.Component {}));"
    `)
})

test("class comp with observer, inject and decorator from another package", () => {
    expect(
        convert(`
    import {observer, inject} from 'mobx-react'
    import {withRouter} from 'react-router-dom'
    /* 1 */
    @withRouter @inject("test") @observer /* 2 */ export /* 3 */ class X extends React.Component {}
    `)
    ).toMatchInlineSnapshot(`
        "import {observer, inject} from 'mobx-react'
        import {withRouter} from 'react-router-dom'
        /* 1 */
        export const X = withRouter(
          inject("test")(observer(class /* 2 */ /* 3 */ X extends React.Component {}))
        );"
    `)
})

test("makeObservable not added to imports #2540", () => {
    expect(
        convert(`
        import { decorate, observable, action } from 'mobx';
        class TestStore
        {
            testValue = 1;
            testFunc = () =>
            {
                this.testValue++;
            }
        }
        decorate(TestStore, {
            testValue: observable,
            testFunc: action
        });
        `)
    ).toMatchInlineSnapshot(`
        "import { observable, action, makeObservable } from 'mobx';
        class TestStore
        {
            testValue = 1;
            testFunc = () =>
            {
                this.testValue++;
            }

            constructor() {
                makeObservable(this, {
                    testValue: observable,
                    testFunc: action
                });
            }
        }"
    `)
})

test("class default export comp with observer and inject", () => {
    expect(
        convert(`
        import {observer, inject} from 'mobx-react'
        
        @inject("test") @observer export default class X extends React.Component {}
    `)
    ).toMatchInlineSnapshot(`
        "import {observer, inject} from 'mobx-react'

        class X extends React.Component {}
        export default inject("test")(observer(X));"
    `)
})

test("class default export comp with observer and inject", () => {
    expect(
        convert(`
        import {observer, inject} from 'mobx-react'
        import {withRouter} from 'react-router-dom'

        @inject("test") @observer class X extends React.Component {}

        export default withRouter(X)

    `)
    ).toMatchInlineSnapshot(`
        "import {observer, inject} from 'mobx-react'
        import {withRouter} from 'react-router-dom'

        class X extends React.Component {}

        export default withRouter(inject("test")(observer(X)))"
    `)
})

test("non-null assertion operator is preserved", () => {
    expect(
        convert(`
        import { observable } from 'mobx';
        class X {
          @observable todos!: ObservableMap<string, TodoModel>
        }
    `)
    ).toMatchInlineSnapshot(`
        "import { observable, makeObservable } from 'mobx';
        class X {
          todos!: ObservableMap<string, TodoModel>;

          constructor() {
            makeObservable(this, {
              todos: observable
            });
          }
        }"
    `)
})



================================================
FILE: packages/mobx-undecorate/src/undecorate.ts
================================================
import {
    API,
    FileInfo,
    Decorator,
    ASTPath,
    ClassProperty,
    Node,
    ClassDeclaration,
    ClassMethod,
    ObjectExpression,
    Identifier
} from "jscodeshift"

interface MobxUndecorateOptions {
    ignoreImports?: boolean
    keepDecorators?: boolean
    decoratorsAfterExport?: boolean
    parseTsAsNonJsx?: boolean
}

const validPackages = ["mobx", "mobx-react", "mobx-react-lite"]
const validDecorators = ["action", "observable", "computed", "observer", "inject"]

const babylon = require("@babel/parser")

const defaultOptions = {
    sourceType: "module",
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    startLine: 1,
    tokens: true,
    plugins: [
        // "estree",
        ["decorators", { decoratorsBeforeExport: true }],
        "asyncGenerators",
        "bigInt",
        "classProperties",
        "classPrivateProperties",
        "classPrivateMethods",
        "legacy-decorators",
        "doExpressions",
        "dynamicImport",
        "exportDefaultFrom",
        "exportNamespaceFrom",
        "functionBind",
        "functionSent",
        "importMeta",
        "logicalAssignment",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        ["pipelineOperator", { proposal: "minimal" }],
        "throwExpressions",
        "typescript",
        "jsx"
    ]
}

let decoratorsBeforeExport = true // hack to get the options into the parser

const safeRemoveJsxPlugin = () => {
    const jsxPluginIdx = defaultOptions.plugins.findIndex(plugin => plugin === "jsx")
    jsxPluginIdx !== -1 && defaultOptions.plugins.splice(jsxPluginIdx, 1)
}

const safeAddJsxPlugin = () => {
    const jsxPluginIdx = defaultOptions.plugins.findIndex(plugin => plugin === "jsx")
    jsxPluginIdx === -1 && defaultOptions.plugins.push("jsx")
}

const checkParseTsAsNonJsxFlag = (fileInfo: FileInfo, options?: MobxUndecorateOptions) => {
    if (options?.parseTsAsNonJsx && fileInfo?.path?.endsWith("ts")) {
        safeRemoveJsxPlugin()
    } else {
        safeAddJsxPlugin()
    }
}

export const parser = {
    parse(code) {
        return babylon.parse(code, defaultOptions)
    }
}

export default function transform(
    fileInfo: FileInfo,
    api: API,
    options?: MobxUndecorateOptions
): any {
    /**
     * @summary for decoratorsBeforeExport flag
     */
    decoratorsBeforeExport = !options?.decoratorsAfterExport
    // @ts-ignore
    defaultOptions.plugins[0][1].decoratorsBeforeExport = !!decoratorsBeforeExport
    /**
     * @summary for parseTsAsNonJsx flag
     */
    if (options?.parseTsAsNonJsx) {
        checkParseTsAsNonJsxFlag(fileInfo, options)
    }

    const j = api.jscodeshift
    const superCall = j.expressionStatement(j.callExpression(j.super(), []))
    superCall.comments = [
        j.commentLine(
            " TODO: [mobx-undecorate] verify the constructor arguments and the arguments of this automatically generated super call"
        )
    ]
    const reactSuperCall = j.expressionStatement(
        j.callExpression(j.super(), [j.identifier("props")])
    )
    const source = j(fileInfo.source)
    const lines = fileInfo.source.split("\n")
    let changed = false
    let needsInitializeImport = false
    let importOverride = false
    const decoratorsUsed = new Set<string>(options?.ignoreImports ? validDecorators : [])
    let usesDecorate = options?.ignoreImports ? true : false
    let hasReact = options?.ignoreImports ? true : false

    // error TS2321: Excessive stack depth comparing types 'ArrayType<ImportDeclaration>' and 'ArrayType<T>'
    // @ts-ignore
    source.find(j.ImportDeclaration).forEach(im => {
        if (im.value.source.value === "react") {
            hasReact = true
        }
        if (validPackages.includes(im.value.source.value as string)) {
            let decorateIndex = -1
            im.value.specifiers?.forEach((specifier, idx) => {
                // imported decorator
                if (
                    j.ImportSpecifier.check(specifier) &&
                    typeof specifier.imported.name === "string" && // dunno what IdentifierKind is
                    validDecorators.includes(specifier.imported.name)
                ) {
                    decoratorsUsed.add(specifier.imported.name)
                }
                // imported decorate call
                if (j.ImportSpecifier.check(specifier) && specifier.imported.name === "decorate") {
                    usesDecorate = true
                    decorateIndex = idx
                }
            })
            if (decorateIndex !== -1) {
                im.value.specifiers?.splice(decorateIndex, 1)
            }
        }
    })

    // rewrite all decorate calls to class decorators
    if (usesDecorate) {
        source
            .find(j.CallExpression)
            .filter(
                callPath =>
                    j.Identifier.check(callPath.value.callee) &&
                    callPath.value.callee.name === "decorate"
            )
            .forEach(callPath => {
                let canRemoveDecorateCall = true
                if (callPath.value.arguments.length !== 2) {
                    warn("Expected a decorate call with two arguments", callPath.value)
                    return
                }
                const target = callPath.value.arguments[0]
                const decorators = callPath.value.arguments[1]

                if (!j.Identifier.check(target)) {
                    // not targeting a class, just swap it with makeObservable
                    changed = true
                    // @ts-ignore // TODO: or "observable" ?
                    callPath.value.callee.name = "makeObservable"
                    needsInitializeImport = true
                    return
                }
                const declarations = callPath.scope.getBindings()[target.name]
                if (declarations.length === 0) {
                    warn(
                        `Expected exactly one class declaration for '${target.name}' but found ${declarations.length}`,
                        target
                    )
                    return
                }
                const targetDeclaration = declarations[0].parentPath.value
                if (!j.ClassDeclaration.check(targetDeclaration)) {
                    // not targeting a class, just swap it with makeObservable
                    changed = true
                    // @ts-ignore // TODO: or "observable" ?
                    callPath.value.callee.name = "makeObservable"
                    needsInitializeImport = true
                    return
                }
                const clazz: ClassDeclaration = targetDeclaration
                // @ts-ignore
                createConstructor(clazz, decorators, [])
                needsInitializeImport = true

                // Remove the callPath (and wrapping expressionStatement)
                if (canRemoveDecorateCall) {
                    callPath.parent.prune()
                }
                changed = true
            })
    }

    // rewrite all class proprty decorators
    source.find(j.ClassDeclaration).forEach(clazzPath => {
        const clazz = clazzPath.value
        const effects = {
            membersMap: [] as any
        }

        clazz.body.body = clazz.body.body.map(prop => {
            if (j.ClassProperty.check(prop) || j.ClassMethod.check(prop)) {
                return handleProperty(prop as any, effects, clazzPath)
            }
            return prop
        })

        if (effects.membersMap.length) {
            changed = true
            let privates: string[] = []
            const members = j.objectExpression(
                effects.membersMap.map(([key, value, computed, isPrivate]) => {
                    // loose the comments, as they are already in the field definition
                    const { comments, ...k } = key
                    const { comments: comments2, ...v } = value
                    const prop = j.objectProperty(k, v)
                    if (v.name === "override") {
                        importOverride = true
                    }
                    prop.computed = !!computed
                    if (isPrivate) {
                        privates.push(k.name)
                    }
                    return prop
                })
            )
            createConstructor(clazz, members, privates)
            needsInitializeImport = true
        }

        // rewrite all @observer / @inject
        if (!options?.keepDecorators && decoratorsUsed.has("observer")) {
            handleObserverAndInject(clazzPath)
        }
    })

    if (needsInitializeImport && !options?.ignoreImports) {
        // @ts-ignore
        const mobxImport = source
            .find(j.ImportDeclaration)
            .filter(im => im.value.source.value === "mobx")
            .nodes()
            .filter(node => node.importKind === "value")[0]
        if (!mobxImport) {
            console.warn(
                "Failed to find mobx import, can't add makeObservable as dependency in " +
                    fileInfo.path
            )
        } else {
            if (!mobxImport.specifiers) {
                mobxImport.specifiers = []
            }
            if (importOverride) {
                mobxImport.specifiers.push(j.importSpecifier(j.identifier("override")))
            }
            mobxImport.specifiers.push(j.importSpecifier(j.identifier("makeObservable")))
        }
    }
    if (!decoratorsUsed.size && !usesDecorate) {
        return // no mobx in this file
    }
    if (changed) {
        return source.toSource()
    }

    function handleObserverAndInject(clazzPath: ASTPath<ClassDeclaration>) {
        const clazz = clazzPath.value
        const decorators = (clazz as any).decorators ?? []
        const defaultExportPath = source.find(j.ExportDefaultDeclaration).paths()[0]

        const isObserver = dec =>
            j.Decorator.check(dec) &&
            j.Identifier.check(dec.expression) &&
            dec.expression.name === "observer"

        const isInject = dec =>
            j.Decorator.check(dec) &&
            j.CallExpression.check(dec.expression) &&
            j.Identifier.check(dec.expression.callee) &&
            dec.expression.callee.name === "inject"

        const hasObserverOrInject = decorators.some(dec => isObserver(dec) || isInject(dec))
        if (!hasObserverOrInject) {
            return
        }

        // If module uses default export
        if (defaultExportPath && clazz.id) {
            // If class is exported directly on the class declaration (`export default class ...`)
            if (j.ClassDeclaration.check(defaultExportPath.node.declaration)) {
                let newDefaultExportDefExpr = j.exportDefaultSpecifier(clazz.id)

                newDefaultExportDefExpr.exported = decorators.reduceRight(
                    (newDefaultExportId, dec) => {
                        return j.callExpression(dec.expression, [newDefaultExportId])
                    },
                    newDefaultExportDefExpr.exported
                )

                const exportDecl = j.exportDefaultDeclaration(newDefaultExportDefExpr.exported)

                // re-create the class
                const newClassDefExpr = j.classExpression(clazz.id, clazz.body, clazz.superClass)
                newClassDefExpr.superTypeParameters = clazz.superTypeParameters
                newClassDefExpr.typeParameters = clazz.typeParameters
                newClassDefExpr.implements = clazz.implements

                const newClassDefDecl = j.classDeclaration(
                    newClassDefExpr.id ?? null,
                    newClassDefExpr.body,
                    newClassDefExpr.superClass
                )

                // Insert module default export after class declaration
                defaultExportPath.insertAfter(exportDecl)
                // Replace old class with new class
                defaultExportPath.replace(newClassDefDecl)

                changed = true
            } else {
                const newDefaultExportDefExpr = j.exportDefaultSpecifier(clazz.id!)
                const decorators = (clazz as any).decorators ?? []
                const newClassExport = decorators.reduceRight((newDefaultExportId, dec) => {
                    return j.callExpression(dec.expression, [newDefaultExportId])
                }, newDefaultExportDefExpr.exported)

                source
                    .find(j.ExportDefaultDeclaration)
                    .find(j.Identifier, (value: Identifier) => value.name === clazz.id!.name)
                    .replaceWith(newClassExport)

                const newDecorators = decorators.some(dec => !isObserver(dec) && !isInject(dec))

                ;(clazz as any).decorators = newDecorators

                changed = true
            }
        } else {
            // re-create the class
            let newClassDefExpr: any = j.classExpression(clazz.id, clazz.body, clazz.superClass)
            newClassDefExpr.superTypeParameters = clazz.superTypeParameters
            newClassDefExpr.typeParameters = clazz.typeParameters
            newClassDefExpr.implements = clazz.implements
            // wrap with decorators
            newClassDefExpr = decorators.reduceRight((newClassDefExpr, dec) => {
                return j.callExpression(dec.expression, [newClassDefExpr])
            }, newClassDefExpr)

            const decl = j.variableDeclaration("const", [
                j.variableDeclarator(j.identifier(clazz.id!.name.toString()), newClassDefExpr)
            ])
            decl.comments = clazz.comments
            clazzPath.replace(decl)

            changed = true
        }
    }

    function handleProperty(
        property: ClassProperty & /* | or ClassMethod */ {
            decorators: Decorator[]
            accessibility: "private" | "protected" | "public"
        },
        effects: {
            membersMap: [[any, any, boolean, boolean]]
        },
        clazzPath: ASTPath<ClassDeclaration>
    ): ClassProperty | ClassMethod {
        const decorators = property.decorators
        if (!decorators || decorators.length === 0) {
            return property
        }
        if (decorators.length > 1) {
            warn("Found multiple decorators, skipping..", property.decorators[0])
            return property
        }
        const decorator = decorators[0]
        if (!j.Decorator.check(decorator)) {
            return property
        }
        let expr = decorator.expression
        if (j.Identifier.check(expr) && !decoratorsUsed.has(expr.name)) {
            warn(`Found non-mobx decorator @${expr.name}`, decorator)
            return property
        }
        if (property.static) {
            warn(`Static properties are not supported ${property.key.loc?.source}`, property)
            return property
        }

        if (options?.keepDecorators !== true) {
            property.decorators.splice(0)
        }

        // Replace decorator with @override
        if ((property as any).override) {
            const overrideDecorator = j.decorator(j.identifier("override"))
            if (options?.keepDecorators) {
                property.decorators[0] = overrideDecorator
            }
            expr = overrideDecorator.expression
        }

        effects.membersMap.push([
            property.key,
            expr,
            property.computed ?? false,
            property.accessibility === "private" || property.accessibility === "protected"
        ])
        return property
    }

    function createConstructor(
        clazz: ClassDeclaration,
        members: ObjectExpression,
        privates: string[]
    ) {
        // makeObservable(this, { members })
        const initializeObservablesCall = j.expressionStatement(
            j.callExpression(
                j.identifier("makeObservable"),
                options?.keepDecorators ? [j.thisExpression()] : [j.thisExpression(), members]
            )
        )
        if (privates.length && !options?.keepDecorators) {
            if (typeof clazz.id!.name !== "string") {
                throw new Error("Unexpected type")
            }
            // @ts-ignore
            initializeObservablesCall.expression.typeArguments = j.tsTypeParameterInstantiation([
                j.tsTypeReference(j.identifier(clazz.id!.name)),
                j.tsUnionType(
                    // @ts-ignore
                    privates.map(member => j.tsLiteralType(j.stringLiteral(member)))
                )
            ])
        }

        const needsSuper = !!clazz.superClass
        let constructorIndex = clazz.body.body.findIndex(
            member => j.ClassMethod.check(member) && member.kind === "constructor"
        )

        // create a constructor
        if (constructorIndex === -1) {
            if (needsSuper) {
                warn(
                    `Generated new constructor for class ${clazz.id?.name}. But since the class does have a base class, it might be needed to revisit the arguments that are passed to \`super()\``,
                    clazz
                )
            }

            let superClassName = j.Identifier.check(clazz.superClass)
                ? clazz.superClass.name
                : j.MemberExpression.check(clazz.superClass)
                ? j.Identifier.check(clazz.superClass.property)
                    ? clazz.superClass.property.name
                    : ""
                : ""

            // if this clazz is a react component, we now that the constructor and super call have one argument, the props
            let isReactComponent =
                hasReact && ["Component", "PureComponent"].includes(superClassName)
            let propsType = isReactComponent && clazz.superTypeParameters?.params[0]
            const propsParam = j.identifier("props")
            // reuse the generic if we found it
            if (propsType) {
                propsParam.typeAnnotation = j.tsTypeAnnotation(propsType as any)
            }
            // create the constructor
            const constructorDecl = j.methodDefinition(
                "constructor",
                j.identifier("constructor"),
                j.functionExpression(
                    null,
                    isReactComponent ? [propsParam] : [],
                    j.blockStatement(
                        needsSuper
                            ? [
                                  isReactComponent ? reactSuperCall : superCall,
                                  initializeObservablesCall
                              ]
                            : [initializeObservablesCall]
                    )
                )
            )

            const firstMethodIndex = clazz.body.body.findIndex(member =>
                j.ClassMethod.check(member)
            )
            if (firstMethodIndex === -1) {
                clazz.body.body.push(constructorDecl)
            } else {
                clazz.body.body.splice(firstMethodIndex, 0, constructorDecl)
            }
        } else {
            const c: ClassMethod = clazz.body.body[constructorIndex] as any
            j.ClassMethod.assert(c)
            const firstStatement = c.body.body[0]
            const hasSuper =
                firstStatement &&
                j.ExpressionStatement.check(firstStatement) &&
                j.CallExpression.check(firstStatement.expression) &&
                j.Super.check(firstStatement.expression.callee)
            c.body.body.splice(hasSuper ? 1 : 0, 0, initializeObservablesCall)
        }
    }

    function warn(msg: string, node: Node) {
        if (process.env.NODE_ENV === "test") {
            return
        }
        if (node.loc) {
            const line = lines[node.loc.start.line - 1]
            const shortline = line.replace(/^\s*/, "")
            console.warn(
                `[mobx:undecorate] ${msg} at (${fileInfo.path}:${node.loc.start.line}:${
                    node.loc.start.column
                }):\n\t${shortline}\n\t${"^".padStart(
                    node.loc.start.column + 1 - line.indexOf(shortline),
                    " "
                )}\n`
            )
        } else {
            console.warn(`[mobx:undecorate] ${msg} at (${fileInfo.path})\n`)
        }
    }
}



================================================
FILE: scripts/build.js
================================================
const fs = require("fs-extra")
const execa = require("execa")
const minimist = require("minimist")

const stdio = ["ignore", "inherit", "pipe"]
const opts = { stdio }

const {
    _: [packageName],
    target
} = minimist(process.argv.slice(2))

// build to publish needs to do more things so it's slower
// for the CI run and local testing this is not necessary
const isPublish = target === "publish"

// for running tests in CI we need CJS only
const isTest = target === "test"

const run = async () => {
    // TSDX converts passed name argument to lowercase for file name
    const pkgPrefix = `${packageName.toLowerCase()}.`

    const tempMove = name => fs.move(`dist/${pkgPrefix}${name}`, `temp/${pkgPrefix}${name}`)
    const moveTemp = name => fs.move(`temp/${pkgPrefix}${name}`, `dist/${pkgPrefix}${name}`)

    const build = (format, env) => {
        const args = ["build", "--name", packageName, "--format", format]
        if (env) {
            args.push("--env", env)
        }
        return execa("tsdx", args, opts)
    }

    if (isPublish) {
        await fs.emptyDir("temp")
        // build dev/prod ESM bundles that can be consumed in browser without NODE_ENV annoyance
        // and these builds cannot be run in parallel because tsdx doesn't allow to change target dir
        await build("esm", "development")
        // tsdx will purge dist folder, so it's necessary to move these
        await tempMove(`esm.development.js`)
        await tempMove(`esm.development.js.map`)

        // cannot build these concurrently
        await build("esm", "production")
        await tempMove(`esm.production.min.js`)
        await tempMove(`esm.production.min.js.map`)
    }

    await build(isTest ? "cjs" : "esm,cjs,umd").catch(err => {
        throw new Error(`build failed: ${err.stderr}`)
    })

    if (isPublish) {
        // move ESM bundles back to dist folder and remove temp
        await moveTemp(`esm.development.js`)
        await moveTemp(`esm.development.js.map`)
        await moveTemp(`esm.production.min.js`)
        await moveTemp(`esm.production.min.js.map`)
        await fs.remove("temp")
    }
}

run().catch(err => {
    console.error(err)
    process.exit(1)
})



================================================
FILE: website/package.json
================================================
{
  "scripts": {
    "examples": "docusaurus-examples",
    "start": "docusaurus-start",
    "build": "docusaurus-build",
    "publish-gh-pages": "docusaurus-publish",
    "write-translations": "docusaurus-write-translations",
    "version": "docusaurus-version",
    "rename-version": "docusaurus-rename-version"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mobxjs/mobx.git"
  },
  "author": "Michel Weststrate",
  "license": "MIT",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/mobx"
  },
  "bugs": {
    "url": "https://github.com/mobxjs/mobx/issues"
  },
  "homepage": "https://mobx.js.org/",
  "devDependencies": {
    "docusaurus": "^1.14.4"
  },
  "dependencies": {
    "@docusaurus/plugin-google-gtag": "^3.2.1"
  }
}



================================================
FILE: website/sidebars.json
================================================
{
  "docs": {
    "Introduction": [
      "README",
      "about-this-documentation",
      "installation",
      "the-gist-of-mobx"
    ],
    "MobX core": [
      "observable-state",
      "actions",
      "computeds",
      "reactions",
      "api"
    ],
    "MobX and React": [
      "react-integration",
      "react-optimizations"
    ],
    "Tips & Tricks": [
      "defining-data-stores",
      "understanding-reactivity",
      "subclassing",
      "analyzing-reactivity",
      "computeds-with-args",
      "mobx-utils",
      "custom-observables",
      "lazy-observables",
      "collection-utilities",
      "intercept-and-observe"
    ],
    "Fine-tuning": [
      "configuration",
      "enabling-decorators",
      "migrating-from-4-or-5"
    ]
  }
}



================================================
FILE: website/siteConfig.js
================================================
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// See https://docusaurus.io/docs/site-config for all the possible
// site configuration options.

// List of projects/orgs using your project for the users page.
const users = [
    {
        caption: "User1",
        // You will need to prepend the image path with your baseUrl
        // if it is not '/', like: '/test-site/img/image.jpg'.
        image: "/img/undraw_open_source.svg",
        infoLink: "https://www.facebook.com",
        pinned: true
    }
]

const siteConfig = {
    algolia: {
        apiKey: '500db32fbdbd53a814f42aafdfa26bd4',
        indexName: 'mobxjs',
    },
    title: "MobX ğŸ‡ºğŸ‡¦", // Title for your website.
    tagline: "Simple, scalable state management",

    // For github.io type URLs, you would set the url and baseUrl like:
    //   url: 'https://facebook.github.io',
    //   baseUrl: '/test-site/',
    url: "https://mobx.js.org", // Your website URL
    baseUrl: "/", // Base URL for your project */
    docsUrl: "", // trim 'docs/ prefix
    cname: "mobx.js.org", // needed for github pages to work under a domain
    // Used for publishing and more

    projectName: "mobx",
    organizationName: "mobxjs",

    // URL for editing docs, usage example: editUrl + 'en/doc1.md'.
    // If this field is omitted, there will be no "Edit this Doc" button
    // for each document.
    editUrl: "https://github.com/mobxjs/mobx/edit/main/docs/",

    // For top-level user or org sites, the organization is still the same.
    // e.g., for the https://JoelMarcey.github.io site, it would be set like...
    //   organizationName: 'JoelMarcey'

    // For no header links in the top nav bar -> headerLinks: [],
    headerLinks: [
        { doc: "api", label: "API Reference" },
        { href: "https://zh.mobx.js.org", label: "ä¸­æ–‡" },
        { href: "https://ko.mobx.js.org", label: "í•œêµ­ì–´" },
        { doc: "backers-sponsors", label: "Sponsors" },
        { href: "https://github.com/mobxjs/mobx", label: "GitHub" }
    ],

    // docsSideNavCollapsible: true,

    // If you have users set above, you add it here:
    users,

    /* path to images for header/footer */
    headerIcon: "img/mobx.png",
    footerIcon: "img/mobx.png",
    favicon: "img/favicon.png",

    /* Colors for website */
    colors: {
        primaryColor: "#035193",
        secondaryColor: "#023866"
    },

    /* Custom fonts for website */
    /*
fonts: {
myFont: [
"Times New Roman",
"Serif"
],
myOtherFont: [
"-apple-system",
"system-ui"
]
},
*/

    // This copyright info is used in /core/Footer.js and blog RSS/Atom feeds.
    copyright: `Copyright Â© ${new Date().getFullYear()} Your Name or Your Company Name`,

    highlight: {
        // Highlight.js theme to use for syntax highlighting in code blocks.
        theme: "default"
    },

    // Add custom scripts here that would be placed in <script> tags.
    scripts: [
        "/js/scripts.js",
        "https://buttons.github.io/buttons.js",
    ],

    // On page navigation for the current documentation page.
    onPageNav: "separate",
    // No .html extensions for paths.
    cleanUrl: false, // similar to old gitbook

    // Open Graph and Twitter card images.
    ogImage: "img/undraw_online.svg",
    twitterImage: "img/undraw_tweetstorm.svg",

    // Show documentation's last contributor's name.
    // enableUpdateBy: true,

    // Show documentation's last update time.
    // enableUpdateTime: true,

    // You may provide arbitrary config keys to be used as needed by your
    // template. For example, if you need your repo's URL...
    repoUrl: "https://github.com/mobxjs/mobx",
    gaGtag: true,
    gaTrackingId: "G-7XBWTSGJ80",
}

module.exports = siteConfig



================================================
FILE: website/core/Footer.js
================================================
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const React = require("react")

class Footer extends React.Component {
    docUrl(doc, language) {
        const baseUrl = this.props.config.baseUrl
        const docsUrl = this.props.config.docsUrl
        const docsPart = `${docsUrl ? `${docsUrl}/` : ""}`
        const langPart = `${language ? `${language}/` : ""}`
        return `${baseUrl}${docsPart}${langPart}${doc}`
    }

    pageUrl(doc, language) {
        const baseUrl = this.props.config.baseUrl
        return baseUrl + (language ? `${language}/` : "") + doc
    }

    render() {
        return (
            <footer className="nav-footer" id="footer">
                <section className="sitemap">
                    <a href={this.props.config.baseUrl} className="nav-home">
                        {this.props.config.footerIcon && (
                            <img
                                src={this.props.config.baseUrl + this.props.config.footerIcon}
                                alt={this.props.config.title}
                                width="66"
                                height="58"
                            />
                        )}
                    </a>
                    <div>
                        <h5>Docs</h5>
                        <a href={this.docUrl("README.html#introduction")}>About MobX</a>
                        <a href={this.docUrl("the-gist-of-mobx.html")}>The gist of MobX</a>
                    </div>
                    <div>
                        <h5>Community</h5>
                        {/* <a href={this.pageUrl('users.html', this.props.language)}>
              User Showcase
            </a> */}
                        <a href="https://github.com/mobxjs/mobx/discussions" target="_blank" rel="noreferrer noopener">GitHub discussions (NEW)</a>
                        <a
                            href="https://stackoverflow.com/questions/tagged/mobx"
                            target="_blank"
                            rel="noreferrer noopener"
                        >
                            Stack Overflow
                        </a>
                    </div>
                    <div>
                        <h5>More</h5>
                        <a
                            className="github-button"
                            href={this.props.config.repoUrl}
                            data-icon="octicon-star"
                            data-count-href="/facebook/docusaurus/stargazers"
                            data-show-count="true"
                            data-count-aria-label="# stargazers on GitHub"
                            aria-label="Star this project on GitHub"
                        >
                            Star
                        </a>
                        {this.props.config.twitterUsername && (
                            <div className="social">
                                <a
                                    href={`https://twitter.com/${this.props.config.twitterUsername
                                        }`}
                                    className="twitter-follow-button"
                                >
                                    Follow @{this.props.config.twitterUsername}
                                </a>
                            </div>
                        )}
                        {this.props.config.facebookAppId && (
                            <div className="social">
                                <div
                                    className="fb-like"
                                    data-href={this.props.config.url}
                                    data-colorscheme="dark"
                                    data-layout="standard"
                                    data-share="true"
                                    data-width="225"
                                    data-show-faces="false"
                                />
                            </div>
                        )}
                    </div>
                </section>
            </footer>
        )
    }
}

module.exports = Footer



================================================
FILE: website/i18n/en.json
================================================
{
  "_comment": "This file is auto-generated by write-translations.js",
  "localized-strings": {
    "next": "Next",
    "previous": "Previous",
    "tagline": "Simple, scalable state management",
    "docs": {
      "about-this-documentation": {
        "title": "About this documentation",
        "sidebar_label": "About this documentation"
      },
      "actions": {
        "title": "Updating state using actions",
        "sidebar_label": "Actions"
      },
      "analyzing-reactivity": {
        "title": "Analyzing reactivity",
        "sidebar_label": "Analyzing reactivity {ğŸš€}"
      },
      "api": {
        "title": "MobX API Reference",
        "sidebar_label": "API"
      },
      "backers-sponsors": {
        "title": "MobX Backers and Sponsors"
      },
      "best/debugging-mobx": {
        "title": "Analyzing reactivity"
      },
      "best/decorators": {
        "title": "Enabling decorators"
      },
      "best/store": {
        "title": "Defining data stores"
      },
      "best/what-does-mobx-react-to": {
        "title": "Understanding reactivity"
      },
      "collection-utilities": {
        "title": "Collection utilities",
        "sidebar_label": "Collection utilities {ğŸš€}"
      },
      "computeds-with-args": {
        "title": "Computeds with arguments",
        "sidebar_label": "Computeds with arguments {ğŸš€}"
      },
      "computeds": {
        "title": "Deriving information with computeds",
        "sidebar_label": "Computeds"
      },
      "configuration": {
        "title": "Configuration",
        "sidebar_label": "Configuration {ğŸš€}"
      },
      "custom-observables": {
        "title": "Creating custom observables",
        "sidebar_label": "Custom observables {ğŸš€}"
      },
      "defining-data-stores": {
        "title": "Defining data stores",
        "sidebar_label": "Defining data stores"
      },
      "enabling-decorators": {
        "title": "Decorators",
        "sidebar_label": "Decorators {ğŸš€}"
      },
      "faq/migrate-to-6": {
        "title": "Migrating from MobX 4/5"
      },
      "installation": {
        "title": "Installation",
        "sidebar_label": "Installation"
      },
      "intercept-and-observe": {
        "title": "Intercept & Observe",
        "sidebar_label": "Intercept & Observe {ğŸš€}"
      },
      "intro/concepts": {
        "title": "The gist of MobX"
      },
      "intro/how-to-read": {
        "title": "About this documentation"
      },
      "intro/installation": {
        "title": "Installation"
      },
      "lazy-observables": {
        "title": "Creating lazy observables",
        "sidebar_label": "Lazy observables {ğŸš€}"
      },
      "LINKS": {
        "title": "LINKS"
      },
      "migrating-from-4-or-5": {
        "title": "Migrating from MobX 4/5",
        "sidebar_label": "Migrating from MobX 4/5 {ğŸš€}"
      },
      "mobx-utils": {
        "title": "MobX-utils",
        "sidebar_label": "MobX-utils {ğŸš€}"
      },
      "observable-state": {
        "title": "Creating observable state",
        "sidebar_label": "Observable state"
      },
      "react-integration": {
        "title": "React integration",
        "sidebar_label": "React integration"
      },
      "react-optimizations": {
        "title": "Optimizing React component rendering",
        "sidebar_label": "React optimizations {ğŸš€}"
      },
      "react/react-integration": {
        "title": "React integration"
      },
      "react/react-performance": {
        "title": "Optimizing React component rendering"
      },
      "reactions": {
        "title": "Running side effects with reactions",
        "sidebar_label": "Reactions {ğŸš€}"
      },
      "README": {
        "title": "About MobX",
        "sidebar_label": "About MobX"
      },
      "refguide/action": {
        "title": "Updating state using actions"
      },
      "refguide/api": {
        "title": "MobX API overview"
      },
      "refguide/autorun": {
        "title": "Running side effects with reactions"
      },
      "refguide/computed-with-args": {
        "title": "Computeds with arguments"
      },
      "refguide/computed": {
        "title": "Deriving information with computeds"
      },
      "refguide/configure": {
        "title": "Configuration"
      },
      "refguide/extending": {
        "title": "Creating custom observables"
      },
      "refguide/mobx-utils": {
        "title": "MobX-utils"
      },
      "refguide/modifiers": {
        "title": "Observable modifiers"
      },
      "refguide/object-api": {
        "title": "Collection utilities"
      },
      "refguide/object": {
        "title": "Observable Objects"
      },
      "refguide/observable": {
        "title": "Creating observable state"
      },
      "refguide/observe": {
        "title": "Intercept & Observe"
      },
      "refguide/on-become-observed": {
        "title": "Creating lazy observables"
      },
      "refguide/set": {
        "title": "Observable Sets"
      },
      "subclassing": {
        "title": "Subclassing",
        "sidebar_label": "Subclassing"
      },
      "the-gist-of-mobx": {
        "title": "The gist of MobX",
        "sidebar_label": "The gist of MobX"
      },
      "understanding-reactivity": {
        "title": "Understanding reactivity",
        "sidebar_label": "Understanding reactivity"
      }
    },
    "links": {
      "API Reference": "API Reference",
      "ä¸­æ–‡": "ä¸­æ–‡",
      "í•œêµ­ì–´": "í•œêµ­ì–´",
      "Sponsors": "Sponsors",
      "GitHub": "GitHub"
    },
    "categories": {
      "Introduction": "Introduction",
      "MobX core": "MobX core",
      "MobX and React": "MobX and React",
      "Tips & Tricks": "Tips & Tricks",
      "Fine-tuning": "Fine-tuning"
    }
  },
  "pages-strings": {
    "Help Translate|recruit community translators for your project": "Help Translate",
    "Edit this Doc|recruitment message asking to edit the doc source": "Edit",
    "Translate this Doc|recruitment message asking to translate the docs": "Translate"
  }
}



================================================
FILE: website/static/getting-started.html
================================================
<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Ten minute introduction to MobX + React">

    <link rel="stylesheet" href="assets/getting-started-assets/style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="shortcut icon" type="image/png" href="assets/getting-started-assets/images/favicon.png" />

    <title>MobX: Ten minute introduction to MobX and React</title>
</head>

<body>
    <div class="github-fork-ribbon-wrapper right-bottom fixed">
        <div class="github-fork-ribbon">
            <a href="https://github.com/mobxjs/mobx">Fork me on GitHub</a>
        </div>
    </div>
    <table class="root">
        <tr>
            <td class="left">
              <div class="left-content-wrapper">
                <div class="left-content">
                    <header>
                        <a href="index.html" style="float:left">
						<img style="width: 120px; padding-right: 20px;" src="assets/getting-started-assets/images/mobservable.png" id="logo" /></a>
                        <h1 id="project_title">MobX</h1>
                        <h2 id="project_tagline" style="font-size: 18pt">Ten minute introduction to MobX and React</h2>
                        <hr/>
                    </header>

                    <section id="main_content">
                        <p>
                            <a href="https://github.com/mobxjs/mobx"><code>MobX</code></a> is a simple, scalable and battle tested state management solution.
							This tutorial will teach you all the important concepts of MobX in ten minutes.
                            MobX is a standalone library, but most people are using it with React and this tutorial focuses on that combination.
                        </p>
                        <h3>The core idea</h3>
						<p>
							State is the heart of each application and there is no quicker way to create buggy, unmanageable applications than by
							producing an inconsistent state or state that is out-of-sync with local variables that linger around.
							Hence many state management solutions try to restrict the ways in which you can modify state, for example by making state immutable.
							But this introduces new problems; data needs to be normalized, referential integrity can no longer be guaranteed and it becomes next to impossible to use powerful concepts like classes in case you fancy those.
						</p><p>
							MobX makes state management simple again by addressing the root issue: it makes it impossible to produce an inconsistent state.
							The strategy to achieve that is simple:
							<em>Make sure that everything that can be derived from the application state, will be derived. Automatically.</em>
						</p>
						<p>
							Conceptually MobX treats your application like a spreadsheet.
                        <p>
							<img src="assets/getting-started-assets/overview.png" width="100%" />
						<ol>
							<li>
							First of all, there is the <em>application state</em>.
							Graphs of objects, arrays, primitives, references that forms the model of your application.
							These values are the &ldquo;data cells&rdquo; of your application.
							</li>
                            <li>Secondly there are <em>derivations</em>.
								Basically, any value that can be computed automatically from the state of your application.
            					These derivations, or computed values, can range from
                                simple values, like the number of unfinished todos, to complex stuff like a visual HTML
                                representation of your todos. In spreadsheet terms: these are the formulas and charts of
                                your application.
                            </li>
                            <li><em>Reactions</em> are very similar to derivations. The main difference is these functions don't produce a
                                value. Instead, they run automatically to perform some task.
                                Usually this is I/O related.
                                They make sure that the DOM is updated or
                                that network requests are made automatically at the right time.
                            </li>
                            <li>Finally there are <em>actions</em>. Actions are all the things that alter the <em>state</em>.
                            MobX will make sure that all changes to the application
                                state caused by your actions are automatically processed by all derivations and reactions.
                                Synchronously and glitch-free.
                            </li>
                        </ol>
                        <h3>A simple todo store...</h3>
                        <p>
                            Enough theory, seeing it in action probably explains more than carefully reading the above stuff. For originality's sake
                            let's start with a very simple ToDo store.
                            Note that all the code blocks below are editable,
                            So use the <em>run code</em> buttons to execute them.
                            Below is a very straightforward <code>TodoStore</code> that maintains a collection of todos.
                            No MobX involved yet.
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code1" rows="25">
class TodoStore {
  todos = [];

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  report() {
    if (this.todos.length === 0)
      return "<none>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `Next todo: "${nextTodo ? nextTodo.task : "<none>"}". ` +
      `Progress: ${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const todoStore = new TodoStore();
                        </textarea>
                        <p>We just created a <code>todoStore</code> instance with a <code>todos</code> collection.
                            Time to fill the todoStore with some objects.
                            To make sure we see the effects of our changes we invoke <code>todoStore.report</code> after each change and log it.
                            Note that the report intentionally always prints the <em>first</em> task only.
                            It makes this example a bit artificial, but as we will see later on it nicely demonstrates that MobX's dependency tracking is dynamic.
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code2" rows="15">
todoStore.addTodo("read MobX tutorial");
console.log(todoStore.report());

todoStore.addTodo("try MobX");
console.log(todoStore.report());

todoStore.todos[0].completed = true;
console.log(todoStore.report());

todoStore.todos[1].task = "try MobX in own project";
console.log(todoStore.report());

todoStore.todos[0].task = "grok MobX tutorial";
console.log(todoStore.report());
                        </textarea>
                        <button onClick="runCode(['#code1', '#code2'])" class="btn-run">Run code</button>

                        <h3>Becoming reactive</h3>
                        <p>So far, there is nothing special about this code.
                            But what if we didn't have to call <code>report</code> explicitly,
                            but that we could declare instead that it should be invoked upon each <em>relevant</em> state change?
                            That would free us from the responsibility of calling <code>report</code> from any place in our code
                            base that <em>might</em> affect the report. We do want to be sure the latest report is printed.
                            But we don't wanna be bothered by organizing that.
                        </p>
                        <p>
                            Luckily that is exactly what MobX can do for us. Automatically execute code that solely depends on state.
                            So that our <code>report</code> function updates automatically, just like a chart in a spreadsheet.
                            To achieve that, the <code>TodoStore</code> has to become observable so that MobX can track all the changes that are being made.
                            Let's alter the class just enough to achieve that.
                        </p>
                        <p>Also, the <code>completedTodosCount</code> property could be derived automatically from the todo
                            list. By using the <code>observable</code> and <code>computed</code> annotations we can introduce observable properties on an
                            object.
                            In the example below we use <code>makeObservable</code> to show the annotations explicitly,
                            but we could have used <code>makeAutoObservable(this)</code> instead to simplify this process.
                        </p>
                        <textarea spellcheck="false" class="prettyprint" id="code3" rows="8">
class ObservableTodoStore {
  todos = [];
  pendingRequests = 0;

  constructor() {
    makeObservable(this, {
      todos: observable,
      pendingRequests: observable,
      completedTodosCount: computed,
      report: computed,
      addTodo: action,
    });
    autorun(() => console.log(this.report));
  }

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  get report() {
    if (this.todos.length === 0)
      return "<none>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `Next todo: "${nextTodo ? nextTodo.task : "<none>"}". ` +
      `Progress: ${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const observableTodoStore = new ObservableTodoStore();
                        </textarea>

                        <p>That's it! We marked some properties as being <code>observable</code> to signal MobX that these values can change over time.
                            The computations are decorated with <code>computed</code> to identify that these can be derived from the state and caches as long as no underlying state changed.
                        </p>
                        <p>
                            The <code>pendingRequests</code> and <code>assignee</code> attributes are not used so far,
                            but will be used later in this tutorial.
                        </p>
                        <p>
                            In the constructor we created a small function that prints the <code>report</code> and
                            wrapped it in <code>autorun</code>. Autorun creates a <em>reaction</em> that runs once, and after
                            that automatically re-runs whenever any observable data that was used inside the function changes.
                            Because <code>report</code> uses the observable <code>todos</code> property, it will print the
                            report whenever appropriate. This is demonstrated in the next listing. Just press the <em>run</em> button:
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code4" rows="6">
observableTodoStore.addTodo("read MobX tutorial");
observableTodoStore.addTodo("try MobX");
observableTodoStore.todos[0].completed = true;
observableTodoStore.todos[1].task = "try MobX in own project";
observableTodoStore.todos[0].task = "grok MobX tutorial";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4'])" class="btn-run">Run code</button>

                        <p>Pure fun, right? The <code>report</code> did print automatically, synchronously and without leaking
                            intermediate values. If you investigate the log carefully, you will see that the fifth line
                            didn't result in a new log-line. Because the report did not <em>actually</em> change as a result
                            of the rename, although the backing data did. On the other hand, changing the name of the first
                            todo did update the report, since that name is actively used in the report.
                            This demonstrates nicely that
                            not just the <code>todos</code> array is being observed by the <code>autorun</code>, but also
                            the individual properties inside the todo items.
                        </p>
                        <h3 id="reactive-reactjs-components">Making React reactive</h3>
                        <p>Ok, so far we made a silly report reactive. Time to build a reactive user interface around this very
                            same store. React components are (despite their name) not reactive out of the box.
                            The <code>observer</code> HoC wrapper from the <code>mobx-react-lite</code> package fixes that by
                            basically wrapping the React component in <code>autorun</code>. This
                            keeps the component in sync with the state. This is conceptually not different from what we did
                            with the <code>report</code> before.
                        </p>
                        <p>
                            The next listing defines a few React components.
                            The only MobX specific code in there is the <code>observer</code> wrapping.
                            That is enough to make sure that each component individually re-renders when relevant data changes.
                            We don't have to call state <code>useState</code> setters anymore,
                            nor do we have to figure out how to subscribe to the proper parts
                            of the application state using selectors or higher order components that need configuration.
                            Basically, all components have become smart. Yet they are defined in a dumb, declarative manner.
                        </p>
                        <p>
                            Press the <em>Run code</em> button to see the code below in action. The listing is editable so
                            feel free to play with it. Try for example to remove all the <code>observer</code> calls, or
                            just the one decorating the <code>TodoView</code>. The numbers in the preview on the right highlight
                            how often a component is rendered.
                        </p>
                        <textarea spellcheck="false" class="" id="react1" rows="44">
const TodoList = observer(({store}) => {
  const onNewTodo = () => {
    store.addTodo(prompt('Enter a new todo:','coffee plz'));
  }

  return (
    <div>
      { store.report }
      <ul>
        { store.todos.map(
          (todo, idx) => <TodoView todo={ todo } key={ idx } />
        ) }
      </ul>
      { store.pendingRequests > 0 ? <marquee>Loading...</marquee> : null }
      <button onClick={ onNewTodo }>New Todo</button>
      <small> (double-click a todo to edit)</small>
      <RenderCounter />
    </div>
  );
})

const TodoView = observer(({todo}) => {
  const onToggleCompleted = () => {
    todo.completed = !todo.completed;
  }

  const onRename = () => {
    todo.task = prompt('Task name', todo.task) || todo.task;
  }

  return (
    <li onDoubleClick={ onRename }>
      <input
        type='checkbox'
        checked={ todo.completed }
        onChange={ onToggleCompleted }
      />
      { todo.task }
      { todo.assignee
        ? <small>{ todo.assignee.name }</small>
        : null
      }
      <RenderCounter />
    </li>
  );
})

ReactDOM.render(
  <TodoList store={ observableTodoStore } />,
  document.getElementById('reactjs-app')
);
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1'])" class="btn-run">Run code</button>

                        <p>
                            The next listing nicely demonstrates that we only have to alter the data, without doing any further bookkeeping.
                            MobX will automatically derive and update the relevant parts of the user interface again from the state in the store.
                        </p>

                        <textarea spellcheck="false" class="" id="play1" rows="8">
const store = observableTodoStore;
store.todos[0].completed = !store.todos[0].completed;
store.todos[1].task = "Random todo " + Math.random();
store.todos.push({ task: "Find a fine cheese", completed: true });
// etc etc.. add your own statements here...
                        </textarea>
                        <button onClick="if (typeof observableTodoStore === 'undefined') { runCode(['#code1', '#code3', '#code4', '#react1']) } runCode(['#play1'])"
                        class="btn-run">Run code</button>
                        <button id="runline-btn" onClick="runCodePerLine()" class="btn-run">Run line-by-line</button>
                        <p>&nbsp;</p>

                        <h3>Working with references</h3>
                        <p>
                            So far we have created observable objects (both prototyped and plain objects), arrays and primitives. You might be wondering,
                            how are references handled in MobX? Is my state allowed to form a graph? In the previous listings
                            you might have noticed that there is an <code>assignee</code> property
                            on the todos. Let's give them some values by introducing another &ldquo;store&rdquo; (ok, it's just
                            a glorified array) containing people, and assign tasks to them.
                        </p>
                        <textarea spellcheck="false" class="" id="store2" rows="8">
const peopleStore = observable([
  { name: "Michel" },
  { name: "Me" }
]);
observableTodoStore.todos[0].assignee = peopleStore[0];
observableTodoStore.todos[1].assignee = peopleStore[1];
peopleStore[0].name = "Michel Weststrate";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1', '#store2'])" class="btn-run">Run code</button>
                        <p>We now have two independent stores. One with people and one with todos. To assign an <code>assignee</code>
                            to a person from the people store, we just assigned a reference. These changes will be picked
                            up automatically by the <code>TodoView</code>. With MobX there is no need to normalize data first
                            and to write selectors to make sure our components will be updated. In fact, it doesn't even
                            matter where the data is stored. As long as objects are made <em>observable</em>, MobX will be
                            able to track them. Real JavaScript references will just work. MobX will track them automatically
                            if they are relevant for a derivation. To test that, just try changing your name in the next
                            input box (make sure you have pressed the above <em>Run code</em> button first!).
                        </p>
                        <hr/>
                        <p style="text-align:center">Your name:
                            <input onkeyup="peopleStore[1].name = event.target.value" />
                        </p>
                        <hr/>
                        <p>By the way, the HTML of the above input box is simply: <pre>&lt;input onkeyup="peopleStore[1].name = event.target.value" /&gt;</pre></p>

                        <h3>Asynchronous actions</h3>
                        <p>Since everything in our small Todo application is derived from the state, it really doesn't matter <em>when</em> state is changed.
                            That makes creating asynchronous actions really straightforward.
                            Just press the the following button (multiple times) to emulate asynchronously loading new todo items:
                        </p>
                        <hr/>
                        <p style="text-align:center">
                            <button onclick="observableTodoStore.pendingRequests++; setTimeout(function() { observableTodoStore.addTodo('Random Todo ' + Math.random()); observableTodoStore.pendingRequests--;  }, 2000);">Load todo</button>
                        </p>
                        <hr/>
                        <p>The code behind that is really straightforward.
                            We start with updating the store property <code>pendingRequests</code> to have the UI reflect the current loading status.
                            Once loading is finished, we update the todos of the store and decrease the <code>pendingRequests</code> counter again.
                            Just compare this snippet with the earlier <code>TodoList</code> definition to see how the pendingRequests property is used.
                        </p><p>
                            Note that the timeout function is wrapped in <code>action</code>. This isn't strictly necessary,
                            but it makes sure that both mutations are processed in a single transaction, making sure any observers are only notified after both updates have completed.
<pre>observableTodoStore.pendingRequests++;
setTimeout(action(() => {
  observableTodoStore.addTodo('Random Todo ' + Math.random());
  observableTodoStore.pendingRequests--;
}), 2000);</pre>
                        </p>

                        <h3>Conclusion</h3>
                        <p>
                            That's all! No boilerplate. Just some simple, declarative components that form our complete UI. And which are derived completely,
                            reactively from our state. You are now ready to start using the <code>mobx</code> and <code>mobx-react-lite</code> packages in your own applications.
                            A short summary of the things you learned so far:
                        </p>
                        <ol>
                            <li>
                                Use the <code>observable</code> decorator or <code>observable(object or array)</code> functions to make objects trackable for MobX.
                            </li>
                            <li>
                                The <code>computed</code> decorator can be used to create functions that can automatically derive value from the state and cache them.
                            </li>
                            <li>
                                Use <code>autorun</code> to automatically run functions that depend on some observable state.
                                This is useful for logging, making network requests, etc.
                            </li>
                            <li>
                                Use the <code>observer</code> wrapper from the <code>mobx-react-lite</code> package to make your React components truly reactive.
                                They will update automatically and
                                efficiently. Even when used in large complex applications with large amounts of data.
                            </li>
                        </ol>
                        <p>
                            Feel free to play around a bit longer with the editable code blocks above to get a basic feeling how MobX reacts to all your
                            changes. You could for example add a log statement to the <code>report</code> function to see when it is called.
                            Or don't show the <code>report</code> at all and see how that
                            influences the rendering of the <code>TodoList</code>. Or show it only under specific circumstances...
                        </p>

                        <h3>MobX doesn't dictate architecture</h3>
                        <p>
                          Please note that the above examples are contrived and it is recommended to use proper engineering practices like
                            encapsulating logic in methods, organize them in stores or controllers, view-models etc.
                            Many different architectural patterns can be applied, and some are further discussed inside the official docs.
                            The above examples, and the examples in the official documentation show how MobX <em>could</em> be used, not how it <em>must</em> be used.
                            Or, as somebody on HackerNews put it:
                            <blockquote><em>
&ldquo;MobX, it's been mentioned elsewhere but I can't help but sing its praises.
Writing in MobX means that using controllers/ dispatchers/ actions/ supervisors or another form of managing dataflow returns to being an architectural concern you can pattern to your application's needs,
rather than being something that's required by default for anything more than a Todo app.&rdquo;
                            </em></blockquote>
                        </p>

                        <div style="text-align:center;">
                            <a class="github-button" href="https://github.com/mobxjs/mobx" data-icon="octicon-star" data-style="small" data-count-href="/mobxjs/mobx/stargazers"
                            data-count-api="/repos/mobxjs/mobx#stargazers_count" data-count-aria-label="# stargazers on GitHub"
                            aria-label="Star mobxjs/mobx on GitHub">Star</a>
                            <a href="https://twitter.com/share" class="twitter-share-button" data-via="mweststrate" data-hashtags="mobx">Tweet</a>
                        </div>

                    </section>

                    <footer>
                        <p class="copyright">MobX is maintained by <a href="https://twitter.com/mweststrate">mweststrate</a></p>
                    </footer>
                </div>
              </div>
            </td>
            <td class="right">
                <div class="right-content">
                    <h3>React preview</h3>
                    <div id="reactjs-app">
						<p style="text-align: center">Read on and press any <em>run</em> buttons you encounter!</p>
					</div>
                    <hr/>
                    <h3>Console log
                        <button onclick="clearConsole();" id="clear-btn">clear</button>
                    </h3>
                    <div id="consoleout"></div>
                </div>
            </td>
        </tr>
    </table>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.min.css" />
    <script src="assets/getting-started-assets/javascripts/jquery-2.1.4.min.js"></script>
    <script src="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/theme/xq-light.css">
    <script src="assets/getting-started-assets/javascripts/codemirror/javascript/javascript.js"></script>

    <script src="https://unpkg.com/react@16.13.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.13.1/umd/react-dom.development.js"></script>
    <script src="assets/getting-started-assets/babel.min.js"></script>
    <script src="https://unpkg.com/mobx@6.0.0-rc.8/dist/mobx.umd.development.js"></script>
    <script src="https://unpkg.com/mobx-react-lite@3.0.0-beta.1/dist/mobxreactlite.umd.development.js"></script>
    <script src="assets/getting-started-assets/script.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-65632006-1");
          pageTracker._trackPageview();
        } catch(err) {}
    </script>
    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    <script>
        !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>
</body>

</html>



================================================
FILE: website/static/index.html
================================================
<!DOCTYPE HTML>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="0; url=/README.html">
    <script type="text/javascript">
      window.location.href = '/README.html';
    </script>
    <title>MobX</title>
  </head>
  <body>
    If you are not redirected automatically, follow this <a href="/README.html">link</a>.
  </body>
</html>



================================================
FILE: website/static/css/custom.css
================================================
/* your custom css */


/*
Docusaurus's default displays img tags as block.
Numerous images in the main README.md relied on default (inline-block) img tag styling
when this project was migrated initially.

Override that style here
*/
article p img {
  display: inline-block;
}

@media only screen and (min-device-width: 360px) and (max-device-width: 736px) {
}

@media only screen and (max-width: 735px) {
  .nav-footer .sitemap .nav-home {
    margin-left: -10px;
  }
}

@media only screen and (min-width: 1024px) {
}

@media only screen and (max-width: 1023px) {
}

@media only screen and (min-width: 1400px) {
}

@media only screen and (min-width: 1500px) {
}

/* Transform Github link. Lifted from Redux's CSS */
/* https://github.com/reduxjs/redux/blob/master/website/static/css/custom.css#L134 */

.navigationSlider .slidingNav ul a[href*="github"] {
  font-size: 0;
}

.navigationSlider .slidingNav ul a[href*="github"]::before {
  content : "";
  width : 32px;
  height : 32px;
  background: url("/img/github-brand.svg");
}

.detail {
    font-size: 0.8em;
    color: #979797;
}

/* no fixed header, it makes linking ugly as headers disappear */
@media only screen and (min-width: 1024px)  {
    .fixedHeaderContainer {
        position: unset !important;
    }

    .navPusher {
        padding-top: 0px !important;
        margin-top: -40px !important;
    }
    .onPageNav {
        top: 70px !important;
    }
    .docsNavContainer {
        top: 30px !important;
    }
}


details {
    background-color: aliceblue;
    font-size: 0.8em;
    padding: 4px 8px;
    border-radius: 4px;
}

details > summary {
    color: navy;
    cursor: pointer;
}

details[open] > summary {
    margin-bottom: 8px;
}

.tabs {
    background: #efefef
}

.tab-content {
    padding: 1.25rem 1.5rem;
}

.tab-content .hljs {
    padding: 1.25rem 0px;
}

.benefits  {
    display: flex;
    align-items: center;
    flex-direction: column;
}

 .benefits > div {
    width: 80%;
    display: flex;
    align-items: center;
}

.benefits .pic {
    font-size: 40px;
    margin-right: 40px;
}

@media (max-width: 480px) {
  .slidingNav::before {
    text-align: left;
    padding-left: 60px;
  }
}

/* Cheat sheet link */
.cheat {
    text-align: center;
}
.cheat button {
    cursor: pointer;
    text-align: center;
    background: #035193;
    color: white;
    padding: 8px;
    border: none;
    border-radius: 4px;
    margin-left: auto;
    margin-right: auto;
    font-weight: bold;
}

/* Carbon */
#carbonads {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
        Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
    display: block;
    overflow: hidden;
    max-width: 728px;
    position: relative;
    background-color: hsl(0, 0%, 99%);
    border: solid 1px #eee;
    font-size: 22px;
    box-sizing: content-box;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 20px;
}

#carbonads > span {
    display: block;
}

#carbonads a {
    color: inherit;
    text-decoration: none;
}

#carbonads a:hover {
    color: inherit;
}

.carbon-wrap {
    display: flex;
    align-items: center;
}

.carbon-img {
    display: block;
    margin: 0;
    line-height: 1;
}

.carbon-img img {
    display: block;
    height: 90px;
    width: auto;
}

.carbon-text {
    display: block;
    padding: 0 1em;
    line-height: 1.35;
    text-align: left;
}

.carbon-poweredby {
    display: block;
    position: absolute;
    bottom: 0;
    right: 0;
    padding: 6px 10px;
    background: repeating-linear-gradient(
            -45deg,
            transparent,
            transparent 5px,
            hsla(0, 0%, 0%, 0.025) 5px,
            hsla(0, 0%, 0%, 0.025) 10px
        )
        hsla(203, 11%, 95%, 0.8);
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
    font-size: 8px;
    border-top-left-radius: 4px;
    line-height: 1;
}

@media only screen and (min-width: 320px) and (max-width: 759px) {
    .carbon-text {
        font-size: 14px;
    }
}

.tip-anchor {
    margin-left: 8px;

}
.tip-anchor::after {
    content: "âˆ"
}

blockquote {
    color: #444a50;
}

a:hover {
    text-decoration: underline;
}

small {
    font-size: smaller;
}



================================================
FILE: website/static/js/scripts.js
================================================
function openTarget() {
    var hash = location.hash.substring(1);
    if(hash) var details = document.getElementById(hash);
    if(details && details.tagName.toLowerCase() === 'details') {
        details.open = true;
        // seems to interfere with scroll spy otherwise (which triggers at 100 ms)
        setTimeout(function() {
            details.scrollIntoView();
        }, 150)
    }
}
function addTooltipToRockets() {
    var classNames = ['navGroups', 'onPageNav', 'post', 'docs-prevnext'];
    var rocketRegex = /ğŸš€/g;

    for (var className of classNames) {
        var els = document.getElementsByClassName(className);
        for (var el of els) {
            el.innerHTML = el.innerHTML.replace(rocketRegex, '<span title="Advanced feature">ğŸš€</span>');
        }
    }
}
window.addEventListener('hashchange', openTarget);
window.addEventListener('DOMContentLoaded', function() {
    addTooltipToRockets();
    openTarget();
});



================================================
FILE: .changeset/README.md
================================================
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/master/docs/common-questions.md)



================================================
FILE: .changeset/config.json
================================================
{
    "changelog": ["@changesets/changelog-github", { "repo": "mobxjs/mobx" }],
    "commit": false,
    "access": "public",
    "baseBranch": "main",
    "___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH": {
        "onlyUpdatePeerDependentsWhenOutOfRange": true
    }
}



================================================
FILE: .changeset/fair-houses-rhyme.md
================================================
---
"mobx": patch
---

Fixed memory leak where makeAutoObservable would keep wrapping setters defined on the prototype. Fixes #4553



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"



================================================
FILE: .github/FUNDING.yml
================================================
open_collective: mobx



================================================
FILE: .github/lock.yml
================================================
# Configuration for Lock Threads - https://github.com/dessant/lock-threads

# Number of days of inactivity before a closed issue or pull request is locked
daysUntilLock: 60

# Skip issues and pull requests created before a given timestamp. Timestamp must
# follow ISO 8601 (`YYYY-MM-DD`). Set to `false` to disable
skipCreatedBefore: 2019-01-01

# Issues and pull requests with these labels will be ignored. Set to `[]` to disable
exemptLabels: []

# Label to add before locking, such as `outdated`. Set to `false` to disable
lockLabel: false

# Comment to post before locking. Set to `false` to disable
lockComment: >
  This thread has been automatically locked since there has not been
  any recent activity after it was closed. Please open a new issue for
  related bugs or questions.

# Assign `resolved` as the reason for locking. Set to `false` to disable
setLockReason: true

# Limit to only `issues` or `pulls`
only: issues



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
<!--
    Thanks for taking the effort to create a PR! ğŸ™Œ

    ğŸ‘‹ Are you making a change to documentation only? Delete the rest of the template and go ahead.

    ğŸ‘‹ If you are creating an extensive PR, you might want to open an issue with your idea first in case there is a chance for rejecting it.

    ğŸ‘‹ If you intend to work on PR over several days, please, create [draft pull requests](https://github.blog/2019-02-14-introducing-draft-pull-requests/) instead.

    ğŸ‘‡ Please look at the following checklist to ensure that your PR can be accepted quickly:
-->

### Code change checklist

-   [ ] Added/updated unit tests
-   [ ] Updated `/docs`. For new functionality, at least `API.md` should be updated
-   [ ] Verified that there is no significant performance drop (`yarn mobx test:performance`)

<!--
    Feel free to ask help with any of these boxes!
-->



================================================
FILE: .github/stale.yml
================================================
# Number of days of inactivity before an issue becomes stale
daysUntilStale: 14
# Number of days of inactivity before a stale issue is closed
daysUntilClose: 4
# Issues with these labels will never be considered stale
exemptLabels:
    - ğŸ“Œ pinned
    - ğŸ’¬ discuss
    - ğŸ— enhancement
    - ğŸ“– documentation
    - ğŸ”¨ breaking-change
    - ğŸš§ experimental
    - ğŸ™ help wanted
    - ğŸ‘“ needs investigation
    - âœ‹ on hold

# Label to use when marking an issue as stale
staleLabel: ğŸš¶ stale
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
    This issue has been automatically marked as stale because it has not had
    recent activity. It will be closed if no further activity occurs. Thank you
    for your contributions.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: false
# Limit to only `issues` or `pulls`
only: issues
# Comment to post when removing the stale label.
unmarkComment: >
    This issue has been automatically unmarked as stale. Please disregard previous warnings.



================================================
FILE: .github/ISSUE_TEMPLATE/bug.md
================================================
---
name: ğŸ› Reporting a Bug
about: Open a new issue if something isn't working as expected.
labels: ğŸ› bug
---

<!--
  Thanks for filing an issue on MobX!

  Please make sure that you include the following information to ensure that your issue is actionable.

  If you don't follow the template, your issue may end up being closed without anyone looking at it carefully, because it is not actionable for us without the information in this template.
-->

**Intended outcome:**

<!--
What you were trying to accomplish when the bug occurred, and as much code as possible related to the source of the problem.
-->

**Actual outcome:**

<!--
A description of what happened, including a screenshot or copy-paste of any related error messages, logs, or other output that might be related. Places to look for information include your browser console, server console, and network logs. Please avoid non-specific phrases like â€œdidnâ€™t workâ€ or â€œbrokeâ€.
-->

**How to reproduce the issue:**

<!--
Please create a reproduction and link to it here. You can use the following starters:
- React: https://codesandbox.io/s/minimal-mobx-react-project-ppgml
- React Native: https://snack.expo.dev/vEF39Ohnb

If the issue is more complicated or not reproducible with React, feel free to create your CodeSandbox or your own GitHub repo with the code.

Instructions for how the issue can be reproduced by a maintainer or contributor. Be as specific as possible, and only mention what is necessary to reproduce the bug. If possible, try to isolate the exact circumstances in which the bug occurs and avoid speculation over what the cause might be. Help us so we can help you quickly.
-->

**Versions**

<!--
If you are unable to use CodeSandbox for whatever reasons, please list here all relevant dependencies

If you encounter the issue after upgrading from MobX 4/5 to MobX 6, make sure you've applied the migration guide: https://mobx.js.org/migrating-from-4-or-5.html
-->



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false
contact_links:
  - name: âœ¨ Feature Request / idea
    url: https://github.com/mobxjs/mobx/discussions/new
    about: Missing something in MobX? Let us know.
  - name: ğŸ’¬ Question / Discussion
    about: Feel free to ask anything
    url: https://github.com/mobxjs/mobx/discussions/new
  - name: ğŸ“– View documentation
    url: https://mobx.js.org
    about: Official Mobx documentation    
  - name: â“ StackOverflow
    url: https://stackoverflow.com/questions/tagged/mobx
    about: Ask question or find answers on Stack overflow


================================================
FILE: .github/ISSUE_TEMPLATE/documentation.md
================================================
---
name: âœ Documentation improvement
about: Please open the PR instead!
labels: ğŸ“– documentation
---

Documentation lives in the `/docs` folder. Please, send in PR directly with a change instead of describing what you want to change.

Ask here only if your change is bigger and there is a chance for rejecting it.



================================================
FILE: .github/workflows/build_and_test.yml
================================================
name: Build and test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch: {}

jobs:
  build:
    name: Build and test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@master

      - name: Setup Node.js 22.x
        uses: actions/setup-node@master
        with:
          node-version: 22.x

      - name: Install Dependencies
        run: yarn --frozen-lockfile --ignore-scripts

      - name: Lint
        run: yarn lint

      - name: Build check
        run: yarn lerna run build:check

      - name: Build packages
        run: yarn lerna run build:test

      - name: Test
        run: yarn test -i

      - name: Test size
        run: yarn lerna run test:size

      - name: Test flow
        run: yarn mobx test:flow

      - name: Test performance
        run: yarn mobx test:performance



================================================
FILE: .github/workflows/coveralls.yml
================================================
name: Coveralls

on: ["push"]

jobs:
  mobx:
    name: Packages coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@master
        with:
          # This makes Actions fetch all Git history so that Changesets can generate changelogs with the correct commits
          fetch-depth: 0

      - name: Setup Node.js 22.x
        uses: actions/setup-node@master
        with:
          node-version: 22.x

      - name: Install Dependencies
        run: yarn --frozen-lockfile --ignore-scripts

      - name: Build packages
        run: yarn lerna run build:test

      - name: Run Coverage
        run: yarn coverage

      - name: Upload to coveralls
        uses: coverallsapp/github-action@v2.3.6 
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .github/workflows/release.yml
================================================
name: Release

on:
  push:
    branches:
      - main

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@main
        with:
          # This makes Actions fetch all Git history so that Changesets can generate changelogs with the correct commits
          fetch-depth: 0

      - name: Setup Node.js 22.x
        uses: actions/setup-node@master
        with:
          node-version: 22.x

      - name: Install Dependencies
        run: yarn

      - name: Build packages
        run: yarn lerna run build

      - name: Create Release Pull Request or Publish to npm
        id: changesets
        uses: changesets/action@master
        with:
          # This expects you to have a script called release which does a build for your packages and calls changeset publish
          publish: yarn release
          commit: Version release
          title: Next release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}


