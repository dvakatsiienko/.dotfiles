Directory structure:
└── google-zx/
    ├── README.md
    ├── lefthook.yml
    ├── LICENSE
    ├── package.json
    ├── tsconfig.json
    ├── .commitlintrc
    ├── .node_version
    ├── .nycrc
    ├── .prettierignore
    ├── .size-limit.json
    ├── dcr/
    │   └── Dockerfile
    ├── docs/
    │   ├── api.md
    │   ├── architecture.md
    │   ├── cli.md
    │   ├── configuration.md
    │   ├── contribution.md
    │   ├── faq.md
    │   ├── getting-started.md
    │   ├── index.md
    │   ├── known-issues.md
    │   ├── lite.md
    │   ├── markdown.md
    │   ├── migration-from-v7.md
    │   ├── process-output.md
    │   ├── process-promise.md
    │   ├── quotes.md
    │   ├── setup.md
    │   ├── shell.md
    │   ├── typescript.md
    │   ├── versions.md
    │   └── .vitepress/
    │       ├── config.mts
    │       └── theme/
    │           ├── custom.css
    │           ├── index.js
    │           ├── MyLayout.vue
    │           └── MyOxygen.vue
    ├── examples/
    │   ├── background-process.mjs
    │   ├── backup-github.mjs
    │   ├── fetch-weather.mjs
    │   ├── interactive.mjs
    │   └── parallel.mjs
    ├── man/
    │   └── zx.1
    ├── scripts/
    │   ├── build-clean.mjs
    │   ├── build-dts.mjs
    │   ├── build-js.mjs
    │   ├── build-jsr.mjs
    │   ├── build-tests.mjs
    │   ├── build-versions.mjs
    │   ├── deno.polyfill.js
    │   ├── import-meta-url.polyfill.js
    │   ├── prepublish-clean.mjs
    │   └── prepublish-lite.mjs
    ├── src/
    │   ├── cli.ts
    │   ├── core.ts
    │   ├── deps.ts
    │   ├── error.ts
    │   ├── globals-jsr.ts
    │   ├── globals.ts
    │   ├── goods.ts
    │   ├── index.ts
    │   ├── internals.ts
    │   ├── log.ts
    │   ├── md.ts
    │   ├── repl.ts
    │   ├── util.ts
    │   ├── vendor-core.ts
    │   ├── vendor-extra.ts
    │   ├── vendor.ts
    │   └── versions.ts
    ├── test/
    │   ├── all.test.js
    │   ├── cli.test.js
    │   ├── core.test.js
    │   ├── deps.test.js
    │   ├── error.test.ts
    │   ├── export.test.js
    │   ├── extra.test.js
    │   ├── global.test.js
    │   ├── goods.test.ts
    │   ├── index.test.js
    │   ├── log.test.ts
    │   ├── md.test.ts
    │   ├── package.test.js
    │   ├── util.test.js
    │   ├── vendor.test.js
    │   ├── bench/
    │   │   └── buf-join.mjs
    │   ├── fixtures/
    │   │   ├── argv.mjs
    │   │   ├── copyright.txt
    │   │   ├── echo.http
    │   │   ├── exit-code.mjs
    │   │   ├── filename-dirname.mjs
    │   │   ├── interactive.mjs
    │   │   ├── markdown-crlf.md
    │   │   ├── markdown.md
    │   │   ├── md.http
    │   │   ├── no-extension
    │   │   ├── no-extension.mjs
    │   │   ├── non-std-ext.zx
    │   │   ├── require.mjs
    │   │   ├── server.mjs
    │   │   ├── js-project/
    │   │   │   ├── package.json
    │   │   │   └── script.js
    │   │   └── ts-project/
    │   │       ├── package.json
    │   │       ├── script.ts
    │   │       └── tsconfig.json
    │   ├── it/
    │   │   ├── build-dcr.test.js
    │   │   ├── build-jsr.test.js
    │   │   ├── build-npm.test.js
    │   │   └── clean-package-json.test.js
    │   └── smoke/
    │       ├── bun.test.js
    │       ├── deno.test.js
    │       ├── node.test.cjs
    │       ├── node.test.mjs
    │       ├── ts.test.ts
    │       ├── tsconfig.json
    │       └── win32.test.js
    ├── test-d/
    │   ├── core.test-d.ts
    │   ├── globals.test-d.ts
    │   └── goods.test-d.ts
    └── .github/
        ├── FUNDING.yml
        ├── ISSUE_TEMPLATE.md
        ├── PULL_REQUEST_TEMPLATE.md
        ├── SECURITY.md
        ├── codeql/
        │   └── codeql-config.yml
        ├── pages/
        │   └── index.html
        └── workflows/
            ├── codeql.yml
            ├── dev-publish.yml
            ├── docs.yml
            ├── jsr-publish.yml
            ├── osv.yml
            ├── publish.yml
            ├── test.yml
            └── zizmor.yml

================================================
FILE: README.md
================================================
<h1><img src="https://google.github.io/zx/img/logo.svg" alt="Zx logo" height="32" width="28" valign="middle"> zx</h1>

```js
#!/usr/bin/env zx

await $`cat package.json | grep name`

const branch = await $`git branch --show-current`
await $`dep deploy --branch=${branch}`

await Promise.all([
  $`sleep 1; echo 1`,
  $`sleep 2; echo 2`,
  $`sleep 3; echo 3`,
])

const name = 'foo bar'
await $`mkdir /tmp/${name}`
```

Bash is great, but when it comes to writing more complex scripts,
many people prefer a more convenient programming language.
JavaScript is a perfect choice, but the Node.js standard library
requires additional hassle before using. No compromise, take the best of both. The `zx` package provides
useful cross-platform wrappers around `child_process`, escapes arguments and
gives sensible defaults.

## Install

```bash
npm install zx
```
All setup options: [zx/setup](https://google.github.io/zx/setup).
See also [**zx@lite**](https://google.github.io/zx/lite).

## Usage

* [Documentation at google.github.io/zx/](https://google.github.io/zx/)
* [Code examples](https://github.com/google/zx/tree/main/examples)

## Compatibility
* Linux, macOS, or Windows
* JavaScript Runtime:
    * Node.js >= 12.17.0
    * Bun >= 1.0.0
    * Deno 1.x, 2.x
    * GraalVM Node.js
* Some kind of [bash or PowerShell](https://google.github.io/zx/shell)
* [Both CJS or ESM](https://google.github.io/zx/setup#hybrid) modules in [JS or TS](https://google.github.io/zx/typescript)


## License

[Apache-2.0](LICENSE)

Disclaimer: _This is not an officially supported Google product._



================================================
FILE: lefthook.yml
================================================
pre-commit:
  parallel: true
  commands:
    format:
      glob: '*.{js,ts,md,yml}'
      run: npm run fmt && git add {staged_files}

commit-msg:
  commands:
    lint-commit-msg:
      run: npx commitlint --edit

pre-push:
  parallel: true
  commands:
    license:
      run: npm run test:license
    size:
      run: npm run test:size
    circular:
      run: npm run test:circular



================================================
FILE: LICENSE
================================================

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: package.json
================================================
{
  "name": "zx",
  "version": "8.8.1",
  "description": "A tool for writing better scripts",
  "type": "module",
  "main": "./build/index.cjs",
  "types": "./build/index.d.ts",
  "typesVersions": {
    "*": {
      ".": [
        "./build/index.d.ts"
      ],
      "globals": [
        "./build/globals.d.ts"
      ],
      "cli": [
        "./build/cli.d.ts"
      ],
      "core": [
        "./build/core.d.ts"
      ]
    }
  },
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "import": "./build/index.js",
      "require": "./build/index.cjs",
      "default": "./build/index.js"
    },
    "./globals": {
      "types": "./build/globals.d.ts",
      "import": "./build/globals.js",
      "require": "./build/globals.cjs",
      "default": "./build/globals.js"
    },
    "./cli": {
      "types": "./build/cli.d.ts",
      "import": "./build/cli.js",
      "require": "./build/cli.cjs",
      "default": "./build/cli.js"
    },
    "./core": {
      "types": "./build/core.d.ts",
      "import": "./build/core.js",
      "require": "./build/core.cjs",
      "default": "./build/core.js"
    },
    "./package.json": "./package.json"
  },
  "bin": {
    "zx": "build/cli.js"
  },
  "man": "./man/zx.1",
  "files": [
    "build/3rd-party-licenses",
    "build/cli.js",
    "build/core.js",
    "build/deno.js",
    "build/globals.js",
    "build/index.js",
    "build/*.cjs",
    "build/*.d.ts",
    "man"
  ],
  "engines": {
    "node": ">= 12.17.0"
  },
  "scripts": {
    "fmt": "prettier --write .",
    "fmt:check": "prettier --check .",
    "prebuild": "rm -rf build",
    "build": "npm run build:versions && npm run build:js && npm run build:dts && npm run build:tests",
    "build:js": "node scripts/build-js.mjs --format=cjs --hybrid --entry='src/{cli,core,deps,globals,index,internals,util,vendor*}.ts' && npm run build:vendor",
    "build:vendor": "node scripts/build-js.mjs --format=cjs --entry=src/vendor-*.ts --bundle=all --external='./internals.ts'",
    "build:versions": "node scripts/build-versions.mjs",
    "build:tests": "node scripts/build-tests.mjs",
    "build:dts": "tsc --project tsconfig.json && node scripts/build-dts.mjs",
    "build:dcr": "docker build -f ./dcr/Dockerfile . -t zx",
    "build:jsr": "node scripts/build-jsr.mjs",
    "postbuild": "node scripts/build-clean.mjs",
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs",
    "docs:preview": "vitepress preview docs",
    "pretest": "npm run build",
    "test": "npm run test:size && npm run fmt:check && npm run test:unit && npm run test:types && npm run test:license",
    "test:npm": "node ./test/it/build-npm.test.js",
    "test:jsr": "node ./test/it/build-jsr.test.js",
    "test:dcr": "node ./test/it/build-dcr.test.js",
    "test:unit": "node --experimental-transform-types ./test/all.test.js",
    "test:coverage": "c8 -c .nycrc --check-coverage npm run test:unit",
    "test:circular": "madge --circular src/*",
    "test:types": "tsd",
    "test:license": "node ./test/extra.test.js",
    "test:audit": "npm audit fix",
    "test:size": "size-limit",
    "test:smoke:strip-types": "node --experimental-strip-types test/smoke/ts.test.ts",
    "test:smoke:tsx": "tsx test/smoke/ts.test.ts",
    "test:smoke:tsc": "cd test/smoke && mkdir -p node_modules && ln -s ../../../  ./node_modules/zx; ../../node_modules/typescript/bin/tsc -v && ../../node_modules/typescript/bin/tsc --esModuleInterop --module node16 --rootDir . --outdir ./temp ts.test.ts && node ./temp/ts.test.js",
    "test:smoke:ts-node": "cd test/smoke && node --loader ts-node/esm ts.test.ts",
    "test:smoke:bun": "bun test ./test/smoke/bun.test.js && bun ./test/smoke/node.test.mjs",
    "test:smoke:win32": "node ./test/smoke/win32.test.js",
    "test:smoke:cjs": "node ./test/smoke/node.test.cjs",
    "test:smoke:mjs": "node ./test/smoke/node.test.mjs",
    "test:smoke:deno": "deno test ./test/smoke/deno.test.js --allow-read --allow-sys --allow-env --allow-run",
    "test:workflow": "zizmor .github/workflows -v -p --min-severity=medium"
  },
  "devDependencies": {
    "@commitlint/cli": "^19.8.1",
    "@commitlint/config-conventional": "^19.8.1",
    "@size-limit/file": "11.2.0",
    "@types/fs-extra": "11.0.4",
    "@types/minimist": "1.2.5",
    "@types/node": "24.2.0",
    "@types/which": "3.0.4",
    "@webpod/ingrid": "1.1.1",
    "@webpod/ps": "0.1.4",
    "c8": "10.1.3",
    "chalk": "5.5.0",
    "create-require": "1.1.1",
    "cronometro": "5.3.0",
    "depseek": "0.4.3",
    "dts-bundle-generator": "9.5.1",
    "envapi": "0.2.3",
    "esbuild": "0.25.9",
    "esbuild-node-externals": "1.18.0",
    "esbuild-plugin-entry-chunks": "0.1.17",
    "esbuild-plugin-extract-helpers": "0.0.6",
    "esbuild-plugin-hybrid-export": "0.3.1",
    "esbuild-plugin-resolve": "2.0.0",
    "esbuild-plugin-transform-hook": "0.2.0",
    "esbuild-plugin-utils": "0.1.0",
    "fs-extra": "11.3.1",
    "get-port": "7.1.0",
    "globby": "14.1.0",
    "jsr": "0.13.5",
    "lefthook": "1.12.3",
    "madge": "8.0.0",
    "minimist": "1.2.8",
    "node-fetch-native": "1.6.7",
    "prettier": "3.6.2",
    "size-limit": "11.2.0",
    "ts-node": "10.9.2",
    "tsd": "0.33.0",
    "tsx": "4.20.4",
    "typescript": "5.9.2",
    "vitepress": "1.6.4",
    "which": "5.0.0",
    "yaml": "2.8.1",
    "zurk": "0.11.4"
  },
  "overrides": {
    "globby": {
      "fast-glob": "3.3.3"
    },
    "tsx": {
      "esbuild": "$esbuild"
    },
    "vite": {
      "esbuild": "$esbuild"
    },
    "@webpod/ps": {
      "zurk": "$zurk"
    }
  },
  "publishConfig": {
    "registry": "https://wombat-dressing-room.appspot.com"
  },
  "keywords": [
    "bash",
    "bin",
    "binary",
    "call",
    "child",
    "child_process",
    "exec",
    "execute",
    "invoke",
    "pipe",
    "process",
    "script",
    "shell",
    "spawn",
    "zx"
  ],
  "prettier": {
    "semi": false,
    "singleQuote": true,
    "endOfLine": "lf",
    "trailingComma": "es5"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/google/zx.git"
  },
  "homepage": "https://google.github.io/zx/",
  "author": "Anton Medvedev <anton@medv.io>",
  "license": "Apache-2.0",
  "volta": {
    "node": "22.12.0"
  },
  "tsd": {
    "compilerOptions": {
      "rootDir": "."
    }
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2021",
    "lib": ["ES2021"],
    "rootDir": "./src",
    "moduleResolution": "NodeNext",
    "module": "NodeNext",
    "strict": true,
    "outDir": "./build",
    "declaration": true,
    "emitDeclarationOnly": true,
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "types": ["node", "fs-extra"]
  },
  "include": ["./src/**/*"],
  "exclude": ["./src/globals.ts"]
}



================================================
FILE: .commitlintrc
================================================
{
  "extends": [
    "@commitlint/config-conventional"
  ],
  "rules": {
    "type-enum": [
      2,
      "always",
      [
        "build",
        "ci",
        "chore",
        "docs",
        "feat",
        "fix",
        "perf",
        "refactor",
        "revert",
        "style",
        "test"
      ]
    ],
  }
}



================================================
FILE: .node_version
================================================
22


================================================
FILE: .nycrc
================================================
{
  "reporter": ["html", "text"],
  "lines": 98,
  "branches": "90",
  "statements": "98",
  "exclude": [
    "build/deno.js",
    "build/vendor-extra.cjs",
    "build/vendor-core.cjs",
    "build/esblib.cjs",
    "test/**",
    "scripts",
    "src/util.ts",
    "src/core.ts",
    "src/index.ts",
    "src/vendor-extra.ts"
  ]
}



================================================
FILE: .prettierignore
================================================
node_modules/
build/
coverage/
package/
reports/
package-lock.json
yarn.lock
*.md



================================================
FILE: .size-limit.json
================================================
[
  {
    "name": "zx-lite",
    "path": [
      "build/3rd-party-licenses",
      "build/core.cjs",
      "build/core.js",
      "build/core.d.ts",
      "build/deno.js",
      "build/esblib.cjs",
      "build/util.cjs",
      "build/util.d.ts",
      "build/vendor-core.cjs",
      "build/vendor-core.d.ts",
      "README.md",
      "LICENSE"
    ],
    "limit": "124.85 kB",
    "brotli": false,
    "gzip": false
  },
  {
    "name": "js parts",
    "path": [
      "build/*.cjs",
      "build/cli.js",
      "build/core.js",
      "build/index.js",
      "build/globals.js",
      "build/deno.js"
    ],
    "limit": "814.851 kB",
    "brotli": false,
    "gzip": false
  },
  {
    "name": "libdefs",
    "path": "build/*.d.ts",
    "limit": "40.35 kB",
    "brotli": false,
    "gzip": false
  },
  {
    "name": "vendor",
    "path": "build/vendor-*.{cjs,d.ts}",
    "limit": "766.40 kB",
    "brotli": false,
    "gzip": false
  },
  {
    "name": "all",
    "path": [
      "build/3rd-party-licenses",
      "build/*.cjs",
      "build/*.d.ts",
      "build/cli.js",
      "build/core.js",
      "build/index.js",
      "build/globals.js",
      "build/deno.js",
      "man/*",
      "README.md",
      "LICENSE"
    ],
    "limit": "872.05 kB",
    "brotli": false,
    "gzip": false
  }
]



================================================
FILE: dcr/Dockerfile
================================================
FROM node:24-alpine

RUN apk add --no-cache bash

COPY ../build /zx/build
COPY ../package.json /zx/package.json
COPY ../LICENSE /zx/LICENSE
COPY ../README.md /zx/README.md

ENTRYPOINT ["node", "/zx/build/cli.js"]



================================================
FILE: docs/api.md
================================================
# API Reference

## `$.sync`
Zx provides both synchronous and asynchronous command executions, returns [`ProcessOutput`](./process-output) or [`ProcessPromise`](./process-promise) respectively.

```js
const list = await $`ls -la`
const dir = $.sync`pwd`
```

## `$({...})`

`$` object holds the default zx [configuration](./configuration), which is used for all execution. To specify a custom preset use `$` as factory:

```js
const $$ = $({
  verbose: false,
  env: {NODE_ENV: 'production'},
})

const env = await $$`node -e 'console.log(process.env.NODE_ENV)'`
const pwd = $$.sync`pwd`
const hello = $({quiet: true})`echo "Hello!"`
```

Moreover, presets are chainable:

```js
const $1 = $({ nothrow: true })
assert.equal((await $1`exit 1`).exitCode, 1)

const $2 = $1({ sync: true }) // Both {nothrow: true, sync: true} are applied
assert.equal($2`exit 2`.exitCode, 2)

const $3 = $({ sync: true })({ nothrow: true })
assert.equal($3`exit 3`.exitCode, 3)
```

### `$({input})`

The input option passes the specified `stdin` to the command.

```js
const p1 = $({ input: 'foo' })`cat`
const p2 = $({ input: Readable.from('bar') })`cat`
const p3 = $({ input: Buffer.from('baz') })`cat`
const p4 = $({ input: p3 })`cat`
const p5 = $({ input: await p3 })`cat`
```

### `$({signal})`

The signal option makes the process abortable.

```js
const {signal} = new AbortController()
const p = $({ signal })`sleep 9999`

setTimeout(() => signal.abort('reason'), 1000)
```

### `$({timeout})`

The timeout option makes the process autokillable after the specified delay.

```js
const p = $({timeout: '1s'})`sleep 999`
```

### `$({nothrow})`

The `nothrow` option suppresses errors and returns a `ProcessOutput` with details.

```js
const o1 = await $({nothrow: true})`exit 1`
o1.ok       // false
o1.exitCode // 1
o1.message  // exit code: 1 ...

const o2 = await $({nothrow: true, spawn() { throw new Error('BrokenSpawn') }})`echo foo`
o2.ok       // false
o2.exitCode // null
o2.message  // BrokenSpawn ...
```

The full options list:
```ts
interface Options {
  cwd:            string
  ac:             AbortController
  signal:         AbortSignal
  input:          string | Buffer | Readable | ProcessOutput | ProcessPromise
  timeout:        Duration
  timeoutSignal:  NodeJS.Signals
  stdio:          StdioOptions
  verbose:        boolean
  sync:           boolean
  env:            NodeJS.ProcessEnv
  shell:          string | true
  nothrow:        boolean
  prefix:         string
  postfix:        string
  quote:          typeof quote
  quiet:          boolean
  detached:       boolean
  preferLocal:    boolean | string | string[]
  spawn:          typeof spawn
  spawnSync:      typeof spawnSync
  store:          TSpawnStore
  log:            typeof log
  kill:           typeof kill
  killSignal:     NodeJS.Signals
  halt:           boolean
  delimiter:      string | RegExp
}
```
See also [Configuration](./configuration).

## `cd()`

Changes the current working directory.

```js
cd('/tmp')
await $`pwd` // => /tmp
```

Like `echo`, in addition to `string` arguments, `cd` accepts and trims
trailing newlines from `ProcessOutput` enabling common idioms like:

```js
cd(await $`mktemp -d`)
```

> ⚠️ `cd` invokes `process.chdir()` internally, so it does affect the global context. To keep `process.cwd()` in sync with separate `$` calls enable [syncProcessCwd()](#syncprocesscwd) hook.

## `fetch()`

A wrapper around the [node-fetch-native](https://www.npmjs.com/package/node-fetch-native)
package.

```js
const r1 = await fetch('https://example.com')
const json = await r1.json()

const r2 = await fetch('https://example.com', {
  signal: AbortSignal.timeout(5000),
})
```

For some cases, `text()` or `json()` can produce extremely large output that exceeds the string size limit.
Streams are just for that, so we've attached a minor adjustment to the `fetch` API to make it more pipe friendly.

```js
const p1 = fetch('https://example.com').pipe($`cat`)
const p2 = fetch('https://example.com').pipe`cat`
```

## `question()`

A wrapper around the [readline](https://nodejs.org/api/readline.html) API.

```js
const bear = await question('What kind of bear is best? ')
const selected = await question('Select an option:', {
  choices: ['A', 'B', 'C'],
})
```

## `sleep()`

A wrapper around the `setTimeout` function.

```js
await sleep(1000)
```

## `echo()`

A `console.log()` alternative which can take [ProcessOutput](#processoutput).

```js
const branch = await $`git branch --show-current`

echo`Current branch is ${branch}.`
// or
echo('Current branch is', branch)
```

## `stdin()`

Returns the stdin as a string.

```js
const content = JSON.parse(await stdin())
```

## `within()`

Creates a new async context.

```js
await $`pwd` // => /home/path
$.foo = 'bar'

within(async () => {
  $.cwd = '/tmp'
  $.foo = 'baz'

  setTimeout(async () => {
    await $`pwd` // => /tmp
    $.foo // baz
  }, 1000)
})

await $`pwd` // => /home/path
$.foo // still 'bar'
```

```js
await $`node --version` // => v20.2.0

const version = await within(async () => {
  $.prefix += 'export NVM_DIR=$HOME/.nvm; source $NVM_DIR/nvm.sh; nvm use 16;'

  return $`node --version`
})

echo(version) // => v16.20.0
```

## `syncProcessCwd()`

Keeps the `process.cwd()` in sync with the internal `$` current working directory if it is changed via [cd()](#cd).

```ts
import {syncProcessCwd} from 'zx'

syncProcessCwd()
syncProcessCwd(false) // pass false to disable the hook
```

> This feature is disabled by default because of performance overhead.

## `retry()`

Retries a callback for a few times. Will return the first
successful result, or will throw after the specified attempts count.

```js
const p = await retry(10, () => $`curl https://medv.io`)

// With a specified delay between attempts.
const p = await retry(20, '1s', () => $`curl https://medv.io`)

// With an exponential backoff.
const p = await retry(30, expBackoff(), () => $`curl https://medv.io`)
```

## `spinner()`

Starts a simple CLI spinner.

```js
await spinner(() => $`long-running command`)

// With a message.
await spinner('working...', () => $`sleep 99`)
```

And it's disabled for `CI` by default.

## `glob()`

The [globby](https://github.com/sindresorhus/globby) package.

```js
const packages = await glob(['package.json', 'packages/*/package.json'])
const markdowns = glob.sync('*.md') // sync API shortcut
```

## `which()`

The [which](https://github.com/npm/node-which) package.

```js
const node = await which('node')
```

If nothrow option is used, returns null if not found.

```js
const pathOrNull = await which('node', { nothrow: true })
```

## `ps`

The [@webpod/ps](https://github.com/webpod/ps) package to provide a cross-platform way to list processes.

```js
const all = await ps.lookup()
const nodejs = await ps.lookup({ command: 'node' })
const children = await ps.tree({ pid: 123 })
const fulltree = await ps.tree({ pid: 123, recursive: true })
```

## `kill()`

A process killer.

```js
await kill(123)
await kill(123, 'SIGKILL')
```

## `tmpdir()`

Creates a temporary directory.

```js
t1 = tmpdir()       // /os/based/tmp/zx-1ra1iofojgg/
t2 = tmpdir('foo')  // /os/based/tmp/zx-1ra1iofojgg/foo/
```

## `tmpfile()`

Temp file factory.

```js
f1 = tmpfile()         // /os/based/tmp/zx-1ra1iofojgg
f2 = tmpfile('f2.txt')  // /os/based/tmp/zx-1ra1iofojgg/foo.txt
f3 = tmpfile('f3.txt', 'string or buffer')
f4 = tmpfile('f4.sh', 'echo "foo"', 0o744) // executable
```

## `minimist`

The [minimist](https://www.npmjs.com/package/minimist) package.

```js
const argv = minimist(process.argv.slice(2), {})
```

## `argv`

A minimist-parsed version of the `process.argv` as `argv`.

```js
if (argv.someFlag) {
  echo('yes')
}
```

Use minimist options to customize the parsing:

```js
const myCustomArgv = minimist(process.argv.slice(2), {
  boolean: [
    'force',
    'help',
  ],
  alias: {
    h: 'help',
  },
})
```

## `chalk`

The [chalk](https://www.npmjs.com/package/chalk) package.

```js
console.log(chalk.blue('Hello world!'))
```

## `fs`

The [fs-extra](https://www.npmjs.com/package/fs-extra) package.

```js
const {version} = await fs.readJson('./package.json')
```

## `os`

The [os](https://nodejs.org/api/os.html) package.

```js
await $`cd ${os.homedir()} && mkdir example`
```

## `path`

The [path](https://nodejs.org/api/path.html) package.

```js
await $`mkdir ${path.join(basedir, 'output')}`
```

## `yaml`

The [yaml](https://www.npmjs.com/package/yaml) package.

```js
console.log(YAML.parse('foo: bar').foo)
```

## `dotenv`

The [envapi](https://www.npmjs.com/package/envapi) package.  
An API to interact with environment vars in [dotenv](https://www.npmjs.com/package/dotenv) format.

```js
// parse
const raw = 'FOO=BAR\nBAZ=QUX'
const data = dotenv.parse(raw) // {FOO: 'BAR', BAZ: 'QUX'}
await fs.writeFile('.env', raw)

// load
const env = dotenv.load('.env')
await $({ env })`echo $FOO`.stdout // BAR

// config
dotenv.config('.env')
process.env.FOO // BAR
```

## `versions`
Exports versions of the zx dependencies.

```ts
import { versions } from 'zx'

versions.zx     // 8.7.2
versions.chalk  // 5.4.1
```

## `quote()`

Default bash quoting function.

```js
quote("$FOO") // "$'$FOO'"
```

## `quotePowerShell()`

PowerShell specific quoting.

```js
quotePowerShell("$FOO") // "'$FOO'"
```

## `useBash()`

Enables bash preset: sets `$.shell` to `bash` and `$.quote` to `quote`.

```js
useBash()
```

## `usePowerShell()`

Switches to PowerShell. Applies the `quotePowerShell` for quoting.

```js
usePowerShell()
```

## `usePwsh()`

Sets pwsh (PowerShell v7+) as `$.shell` default.

```js
usePwsh()
```



================================================
FILE: docs/architecture.md
================================================
# The zx architecture
This section helps to better understand the `zx` concepts and logic, and will be useful for those who want to become a project contributor, make tools based on it, or create something similar from scratch.

## High-level modules
| Module                                                                  | Description                                                         |
|-------------------------------------------------------------------------|---------------------------------------------------------------------|
| [zurk](https://github.com/webpod/zurk)                                  | Execution engine for spawning and managing child processes.         |
| [./src/core.ts](https://github.com/google/zx/blob/main/src/core.ts)     | `$` factory, presets, utilities, high-level APIs.                   |
| [./src/goods.ts](https://github.com/google/zx/blob/main/src/goods.ts)   | Utilities for common tasks like fs ops, glob search, fetching, etc. |
| [./src/cli.ts](https://github.com/google/zx/blob/main/src/cli.ts)       | CLI interface and scripts pre-processors.                           |
| [./src/deps.ts](https://github.com/google/zx/blob/main/src/deps.ts)     | Dependency analyzing and installation.                              |
| [./src/vendor.ts](https://github.com/google/zx/blob/main/src/vendor.ts) | Third-party libraries.                                              |
| [./src/utils.ts](https://github.com/google/zx/blob/main/src/utils.ts)   | Generic helpers.                                                    |
| [./src/md.ts](https://github.com/google/zx/blob/main/src/md.ts)         | Markdown scripts extractor.                                         |
| [./src/error.ts](https://github.com/google/zx/blob/main/src/error.ts)   | Error handling and formatting.                                      |
| [./src/global.ts](https://github.com/google/zx/blob/main/src/global.ts) | Global injectors.                                                   |


## Core design

### `Options`
A set of options for `$` and `ProcessPromise` configuration. `defaults` holds the initial library preset. `Snapshot` captures the current `Options `context and attaches isolated subparts.

### `$`
A piece of template literal magic.
```ts
interface Shell<
  S = false,
  R = S extends true ? ProcessOutput : ProcessPromise,
> {
  (pieces: TemplateStringsArray, ...args: any[]): R
  <O extends Partial<Options> = Partial<Options>, R = O extends { sync: true } ? Shell<true> : Shell>(opts: O): R
  sync: {
    (pieces: TemplateStringsArray, ...args: any[]): ProcessOutput
    (opts: Partial<Omit<Options, 'sync'>>): Shell<true>
  }
}

$`cmd ${arg}`             // ProcessPromise
$(opts)`cmd ${arg}`       // ProcessPromise
$.sync`cmd ${arg}`        // ProcessOutput
$.sync(opts)`cmd ${arg}`  // ProcessOutput
```

The `$` factory creates `ProcessPromise` instances and bounds with snapshot-context via `Proxy` and `AsyncLocalStorage`. The trick:
```ts
const storage = new AsyncLocalStorage<Options>()

const getStore = () => storage.getStore() || defaults

function within<R>(callback: () => R): R {
  return storage.run({ ...getStore() }, callback)
}
// Inside $ factory ...
const opts = getStore()
if (!Array.isArray(pieces)) {
  return function (this: any, ...args: any) {
    return within(() => Object.assign($, opts, pieces).apply(this, args))
  }
}
```

### `ProcessPromise` 
A promise-inherited class represents and operates a child process, provides methods for piping, killing, response formatting.

#### Lifecycle
| Stage        | Description            |
|--------------|------------------------|
| `initial`    | Blank instance         |
| `halted`     | Awaits running         |
| `running`    | Process in action      |
| `fulfilled`  | Successfully completed |
| `rejected`   | Failed                 |

| Gear         | Description                                                                                 |
|--------------|---------------------------------------------------------------------------------------------|
| `build()`    | Produces `cmd` from template and context, applies `quote` to arguments                      |
| `run()`      | Spawns the process and captures its data via `zurk` events listeners                        |
| `finalize()` | Assigns the result to the instance: analyzes status code, invokes `_resolve()`, `_reject()` |

#### Piping
The remarkable part is `pipe()` and `_pipe()` interactions: the first provides a facade, the second binds different streams with acceptors. We use initialization inside static scope to comply with TS method visibility restrictions and to avoid extra `Proxy` usage:
```ts
const p = $`cmd`
const crits = await p.pipe.stderr`grep critical`
const names = await p.pipe.stdout`grep name`
```

Another `pipe()` superpower is an internal recorder. It allows binding processes at any stage w/o data loss, even if settled.
```ts
const onData = (chunk: string | Buffer) => from.write(chunk)
const fill = () => {
  for (const chunk of source) from.write(chunk)
}

ee.once(source, () => {
  fill()                    // 1. Pulling previous records
  ee.on(source, onData)     // 2. Listening for new data
}).once('end', () => {
  ee.removeListener(source, onData)
  from.end()
})
```

Wayback machine in action:
```ts
const p = $`cmd`
await p
await p.pipe`grep name` // Still works, but `p` is settled
```

### `ProcessOutput`
A class that represents the output of a `ProcessPromise`. It provides methods to access the process's stdout, stderr, exit code and extra methods for formatting the output and checking the process's success.

### `Fail`
Consolidates error handling functionality across the zx library: errors codes mapping, formatting, stack parsing.

## CLI
zx provides CLI with embedded script preprocessor to construct an execution context (apply presets, inject global vars) and to install the required deps. Then runs the specified script.

| Helper         | Description                                                                                                                                                                                                                                               |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `main()`       | Initializes a preset from flags, env vars and pushes the reader.                                                                                                                                                                                                |
| `readScript()` | Fetches, parses and transforms the specified source into a runnable form. `stdin` reader, `https` loader and `md` transformer act right here. Deps analyzer internally relies on [depseek](https://www.npmjs.com/package/depseek) and inherits its limitations |
| `runScript()`  | Executes the script in the target context via async `import()`, handles temp assets after.                                                                                                                                                                 |


## Building
In the early stages of the project, we [had some difficulties](https://dev.to/antongolub/how-and-why-do-we-bundle-zx-1ca6) with zx packaging. We couldn't find a suitable tool for assembly, so we made our own toolkit based on [esbuild](https://github.com/evanw/esbuild) and [dts-bundle-generator](https://github.com/timocov/dts-bundle-generator). This process is divided into several scripts.

| Script                                                                                       | Description                                                            |
|----------------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| [`./scripts/build-dts.mjs`](https://github.com/google/zx/blob/main/scripts/build-dts.mjs)    | Extracts and merges 3rd-party types, generates `dts` files.            |
| [`./scripts/build-js.mjs`](https://github.com/google/zx/blob/main/scripts/build-js.mjs)      | Produces [hybrid bundles](./setup#hybrid) for each package entry point |
| [`./scripts/build-jsr.mjs`](https://github.com/google/zx/blob/main/scripts/build-jsr.mjs)    | Builds extra assets for [JSR](https://jsr.io/@webpod/zx) publishing    |
| [`./scripts/build-tests.mjs`](https://github.com/google/zx/blob/main/scripts/build-test.mjs) | Generates autotests to verify exports consistency                      |

Corresponding tasks are defined in the `package.json.scripts`:
```json
{
  "prebuild":     "rm -rf build",
  "build":        "npm run build:js && npm run build:dts && npm run build:tests",
  "build:js":     "node scripts/build-js.mjs --format=cjs --hybrid --entry=src/*.ts:!src/error.ts:!src/repl.ts:!src/md.ts:!src/log.ts:!src/globals-jsr.ts:!src/goods.ts && npm run build:vendor",
  "build:vendor": "node scripts/build-js.mjs --format=cjs --entry=src/vendor-*.ts --bundle=all --external='./internals.ts'",
  "build:tests":  "node scripts/build-tests.mjs",
  "build:dts":    "tsc --project tsconfig.json && rm build/repl.d.ts build/globals-jsr.d.ts && node scripts/build-dts.mjs",
  "build:dcr":    "docker build -f ./dcr/Dockerfile . -t zx",
  "build:jsr":    "node scripts/build-jsr.mjs"
}
```

## Testing

We understand the importance, impact and risks of the tool and invest significant efforts in comprehensive research of its quality, reliability and safety. Therefore, we use an extensive set of tools and testing scenarios.

First, we inspect not how the code was written, but how it actually works. Tests mainly focus on prod bundles, `pretest` ensures they are actual.
```json
{
  "pretest": "npm run build"
}
```

A basic set of implementation correctness checks is provided by unit tests. We also evaluate coverage to ensure that areas of code are not missed. 
```json
{
  "test:unit": "node --experimental-transform-types ./test/all.test.js",
  "test:coverage": "c8 -c .nycrc --check-coverage npm run test:unit"
}
```

Next, we control the contents of all the artifacts and examine their functionality.
```json
{
  "test:npm": "node ./test/it/build-npm.test.js",
  "test:jsr": "node ./test/it/build-jsr.test.js",
  "test:dcr": "node ./test/it/build-dcr.test.js"
}
```

Bundle code duplication issues are highlighted through size check.
```json
{
  "test:size": "size-limit"
}
```

Static analyzers are responsible for code quality.
```json
{
  "fmt:check": "prettier --check .",
  "test:circular": "madge --circular src/*"
}
```

Type checking examines declarations and compatibility with different loaders and transpilers.
```json
{
  "test:types": "tsd",
  "test:smoke:strip-types": "node --experimental-strip-types test/smoke/ts.test.ts",
  "test:smoke:tsx": "tsx test/smoke/ts.test.ts",
  "test:smoke:tsc": "cd test/smoke && mkdir -p node_modules && ln -s ../../../  ./node_modules/zx; ../../node_modules/typescript/bin/tsc -v && ../../node_modules/typescript/bin/tsc --esModuleInterop --module node16 --rootDir . --outdir ./temp ts.test.ts && node ./temp/ts.test.js",
  "test:smoke:ts-node": "cd test/smoke && node --loader ts-node/esm ts.test.ts"
}
```

We also check compatibility with all the target [runtimes x OS variants](https://github.com/google/zx/blob/main/.github/workflows/test.yml).
```json
{
  "test:smoke:bun": "bun test ./test/smoke/bun.test.js && bun ./test/smoke/node.test.mjs",
  "test:smoke:win32": "node ./test/smoke/win32.test.js",
  "test:smoke:deno": "deno test ./test/smoke/deno.test.js --allow-read --allow-sys --allow-env --allow-run",
}
```

CJS and EMS exports are verified separately.
```json
{
  "test:smoke:cjs": "node ./test/smoke/node.test.cjs",
  "test:smoke:mjs": "node ./test/smoke/node.test.mjs"
}
```

Finally, we check the license and supply chain security issues.
```json
{
  "test:license": "node ./test/extra.test.js",
  "test:audit": "npm audit fix",
  "test:workflow": "zizmor .github/workflows -v -p --min-severity=medium"
}
```



================================================
FILE: docs/cli.md
================================================
# CLI Usage

Zx provides a CLI for running scripts. It comes with the package and can be used as `zx` executable (if referenced in package.json `"scripts"`, installed [globally](/setup#install) or added to the `$PATH` somehow).

```sh
zx script.mjs
```

`npx` or `node` inits are valid too.
```sh
npx zx script.mjs
node -r zx/globals script.mjs
node --import zx/globals script.mjs
```

## No extensions

If the script does not have a file extension (like `.git/hooks/pre-commit`), zx
assumes that it is
an [ESM](https://nodejs.org/api/modules.html#modules_module_createrequire_filename)
module unless the `--ext` option is specified.

## Non-standard extension
`zx` internally loads scripts via `import` API, so you can use any extension supported by the runtime (nodejs, deno, bun) or apply a [custom loader](https://nodejs.org/api/cli.html#--experimental-loadermodule).
However, if the script has a non-js-like extension (`/^\.[mc]?[jt]sx?$/`) and the `--ext` is specified, it will be used.

```bash
zx script.zx           # Unknown file extension "\.zx"
zx --ext=mjs script.zx # OK
```

## Markdown
The CLI supports [markdown](/markdown) files and interprets `ts`, `js` and `bash` code blocks as scripts.

```bash
zx docs/markdown.md
```

## Remote scripts

If the argument to the `zx` executable starts with `https://`, the file will be
downloaded and executed.

```bash
zx https://medv.io/game-of-life.js
```

## Scripts from stdin

The `zx` supports executing scripts from stdin.

```js
zx << 'EOF'
await $`pwd`
EOF
```

## `--eval`

Evaluate the following argument as a script.

```bash
cat package.json | zx --eval 'const v = JSON.parse(await stdin()).version; echo(v)'
```

## `--repl`
Starts zx in [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) mode.

## `--install`

```js
// script.mjs:
import sh from 'tinysh'

sh.say('Hello, world!')
```

Add `--install` flag to the `zx` command to install missing dependencies
automatically.

```bash
zx --install script.mjs
```

You can also specify needed version by adding comment with `@` after
the import.

```js
import sh from 'tinysh' // @^1
```

## `--registry`

By default, `zx` uses `https://registry.npmjs.org` as a registry. Customize if needed.

```bash
zx --registry=https://registry.yarnpkg.com script.mjs
```

## `--quiet`

Suppress any outputs.

## `--verbose`

Enable verbose mode.

## `--shell`

Specify a custom shell binary path. By default, zx refers to `bash`.

```bash
zx --shell=/bin/another/sh script.mjs
```

## `--prefer-local, -l`

Prefer locally installed packages and binaries.

```bash
zx --prefer-local=/external/node_modules/or/nm-root script.mjs
```

## `--prefix & --postfix`

Attach a command to the beginning or the end of every command.

```bash
zx --prefix='echo foo;' --postfix='; echo bar' script.mjs
```

## `--cwd`

Set the current working directory.

```bash
zx --cwd=/foo/bar script.mjs
```

## `--env`
Specify an env file.

```bash
zx --env=/path/to/some.env script.mjs
```

When `cwd` option is specified, it will be used as base path:  
`--cwd='/foo/bar' --env='../.env'` → `/foo/.env`

## `--ext`

Overrides the default script extension (`.mjs`).

## `--version, -v`

Print the current `zx` version.

## `--help, -h`

Print help notes.

## Environment variables
All the previously mentioned options can be set via the corresponding `ZX_`-prefixed environment variables.

```bash
ZX_VERBOSE=true ZX_SHELL='/bin/bash' zx script.mjs
```
    
```yaml
steps:
  - name: Run script
    run: zx script.mjs
    env:
      ZX_VERBOSE: true
      ZX_SHELL: '/bin/bash'
```

## `__filename & __dirname`

In [ESM](https://nodejs.org/api/esm.html) modules, Node.js does not provide
`__filename` and `__dirname` globals. As such globals are really handy in scripts,
zx provides these for use in `.mjs` files (when using the `zx` executable).

## `require()`

In [ESM](https://nodejs.org/api/modules.html#modules_module_createrequire_filename)
modules, the `require()` function is not defined.
The `zx` provides `require()` function, so it can be used with imports in `.mjs`
files (when using `zx` executable).

```js
const {version} = require('./package.json')
```



================================================
FILE: docs/configuration.md
================================================
# Configuration

## `$.shell`

Specifies what shell is used. Default is `which bash`.

```js
$.shell = '/usr/bin/bash'
```

Or use a CLI argument: `--shell=/bin/bash`

## `$.spawn`

Specifies a `spawn` api. Defaults to native `child_process.spawn`.

To override a sync API implementation, set `$.spawnSync` correspondingly.

## `$.kill`
Specifies a `kill` function. The default implements _half-graceful shutdown_ via `ps.tree()`. You can override with more sophisticated logic.

```js
import treekill from 'tree-kill'

$.kill = (pid, signal = 'SIGTERM') => {
  return new Promise((resolve, reject) => {
    treekill(pid, signal, (err) => {
      if (err) reject(err)
      else resolve()
    })
  })
}
```

## `$.prefix`

Specifies the command that will be prefixed to all commands run.

Default is `set -euo pipefail;`.

Or use a CLI argument: `--prefix='set -e;'`

## `$.postfix`

Like a `$.prefix`, but for the end of the command.

```js
$.postfix = '; exit $LastExitCode' // for PowerShell compatibility
```

## `$.preferLocal`

Specifies whether to prefer `node_modules/.bin` located binaries over globally system installed ones.

```js
$.preferLocal = true

await $`c8 npm test`
```

You can also specify a directory to search for local binaries:

```js
$.preferLocal = '/some/to/bin'
$.preferLocal = ['/path/to/bin', '/another/path/bin']
```

## `$.quote`

Specifies a function for escaping special characters during
command substitution.

## `$.verbose`

Specifies verbosity. Default is `false`.

In verbose mode, `zx` prints all executed commands alongside with their
outputs.

Or use the CLI argument: `--verbose` to set `true`.

## `$.quiet`

Suppresses all output. Default is `false`.

Via CLI argument: `--quiet` sets `$.quiet = true`.

## `$.env`

Specifies an environment variables map.

Defaults to `process.env`.

## `$.cwd`

Specifies a current working directory of all processes created with the `$`.

The [cd()](#cd) func changes only `process.cwd()` and if no `$.cwd` specified,
all `$` processes use `process.cwd()` by default (same as `spawn` behavior).

## `$.log`

Specifies a [logging function](src/log.ts).

```ts
import {LogEntry, log} from 'zx/core'

$.log = (entry: LogEntry) => {
  switch (entry.kind) {
    case 'cmd':
      // for example, apply custom data masker for cmd printing
      process.stderr.write(masker(entry.cmd))
      break
    default:
      log(entry)
  }
}
```

The log mostly acts like a debugger, so by default it uses `process.error` for output.
Override the `$.log.output` to change the stream.

```ts
$.log.output = process.stdout
```

Define `$.log.formatters` to customize each log entry kind printing:

```ts
$.log.formatters = {
  cmd: (entry: LogEntry) => `CMD: ${entry.cmd}`,
  fetch: (entry: LogEntry) => `FETCH: ${entry.url}`
}
```

## `$.timeout`

Specifies a timeout for the command execution.

```js
$.timeout = '1s'
$.timeoutSignal= 'SIGKILL'

await $`sleep 999`
```

## `$.delimiter`
Specifies a delimiter for splitting command output into lines.
Defaults to `\r?\n` (newline or carriage return + newline).

```js
$.delimiter = /\0/        // null character

await $`find ./ -type f -print0 -maxdepth 1`
```

## `$.defaults`

Holds default configuration values. They will be used if the corresponding
`$` options are not specified.

```ts
$.defaults = {
  cwd:            process.cwd(),
  env:            process.env,
  verbose:        false,
  quiet:          false,
  sync:           false,
  shell:          true,
  prefix:         'set -euo pipefail;',   // for bash
  postfix:        '; exit $LastExitCode', // for powershell
  nothrow:        false,
  stdio:          'pipe', // equivalent to ['pipe', 'pipe', 'pipe']
  detached:       false,
  preferLocal:    false,
  spawn:          childProcess.spawn,
  spawnSync:      childProcess.spawnSync,
  log:            $.log,
  kill:           $.kill,
  killSignal:     'SIGTERM',
  timeoutSignal:  'SIGTERM',
  delimiter:      /\r?\n/,
}
```



================================================
FILE: docs/contribution.md
================================================
# Contribution Guide

zx is a fully [open-source project](https://github.com/google/zx), which is developing by the community for the community. 
We welcome contributions of any kind, including but not limited to:
* Bug reports
* Feature requests
* Code contributions
* Documentation improvements
* Discussions

https://google.github.io/zx/contribution

## Community Guidelines

This project follows [Google's Open Source Community Guidelines](https://opensource.google/conduct/).
In short: all contributors are treated with respect and fairness.

## Contributor License Agreement

Contributions to this project must be accompanied by a Contributor License
Agreement. You (or your employer) retain the copyright to your contribution;
this simply gives us permission to use and redistribute your contributions as
part of the project. Head over to <https://cla.developers.google.com/> to see
your current agreements on file or to sign a new one.

You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.

## How to Contribute
Before proposing changes, look for similar ones in the project's [issues](https://github.com/google/zx/issues) and [pull requests](https://github.com/google/zx/pulls). If you can't decide, create a new [discussion](https://github.com/google/zx/discussions) topic, and we will help you figure it out. Dive also into [architecture notes](/architecture) to observe design concepts. When ready to move on:

* Prepare your development environment.
  * Switch to the recommended version of Node.js
    * Install manually `Node.js >= 22`.
    * Delegate the routine to any version manager, that [supports .node_version config](https://stackoverflow.com/questions/27425852/what-uses-respects-the-node-version-file)
    * Use [Volta](https://volta.sh/), the target version will be set automatically from the `package.json`
  * Bash is essential for running zx scripts. Linux and macOS users usually have it installed by default. Consider using [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install) or [Git Bash](https://git-scm.com/downloads) if you are on Windows.
* Fork [the repository](https://github.com/google/zx).
* Create a new branch.

* Make your changes.
  * If you are adding a new feature, please include additional tests. The coverage threshold is 98%.
  * Create a [conventional-commits](https://www.conventionalcommits.org/en/v1.0.0/) compliant messages.
* Ensure that everything is working:
  * `npm run fmt` to format your code.
  * `npm run test:coverage` to run the tests.
* Push the changes to your fork.
* Create a pull request.
  * Describe your changes in detail.
  * Reference any related issues if applicable.

## Code Reviews

All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult [GitHub Help](https://help.github.com/articles/about-pull-requests/) for more information on using pull requests.

## License

The project is licensed under the [Apache-2.0](https://github.com/google/zx?tab=Apache-2.0-1-ov-file#readme)



================================================
FILE: docs/faq.md
================================================
# FAQ

## Passing env variables

```js
process.env.FOO = 'bar'
await $`echo $FOO`
```

## Passing array of values

When passing an array of values as an argument to `$`, items of the array will
be escaped
individually and concatenated via space.

Example:

```js
const files = [...]
await $`tar cz ${files}`
```

## Importing into other scripts

It is possible to make use of `$` and other functions via explicit imports:

```js
#!/usr/bin/env node
import {$} from 'zx'

await $`date`
```

## Attaching a profile

By default `child_process` does not include aliases and bash functions.
But you are still able to do it by hand. Just attach necessary directives
to the `$.prefix`.

```js
$.prefix += 'export NVM_DIR=$HOME/.nvm; source $NVM_DIR/nvm.sh; '
await $`nvm -v`
```

## Using GitHub Actions

The default GitHub Action runner comes with `npx` installed.

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
#      - uses: actions/setup-node@v4
#        with:
#          node-version: 22

      - name: Build with zx
        env:
          FORCE_COLOR: 3
        run: |
          npx zx <<'EOF'
          await $`...`
          EOF
```

## Verbose and Quiet
zx has internal logger, which captures events if a condition is met:

| Event  | Verbose | Quiet   | Description                  |
|--------|---------|---------|------------------------------|
| stdout | `true`  | `false` | Spawned process stdout       |
| stderr | `any`   | `false` | Process stderr data          |
| cmd    | `true`  | `false` | Command execution            |
| fetch  | `true`  | `false` | Fetch resources by http(s)   |
| cd     | `true`  | `false` | Change directory             |
| retry  | `true`  | `false` | Capture exec error           |
| custom | `true`  | `false` | User-defined event           |

By default, both `$.verbose` and `$.quiet` options are `false`, so only `stderr` events are written. Any output goes to the `process.stderr` stream.

You may control this flow globally or in-place
```js
// Global debug mode on
$.verbose = true
await $`echo hello`

// Suppress the particular command
await $`echo fobar`.quiet()

// Suppress everything
$.quiet = true
await $`echo world`

// Turn on in-place debug
await $`echo foo`.verbose()
```

You can also override the default logger with your own:
```js
// globally
$.log = (entry) => {
  switch (entry.kind) {
    case 'cmd':
      console.log('Command:', entry.cmd)
      break
    default:
      console.warn(entry)
  }
}
// or in-place
$({log: () => {}})`echo hello`
```

## Canary / Beta / RC builds

Impatient early adopters can try the experimental zx versions.
But keep in mind: these builds are ⚠️️__beta__ in every sense.

```bash
npm i zx@dev
npx zx@dev --install --quiet <<< 'import _ from "lodash" /* 4.17.15 */; console.log(_.VERSION)'
```



================================================
FILE: docs/getting-started.md
================================================
# Getting Started

## Overview

```js
#!/usr/bin/env zx

await $`cat package.json | grep name`

const branch = await $`git branch --show-current`
await $`dep deploy --branch=${branch}`

await Promise.all([
  $`sleep 1; echo 1`,
  $`sleep 2; echo 2`,
  $`sleep 3; echo 3`,
])

const name = 'foo bar'
await $`mkdir /tmp/${name}`
```

Bash is great, but when it comes to writing more complex scripts,
many people prefer a more convenient programming language.
JavaScript is a perfect choice, but the Node.js standard library
requires additional hassle before using. The `zx` package provides
useful wrappers around `child_process`, escapes arguments and
gives sensible defaults.

## Install

```bash
npm install zx
```
or many [other ways](/setup)

## Usage

Write your scripts in a file with an `.mjs` extension in order to
use `await` at the top level. If you prefer the `.js` extension,
wrap your scripts in something like `void async function () {...}()`. [TypeScript](./typescript.md) is also supported.

Add the following shebang to the beginning of your `zx` scripts:

```bash
#!/usr/bin/env zx
```

Now you will be able to run your script like so:

```bash
chmod +x ./script.mjs
./script.mjs
```

Or via the [CLI](cli.md):

```bash
zx ./script.mjs
```

All functions (`$`, `cd`, `fetch`, etc) are available straight away
without any imports.

Or import globals explicitly (for better autocomplete in VS Code).

```js
import 'zx/globals'
```

### ``$`command` ``

Executes a given command using the `spawn` func
and returns [`ProcessPromise`](process-promise.md). It supports both sync and async modes.

```js
const list = await $`ls -la`
const dir = $.sync`pwd`
```

Everything passed through `${...}` will be automatically escaped and quoted.

```js
const name = 'foo & bar'
await $`mkdir ${name}`
```

**There is no need to add extra quotes.** Read more about it in
[quotes](quotes.md).

You can pass an array of arguments if needed:

```js
const flags = [
  '--oneline',
  '--decorate',
  '--color',
]
await $`git log ${flags}`
```

In async mode, zx awaits any `thenable` in literal before executing the command.
```js
const a1 = $`echo foo`
const a2 = new Promise((resolve) => setTimeout(resolve, 20, ['bar', 'baz']))

await $`echo ${a1} ${a2}` // foo bar baz
```

If the executed program returns a non-zero exit code,
[`ProcessOutput`](#processoutput) will be thrown.

```js
try {
  await $`exit 1`
} catch (p) {
  console.log(`Exit code: ${p.exitCode}`)
  console.log(`Error: ${p.stderr}`)
}
```

### `ProcessOutput`

```ts
class ProcessOutput {
  readonly stdout: string
  readonly stderr: string
  readonly signal: string
  readonly exitCode: number
  // ...
  toString(): string // Combined stdout & stderr.
  valueOf(): string  // Returns .toString().trim()
}
```

The output of the process is captured as-is. Usually, programs print a new
line `\n` at the end.
If `ProcessOutput` is used as an argument to some other `$` process,
**zx** will use stdout and trim the new line.

```js
const date = await $`date`
await $`echo Current date is ${date}.`
```

## License

[Apache-2.0](https://github.com/google/zx/blob/main/LICENSE)

Disclaimer: _This is not an officially supported Google product._



================================================
FILE: docs/index.md
================================================
---
# https://vitepress.dev/reference/default-theme-home-page
layout: home
titleTemplate: google/zx

hero:
  name: "zx"
  text: "A tool for writing better scripts"
  image:
    src: /img/logo.svg
    alt: Zx Logo
  actions:
    - theme: brand
      text: Documentation
      link: /getting-started

features:
  - title: Simple
    details: Write your scripts in a familiar language.
  - title: Powerful
    details: Interact with the full ecosystem of JS libraries.
  - title: Batteries included
    details: Everything you need, right out of the box.
---



================================================
FILE: docs/known-issues.md
================================================
# Known Issues

## Output gets truncated

This is a known issue with `console.log()` (see [nodejs/node#6379](https://github.com/nodejs/node/issues/6379)).
It's caused by different behaviour of `console.log()` writing to the terminal vs
to a file. If a process calls `process.exit()`, buffered output will be truncated.
To prevent this, the process should use `process.exitCode = 1` and wait for the
process to exit itself. Or use something like [exit](https://www.npmjs.com/package/exit) package.

Workaround is to write to a temp file:
```js
const tmp = await $`mktemp` // Creates a temp file.
const {stdout} = await $`cmd > ${tmp}; cat ${tmp}`
```

## Colors in subprocess

You may see what tools invoked with `await $` don't show colors, compared to
what you see in a terminal. This is because, the subprocess does not think it's
a TTY and the subprocess turns off colors. Usually there is a way force
the subprocess to add colors.

```js
process.env.FORCE_COLOR='1'
await $`cmd`
```



================================================
FILE: docs/lite.md
================================================
# zx@lite

Just core functions without extras:
* ~7x smaller than the full version
* No CLI, no docs, no manpage assets embedded
* Same package name, but different publish channel — `@lite`
* Less code — ~~less risks~~ faster and more reliable ISEC audit
* Recommended for custom toolkits based on zx

```sh
npm i zx@lite
npm i zx@8.5.5-lite
```
Detailed comparison: [versions](./versions)

```js
import { $ } from 'zx'
await $`echo foo`
```

### Range of choice
**tool size ← [`child_process`](https://nodejs.org/api/child_process.html) [`zurk`](https://github.com/webpod/zurk) `zx@lite` `zx`  → built-in functionality** 



================================================
FILE: docs/markdown.md
================================================
# Markdown Scripts

Imagine a script with code blocks, formatted comments, schemas, illustrations, etc. [Markdown](https://en.wikipedia.org/wiki/Markdown) is right for this purpose.
Combine `ts`, `js`, `bash` sections to produce a single zx scenario. For example:

````text
# Some script
`ls` — is an unix command to get directory contents. Let's see how to use it in `zx`:

```js
// ts, js, cjs, mjs, etc
const {stdout} = await $`ls -l`
console.log('directory contents:', stdout)
```

This part invokes the same command in a different way:
```bash
# bash syntax
ls -l
```
````

And how it looks like:

> # Some script
> `ls` — is an unix command to get directory contents. Let's see how to use it in `zx`:
> ```js
> // ts, js, cjs, mjs, etc
> const {stdout} = await $`ls -l`
> console.log('directory contents:', stdout)
> ```
>
> This part invokes the same command in a different way:
> ```bash
> # bash syntax
> ls -l
> ```

The rest is simple: just run via `zx` command:
```bash 
zx script.md
```

## Hints
You can use imports here as well:

```js
await import('chalk')
```

`js`, `javascript`, `ts`, `typescript`, `sh`, `shell`, `bash` code blocks will be executed by zx. 

```bash
VAR=$(date)
echo "$VAR" | wc -c
```

Other kinds are ignored:

```css
body .hero {
  margin: 42px;
}
```

The `__filename` will be pointed to **markdown.md**:

```js
console.log(chalk.yellowBright(__filename))
```




================================================
FILE: docs/migration-from-v7.md
================================================
# Migration from v7 to v8

[v8.0.0 release](https://github.com/google/zx/releases/tag/8.0.0) brought many features, improvements, optimizations and fixes, but also has introduced a few breaking changes. Fortunately, everything can be restored and legacy v7 scripts can still run with minor configurations.

1. `$.verbose` is set to `false` by default, but errors are still printed to `stderr`. Set `$.quiet = true` to suppress any output.
```js
$.verbose = true // everything works like in v7

$.quiet = true   // to completely turn off logging
```

2. `ssh` API was dropped. Install [webpod](https://github.com/webpod/webpod) package instead.
```js
// import {ssh} from 'zx' ↓
import {ssh} from 'webpod'

const remote = ssh('user@host')
await remote`echo foo`
```

3. zx is not looking for `PowerShell` anymore, on Windows by default. If you still need it, use the `usePowerShell` helper to enable:

```js
import { usePowerShell, useBash } from 'zx'

usePowerShell() // to enable powershell
useBash()       // switch to bash, the default
```

To look for modern [PowerShell v7+](https://github.com/google/zx/pull/790), invoke `usePwsh()` helper instead:

```js
import { usePwsh } from 'zx'

usePwsh()
```

4. Process cwd synchronization between `$` invocations is now disabled by default. This functionality is provided via an async hook and can now be controlled directly.

```js
import { syncProcessCwd } from 'zx'

syncProcessCwd() // restores legacy v7 behavior
```

# 🚀
Keep in mind, v7 is in maintenance mode, so it will not receive any new enhancements. We encourage you to upgrade to the latest: it's [16x smaller](https://dev.to/antongolub/how-and-why-do-we-bundle-zx-1ca6), faster, safer, more reliable and useful in a [wider range of practical scenarios](https://github.com/google/zx/releases).



================================================
FILE: docs/process-output.md
================================================
# Process Output

Represents a cmd execution result.

```ts
const p = $`command` // ProcessPromise
const o = await p     // ProcessOutput
```

```ts
interface ProcessOutput extends Error {
  // Exit code of the process: 0 for success, non-zero for failure
  exitCode: number
  
  // Signal that caused the process to exit: SIGTERM, SIGKILL, etc.
  signal: NodeJS.Signals | null
  
  // Holds the stdout of the process
  stdout: string
  
  // Process errors are written to stderr
  stderr: string

  buffer(): Buffer

  json<T = any>(): T

  blob(type = 'text/plain'): Blob
  
  text(encoding: Encoding = 'utf8'): string

  // Output lines splitted by newline
  lines(delimiter?: string | RegExp): string[]
  
  // combined stdout and stderr
  toString(): string

  // Same as toString() but trimmed
  valueOf(): string
}
```



================================================
FILE: docs/process-promise.md
================================================
# Process Promise

The `$` returns a `ProcessPromise` instance, which inherits native `Promise`. When resolved, it becomes a [`ProcessOutput`](./process-output.md).

```js
const p = $`command` // ProcessPromise
const o = await p    // ProcessOutput
```

By default, `$` spawns a new process immediately, but you can delay the start to trigger in manually.

```ts
const p = $({halt: true})`command`
const o = await p.run()
```

## `stage`

Shows the current process stage: `initial` | `halted` | `running` | `fulfilled` | `rejected`

```ts
const p = $`echo foo`
p.stage // 'running'
await p
p.stage // 'fulfilled'
```


## `stdin`

Returns a writable stream of the stdin process. Accessing
this getter will trigger execution of a subprocess with [`stdio('pipe')`](#stdio).

Do not forget to end the stream.

```js
const p = $`while read; do echo $REPLY; done`
p.stdin.write('Hello, World!\n')
p.stdin.end()
```

By default, each process is created with stdin in _inherit_ mode.

## `stdout`/`stderr`

Returns a readable streams of stdout/stderr process.

```js
const p = $`npm init`
for await (const chunk of p.stdout) {
  echo(chunk)
}
```

## `exitCode`

Returns a promise which resolves to the exit code of the process.

```js
if (await $`[[ -d path ]]`.exitCode == 0) {
...
}
```

## `json(), text(), lines(), buffer(), blob()`

Output formatters collection.

```js
const p = $`echo 'foo\nbar'`

await p.text()        // foo\n\bar\n
await p.text('hex')   // 666f6f0a0861720a
await p.buffer()      // Buffer.from('foo\n\bar\n')
await p.lines()       // ['foo', 'bar']

// You can specify a custom lines delimiter if necessary:
await $`touch foo bar baz; find ./ -type f -print0`
  .lines('\0')        // ['./bar', './baz', './foo']

// If the output is a valid JSON, parse it in place:
await $`echo '{"foo": "bar"}'`
  .json()             // {foo: 'bar'}
```

## `[Symbol.asyncIterator]`

Returns an async iterator for the process stdout.

```js
const p = $`echo "Line1\nLine2\nLine3"`
for await (const line of p) {
  console.log(line)
}

// Custom delimiter can be specified:
for await (const line of $({
  delimiter: '\0'
})`touch foo bar baz; find ./ -type f -print0`) {
  console.log(line)
}
```

## `pipe()`

Redirects the output of the process. Almost same as `|` in bash but with enhancements.
```js
const greeting = await $`printf "hello"`
  .pipe($`awk '{printf $1", world!"}'`)
  .pipe($`tr '[a-z]' '[A-Z]'`)
```

`pipe()` accepts any kind `Writable`, `ProcessPromise` or a file path.

```js
await $`echo "Hello, stdout!"`
  .pipe(fs.createWriteStream('/tmp/output.txt'))
```
You can pass a string to `pipe()` to implicitly create a receiving file. The previous example is equivalent to:

```js
await $`echo "Hello, stdout!"`
  .pipe('/tmp/output.txt')
```

Chained streams become _thenables_, so you can `await` them:

```js
const p = $`echo "hello"`
  .pipe(getUpperCaseTransform())
  .pipe(fs.createWriteStream(tempfile()))  // <- stream
const o = await p
```

And the `ProcessPromise` itself is compatible with the standard `Stream.pipe` API:

```js
const { stdout } = await fs
  .createReadStream(await fs.writeFile(file, 'test'))
  .pipe(getUpperCaseTransform())
  .pipe($`cat`)
```

Pipes can be used to show a real-time output of the process:

```js
await $`echo 1; sleep 1; echo 2; sleep 1; echo 3;`
  .pipe(process.stdout)
```

And the time machine is in stock! You can pipe the process at any phase: on start, in the middle, or even after the end. All chunks will be buffered and processed in the right order.

```js
const result = $`echo 1; sleep 1; echo 2; sleep 1; echo 3`
const piped1 = result.pipe`cat`
let piped2

setTimeout(() => { piped2 = result.pipe`cat` }, 1500)
  
(await piped1).toString()  // '1\n2\n3\n'
(await piped2).toString()  // '1\n2\n3\n'
```

This mechanism allows you to easily split streams to multiple consumers:
```js
const p = $`some-command`
const [o1, o2] = await Process.all([
  p.pipe`log`,
  p.pipe`extract`
])
```

Use combinations of `pipe()` and [`nothrow()`](#nothrow):

```js
await $`find ./examples -type f -print0`
  .pipe($`xargs -0 grep ${'missing' + 'part'}`.nothrow())
  .pipe($`wc -l`)
```

And literals! The `pipe()` does support them too:

```js
await $`printf "hello"`
  .pipe`awk '{printf $1", world!"}'`
  .pipe`tr '[a-z]' '[A-Z]'`
```

The `pipe()` allows not only chain or split stream, but also to merge them.
```js
const $h = $({ halt: true })
const p1 = $`echo foo`
const p2 = $h`echo a && sleep 0.1 && echo c && sleep 0.2 && echo e`
const p3 = $h`sleep 0.05 && echo b && sleep 0.1 && echo d`
const p4 = $`sleep 0.4 && echo bar`
const p5 = $h`cat`

await p1
p1.pipe(p5)
p2.pipe(p5)
p3.pipe(p5)
p4.pipe(p5)

const { stdout } = await p5.run() // 'foo\na\nb\nc\nd\ne\nbar\n'
```

By default, `pipe()` operates with `stdout` stream, but you can specify `stderr` as well:

```js
const p = $`echo foo >&2; echo bar`
const o1 = (await p.pipe.stderr`cat`).toString()  // 'foo\n'
const o2 = (await p.pipe.stdout`cat`).toString()  // 'bar\n'
```

The [signal](/api#signal) option, if specified, will be transmitted through the pipeline.

```js
const ac = new AbortController()
const { signal } = ac
const p = $({ signal, nothrow: true })`echo test`.pipe`sleep 999`
setTimeout(() => ac.abort(), 50)

try {
  await p
} catch ({ message }) {
  message // The operation was aborted
}
```

In short, combine anything you want:

```js
const getUpperCaseTransform = () => new Transform({
  transform(chunk, encoding, callback) {
    callback(null, String(chunk).toUpperCase())
  },
})

// $ > stream (promisified) > $
const o1 = await $`echo "hello"`
  .pipe(getUpperCaseTransform())
  .pipe($`cat`)

o1.stdout //  'HELLO\n'

// stream > $
const file = tempfile()
await fs.writeFile(file, 'test')
const o2 = await fs
  .createReadStream(file)
  .pipe(getUpperCaseTransform())
  .pipe($`cat`)

o2.stdout //  'TEST'
```

## `unpipe()`

Opposite of `pipe()`, it removes the process from the pipeline.

```js
const p1 = $`echo foo && sleep 0.05 && echo bar && sleep 0.05 && echo baz && sleep 0.05 && echo qux`
const p2 = $`echo 1 && sleep 0.05 && echo 2 && sleep 0.05 && echo 3`
const p3 = $`cat`

p1.pipe(p3)
p2.pipe(p3)

setTimeout(() => p1.unpipe(p3), 105)

assert.equal((await p1).stdout, 'foo\nbar\nbaz\nqux')
assert.equal((await p2).stdout, '1\n2\n3')
assert.equal((await p3).stdout, 'foo\n1\nbar\n2\n3')
```

## `kill()`

Kills the process and all children.

By default, signal `SIGTERM` is sent. You can specify a signal via an argument.

```js
const p = $`sleep 999`
setTimeout(() => p.kill('SIGINT'), 100)
await p
```

Killing the expired process raises an error:

```js
const p = await $`sleep 999`
p.kill() // Error: Too late to kill the process.
```

## `abort()`

Terminates the process via an `AbortController` signal.

```js
const ac = new AbortController()
const {signal} = ac
const p = $({signal})`sleep 999`

setTimeout(() => ac.abort('reason'), 100)
await p
```

If `ac` or `signal` is not provided, it will be autocreated and could be used to control external processes.

```js
const p = $`sleep 999`
const {signal} = p

const res = fetch('https://example.com', {signal})
p.abort('reason')
```

The process may be aborted while executing, the method raises an error otherwise:

```js
const p = $({nothrow: true})`sleep 999`
p.abort() // ok

await p
p.abort() // Error: Too late to abort the process.
```

## `stdio()`
Specifies a standard input-output for the process.

```js
const h$ = $({halt: true})
const p1 = h$`read`.stdio('inherit', 'pipe', null).run()
const p2 = h$`read`.stdio('pipe').run() // sets ['pipe', 'pipe', 'pipe']
```

Keep in mind, `stdio` should be set before the process is started, so the preset syntax might be preferable:

```js
await $({stdio: ['pipe', 'pipe', 'pipe']})`read`
```

## `nothrow()`

Changes behavior of `$` to not throw an exception on non-zero exit codes. Equivalent to [`$({nothrow: true})` option](./api#nothrow).

```js
await $`grep something from-file`.nothrow()

// Inside a pipe():
await $`find ./examples -type f -print0`
  .pipe($`xargs -0 grep something`.nothrow())
  .pipe($`wc -l`)

// Accepts a flag to switch nothrow mode for the specific command
$.nothrow = true
await $`echo foo`.nothrow(false)
```

If only the `exitCode` is needed, you can use [`exitCode`](#exitcode) directly:

```js
if (await $`[[ -d path ]]`.exitCode == 0) {
//...
}

// Equivalent of:

if ((await $`[[ -d path ]]`.nothrow()).exitCode == 0) {
//...
}
```

## `quiet()`

Changes behavior of `$` to enable suppress mode.

```js
// Command output will not be displayed.
await $`grep something from-file`.quiet()

$.quiet = true
await $`echo foo`.quiet(false) // Disable for the specific command
```

## `verbose()`

Enables verbose output. Pass `false` to disable.

```js
await $`grep something from-file`.verbose()

$.verbose = true
await $`echo foo`.verbose(false) // Turn off verbose mode once
```

## `timeout()`

Kills the process after a specified period.

```js
await $`sleep 999`.timeout('5s')

// Or with a specific signal.
await $`sleep 999`.timeout('5s', 'SIGKILL')
```

If the process is already settled, the method does nothing. Passing nullish value will disable the timeout.



================================================
FILE: docs/quotes.md
================================================
# Quotes

Bash supports various ways to quote arguments: single quotes, double quotes, and a bash-specific method using C-style
quotes `$'...'`. Zx prefers the latter approach.

```js
const name = 'foo & bar'
await $`mkdir ${name}`
```


> [!WARNING]  
> Zx automatically escapes and quotes anything within `${...}`, so there's no need for additional quotes. Moreover, this may result in an **unsafe injection**.
> ```ts
> const args = ['param && echo bar']
> const p = $`echo --foo=$'${args}'`
> (await p).stdout // '--foo=$param\nbar\n'
> ```


The following examples produce the same, correct result:

```js
await $`mkdir ${'path/to-dir/' + name}`
```

```js
await $`mkdir path/to-dir/${name}`
```

Keep in mind, that `PowerShell` or `pwsh` requires a corresponding quote implementation. Define it [via helpers](./setup#bash) or manually:

```js
import { quotePowerShell } from 'zx'

$.quote = quotePowerShell
```

## Array of arguments

Zx can also accept an array of arguments within `${...}`. Each array item will be quoted separately and then joined by a
space.

```js
const flags = [
  '--oneline',
  '--decorate',
  '--color',
]
await $`git log ${flags}`
```

## Glob patterns

Because Zx escapes everything inside `${...}`, you can't use glob syntax directly. Instead, Zx provides 
a [`glob`](api.md#glob) function.

The following example won't work:

```js
const files = './**/*.md' // [!code error] // Incorrect
await $`ls ${files}`
```

The correct approach:

```js
const files = await glob('./**/*.md')
await $`ls ${files}`
```

## Home dir `~`

Zx won't expand the home directory symbol `~` if it's within `${...}`. Use `os.homedir()` for that purpose.

```js
const dir = `~/Downloads` // [!code error] // Incorrect
await $`ls ${dir}`
```

```js
await $`ls ${os.homedir()}/Downloads` // Correct
```

```js
await $`ls ~/Downloads` // Correct, ~ is outside of ${...}
```

## Assembling commands

If you're trying to dynamically assemble commands in Zx, you might run into limitations. For instance, the following
approach won't work:

```js
const cmd = 'rm'
if (force) cmd += ' -f'
if (recursive) cmd += ' -r'
cmd += ' ' + file

await $`${cmd}` // [!code error] // Incorrect
```

Zx will escape the entire string, making the command invalid. Instead, assemble an array of arguments and pass it to Zx
like this:

```js
const args = []
if (force) args.push('-f')
if (recursive) args.push('-r')
args.push(file)

await $`rm ${args}` // [!code hl]
```



================================================
FILE: docs/setup.md
================================================
# Setup

## Requirements
* Linux, macOS, or Windows
* JavaScript Runtime:
  * Node.js >= 12.17.0
  * Bun >= 1.0.0
  * Deno 1.x, 2.x
  * GraalVM Node.js
* Some kind of bash or PowerShell

## Install

::: code-group

```bash [npm]
npm install zx     # add -g to install globally
```

```bash [npx]
npx zx script.js         # run script without installing the zx package
npx zx@8.6.0 script.js   # pin to a specific zx version
```

```bash [yarn]
yarn add zx
```

```bash [pnpm]
pnpm add zx
```

```bash [bun]
bun install zx
```

```bash [deno]
deno install -A npm:zx

# zx requires additional permissions: --allow-read --allow-sys --allow-env --allow-run
```

```bash [jsr]
npx jsr add @webpod/zx
deno add jsr:@webpod/zx

# https://jsr.io/docs/using-packages
```

```bash [docker]
docker pull ghcr.io/google/zx:8.5.0
docker run -t ghcr.io/google/zx:8.5.0 -e="await \$({verbose: true})\`echo foo\`"
docker run -t -i -v ./:/script ghcr.io/google/zx:8.5.0 script/t.js
```

```bash [brew]
brew install zx
```

:::

### Channels

zx is distributed in several versions, each with its own set of features.

| Channel  | Description                                                                                  | Install              |
|----------|----------------------------------------------------------------------------------------------|----------------------|
| `latest` | Mainline releases with the latest features and improvements.                                 | `npm i zx`           |
| `lite`   | [A minimalistic version of zx](./lite), suitable for lightweight scripts.                    | `npm i zx@lite`      |
| `dev`    | Development snapshots with the latest changes, may be unstable.                              | `npm i zx@dev`       |
| `legacy` | Legacy supporting versions for compatibility with older scripts, no new features, only bugfixes | `npm i zx@<version>` |

Detailed comparison: [versions](./versions).

Please check the download sources carefully. Official links:

* [npmjs](https://www.npmjs.com/package/zx)
* [GH npm](https://github.com/google/zx/pkgs/npm/zx)
* [GH repo](https://github.com/google/zx)
* [GH docker](https://github.com/google/zx/pkgs/container/zx)
* [JSR](https://jsr.io/@webpod/zx)
* [Homebrew](https://github.com/Homebrew/homebrew-core/blob/master/Formula/z/zx.rb)

### Github
To fetch zx directly from the GitHub:
```bash
# Install via git
npm i google/zx
npm i git@github.com:google/zx.git

# Fetch from the GH pkg registry
npm i --registry=https://npm.pkg.github.com @google/zx
```

### Docker
If you'd prefer to run scripts in a container, you can pull the zx image from the [ghcr.io](https://ghcr.io).
[node:24-alpine](https://hub.docker.com/_/node) is used as [a base](https://github.com/google/zx/blob/main/dcr/Dockerfile).

```shell
docker pull ghcr.io/google/zx:8.5.0
docker run -t ghcr.io/google/zx:8.5.0 -e="await \$({verbose: true})\`echo foo\`"
docker run -t -i -v ./:/script ghcr.io/google/zx:8.5.0 script/t.js
```

## Bash

zx mostly relies on bash, so make sure it's available in your environment. If you're on Windows, consider using [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install) or [Git Bash](https://git-scm.com/downloads).
By default, zx looks for bash binary, but you can switch to PowerShell by invoking `usePowerShell()` or `usePwsh()`.

```js
import { useBash, usePowerShell, usePwsh } from 'zx'

usePowerShell() // Use PowerShell.exe
usePwsh()       // Rely on pwsh binary (PowerShell v7+)
useBash()       // Switch back to bash
```

## Package

### Hybrid
zx is distributed as a [hybrid package](https://2ality.com/2019/10/hybrid-npm-packages.html): it provides both CJS and ESM entry points.

```js
import { $ } from 'zx'

const { $ } = require('zx')
```

It also contains built-in TypeScript libdefs. But `@types/fs-extra` and `@types/node` are required to be installed on user's side.

```bash
npm i -D @types/fs-extra @types/node
```

```ts
import { type Options } from 'zx'

const opts: Options = {
  quiet: true,
  timeout: '5s'
}
```

### Bundled

We use [esbuild](https://dev.to/antongolub/how-and-why-do-we-bundle-zx-1ca6) to produce a static build that allows us to solve several issues at once:
* Reduce the pkg size and install time.
* Make npx (yarn dlx / bunx) invocations reproducible.
* Provide support for a wide range of Node.js versions: from [12 to 25](https://github.com/google/zx/blob/61d03329349770d90fda3c9e26f7ef09f869a096/.github/workflows/test.yml#L195).
* Make auditing easier: complete code is in one place.

### Composite

zx exports several entry points adapted for different use cases:
* `zx` – the main entry point, provides all the features.
* `zx/global` – to populate the global scope with zx functions.
* `zx/cli` – to run zx scripts from the command line.
* `zx/core` – to use zx template spawner as part of 3rd party libraries with alternating set of utilities.

### Typed
The library is written in TypeScript 5 and provides comprehensive type definitions for TS users.
* Libdefs are bundled via [dts-bundle-generator](https://github.com/timocov/dts-bundle-generator).
* Compatible with TS 4.0 and later.
* Requires `@types/node` and `@types/fs-extra` to be installed.



================================================
FILE: docs/shell.md
================================================
# Shell

[Bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) is a fundamental part of the Unix ecosystem, and it is widely used for scripting and automation tasks. It provides a powerful set of built-in utils, operators, process controllers.
Bash gives an efficient way to fine-tune the behavior: cmd aliases, context presets, custom functions, env injections, and more.

zx is not trying to replace bash, but to enhance it with JavaScript's capabilities:
* Parallel execution
* Data transformations
* Exception handling
* Conditional logic and loops

```js
#!/usr/bin/env zx
import { $ } from 'zx'

$.nothrow = true

const repos = ['zx', 'webpod']
const clones = repos
  .map(n => $`git clone https://github.com/google/${n} ${n}-clone`)

const results = await Promise.all(clones)
const errors = results.filter(o => !o.ok).map(o => o.stderr.trim())
console.log('errors', errors.join('\n'))

for (p of clones) {
  await p.pipe`cat > ${p.pid}.txt`
}
```

## Bash and Pwsh
There're many shell implementations. zx brings a few setup helpers:

* [`useBash`](./api#usebash) switches to bash
* [`usePowerShell`](./api#usepowershell) — PowerShell
* [`usePwsh`](./api#usepwsh) — pwsh (PowerShell v7+)

You can also set the shell directly via [JS API](./setup#bash), [CLI flags](./cli#shell) or [envars](./cli#environment-variables):

```js
$.shell = '/bin/zsh'
```

```bash
zx --shell /bin/zsh script.js
```

```bash
ZX_SHELL=/bin/zsh zx script.js
```

## zx = bash + js
No compromise, take the best of both.



================================================
FILE: docs/typescript.md
================================================
# TypeScript

zx is written in TypeScript and provides the corresponding libdefs out of the box. Types are TS 4+ compatible. Write code in any suitable format `.ts`, `.mts`, `.cts` or add [a custom loader](./cli#non-standard-extension).

```ts
// script.ts
import { $ } from 'zx'

const list = await $`ls -la`
```

Some runtimes like [Bun](https://bun.sh/) or [Deno](https://deno.com/) have built-in TS support. Node.js requires additional setup. Configure your project according to the [ES modules contract](https://nodejs.org/api/packages.html#packages_type):

- Set [`"type": "module"`](https://nodejs.org/api/packages.html#packages_type)
in **package.json**
- Set [`"module": "ESNext"`](https://www.typescriptlang.org/tsconfig/#module)
in **tsconfig.json**.

Using TypeScript compiler is the most straightforward way, but native TS support from runtimes is gradually increasing.

::: code-group

```bash [node]
# Since Node.js v22.6.0
node --experimental-strip-types script.js
```

```bash [npx]
# Since Node.js v22.6.0
NODE_OPTIONS="--experimental-strip-types" zx script.js
```

```bash [tsc]
npm install typescript

tsc script.ts

node script.js
```

```bash [ts-node]
npm install ts-node

ts-node script.ts
# or via node loader
node --loader ts-node/esm script.ts
```

```bash [swc-node]
npm install swc-node

swc-node script.ts
```

```bash [tsx]
npm install tsx

tsx script.ts
# or
node --import=tsx script.ts
```

```bash [bun]
bun script.ts
```

```bash [deno]
deno run --allow-read --allow-sys --allow-env --allow-run script.ts
```

:::



================================================
FILE: docs/versions.md
================================================
# Versions

zx is distributed in several versions, each with its own set of features.

* `@latest` represents the stable full-featured version.
* `@lite` separates the zx core from the extensions.
* `@dev` brings experimental snapshots and RCs.

| Feature           | latest | lite |
|-------------------|--------|------|
| **zx/globals**    | ✔️     | ️    |
| **zx/cli**        | ✔️     |      |
| `$`               | ✔️     | ✔️   |
| `ProcessPromise`  | ✔️     | ✔️   |
| `ProcessOutput`   | ✔️     | ✔️   |
| `argv`            | ✔️     | ️    |
| `cd`              | ✔️     | ✔️   |
| `chalk`           | ✔️     | ✔️   |
| `defaults`        | ✔️     | ✔️   |
| `dotenv`          | ✔️     | ️    |
| `echo`            | ✔️     | ️    |
| `expBackoff`      | ✔️     | ️    |
| `fetch`           | ✔️     | ️    |
| `fs`              | ✔️     | ️    |
| `glob`            | ✔️     | ️    |
| `kill`            | ✔️     | ✔️   |
| `log`             | ✔️     | ✔️   |
| `minimist`        | ✔️     | ️    |
| `nothrow`         | ✔️     | ️    |
| `os`              | ✔️     | ✔️   |
| `parseArgv`       | ✔️     | ️    |
| `path`            | ✔️     | ✔️   |
| `ps`              | ✔️     | ✔️   |
| `question`        | ✔️     | ️    |
| `quiet`           | ✔️     | ️    |
| `quote`           | ✔️     | ✔️   |
| `quotePowerShell` | ✔️     | ✔️   |
| `resolveDefaults` | ✔️     | ✔️   |
| `retry`           | ✔️     | ️    |
| `sleep`           | ✔️     | ️    |
| `spinner`         | ✔️     | ️    |
| `syncProcessCwd`  | ✔️     | ✔️   |
| `tempdir`         | ✔️     |      |
| `tempfile`        | ✔️     |      |
| `updateArgv`      | ✔️     |      |
| `useBash`         | ✔️     | ✔️   |
| `usePowerShell`   | ✔️     | ✔️   |
| `usePwsh`         | ✔️     | ✔️   |
| `version`         | ✔️     | ️    |
| `which`           | ✔️     | ✔️   |
| `whithin`         | ✔️     | ✔️   |
| `YAML`            | ✔️     | ️    |




================================================
FILE: docs/.vitepress/config.mts
================================================
import { defineConfig } from 'vitepress'

// https://vitepress.dev/reference/site-config
export default defineConfig({
  base: '/zx/',
  outDir: 'build',
  cleanUrls: true,
  title: 'google/zx',
  titleTemplate: ':title | google/zx',
  description: 'A tool for writing better scripts',
  head: [
    [
      'link',
      {
        rel: 'apple-touch-icon',
        sizes: '180x180',
        href: '/zx/img/favicons/apple-touch-icon.png',
      },
    ],
    [
      'link',
      {
        rel: 'icon',
        type: 'image/png',
        sizes: '32x32',
        href: '/zx/img/favicons/favicon-32x32.png',
      },
    ],
    [
      'link',
      {
        rel: 'icon',
        type: 'image/png',
        sizes: '16x16',
        href: '/zx/img/favicons/favicon-16x16.png',
      },
    ],
    [
      'link',
      {
        rel: 'mask-icon',
        href: '/zx/img/favicons/safari-pinned-tab.svg',
        color: '#3a0839',
      },
    ],
    ['link', { rel: 'shortcut icon', href: '/zx/img/favicons/favicon.ico' }],
    ['meta', { name: 'og:image', content: '/zx/img/og-image.png' }],
    ['meta', { name: 'twitter:image', content: '/zx/img/og-image.png' }],
  ],
  themeConfig: {
    logo: '/img/logo.svg',
    // https://vitepress.dev/reference/default-theme-config
    nav: [
      { text: 'Home', link: '/' },
      { text: 'Docs', link: '/getting-started' },
    ],

    sidebar: {
      '/': [
        {
          text: 'Docs',
          items: [
            { text: 'Getting Started', link: '/getting-started' },
            { text: 'Setup', link: '/setup' },
            { text: 'API Reference', link: '/api' },
            { text: 'CLI Usage', link: '/cli' },
            { text: 'Configuration', link: '/configuration' },
            { text: 'Process Promise', link: '/process-promise' },
            { text: 'Process Output', link: '/process-output' },
            { text: 'Contribution Guide', link: '/contribution' },
            { text: 'Architecture', link: '/architecture' },
            { text: 'Migration from v7', link: '/migration-from-v7' },
            { text: '⚡ zx@lite', link: '/lite' },
          ],
        },
        {
          text: 'FAQ',
          link: '/faq',
          items: [
            { text: 'Quotes', link: '/quotes' },
            { text: 'Shell', link: '/shell' },
            { text: 'TypeScript', link: '/typescript' },
            { text: 'Markdown Scripts', link: '/markdown' },
            { text: 'Known Issues', link: '/known-issues' },
          ],
        },
      ],
    },

    socialLinks: [{ icon: 'github', link: 'https://github.com/google/zx' }],

    editLink: {
      pattern: 'https://github.com/google/zx/blob/main/docs/:path',
    },

    footer: {
      message:
        'Disclaimer: This is not an officially supported Google product.',
    },

    search: {
      provider: 'local',
    },
  },
})



================================================
FILE: docs/.vitepress/theme/custom.css
================================================
:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: -webkit-linear-gradient(
    120deg,
    #f11a7b 10%,
    #feffac
  );

  --vp-home-hero-image-background-image: linear-gradient(
    -45deg,
    rgba(241, 26, 123, 0.33) 50%,
    rgba(254, 255, 172, 0.33) 50%
  );
  --vp-home-hero-image-filter: blur(40px);
}

@media (min-width: 640px) {
  :root {
    --vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    --vp-home-hero-image-filter: blur(72px);
  }
}



================================================
FILE: docs/.vitepress/theme/index.js
================================================
import DefaultTheme from 'vitepress/theme'
import MyLayout from './MyLayout.vue'
import './custom.css'

export default {
  ...DefaultTheme,
  // override the Layout with a wrapper component that
  // injects the slots
  Layout: MyLayout,
}



================================================
FILE: docs/.vitepress/theme/MyLayout.vue
================================================
<script setup>
import DefaultTheme from 'vitepress/theme'
import MyOxygen from './MyOxygen.vue'

const { Layout } = DefaultTheme
</script>

<template>
  <Layout>
    <template #aside-ads-after>
      <MyOxygen />
    </template>
  </Layout>
</template>



================================================
FILE: docs/.vitepress/theme/MyOxygen.vue
================================================
<template>
  <!--  <div class="Oxygen">-->
  <!--    <a href="https://webpod.dev/?from=zx-site">-->
  <!--      &lt;!&ndash;<img src="https://webpod.dev/img/banner.png" alt="Webpod - deploy JavaScript apps">&ndash;&gt;-->
  <!--      <img-->
  <!--        src="https://webpod.dev/img/logo.svg"-->
  <!--        alt="Webpod - deploy JavaScript apps"-->
  <!--      />-->
  <!--      <p>Webpod – deploy JavaScript apps to own cloud or private server</p>-->
  <!--    </a>-->
  <!--  </div>-->
</template>

<style scoped>
.Oxygen {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 24px;
  border-radius: 12px;
  min-height: 256px;
  text-align: center;
  line-height: 18px;
  font-size: 12px;
  font-weight: 500;
  background-color: var(--vp-carbon-ads-bg-color);
}

.Oxygen :deep(img) {
  margin: 0 auto;
}

.Oxygen :deep(p) {
  display: block;
  margin: 0 auto;
  color: var(--vp-carbon-ads-text-color);
  transition: color 0.25s;
}

.Oxygen :deep(p:hover) {
  color: var(--vp-carbon-ads-hover-text-color);
}
</style>
<script setup></script>



================================================
FILE: examples/background-process.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const serve = $`npx serve`

for await (const chunk of serve.stdout) {
  if (chunk.includes('Accepting connections')) break
}

await $`curl http://localhost:3000`

serve.kill('SIGINT')



================================================
FILE: examples/backup-github.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const username = await question('What is your GitHub username? ')
const token = await question('Do you have GitHub token in env? ', {
  choices: Object.keys(process.env),
})

let headers = {}
if (process.env[token]) {
  headers = {
    Authorization: `token ${process.env[token]}`,
  }
}
let res = await fetch(
  `https://api.github.com/users/${username}/repos?per_page=1000`,
  { headers }
)
const data = await res.json()
const urls = data.map((x) =>
  x.git_url.replace('git://github.com/', 'git@github.com:')
)

await $`mkdir -p backups`
cd('./backups')

for (const url of urls) {
  await $`git clone ${url}`
}



================================================
FILE: examples/fetch-weather.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

async function main() {
  const argv = minimist(process.argv.slice(2), {
    boolean: ['help'],
    alias: { h: 'help' },
  })

  if (argv.help) {
    echo(`
${chalk.bold('Usage:')} zx fetch-weather.mjs [city name]

Fetches weather data using wttr.in with a neat two-column colored table format.

${chalk.bold('Examples:')}
  zx fetch-weather.mjs London
  ./fetch-weather.mjs "New York"
`)
    process.exit(0)
  }

  const args = argv._.slice(__filename === process.argv[1] ? 0 : 1)
  const city = args.join(' ')

  if (!city) throw 'No city provided. Use -h for help.'

  const svc_url = 'https://wttr.in'

  const data = await spinner(
    `📡 Fetching weather for "${city}" from ${svc_url}...`,
    async () => {
      try {
        const res = await fetch(
          `${svc_url}/${encodeURIComponent(city)}?format=j1`,
          {
            signal: AbortSignal.timeout(5000),
          }
        )
        if (!res.ok) throw `API error: ${res.status} ${res.statusText}`
        return res.json()
      } catch (err) {
        if (err.name === 'AbortError') {
          throw 'Request timed out after 5 seconds.'
        }
        throw err
      }
    }
  )

  const area = data.nearest_area[0]
  const current = data.current_condition[0]

  if (!area || !current) {
    throw '❌ Missing weather data in API response.'
  }

  const location = area.areaName[0].value
  const condition = current.weatherDesc[0].value
  const temperature = current.temp_C
  const humidity = current.humidity

  echo(chalk.yellow(`🌤️  Weather in ${location}: ${condition}`))
  echo(chalk.red(`🌡️  Temperature: ${temperature}°C`))
  echo(chalk.blue(`💧 Humidity: ${humidity}%`))
}

await main().then(
  () => process.exit(0),
  (err) => {
    const msg = typeof err === 'string' ? err : err.message
    echo(chalk.red(`❌ ${msg}`))
    process.exit(1)
  }
)

// Here's how to add this script to your shell as a bash alias. This assumes you have zx installed globally.
// 1. Save this script as `fetch-weather.mjs`.
// 2. Add the following line to your .bashrc file, replacing the path with your own:
// alias weather='zx /full/path/to/fetch-weather.mjs'
// 3. Then reload your shell using the following command:
// source ~/.bashrc
// Now you can use the `weather` command to fetch weather data for any city.
// Example usage: `weather London`



================================================
FILE: examples/interactive.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const p = $`npm init`.stdio('pipe')

for await (const chunk of p.stdout) {
  if (chunk.includes('package name:')) p.stdin.write('test\n')
  if (chunk.includes('version:')) p.stdin.write('1.0.0\n')
  if (chunk.includes('description:')) p.stdin.write('My test package\n')
  if (chunk.includes('entry point:')) p.stdin.write('index.mjs\n')
  if (chunk.includes('test command:')) p.stdin.write('test.mjs\n')
  if (chunk.includes('git repository:')) p.stdin.write('my-org/repo\n')
  if (chunk.includes('keywords:')) p.stdin.write('foo, bar\n')
  if (chunk.includes('author:')) p.stdin.write('Anton Medvedev\n')
  if (chunk.includes('license:')) p.stdin.write('MIT\n')
  if (chunk.includes('Is this OK?')) p.stdin.write('yes\n')
}



================================================
FILE: examples/parallel.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { spinner } from 'zx'

const tests = await glob('test/*.test.js')
await spinner('running tests', async () => {
  try {
    const res = await Promise.all(tests.map((file) => $`npx uvu . ${file}`))
    res.forEach((r) => console.log(r.toString()))
    console.log(chalk.bgGreen.black(' SUCCESS '))
  } catch (e) {
    console.log(e.toString())
    process.exitCode = 1
  }
})



================================================
FILE: man/zx.1
================================================
.\" Manpage for zx.
.TH man 8 "06 Jul 2024" "8.x" "zx man page"
.SH NAME
zx \- the zx CLI
.SH DESCRIPTION
A tool for writing better scripts.
.SH SYNOPSIS
.SS zx\fR [\fIOPTIONS\fR]  \fIURI\fR
.SH OPTIONS
.SS --cwd
set current directory
.SS --quiet
suppress any outputs
.SS --verbose
enables verbose mode
.SS --shell=<path>
set the shell to use
.SS --prefix=<command>
prefix all commands
.SS --postfix=<command>
postfix all commands
.SS --prefer-local, -l
prefer locally installed packages and binaries
.SS --eval=<js>, -e
evaluate script
.SS --ext=<.mjs>
script extension
.SS --install, -i
install dependencies
.SS --registry=<URL>
npm registry, defaults to https://registry.npmjs.org/
.SS --repl
start repl
.SS --env=<path>
path to env file
.SS --version, -v
print current zx version
.SS --help, -h
print command help and options
.SH EXAMPLES
.TP
.I zx --verbose script.js
.TP
.I zx https://example.com/script.js
.TP
.I zx -e '$`ls -l`'
.SH BUGS
https://github.com/google/zx/issues.
.SH AUTHOR
Anton Medvedev (https://medv.io/)


================================================
FILE: scripts/build-clean.mjs
================================================
#!/usr/bin/env node

// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import fs from 'node:fs'
import glob from 'fast-glob'

const redundants = await glob(
  [
    'build/{repl,globals-jsr,internals}.d.ts',
    'build/{deps,internals,util,vendor*}.js',
  ],
  {
    onlyFiles: true,
    absolute: true,
  }
)

for (const file of redundants) {
  fs.unlinkSync(file)
}

console.log('postbuild removed', redundants)



================================================
FILE: scripts/build-dts.mjs
================================================
#!/usr/bin/env node

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import fs from 'node:fs/promises'
import { generateDtsBundle } from 'dts-bundle-generator'
import glob from 'fast-glob'

const output = {
  inlineDeclareExternals: true,
  inlineDeclareGlobals: true,
  sortNodes: false,
  exportReferencedTypes: false, //args['export-referenced-types'],
}
const entries = [
  {
    filePath: './src/vendor-extra.ts',
    outFile: './build/vendor-extra.d.ts',
    libraries: {
      allowedTypesLibraries: ['node'], // args['external-types'],
      inlinedLibraries: [
        '@nodelib/fs.stat',
        '@nodelib/fs.scandir',
        '@nodelib/fs.walk',
        'fast-glob',
        '@types/jsonfile',
        'node-fetch-native',
        // 'chalk',
        'globby',
        '@types/minimist',
        // '@types/which',
        // 'zurk',
        // '@webpod/ps',
        '@webpod/ingrid',
        'depseek',
        'envapi',
      ], // args['external-inlines'],
    },
    output,
  },
  {
    filePath: './src/vendor-core.ts',
    outFile: './build/vendor-core.d.ts',
    libraries: {
      allowedTypesLibraries: ['node'], // args['external-types'],
      inlinedLibraries: [
        '@types/which',
        '@webpod/ps',
        '@webpod/ingrid',
        'chalk',
        'zurk',
      ], // args['external-inlines'],
    },
    output,
  },
]

const compilationOptions = {
  preferredConfigPath: './tsconfig.json', // args.project,
  followSymlinks: true,
}

const results = generateDtsBundle(entries, compilationOptions)
  // generateDtsBundle cannot handle the circular refs on types inlining, so we need to help it manually:
  /*
build/vendor.d.ts(163,7): error TS2456: Type alias 'Options' circularly references itself.
build/vendor.d.ts(164,7): error TS2456: Type alias 'Entry' circularly references itself.
build/vendor.d.ts(165,7): error TS2456: Type alias 'Task' circularly references itself.
build/vendor.d.ts(166,7): error TS2456: Type alias 'Pattern' circularly references itself.
build/vendor.d.ts(167,7): error TS2456: Type alias 'FileSystemAdapter' circularly references itself.
build/vendor.d.ts(197,48): error TS2694: Namespace 'FastGlob' has no exported member 'FastGlobOptions
 */

  .map((r) =>
    r
      .replace('type Options = Options;', 'export {Options};')
      .replace('type Task = Task;', 'export {Task};')
      .replace('type Pattern = Pattern;', 'export {Pattern};')
      .replace('FastGlob.FastGlobOptions', 'FastGlob.Options')
      .replace('type Entry =', 'export type Entry =')
  )

for (const i in results) {
  const entry = entries[i]
  const result = results[i]

  await fs.writeFile(entry.outFile, result, 'utf8')
}

// Properly formats triple-slash directives
const pkgEntries = ['core', 'index', 'vendor']
const prefix = `/// <reference types="node" />
/// <reference types="fs-extra" />

`

for (const dts of await glob(['build/**/*.d.ts', '!build/vendor-*.d.ts'])) {
  const contents =
    (pkgEntries.some((e) => dts.includes(e)) ? prefix : '') +
    (await fs.readFile(dts, 'utf8'))
      .replaceAll(".ts';", ".js';")
      .split('\n')
      .filter((line) => !line.startsWith('/// <reference types'))
      .join('\n')

  await fs.writeFile(dts, contents, 'utf8')
}

process.exit(0)



================================================
FILE: scripts/build-js.mjs
================================================
#!/usr/bin/env node

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import path from 'node:path'
import fs from 'node:fs'
import esbuild from 'esbuild'
import { injectCode, injectFile } from 'esbuild-plugin-utils'
import { nodeExternalsPlugin } from 'esbuild-node-externals'
import { entryChunksPlugin } from 'esbuild-plugin-entry-chunks'
import { hybridExportPlugin } from 'esbuild-plugin-hybrid-export'
import { transformHookPlugin } from 'esbuild-plugin-transform-hook'
import { extractHelpersPlugin } from 'esbuild-plugin-extract-helpers'
import esbuildResolvePlugin from 'esbuild-plugin-resolve'
import minimist from 'minimist'
import glob from 'fast-glob'

const __dirname = path.dirname(new URL(import.meta.url).pathname)

const argv = minimist(process.argv.slice(2), {
  default: {
    entry: './src/index.ts',
    external: 'node:*',
    bundle: 'src', // 'all' | 'none'
    license: 'none', // see digestLicenses below // 'eof',
    minify: false,
    sourcemap: false,
    format: 'cjs,esm',
    target: 'node12',
    cwd: process.cwd(),
  },
  boolean: ['minify', 'sourcemap', 'hybrid'],
  string: ['entry', 'external', 'bundle', 'license', 'format', 'map', 'cwd'],
})
const {
  entry,
  external,
  bundle,
  minify,
  sourcemap,
  license,
  format,
  hybrid,
  cwd: _cwd,
} = argv

const formats = format.split(',')
const cwd = [_cwd].flat().pop()
const entries = entry.split(/:\s?/)
const entryPoints =
  entry.includes('*') || entry.includes('{')
    ? await glob(entries, { absolute: false, onlyFiles: true, cwd, root: cwd })
    : entries.map((p) => path.relative(cwd, path.resolve(cwd, p)))
const _bundle = bundle && bundle !== 'none'
const _external = ['zx/globals', ...(_bundle ? external.split(',') : [])] // https://github.com/evanw/esbuild/issues/1466

const plugins = [
  esbuildResolvePlugin({
    yaml: path.resolve(__dirname, '../node_modules/yaml/browser'),
  }),
]

const thirdPartyModules = new Set()

if (_bundle && entryPoints.length > 1) {
  plugins.push(entryChunksPlugin())
}

if (bundle === 'src') {
  // https://github.com/evanw/esbuild/issues/619
  // https://github.com/pradel/esbuild-node-externals/pull/52
  plugins.push(nodeExternalsPlugin())
}

if (hybrid) {
  plugins.push(
    hybridExportPlugin({
      loader: 'reexport',
      to: 'build',
      toExt: '.js',
    })
  )
}

plugins.push(
  {
    name: 'get-3rd-party-modules',
    setup: (build) => {
      build.onResolve({ filter: /./, namespace: 'file' }, async (args) => {
        thirdPartyModules.add(args.resolveDir)
      })
    },
  },
  transformHookPlugin({
    hooks: [
      {
        on: 'end',
        if: !hybrid,
        pattern: /\.js$/,
        transform(contents, file) {
          const { name } = path.parse(file)
          const _contents = contents
            .toString()
            .replace(
              '} = __module__',
              `} = globalThis.Deno ? globalThis.require("./${name}.cjs") : __module__`
            )
          return injectCode(_contents, `import "./deno.js"`)
        },
      },
      {
        on: 'end',
        pattern: entryPointsToRegexp(entryPoints),
        transform(contents) {
          const extras = [
            // https://github.com/evanw/esbuild/issues/1633
            contents.includes('import_meta')
              ? './scripts/import-meta-url.polyfill.js'
              : '',

            //https://github.com/evanw/esbuild/issues/1921
            // p.includes('vendor') ? './scripts/require.polyfill.js' : '',
          ].filter(Boolean)
          return injectFile(contents, ...extras)
        },
      },
      {
        on: 'end',
        pattern: entryPointsToRegexp(entryPoints),
        transform(contents) {
          return contents
            .toString()
            .replaceAll('import.meta.url', 'import_meta_url')
            .replaceAll('import_meta.url', 'import_meta_url')
            .replaceAll('"node:', '"')
            .replaceAll(
              'require("stream/promises")',
              'require("stream").promises'
            )
            .replaceAll('require("fs/promises")', 'require("fs").promises')
            .replaceAll('}).prototype', '}).prototype || {}')
            .replace(/DISABLE_NODE_FETCH_NATIVE_WARN/, ($0) => `${$0} || true`)
            .replace(
              /\/\/ Annotate the CommonJS export names for ESM import in node:/,
              ($0) => `/* c8 ignore next 100 */\n${$0}`
            )
            .replace(
              'yield import("zx/globals")',
              'yield require("./globals.cjs")'
            )
            .replace('require("./internals.ts")', 'require("./internals.cjs")')
        },
      },
    ],
  }),
  extractHelpersPlugin({
    cwd: 'build',
    include: /\.cjs/,
  }),
  {
    name: 'deno',
    setup(build) {
      build.onEnd(() => {
        fs.copyFileSync('./scripts/deno.polyfill.js', './build/deno.js')
        fs.writeFileSync(
          './build/3rd-party-licenses',
          digestLicenses(thirdPartyModules)
        )
      })
    },
  }
)

// prettier-ignore
function digestLicenses(dirs) {
  const digest = [...[...dirs]
    .reduce((m, d) => {
      const chunks = d.split('/')
      const i = chunks.lastIndexOf('node_modules')
      const name = chunks[i + 1]
      const shift = i + 1 + (name.startsWith('@') ? 2 : 1)
      const root = chunks.slice(0, shift).join('/')
      m.add(root)
      return m
    }, new Set())]
    .map(d => {
      const extractName = (entry) => entry?.name ? `${entry.name} <${entry.email}>` : entry
      const pkg = path.join(d, 'package.json')
      const pkgJson = JSON.parse(fs.readFileSync(pkg, 'utf-8'))
      const author = extractName(pkgJson.author)
      const contributors = (pkgJson.contributors || pkgJson.maintainers || []).map(extractName).join(', ')
      const by = author || contributors || '<unknown>'
      const repository = pkgJson.repository?.url || pkgJson.repository || ''
      const license = pkgJson.license || '<unknown>'

      if (pkgJson.name === 'zx') return

      return `${pkgJson.name}@${pkgJson.version}
  ${by}
  ${repository}
  ${license}`
    })
    .filter(Boolean)
    .sort()
    .join('\n\n')

  return `THIRD PARTY LICENSES

${digest}
`
}

function entryPointsToRegexp(entryPoints) {
  return new RegExp(
    '(' +
      entryPoints.map((e) => escapeRegExp(path.parse(e).name)).join('|') +
      ')\\.cjs$'
  )
}

function escapeRegExp(str) {
  return str.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&')
}

const esmConfig = {
  absWorkingDir: cwd,
  entryPoints,
  outdir: './build',
  bundle: _bundle,
  external: _external,
  minify,
  sourcemap,
  sourcesContent: false,
  platform: 'node',
  target: 'esnext',
  format: 'esm',
  outExtension: {
    '.js': '.mjs',
  },
  plugins,
  legalComments: license,
  tsconfig: './tsconfig.json',
}

const cjsConfig = {
  ...esmConfig,
  outdir: './build',
  target: 'es6',
  format: 'cjs',
  outExtension: {
    '.js': '.cjs',
  },
}

for (const format of formats) {
  const config = format === 'cjs' ? cjsConfig : esmConfig
  console.log('esbuild config:', config)

  await esbuild.build(config).catch(() => process.exit(1))
}

process.exit(0)



================================================
FILE: scripts/build-jsr.mjs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import fs from 'node:fs'
import path from 'node:path'
const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '..')
const pkgJson = JSON.parse(
  fs.readFileSync(path.resolve(root, 'package.json'), 'utf-8')
)
const deps = pkgJson.devDependencies

const jsrDeps = {
  yaml: 'jsr:@eemeli/yaml',
  zurk: 'jsr:@webpod/zurk',
}
const prodDeps = new Set([
  '@types/fs-extra',
  '@types/minimist',
  '@types/node',
  '@types/which',
  '@webpod/ingrid',
  '@webpod/ps',
  'chalk',
  'create-require',
  'depseek',
  'envapi',
  'fs-extra',
  'globby',
  'minimist',
  'node-fetch-native',
  'which',
  'yaml',
  'zurk',
])

fs.writeFileSync(
  path.resolve(root, 'jsr.json'),
  JSON.stringify(
    {
      name: '@webpod/zx',
      version: pkgJson.version,
      license: pkgJson.license,
      exports: {
        '.': './src/index.ts',
        './core': './src/core.ts',
        './cli': './src/cli.ts',
        './globals': './src/globals-jsr.ts',
      },
      publish: {
        include: ['src', 'README.md', 'LICENSE'],
        exclude: ['src/globals.ts'],
      },
      nodeModulesDir: 'auto',
      imports: Object.entries(deps).reduce(
        (m, [k, v]) => {
          if (prodDeps.has(k)) {
            const name = jsrDeps[k] || `npm:${k}`
            m[k] = `${name}@${v}`
          }
          return m
        },
        {
          'zurk/spawn': `jsr:@webpod/zurk@${deps.zurk}`,
          'zx/globals': './src/globals-jsr.ts',
        }
      ),
    },
    null,
    2
  )
)



================================================
FILE: scripts/build-tests.mjs
================================================
#!/usr/bin/env node

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import fs from 'node:fs'
import path from 'node:path'
import * as core from '../build/core.js'
import * as cli from '../build/cli.js'
import * as index from '../build/index.js'

// prettier-ignore
const modules = [
  ['core', core],
  ['cli', cli],
  ['index', index],
]
const root = path.resolve(new URL(import.meta.url).pathname, '../..')
const filePath = path.resolve(root, `test/export.test.js`)

const copyright = await fs.readFileSync(
  path.resolve(root, 'test/fixtures/copyright.txt'),
  'utf8'
)

let head = `${copyright.replace('YEAR', new Date().getFullYear())}
import assert from 'node:assert'
import { test, describe } from 'node:test'`
let body = '\n'

for (const [name, ref, apis = Object.keys(ref).sort()] of modules) {
  head += `\nimport * as ${name} from '../build/${name}.cjs'`
  body += `\n//prettier-ignore\ndescribe('${name}', () => {\n`
  body += `  test('exports', () => {\n`
  for (const r of apis) {
    const api = ref[r]
    body += `    assert.equal(typeof ${name}.${r}, '${typeof api}', '${name}.${r}')\n`
    if (typeof api !== 'function' && typeof api !== 'object') continue
    for (const k of Object.keys(api).sort()) {
      const v = api[k]
      body += `    assert.equal(typeof ${name}.${r}.${k}, '${typeof v}', '${name}.${r}.${k}')\n`
    }
  }
  body += '  })\n'
  body += '})\n'
}

const contents = head + body

fs.writeFileSync(filePath, contents)



================================================
FILE: scripts/build-versions.mjs
================================================
#!/usr/bin/env node

// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import fs from 'fs-extra'
import path from 'node:path'
import minimist from 'minimist'

const root = path.resolve(new URL(import.meta.url).pathname, '../..')
const copyright = await fs.readFileSync(
  path.resolve(root, 'test/fixtures/copyright.txt'),
  'utf8'
)
const deps = [
  'chalk',
  'depseek',
  'dotenv',
  'fetch',
  'fs',
  'glob',
  'minimist',
  'ps',
  'which',
  'yaml',
]
const namemap = {
  dotenv: 'envapi',
  fs: 'fs-extra',
  fetch: 'node-fetch-native',
  glob: 'globby',
  ps: '@webpod/ps',
}
const versions = deps.reduce(
  (m, name) => {
    m[name] = fs.readJsonSync(
      path.resolve(root, 'node_modules', namemap[name] || name, 'package.json')
    ).version
    return m
  },
  {
    zx: fs.readJsonSync(path.join(root, 'package.json')).version,
  }
)

const argv = minimist(process.argv.slice(2), {
  default: versions,
  string: ['zx', ...deps],
})

delete argv._

const list = JSON.stringify(argv, null, 2)
  .replaceAll('  "', '  ')
  .replaceAll('": ', ': ')
  .replaceAll('"', "'")
  .replace(/\n}$/, ',\n}')

const versionsTs = `${copyright.replace('YEAR', new Date().getFullYear())}
export const versions: Record<string, string> = ${list}
`
const versionsCjs = `${copyright.replace('YEAR', new Date().getFullYear())}
module.exports = { versions: ${list}
`

fs.writeFileSync(path.join(root, 'src/versions.ts'), versionsTs, 'utf8')
// fs.writeFileSync(path.join(root, 'build/versions.cjs'), versionsCjs, 'utf8')



================================================
FILE: scripts/deno.polyfill.js
================================================
import { createRequire } from 'node:module'
import * as process from 'node:process'

// prettier-ignore
if (globalThis.Deno) {
  globalThis.require = createRequire(import.meta.url)
  globalThis.__filename = new URL(import.meta.url).pathname
  globalThis.__dirname = new URL('.', import.meta.url).pathname
  globalThis.module = new Proxy({}, { set() { return true } })

  const p = globalThis.process = globalThis.process || process
  p.version || (p.version = 'v18.0.0')
  p.version || (p.version = { node: '18.0.0' })
  p.env || (p.env = globalThis.Deno.env.toObject())
  p.argv || (p.argv = [globalThis.Deno.execPath(), globalThis.Deno.mainModule.replace('file://', ''), ...globalThis.Deno.args])
}



================================================
FILE: scripts/import-meta-url.polyfill.js
================================================
const import_meta_url =
  typeof document === 'undefined'
    ? new (require('url').URL)('file:' + __filename).href
    : (document.currentScript && document.currentScript.src) ||
      new URL('main.js', document.baseURI).href



================================================
FILE: scripts/prepublish-clean.mjs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Optimizes package.json for npm publishing

import fs from 'node:fs'
import path from 'node:path'

const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '..')
const pkgJsonFile = path.join(root, 'package.json')
const _pkgJson = JSON.parse(fs.readFileSync(pkgJsonFile, 'utf-8'))

const whitelist = new Set([
  'name',
  'version',
  'description',
  'type',
  'main',
  'types',
  'typesVersions',
  'exports',
  'bin',
  'man',
  'files',
  'engines',
  'optionalDependencies',
  'publishConfig',
  'keywords',
  'repository',
  'homepage',
  'author',
  'license',
])

const pkgJson = Object.fromEntries(
  Object.entries(_pkgJson).filter(([k]) => whitelist.has(k))
)
fs.writeFileSync(pkgJsonFile, JSON.stringify(pkgJson, null, 2))

console.log('package.json optimized for npm publishing')



================================================
FILE: scripts/prepublish-lite.mjs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Prepares a lite (core) version of zx to publish

import fs from 'node:fs'
import path from 'node:path'
import { depseekSync } from 'depseek'

const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '..')
const pkgJsonFile = path.join(root, 'package.json')
const _pkgJson = JSON.parse(fs.readFileSync(pkgJsonFile, 'utf-8'))

const files = new Set()
const entries = new Set(['./core.js', './3rd-party-licenses'])

for (const entry of entries) {
  if (!fs.existsSync(path.join(root, 'build', entry))) continue

  files.add(entry)
  const contents = fs.readFileSync(path.join(root, 'build', entry), 'utf-8')
  const deps = depseekSync(contents)
  for (const { value: file } of deps) {
    if (file.startsWith('.')) {
      entries.add(file)
      entries.add(file.replace(/\.c?js$/, '.d.ts'))
    }
  }
}

const pkgJson = {
  ..._pkgJson,
  version: _pkgJson.version + '-lite',
  exports: {
    '.': {
      types: './build/core.d.ts',
      import: './build/core.js',
      require: './build/core.cjs',
      default: './build/core.js',
    },
    './package.json': './package.json',
  },
  main: './build/core.cjs',
  types: './build/core.d.ts',
  typesVersions: {
    '*': {
      '.': ['./build/core.d.ts'],
    },
  },
  man: undefined,
  files: [...files].map((f) => path.join('build', f)).sort(),
}

fs.writeFileSync(pkgJsonFile, JSON.stringify(pkgJson, null, 2))

console.log('package.json prepared for zx-lite publishing')



================================================
FILE: src/cli.ts
================================================
#!/usr/bin/env node

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import url from 'node:url'
import process from 'node:process'
import {
  $,
  ProcessOutput,
  parseArgv,
  updateArgv,
  resolveDefaults,
  chalk,
  dotenv,
  fetch,
  fs,
  path,
  stdin,
  VERSION,
  Fail,
} from './index.ts'
import { installDeps, parseDeps } from './deps.ts'
import { startRepl } from './repl.ts'
import { randomId } from './util.ts'
import { transformMarkdown } from './md.ts'
import { createRequire, type minimist } from './vendor.ts'

export { transformMarkdown } from './md.ts'

const EXT = '.mjs'
const EXT_RE = /^\.[mc]?[jt]sx?$/

// prettier-ignore
export const argv: minimist.ParsedArgs = parseArgv(process.argv.slice(2), {
  default: resolveDefaults({ ['prefer-local']: false } as any, 'ZX_', process.env, new Set(['env', 'install', 'registry'])),
  // exclude 'prefer-local' to let minimist infer the type
  string: ['shell', 'prefix', 'postfix', 'eval', 'cwd', 'ext', 'registry', 'env'],
  boolean: ['version', 'help', 'quiet', 'verbose', 'install', 'repl', 'experimental'],
  alias: { e: 'eval', i: 'install', v: 'version', h: 'help', l: 'prefer-local', 'env-file': 'env' },
  stopEarly: true,
  parseBoolean: true,
  camelCase: true,
})

isMain() &&
  main().catch((err) => {
    if (err instanceof ProcessOutput) {
      console.error('Error:', err.message)
    } else {
      console.error(err)
    }
    process.exitCode = 1
  })

export function printUsage() {
  // language=txt
  console.log(`
 ${chalk.bold('zx ' + VERSION)}
   A tool for writing better scripts

 ${chalk.bold('Usage')}
   zx [options] <script>

 ${chalk.bold('Options')}
   --quiet              suppress any outputs
   --verbose            enable verbose mode
   --shell=<path>       custom shell binary
   --prefix=<command>   prefix all commands
   --postfix=<command>  postfix all commands
   --prefer-local, -l   prefer locally installed packages and binaries
   --cwd=<path>         set current directory
   --eval=<js>, -e      evaluate script
   --ext=<.mjs>         script extension
   --install, -i        install dependencies
   --registry=<URL>     npm registry, defaults to https://registry.npmjs.org/
   --version, -v        print current zx version
   --help, -h           print help
   --repl               start repl
   --env=<path>         path to env file
   --experimental       enables experimental features (deprecated)

 ${chalk.italic('Full documentation:')} ${chalk.underline(Fail.DOCS_URL)}
`)
}

export async function main(): Promise<void> {
  if (argv.version) {
    console.log(VERSION)
    return
  }
  if (argv.help) {
    printUsage()
    return
  }
  if (argv.cwd) $.cwd = argv.cwd
  if (argv.env) {
    const envfile = path.resolve($.cwd ?? process.cwd(), argv.env)
    dotenv.config(envfile)
    resolveDefaults()
  }
  if (argv.verbose) $.verbose = true
  if (argv.quiet) $.quiet = true
  if (argv.shell) $.shell = argv.shell
  if (argv.prefix) $.prefix = argv.prefix
  if (argv.postfix) $.postfix = argv.postfix
  if (argv.preferLocal) $.preferLocal = argv.preferLocal

  await import('zx/globals')
  if (argv.repl) {
    await startRepl()
    return
  }
  argv.ext = normalizeExt(argv.ext)

  const { script, scriptPath, tempPath } = await readScript()
  await runScript(script, scriptPath, tempPath)
}

const rmrf = (p: string) => p && fs.rmSync(p, { force: true, recursive: true })
async function runScript(
  script: string,
  scriptPath: string,
  tempPath: string
): Promise<void> {
  let nmLink = ''
  const rmTemp = () => {
    rmrf(tempPath)
    rmrf(nmLink)
  }
  try {
    if (tempPath) {
      scriptPath = tempPath
      await fs.writeFile(tempPath, script)
    }
    const cwd = path.dirname(scriptPath)
    if (typeof argv.preferLocal === 'string') {
      nmLink = linkNodeModules(cwd, argv.preferLocal)
    }
    if (argv.install) {
      await installDeps(parseDeps(script), cwd, argv.registry)
    }

    injectGlobalRequire(scriptPath)
    process.once('exit', rmTemp)

    // TODO: fix unanalyzable-dynamic-import to work correctly with jsr.io
    await import(url.pathToFileURL(scriptPath).toString())
  } finally {
    rmTemp()
  }
}

function linkNodeModules(cwd: string, external: string): string {
  const nm = 'node_modules'
  const alias = path.resolve(cwd, nm)
  const target =
    path.basename(external) === nm
      ? path.resolve(external)
      : path.resolve(external, nm)

  if (fs.existsSync(alias) || !fs.existsSync(target)) return ''

  fs.symlinkSync(target, alias, 'junction')
  return target
}

async function readScript() {
  const [firstArg] = argv._
  let script = ''
  let scriptPath = ''
  let tempPath = ''
  let argSlice = 1

  if (argv.eval) {
    argSlice = 0
    script = argv.eval
    tempPath = getFilepath($.cwd, 'zx', argv.ext)
  } else if (!firstArg || firstArg === '-') {
    script = await readScriptFromStdin()
    tempPath = getFilepath($.cwd, 'zx', argv.ext)
    if (script.length === 0) {
      printUsage()
      process.exitCode = 1
      throw new Fail('No script provided')
    }
  } else if (/^https?:/.test(firstArg)) {
    const { name, ext = argv.ext } = path.parse(new URL(firstArg).pathname)
    script = await readScriptFromHttp(firstArg)
    tempPath = getFilepath($.cwd, name, ext)
  } else {
    script = await fs.readFile(firstArg, 'utf8')
    scriptPath = firstArg.startsWith('file:')
      ? url.fileURLToPath(firstArg)
      : path.resolve(firstArg)
  }

  const { ext, base, dir } = path.parse(tempPath || scriptPath)
  if (ext === '' || (argv.ext && !EXT_RE.test(ext))) {
    tempPath = getFilepath(dir, base)
  }
  if (ext === '.md') {
    script = transformMarkdown(script)
    tempPath = getFilepath(dir, base)
  }
  if (argSlice) updateArgv(argv._.slice(argSlice))

  return { script, scriptPath, tempPath }
}

async function readScriptFromStdin(): Promise<string> {
  return process.stdin.isTTY ? '' : stdin()
}

async function readScriptFromHttp(remote: string): Promise<string> {
  const res = await fetch(remote)
  if (!res.ok) {
    console.error(`Error: Can't get ${remote}`)
    process.exit(1)
  }
  return res.text()
}

export function injectGlobalRequire(origin: string): void {
  const __filename = path.resolve(origin)
  const __dirname = path.dirname(__filename)
  const require = createRequire(origin)
  Object.assign(globalThis, { __filename, __dirname, require })
}

export function isMain(
  metaurl: string = import.meta.url,
  scriptpath: string = process.argv[1]
): boolean {
  if (metaurl.startsWith('file:')) {
    const modulePath = url.fileURLToPath(metaurl).replace(/\.\w+$/, '')
    const mainPath = fs.realpathSync(scriptpath).replace(/\.\w+$/, '')
    return mainPath === modulePath
  }

  return false
}

export function normalizeExt(ext?: string): string | undefined {
  return ext ? path.parse(`foo.${ext}`).ext : ext
}

// prettier-ignore
function getFilepath(cwd = '.', name = 'zx', _ext?: string): string {
  const ext = _ext || argv.ext || EXT
  return [
    name + ext,
    name + '-' + randomId() + ext,
  ]
    .map(f => path.resolve(process.cwd(), cwd, f))
    .find(f => !fs.existsSync(f))!
}



================================================
FILE: src/core.ts
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { type AsyncHook, AsyncLocalStorage, createHook } from 'node:async_hooks'
import { Buffer } from 'node:buffer'
import cp, {
  type ChildProcess,
  type IOType,
  type StdioOptions,
} from 'node:child_process'
import { type Encoding } from 'node:crypto'
import { EventEmitter } from 'node:events'
import fs from 'node:fs'
import { EOL as _EOL } from 'node:os'
import process from 'node:process'
import { type Readable, type Writable } from 'node:stream'
import { inspect } from 'node:util'

import { Fail } from './error.ts'
import { log } from './log.ts'
import {
  exec,
  buildCmd,
  chalk,
  which,
  ps,
  VoidStream,
  type TSpawnStore,
} from './vendor-core.ts'
import {
  type Duration,
  isString,
  isStringLiteral,
  iteratorToArray,
  getLast,
  getLines,
  noop,
  once,
  parseBool,
  parseDuration,
  preferLocalBin,
  proxyOverride,
  quote,
  quotePowerShell,
  toCamelCase,
  randomId,
  bufArrJoin,
} from './util.ts'

export { default as path } from 'node:path'
export * as os from 'node:os'
export { Fail } from './error.ts'
export { log, type LogEntry } from './log.ts'
export { chalk, which, ps } from './vendor-core.ts'
export { type Duration, quote, quotePowerShell } from './util.ts'

const CWD = Symbol('processCwd')
const SYNC = Symbol('syncExec')
const EPF = Symbol('end-piped-from')
const SHOT = Symbol('snapshot')
const EOL = Buffer.from(_EOL)
const BR_CC = '\n'.charCodeAt(0)
const DLMTR = /\r?\n/
const SIGTERM = 'SIGTERM'
const ENV_PREFIX = 'ZX_'
const ENV_OPTS: Set<string> = new Set([
  'cwd',
  'preferLocal',
  'detached',
  'verbose',
  'quiet',
  'timeout',
  'timeoutSignal',
  'killSignal',
  'prefix',
  'postfix',
  'shell',
])

// prettier-ignore
export interface Options {
  [CWD]:          string
  [SYNC]:         boolean
  cwd?:           string
  ac?:            AbortController
  signal?:        AbortSignal
  input?:         string | Buffer | Readable | ProcessOutput | ProcessPromise
  timeout?:       Duration
  timeoutSignal?: NodeJS.Signals
  stdio:          StdioOptions
  verbose:        boolean
  sync:           boolean
  env:            NodeJS.ProcessEnv
  shell:          string | true
  nothrow:        boolean
  prefix?:        string
  postfix?:       string
  quote?:         typeof quote
  quiet:          boolean
  detached:       boolean
  preferLocal:    boolean | string | string[]
  spawn:          typeof cp.spawn
  spawnSync:      typeof cp.spawnSync
  store?:         TSpawnStore
  log:            typeof log
  kill:           typeof kill
  killSignal?:    NodeJS.Signals
  halt?:          boolean
  delimiter?:     string | RegExp
}

// prettier-ignore
type Snapshot = Options & {
  from:           string
  pieces:         TemplateStringsArray
  args:           string[]
  cmd:            string
  ee:             EventEmitter
  ac:             AbortController
}

// prettier-ignore
export const defaults: Options = resolveDefaults({
  [CWD]:          process.cwd(),
  [SYNC]:         false,
  verbose:        false,
  env:            process.env,
  sync:           false,
  shell:          true,
  stdio:          'pipe',
  nothrow:        false,
  quiet:          false,
  detached:       false,
  preferLocal:    false,
  spawn:          cp.spawn,
  spawnSync:      cp.spawnSync,
  log,
  kill,
  killSignal:     SIGTERM,
  timeoutSignal:  SIGTERM,
})

const storage = new AsyncLocalStorage<Options>()

const getStore = () => storage.getStore() || defaults

const getSnapshot = (
  opts: Options,
  from: string,
  pieces: TemplateStringsArray,
  args: any[]
): Snapshot => ({
  ...opts,
  ac: opts.ac || new AbortController(),
  ee: new EventEmitter(),
  from,
  pieces,
  args,
  cmd: '',
})

export function within<R>(callback: () => R): R {
  return storage.run({ ...getStore() }, callback)
}

// prettier-ignore
export interface Shell<
  S = false,
  R = S extends true ? ProcessOutput : ProcessPromise,
> {
  (pieces: TemplateStringsArray, ...args: any[]): R
  <O extends Partial<Options> = Partial<Options>, R = O extends { sync: true } ? Shell<true> : Shell>(opts: O): R
  sync: {
    (pieces: TemplateStringsArray, ...args: any[]): ProcessOutput
    (opts: Partial<Omit<Options, 'sync'>>): Shell<true>
  }
}

// The zx
export type $ = Shell & Options

export const $: $ = new Proxy<$>(
  // prettier-ignore
  function (pieces: TemplateStringsArray | Partial<Options>, ...args: any[]) {
    const opts = getStore()
    if (!Array.isArray(pieces)) {
      return function (this: any, ...args: any) {
        return within(() => Object.assign($, opts, pieces).apply(this, args))
      }
    }
    const from = Fail.getCallerLocation()
    const cb: PromiseCallback = () => (cb[SHOT] = getSnapshot(opts, from, pieces as TemplateStringsArray, args))
    const pp = new ProcessPromise(cb)

    if (!pp.isHalted()) pp.run()

    return pp.sync ? pp.output : pp
  } as $,
  {
    set(t, key, value) {
      return Reflect.set(
        key in Function.prototype ? t : getStore(),
        key === 'sync' ? SYNC : key,
        value
      )
    },
    get(t, key) {
      return key === 'sync'
        ? $({ sync: true })
        : Reflect.get(key in Function.prototype ? t : getStore(), key)
    },
  }
)

type ProcessStage = 'initial' | 'halted' | 'running' | 'fulfilled' | 'rejected'

type Resolve = (out: ProcessOutput) => void

type Reject = (error: ProcessOutput | Error) => void

type PromiseCallback = {
  (resolve: Resolve, reject: Reject): void
  [SHOT]?: Snapshot
}

type PromisifiedStream<D extends Writable = Writable> = D &
  PromiseLike<ProcessOutput & D> & { run(): void }

type PipeAcceptor = Writable | ProcessPromise
type PipeDest = PipeAcceptor | TemplateStringsArray | string
type PipeMethod = {
  (dest: TemplateStringsArray, ...args: any[]): ProcessPromise
  (file: string): PromisifiedStream
  <D extends Writable>(dest: D): PromisifiedStream<D>
  <D extends ProcessPromise>(dest: D): D
}

export class ProcessPromise extends Promise<ProcessOutput> {
  private _stage: ProcessStage = 'initial'
  private _id = randomId()
  private _snapshot!: Snapshot
  private _timeoutId?: ReturnType<typeof setTimeout>
  private _piped = false
  private _stdin = new VoidStream()
  private _zurk: ReturnType<typeof exec> | null = null
  private _output: ProcessOutput | null = null
  private _resolve!: Resolve
  private _reject!: Reject

  constructor(executor: PromiseCallback) {
    let resolve: Resolve
    let reject: Reject
    super((...args) => {
      ;[resolve = noop, reject = noop] = args
      executor(...args)
    })

    const snapshot = executor[SHOT]
    if (snapshot) {
      this._snapshot = snapshot
      this._resolve = resolve!
      this._reject = reject!
      if (snapshot.halt) this._stage = 'halted'
      try {
        this.build()
      } catch (err) {
        this.finalize(ProcessOutput.fromError(err as Error), true)
      }
    } else ProcessPromise.disarm(this)
  }
  // prettier-ignore
  private build(): void {
    const $ = this._snapshot
    if (!$.shell)
      throw new Fail(`No shell is available: ${Fail.DOCS_URL}/shell`)
    if (!$.quote)
      throw new Fail(`No quote function is defined: ${Fail.DOCS_URL}/quotes`)
    if ($.pieces.some((p) => p == null))
      throw new Fail(`Malformed command at ${$.from}`)

    $.cmd = buildCmd(
      $.quote!,
      $.pieces as TemplateStringsArray,
      $.args
    ) as string
  }
  run(): this {
    ProcessPromise.bus.runBack(this)
    if (this.isRunning() || this.isSettled()) return this // The _run() can be called from a few places.
    this._stage = 'running'

    const self = this
    const $ = self._snapshot
    const id = self.id
    const cwd = $.cwd || $[CWD]

    if ($.preferLocal) {
      const dirs =
        $.preferLocal === true ? [$.cwd, $[CWD]] : [$.preferLocal].flat()
      $.env = preferLocalBin($.env, ...dirs)
    }

    // prettier-ignore
    this._zurk = exec({
      cmd:      self.fullCmd,
      cwd,
      input:    ($.input as ProcessPromise | ProcessOutput)?.stdout ?? $.input,
      stdin:    self._stdin,
      sync:     self.sync,
      signal:   self.signal,
      shell:    isString($.shell) ? $.shell : true,
      id,
      env:      $.env,
      spawn:    $.spawn,
      spawnSync:$.spawnSync,
      store:    $.store,
      stdio:    $.stdio,
      detached: $.detached,
      ee:       $.ee,
      run(cb, ctx){
        (self.cmd as unknown as Promise<string>).then?.(
          cmd => {
            $.cmd = cmd
            ctx.cmd = self.fullCmd
            cb()
          },
          error => self.finalize(ProcessOutput.fromError(error))
        ) || cb()
      },
      on: {
        start: () => {
          $.log({ kind: 'cmd', cmd: $.cmd, cwd, verbose: self.isVerbose(), id })
          self.timeout($.timeout, $.timeoutSignal)
        },
        stdout: (data) => {
          // If the process is piped, don't print its output.
          $.log({ kind: 'stdout', data, verbose: !self._piped && self.isVerbose(), id })
        },
        stderr: (data) => {
          // Stderr should be printed regardless of piping.
          $.log({ kind: 'stderr', data, verbose: !self.isQuiet(), id })
        },
        end: (data, c) => {
          const { error: _error, status, signal: __signal, duration, ctx: { store }} = data
          const { stdout, stderr } = store
          const { cause, exitCode, signal: _signal } = self._breakerData || {}

          const signal = _signal ?? __signal
          const code = exitCode ?? status
          const error = cause ?? _error
          const output = new ProcessOutput({
            code,
            signal,
            error,
            duration,
            store,
            from: $.from,
          })

          $.log({ kind: 'end', signal, exitCode: code, duration, error, verbose: self.isVerbose(), id })

          // Ensures EOL
          if (stdout.length && getLast(getLast(stdout)) !== BR_CC) c.on.stdout!(EOL, c)
          if (stderr.length && getLast(getLast(stderr)) !== BR_CC) c.on.stderr!(EOL, c)

          self.finalize(output)
        },
      },
    })

    return this
  }
  private _breakerData?: Partial<
    Pick<ProcessOutput, 'exitCode' | 'signal' | 'cause'>
  >

  private break(
    exitCode?: ProcessOutput['exitCode'],
    signal?: ProcessOutput['signal'],
    cause?: ProcessOutput['cause']
  ): void {
    if (!this.isRunning()) return
    this._breakerData = { exitCode, signal, cause }
    this.kill(signal)
  }

  private finalize(output: ProcessOutput, legacy = false): void {
    if (this.isSettled()) return
    this._output = output
    ProcessPromise.bus.unpipeBack(this)
    if (output.ok || this.isNothrow()) {
      this._stage = 'fulfilled'
      this._resolve(output)
    } else {
      this._stage = 'rejected'
      if (legacy) {
        this._resolve(output) // to avoid unhandledRejection alerts
        throw output.cause || output
      }
      this._reject(output)
      if (this.sync) throw output
    }
  }

  abort(reason?: string) {
    if (this.isSettled()) throw new Fail('Too late to abort the process.')
    if (this.signal !== this.ac.signal)
      throw new Fail('The signal is controlled by another process.')
    if (!this.child)
      throw new Fail('Trying to abort a process without creating one.')

    this.ac.abort(reason)
  }

  kill(signal?: NodeJS.Signals | null): Promise<void> {
    if (this.isSettled()) throw new Fail('Too late to kill the process.')
    if (!this.child)
      throw new Fail('Trying to kill a process without creating one.')
    if (!this.pid) throw new Fail('The process pid is undefined.')

    return $.kill(this.pid, signal || this._snapshot.killSignal || $.killSignal)
  }

  // Configurators
  stdio(
    stdin: IOType | StdioOptions,
    stdout: IOType = 'pipe',
    stderr: IOType = 'pipe'
  ): this {
    this._snapshot.stdio = Array.isArray(stdin)
      ? stdin
      : [stdin, stdout, stderr]
    return this
  }

  nothrow(v = true): this {
    this._snapshot.nothrow = v
    return this
  }

  quiet(v = true): this {
    this._snapshot.quiet = v
    return this
  }

  verbose(v = true): this {
    this._snapshot.verbose = v
    return this
  }

  timeout(d: Duration = 0, signal = $.timeoutSignal): this {
    if (this.isSettled()) return this

    const $ = this._snapshot
    $.timeout = parseDuration(d)
    $.timeoutSignal = signal

    if (this._timeoutId) clearTimeout(this._timeoutId)
    if ($.timeout && this.isRunning()) {
      this._timeoutId = setTimeout(() => this.kill($.timeoutSignal), $.timeout)
      this.finally(() => clearTimeout(this._timeoutId)).catch(noop)
    }
    return this
  }
  /**
   *  @deprecated Use $({halt: true})`cmd` instead.
   */
  halt(): this {
    return this
  }

  // Getters
  get id(): string {
    return this._id
  }

  get pid(): number | undefined {
    return this.child?.pid
  }

  get cmd(): string {
    return this._snapshot.cmd
  }

  get fullCmd(): string {
    const { prefix = '', postfix = '', cmd } = this._snapshot
    return prefix + cmd + postfix
  }

  get child(): ChildProcess | undefined {
    return this._zurk?.child
  }

  get stdin(): Writable {
    return this.child?.stdin!
  }

  get stdout(): Readable {
    return this.child?.stdout!
  }

  get stderr(): Readable {
    return this.child?.stderr!
  }

  get exitCode(): Promise<number | null> {
    return this.then(
      (o) => o.exitCode,
      (o) => o.exitCode
    )
  }

  get signal(): AbortSignal {
    return this._snapshot.signal || this.ac.signal
  }

  get ac(): AbortController {
    return this._snapshot.ac
  }

  get output(): ProcessOutput | null {
    return this._output
  }

  get stage(): ProcessStage {
    return this._stage
  }

  get sync(): boolean {
    return this._snapshot[SYNC]
  }

  override get [Symbol.toStringTag](): string {
    return 'ProcessPromise'
  }

  [Symbol.toPrimitive](): string {
    return this.toString()
  }

  // Output formatters
  json<T = any>(): Promise<T> {
    return this.then((o) => o.json<T>())
  }

  text(encoding?: Encoding): Promise<string> {
    return this.then((o) => o.text(encoding))
  }

  lines(delimiter?: Options['delimiter']): Promise<string[]> {
    return this.then((o) => o.lines(delimiter))
  }

  buffer(): Promise<Buffer> {
    return this.then((o) => o.buffer())
  }

  blob(type?: string): Promise<Blob> {
    return this.then((o) => o.blob(type))
  }

  // Status checkers
  isQuiet(): boolean {
    return this._snapshot.quiet
  }

  isVerbose(): boolean {
    return this._snapshot.verbose && !this.isQuiet()
  }

  isNothrow(): boolean {
    return this._snapshot.nothrow
  }

  isHalted(): boolean {
    return this.stage === 'halted' && !this.sync
  }

  private isSettled(): boolean {
    return !!this.output
  }

  private isRunning(): boolean {
    return this.stage === 'running'
  }

  // Piping
  // prettier-ignore
  get pipe(): PipeMethod & {
    [key in keyof TSpawnStore]: PipeMethod
  } {
    const getPipeMethod = (kind: keyof TSpawnStore) => this._pipe.bind(this, kind) as PipeMethod
    const stdout = getPipeMethod('stdout')
    const stderr = getPipeMethod('stderr')
    const stdall = getPipeMethod('stdall')
    return Object.assign(stdout, { stdout, stderr, stdall })
  }

  unpipe(to?: PipeAcceptor): this {
    ProcessPromise.bus.unpipe(this, to)
    return this
  }

  // prettier-ignore
  private _pipe(source: keyof TSpawnStore, dest: PipeDest, ...args: any[]): PromisifiedStream | ProcessPromise {
    if (isString(dest))
      return this._pipe(source, fs.createWriteStream(dest))

    if (isStringLiteral(dest, ...args))
      return this._pipe(
        source,
        $({
          halt: true,
          signal: this.signal,
        })(dest as TemplateStringsArray, ...args)
      )

    const isP = dest instanceof ProcessPromise
    if (isP && dest.isSettled()) throw new Fail('Cannot pipe to a settled process.')
    if (!isP && dest.writableEnded) throw new Fail('Cannot pipe to a closed stream.')

    this._piped = true
    ProcessPromise.bus.pipe(this, dest)

    const { ee } = this._snapshot
    const output = this.output
    const from = new VoidStream()
    const check = () => !!ProcessPromise.bus.refs.get(this)?.has(dest)
    const end = () => {
      if (!check()) return
      setImmediate(() => {
        ProcessPromise.bus.unpipe(this, dest)
        ProcessPromise.bus.sources(dest).length === 0 && from.end()
      })
    }
    const fill = () => {
      for (const chunk of this._zurk!.store[source]) from.write(chunk)
    }
    const fillSettled = () => {
      if (!output) return
      if (isP && !output.ok) dest.break(output.exitCode, output.signal, output.cause)
      fill()
      end()
    }

    if (!output) {
      const onData = (chunk: string | Buffer) => check() && from.write(chunk)
      ee
        .once(source, () => {
          fill()
          ee.on(source, onData)
        })
        .once('end', () => {
          ee.removeListener(source, onData)
          end()
        })
    }

    if (isP) {
      from.pipe(dest._stdin)
      if (this.isHalted()) ee.once('start', () => dest.run())
      else {
        dest.run()
        this.catch((e) => dest.break(e.exitCode, e.signal, e.cause))
      }
      fillSettled()
      return dest
    }

    from.once('end', () => dest.emit(EPF)).pipe(dest)
    fillSettled()
    return ProcessPromise.promisifyStream(dest, this)
  }

  // prettier-ignore
  private static bus = {
    refs: new Map<ProcessPromise, Set<PipeAcceptor>>,
    streams: new WeakMap<Writable, PromisifiedStream>(),
    pipe(from: ProcessPromise, to: PipeAcceptor) {
      const set = this.refs.get(from) || (this.refs.set(from, new Set())).get(from)!
      set.add(to)
    },
    unpipe(from: ProcessPromise, to?: PipeAcceptor) {
      const set = this.refs.get(from)
      if (!set) return
      if (to) set.delete(to)
      if (set.size) return
      this.refs.delete(from)
      from._piped = false
    },
    unpipeBack(to: ProcessPromise, from?: ProcessPromise) {
      if (from) return this.unpipe(from, to)
      for (const _from of this.refs.keys()) {
        this.unpipe(_from, to)
      }
    },
    runBack(p: PipeAcceptor) {
      for (const from of this.sources(p)) {
        if (from instanceof ProcessPromise) from.run()
        else this.streams.get(from)?.run()
      }
    },
    sources(p: PipeAcceptor): PipeAcceptor[] {
      const refs = []
      for (const [from, set] of this.refs.entries()) {
        set.has(p) && refs.push(from)
      }
      return refs
    }
  }

  private static promisifyStream = <S extends Writable>(
    stream: S,
    from: ProcessPromise
  ): PromisifiedStream<S> => {
    const proxy =
      ProcessPromise.bus.streams.get(stream) ||
      proxyOverride(stream as PromisifiedStream<S>, {
        then(res: any = noop, rej: any = noop) {
          return new Promise((_res, _rej) => {
            const end = () => _res(res(proxyOverride(stream, from.output)))
            stream
              .once('error', (e) => _rej(rej(e)))
              .once('finish', end)
              .once(EPF, end)
          })
        },
        run() {
          from.run()
        },
        pipe(...args: any) {
          const dest = stream.pipe.apply(stream, args)
          return dest instanceof ProcessPromise
            ? dest
            : ProcessPromise.promisifyStream(dest as Writable, from)
        },
      })

    ProcessPromise.bus.streams.set(stream, proxy as any)
    return proxy as PromisifiedStream<S>
  }

  // Promise API
  override then<R = ProcessOutput, E = ProcessOutput>(
    onfulfilled?:
      | ((value: ProcessOutput) => PromiseLike<R> | R)
      | undefined
      | null,
    onrejected?:
      | ((reason: ProcessOutput) => PromiseLike<E> | E)
      | undefined
      | null
  ): Promise<R | E> {
    return super.then(onfulfilled, onrejected)
  }

  override catch<T = ProcessOutput>(
    onrejected?:
      | ((reason: ProcessOutput) => PromiseLike<T> | T)
      | undefined
      | null
  ): Promise<ProcessOutput | T> {
    return super.catch(onrejected)
  }

  // Async iterator API
  async *[Symbol.asyncIterator](): AsyncIterator<string> {
    const memo: (string | undefined)[] = []
    const dlmtr = this._snapshot.delimiter || $.delimiter || DLMTR

    for (const chunk of this._zurk!.store.stdout) {
      yield* getLines(chunk, memo, dlmtr)
    }

    for await (const chunk of this.stdout || []) {
      yield* getLines(chunk, memo, dlmtr)
    }

    if (memo[0]) yield memo[0]

    await this
  }

  // Stream-like API
  private writable = true
  private emit(event: string, ...args: any[]) {
    return this
  }
  private on(event: string, cb: any) {
    this._stdin.on(event, cb)
    return this
  }
  private once(event: string, cb: any) {
    this._stdin.once(event, cb)
    return this
  }
  private write(data: any, encoding: NodeJS.BufferEncoding, cb: any) {
    this._stdin.write(data, encoding, cb)
    return this
  }
  private end(chunk: any, cb: any) {
    this._stdin.end(chunk, cb)
    return this
  }
  private removeListener(event: string, cb: any) {
    this._stdin.removeListener(event, cb)
    return this
  }

  // prettier-ignore
  private static disarm(p: ProcessPromise, toggle = true): void {
    Object.getOwnPropertyNames(ProcessPromise.prototype).forEach(k => {
      if (k in Promise.prototype) return
      if (!toggle) { Reflect.deleteProperty(p, k); return }
      Object.defineProperty(p, k, { configurable: true, get() {
        throw new Fail('Inappropriate usage. Apply $ instead of direct instantiation.')
      }})
    })
  }
}

type ProcessDto = {
  code: number | null
  signal: NodeJS.Signals | null
  duration: number
  error: any
  from: string
  store: TSpawnStore
  delimiter?: string | RegExp
}

export class ProcessOutput extends Error {
  private readonly _dto!: ProcessDto
  cause!: Error | null
  message!: string
  stdout!: string
  stderr!: string
  stdall!: string
  constructor(dto: ProcessDto)
  constructor(
    code?: number | null,
    signal?: NodeJS.Signals | null,
    stdout?: string,
    stderr?: string,
    stdall?: string,
    message?: string,
    duration?: number
  )
  // prettier-ignore
  constructor(
    code: number | null | ProcessDto = null,
    signal: NodeJS.Signals | null = null,
    stdout: string = '',
    stderr: string = '',
    stdall: string = '',
    message: string = '',
    duration: number = 0,
    error: any = null,
    from: string = '',
    store: TSpawnStore = { stdout: [stdout], stderr: [stderr], stdall: [stdall], }
  ) {
    super(message)
    const dto = code !== null && typeof code === 'object'
      ? code
      : { code, signal, duration, error, from, store }

    Object.defineProperties(this, {
      _dto: { value: dto, enumerable: false },
      cause: { get() { return dto.error }, enumerable: false },
      stdout: { get: once(() => bufArrJoin(dto.store.stdout)) },
      stderr: { get: once(() => bufArrJoin(dto.store.stderr)) },
      stdall: { get: once(() => bufArrJoin(dto.store.stdall)) },
      message: { get: once(() =>
        dto.error || message
          ? ProcessOutput.getErrorMessage(dto.error || new Error(message), dto.from)
          : ProcessOutput.getExitMessage(
            dto.code,
            dto.signal,
            this.stderr,
            dto.from,
            this.stderr.trim() ? '' : ProcessOutput.getErrorDetails(this.lines())
          )
      )},
    })
  }

  get exitCode(): number | null {
    return this._dto.code
  }

  get signal(): NodeJS.Signals | null {
    return this._dto.signal
  }

  get duration(): number {
    return this._dto.duration
  }

  get [Symbol.toStringTag](): string {
    return 'ProcessOutput'
  }

  get ok(): boolean {
    return !this._dto.error && this.exitCode === 0
  }

  json<T = any>(): T {
    return JSON.parse(this.stdall)
  }

  buffer(): Buffer {
    return Buffer.from(this.stdall)
  }

  blob(type = 'text/plain'): Blob {
    if (!globalThis.Blob)
      throw new Fail(
        'Blob is not supported in this environment. Provide a polyfill'
      )
    return new Blob([this.buffer()], { type })
  }

  text(encoding: Encoding = 'utf8'): string {
    return encoding === 'utf8'
      ? this.toString()
      : this.buffer().toString(encoding)
  }

  lines(delimiter?: string | RegExp): string[] {
    return iteratorToArray(this[Symbol.iterator](delimiter))
  }

  override toString(): string {
    return this.stdall
  }

  override valueOf(): string {
    return this.stdall.trim()
  }

  [Symbol.toPrimitive](): string {
    return this.valueOf()
  }
  // prettier-ignore
  *[Symbol.iterator](dlmtr: Options['delimiter'] = this._dto.delimiter || $.delimiter || DLMTR): Iterator<string> {
    const memo: (string | undefined)[] = []
    for (const chunk of this._dto.store.stdall) {
      yield* getLines(chunk, memo, dlmtr)
    }

    if (memo[0]) yield memo[0]
  }

  [inspect.custom](): string {
    const codeInfo = ProcessOutput.getExitCodeInfo(this.exitCode)

    return `ProcessOutput {
  stdout: ${chalk.green(inspect(this.stdout))},
  stderr: ${chalk.red(inspect(this.stderr))},
  signal: ${inspect(this.signal)},
  exitCode: ${(this.ok ? chalk.green : chalk.red)(this.exitCode)}${
    codeInfo ? chalk.grey(' (' + codeInfo + ')') : ''
  },
  duration: ${this.duration}
}`
  }

  static getExitMessage = Fail.formatExitMessage
  static getErrorMessage = Fail.formatErrorMessage
  static getErrorDetails = Fail.formatErrorDetails
  static getExitCodeInfo = Fail.getExitCodeInfo

  static fromError(error: Error): ProcessOutput {
    const output = new ProcessOutput()
    output._dto.error = error
    return output
  }
}

export const useBash = (): void => setShell('bash', false)
export const usePwsh = (): void => setShell('pwsh')
export const usePowerShell = (): void => setShell('powershell.exe')
function setShell(n: string, ps = true) {
  $.shell = which.sync(n)
  $.prefix = ps ? '' : 'set -euo pipefail;'
  $.postfix = ps ? '; exit $LastExitCode' : ''
  $.quote = ps ? quotePowerShell : quote
}

try {
  const { shell, prefix, postfix } = $
  useBash()
  if (isString(shell)) $.shell = shell
  if (isString(prefix)) $.prefix = prefix
  if (isString(postfix)) $.postfix = postfix
} catch (err) {}

let cwdSyncHook: AsyncHook

export function syncProcessCwd(flag: boolean = true) {
  cwdSyncHook =
    cwdSyncHook ||
    createHook({
      init: syncCwd,
      before: syncCwd,
      promiseResolve: syncCwd,
      after: syncCwd,
      destroy: syncCwd,
    })
  if (flag) cwdSyncHook.enable()
  else cwdSyncHook.disable()
}

function syncCwd() {
  if ($[CWD] != process.cwd()) process.chdir($[CWD])
}

export function cd(dir: string | ProcessOutput) {
  if (dir instanceof ProcessOutput) {
    dir = dir.toString().trim()
  }

  $.log({ kind: 'cd', dir, verbose: !$.quiet && $.verbose })
  process.chdir(dir)
  $[CWD] = process.cwd()
}

export async function kill(pid: number, signal = $.killSignal || SIGTERM) {
  $.log({ kind: 'kill', pid, signal, verbose: !$.quiet && $.verbose })
  if (
    process.platform === 'win32' &&
    (await new Promise((resolve) => {
      cp.exec(`taskkill /pid ${pid} /t /f`, (err) => resolve(!err))
    }))
  )
    return

  for (const p of await ps.tree({ pid, recursive: true })) {
    try {
      process.kill(+p.pid, signal)
    } catch (e) {}
  }
  try {
    process.kill(-pid, signal)
  } catch (e) {
    try {
      process.kill(+pid, signal)
    } catch (e) {}
  }
}

export function resolveDefaults(
  defs: Options = defaults,
  prefix: string = ENV_PREFIX,
  env = process.env,
  allowed = ENV_OPTS
): Options {
  return Object.entries(env).reduce<Options>((m, [k, v]) => {
    if (v && k.startsWith(prefix)) {
      const _k = toCamelCase(k.slice(prefix.length))
      const _v = parseBool(v)
      if (allowed.has(_k)) (m as any)[_k] = _v
    }
    return m
  }, defs)
}



================================================
FILE: src/deps.ts
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { builtinModules } from 'node:module'
import { $, spinner, Fail } from './index.ts'
import { depseek } from './vendor.ts'

/**
 * Install npm dependencies
 * @param dependencies object of dependencies
 * @param prefix  path to the directory where npm should install the dependencies
 * @param registry custom npm registry URL when installing dependencies
 * @param installerType package manager: npm, yarn, pnpm, bun, etc.
 */
export async function installDeps(
  dependencies: Record<string, string>,
  prefix?: string,
  registry?: string,
  installerType = 'npm'
): Promise<void> {
  const installer = installers[installerType]
  const packages = Object.entries(dependencies).map(
    ([name, version]) => `${name}@${version}`
  )
  if (packages.length === 0) return
  if (!installer) {
    throw new Fail(
      `Unsupported installer type: ${installerType}. Supported types: ${Object.keys(installers).join(', ')}`
    )
  }

  await spinner(`${installerType} i ${packages.join(' ')}`, () =>
    installer({ packages, prefix, registry })
  )
}

type DepsInstaller = (opts: {
  packages: string[]
  registry?: string
  prefix?: string
}) => Promise<void>

const installers: Record<any, DepsInstaller> = {
  npm: async ({ packages, prefix, registry }) => {
    const flags = [
      '--no-save',
      '--no-audit',
      '--no-fund',
      prefix && `--prefix=${prefix}`,
      registry && `--registry=${registry}`,
    ].filter(Boolean)
    await $`npm install ${flags} ${packages}`.nothrow()
  },
}

const builtins = new Set(builtinModules)

const nameRe = /^(?<name>(@[a-z\d-~][\w-.~]*\/)?[a-z\d-~][\w-.~]*)\/?.*$/i
const versionRe = /^@(?<version>[~^]?(v?[\dx*]+([-.][\d*a-z-]+)*))/i

export function parseDeps(content: string): Record<string, string> {
  return depseek(content + '\n', { comments: true }).reduce<
    Record<string, string>
  >((m, { type, value }, i, list) => {
    if (type === 'dep') {
      const meta = list[i + 1]
      const name = parsePackageName(value)
      const version =
        (meta?.type === 'comment' && parseVersion(meta?.value.trim())) ||
        'latest'
      if (name) m[name] = version
    }
    return m
  }, {})
}

function parsePackageName(path?: string): string | undefined {
  if (!path) return

  const name = nameRe.exec(path)?.groups?.name
  if (name && !builtins.has(name)) return name
}

function parseVersion(line: string) {
  return versionRe.exec(line)?.groups?.version || 'latest'
}



================================================
FILE: src/error.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const EXIT_CODES: Record<number, string> = {
  2: 'Misuse of shell builtins',
  126: 'Invoked command cannot execute',
  127: 'Command not found',
  128: 'Invalid exit argument',
  129: 'Hangup',
  130: 'Interrupt',
  131: 'Quit and dump core',
  132: 'Illegal instruction',
  133: 'Trace/breakpoint trap',
  134: 'Process aborted',
  135: 'Bus error: "access to undefined portion of memory object"',
  136: 'Floating point exception: "erroneous arithmetic operation"',
  137: 'Kill (terminate immediately)',
  138: 'User-defined 1',
  139: 'Segmentation violation',
  140: 'User-defined 2',
  141: 'Write to pipe with no one reading',
  142: 'Signal raised by alarm',
  143: 'Termination (request to terminate)',
  145: 'Child process terminated, stopped (or continued*)',
  146: 'Continue if stopped',
  147: 'Stop executing temporarily',
  148: 'Terminal stop signal',
  149: 'Background process attempting to read from tty ("in")',
  150: 'Background process attempting to write to tty ("out")',
  151: 'Urgent data available on socket',
  152: 'CPU time limit exceeded',
  153: 'File size limit exceeded',
  154: 'Signal raised by timer counting virtual time: "virtual timer expired"',
  155: 'Profiling timer expired',
  157: 'Pollable event',
  159: 'Bad syscall',
}

const ERRNO_CODES: Record<number, string> = {
  0: 'Success',
  1: 'Not super-user',
  2: 'No such file or directory',
  3: 'No such process',
  4: 'Interrupted system call',
  5: 'I/O error',
  6: 'No such device or address',
  7: 'Arg list too long',
  8: 'Exec format error',
  9: 'Bad file number',
  10: 'No children',
  11: 'No more processes',
  12: 'Not enough core',
  13: 'Permission denied',
  14: 'Bad address',
  15: 'Block device required',
  16: 'Mount device busy',
  17: 'File exists',
  18: 'Cross-device link',
  19: 'No such device',
  20: 'Not a directory',
  21: 'Is a directory',
  22: 'Invalid argument',
  23: 'Too many open files in system',
  24: 'Too many open files',
  25: 'Not a typewriter',
  26: 'Text file busy',
  27: 'File too large',
  28: 'No space left on device',
  29: 'Illegal seek',
  30: 'Read only file system',
  31: 'Too many links',
  32: 'Broken pipe',
  33: 'Math arg out of domain of func',
  34: 'Math result not representable',
  35: 'File locking deadlock error',
  36: 'File or path name too long',
  37: 'No record locks available',
  38: 'Function not implemented',
  39: 'Directory not empty',
  40: 'Too many symbolic links',
  42: 'No message of desired type',
  43: 'Identifier removed',
  44: 'Channel number out of range',
  45: 'Level 2 not synchronized',
  46: 'Level 3 halted',
  47: 'Level 3 reset',
  48: 'Link number out of range',
  49: 'Protocol driver not attached',
  50: 'No CSI structure available',
  51: 'Level 2 halted',
  52: 'Invalid exchange',
  53: 'Invalid request descriptor',
  54: 'Exchange full',
  55: 'No anode',
  56: 'Invalid request code',
  57: 'Invalid slot',
  59: 'Bad font file fmt',
  60: 'Device not a stream',
  61: 'No data (for no delay io)',
  62: 'Timer expired',
  63: 'Out of streams resources',
  64: 'Machine is not on the network',
  65: 'Package not installed',
  66: 'The object is remote',
  67: 'The link has been severed',
  68: 'Advertise error',
  69: 'Srmount error',
  70: 'Communication error on send',
  71: 'Protocol error',
  72: 'Multihop attempted',
  73: 'Cross mount point (not really error)',
  74: 'Trying to read unreadable message',
  75: 'Value too large for defined data type',
  76: 'Given log. name not unique',
  77: 'f.d. invalid for this operation',
  78: 'Remote address changed',
  79: 'Can   access a needed shared lib',
  80: 'Accessing a corrupted shared lib',
  81: '.lib section in a.out corrupted',
  82: 'Attempting to link in too many libs',
  83: 'Attempting to exec a shared library',
  84: 'Illegal byte sequence',
  86: 'Streams pipe error',
  87: 'Too many users',
  88: 'Socket operation on non-socket',
  89: 'Destination address required',
  90: 'Message too long',
  91: 'Protocol wrong type for socket',
  92: 'Protocol not available',
  93: 'Unknown protocol',
  94: 'Socket type not supported',
  95: 'Not supported',
  96: 'Protocol family not supported',
  97: 'Address family not supported by protocol family',
  98: 'Address already in use',
  99: 'Address not available',
  100: 'Network interface is not configured',
  101: 'Network is unreachable',
  102: 'Connection reset by network',
  103: 'Connection aborted',
  104: 'Connection reset by peer',
  105: 'No buffer space available',
  106: 'Socket is already connected',
  107: 'Socket is not connected',
  108: "Can't send after socket shutdown",
  109: 'Too many references',
  110: 'Connection timed out',
  111: 'Connection refused',
  112: 'Host is down',
  113: 'Host is unreachable',
  114: 'Socket already connected',
  115: 'Connection already in progress',
  116: 'Stale file handle',
  122: 'Quota exceeded',
  123: 'No medium (in tape drive)',
  125: 'Operation canceled',
  130: 'Previous owner died',
  131: 'State not recoverable',
}

const DOCS_URL = 'https://google.github.io/zx'

export class Fail extends Error {
  static DOCS_URL = DOCS_URL
  static EXIT_CODES = EXIT_CODES
  static ERRNO_CODES = ERRNO_CODES

  static formatExitMessage(
    code: number | null,
    signal: NodeJS.Signals | null,
    stderr: string,
    from: string,
    details: string = ''
  ): string {
    if (code == 0 && signal == null) return `exit code: ${code}`

    const codeInfo = Fail.getExitCodeInfo(code)
    let message = `${stderr}
    at ${from}
    exit code: ${code}${codeInfo ? ' (' + codeInfo + ')' : ''}`

    if (signal != null) message += `\n    signal: ${signal}`

    if (details) message += `\n    details: \n${details}`

    return message
  }

  static formatErrorMessage(err: NodeJS.ErrnoException, from: string): string {
    return `${err.message}
    errno: ${err.errno} (${Fail.getErrnoMessage(err.errno)})
    code: ${err.code}
    at ${from}`
  }

  static formatErrorDetails(lines: string[] = [], lim = 20): string {
    if (lines.length < lim) return lines.join('\n')

    let errors = lines.filter((l) => /(fail|error|not ok|exception)/i.test(l))
    if (errors.length === 0) errors = lines
    return (
      errors.slice(0, lim).join('\n') + (errors.length > lim ? '\n...' : '')
    )
  }

  static getExitCodeInfo(exitCode: number | null): string | undefined {
    return EXIT_CODES[exitCode as keyof typeof EXIT_CODES]
  }

  static getCallerLocationFromString(stackString = 'unknown'): string {
    const lines = stackString
      .split(/^\s*(at\s)?/m)
      .filter((s) => s?.includes(':'))
    const i = lines.findIndex((l) => l.includes('Proxy.set'))
    const offset = i < 0 ? i : i + 2

    return (
      lines.find((l) => l.includes('file://')) ||
      lines[offset] ||
      stackString
    ).trim()
  }

  static getCallerLocation(err: Error = new Error('zx error')): string {
    return Fail.getCallerLocationFromString(err.stack)
  }

  static getErrnoMessage(errno?: number): string {
    return (
      ERRNO_CODES[-(errno as number) as keyof typeof ERRNO_CODES] ||
      'Unknown error'
    )
  }
}



================================================
FILE: src/globals-jsr.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as _ from './index.ts'
Object.assign(globalThis, _)



================================================
FILE: src/globals.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as _ from './index.ts'

Object.assign(globalThis, _)
// TODO: global types not working with jsr.io
declare global {
  type ProcessPromise = _.ProcessPromise
  type ProcessOutput = _.ProcessOutput
  var ProcessPromise: typeof _.ProcessPromise
  var ProcessOutput: typeof _.ProcessOutput
  var $: typeof _.$
  var argv: typeof _.argv
  var cd: typeof _.cd
  var chalk: typeof _.chalk
  var defaults: typeof _.defaults
  var dotenv: typeof _.dotenv
  var echo: typeof _.echo
  var expBackoff: typeof _.expBackoff
  var fs: typeof _.fs
  var glob: typeof _.glob
  var globby: typeof _.globby
  var kill: typeof _.kill
  var log: typeof _.log
  var minimist: typeof _.minimist
  var nothrow: typeof _.nothrow
  var os: typeof _.os
  var parseArgv: typeof _.parseArgv
  var path: typeof _.path
  var ps: typeof _.ps
  var question: typeof _.question
  var quiet: typeof _.quiet
  var quote: typeof _.quote
  var quotePowerShell: typeof _.quotePowerShell
  var resolveDefaults: typeof _.resolveDefaults
  var retry: typeof _.retry
  var sleep: typeof _.sleep
  var spinner: typeof _.spinner
  var stdin: typeof _.stdin
  var syncProcessCwd: typeof _.syncProcessCwd
  var tempdir: typeof _.tempdir
  var tempfile: typeof _.tempfile
  var tmpdir: typeof _.tempdir
  var tmpfile: typeof _.tempfile
  var updateArgv: typeof _.updateArgv
  var usePowerShell: typeof _.usePowerShell
  var usePwsh: typeof _.usePwsh
  var useBash: typeof _.useBash
  var version: typeof _.version
  var VERSION: typeof _.VERSION
  var which: typeof _.which
  var within: typeof _.within
  var YAML: typeof _.YAML
}



================================================
FILE: src/goods.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { Buffer } from 'node:buffer'
import process from 'node:process'
import { createInterface } from 'node:readline'
import { Readable } from 'node:stream'
import { type Mode } from 'node:fs'
import {
  $,
  within,
  ProcessOutput,
  type ProcessPromise,
  path,
  os,
  Fail,
} from './core.ts'
import {
  type Duration,
  getLast,
  identity,
  isStringLiteral,
  parseBool,
  parseDuration,
  randomId,
  toCamelCase,
} from './util.ts'
import {
  type RequestInfo,
  type RequestInit,
  nodeFetch,
  minimist,
  fs,
} from './vendor.ts'

export { versions } from './versions.ts'

export function tempdir(
  prefix: string = `zx-${randomId()}`,
  mode?: Mode
): string {
  const dirpath = path.join(os.tmpdir(), prefix)
  fs.mkdirSync(dirpath, { recursive: true, mode })

  return dirpath
}

export function tempfile(
  name?: string,
  data?: string | Buffer,
  mode?: Mode
): string {
  const filepath = name
    ? path.join(tempdir(), name)
    : path.join(os.tmpdir(), `zx-${randomId()}`)

  if (data === undefined) fs.closeSync(fs.openSync(filepath, 'w', mode))
  else fs.writeFileSync(filepath, data, { mode })

  return filepath
}

export { tempdir as tmpdir, tempfile as tmpfile }

type ArgvOpts = minimist.Opts & { camelCase?: boolean; parseBoolean?: boolean }

export const parseArgv = (
  args: string[] = process.argv.slice(2),
  opts: ArgvOpts = {},
  defs: Record<string, any> = {}
): minimist.ParsedArgs =>
  Object.entries<string>(minimist(args, opts)).reduce<minimist.ParsedArgs>(
    (m, [k, v]) => {
      const kTrans = opts.camelCase ? toCamelCase : identity
      const vTrans = opts.parseBoolean ? parseBool : identity
      const [_k, _v] = k === '--' || k === '_' ? [k, v] : [kTrans(k), vTrans(v)]
      m[_k] = _v
      return m
    },
    defs as minimist.ParsedArgs
  )

export function updateArgv(args?: string[], opts?: ArgvOpts) {
  for (const k in argv) delete argv[k]
  parseArgv(args, opts, argv)
}

export const argv: minimist.ParsedArgs = parseArgv()

export function sleep(duration: Duration): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(resolve, parseDuration(duration))
  })
}

const responseToReadable = (response: Response, rs: Readable) => {
  const reader = response.body?.getReader()
  if (!reader) {
    rs.push(null)
    return rs
  }
  rs._read = async () => {
    const result = await reader.read()
    rs.push(result.done ? null : Buffer.from(result.value))
  }
  return rs
}

export function fetch(
  url: RequestInfo,
  init?: RequestInit
): Promise<Response> & {
  pipe: {
    (dest: TemplateStringsArray, ...args: any[]): ProcessPromise
    <D>(dest: D): D
  }
} {
  $.log({ kind: 'fetch', url, init, verbose: !$.quiet && $.verbose })
  const p = nodeFetch(url, init)

  return Object.assign(p, {
    pipe(dest: any, ...args: any[]) {
      const rs = new Readable()
      const _dest = isStringLiteral(dest, ...args)
        ? $({
            halt: true,
            signal: init?.signal as AbortSignal,
          })(dest as TemplateStringsArray, ...args)
        : dest
      p.then(
        (r) => responseToReadable(r, rs).pipe(_dest.run?.()),
        (err) => _dest.abort?.(err)
      )
      return _dest
    },
  })
}

export function echo(...args: any[]): void
export function echo(pieces: TemplateStringsArray, ...args: any[]) {
  const msg = isStringLiteral(pieces, ...args)
    ? args.map((a, i) => pieces[i] + stringify(a)).join('') + getLast(pieces)
    : [pieces, ...args].map(stringify).join(' ')

  console.log(msg)
}

function stringify(arg: any) {
  return arg instanceof ProcessOutput ? arg.toString().trimEnd() : `${arg}`
}

export async function question(
  query?: string,
  {
    choices,
    input = process.stdin,
    output = process.stdout,
  }: {
    choices?: string[]
    input?: NodeJS.ReadStream
    output?: NodeJS.WriteStream
  } = {}
): Promise<string> {
  /* c8 ignore next 5 */
  const completer = Array.isArray(choices)
    ? (line: string) => {
        const hits = choices.filter((c) => c.startsWith(line))
        return [hits.length ? hits : choices, line]
      }
    : undefined
  const rl = createInterface({
    input,
    output,
    terminal: true,
    completer,
  })

  return new Promise((resolve) =>
    rl.question(query ?? '', (answer) => {
      rl.close()
      resolve(answer)
    })
  )
}

export async function stdin(stream: Readable = process.stdin): Promise<string> {
  let buf = ''
  for await (const chunk of stream.setEncoding('utf8')) {
    buf += chunk
  }
  return buf
}

export async function retry<T>(count: number, callback: () => T): Promise<T>
export async function retry<T>(
  count: number,
  duration: Duration | Generator<number>,
  callback: () => T
): Promise<T>
export async function retry<T>(
  count: number,
  d: Duration | Generator<number> | (() => T),
  cb?: () => T
): Promise<T> {
  if (typeof d === 'function') return retry(count, 0, d)
  if (!cb) throw new Fail('Callback is required for retry')

  const total = count
  const gen =
    typeof d === 'object'
      ? d
      : (function* (d) {
          while (true) yield d
        })(parseDuration(d))

  let attempt = 0
  let lastErr: unknown
  while (count-- > 0) {
    attempt++
    try {
      return await cb()
    } catch (err) {
      lastErr = err
      const delay = gen.next().value

      $.log({
        kind: 'retry',
        total,
        attempt,
        delay,
        exception: err,
        verbose: !$.quiet && $.verbose,
        error: `FAIL Attempt: ${attempt}/${total}, next: ${delay}`, // legacy
      })
      if (delay > 0) await sleep(delay)
    }
  }
  throw lastErr
}

export function* expBackoff(
  max: Duration = '60s',
  delay: Duration = '100ms'
): Generator<number, void, unknown> {
  const maxMs = parseDuration(max)
  const randMs = parseDuration(delay)
  let n = 0
  while (true) {
    yield Math.min(randMs * 2 ** n++, maxMs)
  }
}

export async function spinner<T>(callback: () => T): Promise<T>
export async function spinner<T>(title: string, callback: () => T): Promise<T>
export async function spinner<T>(
  title: string | (() => T),
  callback?: () => T
): Promise<T> {
  if (typeof title === 'function') return spinner('', title)
  if ($.quiet || process.env.CI) return callback!()

  let i = 0
  const stream = $.log.output || process.stderr
  const spin = () => stream.write(`  ${'⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'[i++ % 10]} ${title}\r`)
  return within(async () => {
    $.verbose = false
    const id = setInterval(spin, 100)

    try {
      return await callback!()
    } finally {
      clearInterval(id as ReturnType<typeof setTimeout>)
      stream.write(' '.repeat((process.stdout.columns || 1) - 1) + '\r')
    }
  })
}



================================================
FILE: src/index.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { type ProcessPromise } from './core.ts'
import { versions } from './goods.ts'

export * from './core.ts'
export * from './goods.ts'
export { minimist, dotenv, fs, YAML, glob, glob as globby } from './vendor.ts'

export const VERSION: string = versions.zx || '0.0.0'
export const version: string = VERSION

/**
 *  @deprecated Use $`cmd`.nothrow() instead.
 */
export function nothrow(promise: ProcessPromise): ProcessPromise {
  return promise.nothrow()
}

/**
 * @deprecated Use $`cmd`.quiet() instead.
 */
export function quiet(promise: ProcessPromise): ProcessPromise {
  return promise.quiet()
}



================================================
FILE: src/internals.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

type TCallable = (...args: any[]) => any

const store = new Map<string, any>()
const override = store.set.bind(store)
const wrap = <T extends object>(name: string, api: T): T => {
  override(name, api)
  return new Proxy<T>(api, {
    get(_, key) {
      return store.get(name)[key] || store.get(name)?.default?.[key]
    },
    apply(_, self, args) {
      return (store.get(name) as TCallable).apply(self, args)
    },
  })
}

export const bus = {
  override,
  store,
  wrap,
}



================================================
FILE: src/log.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { chalk, type RequestInfo, type RequestInit } from './vendor-core.ts'
import { inspect } from 'node:util'
import { type Buffer } from 'node:buffer'
import process from 'node:process'

export type LogEntry = {
  verbose?: boolean
} & (
  | {
      kind: 'cmd'
      cmd: string
      cwd: string
      id: string
    }
  | {
      kind: 'stdout'
      data: Buffer
      id: string
    }
  | {
      kind: 'stderr'
      data: Buffer
      id: string
    }
  | {
      kind: 'end'
      exitCode: number | null
      signal: NodeJS.Signals | null
      duration: number
      error: null | Error
      id: string
    }
  | {
      kind: 'cd'
      dir: string
    }
  | {
      kind: 'fetch'
      url: RequestInfo
      init?: RequestInit
    }
  | {
      kind: 'retry'
      attempt: number
      total: number
      delay: number
      exception: unknown
      error?: string
    }
  | {
      kind: 'custom'
      data: any
    }
  | {
      kind: 'kill'
      pid: number
      signal: NodeJS.Signals | null
    }
)

type LogFormatters = {
  [key in LogEntry['kind']]: (
    entry: Extract<LogEntry, { kind: key }>
  ) => string | Buffer
}

const formatters: LogFormatters = {
  cmd({ cmd }) {
    return formatCmd(cmd)
  },
  stdout({ data }) {
    return data
  },
  stderr({ data }) {
    return data
  },
  custom({ data }) {
    return data
  },
  fetch(entry) {
    const init = entry.init ? ' ' + inspect(entry.init) : ''
    return `$ ${chalk.greenBright('fetch')} ${entry.url}${init}\n`
  },
  cd(entry) {
    return `$ ${chalk.greenBright('cd')} ${entry.dir}\n`
  },
  retry(entry) {
    const attempt = `Attempt: ${entry.attempt}${entry.total == Infinity ? '' : `/${entry.total}`}`
    const delay = entry.delay > 0 ? `; next in ${entry.delay}ms` : ''

    return `${chalk.bgRed.white(' FAIL ')} ${attempt}${delay}\n`
  },
  end() {
    return ''
  },
  kill() {
    return ''
  },
}

type Log = {
  (entry: LogEntry): void
  formatters?: Partial<LogFormatters>
  output?: NodeJS.WriteStream
}

export const log: Log = function (entry) {
  if (!entry.verbose) return
  const stream = log.output || process.stderr
  const format = (log.formatters?.[entry.kind] || formatters[entry.kind]) as (
    entry: LogEntry
  ) => string | Buffer
  if (!format) return // ignore unknown log entries

  stream.write(format(entry))
}

const SPACE_RE = /\s/
const SYNTAX = '()[]{}<>;:+|&='
const CMD_BREAK = '|&;><'
const RESERVED_WORDS = new Set([
  'if',
  'then',
  'else',
  'elif',
  'fi',
  'case',
  'esac',
  'for',
  'select',
  'while',
  'until',
  'do',
  'done',
  'in',
  'EOF',
])

export function formatCmd(cmd: string): string {
  if (cmd == undefined) return chalk.grey('undefined')
  let q = ''
  let out = '$ '
  let buf = ''
  let mode: 'syntax' | 'quote' | 'dollar' | '' = ''
  let pos = 0
  const cap = () => {
    const word = buf.trim()
    if (word) {
      pos++
      if (mode === 'syntax') {
        if (CMD_BREAK.includes(word)) {
          pos = 0
        }
        out += chalk.red(buf)
      } else if (mode === 'quote' || mode === 'dollar') {
        out += chalk.yellowBright(buf)
      } else if (RESERVED_WORDS.has(word)) {
        out += chalk.cyanBright(buf)
      } else if (pos === 1) {
        out += chalk.greenBright(buf)
        pos = Infinity
      } else {
        out += buf
      }
    } else {
      out += buf
    }
    mode = ''
    buf = ''
  }

  for (const c of [...cmd]) {
    if (!q) {
      if (c === '$') {
        cap()
        mode = 'dollar'
        buf += c
        cap()
      } else if (c === "'" || c === '"') {
        cap()
        mode = 'quote'
        q = c
        buf += c
      } else if (SPACE_RE.test(c)) {
        cap()
        buf += c
      } else if (SYNTAX.includes(c)) {
        const isEnv = c === '=' && pos === 0
        isEnv && (pos = 1)
        cap()
        mode = 'syntax'
        buf += c
        cap()
        isEnv && (pos = -1)
      } else {
        buf += c
      }
    } else {
      buf += c
      if (c === q) {
        cap()
        q = ''
      }
    }
  }
  cap()
  return out.replaceAll('\n', chalk.reset('\n> ')) + '\n'
}



================================================
FILE: src/md.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { type Buffer } from 'node:buffer'
import { bufToString } from './util.ts'

export function transformMarkdown(buf: Buffer | string): string {
  const output = []
  const tabRe = /^(  +|\t)/
  const codeBlockRe =
    /^(?<fence>(`{3,20}|~{3,20}))(?:(?<js>(js|javascript|ts|typescript))|(?<bash>(sh|shell|bash))|.*)$/
  let state = 'root'
  let codeBlockEnd = ''
  let prevLineIsEmpty = true
  for (const line of bufToString(buf).split(/\r?\n/)) {
    switch (state) {
      case 'root':
        if (tabRe.test(line) && prevLineIsEmpty) {
          output.push(line)
          state = 'tab'
          continue
        }
        const { fence, js, bash } = line.match(codeBlockRe)?.groups || {}
        if (!fence) {
          prevLineIsEmpty = line === ''
          output.push('// ' + line)
          continue
        }
        codeBlockEnd = fence
        if (js) {
          state = 'js'
          output.push('')
        } else if (bash) {
          state = 'bash'
          output.push('await $`')
        } else {
          state = 'other'
          output.push('')
        }
        break
      case 'tab':
        if (line === '') {
          output.push('')
        } else if (tabRe.test(line)) {
          output.push(line)
        } else {
          output.push('// ' + line)
          state = 'root'
        }
        break
      case 'js':
        if (line === codeBlockEnd) {
          output.push('')
          state = 'root'
        } else {
          output.push(line)
        }
        break
      case 'bash':
        if (line === codeBlockEnd) {
          output.push('`')
          state = 'root'
        } else {
          output.push(line)
        }
        break
      case 'other':
        if (line === codeBlockEnd) {
          output.push('')
          state = 'root'
        } else {
          output.push('// ' + line)
        }
        break
    }
  }
  return output.join('\n')
}



================================================
FILE: src/repl.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import process from 'node:process'
import repl from 'node:repl'
import { inspect } from 'node:util'
import { ProcessOutput, defaults, chalk, path, os } from './core.ts'

const HISTORY =
  process.env.ZX_REPL_HISTORY ?? path.join(os.homedir(), '.zx_repl_history')

export async function startRepl(history = HISTORY) {
  defaults.verbose = false
  const r = repl.start({
    prompt: chalk.greenBright.bold('❯ '),
    useGlobal: true,
    preview: false,
    writer(output: any) {
      return output instanceof ProcessOutput
        ? output.toString().trimEnd()
        : inspect(output, { colors: true })
    },
  })
  r.setupHistory(history, () => {})
}



================================================
FILE: src/util.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import path from 'node:path'
import { type Buffer } from 'node:buffer'
import process from 'node:process'
import { type TSpawnStore } from './vendor-core.ts'

export { isStringLiteral } from './vendor-core.ts'

export function noop() {}

export function identity<T>(v: T): T {
  return v
}

export function randomId() {
  return Math.random().toString(36).slice(2)
}

export function isString(obj: any) {
  return typeof obj === 'string'
}

const utf8Decoder = new TextDecoder('utf-8')
export const bufToString = (buf: Buffer | string): string =>
  isString(buf) ? buf : utf8Decoder.decode(buf)

export const bufArrJoin = (arr: TSpawnStore[keyof TSpawnStore]): string =>
  arr.reduce((acc, buf) => acc + bufToString(buf), '')

export const getLast = <T>(arr: { length: number; [i: number]: any }): T =>
  arr[arr.length - 1]

export function preferLocalBin(
  env: NodeJS.ProcessEnv,
  ...dirs: (string | undefined)[]
) {
  const pathKey =
    process.platform === 'win32'
      ? Object.keys(env)
          .reverse()
          .find((key) => key.toUpperCase() === 'PATH') || 'Path'
      : 'PATH'
  const pathValue = dirs
    .map(
      (c) =>
        c && [
          path.resolve(c as string, 'node_modules', '.bin'),
          path.resolve(c as string),
        ]
    )
    .flat()
    .concat(env[pathKey])
    .filter(Boolean)
    .join(path.delimiter)

  return {
    ...env,
    [pathKey]: pathValue,
  }
}

export function quote(arg: string): string {
  if (arg === '') return `$''`
  if (/^[\w/.\-@:=]+$/.test(arg)) return arg

  return (
    `$'` +
    arg
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/\f/g, '\\f')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t')
      .replace(/\v/g, '\\v')
      .replace(/\0/g, '\\0') +
    `'`
  )
}

export function quotePowerShell(arg: string): string {
  if (arg === '') return `''`
  if (/^[\w/.\-]+$/.test(arg)) return arg

  return `'` + arg.replace(/'/g, "''") + `'`
}

export type Duration =
  | number
  | `${number}`
  | `${number}m`
  | `${number}s`
  | `${number}ms`

export function parseDuration(d: Duration) {
  if (typeof d === 'number') {
    if (isNaN(d) || d < 0) throw new Error(`Invalid duration: "${d}".`)
    return d
  }
  const [m, v, u] = d.match(/^(\d+)(m?s?)$/) || []
  if (!m) throw new Error(`Unknown duration: "${d}".`)

  return +v * ({ s: 1000, ms: 1, m: 60_000 }[u] || 1)
}

export const once = <T extends (...args: any[]) => any>(fn: T) => {
  let called = false
  let result: ReturnType<T>

  return (...args: Parameters<T>): ReturnType<T> =>
    called ? result : ((called = true), (result = fn(...args)))
}

export const proxyOverride = <T extends object>(
  origin: T,
  ...fallbacks: any
): T =>
  new Proxy(origin, {
    get(target: any, key) {
      return (
        fallbacks.find((f: any) => key in f)?.[key] ?? Reflect.get(target, key)
      )
    },
  }) as T

export const toCamelCase = (str: string) =>
  str
    .toLowerCase()
    .replace(/([a-z])[_-]+([a-z])/g, (_, p1, p2) => p1 + p2.toUpperCase())

export const parseBool = (v: string): boolean | string =>
  v === 'true' || (v !== 'false' && v)

export const getLines = (
  chunk: Buffer | string,
  next: (string | undefined)[],
  delimiter: string | RegExp
) => {
  const lines = ((next.pop() || '') + bufToString(chunk)).split(delimiter)
  next.push(lines.pop())
  return lines
}

export const iteratorToArray = <T>(it: Iterator<T>): T[] => {
  const arr = []
  let entry
  while (!(entry = it.next()).done) arr.push(entry.value)
  return arr
}



================================================
FILE: src/vendor-core.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { default as _chalk } from 'chalk'
import { default as _which } from 'which'
import { default as _ps } from '@webpod/ps'
import { bus } from './internals.ts'

export {
  type TSpawnStore,
  exec,
  buildCmd,
  isStringLiteral,
  VoidStream,
} from 'zurk/spawn'

export type RequestInfo = Parameters<typeof globalThis.fetch>[0]
export type RequestInit = Parameters<typeof globalThis.fetch>[1] & {
  signal?: AbortSignal
}

export { type ChalkInstance } from 'chalk'
export const chalk: typeof _chalk = bus.wrap('chalk', _chalk)
export const which: typeof _which = bus.wrap('which', _which)
export const ps: typeof _ps = bus.wrap('ps', _ps)



================================================
FILE: src/vendor-extra.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { URL } from 'node:url'
import {
  convertPathToPattern,
  globby,
  globbySync,
  globbyStream,
  generateGlobTasksSync,
  generateGlobTasks,
  isGitIgnoredSync,
  isGitIgnored,
  isDynamicPattern,
  type Options as GlobbyOptions,
} from 'globby'
import * as _yaml from 'yaml'
import * as _fs from 'fs-extra'
import _createRequire from 'create-require'
import { fetch as _nodeFetch, AbortController } from 'node-fetch-native'
import { depseekSync as _depseek } from 'depseek'
import { default as _minimist } from 'minimist'
import { default as _dotenv } from 'envapi'

import { bus } from './internals.ts'

const { wrap } = bus

// Calculate a global variable for use (Deno/NodeJS) runtime.
// deno-lint-ignore no-node-globals
const globalVar = 'Deno' in globalThis ? globalThis : global

globalVar.AbortController = globalVar.AbortController || AbortController

export const createRequire = _createRequire as unknown as (
  filename: string | URL
) => NodeJS.Require

const globbyModule = {
  convertPathToPattern,
  globby,
  sync: globbySync,
  globbySync,
  globbyStream,
  generateGlobTasksSync,
  generateGlobTasks,
  isGitIgnoredSync,
  isGitIgnored,
  isDynamicPattern,
}

const _glob = Object.assign(function globby(
  patterns: string | readonly string[],
  options?: GlobbyOptions
) {
  return globbyModule.globby(patterns, options)
}, globbyModule) as (typeof globbyModule)['globby'] & typeof globbyModule

const _YAML: YAML = _yaml

export interface YAML {
  parse(text: string): any
  stringify(object: any): string
  /** @deprecated */
  parseAllDocuments(s: string, opts?: any): any[]
  /** @deprecated */
  parseDocument(s: string, opts?: any): any
  /** @deprecated */
  isAlias(v: any): boolean
  /** @deprecated */
  isCollection(v: any): boolean
  /** @deprecated */
  isDocument(v: any): boolean
  /** @deprecated */
  isMap(v: any): boolean
  /** @deprecated */
  isNode(v: any): boolean
  /** @deprecated */
  isPair(v: any): boolean
  /** @deprecated */
  isScalar(v: any): boolean
  /** @deprecated */
  isSeq(v: any): boolean
  /** @deprecated */
  Alias: any
  /** @deprecated */
  Composer: any
  /** @deprecated */
  Document: any
  /** @deprecated */
  Schema: any
  /** @deprecated */
  YAMLSeq: any
  /** @deprecated */
  YAMLMap: any
  /** @deprecated */
  YAMLError: any
  /** @deprecated */
  YAMLParseError: any
  /** @deprecated */
  YAMLWarning: any
  /** @deprecated */
  Pair: any
  /** @deprecated */
  Scalar: any
  /** @deprecated */
  Lexer: any
  /** @deprecated */
  LineCounter: any
  /** @deprecated */
  Parser: any
}

export const depseek: typeof _depseek = wrap('depseek', _depseek)
export const dotenv: typeof _dotenv = wrap('dotenv', _dotenv)
export const fs: typeof import('fs-extra') = wrap('fs', _fs)
export const YAML: typeof _YAML = wrap('YAML', _YAML)
export const glob: typeof _glob = wrap('glob', _glob)
export const nodeFetch: typeof _nodeFetch = wrap('nodeFetch', _nodeFetch)

export const minimist: typeof _minimist = wrap('minimist', _minimist)
export namespace minimist {
  export interface Opts extends _minimist.Opts {}
  export interface ParsedArgs extends _minimist.ParsedArgs {}
}



================================================
FILE: src/vendor.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

export * from './vendor-core.ts'
export * from './vendor-extra.ts'



================================================
FILE: src/versions.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

export const versions: Record<string, string> = {
  zx: '8.8.0',
  chalk: '5.5.0',
  depseek: '0.4.3',
  dotenv: '0.2.3',
  fetch: '1.6.7',
  fs: '11.3.1',
  glob: '14.1.0',
  minimist: '1.2.8',
  ps: '0.1.4',
  which: '5.0.0',
  yaml: '2.8.1',
}



================================================
FILE: test/all.test.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import './cli.test.js'
import './core.test.js'
import './deps.test.js'
import './error.test.ts'
import './export.test.js'
import './global.test.js'
import './goods.test.ts'
import './index.test.js'
import './log.test.ts'
import './md.test.ts'
import './package.test.js'
import './util.test.js'
import './vendor.test.js'



================================================
FILE: test/cli.test.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe, before, after } from 'node:test'
import { fileURLToPath } from 'node:url'
import net from 'node:net'
import getPort from 'get-port'
import { $, path, tmpfile, tmpdir, fs } from '../build/index.js'
import { isMain, normalizeExt } from '../build/cli.js'
import { fakeServer } from './fixtures/server.mjs'

const __filename = fileURLToPath(import.meta.url)
const spawn = $.spawn
const nodeMajor = +process.versions?.node?.split('.')[0]
const test22 = nodeMajor >= 22 ? test : test.skip

describe('cli', () => {
  // Helps to detect unresolved ProcessPromise.
  before(() => {
    const spawned = []
    $.spawn = (...args) => {
      const proc = spawn(...args)
      const done = () => (proc._done = true)
      spawned.push(proc)
      return proc.once('close', done).once('error', done)
    }
    process.on('exit', () => {
      if (spawned.some((p) => p._done !== true)) {
        console.error('Error: ProcessPromise never resolved.')
        process.exitCode = 1
      }
    })
  })
  after(() => ($.spawn = spawn))

  test('promise resolved', async () => {
    await $`echo`
  })

  test('prints version', async () => {
    assert.match((await $`node build/cli.js -v`).toString(), /\d+.\d+.\d+/)
  })

  test('prints help', async () => {
    const p = $`node build/cli.js -h`
    p.stdin.end()
    const help = await p
    assert.match(help.stdout, /zx/)
  })

  test('zx prints usage if no param passed', async () => {
    const p = $`node build/cli.js`
    p.stdin.end()
    try {
      await p
      assert.fail('must throw')
    } catch (out) {
      assert.match(out.stdout, /A tool for writing better scripts/)
      assert.equal(out.exitCode, 1)
    }
  })

  test('starts repl with --repl', async () => {
    const p = $`node build/cli.js --repl`
    p.stdin.write('await $`echo f"o"o`\n')
    p.stdin.write('"b"+"ar"\n')
    p.stdin.end()
    const out = await p
    assert.match(out.stdout, /foo/)
    assert.match(out.stdout, /bar/)
  })

  test('starts repl with verbosity off', async () => {
    const p = $`node build/cli.js --repl`
    p.stdin.write('"verbose" + " is " + $.verbose\n')
    p.stdin.end()
    const out = await p
    assert.match(out.stdout, /verbose is false/)
  })

  test('supports `--quiet` flag', async () => {
    const p = await $`node build/cli.js --quiet test/fixtures/markdown.md`
    assert.ok(!p.stderr.includes('ignore'), 'ignore was printed')
    assert.ok(!p.stderr.includes('hello'), 'no hello')
    assert.ok(p.stdout.includes('world'), 'no world')
  })

  test('supports `--shell` flag ', async () => {
    const shell = $.shell
    const p =
      await $`node build/cli.js --verbose --shell=${shell} <<< '$\`echo \${$.shell}\`'`
    assert.ok(p.stderr.includes(shell))
  })

  test('supports `--prefix` flag ', async () => {
    const prefix = 'set -e;'
    const p =
      await $`node build/cli.js --verbose --prefix=${prefix} <<< '$\`echo \${$.prefix}\`'`
    assert.ok(p.stderr.includes(prefix))
  })

  test('supports `--postfix` flag ', async () => {
    const postfix = '; exit 0'
    const p =
      await $`node build/cli.js --verbose --postfix=${postfix} <<< '$\`echo \${$.postfix}\`'`
    assert.ok(p.stderr.includes(postfix))
  })

  test('supports `--cwd` option ', async () => {
    const cwd = path.resolve(fileURLToPath(import.meta.url), '../../temp')
    fs.mkdirSync(cwd, { recursive: true })
    const p =
      await $`node build/cli.js --verbose --cwd=${cwd} <<< '$\`echo \${$.cwd}\`'`
    assert.ok(p.stderr.endsWith(cwd + '\n'))
  })

  test('supports `--env` option', async () => {
    const env = tmpfile(
      '.env',
      `FOO=BAR
      BAR=FOO+`
    )
    const file = `
    console.log((await $\`echo $FOO\`).stdout);
    console.log((await $\`echo $BAR\`).stdout)
    `

    const out = await $`node build/cli.js --env=${env} <<< ${file}`
    fs.remove(env)
    assert.equal(out.stdout, 'BAR\n\nFOO+\n\n')
  })

  test('supports `--env` and `--cwd` options with file', async () => {
    const env = tmpfile(
      '.env',
      `FOO=BAR
      BAR=FOO+`
    )
    const dir = tmpdir()
    const file = `
      console.log((await $\`echo $FOO\`).stdout);
      console.log((await $\`echo $BAR\`).stdout)
      `

    const out =
      await $`node build/cli.js --cwd=${dir} --env=${env}  <<< ${file}`
    fs.remove(env)
    fs.remove(dir)
    assert.equal(out.stdout, 'BAR\n\nFOO+\n\n')
  })

  test('supports handling errors with the `--env` option', async () => {
    const file = `
      console.log((await $\`echo $FOO\`).stdout);
      console.log((await $\`echo $BAR\`).stdout)
      `
    try {
      await $`node build/cli.js --env=./env <<< ${file}`
      fs.remove(env)
      assert.throw()
    } catch (e) {
      assert.equal(e.exitCode, 1)
    }
  })

  test('supports --prefer-local to load modules', async () => {
    const cwd = tmpdir()
    const external = tmpdir()
    await fs.outputJson(path.join(external, 'node_modules/a/package.json'), {
      name: 'a',
      version: '1.0.0',
      type: 'module',
      exports: './index.js',
    })
    await fs.outputFile(
      path.join(external, 'node_modules/a/index.js'),
      `
export const a = 'AAA'
`
    )
    const script = `
import {a} from 'a'
console.log(a);
`
    const out =
      await $`node build/cli.js --cwd=${cwd} --prefer-local=${external} --test <<< ${script}`
    assert.equal(out.stdout, 'AAA\n')
  })

  test('scripts from https 200', async () => {
    const resp = await fs.readFile(path.resolve('test/fixtures/echo.http'))
    const port = await getPort()
    const server = await fakeServer([resp]).start(port)
    const out =
      await $`node build/cli.js --verbose http://127.0.0.1:${port}/script.mjs`
    assert.match(out.stderr, /test/)
    await server.stop()
  })

  test('scripts from https 500', async () => {
    const port = await getPort()
    const server = await fakeServer(['HTTP/1.1 500\n\n']).listen(port)
    const out = await $`node build/cli.js http://127.0.0.1:${port}`.nothrow()
    assert.match(out.stderr, /Error: Can't get/)
    await server.stop()
  })

  test('scripts (md) from https', async () => {
    const resp = await fs.readFile(path.resolve('test/fixtures/md.http'))
    const port = await getPort()
    const server = await fakeServer([resp]).start(port)
    const out =
      await $`node build/cli.js --verbose http://127.0.0.1:${port}/script.md`
    assert.match(out.stderr, /md/)
    await server.stop()
  })

  test('scripts with no extension', async () => {
    await $`node build/cli.js test/fixtures/no-extension`
    assert.ok(
      /Test file to verify no-extension didn't overwrite similarly name .mjs file./.test(
        (await fs.readFile('test/fixtures/no-extension.mjs')).toString()
      )
    )
  })

  test('scripts with non standard extension', async () => {
    const o =
      await $`node build/cli.js --ext='.mjs' test/fixtures/non-std-ext.zx`
    assert.ok(o.stdout.trim().endsWith('zx/test/fixtures/non-std-ext.zx.mjs'))

    await assert.rejects(
      $`node build/cli.js test/fixtures/non-std-ext.zx`,
      /Unknown file extension "\.zx"/
    )
  })

  test22('scripts from stdin with explicit extension', async () => {
    const out =
      await $`node --experimental-strip-types build/cli.js --ext='.ts' <<< 'const foo: string = "bar"; console.log(foo)'`
    assert.match(out.stdout, /bar/)
  })

  test('require() is working from stdin', async () => {
    const out =
      await $`node build/cli.js <<< 'console.log(require("./package.json").name)'`
    assert.match(out.stdout, /zx/)
  })

  test('require() is working in ESM', async () => {
    await $`node build/cli.js test/fixtures/require.mjs`
  })

  test('__filename & __dirname are defined', async () => {
    await $`node build/cli.js test/fixtures/filename-dirname.mjs`
  })

  test('markdown scripts are working', async () => {
    await $`node build/cli.js test/fixtures/markdown.md`
  })

  test('markdown scripts are working for CRLF', async () => {
    const p = await $`node build/cli.js test/fixtures/markdown-crlf.md`
    assert.ok(p.stdout.includes('Hello, world!'))
  })

  test('exceptions are caught', async () => {
    const out1 = await $`node build/cli.js <<<${'await $`wtf`'}`.nothrow()
    const out2 = await $`node build/cli.js <<<'throw 42'`.nothrow()
    assert.match(out1.stderr, /Error:/)
    assert.match(out2.stderr, /42/)
  })

  test('eval works', async () => {
    assert.equal((await $`node build/cli.js --eval 'echo(42)'`).stdout, '42\n')
    assert.equal((await $`node build/cli.js -e='echo(69)'`).stdout, '69\n')
  })

  test('eval works with stdin', async () => {
    const p = $`(printf foo; sleep 0.1; printf bar) | node build/cli.js --eval 'echo(await stdin())'`
    assert.equal((await p).stdout, 'foobar\n')
  })

  test('executes a script from $PATH', async () => {
    const isWindows = process.platform === 'win32'
    const oldPath = process.env.PATH
    const toPOSIXPath = (_path) => _path.split(path.sep).join(path.posix.sep)

    const zxPath = path.resolve('./build/cli.js')
    const zxLocation = isWindows ? toPOSIXPath(zxPath) : zxPath
    const scriptCode = `#!/usr/bin/env ${zxLocation}\nconsole.log('The script from path runs.')`
    const scriptName = 'script-from-path'
    const scriptFile = tmpfile(scriptName, scriptCode, 0o744)
    const scriptDir = path.dirname(scriptFile)

    const envPathSeparator = isWindows ? ';' : ':'
    process.env.PATH += envPathSeparator + scriptDir

    try {
      await $`chmod +x ${zxLocation}`
      await $`${scriptName}`
    } finally {
      process.env.PATH = oldPath
      await fs.rm(scriptFile)
    }
  })

  test('argv works with zx and node', async () => {
    assert.equal(
      (await $`node build/cli.js test/fixtures/argv.mjs foo`).toString(),
      `global {"_":["foo"]}\nimported {"_":["foo"]}\n`
    )
    assert.equal(
      (await $`node test/fixtures/argv.mjs bar`).toString(),
      `global {"_":["bar"]}\nimported {"_":["bar"]}\n`
    )
    assert.equal(
      (
        await $`node build/cli.js --eval 'console.log(argv._.join(''))' baz`
      ).toString(),
      `baz\n`
    )
  })

  test('exit code can be set', async () => {
    const p = await $`node build/cli.js test/fixtures/exit-code.mjs`.nothrow()
    assert.equal(p.exitCode, 42)
  })

  describe('internals', () => {
    test('isMain() checks process entry point', () => {
      assert.equal(isMain(import.meta.url, __filename), true)

      assert.equal(
        isMain(import.meta.url.replace('.js', '.cjs'), __filename),
        true
      )

      try {
        assert.equal(
          isMain(
            'file:///root/zx/test/cli.test.js',
            '/root/zx/test/all.test.js'
          ),
          true
        )
        assert.throw()
      } catch (e) {
        assert.ok(['EACCES', 'ENOENT'].includes(e.code))
      }
    })

    test('isMain() function is running from the wrong path', () => {
      assert.equal(isMain('///root/zx/test/cli.test.js'), false)
    })

    test('normalizeExt()', () => {
      assert.equal(normalizeExt('.ts'), '.ts')
      assert.equal(normalizeExt('ts'), '.ts')
      assert.equal(normalizeExt('.'), '.')
      assert.equal(normalizeExt(), undefined)
    })
  })
})



================================================
FILE: test/core.test.js
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe, before, after, it } from 'node:test'
import { inspect } from 'node:util'
import { basename } from 'node:path'
import { WriteStream } from 'node:fs'
import { Readable, Transform, Writable } from 'node:stream'
import { Socket } from 'node:net'
import { ChildProcess } from 'node:child_process'
import {
  $,
  ProcessPromise,
  ProcessOutput,
  defaults,
  resolveDefaults,
  cd,
  syncProcessCwd,
  within,
  usePowerShell,
  usePwsh,
  useBash,
  Fail,
} from '../build/core.js'
import {
  tempfile,
  tempdir,
  fs,
  quote,
  quotePowerShell,
  sleep,
  quiet,
  which,
  nothrow,
  fetch,
} from '../build/index.js'
import { noop } from '../build/util.cjs'
import { EventEmitter } from 'node:events'

describe('core', () => {
  describe('resolveDefaults()', () => {
    test('overrides known (allowed) opts', async () => {
      const defaults = resolveDefaults({ verbose: false }, 'ZX_', {
        ZX_VERBOSE: 'true',
        ZX_PREFER_LOCAL: '/foo/bar/',
      })
      assert.equal(defaults.verbose, true)
      assert.equal(defaults.preferLocal, '/foo/bar/')
    })

    test('ignores unknown', async () => {
      const defaults = resolveDefaults({}, 'ZX_', {
        ZX_INPUT: 'input',
        ZX_FOO: 'test',
      })
      assert.equal(defaults.input, undefined)
      assert.equal(defaults.foo, undefined)
    })
  })

  describe('$', () => {
    test('is a regular function', async () => {
      const _$ = $.bind(null)
      const foo = await _$`echo foo`
      assert.equal(foo.stdout, 'foo\n')
      assert.ok(typeof $.call === 'function')
      assert.ok(typeof $.apply === 'function')
    })

    test('only stdout is used during command substitution', async () => {
      const hello = await $`echo Error >&2; echo Hello`
      const len = +(await $`echo ${hello} | wc -c`)
      assert.equal(len, 6)
    })

    test('env vars works', async () => {
      process.env.ZX_TEST_FOO = 'foo'
      const foo = await $`echo $ZX_TEST_FOO`
      assert.equal(foo.stdout, 'foo\n')
      delete process.env.ZX_TEST_FOO
    })

    test('env vars are safe to pass', async () => {
      process.env.ZX_TEST_BAR = 'hi; exit 1'
      const bar = await $`echo $ZX_TEST_BAR`
      assert.equal(bar.stdout, 'hi; exit 1\n')
      delete process.env.ZX_TEST_BAR
    })

    test('arguments are quoted', async () => {
      const bar = 'bar"";baz!$#^$\'&*~*%)({}||\\/'
      assert.equal((await $`echo ${bar}`).stdout.trim(), bar)
    })

    test('broken quoting', async () => {
      const args = ['param && echo bar']
      const p = $`echo --foo=$'${args}'`
      assert.equal((await p).stdout, '--foo=$param\nbar\n')
    })

    test('undefined and empty string correctly quoted', async () => {
      assert.equal((await $`echo -n ${undefined}`).toString(), 'undefined')
      assert.equal((await $`echo -n ${''}`).toString(), '')
    })

    test('accepts thenable arguments', async () => {
      const a1 = $`echo foo`
      const a2 = new Promise((res) => setTimeout(res, 10, ['bar', 'baz']))
      const a3 = new Promise((_, rej) => setTimeout(rej, 20, 'failure'))

      const p1 = $`echo ${a1} ${a2}`
      assert(p1.cmd instanceof Promise)
      const o1 = await p1
      assert(o1 instanceof ProcessOutput)
      assert.equal(o1.stdout.trim(), 'foo bar baz')
      assert.equal(p1.cmd, 'echo foo bar baz')

      try {
        await $`echo ${a3}`
      } catch (e) {
        assert.ok(e instanceof ProcessOutput)
        assert.equal(e.exitCode, null)
        assert.equal(e.cause, 'failure')
      }

      try {
        await $`echo ${$`exit 1`}`
      } catch (e) {
        assert.ok(e instanceof ProcessOutput)
        assert.ok(e.cause instanceof ProcessOutput)
        assert.equal(e.exitCode, null)
        assert.equal(e.cause.exitCode, 1)
      }

      await Promise.allSettled([a3])
    })

    test.skip('handles multiline literals', async () => {
      assert.equal(
        (
          await $`echo foo
     bar
     "baz
      qux"
`
        ).toString(),
        'foo bar baz\n      qux\n'
      )
      assert.equal(
        (
          await $`echo foo \
                     bar \
                     baz \
`
        ).toString(),
        'foo bar baz\n'
      )
    })

    test('can create a dir with a space in the name', async () => {
      const name = 'foo bar'
      try {
        await $`mkdir /tmp/${name}`
      } catch {
        assert.unreachable()
      } finally {
        await fs.rmdir('/tmp/' + name)
      }
    })

    test('pipefail is on', async () => {
      let p
      try {
        p = await $`cat /dev/not_found | sort`
      } catch (e) {
        p = e
      }
      assert.notEqual(p.exitCode, 0)
    })

    test('toString() is called on arguments', async () => {
      const foo = 0
      const p = await $`echo ${foo}`
      assert.equal(p.stdout, '0\n')
    })

    test('can use array as an argument', async () => {
      const _$ = $({ prefix: '', postfix: '' })
      const p1 = _$`echo ${['-n', 'foo']}`
      assert.equal(p1.cmd, 'echo -n foo')
      assert.equal((await p1).toString(), 'foo')

      const p2 = _$`echo ${[1, '', '*', '2']}`
      assert.equal(p2.cmd, `echo 1 $'' $'*' 2`)
      assert.equal((await p2).toString(), `1  * 2\n`)
    })

    test('requires $.shell to be specified', async () => {
      await within(() => {
        $.shell = undefined
        assert.throws(() => $`echo foo`, /shell/)
      })
    })

    test('malformed cmd error', async () => {
      assert.throws(() => $`\033`, /malformed/i)

      try {
        $([null])
        throw new Error('unreachable')
      } catch (e) {
        assert.ok(e instanceof Fail)
        assert.match(e.message, /malformed/i)
      }

      const o = await $({ nothrow: true })`\033`
      assert.equal(o.ok, false)
      assert.match(o.cause.message, /malformed/i)
    })

    test('snapshots works', async () => {
      await within(async () => {
        $.prefix += 'echo success;'
        const p = $`:`
        $.prefix += 'echo fail;'
        const out = await p
        assert.equal(out.stdout, 'success\n')
        assert.doesNotMatch(out.stdout, /fail/)
      })
    })

    test('$ thrown as error', async () => {
      let err
      try {
        await $`wtf`
      } catch (p) {
        err = p
      }
      assert.ok(err.exitCode > 0)
      assert.match(err.toString(), /command not found/)
      assert.match(err.valueOf(), /command not found/)
      assert.match(err.stderr, /wtf: command not found/)
      assert.match(err[inspect.custom](), /Command not found/)
    })

    test('error event is handled', async () => {
      await within(async () => {
        $.cwd = 'wtf'
        try {
          await $`pwd`
          assert.unreachable('should have thrown')
        } catch (err) {
          assert.ok(err instanceof ProcessOutput)
          assert.match(err.message, /No such file or directory/)
        }
      })
    })

    test('await $`cmd`.exitCode does not throw', async () => {
      assert.notEqual(await $`grep qwerty README.md`.exitCode, 0)
      assert.equal(await $`[[ -f README.md ]]`.exitCode, 0)
    })

    test('`$.sync()` provides synchronous API', () => {
      const o1 = $.sync`echo foo`
      const o2 = $({ sync: true })`echo foo`
      const o3 = $.sync({})`echo foo`
      assert.equal(o1.stdout, 'foo\n')
      assert.equal(o2.stdout, 'foo\n')
      assert.equal(o3.stdout, 'foo\n')
    })

    describe('$({opts}) API', () => {
      it('$ proxy uses `defaults` store', () => {
        assert.equal($.foo, undefined)
        defaults.foo = 'bar'
        $.baz = 'qux'
        assert.equal($.foo, 'bar')
        assert.equal($.baz, 'qux')
        assert.equal(defaults.baz, 'qux')
        delete defaults.foo
        $.baz = undefined
        assert.equal($.foo, undefined)
        assert.equal($.baz, undefined)
        assert.equal(defaults.baz, undefined)
      })

      test('provides presets', async () => {
        const $1 = $({ nothrow: true })
        assert.equal((await $1`exit 1`).exitCode, 1)

        const $2 = $1({ sync: true })
        assert.equal($2`exit 2`.exitCode, 2)

        const $3 = $({ sync: true })({ nothrow: true })
        assert.equal($3`exit 3`.exitCode, 3)
      })

      test('handles `nothrow` option', async () => {
        const o1 = await $({ nothrow: true })`exit 1`
        assert.equal(o1.ok, false)
        assert.equal(o1.exitCode, 1)
        assert.match(o1.message, /exit code: 1/)

        const err = new Error('BrokenSpawn')
        const o2 = await $({
          nothrow: true,
          spawn() {
            throw err
          },
        })`echo foo`
        assert.equal(o2.ok, false)
        assert.equal(o2.exitCode, null)
        assert.match(o2.message, /BrokenSpawn/)
        assert.equal(o2.cause, err)
      })

      test('handles `input` option', async () => {
        const p1 = $({ input: 'foo' })`cat`
        const p2 = $({ input: Readable.from('bar') })`cat`
        const p3 = $({ input: Buffer.from('baz') })`cat`
        const p4 = $({ input: p3 })`cat`
        const p5 = $({ input: await p3 })`cat`

        assert.equal((await p1).stdout, 'foo')
        assert.equal((await p2).stdout, 'bar')
        assert.equal((await p3).stdout, 'baz')
        assert.equal((await p4).stdout, 'baz')
        assert.equal((await p5).stdout, 'baz')
      })

      test('handles `timeout` and `timeoutSignal`', async () => {
        let exitCode, signal
        try {
          await $({
            timeout: 10,
            timeoutSignal: 'SIGKILL',
          })`sleep 999`
        } catch (p) {
          exitCode = p.exitCode
          signal = p.signal
        }
        assert.equal(exitCode, null)
        assert.equal(signal, 'SIGKILL')
      })

      test('`env` option', async () => {
        const baz = await $({
          env: { ZX_TEST_BAZ: 'baz' },
        })`echo $ZX_TEST_BAZ`
        assert.equal(baz.stdout, 'baz\n')
      })

      test('`preferLocal` preserves env', async () => {
        const cases = [
          [true, `${process.cwd()}/node_modules/.bin:${process.cwd()}:`],
          ['/foo', `/foo/node_modules/.bin:/foo:`],
          [
            ['/bar', '/baz'],
            `/bar/node_modules/.bin:/bar:/baz/node_modules/.bin:/baz`,
          ],
        ]

        for (const [preferLocal, expected] of cases) {
          const PATH = await $({
            preferLocal,
            env: { PATH: process.env.PATH },
          })`echo $PATH`
          assert(PATH.stdout.startsWith(expected))
        }
      })

      test('supports custom intermediate store', async () => {
        const getFixedSizeArray = (size) => {
          const arr = []
          return new Proxy(arr, {
            get: (target, prop) =>
              prop === 'push' && arr.length >= size
                ? () => {
                    /* noop */
                  }
                : target[prop],
          })
        }
        const store = {
          stdout: getFixedSizeArray(1),
          stderr: getFixedSizeArray(1),
          stdall: getFixedSizeArray(0),
        }

        const p = await $({ store })`echo foo`

        assert.equal(p.stdout.trim(), 'foo')
        assert.equal(p.toString(), '')
      })
    })

    describe('accepts `stdio`', () => {
      test('ignore', async () => {
        const p = $({ stdio: 'ignore' })`echo foo`
        assert.equal((await p).stdout, '')
      })

      test('inherit', async () => {
        const r1 = (await $({ stdio: 'inherit' })`ls`).stdout
        const r2 = $.sync({ stdio: 'inherit' })`ls`.stdout
        assert.equal(r1, r2)
      })

      test('mixed', async () => {
        assert.equal(
          (
            await $({
              quiet: true,
              stdio: ['inherit', 'pipe', 'ignore'],
            })`>&2 echo error; echo ok`
          ).toString(),
          'ok\n'
        )
      })

      test('via stdio() method', async () => {
        assert.equal(
          (
            await $({ halt: true })`>&2 echo error; echo ok`
              .stdio('inherit', 'ignore', 'pipe')
              .quiet()
              .run()
          ).toString(),
          'error\n'
        )

        assert.equal(
          (
            await $({ halt: true })`>&2 echo error; echo ok`
              .stdio(['inherit', 'pipe', 'ignore'])
              .quiet()
              .run()
          ).toString(),
          'ok\n'
        )
      })

      test('file stream as stdout', async () => {
        const createWriteStream = (f) => {
          const stream = fs.createWriteStream(f)
          return new Promise((resolve) => {
            stream.on('open', () => resolve(stream))
          })
        }
        const file = tempfile()
        const stream = await createWriteStream(file)
        const p = $({ stdio: ['pipe', stream, 'ignore'] })`echo foo`

        await p
        assert.equal((await fs.readFile(file)).toString(), 'foo\n')
      })
    })

    it('uses custom `log` if specified', async () => {
      const entries = []
      const log = (entry) => entries.push(entry)
      const p = $({ log })`echo foo`
      const { id } = p
      const { duration } = await p
      const cwd = process.cwd()

      assert.equal(entries.length, 3)
      assert.deepEqual(entries[0], {
        kind: 'cmd',
        cmd: 'echo foo',
        cwd,
        verbose: false,
        id,
      })
      assert.deepEqual(entries[1], {
        kind: 'stdout',
        data: Buffer.from('foo\n'),
        verbose: false,
        id,
      })
      assert.deepEqual(entries[2], {
        kind: 'end',
        duration,
        exitCode: 0,
        signal: null,
        error: null,
        verbose: false,
        id,
      })
    })
  })

  describe('ProcessPromise', () => {
    test('getters', async () => {
      const p = $`echo foo`
      assert.ok(typeof p.pid === 'number')
      assert.ok(typeof p.id === 'string')
      assert.ok(typeof p.cmd === 'string')
      assert.ok(typeof p.fullCmd === 'string')
      assert.ok(typeof p.stage === 'string')
      assert.ok(p.child instanceof ChildProcess)
      assert.ok(p.stdout instanceof Socket)
      assert.ok(p.stderr instanceof Socket)
      assert.ok(p.exitCode instanceof Promise)
      assert.ok(p.signal instanceof AbortSignal)
      assert.equal(p.output, null)
      assert.equal(Object.prototype.toString.call(p), '[object ProcessPromise]')
      assert.equal('' + p, '[object ProcessPromise]')
      assert.equal(`${p}`, '[object ProcessPromise]')
      assert.equal(+p, NaN)

      await p
      assert.ok(p.output instanceof ProcessOutput)
    })

    describe('state machine transitions', () => {
      it('running > fulfilled', async () => {
        const p = $`echo foo`
        assert.equal(p.stage, 'running')
        await p
        assert.equal(p.stage, 'fulfilled')
      })

      it('running > rejected', async () => {
        const p = $`foo`
        assert.equal(p.stage, 'running')

        try {
          await p
        } catch {}
        assert.equal(p.stage, 'rejected')
      })

      it('halted > running > fulfilled', async () => {
        const p = $({ halt: true })`echo foo`
        assert.equal(p.stage, 'halted')
        p.run()
        assert.equal(p.stage, 'running')
        await p
        assert.equal(p.stage, 'fulfilled')
      })

      it('all transitions', async () => {
        const { promise, resolve, reject } = Promise.withResolvers()
        const p = new ProcessPromise(noop)
        ProcessPromise.disarm(p, false)
        assert.equal(p.stage, 'initial')

        p._resolve = resolve
        p._reject = reject
        p._stage = 'halted'
        p._snapshot = {
          ...defaults,
          ac: new AbortController(),
          from: 'test',
          cmd: 'echo foo',
          ee: new EventEmitter(),
        }

        assert.equal(p.stage, 'halted')
        p.run()
        assert.equal(p.stage, 'running')
        await promise
        assert.equal(p.stage, 'fulfilled')
        assert.equal(p.output.stdout, 'foo\n')
      })
    })

    test('inherits native Promise', async () => {
      const p1 = $`echo 1`
      const p2 = p1.then((v) => v)
      const p3 = p2.then((v) => v)
      const p4 = p3.catch((v) => v)
      const p5 = p1.finally((v) => v)

      assert(p1 instanceof Promise)
      assert(p1 instanceof ProcessPromise)
      assert(p2 instanceof ProcessPromise)
      assert(p3 instanceof ProcessPromise)
      assert(p4 instanceof ProcessPromise)
      assert(p5 instanceof ProcessPromise)
      assert.ok(p1 !== p2)
      assert.ok(p2 !== p3)
      assert.ok(p3 !== p4)
      assert.ok(p5 !== p1)
    })

    test('asserts self instantiation', async () => {
      const p = new ProcessPromise(() => {})

      assert(typeof p.then === 'function')
      assert.throws(() => p.stage, /Inappropriate usage/)
    })

    test('resolves with ProcessOutput', async () => {
      const o = await $`echo foo`
      assert.ok(o instanceof ProcessOutput)
    })

    test('cmd() returns cmd to exec', () => {
      const foo = '#bar'
      const baz = 1
      const p = $`echo ${foo} --t ${baz}`
      assert.equal(p.cmd, "echo $'#bar' --t 1")
      assert.equal(p.fullCmd, "set -euo pipefail;echo $'#bar' --t 1")
    })

    test('stdin works', async () => {
      const p = $`read; printf $REPLY`
      p.stdin.write('bar\n')
      assert.equal((await p).stdout, 'bar')
    })

    describe('pipe()', () => {
      test('accepts Writable', async () => {
        let contents = ''
        const stream = new Writable({
          write: function (chunk, encoding, next) {
            contents += chunk.toString()
            next()
          },
        })
        const p1 = $`echo 'test'`
        const p2 = p1.pipe(stream)
        assert.equal(p1._piped, true)
        await p2
        assert.equal(p1._piped, false)
        assert.ok(p1.stderr instanceof Socket)
        assert.equal(contents, 'test\n')
      })

      test('throws if Writable ended', async () => {
        const stream = { writableEnded: true }
        const p = $`echo foo`
        assert.throws(() => p.pipe(stream), /Cannot pipe to a closed stream/)
        await p
      })

      test('accepts WriteStream', async () => {
        const file = tempfile()
        try {
          await $`echo foo`.pipe(fs.createWriteStream(file))
          assert.equal((await fs.readFile(file)).toString(), 'foo\n')

          const r = $`cat`
          fs.createReadStream(file).pipe(r.stdin)
          assert.equal((await r).stdout, 'foo\n')
        } finally {
          await fs.rm(file)
        }
      })

      test('accepts file', async () => {
        const file = tempfile()
        try {
          await $`echo foo`.pipe(file)
          assert.equal((await fs.readFile(file)).toString(), 'foo\n')

          const r = $`cat`
          fs.createReadStream(file).pipe(r.stdin)
          assert.equal((await r).stdout, 'foo\n')
        } finally {
          await fs.rm(file)
        }
      })

      test('accepts ProcessPromise', async () => {
        const p = await $`echo foo`.pipe($`cat`)
        assert.equal(p.stdout.trim(), 'foo')
      })

      test('throws if dest ProcessPromise is settled', async () => {
        const dest = $`echo bar`
        await dest
        const p = $`echo foo`
        assert.throws(() => p.pipe(dest), /Cannot pipe to a settled process/)
        await p
      })

      test('detects inappropriate ProcessPromise', async () => {
        const foo = $`echo foo`
        const p1 = $`cat`
        const p2 = p1.then((v) => v)

        assert.throws(() => foo.pipe(p2), /Inappropriate usage/)
        await foo.pipe(p1)
      })

      test('accepts $ template literal', async () => {
        const p = await $`echo foo`.pipe`cat`
        assert.equal(p.stdout.trim(), 'foo')
      })

      test('accepts stdout', async () => {
        const p1 = $`echo pipe-to-stdout`
        const p2 = p1.pipe(process.stdout)
        assert.equal((await p1).stdout.trim(), 'pipe-to-stdout')
      })

      describe('supports chaining', () => {
        const getUpperCaseTransform = () =>
          new Transform({
            transform(chunk, encoding, callback) {
              callback(null, String(chunk).toUpperCase())
            },
          })

        test('$ > $', async () => {
          const { stdout: o1 } = await $`echo "hello"`
            .pipe($`awk '{print $1" world"}'`)
            .pipe($`tr '[a-z]' '[A-Z]'`)
          assert.equal(o1, 'HELLO WORLD\n')

          const { stdout: o2 } = await $`echo "hello"`
            .pipe`awk '{print $1" world"}'`.pipe`tr '[a-z]' '[A-Z]'`
          assert.equal(o2, 'HELLO WORLD\n')
        })

        test('$ > $ halted', async () => {
          const $h = $({ halt: true })
          const { stdout } = await $`echo "hello"`
            .pipe($h`awk '{print $1" world"}'`)
            .pipe($h`tr '[a-z]' '[A-Z]'`)

          assert.equal(stdout, 'HELLO WORLD\n')
        })

        test('$ halted > $ halted', async () => {
          const $h = $({ halt: true })
          const { stdout } = await $h`echo "hello"`
            .pipe($h`awk '{print $1" world"}'`)
            .pipe($h`tr '[a-z]' '[A-Z]'`)
            .run()

          assert.equal(stdout, 'HELLO WORLD\n')
        })

        test('$ halted > $ literal', async () => {
          const { stdout } = await $({ halt: true })`echo "hello"`
            .pipe`awk '{print $1" world"}'`.pipe`tr '[a-z]' '[A-Z]'`.run()

          assert.equal(stdout, 'HELLO WORLD\n')
        })

        test('several $ halted > $ halted', async () => {
          const $h = $({ halt: true })
          const p1 = $`echo foo`
          const p2 = $h`echo a && sleep 0.1 && echo c && sleep 0.2 && echo e`
          const p3 = $h`sleep 0.05 && echo b && sleep 0.1 && echo d`
          const p4 = $`sleep 0.4 && echo bar`
          const p5 = $h`cat`

          await p1
          p1.pipe(p5)
          p2.pipe(p5)
          p3.pipe(p5)
          p4.pipe(p5)

          const { stdout } = await p5.run()

          assert.equal(stdout, 'foo\na\nb\nc\nd\ne\nbar\n')
        })

        test('$ > stream', async () => {
          const file = tempfile()
          const fileStream = fs.createWriteStream(file)
          const p = $`echo "hello"`
            .pipe(getUpperCaseTransform())
            .pipe(fileStream)
          const o = await p

          assert.ok(p instanceof WriteStream)
          assert.ok(o instanceof WriteStream)
          assert.equal(o.stdout, 'hello\n')
          assert.equal(o.exitCode, 0)
          assert.equal((await fs.readFile(file)).toString(), 'HELLO\n')
          await fs.rm(file)
        })

        test('$ > stdout', async () => {
          const p = $`echo 1`.pipe(process.stdout)
          assert.deepEqual(p, process.stdout)
        })

        test('$ halted > stream', async () => {
          const file = tempfile()
          const fileStream = fs.createWriteStream(file)
          const p1 = $({ halt: true })`echo "hello"`
          const p2 = p1.pipe(getUpperCaseTransform()).pipe(fileStream)

          assert.ok(p2 instanceof WriteStream)
          assert.equal(p2.run(), undefined)

          await p2

          assert.equal((await fs.readFile(file)).toString(), 'HELLO\n')
          await fs.rm(file)
        })

        test('stream > $', async () => {
          const file = tempfile()
          await fs.writeFile(file, 'test')
          const { stdout } = await fs
            .createReadStream(file)
            .pipe(getUpperCaseTransform())
            .pipe($`cat`)

          assert.equal(stdout, 'TEST')
        })

        test('fetch (stream) > $', async () => {
          // stream.Readable.fromWeb requires Node.js 18+
          const responseToReadable = (response) => {
            const reader = response.body.getReader()
            const rs = new Readable()
            rs._read = async () => {
              const result = await reader.read()
              if (!result.done) rs.push(Buffer.from(result.value))
              else rs.push(null)
            }
            return rs
          }

          const p = (
            await fetch('https://example.com').then(responseToReadable)
          ).pipe($`cat`)
          const o = await p

          assert.match(o.stdout, /Example Domain/)
        })

        test('fetch (pipe) > $', async () => {
          const p1 = fetch('https://example.com').pipe($`cat`)
          const p2 = fetch('https://example.com').pipe`cat`
          const o1 = await p1
          const o2 = await p2

          assert.match(o1.stdout, /Example Domain/)
          assert.equal(o1.stdout, o2.stdout)
        })

        test('$ > stream > $', async () => {
          const p = $`echo "hello"`
          const { stdout } = await p.pipe(getUpperCaseTransform()).pipe($`cat`)

          assert.equal(stdout, 'HELLO\n')
        })
      })

      it('supports delayed piping', async () => {
        const result = $`echo 1; sleep 1; echo 2; sleep 1; echo 3`
        const piped1 = result.pipe`cat`
        let piped2

        setTimeout(() => {
          piped2 = result.pipe`cat`
        }, 1500)

        await piped1
        assert.equal((await piped1).toString(), '1\n2\n3\n')
        assert.equal((await piped2).toString(), '1\n2\n3\n')
      })

      it('fulfilled piping', async () => {
        const p1 = $`echo foo && sleep 0.1 && echo bar`
        await p1
        const p2 = p1.pipe`cat`
        await p2

        assert.equal(p1.output.toString(), 'foo\nbar\n')
        assert.equal(p2.output.toString(), 'foo\nbar\n')
      })

      it('rejected piping', async () => {
        const p1 = $({ nothrow: true })`echo foo && exit 1`
        await p1
        const p2 = p1.pipe($({ nothrow: true })`cat`)
        await p2

        assert.equal(p1.output.toString(), 'foo\n')
        assert.equal(p1.output.ok, false)
        assert.equal(p1.output.exitCode, 1)

        assert.equal(p2.output.toString(), 'foo\n')
        assert.equal(p2.output.ok, false)
        assert.equal(p2.output.exitCode, 1)
      })

      test('propagates rejection', async () => {
        const p1 = $`exit 1`
        const p2 = p1.pipe($`echo hello`)

        try {
          await p1
        } catch (e) {
          assert.equal(e.exitCode, 1)
          assert.equal(e.stdout, '')
        }

        try {
          await p2
        } catch (e) {
          assert.equal(e.exitCode, 1)
          assert.equal(e.ok, false)
        }

        const p3 = await $({ nothrow: true })`echo hello && exit 1`.pipe($`cat`)
        assert.equal(p3.exitCode, 0)
        assert.equal(p3.stdout.trim(), 'hello')

        const p4 = $`exit 1`.pipe($`echo hello`)
        try {
          await p4
        } catch (e) {
          assert.equal(e.exitCode, 1)
          assert.equal(e.ok, false)
        }

        const p5 = $`echo bar && sleep 0.1 && exit 1`
        const [r1, r2, r3] = await Promise.allSettled([
          p5.pipe($`cat`),
          p5.pipe($({ nothrow: true })`cat`),
          p5.pipe($({ nothrow: true, halt: true })`cat`),
        ])
        assert.equal(r1.reason.stdout, 'bar\n')
        assert.equal(r1.reason.exitCode, 1)
        assert.equal(r1.reason.ok, false)

        assert.equal(r2.value.stdout, 'bar\n')
        assert.equal(r2.value.exitCode, 1)
        assert.equal(r2.value.ok, false)

        assert.equal(r3.value.stdout, 'bar\n')
        assert.equal(r3.value.exitCode, 1)
        assert.equal(r3.value.ok, false)

        const p6 = $`echo bar && exit 1`
        const [r4, r5] = await Promise.allSettled([
          p6.pipe($`cat`),
          p6.pipe($({ nothrow: true })`cat`),
        ])
        assert.equal(r4.reason.stdout, 'bar\n')
        assert.equal(r4.reason.exitCode, 1)
        assert.equal(r4.reason.ok, false)

        assert.equal(r5.value.stdout, 'bar\n')
        assert.equal(r5.value.exitCode, 1)
        assert.equal(r5.value.ok, false)
      })

      test('pipes particular stream: stdout, stderr, stdall', async () => {
        const p = $`echo foo >&2; sleep 0.01 && echo bar`
        const o1 = (await p.pipe.stderr`cat`).toString()
        const o2 = (await p.pipe.stdout`cat`).toString()
        const o3 = (await p.pipe.stdall`cat`).toString()

        assert.equal(o1, 'foo\n')
        assert.equal(o2, 'bar\n')
        assert.equal(o3, 'foo\nbar\n')
      })
    })

    describe('unpipe()', () => {
      it('disables piping', async () => {
        const p1 = $`echo foo && sleep 0.1 && echo bar && sleep 0.1 && echo baz && sleep 0.1 && echo qux`
        const p2 = $`echo 1 && sleep 0.15 && echo 2 && sleep 0.1 && echo 3`
        const p3 = $`cat`

        p1.pipe(p3)
        p2.pipe(p3)

        setTimeout(() => p1.unpipe(p3), 150)

        const { stdout } = await p3
        assert.equal(stdout, 'foo\n1\nbar\n2\n3\n')
      })
    })

    describe('abort()', () => {
      test('just works', async () => {
        const p = $({ detached: true })`sleep 999`
        setTimeout(() => p.abort(), 100)

        try {
          await p
          assert.unreachable('should have thrown')
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })

      test('accepts optional AbortController', async () => {
        const ac = new AbortController()
        const p = $({ ac, detached: true })`sleep 999`
        setTimeout(() => ac.abort(), 100)

        try {
          await p
          assert.unreachable('should have thrown')
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })

      test('accepts AbortController `signal` separately', async () => {
        const ac = new AbortController()
        const signal = ac.signal
        const p = $({ signal, detached: true })`sleep 999`
        setTimeout(() => ac.abort(), 100)

        try {
          await p
          assert.unreachable('should have thrown')
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })

      describe('handles halt option', () => {
        test('just works', async () => {
          const filepath = `${tempdir()}/${Math.random().toString()}`
          const p = $({ halt: true })`touch ${filepath}`
          await sleep(1)
          assert.ok(
            !fs.existsSync(filepath),
            'The cmd called, but it should not have been called'
          )
          await p.run()
          assert.ok(fs.existsSync(filepath), 'The cmd should have been called')
        })

        test('sync process ignores halt option', () => {
          const p = $.sync({ halt: true })`echo foo`
          assert.equal(p.stdout, 'foo\n')
        })
      })

      test('exposes `signal` property', async () => {
        const ac = new AbortController()
        const p = $({ ac, detached: true })`echo test`

        assert.equal(p.signal, ac.signal)
        await p
      })

      test('throws if the signal was previously aborted', async () => {
        const ac = new AbortController()
        const { signal } = ac
        ac.abort('reason')

        try {
          await $({ signal, detached: true })`sleep 999`
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })

      test('throws if the signal is controlled by another process', async () => {
        const ac = new AbortController()
        const { signal } = ac
        const p = $({ signal })`sleep 999`

        try {
          p.abort()
        } catch ({ message }) {
          assert.match(message, /The signal is controlled by another process./)
        }

        try {
          ac.abort()
          await p
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })

      test('throws if too late', async () => {
        const p = $`echo foo`
        await p

        assert.throws(() => p.abort(), /Too late to abort the process/)
      })

      test('abort signal is transmittable through pipe', async () => {
        const ac = new AbortController()
        const { signal } = ac
        const p1 = $({ signal, nothrow: true })`echo test`
        const p2 = p1.pipe`sleep 999`
        setTimeout(() => ac.abort(), 50)

        try {
          await p2
        } catch ({ message }) {
          assert.match(message, /The operation was aborted/)
        }
      })
    })

    describe('kill()', () => {
      test('just works', async () => {
        const p = $`sleep 999`.nothrow()
        setTimeout(() => {
          p.kill()
        }, 100)
        const o = await p
        assert.equal(o.signal, 'SIGTERM')
        assert.ok(o.duration >= 100 && o.duration < 1000)
      })

      test('applies custom signal if passed', async () => {
        const p = $`while true; do :; done`
        setTimeout(() => p.kill('SIGKILL'), 100)
        let signal
        try {
          await p
        } catch (p) {
          signal = p.signal
        }
        assert.equal(signal, 'SIGKILL')
      })

      test('applies `$.killSignal` if defined', async () => {
        const p = $({ killSignal: 'SIGKILL' })`while true; do :; done`
        setTimeout(() => p.kill(), 100)
        let signal
        try {
          await p
        } catch (p) {
          signal = p.signal
        }
        assert.equal(signal, 'SIGKILL')
      })

      test('throws if too late', async () => {
        const p = $`echo foo`
        await p

        assert.throws(() => p.kill(), /Too late to kill the process/)
      })

      test('throws if too early', async () => {
        const p = $({ halt: true })`echo foo`

        assert.throws(
          () => p.kill(),
          /Trying to kill a process without creating one/
        )
      })

      test('throws if pid is empty', async () => {
        const p = $({
          spawn() {
            return new EventEmitter()
          },
        })`echo foo`

        assert.throws(() => p.kill(), /The process pid is undefined/)
      })
    })

    describe('[Symbol.asyncIterator]', () => {
      it('should iterate over lines from stdout', async () => {
        const process = $`echo "Line1\nLine2\nLine3"`
        const lines = []
        for await (const line of process) {
          lines.push(line)
        }

        assert.deepEqual(lines, ['Line1', 'Line2', 'Line3'])
      })

      it('should handle partial lines correctly', async () => {
        const process = $`node -e "process.stdout.write('PartialLine1\\nLine2\\nPartial'); setTimeout(() => process.stdout.write('Line3\\n'), 100)"`
        const lines = []
        for await (const line of process) {
          lines.push(line)
        }

        assert.deepEqual(lines, ['PartialLine1', 'Line2', 'PartialLine3'])
      })

      it('should handle empty stdout', async () => {
        const process = $`echo -n ""`
        const lines = []
        for await (const line of process) {
          lines.push(line)
        }

        assert.equal(lines.length, 0, 'Should have 0 lines for empty stdout')
      })

      it('should handle single line without trailing newline', async () => {
        const process = $`echo -n "SingleLine"`
        const lines = []
        for await (const line of process) {
          lines.push(line)
        }

        assert.deepEqual(lines, ['SingleLine'])
      })

      it('should yield all buffered and new chunks when iterated after a delay', async () => {
        const process = $`sleep 0.1; echo Chunk1; sleep 0.1; echo Chunk2; sleep 0.2; echo Chunk3; sleep 0.1; echo Chunk4;`
        const chunks = []

        await sleep(250)
        for await (const chunk of process) {
          chunks.push(chunk)
        }

        assert.equal(chunks.length, 4, 'Should get all chunks')
        assert.equal(chunks[0], 'Chunk1', 'First chunk should be "Chunk1"')
        assert.equal(chunks[3], 'Chunk4', 'Second chunk should be "Chunk4"')
      })

      it('handles ignored stdio', async () => {
        const p = $({
          stdio: 'ignore',
        })`sleep 0.1; echo Chunk1; sleep 0.1; echo Chunk2`
        const chunks = []
        for await (const chunk of p) {
          chunks.push(chunk)
        }

        assert.equal(chunks.length, 0)
        assert.equal((await p).stdout, '')
      })

      it('handles non-iterable stdio', async () => {
        const file = tempfile()
        const fd = fs.openSync(file, 'w')
        const p = $({
          stdio: ['ignore', fd, 'ignore'],
        })`sleep 0.1; echo Chunk1; sleep 0.1; echo Chunk2`
        const chunks = []
        for await (const chunk of p) {
          chunks.push(chunk)
        }

        assert.equal(chunks.length, 0)
        assert.equal((await p).stdout, '')
        assert.equal(fs.readFileSync(file, 'utf-8'), `Chunk1\nChunk2\n`)
      })

      it('should process all output before handling a non-zero exit code', async () => {
        const process = $`sleep 0.1; echo foo; sleep 0.1; echo bar; sleep 0.1; exit 1;`
        const chunks = []

        let errorCaught = null
        try {
          for await (const chunk of process) {
            chunks.push(chunk)
          }
        } catch (err) {
          errorCaught = err
        }

        assert.equal(chunks.length, 2, 'Should have received 2 chunks')
        assert.equal(chunks[0], 'foo', 'First chunk should be "foo"')
        assert.equal(chunks[1], 'bar', 'Second chunk should be "bar"')

        assert.ok(errorCaught, 'An error should have been caught')
        assert.equal(
          errorCaught.exitCode,
          1,
          'The process exit code should be 1'
        )
      })

      it('handles .nothrow() correctly', async () => {
        const lines = []
        for await (const line of $({ nothrow: true })`grep any test`) {
          lines.push(line)
        }
        assert.equal(lines.length, 0, 'Should not yield any lines')
      })

      it('handles a custom delimiter', async () => {
        const lines = []
        for await (const line of $({
          delimiter: '\0',
          cwd: tempdir(),
        })`touch foo bar baz; find ./ -type f -print0 -maxdepth 1`) {
          lines.push(line)
        }
        assert.deepEqual(lines.sort(), ['./bar', './baz', './foo'])
      })
    })

    test('quiet() mode is working', async () => {
      const log = console.log
      let stdout = ''
      console.log = (...args) => {
        stdout += args.join(' ')
      }
      await $`echo 'test'`.quiet()
      console.log = log
      assert.equal(stdout, '')
      {
        // Deprecated.
        let stdout = ''
        console.log = (...args) => {
          stdout += args.join(' ')
        }
        await quiet($`echo 'test'`)
        console.log = log
        assert.equal(stdout, '')
      }
    })

    test('verbose() mode is working', async () => {
      const p = $`echo 'test'`
      assert.equal(p.isVerbose(), false)

      p.verbose()
      assert.equal(p.isVerbose(), true)

      p.verbose(false)
      assert.equal(p.isVerbose(), false)
    })

    test('nothrow() does not throw', async () => {
      {
        const { exitCode } = await $`exit 42`.nothrow()
        assert.equal(exitCode, 42)
      }
      {
        // Toggle
        try {
          const p = $`exit 42`.nothrow()
          await p.nothrow(false)
        } catch ({ exitCode }) {
          assert.equal(exitCode, 42)
        }
      }
      {
        // Deprecated.
        const { exitCode } = await nothrow($`exit 42`)
        assert.equal(exitCode, 42)
      }
    })

    describe('timeout()', () => {
      test('expiration works', async () => {
        await $`sleep 1`.timeout(1000)
        let exitCode, signal
        try {
          await $`sleep 1`.timeout(200)
        } catch (p) {
          exitCode = p.exitCode
          signal = p.signal
        }
        assert.equal(exitCode, null)
        assert.equal(signal, 'SIGTERM')
      })

      test('accepts a signal opt', async () => {
        let exitCode, signal
        try {
          await $`sleep 999`.timeout(10, 'SIGKILL')
        } catch (p) {
          exitCode = p.exitCode
          signal = p.signal
        }
        assert.equal(exitCode, null)
        assert.equal(signal, 'SIGKILL')
      })
    })

    test('json()', async () => {
      assert.deepEqual(await $`echo '{"key":"value"}'`.json(), { key: 'value' })
    })

    test('text()', async () => {
      const p = $`echo foo`
      assert.equal(await p.text(), 'foo\n')
      assert.equal(await p.text('hex'), '666f6f0a')
    })

    test('lines()', async () => {
      const p1 = $`echo 'foo\nbar\r\nbaz'`
      assert.deepEqual(await p1.lines(), ['foo', 'bar', 'baz'])

      const p2 = $.sync`echo 'foo\nbar\r\nbaz'`
      assert.deepEqual(p2.lines(), ['foo', 'bar', 'baz'])

      const p3 = $({
        cwd: await tempdir(),
      })`touch foo bar baz; find ./ -type f -print0 -maxdepth 1`
      assert.deepEqual((await p3.lines('\0')).sort(), [
        './bar',
        './baz',
        './foo',
      ])
    })

    test('buffer()', async () => {
      assert.equal(
        (await $`echo foo`.buffer()).compare(Buffer.from('foo\n', 'utf-8')),
        0
      )
    })

    test('blob()', async () => {
      const p = $`echo foo`
      assert.equal(await (await p.blob()).text(), 'foo\n')
    })
  })

  describe('ProcessOutput', () => {
    test('getters', async () => {
      const o = new ProcessOutput(-1, 'SIGTERM', '', '', 'foo\n', 'msg', 20)

      assert.equal(o.stdout, '')
      assert.equal(o.stderr, '')
      assert.equal(o.stdall, 'foo\n')
      assert.equal(o.signal, 'SIGTERM')
      assert.equal(o.exitCode, -1)
      assert.equal(o.duration, 20)
      assert.equal(o.ok, false)
      assert.equal(
        o.message,
        'msg\n    errno: undefined (Unknown error)\n    code: undefined\n    at '
      )
      assert.equal(Object.prototype.toString.call(o), '[object ProcessOutput]')

      const o1 = new ProcessOutput({
        code: -1,
        from: 'file.js(12:34)',
        store: {
          stdall: ['error in stdout'],
          stdout: [],
          stderr: [],
        },
      })
      assert.equal(
        o1.message,
        '\n    at file.js(12:34)\n    exit code: -1\n    details: \nerror in stdout'
      )
    })

    test('[Symbol.toPrimitive]', () => {
      const o = new ProcessOutput(-1, 'SIGTERM', '', '', 'foo\n', 'msg', 20)
      assert.equal('' + o, 'foo')
      assert.equal(`${o}`, 'foo')
      assert.equal(+o, NaN)
    })

    test('toString()', async () => {
      const o = new ProcessOutput(null, null, '', '', 'foo\n')
      assert.equal(o.toString(), 'foo\n')
    })

    test('valueOf()', async () => {
      const o = new ProcessOutput(null, null, '', '', 'foo\n')
      assert.equal(o.valueOf(), 'foo')
      assert.ok(o == 'foo')
    })

    test('json()', async () => {
      const o = new ProcessOutput(null, null, '', '', '{"key":"value"}')
      assert.deepEqual(o.json(), { key: 'value' })
    })

    test('text()', async () => {
      const o = new ProcessOutput(null, null, '', '', 'foo\n')
      assert.equal(o.text(), 'foo\n')
      assert.equal(o.text('hex'), '666f6f0a')
    })

    test('lines()', async () => {
      const o1 = new ProcessOutput(null, null, '', '', 'foo\nbar\r\nbaz\n')
      assert.deepEqual(o1.lines(), ['foo', 'bar', 'baz'])

      const o2 = new ProcessOutput(null, null, '', '', 'foo\0bar\0baz\0')
      assert.deepEqual(o2.lines(), ['foo\0bar\0baz\0'])
      assert.deepEqual(o2.lines('\0'), ['foo', 'bar', 'baz'])
    })

    test('buffer()', async () => {
      const o = new ProcessOutput(null, null, '', '', 'foo\n')
      assert.equal(o.buffer().compare(Buffer.from('foo\n', 'utf-8')), 0)
    })

    test('blob()', async () => {
      const o = new ProcessOutput(null, null, '', '', 'foo\n')
      assert.equal(await o.blob().text(), 'foo\n')

      const { Blob } = globalThis
      globalThis.Blob = undefined
      assert.throws(() => o.blob(), /Blob is not supported/)
      globalThis.Blob = Blob
    })

    test('[Symbol.Iterator]', () => {
      const o = new ProcessOutput({
        store: {
          stdall: ['foo\nba', 'r\nbaz'],
        },
      })
      const lines = []
      const expected = ['foo', 'bar', 'baz']
      for (const line of o) {
        lines.push(line)
      }
      assert.deepEqual(lines, expected)
      assert.deepEqual(o.lines(), expected)
      assert.deepEqual([...o], expected) // isConcatSpreadable
    })

    describe('static', () => {
      test('getExitMessage()', () => {
        assert.match(
          ProcessOutput.getExitMessage(2, null, '', ''),
          /Misuse of shell builtins/
        )
      })

      test('getErrorMessage()', () => {
        assert.match(
          ProcessOutput.getErrorMessage({ errno: -2 }, ''),
          /No such file or directory/
        )
        assert.match(
          ProcessOutput.getErrorMessage({ errno: -1e9 }, ''),
          /Unknown error/
        )
        assert.match(ProcessOutput.getErrorMessage({}, ''), /Unknown error/)
      })
    })
  })

  describe('cd()', () => {
    test('works with relative paths', async () => {
      const cwd = process.cwd()
      try {
        fs.mkdirpSync('/tmp/zx-cd-test/one/two')
        cd('/tmp/zx-cd-test/one/two')
        const p1 = $`pwd`
        assert.equal($.cwd, undefined)
        assert.ok(process.cwd().endsWith('/two'))

        cd('..')
        const p2 = $`pwd`
        assert.equal($.cwd, undefined)
        assert.ok(process.cwd().endsWith('/one'))

        cd('..')
        const p3 = $`pwd`
        assert.equal($.cwd, undefined)
        assert.ok(process.cwd().endsWith('/tmp/zx-cd-test'))

        const results = (await Promise.all([p1, p2, p3])).map((p) =>
          basename(p.stdout.trim())
        )
        assert.deepEqual(results, ['two', 'one', 'zx-cd-test'])
      } catch (e) {
        assert.ok(!e, e)
      } finally {
        fs.rmSync('/tmp/zx-cd-test', { recursive: true })
        cd(cwd)
      }
    })

    test('does not affect parallel contexts ($.cwdSyncHook enabled)', async () => {
      syncProcessCwd()
      const cwd = process.cwd()
      try {
        fs.mkdirpSync('/tmp/zx-cd-parallel/one/two')
        await Promise.all([
          within(async () => {
            assert.equal(process.cwd(), cwd)
            cd('/tmp/zx-cd-parallel/one')
            await sleep(Math.random() * 15)
            assert.ok(process.cwd().endsWith('/tmp/zx-cd-parallel/one'))
          }),
          within(async () => {
            assert.equal(process.cwd(), cwd)
            await sleep(Math.random() * 15)
            assert.equal(process.cwd(), cwd)
          }),
          within(async () => {
            assert.equal(process.cwd(), cwd)
            await sleep(Math.random() * 15)
            $.cwd = '/tmp/zx-cd-parallel/one/two'
            assert.equal(process.cwd(), cwd)
            assert.ok(
              (await $`pwd`).stdout
                .toString()
                .trim()
                .endsWith('/tmp/zx-cd-parallel/one/two')
            )
          }),
        ])
      } catch (e) {
        assert.ok(!e, e)
      } finally {
        fs.rmSync('/tmp/zx-cd-parallel', { recursive: true })
        cd(cwd)
        syncProcessCwd(false)
      }
    })

    test('fails on entering not existing dir', async () => {
      assert.throws(() => cd('/tmp/abra-kadabra'))
    })

    test('accepts ProcessOutput in addition to string', async () => {
      await within(async () => {
        const tmp = await $`mktemp -d`
        cd(tmp)
        assert.equal(
          basename(process.cwd()),
          basename(tmp.toString().trimEnd())
        )
      })
    })
  })

  describe('within()', () => {
    test('just works', async () => {
      let resolve, reject
      const promise = new Promise((...args) => ([resolve, reject] = args))

      function yes() {
        assert.equal($.verbose, true)
        resolve()
      }

      assert.equal($.verbose, false)

      within(() => {
        $.verbose = true
      })
      assert.equal($.verbose, false)

      within(async () => {
        $.verbose = true
        setTimeout(yes, 10)
      })
      assert.equal($.verbose, false)

      await promise
    })

    test('keeps the cwd ref for internal $ calls', async () => {
      let resolve, reject
      const promise = new Promise((...args) => ([resolve, reject] = args))
      const cwd = process.cwd()
      const pwd = await $`pwd`

      within(async () => {
        cd('/tmp')
        assert.ok(process.cwd().endsWith('/tmp'))
        assert.ok((await $`pwd`).stdout.trim().endsWith('/tmp'))

        setTimeout(async () => {
          process.chdir('/')
          assert.ok((await $`pwd`).stdout.trim().endsWith('/tmp'))
          resolve()
          process.chdir(cwd)
        }, 1000)
      })

      assert.equal((await $`pwd`).stdout, pwd.stdout)
      await promise
    })

    test(`isolates nested context and returns cb result`, async () => {
      within(async () => {
        const res = await within(async () => {
          $.verbose = true

          return within(async () => {
            assert.equal($.verbose, true)
            $.verbose = false

            return within(async () => {
              assert.equal($.verbose, false)
              $.verbose = true
              return 'foo'
            })
          })
        })
        assert.equal($.verbose, false)
        assert.equal(res, 'foo')
      })
    })
  })

  describe('shell presets', () => {
    const originalWhichSync = which.sync
    before(() => {
      which.sync = (bin) => bin
    })
    after(() => {
      which.sync = originalWhichSync
      useBash()
    })

    test('usePwsh()', () => {
      usePwsh()
      assert.equal($.shell, 'pwsh')
      assert.equal($.prefix, '')
      assert.equal($.postfix, '; exit $LastExitCode')
      assert.equal($.quote, quotePowerShell)
    })

    test('usePowerShell()', () => {
      usePowerShell()
      assert.equal($.shell, 'powershell.exe')
      assert.equal($.prefix, '')
      assert.equal($.postfix, '; exit $LastExitCode')
      assert.equal($.quote, quotePowerShell)
    })

    test('useBash()', () => {
      useBash()
      assert.equal($.shell, 'bash')
      assert.equal($.prefix, 'set -euo pipefail;')
      assert.equal($.postfix, '')
      assert.equal($.quote, quote)
    })
  })
})



================================================
FILE: test/deps.test.js
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import { $, tmpfile, tmpdir, fs, path } from '../build/index.js'
import { installDeps, parseDeps } from '../build/deps.cjs'

const __dirname = new URL('.', import.meta.url).pathname
const root = path.resolve(__dirname, '..')
const cli = path.resolve(root, 'build/cli.js')

describe('deps', () => {
  describe('installDeps()', () => {
    const pkgjson = tmpfile(
      'package.json',
      '{"name": "temp", "version": "0.0.0"}'
    )
    const cwd = path.dirname(pkgjson)
    const t$ = $({ cwd })
    const load = (dep) =>
      fs.readJsonSync(path.join(cwd, 'node_modules', dep, 'package.json'))

    test('loader works via JS API', async () => {
      await installDeps(
        {
          cpy: '9.0.1',
          'lodash-es': '4.17.21',
        },
        cwd
      )
      assert(load('cpy').name === 'cpy')
      assert(load('lodash-es').name === 'lodash-es')
    })

    test('loader works via JS API with custom npm registry URL', async () => {
      await installDeps(
        {
          '@jsr/std__internal': '1.0.5',
        },
        cwd,
        'https://npm.jsr.io'
      )

      assert(load('@jsr/std__internal').name === '@jsr/std__internal')
    })

    test('loader works via CLI', async () => {
      const out =
        await t$`node ${cli} --install <<< 'import _ from "lodash" /* @4.17.15 */; console.log(_.VERSION)'`
      assert.match(out.stdout, /4.17.15/)
    })

    test('loader works via CLI with custom npm registry URL', async () => {
      const code =
        'import { diff } from "@jsr/std__internal";console.log(diff instanceof Function)'
      const file = tmpfile('index.mjs', code)

      let out = await t$`node ${cli} --i --registry=https://npm.jsr.io ${file}`
      fs.remove(file)
      assert.match(out.stdout, /true/)

      out = await t$`node ${cli}  -i --registry=https://npm.jsr.io <<< ${code}`
      assert.match(out.stdout, /true/)
    })

    test('throws on invalid installer type', async () => {
      await assert.rejects(
        () =>
          installDeps({ foo: 'latest' }, cwd, 'https://npm.jsr.io', 'invalid'),
        {
          message: /Unsupported installer type: invalid. Supported types: npm/,
        }
      )
    })

    test('does nothing on empty deps', async () => {
      const cwd = tmpdir()
      await installDeps({}, cwd)
      assert(!fs.existsSync(path.join(cwd, 'node_modules')))
    })
  })

  describe('parseDeps()', () => {
    test('import or require', async () => {
      ;[
        [`import "foo"`, { foo: 'latest' }],
        [`import "foo"`, { foo: 'latest' }],
        [`import * as bar from "foo"`, { foo: 'latest' }],
        [`import('foo')`, { foo: 'latest' }],
        [`require('foo')`, { foo: 'latest' }],
        [`require('foo/bar')`, { foo: 'latest' }],
        [`require('foo/bar.js')`, { foo: 'latest' }],
        [`require('foo-bar')`, { 'foo-bar': 'latest' }],
        [`require('foo_bar')`, { foo_bar: 'latest' }],
        [`require('@foo/bar')`, { '@foo/bar': 'latest' }],
        [`require('@foo/bar/baz')`, { '@foo/bar': 'latest' }],
        [`require('foo.js')`, { 'foo.js': 'latest' }],

        // ignores local deps
        [`import '.'`, {}],
        [`require('.')`, {}],
        [`require('..')`, {}],
        [`require('../foo.js')`, {}],
        [`require('./foo.js')`, {}],

        // ignores invalid pkg names
        [`require('_foo')`, {}],
        [`require('@')`, {}],
        [`require('@/_foo')`, {}],
        [`require('@foo')`, {}],
      ].forEach(([input, result]) => {
        assert.deepEqual(parseDeps(input), result)
      })
    })

    test('import with org and filename', async () => {
      assert.deepEqual(parseDeps(`import "@foo/bar/file"`), {
        '@foo/bar': 'latest',
      })
    })

    test('import with version', async () => {
      assert.deepEqual(parseDeps(`import "foo" // @2.x`), { foo: '2.x' })
      assert.deepEqual(parseDeps(`import "foo" // @^7`), { foo: '^7' })
      assert.deepEqual(parseDeps(`import "foo" /* @1.2.x */`), { foo: '1.2.x' })
    })

    test('multiline', () => {
      const contents = `
  require('a') // @1.0.0
  const b =require('b') /* @2.0.0 */
  const c = {
    c:require('c') /* @3.0.0 */,
    d: await import('d') /* @4.0.0 */,
    ...require('e') /* @5.0.0 */
  }
  const f = [...require('f') /* @6.0.0 */]
  ;require('g'); // @7.0.0
  const h = 1 *require('h') // @8.0.0
  {require('i') /* @9.0.0 */}
  import 'j' // @10.0.0

  import fs from 'fs'
  import path from 'path'
  import foo from "foo"
  // import aaa from 'a'
  /* import bbb from 'b' */
  import bar from "bar" /* @1.0.0 */
  import baz from "baz" //    @^2.0
  import qux from "@qux/pkg/entry" //    @^3.0
  import {api as alias} from "qux/entry/index.js" // @^4.0.0-beta.0

  const cpy = await import('cpy')
  const { pick } = require("lodash") //  @4.17.15
  `

      assert.deepEqual(parseDeps(contents), {
        a: '1.0.0',
        b: '2.0.0',
        c: '3.0.0',
        d: '4.0.0',
        e: '5.0.0',
        f: '6.0.0',
        g: '7.0.0',
        h: '8.0.0',
        i: '9.0.0',
        j: '10.0.0',
        foo: 'latest',
        bar: '1.0.0',
        baz: '^2.0',
        '@qux/pkg': '^3.0',
        qux: '^4.0.0-beta.0',
        cpy: 'latest',
        lodash: '4.17.15',
      })
    })
  })
})



================================================
FILE: test/error.test.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import { Fail } from '../src/error.ts'

const {
  getErrnoMessage,
  getExitCodeInfo,
  getCallerLocation,
  getCallerLocationFromString,
  formatExitMessage,
  formatErrorMessage,
  formatErrorDetails,
} = Fail

describe('error', () => {
  test('getExitCodeInfo()', () => {
    assert.equal(getExitCodeInfo(2), 'Misuse of shell builtins')
  })

  test('getErrnoMessage()', () => {
    assert.equal(getErrnoMessage(-2), 'No such file or directory')
    assert.equal(getErrnoMessage(1e9), 'Unknown error')
    assert.equal(getErrnoMessage(undefined), 'Unknown error')
  })

  test('getCallerLocation()', () => {
    assert.match(
      getCallerLocation(new Error('Foo')),
      /TestContext\.<anonymous>/
    )
  })

  describe('getCallerLocationFromString()', () => {
    test('empty', () => {
      assert.equal(getCallerLocationFromString(), 'unknown')
    })

    test('no-match', () => {
      assert.equal(
        getCallerLocationFromString('stack\nstring'),
        'stack\nstring'
      )
    })

    test(`getCallerLocationFromString-v8`, () => {
      const stack = `
    Error
      at getCallerLocation (/Users/user/test.js:22:17)
      at Proxy.set (/Users/user/test.js:40:10)
      at e (/Users/user/test.js:34:13)
      at d (/Users/user/test.js:11:5)
      at c (/Users/user/test.js:8:5)
      at b (/Users/user/test.js:5:5)
      at a (/Users/user/test.js:2:5)
      at Object.<anonymous> (/Users/user/test.js:37:1)
      at Module._compile (node:internal/modules/cjs/loader:1254:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)
      at Module.load (node:internal/modules/cjs/loader:1117:32)
      at Module._load (node:internal/modules/cjs/loader:958:12)
    `
      assert.match(getCallerLocationFromString(stack), /^.*:11:5.*$/)
    })

    test(`getCallerLocationFromString-JSC`, () => {
      const stack = `
    getCallerLocation@/Users/user/test.js:22:17
    Proxy.set@/Users/user/test.js:40:10)
    e@/Users/user/test.js:34:13
    d@/Users/user/test.js:11:5
    c@/Users/user/test.js:8:5
    b@/Users/user/test.js:5:5
    a@/Users/user/test.js:2:5
    module code@/Users/user/test.js:37:1
    evaluate@[native code]
    moduleEvaluation@[native code]
    moduleEvaluation@[native code]
    @[native code]
    asyncFunctionResume@[native code]
    promiseReactionJobWithoutPromise@[native code]
    promiseReactionJob@[native code]
    d@/Users/user/test.js:11:5
  `
      assert.match(getCallerLocationFromString(stack), /^.*:11:5.*$/)
    })
  })

  // prettier-ignore
  test('getExitMessage()', () => {
    assert.match(formatExitMessage(2, null, '', ''), /Misuse of shell builtins/)
    assert.equal(formatExitMessage(1, 'SIGKILL', '', '', 'data'), `\n    at \n    exit code: 1\n    signal: SIGKILL\n    details: \ndata`)
    assert.equal(formatExitMessage(0, null, '', ''), 'exit code: 0')
  })

  test('getErrorMessage()', () => {
    assert.match(
      formatErrorMessage({ errno: -2 } as NodeJS.ErrnoException, ''),
      /No such file or directory/
    )
    assert.match(
      formatErrorMessage({ errno: -1e9 } as NodeJS.ErrnoException, ''),
      /Unknown error/
    )
    assert.match(
      formatErrorMessage({} as NodeJS.ErrnoException, ''),
      /Unknown error/
    )
  })

  test('findErrors()', () => {
    const lines = [...Array(40).keys()].map((v) => v + '')

    assert.equal(formatErrorDetails([]), '', 'empty returns empty')
    assert.equal(
      formatErrorDetails(['foo', 'bar']),
      'foo\nbar',
      'squashes a few'
    )
    assert.equal(
      formatErrorDetails(['failure: foo', 'NOT OK smth', ...lines]),
      'failure: foo\nNOT OK smth',
      'extracts errors'
    )
    assert.equal(
      formatErrorDetails(lines),
      '0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n...',
      'shows a sample'
    )
  })
})



================================================
FILE: test/export.test.js
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import * as core from '../build/core.cjs'
import * as cli from '../build/cli.cjs'
import * as index from '../build/index.cjs'

//prettier-ignore
describe('core', () => {
  test('exports', () => {
    assert.equal(typeof core.$, 'function', 'core.$')
    assert.equal(typeof core.Fail, 'function', 'core.Fail')
    assert.equal(typeof core.Fail.DOCS_URL, 'string', 'core.Fail.DOCS_URL')
    assert.equal(typeof core.Fail.ERRNO_CODES, 'object', 'core.Fail.ERRNO_CODES')
    assert.equal(typeof core.Fail.EXIT_CODES, 'object', 'core.Fail.EXIT_CODES')
    assert.equal(typeof core.ProcessOutput, 'function', 'core.ProcessOutput')
    assert.equal(typeof core.ProcessOutput.getErrorDetails, 'function', 'core.ProcessOutput.getErrorDetails')
    assert.equal(typeof core.ProcessOutput.getErrorMessage, 'function', 'core.ProcessOutput.getErrorMessage')
    assert.equal(typeof core.ProcessOutput.getExitCodeInfo, 'function', 'core.ProcessOutput.getExitCodeInfo')
    assert.equal(typeof core.ProcessOutput.getExitMessage, 'function', 'core.ProcessOutput.getExitMessage')
    assert.equal(typeof core.ProcessPromise, 'function', 'core.ProcessPromise')
    assert.equal(typeof core.ProcessPromise.bus, 'object', 'core.ProcessPromise.bus')
    assert.equal(typeof core.ProcessPromise.promisifyStream, 'function', 'core.ProcessPromise.promisifyStream')
    assert.equal(typeof core.cd, 'function', 'core.cd')
    assert.equal(typeof core.chalk, 'function', 'core.chalk')
    assert.equal(typeof core.chalk.level, 'number', 'core.chalk.level')
    assert.equal(typeof core.defaults, 'object', 'core.defaults')
    assert.equal(typeof core.defaults.detached, 'boolean', 'core.defaults.detached')
    assert.equal(typeof core.defaults.env, 'object', 'core.defaults.env')
    assert.equal(typeof core.defaults.kill, 'function', 'core.defaults.kill')
    assert.equal(typeof core.defaults.killSignal, 'string', 'core.defaults.killSignal')
    assert.equal(typeof core.defaults.log, 'function', 'core.defaults.log')
    assert.equal(typeof core.defaults.nothrow, 'boolean', 'core.defaults.nothrow')
    assert.equal(typeof core.defaults.postfix, 'string', 'core.defaults.postfix')
    assert.equal(typeof core.defaults.preferLocal, 'boolean', 'core.defaults.preferLocal')
    assert.equal(typeof core.defaults.prefix, 'string', 'core.defaults.prefix')
    assert.equal(typeof core.defaults.quiet, 'boolean', 'core.defaults.quiet')
    assert.equal(typeof core.defaults.quote, 'function', 'core.defaults.quote')
    assert.equal(typeof core.defaults.shell, 'string', 'core.defaults.shell')
    assert.equal(typeof core.defaults.spawn, 'function', 'core.defaults.spawn')
    assert.equal(typeof core.defaults.spawnSync, 'function', 'core.defaults.spawnSync')
    assert.equal(typeof core.defaults.stdio, 'string', 'core.defaults.stdio')
    assert.equal(typeof core.defaults.sync, 'boolean', 'core.defaults.sync')
    assert.equal(typeof core.defaults.timeoutSignal, 'string', 'core.defaults.timeoutSignal')
    assert.equal(typeof core.defaults.verbose, 'boolean', 'core.defaults.verbose')
    assert.equal(typeof core.kill, 'function', 'core.kill')
    assert.equal(typeof core.log, 'function', 'core.log')
    assert.equal(typeof core.os, 'object', 'core.os')
    assert.equal(typeof core.os.EOL, 'string', 'core.os.EOL')
    assert.equal(typeof core.os.arch, 'function', 'core.os.arch')
    assert.equal(typeof core.os.availableParallelism, 'function', 'core.os.availableParallelism')
    assert.equal(typeof core.os.constants, 'object', 'core.os.constants')
    assert.equal(typeof core.os.cpus, 'function', 'core.os.cpus')
    assert.equal(typeof core.os.default, 'object', 'core.os.default')
    assert.equal(typeof core.os.devNull, 'string', 'core.os.devNull')
    assert.equal(typeof core.os.endianness, 'function', 'core.os.endianness')
    assert.equal(typeof core.os.freemem, 'function', 'core.os.freemem')
    assert.equal(typeof core.os.getPriority, 'function', 'core.os.getPriority')
    assert.equal(typeof core.os.homedir, 'function', 'core.os.homedir')
    assert.equal(typeof core.os.hostname, 'function', 'core.os.hostname')
    assert.equal(typeof core.os.loadavg, 'function', 'core.os.loadavg')
    assert.equal(typeof core.os.machine, 'function', 'core.os.machine')
    assert.equal(typeof core.os.networkInterfaces, 'function', 'core.os.networkInterfaces')
    assert.equal(typeof core.os.platform, 'function', 'core.os.platform')
    assert.equal(typeof core.os.release, 'function', 'core.os.release')
    assert.equal(typeof core.os.setPriority, 'function', 'core.os.setPriority')
    assert.equal(typeof core.os.tmpdir, 'function', 'core.os.tmpdir')
    assert.equal(typeof core.os.totalmem, 'function', 'core.os.totalmem')
    assert.equal(typeof core.os.type, 'function', 'core.os.type')
    assert.equal(typeof core.os.uptime, 'function', 'core.os.uptime')
    assert.equal(typeof core.os.userInfo, 'function', 'core.os.userInfo')
    assert.equal(typeof core.os.version, 'function', 'core.os.version')
    assert.equal(typeof core.path, 'object', 'core.path')
    assert.equal(typeof core.path._makeLong, 'function', 'core.path._makeLong')
    assert.equal(typeof core.path.basename, 'function', 'core.path.basename')
    assert.equal(typeof core.path.delimiter, 'string', 'core.path.delimiter')
    assert.equal(typeof core.path.dirname, 'function', 'core.path.dirname')
    assert.equal(typeof core.path.extname, 'function', 'core.path.extname')
    assert.equal(typeof core.path.format, 'function', 'core.path.format')
    assert.equal(typeof core.path.isAbsolute, 'function', 'core.path.isAbsolute')
    assert.equal(typeof core.path.join, 'function', 'core.path.join')
    assert.equal(typeof core.path.matchesGlob, 'function', 'core.path.matchesGlob')
    assert.equal(typeof core.path.normalize, 'function', 'core.path.normalize')
    assert.equal(typeof core.path.parse, 'function', 'core.path.parse')
    assert.equal(typeof core.path.posix, 'object', 'core.path.posix')
    assert.equal(typeof core.path.relative, 'function', 'core.path.relative')
    assert.equal(typeof core.path.resolve, 'function', 'core.path.resolve')
    assert.equal(typeof core.path.sep, 'string', 'core.path.sep')
    assert.equal(typeof core.path.toNamespacedPath, 'function', 'core.path.toNamespacedPath')
    assert.equal(typeof core.path.win32, 'object', 'core.path.win32')
    assert.equal(typeof core.ps, 'object', 'core.ps')
    assert.equal(typeof core.ps.kill, 'function', 'core.ps.kill')
    assert.equal(typeof core.ps.lookup, 'function', 'core.ps.lookup')
    assert.equal(typeof core.ps.lookupSync, 'function', 'core.ps.lookupSync')
    assert.equal(typeof core.ps.tree, 'function', 'core.ps.tree')
    assert.equal(typeof core.ps.treeSync, 'function', 'core.ps.treeSync')
    assert.equal(typeof core.quote, 'function', 'core.quote')
    assert.equal(typeof core.quotePowerShell, 'function', 'core.quotePowerShell')
    assert.equal(typeof core.resolveDefaults, 'function', 'core.resolveDefaults')
    assert.equal(typeof core.syncProcessCwd, 'function', 'core.syncProcessCwd')
    assert.equal(typeof core.useBash, 'function', 'core.useBash')
    assert.equal(typeof core.usePowerShell, 'function', 'core.usePowerShell')
    assert.equal(typeof core.usePwsh, 'function', 'core.usePwsh')
    assert.equal(typeof core.which, 'function', 'core.which')
    assert.equal(typeof core.which.sync, 'function', 'core.which.sync')
    assert.equal(typeof core.within, 'function', 'core.within')
  })
})

//prettier-ignore
describe('cli', () => {
  test('exports', () => {
    assert.equal(typeof cli.argv, 'object', 'cli.argv')
    assert.equal(typeof cli.argv._, 'object', 'cli.argv._')
    assert.equal(typeof cli.argv.experimental, 'boolean', 'cli.argv.experimental')
    assert.equal(typeof cli.argv.h, 'boolean', 'cli.argv.h')
    assert.equal(typeof cli.argv.help, 'boolean', 'cli.argv.help')
    assert.equal(typeof cli.argv.i, 'boolean', 'cli.argv.i')
    assert.equal(typeof cli.argv.install, 'boolean', 'cli.argv.install')
    assert.equal(typeof cli.argv.l, 'boolean', 'cli.argv.l')
    assert.equal(typeof cli.argv.preferLocal, 'boolean', 'cli.argv.preferLocal')
    assert.equal(typeof cli.argv.quiet, 'boolean', 'cli.argv.quiet')
    assert.equal(typeof cli.argv.repl, 'boolean', 'cli.argv.repl')
    assert.equal(typeof cli.argv.v, 'boolean', 'cli.argv.v')
    assert.equal(typeof cli.argv.verbose, 'boolean', 'cli.argv.verbose')
    assert.equal(typeof cli.argv.version, 'boolean', 'cli.argv.version')
    assert.equal(typeof cli.injectGlobalRequire, 'function', 'cli.injectGlobalRequire')
    assert.equal(typeof cli.isMain, 'function', 'cli.isMain')
    assert.equal(typeof cli.main, 'function', 'cli.main')
    assert.equal(typeof cli.normalizeExt, 'function', 'cli.normalizeExt')
    assert.equal(typeof cli.printUsage, 'function', 'cli.printUsage')
    assert.equal(typeof cli.transformMarkdown, 'function', 'cli.transformMarkdown')
  })
})

//prettier-ignore
describe('index', () => {
  test('exports', () => {
    assert.equal(typeof index.$, 'function', 'index.$')
    assert.equal(typeof index.Fail, 'function', 'index.Fail')
    assert.equal(typeof index.Fail.DOCS_URL, 'string', 'index.Fail.DOCS_URL')
    assert.equal(typeof index.Fail.ERRNO_CODES, 'object', 'index.Fail.ERRNO_CODES')
    assert.equal(typeof index.Fail.EXIT_CODES, 'object', 'index.Fail.EXIT_CODES')
    assert.equal(typeof index.ProcessOutput, 'function', 'index.ProcessOutput')
    assert.equal(typeof index.ProcessOutput.getErrorDetails, 'function', 'index.ProcessOutput.getErrorDetails')
    assert.equal(typeof index.ProcessOutput.getErrorMessage, 'function', 'index.ProcessOutput.getErrorMessage')
    assert.equal(typeof index.ProcessOutput.getExitCodeInfo, 'function', 'index.ProcessOutput.getExitCodeInfo')
    assert.equal(typeof index.ProcessOutput.getExitMessage, 'function', 'index.ProcessOutput.getExitMessage')
    assert.equal(typeof index.ProcessPromise, 'function', 'index.ProcessPromise')
    assert.equal(typeof index.ProcessPromise.bus, 'object', 'index.ProcessPromise.bus')
    assert.equal(typeof index.ProcessPromise.promisifyStream, 'function', 'index.ProcessPromise.promisifyStream')
    assert.equal(typeof index.VERSION, 'string', 'index.VERSION')
    assert.equal(typeof index.YAML, 'object', 'index.YAML')
    assert.equal(typeof index.YAML.Alias, 'function', 'index.YAML.Alias')
    assert.equal(typeof index.YAML.CST, 'object', 'index.YAML.CST')
    assert.equal(typeof index.YAML.Composer, 'function', 'index.YAML.Composer')
    assert.equal(typeof index.YAML.Document, 'function', 'index.YAML.Document')
    assert.equal(typeof index.YAML.Lexer, 'function', 'index.YAML.Lexer')
    assert.equal(typeof index.YAML.LineCounter, 'function', 'index.YAML.LineCounter')
    assert.equal(typeof index.YAML.Pair, 'function', 'index.YAML.Pair')
    assert.equal(typeof index.YAML.Parser, 'function', 'index.YAML.Parser')
    assert.equal(typeof index.YAML.Scalar, 'function', 'index.YAML.Scalar')
    assert.equal(typeof index.YAML.Schema, 'function', 'index.YAML.Schema')
    assert.equal(typeof index.YAML.YAMLError, 'function', 'index.YAML.YAMLError')
    assert.equal(typeof index.YAML.YAMLMap, 'function', 'index.YAML.YAMLMap')
    assert.equal(typeof index.YAML.YAMLParseError, 'function', 'index.YAML.YAMLParseError')
    assert.equal(typeof index.YAML.YAMLSeq, 'function', 'index.YAML.YAMLSeq')
    assert.equal(typeof index.YAML.YAMLWarning, 'function', 'index.YAML.YAMLWarning')
    assert.equal(typeof index.YAML.default, 'object', 'index.YAML.default')
    assert.equal(typeof index.YAML.isAlias, 'function', 'index.YAML.isAlias')
    assert.equal(typeof index.YAML.isCollection, 'function', 'index.YAML.isCollection')
    assert.equal(typeof index.YAML.isDocument, 'function', 'index.YAML.isDocument')
    assert.equal(typeof index.YAML.isMap, 'function', 'index.YAML.isMap')
    assert.equal(typeof index.YAML.isNode, 'function', 'index.YAML.isNode')
    assert.equal(typeof index.YAML.isPair, 'function', 'index.YAML.isPair')
    assert.equal(typeof index.YAML.isScalar, 'function', 'index.YAML.isScalar')
    assert.equal(typeof index.YAML.isSeq, 'function', 'index.YAML.isSeq')
    assert.equal(typeof index.YAML.parse, 'function', 'index.YAML.parse')
    assert.equal(typeof index.YAML.parseAllDocuments, 'function', 'index.YAML.parseAllDocuments')
    assert.equal(typeof index.YAML.parseDocument, 'function', 'index.YAML.parseDocument')
    assert.equal(typeof index.YAML.stringify, 'function', 'index.YAML.stringify')
    assert.equal(typeof index.YAML.visit, 'function', 'index.YAML.visit')
    assert.equal(typeof index.YAML.visitAsync, 'function', 'index.YAML.visitAsync')
    assert.equal(typeof index.argv, 'object', 'index.argv')
    assert.equal(typeof index.argv._, 'object', 'index.argv._')
    assert.equal(typeof index.cd, 'function', 'index.cd')
    assert.equal(typeof index.chalk, 'function', 'index.chalk')
    assert.equal(typeof index.chalk.level, 'number', 'index.chalk.level')
    assert.equal(typeof index.defaults, 'object', 'index.defaults')
    assert.equal(typeof index.defaults.detached, 'boolean', 'index.defaults.detached')
    assert.equal(typeof index.defaults.env, 'object', 'index.defaults.env')
    assert.equal(typeof index.defaults.kill, 'function', 'index.defaults.kill')
    assert.equal(typeof index.defaults.killSignal, 'string', 'index.defaults.killSignal')
    assert.equal(typeof index.defaults.log, 'function', 'index.defaults.log')
    assert.equal(typeof index.defaults.nothrow, 'boolean', 'index.defaults.nothrow')
    assert.equal(typeof index.defaults.postfix, 'string', 'index.defaults.postfix')
    assert.equal(typeof index.defaults.preferLocal, 'boolean', 'index.defaults.preferLocal')
    assert.equal(typeof index.defaults.prefix, 'string', 'index.defaults.prefix')
    assert.equal(typeof index.defaults.quiet, 'boolean', 'index.defaults.quiet')
    assert.equal(typeof index.defaults.quote, 'function', 'index.defaults.quote')
    assert.equal(typeof index.defaults.shell, 'string', 'index.defaults.shell')
    assert.equal(typeof index.defaults.spawn, 'function', 'index.defaults.spawn')
    assert.equal(typeof index.defaults.spawnSync, 'function', 'index.defaults.spawnSync')
    assert.equal(typeof index.defaults.stdio, 'string', 'index.defaults.stdio')
    assert.equal(typeof index.defaults.sync, 'boolean', 'index.defaults.sync')
    assert.equal(typeof index.defaults.timeoutSignal, 'string', 'index.defaults.timeoutSignal')
    assert.equal(typeof index.defaults.verbose, 'boolean', 'index.defaults.verbose')
    assert.equal(typeof index.dotenv, 'object', 'index.dotenv')
    assert.equal(typeof index.dotenv.config, 'function', 'index.dotenv.config')
    assert.equal(typeof index.dotenv.load, 'function', 'index.dotenv.load')
    assert.equal(typeof index.dotenv.loadSafe, 'function', 'index.dotenv.loadSafe')
    assert.equal(typeof index.dotenv.parse, 'function', 'index.dotenv.parse')
    assert.equal(typeof index.dotenv.stringify, 'function', 'index.dotenv.stringify')
    assert.equal(typeof index.echo, 'function', 'index.echo')
    assert.equal(typeof index.expBackoff, 'function', 'index.expBackoff')
    assert.equal(typeof index.fetch, 'function', 'index.fetch')
    assert.equal(typeof index.fs, 'object', 'index.fs')
    assert.equal(typeof index.fs.Dir, 'function', 'index.fs.Dir')
    assert.equal(typeof index.fs.Dirent, 'function', 'index.fs.Dirent')
    assert.equal(typeof index.fs.F_OK, 'number', 'index.fs.F_OK')
    assert.equal(typeof index.fs.FileReadStream, 'function', 'index.fs.FileReadStream')
    assert.equal(typeof index.fs.FileWriteStream, 'function', 'index.fs.FileWriteStream')
    assert.equal(typeof index.fs.R_OK, 'number', 'index.fs.R_OK')
    assert.equal(typeof index.fs.ReadStream, 'function', 'index.fs.ReadStream')
    assert.equal(typeof index.fs.Stats, 'function', 'index.fs.Stats')
    assert.equal(typeof index.fs.W_OK, 'number', 'index.fs.W_OK')
    assert.equal(typeof index.fs.WriteStream, 'function', 'index.fs.WriteStream')
    assert.equal(typeof index.fs.X_OK, 'number', 'index.fs.X_OK')
    assert.equal(typeof index.fs._toUnixTimestamp, 'function', 'index.fs._toUnixTimestamp')
    assert.equal(typeof index.fs.access, 'function', 'index.fs.access')
    assert.equal(typeof index.fs.accessSync, 'function', 'index.fs.accessSync')
    assert.equal(typeof index.fs.appendFile, 'function', 'index.fs.appendFile')
    assert.equal(typeof index.fs.appendFileSync, 'function', 'index.fs.appendFileSync')
    assert.equal(typeof index.fs.chmod, 'function', 'index.fs.chmod')
    assert.equal(typeof index.fs.chmodSync, 'function', 'index.fs.chmodSync')
    assert.equal(typeof index.fs.chown, 'function', 'index.fs.chown')
    assert.equal(typeof index.fs.chownSync, 'function', 'index.fs.chownSync')
    assert.equal(typeof index.fs.close, 'function', 'index.fs.close')
    assert.equal(typeof index.fs.closeSync, 'function', 'index.fs.closeSync')
    assert.equal(typeof index.fs.constants, 'object', 'index.fs.constants')
    assert.equal(typeof index.fs.copy, 'function', 'index.fs.copy')
    assert.equal(typeof index.fs.copyFile, 'function', 'index.fs.copyFile')
    assert.equal(typeof index.fs.copyFileSync, 'function', 'index.fs.copyFileSync')
    assert.equal(typeof index.fs.copySync, 'function', 'index.fs.copySync')
    assert.equal(typeof index.fs.cp, 'function', 'index.fs.cp')
    assert.equal(typeof index.fs.cpSync, 'function', 'index.fs.cpSync')
    assert.equal(typeof index.fs.createFile, 'function', 'index.fs.createFile')
    assert.equal(typeof index.fs.createFileSync, 'function', 'index.fs.createFileSync')
    assert.equal(typeof index.fs.createLink, 'function', 'index.fs.createLink')
    assert.equal(typeof index.fs.createLinkSync, 'function', 'index.fs.createLinkSync')
    assert.equal(typeof index.fs.createReadStream, 'function', 'index.fs.createReadStream')
    assert.equal(typeof index.fs.createSymlink, 'function', 'index.fs.createSymlink')
    assert.equal(typeof index.fs.createSymlinkSync, 'function', 'index.fs.createSymlinkSync')
    assert.equal(typeof index.fs.createWriteStream, 'function', 'index.fs.createWriteStream')
    assert.equal(typeof index.fs.default, 'object', 'index.fs.default')
    assert.equal(typeof index.fs.emptyDir, 'function', 'index.fs.emptyDir')
    assert.equal(typeof index.fs.emptyDirSync, 'function', 'index.fs.emptyDirSync')
    assert.equal(typeof index.fs.emptydir, 'function', 'index.fs.emptydir')
    assert.equal(typeof index.fs.emptydirSync, 'function', 'index.fs.emptydirSync')
    assert.equal(typeof index.fs.ensureDir, 'function', 'index.fs.ensureDir')
    assert.equal(typeof index.fs.ensureDirSync, 'function', 'index.fs.ensureDirSync')
    assert.equal(typeof index.fs.ensureFile, 'function', 'index.fs.ensureFile')
    assert.equal(typeof index.fs.ensureFileSync, 'function', 'index.fs.ensureFileSync')
    assert.equal(typeof index.fs.ensureLink, 'function', 'index.fs.ensureLink')
    assert.equal(typeof index.fs.ensureLinkSync, 'function', 'index.fs.ensureLinkSync')
    assert.equal(typeof index.fs.ensureSymlink, 'function', 'index.fs.ensureSymlink')
    assert.equal(typeof index.fs.ensureSymlinkSync, 'function', 'index.fs.ensureSymlinkSync')
    assert.equal(typeof index.fs.exists, 'function', 'index.fs.exists')
    assert.equal(typeof index.fs.existsSync, 'function', 'index.fs.existsSync')
    assert.equal(typeof index.fs.fchmod, 'function', 'index.fs.fchmod')
    assert.equal(typeof index.fs.fchmodSync, 'function', 'index.fs.fchmodSync')
    assert.equal(typeof index.fs.fchown, 'function', 'index.fs.fchown')
    assert.equal(typeof index.fs.fchownSync, 'function', 'index.fs.fchownSync')
    assert.equal(typeof index.fs.fdatasync, 'function', 'index.fs.fdatasync')
    assert.equal(typeof index.fs.fdatasyncSync, 'function', 'index.fs.fdatasyncSync')
    assert.equal(typeof index.fs.fstat, 'function', 'index.fs.fstat')
    assert.equal(typeof index.fs.fstatSync, 'function', 'index.fs.fstatSync')
    assert.equal(typeof index.fs.fsync, 'function', 'index.fs.fsync')
    assert.equal(typeof index.fs.fsyncSync, 'function', 'index.fs.fsyncSync')
    assert.equal(typeof index.fs.ftruncate, 'function', 'index.fs.ftruncate')
    assert.equal(typeof index.fs.ftruncateSync, 'function', 'index.fs.ftruncateSync')
    assert.equal(typeof index.fs.futimes, 'function', 'index.fs.futimes')
    assert.equal(typeof index.fs.futimesSync, 'function', 'index.fs.futimesSync')
    assert.equal(typeof index.fs.glob, 'function', 'index.fs.glob')
    assert.equal(typeof index.fs.globSync, 'function', 'index.fs.globSync')
    assert.equal(typeof index.fs.gracefulify, 'function', 'index.fs.gracefulify')
    assert.equal(typeof index.fs.lchmod, 'function', 'index.fs.lchmod')
    assert.equal(typeof index.fs.lchmodSync, 'function', 'index.fs.lchmodSync')
    assert.equal(typeof index.fs.lchown, 'function', 'index.fs.lchown')
    assert.equal(typeof index.fs.lchownSync, 'function', 'index.fs.lchownSync')
    assert.equal(typeof index.fs.link, 'function', 'index.fs.link')
    assert.equal(typeof index.fs.linkSync, 'function', 'index.fs.linkSync')
    assert.equal(typeof index.fs.lstat, 'function', 'index.fs.lstat')
    assert.equal(typeof index.fs.lstatSync, 'function', 'index.fs.lstatSync')
    assert.equal(typeof index.fs.lutimes, 'function', 'index.fs.lutimes')
    assert.equal(typeof index.fs.lutimesSync, 'function', 'index.fs.lutimesSync')
    assert.equal(typeof index.fs.mkdir, 'function', 'index.fs.mkdir')
    assert.equal(typeof index.fs.mkdirSync, 'function', 'index.fs.mkdirSync')
    assert.equal(typeof index.fs.mkdirp, 'function', 'index.fs.mkdirp')
    assert.equal(typeof index.fs.mkdirpSync, 'function', 'index.fs.mkdirpSync')
    assert.equal(typeof index.fs.mkdirs, 'function', 'index.fs.mkdirs')
    assert.equal(typeof index.fs.mkdirsSync, 'function', 'index.fs.mkdirsSync')
    assert.equal(typeof index.fs.mkdtemp, 'function', 'index.fs.mkdtemp')
    assert.equal(typeof index.fs.mkdtempSync, 'function', 'index.fs.mkdtempSync')
    assert.equal(typeof index.fs.move, 'function', 'index.fs.move')
    assert.equal(typeof index.fs.moveSync, 'function', 'index.fs.moveSync')
    assert.equal(typeof index.fs.open, 'function', 'index.fs.open')
    assert.equal(typeof index.fs.openAsBlob, 'function', 'index.fs.openAsBlob')
    assert.equal(typeof index.fs.openSync, 'function', 'index.fs.openSync')
    assert.equal(typeof index.fs.opendir, 'function', 'index.fs.opendir')
    assert.equal(typeof index.fs.opendirSync, 'function', 'index.fs.opendirSync')
    assert.equal(typeof index.fs.outputFile, 'function', 'index.fs.outputFile')
    assert.equal(typeof index.fs.outputFileSync, 'function', 'index.fs.outputFileSync')
    assert.equal(typeof index.fs.outputJSON, 'function', 'index.fs.outputJSON')
    assert.equal(typeof index.fs.outputJSONSync, 'function', 'index.fs.outputJSONSync')
    assert.equal(typeof index.fs.outputJson, 'function', 'index.fs.outputJson')
    assert.equal(typeof index.fs.outputJsonSync, 'function', 'index.fs.outputJsonSync')
    assert.equal(typeof index.fs.pathExists, 'function', 'index.fs.pathExists')
    assert.equal(typeof index.fs.pathExistsSync, 'function', 'index.fs.pathExistsSync')
    assert.equal(typeof index.fs.promises, 'object', 'index.fs.promises')
    assert.equal(typeof index.fs.read, 'function', 'index.fs.read')
    assert.equal(typeof index.fs.readFile, 'function', 'index.fs.readFile')
    assert.equal(typeof index.fs.readFileSync, 'function', 'index.fs.readFileSync')
    assert.equal(typeof index.fs.readJSON, 'function', 'index.fs.readJSON')
    assert.equal(typeof index.fs.readJSONSync, 'function', 'index.fs.readJSONSync')
    assert.equal(typeof index.fs.readJson, 'function', 'index.fs.readJson')
    assert.equal(typeof index.fs.readJsonSync, 'function', 'index.fs.readJsonSync')
    assert.equal(typeof index.fs.readSync, 'function', 'index.fs.readSync')
    assert.equal(typeof index.fs.readdir, 'function', 'index.fs.readdir')
    assert.equal(typeof index.fs.readdirSync, 'function', 'index.fs.readdirSync')
    assert.equal(typeof index.fs.readlink, 'function', 'index.fs.readlink')
    assert.equal(typeof index.fs.readlinkSync, 'function', 'index.fs.readlinkSync')
    assert.equal(typeof index.fs.readv, 'function', 'index.fs.readv')
    assert.equal(typeof index.fs.readvSync, 'function', 'index.fs.readvSync')
    assert.equal(typeof index.fs.realpath, 'function', 'index.fs.realpath')
    assert.equal(typeof index.fs.realpathSync, 'function', 'index.fs.realpathSync')
    assert.equal(typeof index.fs.remove, 'function', 'index.fs.remove')
    assert.equal(typeof index.fs.removeSync, 'function', 'index.fs.removeSync')
    assert.equal(typeof index.fs.rename, 'function', 'index.fs.rename')
    assert.equal(typeof index.fs.renameSync, 'function', 'index.fs.renameSync')
    assert.equal(typeof index.fs.rm, 'function', 'index.fs.rm')
    assert.equal(typeof index.fs.rmSync, 'function', 'index.fs.rmSync')
    assert.equal(typeof index.fs.rmdir, 'function', 'index.fs.rmdir')
    assert.equal(typeof index.fs.rmdirSync, 'function', 'index.fs.rmdirSync')
    assert.equal(typeof index.fs.stat, 'function', 'index.fs.stat')
    assert.equal(typeof index.fs.statSync, 'function', 'index.fs.statSync')
    assert.equal(typeof index.fs.statfs, 'function', 'index.fs.statfs')
    assert.equal(typeof index.fs.statfsSync, 'function', 'index.fs.statfsSync')
    assert.equal(typeof index.fs.symlink, 'function', 'index.fs.symlink')
    assert.equal(typeof index.fs.symlinkSync, 'function', 'index.fs.symlinkSync')
    assert.equal(typeof index.fs.truncate, 'function', 'index.fs.truncate')
    assert.equal(typeof index.fs.truncateSync, 'function', 'index.fs.truncateSync')
    assert.equal(typeof index.fs.unlink, 'function', 'index.fs.unlink')
    assert.equal(typeof index.fs.unlinkSync, 'function', 'index.fs.unlinkSync')
    assert.equal(typeof index.fs.unwatchFile, 'function', 'index.fs.unwatchFile')
    assert.equal(typeof index.fs.utimes, 'function', 'index.fs.utimes')
    assert.equal(typeof index.fs.utimesSync, 'function', 'index.fs.utimesSync')
    assert.equal(typeof index.fs.watch, 'function', 'index.fs.watch')
    assert.equal(typeof index.fs.watchFile, 'function', 'index.fs.watchFile')
    assert.equal(typeof index.fs.write, 'function', 'index.fs.write')
    assert.equal(typeof index.fs.writeFile, 'function', 'index.fs.writeFile')
    assert.equal(typeof index.fs.writeFileSync, 'function', 'index.fs.writeFileSync')
    assert.equal(typeof index.fs.writeJSON, 'function', 'index.fs.writeJSON')
    assert.equal(typeof index.fs.writeJSONSync, 'function', 'index.fs.writeJSONSync')
    assert.equal(typeof index.fs.writeJson, 'function', 'index.fs.writeJson')
    assert.equal(typeof index.fs.writeJsonSync, 'function', 'index.fs.writeJsonSync')
    assert.equal(typeof index.fs.writeSync, 'function', 'index.fs.writeSync')
    assert.equal(typeof index.fs.writev, 'function', 'index.fs.writev')
    assert.equal(typeof index.fs.writevSync, 'function', 'index.fs.writevSync')
    assert.equal(typeof index.glob, 'function', 'index.glob')
    assert.equal(typeof index.glob.convertPathToPattern, 'function', 'index.glob.convertPathToPattern')
    assert.equal(typeof index.glob.generateGlobTasks, 'function', 'index.glob.generateGlobTasks')
    assert.equal(typeof index.glob.generateGlobTasksSync, 'function', 'index.glob.generateGlobTasksSync')
    assert.equal(typeof index.glob.globby, 'function', 'index.glob.globby')
    assert.equal(typeof index.glob.globbyStream, 'function', 'index.glob.globbyStream')
    assert.equal(typeof index.glob.globbySync, 'function', 'index.glob.globbySync')
    assert.equal(typeof index.glob.isDynamicPattern, 'function', 'index.glob.isDynamicPattern')
    assert.equal(typeof index.glob.isGitIgnored, 'function', 'index.glob.isGitIgnored')
    assert.equal(typeof index.glob.isGitIgnoredSync, 'function', 'index.glob.isGitIgnoredSync')
    assert.equal(typeof index.glob.sync, 'function', 'index.glob.sync')
    assert.equal(typeof index.globby, 'function', 'index.globby')
    assert.equal(typeof index.globby.convertPathToPattern, 'function', 'index.globby.convertPathToPattern')
    assert.equal(typeof index.globby.generateGlobTasks, 'function', 'index.globby.generateGlobTasks')
    assert.equal(typeof index.globby.generateGlobTasksSync, 'function', 'index.globby.generateGlobTasksSync')
    assert.equal(typeof index.globby.globby, 'function', 'index.globby.globby')
    assert.equal(typeof index.globby.globbyStream, 'function', 'index.globby.globbyStream')
    assert.equal(typeof index.globby.globbySync, 'function', 'index.globby.globbySync')
    assert.equal(typeof index.globby.isDynamicPattern, 'function', 'index.globby.isDynamicPattern')
    assert.equal(typeof index.globby.isGitIgnored, 'function', 'index.globby.isGitIgnored')
    assert.equal(typeof index.globby.isGitIgnoredSync, 'function', 'index.globby.isGitIgnoredSync')
    assert.equal(typeof index.globby.sync, 'function', 'index.globby.sync')
    assert.equal(typeof index.kill, 'function', 'index.kill')
    assert.equal(typeof index.log, 'function', 'index.log')
    assert.equal(typeof index.minimist, 'function', 'index.minimist')
    assert.equal(typeof index.nothrow, 'function', 'index.nothrow')
    assert.equal(typeof index.os, 'object', 'index.os')
    assert.equal(typeof index.os.EOL, 'string', 'index.os.EOL')
    assert.equal(typeof index.os.arch, 'function', 'index.os.arch')
    assert.equal(typeof index.os.availableParallelism, 'function', 'index.os.availableParallelism')
    assert.equal(typeof index.os.constants, 'object', 'index.os.constants')
    assert.equal(typeof index.os.cpus, 'function', 'index.os.cpus')
    assert.equal(typeof index.os.default, 'object', 'index.os.default')
    assert.equal(typeof index.os.devNull, 'string', 'index.os.devNull')
    assert.equal(typeof index.os.endianness, 'function', 'index.os.endianness')
    assert.equal(typeof index.os.freemem, 'function', 'index.os.freemem')
    assert.equal(typeof index.os.getPriority, 'function', 'index.os.getPriority')
    assert.equal(typeof index.os.homedir, 'function', 'index.os.homedir')
    assert.equal(typeof index.os.hostname, 'function', 'index.os.hostname')
    assert.equal(typeof index.os.loadavg, 'function', 'index.os.loadavg')
    assert.equal(typeof index.os.machine, 'function', 'index.os.machine')
    assert.equal(typeof index.os.networkInterfaces, 'function', 'index.os.networkInterfaces')
    assert.equal(typeof index.os.platform, 'function', 'index.os.platform')
    assert.equal(typeof index.os.release, 'function', 'index.os.release')
    assert.equal(typeof index.os.setPriority, 'function', 'index.os.setPriority')
    assert.equal(typeof index.os.tmpdir, 'function', 'index.os.tmpdir')
    assert.equal(typeof index.os.totalmem, 'function', 'index.os.totalmem')
    assert.equal(typeof index.os.type, 'function', 'index.os.type')
    assert.equal(typeof index.os.uptime, 'function', 'index.os.uptime')
    assert.equal(typeof index.os.userInfo, 'function', 'index.os.userInfo')
    assert.equal(typeof index.os.version, 'function', 'index.os.version')
    assert.equal(typeof index.parseArgv, 'function', 'index.parseArgv')
    assert.equal(typeof index.path, 'object', 'index.path')
    assert.equal(typeof index.path._makeLong, 'function', 'index.path._makeLong')
    assert.equal(typeof index.path.basename, 'function', 'index.path.basename')
    assert.equal(typeof index.path.delimiter, 'string', 'index.path.delimiter')
    assert.equal(typeof index.path.dirname, 'function', 'index.path.dirname')
    assert.equal(typeof index.path.extname, 'function', 'index.path.extname')
    assert.equal(typeof index.path.format, 'function', 'index.path.format')
    assert.equal(typeof index.path.isAbsolute, 'function', 'index.path.isAbsolute')
    assert.equal(typeof index.path.join, 'function', 'index.path.join')
    assert.equal(typeof index.path.matchesGlob, 'function', 'index.path.matchesGlob')
    assert.equal(typeof index.path.normalize, 'function', 'index.path.normalize')
    assert.equal(typeof index.path.parse, 'function', 'index.path.parse')
    assert.equal(typeof index.path.posix, 'object', 'index.path.posix')
    assert.equal(typeof index.path.relative, 'function', 'index.path.relative')
    assert.equal(typeof index.path.resolve, 'function', 'index.path.resolve')
    assert.equal(typeof index.path.sep, 'string', 'index.path.sep')
    assert.equal(typeof index.path.toNamespacedPath, 'function', 'index.path.toNamespacedPath')
    assert.equal(typeof index.path.win32, 'object', 'index.path.win32')
    assert.equal(typeof index.ps, 'object', 'index.ps')
    assert.equal(typeof index.ps.kill, 'function', 'index.ps.kill')
    assert.equal(typeof index.ps.lookup, 'function', 'index.ps.lookup')
    assert.equal(typeof index.ps.lookupSync, 'function', 'index.ps.lookupSync')
    assert.equal(typeof index.ps.tree, 'function', 'index.ps.tree')
    assert.equal(typeof index.ps.treeSync, 'function', 'index.ps.treeSync')
    assert.equal(typeof index.question, 'function', 'index.question')
    assert.equal(typeof index.quiet, 'function', 'index.quiet')
    assert.equal(typeof index.quote, 'function', 'index.quote')
    assert.equal(typeof index.quotePowerShell, 'function', 'index.quotePowerShell')
    assert.equal(typeof index.resolveDefaults, 'function', 'index.resolveDefaults')
    assert.equal(typeof index.retry, 'function', 'index.retry')
    assert.equal(typeof index.sleep, 'function', 'index.sleep')
    assert.equal(typeof index.spinner, 'function', 'index.spinner')
    assert.equal(typeof index.stdin, 'function', 'index.stdin')
    assert.equal(typeof index.syncProcessCwd, 'function', 'index.syncProcessCwd')
    assert.equal(typeof index.tempdir, 'function', 'index.tempdir')
    assert.equal(typeof index.tempfile, 'function', 'index.tempfile')
    assert.equal(typeof index.tmpdir, 'function', 'index.tmpdir')
    assert.equal(typeof index.tmpfile, 'function', 'index.tmpfile')
    assert.equal(typeof index.updateArgv, 'function', 'index.updateArgv')
    assert.equal(typeof index.useBash, 'function', 'index.useBash')
    assert.equal(typeof index.usePowerShell, 'function', 'index.usePowerShell')
    assert.equal(typeof index.usePwsh, 'function', 'index.usePwsh')
    assert.equal(typeof index.version, 'string', 'index.version')
    assert.equal(typeof index.versions, 'object', 'index.versions')
    assert.equal(typeof index.versions.chalk, 'string', 'index.versions.chalk')
    assert.equal(typeof index.versions.depseek, 'string', 'index.versions.depseek')
    assert.equal(typeof index.versions.dotenv, 'string', 'index.versions.dotenv')
    assert.equal(typeof index.versions.fetch, 'string', 'index.versions.fetch')
    assert.equal(typeof index.versions.fs, 'string', 'index.versions.fs')
    assert.equal(typeof index.versions.glob, 'string', 'index.versions.glob')
    assert.equal(typeof index.versions.minimist, 'string', 'index.versions.minimist')
    assert.equal(typeof index.versions.ps, 'string', 'index.versions.ps')
    assert.equal(typeof index.versions.which, 'string', 'index.versions.which')
    assert.equal(typeof index.versions.yaml, 'string', 'index.versions.yaml')
    assert.equal(typeof index.versions.zx, 'string', 'index.versions.zx')
    assert.equal(typeof index.which, 'function', 'index.which')
    assert.equal(typeof index.which.sync, 'function', 'index.which.sync')
    assert.equal(typeof index.within, 'function', 'index.within')
  })
})



================================================
FILE: test/extra.test.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import { globby, fs, path } from '../build/index.js'

const __dirname = path.dirname(new URL(import.meta.url).pathname)

describe('extra', () => {
  test('every file should have a license', async () => {
    const copyright = await fs.readFile(
      path.resolve(__dirname, 'fixtures/copyright.txt'),
      'utf8'
    )
    const files = await globby(
      ['**/*.{js,mjs,ts}', '!**/*polyfill.js', '!build'],
      {
        gitignore: true,
        onlyFiles: true,
        cwd: process.cwd(),
        followSymbolicLinks: false,
      }
    )
    for (const file of files) {
      const content = await fs.readFile(file, 'utf8')
      assert(
        content.replace(/\d{4}/g, 'YEAR').includes(copyright),
        `No license header in ${file}.`
      )
    }
  })
})



================================================
FILE: test/global.test.js
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe, after } from 'node:test'
import '../build/globals.js'
import * as index from '../build/index.js'

describe('global', () => {
  after(() => {
    for (const key of Object.keys(index)) {
      delete global[key]
    }
  })

  test('global cd()', async () => {
    const cwd = (await $`pwd`).toString().trim()
    cd('/')
    assert.equal((await $`pwd`).toString().trim(), path.resolve('/'))
    cd(cwd)
    assert.equal((await $`pwd`).toString().trim(), cwd)
  })

  test('injects zx index to global', () => {
    for (const [key, value] of Object.entries(index)) {
      assert.equal(global[key], value)
    }
  })
})



================================================
FILE: test/goods.test.ts
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe, after } from 'node:test'
import { Duplex } from 'node:stream'
import { $, chalk, fs, path, dotenv } from '../src/index.ts'
import {
  echo,
  sleep,
  argv,
  parseArgv,
  updateArgv,
  stdin,
  spinner,
  fetch,
  retry,
  question,
  expBackoff,
  tempfile,
  tempdir,
  tmpdir,
  tmpfile,
  versions,
} from '../src/goods.ts'
import { Writable } from 'node:stream'
import process from 'node:process'

const __dirname = new URL('.', import.meta.url).pathname
const root = path.resolve(__dirname, '..')

describe('goods', () => {
  function zx(script) {
    return $`node build/cli.js --eval ${script}`.nothrow().timeout('5s')
  }

  describe('question()', async () => {
    test('works', async () => {
      let contents = ''
      class Input extends Duplex {
        constructor() {
          super()
        }
        _read() {}
        _write(chunk, encoding, callback) {
          this.push(chunk)
          callback()
        }
        _final() {
          this.push(null)
        }
      }
      const input = new Input() as any
      const output = new Writable({
        write: function (chunk, encoding, next) {
          contents += chunk.toString()
          next()
        },
      }) as NodeJS.WriteStream

      setTimeout(() => {
        input.write('foo\n')
        input.end()
      }, 10)
      const result = await question('foo or bar? ', {
        choices: ['foo', 'bar'],
        input,
        output,
      })

      assert.equal(result, 'foo')
      assert(contents.includes('foo or bar? '))
    })

    test('integration', async () => {
      const p = $`node build/cli.js --eval "
  let answer = await question('foo or bar? ', { choices: ['foo', 'bar'] })
  echo('Answer is', answer)
"`
      p.stdin.write('foo\n')
      p.stdin.end()
      assert.match((await p).stdout, /Answer is foo/)
    })
  })

  test('echo() works', async () => {
    const log = console.log
    let stdout = ''
    console.log = (...args) => {
      stdout += args.join(' ')
    }
    echo(chalk.cyan('foo'), chalk.green('bar'), chalk.bold('baz'))
    echo`${chalk.cyan('foo')} ${chalk.green('bar')} ${chalk.bold('baz')}`
    echo(
      await $`echo ${chalk.cyan('foo')}`,
      await $`echo ${chalk.green('bar')}`,
      await $`echo ${chalk.bold('baz')}`
    )
    console.log = log
    assert.match(stdout, /foo/)
  })

  test('sleep() works', async () => {
    const now = Date.now()
    await sleep(100)
    assert.ok(Date.now() >= now + 99)
  })

  describe('retry()', () => {
    test('works', async () => {
      let count = 0
      const result = await retry(5, () => {
        count++
        if (count < 5) throw new Error('fail')
        return 'success'
      })
      assert.equal(result, 'success')
      assert.equal(count, 5)
    })

    test('works with custom delay and limit', async () => {
      const now = Date.now()
      let count = 0
      try {
        await retry(3, '2ms', () => {
          count++
          throw new Error('fail')
        })
      } catch (e) {
        assert.match(e.message, /fail/)
        assert.ok(Date.now() >= now + 4)
        assert.equal(count, 3)
      }
    })

    test('throws undefined on count misconfiguration', async () => {
      try {
        await retry(0, () => 'ok')
      } catch (e) {
        assert.equal(e, undefined)
      }
    })

    test('throws err on empty callback', async () => {
      try {
        // @ts-ignore
        await retry(5)
      } catch (e) {
        assert.match(e.message, /Callback is required for retry/)
      }
    })

    test('supports expBackoff', async () => {
      const result = await retry(5, expBackoff('10ms'), () => {
        if (Math.random() < 0.1) throw new Error('fail')
        return 'success'
      })

      assert.equal(result, 'success')
    })

    test('integration', async () => {
      const now = Date.now()
      const p = await zx(`
    try {
      await retry(5, '50ms', () => $\`exit 123\`)
    } catch (e) {
      echo('exitCode:', e.exitCode)
    }
    await retry(5, () => $\`exit 0\`)
    echo('success')
`)
      assert.ok(p.toString().includes('exitCode: 123'))
      assert.ok(p.toString().includes('success'))
      assert.ok(Date.now() >= now + 50 * (5 - 1))
    })

    test('integration with expBackoff', async () => {
      const now = Date.now()
      const p = await zx(`
    try {
      await retry(5, expBackoff('60s', 0), () => $\`exit 123\`)
    } catch (e) {
      echo('exitCode:', e.exitCode)
    }
    echo('success')
`)
      assert.ok(p.toString().includes('exitCode: 123'))
      assert.ok(p.toString().includes('success'))
      assert.ok(Date.now() >= now + 2 + 4 + 8 + 16 + 32)
    })
  })

  test('expBackoff()', async () => {
    const g = expBackoff('10s', '100ms')

    const [a, b, c] = [
      g.next().value,
      g.next().value,
      g.next().value,
    ] as number[]

    assert.equal(a, 100)
    assert.equal(b, 200)
    assert.equal(c, 400)
  })

  describe('spinner()', () => {
    test('works', async () => {
      let contents = ''
      const { CI } = process.env
      const output = new Writable({
        write: function (chunk, encoding, next) {
          contents += chunk.toString()
          next()
        },
      })

      delete process.env.CI
      $.log.output = output as NodeJS.WriteStream

      const p = spinner(() => sleep(100))

      delete $.log.output
      process.env.CI = CI

      await p
      assert(contents.includes('⠋'))
    })

    describe('integration', () => {
      test('works', async () => {
        const out = await zx(
          `
    process.env.CI = ''
    echo(await spinner(async () => {
      await sleep(100)
      await $\`echo hidden\`
      return $\`echo result\`
    }))
  `
        )
        assert(out.stdout.includes('result'))
        assert(out.stderr.includes('⠋'))
        assert(!out.stderr.includes('result'))
        assert(!out.stderr.includes('hidden'))
      })

      test('with title', async () => {
        const out = await zx(
          `
    process.env.CI = ''
    await spinner('processing', () => sleep(100))
  `
        )
        assert.match(out.stderr, /processing/)
      })

      test('disabled in CI', async () => {
        const out = await zx(
          `
    process.env.CI = 'true'
    await spinner('processing', () => sleep(100))
  `
        )
        assert.doesNotMatch(out.stderr, /processing/)
      })

      test('stops on throw', async () => {
        const out = await zx(`
    await spinner('processing', () => $\`wtf-cmd\`)
  `)
        assert.match(out.stderr, /Error:/)
        assert(out.exitCode !== 0)
      })
    })
  })

  describe('args', () => {
    test('parseArgv() works', () => {
      assert.deepEqual(
        parseArgv(
          // prettier-ignore
          [
          '--foo-bar', 'baz',
          '-a', '5',
          '-a', '42',
          '--aaa', 'AAA',
          '--force',
          './some.file',
          '--b1', 'true',
          '--b2', 'false',
          '--b3',
          '--b4', 'false',
          '--b5', 'true',
          '--b6', 'str'
        ],
          {
            boolean: ['force', 'b3', 'b4', 'b5', 'b6'],
            camelCase: true,
            parseBoolean: true,
            alias: { a: 'aaa' },
          },
          {
            def: 'def',
          }
        ),
        {
          a: [5, 42, 'AAA'],
          aaa: [5, 42, 'AAA'],
          fooBar: 'baz',
          force: true,
          _: ['./some.file', 'str'],
          b1: true,
          b2: false,
          b3: true,
          b4: false,
          b5: true,
          b6: true,
          def: 'def',
        }
      )
    })

    test('updateArgv() works', () => {
      updateArgv(['--foo', 'bar'])
      assert.deepEqual(argv, {
        _: [],
        foo: 'bar',
      })
    })
  })

  test('stdin()', async () => {
    const stream = fs.createReadStream(path.resolve(root, 'package.json'))
    const input = await stdin(stream)
    assert.match(input, /"name": "zx"/)
  })

  test('fetch()', async () => {
    const req1 = fetch('https://example.com/')
    const req2 = fetch('https://example.com/')
    const req3 = fetch('https://example.com/', { method: 'OPTIONS' })

    const p1 = (await req1.pipe`cat`).stdout
    const p2 = (await req2.pipe($`cat`)).stdout
    const p3 = (await req3.pipe`cat`).stdout

    assert.equal((await req1).status, 200)
    assert.equal((await req2).status, 200)
    assert.equal((await req3).status, 501)
    assert(p1.includes('Example Domain'))
    assert(p2.includes('Example Domain'))
    assert(!p3.includes('Example Domain'))
  })

  describe('dotenv', () => {
    test('parse()', () => {
      assert.deepEqual(dotenv.parse(''), {})
      assert.deepEqual(
        dotenv.parse('ENV=v1\nENV2=v2\n\n\n  ENV3  =    v3   \nexport ENV4=v4'),
        {
          ENV: 'v1',
          ENV2: 'v2',
          ENV3: 'v3',
          ENV4: 'v4',
        }
      )

      const multiline = `SIMPLE=xyz123
# comment ###
NON_INTERPOLATED='raw text without variable interpolation' 
MULTILINE = """
long text here, # not-comment
e.g. a private SSH key
"""
ENV=v1\nENV2=v2\n\n\n\t\t  ENV3  =    v3   \n   export ENV4=v4
ENV5=v5 # comment
`
      assert.deepEqual(dotenv.parse(multiline), {
        SIMPLE: 'xyz123',
        NON_INTERPOLATED: 'raw text without variable interpolation',
        MULTILINE: 'long text here, # not-comment\ne.g. a private SSH key',
        ENV: 'v1',
        ENV2: 'v2',
        ENV3: 'v3',
        ENV4: 'v4',
        ENV5: 'v5',
      })
    })

    describe('load()', () => {
      const file1 = tempfile('.env.1', 'ENV1=value1\nENV2=value2')
      const file2 = tempfile('.env.2', 'ENV2=value222\nENV3=value3')
      after(() => Promise.all([fs.remove(file1), fs.remove(file2)]))

      test('loads env from files', () => {
        const env = dotenv.load(file1, file2)
        assert.equal(env.ENV1, 'value1')
        assert.equal(env.ENV2, 'value2')
        assert.equal(env.ENV3, 'value3')
      })

      test('throws error on ENOENT', () => {
        try {
          dotenv.load('./.env')
          throw new Error('unreachable')
        } catch (e) {
          assert.equal(e.code, 'ENOENT')
          assert.equal(e.errno, -2)
        }
      })
    })

    describe('loadSafe()', () => {
      const file1 = tempfile('.env.1', 'ENV1=value1\nENV2=value2')
      const file2 = '.env.notexists'

      after(() => fs.remove(file1))

      test('loads env from files', () => {
        const env = dotenv.loadSafe(file1, file2)
        assert.equal(env.ENV1, 'value1')
        assert.equal(env.ENV2, 'value2')
      })
    })

    describe('config()', () => {
      test('updates process.env', () => {
        const file1 = tempfile('.env.1', 'ENV1=value1')

        assert.equal(process.env.ENV1, undefined)
        dotenv.config(file1)
        assert.equal(process.env.ENV1, 'value1')
        delete process.env.ENV1
      })
    })
  })

  describe('temp*', () => {
    test('tempdir() creates temporary folders', () => {
      assert.equal(tmpdir, tempdir)
      assert.match(tempdir(), /\/zx-/)
      assert.match(tempdir('foo'), /\/foo$/)
    })

    test('tempfile() creates temporary files', () => {
      assert.equal(tmpfile, tempfile)
      assert.match(tempfile(), /\/zx-.+/)
      assert.match(tempfile('foo.txt'), /\/zx-.+\/foo\.txt$/)

      const tf = tempfile('bar.txt', 'bar')
      assert.match(tf, /\/zx-.+\/bar\.txt$/)
      assert.equal(fs.readFileSync(tf, 'utf-8'), 'bar')
    })
  })

  describe('versions', () => {
    test('exports deps versions', () => {
      assert.deepEqual(
        Object.keys(versions).sort(),
        [
          'chalk',
          'depseek',
          'dotenv',
          'fetch',
          'fs',
          'glob',
          'minimist',
          'ps',
          'which',
          'yaml',
          'zx',
        ].sort()
      )
    })
  })
})



================================================
FILE: test/index.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { describe, test } from 'node:test'
import {
  nothrow,
  quiet,
  versions,
  version,
  VERSION,
  $,
  log,
  cd,
  syncProcessCwd,
  usePowerShell,
  usePwsh,
  useBash,
  kill,
  ProcessOutput,
  ProcessPromise,
  defaults,
  dotenv,
  minimist,
  chalk,
  fs,
  which,
  YAML,
  ps,
  quote,
  quotePowerShell,
  within,
  os,
  argv,
  parseArgv,
  updateArgv,
  globby,
  glob,
  sleep,
  fetch,
  echo,
  question,
  stdin,
  retry,
  expBackoff,
  spinner,
  path,
  tempdir,
  tempfile,
  tmpdir,
  tmpfile,
} from '../build/index.js'

describe('index', () => {
  test('has proper exports', () => {
    // index
    assert(nothrow)
    assert(quiet)
    assert(version)
    assert(versions)
    assert.equal(version, VERSION)

    // core
    assert($)
    assert(ProcessOutput)
    assert(ProcessPromise)
    assert(cd)
    assert(syncProcessCwd)
    assert(log)
    assert(kill)
    assert(defaults)
    assert(within)
    assert(usePowerShell)
    assert(usePwsh)
    assert(useBash)

    // goods
    assert(os)
    assert(argv)
    assert(parseArgv)
    assert(updateArgv)
    assert(globby)
    assert(glob)
    assert(sleep)
    assert(fetch)
    assert(echo)
    assert(question)
    assert(stdin)
    assert(retry)
    assert(expBackoff)
    assert(spinner)
    assert(path)

    // vendor
    assert(minimist)
    assert(chalk)
    assert(fs)
    assert(which)
    assert(YAML)
    assert(ps)
    assert(dotenv)

    // utils
    assert(quote)
    assert(quotePowerShell)
    assert(tempdir)
    assert(tmpdir)
    assert(tmpfile)
    assert(tempfile)
  })
})



================================================
FILE: test/log.test.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe, beforeEach, before, after } from 'node:test'
import { formatCmd, log } from '../src/log.ts'

describe('log', () => {
  describe('log()', () => {
    const data = []
    const stream = {
      write(s: string) {
        data.push(s)
      },
    } as NodeJS.WriteStream

    before(() => (log.output = stream))

    after(() => {
      delete log.output
      delete log.formatters
    })

    beforeEach(() => (data.length = 0))

    test('empty log', () => {
      log({
        kind: 'cmd',
        cmd: 'echo hi',
        cwd: process.cwd(),
        id: '1',
        verbose: false,
      })
      assert.equal(data.join(''), '')
    })

    test('cmd', () => {
      log({
        kind: 'cmd',
        cmd: 'echo hi',
        cwd: process.cwd(),
        id: '1',
        verbose: true,
      })
      assert.equal(data.join(''), '$ \x1B[92mecho\x1B[39m hi\n')
    })

    test('stdout', () => {
      log({
        kind: 'stdout',
        data: Buffer.from('foo'),
        id: '1',
        verbose: true,
      })
      assert.equal(data.join(''), 'foo')
    })

    test('cd', () => {
      log({
        kind: 'cd',
        dir: '/tmp',
        verbose: true,
      })
      assert.equal(data.join(''), '$ \x1B[92mcd\x1B[39m /tmp\n')
    })

    test('fetch', () => {
      log({
        kind: 'fetch',
        url: 'https://example.com',
        init: { method: 'GET' },
        verbose: true,
      })
      assert.equal(
        data.join(''),
        "$ \x1B[92mfetch\x1B[39m https://example.com { method: 'GET' }\n"
      )
    })

    test('custom', () => {
      log({
        kind: 'custom',
        data: 'test',
        verbose: true,
      })
      assert.equal(data.join(''), 'test')
    })

    test('retry', () => {
      log({
        kind: 'retry',
        attempt: 1,
        total: 3,
        delay: 1000,
        exception: new Error('foo'),
        error: 'bar',
        verbose: true,
      })
      assert.equal(
        data.join(''),
        '\x1B[41m\x1B[37m FAIL \x1B[39m\x1B[49m Attempt: 1/3; next in 1000ms\n'
      )
    })

    test('end', () => {
      log({
        kind: 'end',
        id: '1',
        exitCode: null,
        signal: null,
        duration: 0,
        error: null,
        verbose: true,
      })
      assert.equal(data.join(''), '')
    })

    test('kill', () => {
      log({
        kind: 'kill',
        signal: null,
        pid: 1234,
      })
      assert.equal(data.join(''), '')
    })

    test('formatters', () => {
      log.formatters = {
        cmd: ({ cmd }) => `CMD: ${cmd}`,
      }

      log({
        kind: 'cmd',
        cmd: 'echo hi',
        cwd: process.cwd(),
        id: '1',
        verbose: true,
      })
      assert.equal(data.join(''), 'CMD: echo hi')
    })
  })

  test('formatCwd()', () => {
    const cases = [
      [
        `echo $'hi'`,
        "$ \x1B[92mecho\x1B[39m \x1B[93m$\x1B[39m\x1B[93m'hi'\x1B[39m\n",
      ],
      [`echo$foo`, '$ \x1B[92mecho\x1B[39m\x1B[93m$\x1B[39mfoo\n'],
      [
        `test --foo=bar p1 p2`,
        '$ \x1B[92mtest\x1B[39m --foo\x1B[31m=\x1B[39mbar p1 p2\n',
      ],
      [
        `cmd1 --foo || cmd2`,
        '$ \x1B[92mcmd1\x1B[39m --foo \x1B[31m|\x1B[39m\x1B[31m|\x1B[39m\x1B[92m cmd2\x1B[39m\n',
      ],
      [
        `A=B C='D' cmd`,
        "$ A\x1B[31m=\x1B[39mB C\x1B[31m=\x1B[39m\x1B[93m'D'\x1B[39m\x1B[92m cmd\x1B[39m\n",
      ],
      [
        `foo-extra --baz = b-a-z --bar = 'b-a-r' -q -u x`,
        "$ \x1B[92mfoo-extra\x1B[39m --baz \x1B[31m=\x1B[39m b-a-z --bar \x1B[31m=\x1B[39m \x1B[93m'b-a-r'\x1B[39m -q -u x\n",
      ],
      [
        `while true; do "$" done`,
        '$ \x1B[96mwhile\x1B[39m true\x1B[31m;\x1B[39m\x1B[96m do\x1B[39m \x1B[93m"$"\x1B[39m\x1B[96m done\x1B[39m\n',
      ],
      [
        `echo '\n str\n'`,
        "$ \x1B[92mecho\x1B[39m \x1B[93m'\x1B[39m\x1B[0m\x1B[0m\n\x1B[0m> \x1B[0m\x1B[93m str\x1B[39m\x1B[0m\x1B[0m\n\x1B[0m> \x1B[0m\x1B[93m'\x1B[39m\n",
      ],
      [`$'\\''`, "$ \x1B[93m$\x1B[39m\x1B[93m'\\'\x1B[39m\x1B[93m'\x1B[39m\n"],
      [
        'sass-compiler --style=compressed src/static/bootstrap.scss > dist/static/bootstrap-v5.3.3.min.css',
        '$ \x1B[92msass-compiler\x1B[39m --style\x1B[31m=\x1B[39mcompressed src/static/bootstrap.scss \x1B[31m>\x1B[39m\x1B[92m dist/static/bootstrap-v5.3.3.min.css\x1B[39m\n',
      ],
      [
        'echo 1+2 | bc',
        '$ \x1B[92mecho\x1B[39m 1\x1B[31m+\x1B[39m2 \x1B[31m|\x1B[39m\x1B[92m bc\x1B[39m\n',
      ],
      [
        'echo test &>> filepath',
        '$ \x1B[92mecho\x1B[39m test \x1B[31m&\x1B[39m\x1B[31m>\x1B[39m\x1B[31m>\x1B[39m\x1B[92m filepath\x1B[39m\n',
      ],
      [
        'bc < filepath',
        '$ \x1B[92mbc\x1B[39m \x1B[31m<\x1B[39m\x1B[92m filepath\x1B[39m\n',
      ],
      [
        `cat << 'EOF' | tee -a filepath
line 1
line 2
EOF`,
        "$ \x1B[92mcat\x1B[39m \x1B[31m<\x1B[39m\x1B[31m<\x1B[39m \x1B[93m'EOF'\x1B[39m \x1B[31m|\x1B[39m\x1B[92m tee\x1B[39m -a filepath\x1B[0m\x1B[0m\n\x1B[0m> \x1B[0mline 1\x1B[0m\x1B[0m\n\x1B[0m> \x1B[0mline 2\x1B[96m\x1B[39m\x1B[0m\x1B[0m\n\x1B[0m> \x1B[0m\x1B[96mEOF\x1B[39m\n",
      ],
    ]

    cases.forEach(([input, expected]) => {
      assert.equal(formatCmd(input), expected, input)
    })
  })
})



================================================
FILE: test/md.test.ts
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { test, describe } from 'node:test'
import assert from 'node:assert'
import { transformMarkdown } from '../src/md.ts'

describe('md', () => {
  test('transformMarkdown()', () => {
    assert.equal(transformMarkdown('\n'), '// \n// ')
    assert.equal(transformMarkdown('  \n    '), '  \n    ')
    assert.equal(
      transformMarkdown(`
\t~~~js
console.log('js')`),
      `// \n\t~~~js\n// console.log('js')`
    )
    // prettier-ignore
    assert.equal(transformMarkdown(`
# Title
    
~~~js
await $\`echo "js"\`
~~~

typescript code block
~~~~~ts
await $\`echo "ts"\`
~~~~~

~~~
unknown code block
~~~

~~~sh
echo foo
~~~

`), `// 
// # Title
//     

await $\`echo "js"\`

// 
// typescript code block

await $\`echo "ts"\`

// 

// unknown code block

// 
await $\`
echo foo
\`
// 
// `)
  })
})



================================================
FILE: test/package.test.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import { $, within, path, glob, tempdir, fs } from '../build/index.js'

const __dirname = new URL('.', import.meta.url).pathname
const root = path.resolve(__dirname, '..')

describe('package', () => {
  describe('work mode', () => {
    test('ts', async () => {
      const out = await within(async () => {
        $.cwd = path.resolve(root, 'test/fixtures/ts-project')
        await $`npm i --no-package-lock`
        try {
          await $`npx tsc`
        } catch (err) {
          throw new Error(err.stdout)
        }
        return $`node build/script.js`
      })
      assert.match(out.stderr, /ts-script/)
    })

    test('js', async () => {
      const out = await within(async () => {
        $.cwd = path.resolve(root, 'test/fixtures/js-project')
        await $`npm i --no-package-lock`
        return $`node node_modules/zx/build/cli.js --verbose script.js`
      })
      assert.match(out.stderr, /js-script/)
    })
  })

  describe('contents', () => {
    test('zx full', async () =>
      within(async () => {
        const tmp = tempdir()
        $.cwd = tmp
        $.quiet = true

        // link
        await $`ln -s ${path.resolve(root, 'node_modules')} ${path.resolve(tmp, 'node_modules')}`
        for (const entry of [
          'scripts',
          'build',
          'man',
          'package.json',
          'README.md',
          'LICENSE',
        ]) {
          await fs.copy(path.resolve(root, entry), path.join(tmp, entry))
        }

        // pack / unpack
        await $`node scripts/prepublish-clean.mjs`
        const pack = await $`npm pack`
        await $`tar xf ${pack}`
        await $`rm ${pack}`.nothrow()

        // run
        const { stderr } =
          await $`node -e 'import {$} from "./package/build/core.js"; $.verbose = true; await $\`echo hello\`'`
        assert.match(stderr, /hello/)

        // contents
        const files = await glob('**/*', {
          cwd: path.resolve(tmp, 'package'),
          absolute: false,
          onlyFiles: true,
        })
        assert.deepEqual(
          files.sort(),
          [
            'LICENSE',
            'README.md',
            'package.json',
            'man/zx.1',
            'build/cli.cjs',
            'build/cli.d.ts',
            'build/cli.js',
            'build/core.cjs',
            'build/core.d.ts',
            'build/core.js',
            'build/deno.js',
            'build/deps.cjs',
            'build/deps.d.ts',
            'build/error.d.ts',
            'build/esblib.cjs',
            'build/globals.cjs',
            'build/globals.d.ts',
            'build/globals.js',
            'build/goods.d.ts',
            'build/index.cjs',
            'build/index.d.ts',
            'build/index.js',
            'build/internals.cjs',
            'build/log.d.ts',
            'build/md.d.ts',
            'build/util.cjs',
            'build/util.d.ts',
            'build/versions.d.ts',
            'build/vendor-core.cjs',
            'build/vendor-core.d.ts',
            'build/vendor-extra.cjs',
            'build/vendor-extra.d.ts',
            'build/vendor.cjs',
            'build/vendor.d.ts',
            'build/3rd-party-licenses',
          ].sort()
        )
      }))

    test('zx@lite', async () =>
      within(async () => {
        const tmp = tempdir()
        $.cwd = tmp
        $.quiet = true

        // link
        await $`ln -s ${path.resolve(root, 'node_modules')} ${path.resolve(tmp, 'node_modules')}`
        for (const entry of [
          'build',
          'package.json',
          'README.md',
          'LICENSE',
          'scripts',
        ]) {
          await fs.copy(path.resolve(root, entry), path.join(tmp, entry))
        }

        // prepare package.json for lite
        await $`node scripts/prepublish-lite.mjs`
        await $`node scripts/prepublish-clean.mjs`

        // pack / unpack
        const pack = await $`npm pack`
        await $`tar xf ${pack}`
        await $`rm ${pack}`.nothrow()

        // run
        const { stderr } =
          await $`node -e 'import {$} from "./package/build/core.js"; $.verbose = true; await $\`echo hello\`'`
        assert.match(stderr, /hello/)

        // contents
        const files = await glob('**/*', {
          cwd: path.resolve(tmp, 'package'),
          absolute: false,
          onlyFiles: true,
        })
        assert.deepEqual(
          files.sort(),
          [
            'LICENSE',
            'README.md',
            'build/3rd-party-licenses',
            'build/cli.js',
            'build/core.cjs',
            'build/core.d.ts',
            'build/core.js',
            'build/deno.js',
            'build/error.d.ts',
            'build/esblib.cjs',
            'build/internals.cjs',
            'build/log.d.ts',
            'build/util.cjs',
            'build/util.d.ts',
            'build/vendor-core.cjs',
            'build/vendor-core.d.ts',
            'package.json',
          ].sort()
        )
      }))
  })
})



================================================
FILE: test/util.test.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import {
  isString,
  isStringLiteral,
  identity,
  once,
  noop,
  parseDuration,
  parseBool,
  quote,
  quotePowerShell,
  randomId,
  // normalizeMultilinePieces,
  preferLocalBin,
  toCamelCase,
  getLast,
} from '../build/util.cjs'

describe('util', () => {
  test('randomId()', () => {
    assert.ok(/^[a-z0-9]+$/.test(randomId()))
    assert.ok(
      new Set(Array.from({ length: 1000 }).map(() => randomId())).size === 1000
    )
  })

  test('noop()', () => {
    assert.ok(noop() === undefined)
  })

  test('once()', () => {
    const fn = once(identity)
    assert.equal(identity(1), 1)
    assert.equal(identity(2), 2)
    assert.equal(fn(1), 1)
    assert.equal(fn(2), 1)
  })

  test('isString()', () => {
    assert.ok(isString('string'))
    assert.ok(!isString(1))
  })

  test('isStringLiteral()', () => {
    const bar = 'baz'
    assert.ok(isStringLiteral``)
    assert.ok(isStringLiteral`foo`)
    assert.ok(isStringLiteral`foo ${bar}`)

    assert.ok(!isStringLiteral(''))
    assert.ok(!isStringLiteral('foo'))
    assert.ok(!isStringLiteral(['foo']))
  })

  test('quote()', () => {
    assert.ok(quote('string') === 'string')
    assert.ok(quote('') === `$''`)
    assert.ok(quote(`'\f\n\r\t\v\0`) === `$'\\'\\f\\n\\r\\t\\v\\0'`)
  })

  test('quotePowerShell()', () => {
    assert.equal(quotePowerShell('string'), 'string')
    assert.equal(quotePowerShell(`'`), `''''`)
    assert.equal(quotePowerShell(''), `''`)
  })

  test('duration parsing works', () => {
    assert.equal(parseDuration(0), 0)
    assert.equal(parseDuration(1000), 1000)
    assert.equal(parseDuration('100'), 100)
    assert.equal(parseDuration('2s'), 2000)
    assert.equal(parseDuration('500ms'), 500)
    assert.equal(parseDuration('2m'), 120000)
    assert.throws(() => parseDuration('f2ms'))
    assert.throws(() => parseDuration('2mss'))
    assert.throws(() => parseDuration(NaN))
    assert.throws(() => parseDuration(-1))
  })

  // test('normalizeMultilinePieces()', () => {
  //   assert.equal(
  //     normalizeMultilinePieces([' a ', 'b    c    d', ' e']).join(','),
  //     ' a ,b c d, e'
  //   )
  // })

  test('preferLocalBin()', () => {
    const env = {
      PATH: '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/sbin',
    }
    const _env = preferLocalBin(env, process.cwd())
    assert.equal(
      _env.PATH,
      `${process.cwd()}/node_modules/.bin:${process.cwd()}:${env.PATH}`
    )
  })

  test('toCamelCase()', () => {
    assert.equal(toCamelCase('VERBOSE'), 'verbose')
    assert.equal(toCamelCase('PREFER_LOCAL'), 'preferLocal')
    assert.equal(toCamelCase('SOME_MORE_BIG_STR'), 'someMoreBigStr')
    assert.equal(toCamelCase('kebab-input-str'), 'kebabInputStr')
  })

  test('parseBool()', () => {
    assert.equal(parseBool('true'), true)
    assert.equal(parseBool('false'), false)
    assert.equal(parseBool('other'), 'other')
  })

  test('getLast()', () => {
    assert.equal(getLast([1, 2, 3]), 3)
    assert.equal(getLast([]), undefined)
  })
})



================================================
FILE: test/vendor.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import {
  YAML,
  minimist,
  which,
  glob,
  nodeFetch as fetch,
} from '../build/vendor.cjs'

describe('vendor API', () => {
  test('YAML.parse', () => {
    assert.deepEqual(YAML.parse('a: b\n'), { a: 'b' })
  })

  test('YAML.stringify', () => {
    assert.equal(YAML.stringify({ a: 'b' }), 'a: b\n')
  })

  test('globby() works', async () => {
    assert.deepEqual(await glob('*.md'), ['README.md'])
    assert.deepEqual(glob.sync('*.md'), ['README.md'])
  })

  test('fetch() works', async () => {
    assert.match(
      await fetch('https://example.com').then((res) => res.text()),
      /Example Domain/
    )
  })

  test('which() available', async () => {
    assert.equal(which.sync('npm'), await which('npm'))
    assert.throws(() => which.sync('not-found-cmd'), /not-found-cmd/)
  })

  test('minimist available', async () => {
    assert.equal(typeof minimist, 'function')
  })

  test('minimist works', async () => {
    assert.deepEqual(
      minimist(
        ['--foo', 'bar', '-a', '5', '-a', '42', '--force', './some.file'],
        { boolean: 'force' }
      ),
      {
        a: [5, 42],
        foo: 'bar',
        force: true,
        _: ['./some.file'],
      }
    )
  })
})



================================================
FILE: test/bench/buf-join.mjs
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import cronometro from 'cronometro'

const STR = 'a'.repeat(1024)
const BUF = Buffer.from(STR)
const BUF_ARR = new Array(128).fill(null).map(() => Buffer.from(STR))
const STR_ARR = new Array(128).fill(STR)

const decoder = new TextDecoder()
cronometro({
  buf_arr_map_decode_join() {
    BUF_ARR.map(decoder.decode.bind(decoder)).join('')
  },
  buf_arr_reduce_decode() {
    BUF_ARR.reduce((acc, buf) => acc + decoder.decode(buf), '')
  },
  buf_arr_reduce_to_string() {
    BUF_ARR.reduce((acc, buf) => acc + buf.toString('utf8'), '')
  },
  buf_arr_for_decode() {
    let res = ''
    for (const buf of BUF_ARR) {
      res += decoder.decode(buf)
    }
  },
  buf_arr_while_decode() {
    let res = ''
    let i = 0
    const bl = BUF_ARR.length
    while (i < bl) {
      res += decoder.decode(BUF_ARR[i])
      i++
    }
  },
  buf_arr_join() {
    BUF_ARR.join('')
  },
  buf_arr_concat_decode() {
    decoder.decode(Buffer.concat(BUF_ARR))
  },
  str_arr_join() {
    STR_ARR.join('')
  },
  str_arr_reduce() {
    STR_ARR.reduce((acc, buf) => acc + buf, '')
  },
})



================================================
FILE: test/fixtures/argv.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import 'zx/globals'
import { argv as importedArgv } from 'zx'
console.log('global', JSON.stringify(argv))
console.log('imported', JSON.stringify(importedArgv))



================================================
FILE: test/fixtures/copyright.txt
================================================
// Copyright YEAR Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



================================================
FILE: test/fixtures/echo.http
================================================
HTTP/1.1 200 OK
Content-Type: text/javascript; charset=UTF-8
Content-Length: 15
Server: netcat!

$`echo 'test'`



================================================
FILE: test/fixtures/exit-code.mjs
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

process.exitCode = 42



================================================
FILE: test/fixtures/filename-dirname.mjs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { strict } from 'assert'

strict.equal(path.basename(__filename), 'filename-dirname.mjs')
strict.equal(path.basename(__dirname), 'fixtures')



================================================
FILE: test/fixtures/interactive.mjs
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const out = fs.createWriteStream('log.txt') // Record program output to this file.

process.stdin.pipe(out) // Record user input as well.
await $`npm init`.pipe(out) // Process will be interactive.



================================================
FILE: test/fixtures/markdown-crlf.md
================================================
```js
echo`Hello, world!`
```


================================================
FILE: test/fixtures/markdown.md
================================================
# Markdown

ignore

>
> ```
> echo ignore
> ```

```js
await $`whoami`
await $`echo ${__dirname}`
```

~~~js
await $`echo "tilde"`
~~~

```js
console.log(chalk.yellowBright(__filename))
```

```js
await import('chalk')
```

```bash
VAR=$(echo hello)
echo "$VAR"
```

    // ignore
    console.log('world')

Other code blocks are ignored:

```css
.ignore {}
```



================================================
FILE: test/fixtures/md.http
================================================
HTTP/1.1 200 OK
Content-Type: plain/text; charset=UTF-8
Content-Length: 15
Server: netcat!

# Title
```js
$`echo 'md'`
```



================================================
FILE: test/fixtures/no-extension
================================================
#!/usr/bin/env zx

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

console.log(chalk.yellowBright`If file has no extension, zx assumes it's ESM.`)
await $`pwd`
console.log('__filename =', __filename)
console.log('__dirname  =', __dirname)



================================================
FILE: test/fixtures/no-extension.mjs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Test file to verify no-extension didn't overwrite similarly name .mjs file.



================================================
FILE: test/fixtures/non-std-ext.zx
================================================
#!/usr/bin/env zx

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

console.log(chalk.yellowBright`If file has non-std ext and 'ext-override' option specified, zx assumes it's ESM.`)
await $`pwd`
console.log('__filename =', __filename)



================================================
FILE: test/fixtures/require.mjs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { strict as assert } from 'assert'
const data = require('../../package.json')
assert.equal(data.name, 'zx')
assert.equal(data, require('zx/package.json'))



================================================
FILE: test/fixtures/server.mjs
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import net from 'node:net'

export const fakeServer = (data = []) => {
  const server = net.createServer()
  server.on('connection', (conn) => {
    conn.on('data', () => {
      const d = data.shift() || 'pong'
      const _d = typeof d === 'string' ? d.replace(/\r?\n/gm, '\r\n') : d
      conn.write(_d)
    })
  })
  server.stop = () => new Promise((resolve) => server.close(() => resolve()))
  server.start = async (port) => {
    const p = port || (await (await import('get-port')).getPort())
    server.url = `http://127.0.0.1:${p}`
    return new Promise((resolve) => server.listen(p, () => resolve(server)))
  }

  return server
}



================================================
FILE: test/fixtures/js-project/package.json
================================================
{
  "private": true,
  "type": "module",
  "dependencies": {
    "zx": "file:../../.."
  }
}



================================================
FILE: test/fixtures/js-project/script.js
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

$`echo js-script`



================================================
FILE: test/fixtures/ts-project/package.json
================================================
{
  "private": true,
  "type": "module",
  "dependencies": {
    "typescript": "^5.0.0",
    "zx": "file:../../.."
  }
}



================================================
FILE: test/fixtures/ts-project/script.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { $, ProcessPromise } from 'zx'

const p: ProcessPromise = $({ verbose: true })`echo ts-script`
await p



================================================
FILE: test/fixtures/ts-project/tsconfig.json
================================================
{
  "compilerOptions": {
    "outDir": "./build",
    "target": "es2021",
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["*.ts"]
}



================================================
FILE: test/it/build-dcr.test.js
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { $ } from '../../build/index.js'
import { describe, test } from 'node:test'
import assert from 'node:assert'

describe('docker container', () => {
  test('works', async () => {
    const hello = await $({
      input: 'await $({verbose: true})`echo hello`',
    })`docker run -i zx`
    assert.equal(hello.stderr, '$ echo hello\nhello\n')

    const node = await $({
      input: 'console.log((await $`node -v`).valueOf())',
    })`docker run -i zx`
    assert.match(node.stdout, /^v24\./)
  })
})



================================================
FILE: test/it/build-jsr.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { tempdir, $, path, fs } from '../../build/index.js'
import { describe, before, after, it } from 'node:test'

const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '../../')

describe('jsr artifact', () => {
  let tmp
  let t$

  before(async () => {
    tmp = tempdir()
    t$ = $({ cwd: tmp, quiet: true })

    // copy all for jsr publish
    await Promise.all(
      [
        'src/',
        'tsconfig.json',
        'LICENSE',
        'README.md',
        'scripts/build-jsr.mjs',
        'package.json',
      ].map((filepath) =>
        fs.copy(
          path.resolve(path.join(root, filepath)),
          path.resolve(path.join(tmp, filepath))
        )
      )
    )
    await t$`ln -s ${path.resolve(root, 'node_modules')} ${path.resolve(tmp, 'node_modules')}`
  })
  after(() => fs.remove(tmp))

  it('publish --dry-run`', async () => {
    await t$`node scripts/build-jsr.mjs`
    await t$({ quiet: false })`jsr publish --dry-run`
  })
})



================================================
FILE: test/it/build-npm.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { tempdir, $, path, fs, version } from '../../build/index.js'
import assert from 'node:assert'
import { describe, before, after, it } from 'node:test'

const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '../../')

describe('npm artifact', () => {
  let tmp
  let zxdir
  let t$

  const pkgJson = {
    name: 'zx-test',
    dependencies: {
      typescript: '^5',
      esbuild: '^0.25.8',
      '@types/node': '*',
      '@types/fs-extra': '*',
    },
  }

  before(async () => {
    tmp = tempdir()
    t$ = $({ cwd: tmp, quiet: true })
    zxdir = path.resolve(tmp, 'node_modules/zx')

    await fs.outputJSON(path.resolve(tmp, 'package.json'), pkgJson)
    await t$`npm i`
    // `file:<path>` dep mounts `node_modules` too, so we use cloning here
    await fs.copy(
      path.resolve(root, 'package.json'),
      path.resolve(zxdir, 'package.json')
    )
    await fs.copy(path.resolve(root, 'build'), path.resolve(zxdir, 'build'))
  })

  after(() => fs.remove(tmp))

  it('buildable with tsc', async () => {
    const tsconfig = {
      compilerOptions: {
        module: 'commonjs',
        target: 'esnext',
        outDir: 'bundle',
        rootDir: 'src',
        declaration: true,
        declarationMap: false,
        esModuleInterop: true,
      },
      include: ['src'],
    }
    const indexTs = `import {$} from 'zx'
(async () => {
  await $({verbose: true})\`echo hello\`
})()
`
    await fs.outputJSON(path.resolve(tmp, 'tsconfig.json'), tsconfig)
    await fs.outputFile(path.resolve(tmp, 'src/index.ts'), indexTs)

    await t$`tsc`
    const out = await t$`node bundle/index.js`.text()
    assert.strictEqual(out, '$ echo hello\nhello\n')
  })

  it('compilable with esbuild (iife)', async () => {
    const verJs = `import {version, $} from 'zx'
(async () => {
  await $({verbose: true})\`echo \${version}\`
})()
`
    await fs.outputFile(path.resolve(tmp, 'src/ver.js'), verJs)

    await t$`npx esbuild src/ver.js --bundle --format=iife --platform=node > bundle/ver.js`
    const out = await t$`node bundle/ver.js`.text()
    assert.strictEqual(out, `$ echo ${version}\n${version}\n`)
  })
})



================================================
FILE: test/it/clean-package-json.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { tempdir, $, path, fs } from '../../build/index.js'
import { describe, before, after, it } from 'node:test'

const __dirname = path.dirname(new URL(import.meta.url).pathname)
const root = path.resolve(__dirname, '../../')

describe('package.json artifact', () => {
  let tmp
  let t$

  before(async () => {
    tmp = tempdir()
    t$ = $({ cwd: tmp, quiet: true })

    await fs.copy(
      path.resolve(root, 'package.json'),
      path.resolve(tmp, 'package.json')
    )
    await fs.copy(
      path.resolve(root, 'scripts/clean-package-json.mjs'),
      path.resolve(tmp, 'scripts/clean-package-json.mjs')
    )
  })

  after(() => fs.remove(tmp))

  it('handle exist properties required for publishing', async () => {
    await t$`node scripts/clean-package-json.mjs`
    // to throw if manifest is not correct
    const pkgJson = JSON.parse(
      fs.readFileSync(path.resolve(tmp, 'package.json'))
    )

    assert.equal(pkgJson.name, 'zx')
    assert.equal(pkgJson.description, 'A tool for writing better scripts')
    assert.equal(pkgJson.prettier, undefined)
    assert.equal(pkgJson.scripts, undefined)
    assert.equal(pkgJson.volta, undefined)
  })
})



================================================
FILE: test/smoke/bun.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'bun:test'
import { $, within, tmpdir } from '../../build/index.js'
import '../../build/cli.js'

describe('bun', () => {
  test('smoke test', async () => {
    const p = await $`echo foo`
    assert.match(p.stdout, /foo/)
  })

  test('captures err stack', async () => {
    const p = await $({ nothrow: true })`echo foo; exit 3`
    assert.match(p.message, /exit code: 3/)
  })

  test('stdio: inherit', async () => {
    await $({ stdio: 'inherit' })`ls`
  })

  test('ctx isolation', async () => {
    await within(async () => {
      const t1 = tmpdir()
      const t3 = tmpdir()
      $.cwd = t1
      assert.equal($.cwd, t1)
      assert.equal($.cwd, t1)

      const w = within(async () => {
        const t3 = tmpdir()
        $.cwd = t3
        assert.equal($.cwd, t3)

        assert.ok((await $`pwd`).toString().trim().endsWith(t3))
        assert.equal($.cwd, t3)
      })

      await $`pwd`
      assert.ok((await $`pwd`).toString().trim().endsWith(t1))
      assert.equal($.cwd, t1)
      assert.ok((await $`pwd`).toString().trim().endsWith(t1))

      $.cwd = t3
      assert.ok((await $`pwd`).toString().trim().endsWith(t3))
      assert.equal($.cwd, t3)

      await w
    })
  })
})



================================================
FILE: test/smoke/deno.test.js
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { assert } from 'https://deno.land/std@0.224.0/assert/assert.ts'
import { $ } from '../../build/index.js'
import '../../build/cli.js'

Deno.test('deno smoke test', async () => {
  // smoke test
  {
    const p = await $`echo foo`
    assert(p.valueOf() === 'foo')
  }

  // captures err stack
  {
    const p = await $({ nothrow: true })`echo foo; exit 3`
    assert(p.message.match(/exit code: 3/))
  }
})



================================================
FILE: test/smoke/node.test.cjs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const assert = require('assert')
require('zx/globals')
;(async () => {
  // smoke test
  {
    const p = await $`echo foo`
    assert.match(p.stdout, /foo/)
  }

  // captures err stack
  {
    const p = await $({ nothrow: true })`echo foo; exit 3`
    assert.match(p.message, /exit code: 3/)
  }

  console.log('smoke cjs: ok')
})()



================================================
FILE: test/smoke/node.test.mjs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'assert'
import 'zx/globals'
;(async () => {
  // smoke test
  {
    const p = await $`echo foo`
    assert.match(p.stdout, /foo/)
    assert.deepEqual(p.lines(), ['foo'])
  }

  // captures err stack
  {
    const p = await $({ nothrow: true })`echo foo; exit 3`
    assert.match(p.message, /exit code: 3/)
  }

  // ctx isolation
  {
    await within(async () => {
      const t1 = tmpdir()
      const t3 = tmpdir()
      $.cwd = t1
      assert.equal($.cwd, t1)
      assert.equal($.cwd, t1)

      const w = within(async () => {
        const t3 = tmpdir()
        $.cwd = t3
        assert.equal($.cwd, t3)

        assert.ok((await $`pwd`).toString().trim().endsWith(t3))
        assert.equal($.cwd, t3)
      })

      await $`pwd`
      assert.ok((await $`pwd`).toString().trim().endsWith(t1))
      assert.equal($.cwd, t1)
      assert.ok((await $`pwd`).toString().trim().endsWith(t1))

      $.cwd = t3
      assert.ok((await $`pwd`).toString().trim().endsWith(t3))
      assert.equal($.cwd, t3)

      await w
    })
  }

  // ps works fine
  {
    const [root] = await ps.lookup({ pid: process.pid })
    assert.equal(root.pid, process.pid)
  }

  // abort controller
  {
    const ac = new AbortController()
    const { signal } = ac
    const p = $({
      signal,
      timeout: '5s',
      nothrow: true,
      killSignal: 'SIGKILL',
    })`sleep 10`

    setTimeout(async () => {
      assert.throws(
        () => p.abort('SIGINT'),
        /signal is controlled by another process/
      )
      setTimeout(() => {
        ac.abort('stop')
      }, 500)
    }, 500)

    const o = await p
    assert.equal(o.signal, 'SIGTERM')
    assert.throws(() => p.kill(), /Too late to kill the process/)
  }

  // fetch()
  {
    const server = (await import('../fixtures/server.mjs')).fakeServer([
      `HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 13
Server: netcat!

{"foo":"bar"}
`,
    ])

    const { url } = await server.start(8081)
    const res = await fetch(url)
    const json = await res.json()
    assert.equal(res.status, 200)
    assert.equal(json.foo, 'bar')

    await server.stop()
  }

  console.log('smoke mjs: ok')
})()



================================================
FILE: test/smoke/ts.test.ts
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as assert from 'node:assert'
import 'zx/globals'
;(async () => {
  // smoke test async
  {
    const p = await $`echo foo`
    assert.match(p.stdout, /foo/)
  }

  // smoke test sync
  {
    const p = $.sync`echo foo`
    assert.match(p.stdout, /foo/)
  }

  // captures err stack
  {
    const p = await $({ nothrow: true })`echo foo; exit 3`
    assert.match(p.message, /exit code: 3/)
  }
})()

console.log('smoke ts: ok')



================================================
FILE: test/smoke/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2021",
    "lib": ["ES2021"],
    "moduleResolution": "NodeNext",
    "module": "NodeNext",
    "strict": true,
    "outDir": "./build",
    "declaration": true,
    "emitDeclarationOnly": true,
    "types": []
  },
  "include": ["./src/**/*"],
  "exclude": ["./src/globals.ts"]
}



================================================
FILE: test/smoke/win32.test.js
================================================
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { test, describe } from 'node:test'
import process from 'node:process'
import '../../build/globals.js'

const _describe = process.platform === 'win32' ? describe : describe.skip

const _testPwsh = which.sync('pwsh', { nothrow: true }) ? test : test.skip

_describe('win32', () => {
  test('should work with windows-specific commands', async () => {
    const p = await $`echo $0` // Bash is first by default.
    assert.match(p.stdout, /bash/)

    await within(async () => {
      usePowerShell()
      assert.match($.shell, /powershell/i)
      const p = await $`get-host`
      assert.match(p.stdout, /PowerShell/)
    })
  })

  test('quotePowerShell works', async () => {
    await within(async () => {
      usePowerShell()
      const p = await $`echo ${`Windows 'rulez!'`}`
      assert.match(p.stdout, /Windows 'rulez!'/)
    })
  })

  _testPwsh('should work with pwsh when it is available', async () => {
    await within(async () => {
      usePwsh()
      assert.match($.shell, /pwsh/i)
      const p = await $`echo 'Hello,' && echo ${`new 'PowerShell'!`}`
      assert.match(p.stdout, /Hello,\s+new 'PowerShell'!/)
    })
  })

  test('should create a dir via mkdir', async () => {
    const temp = tmpdir()
    const _$ = $({ verbose: true, cwd: temp })

    console.log('shell:', $.shell)
    await _$`which bash`
    await _$`bash --version`

    await _$`mkdir -p ${path.join(temp, 'AA-zx-test')}`
    await _$`mkdir -p BB-zx-test`
    const { stdout } = await _$`ls -l | grep zx-test`

    assert.match(stdout, /AA-zx-test/)
    assert.match(stdout, /BB-zx-test/)
  })

  test('ps detects self process', async () => {
    const [root] = await ps.lookup({ pid: process.pid })
    assert.equal(root.pid, process.pid)
  })

  test('kill works', async () => {
    const p = $({ nothrow: true })`sleep 100`
    const { pid } = p
    const found = await ps.lookup({ pid })
    console.log('found:', found)
    assert.equal(found.length, 1)
    assert.equal(found[0].pid, pid)

    await p.kill()
    const killed = await ps.lookup({ pid })
    console.log('killed:', killed)
    assert.equal(killed.length, 0)
  })

  test('abort controller works', async () => {
    const ac = new AbortController()
    const { signal } = ac
    const p = $({
      signal,
      timeout: '5s',
      nothrow: true,
      killSignal: 'SIGKILL',
    })`sleep 10`

    setTimeout(async () => {
      assert.throws(
        () => p.abort('SIGINT'),
        /signal is controlled by another process/
      )
      setTimeout(() => {
        ac.abort('stop')
      }, 500)
    }, 500)

    const o = await p
    assert.equal(o.signal, 'SIGTERM')
    assert.throws(() => p.abort(), /Too late to abort the process/)
    assert.throws(() => p.kill(), /Too late to kill the process/)
  })
})



================================================
FILE: test-d/core.test-d.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { Readable, Writable } from 'node:stream'
import { expectError, expectType } from 'tsd'
import { $, ProcessPromise, ProcessOutput, within } from 'zx'

let p = $`cmd`
assert(p instanceof ProcessPromise)
expectType<ProcessPromise>(p)
expectType<Writable>(p.stdin)
expectType<Readable>(p.stdout)
expectType<Readable>(p.stderr)
expectType<ProcessPromise>(p.nothrow())
expectType<ProcessPromise>(p.quiet())
expectType<ProcessPromise>(p.pipe($`cmd`))
expectType<ProcessPromise>(p.pipe`cmd`)
expectType<
  Writable & PromiseLike<ProcessOutput & Writable> & { run: () => void }
>(p.pipe('file'))
expectType<
  typeof process.stdout &
    PromiseLike<ProcessOutput & typeof process.stdout> & { run: () => void }
>(p.pipe(process.stdout))
expectType<ProcessPromise>(p.stdio('pipe'))
expectType<ProcessPromise>(p.timeout('1s'))
expectType<Promise<void>>(p.kill())
expectType<Promise<ProcessOutput>>(p.then((p) => p))
expectType<Promise<ProcessOutput>>(p.catch((p) => p))
expectType<Promise<any>>(p.then((p) => p).catch((p) => p))

let o = await p
assert(o instanceof ProcessOutput)
expectType<ProcessOutput>(o)
expectType<string>(o.stdout)
expectType<string>(o.stderr)
expectType<number | null>(o.exitCode)
expectType<NodeJS.Signals | null>(o.signal)
// prettier-ignore
expectType<ProcessOutput>(new ProcessOutput({
  code: null,
  signal: null,
  duration: 0,
  store: { stdout: [], stderr: [], stdall: [] },
  error: null,
  from: ''
}))

expectType<ProcessOutput>(new ProcessOutput(null, null, '', '', '', '', 1))
expectType<ProcessOutput>(new ProcessOutput(null, null, '', '', '', ''))
expectError(new ProcessOutput('1'))

expectType<'banana'>(within(() => 'apple' as 'banana'))

expectType<ProcessPromise>($`cmd`)
expectType<ProcessPromise>($({ sync: false })`cmd`)
expectType<ProcessOutput>($({ sync: true })`cmd`)
expectType<ProcessOutput>($.sync`cmd`)



================================================
FILE: test-d/globals.test-d.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import assert from 'node:assert'
import { expectType } from 'tsd'
import 'zx/globals'
import { ParsedArgs } from 'minimist'

let p = $`cmd`
assert(p instanceof ProcessPromise)
expectType<ProcessPromise>(p)

let o = await p
assert(o instanceof ProcessOutput)
expectType<ProcessOutput>(o)

expectType<string>(quote('foo'))
expectType<string>(quotePowerShell('foo'))

expectType<ParsedArgs>(minimist(['--foo', 'bar']))



================================================
FILE: test-d/goods.test-d.ts
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { expectType } from 'tsd'
import { $, echo, sleep, spinner, retry, expBackoff } from 'zx'

echo`Date is ${await $`date`}`
echo('Hello, world!')

await sleep('1s')
await sleep(1000)

expectType<'foo'>(await spinner(() => 'foo' as 'foo'))
expectType<'bar'>(await spinner('title', () => 'bar' as 'bar'))
expectType<'foo'>(await retry(0, () => 'foo' as 'foo'))
expectType<Generator<number, void, unknown>>(expBackoff())



================================================
FILE: .github/FUNDING.yml
================================================
github: antonmedv



================================================
FILE: .github/ISSUE_TEMPLATE.md
================================================
### Expected Behavior
```js

```

### Actual Behavior
```js

```

### Steps to Reproduce

1.
2.
3.

### Specifications

- zx version:  x.x.x
- Platform: windows / macos / linux
- Runtime: node / deno / bun



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
<!-- It's a good idea to open an issue first for discussion. -->

Fixes #<number_goes_here>

<!-- Usage demo -->
```js

```

- [ ] Tests pass
- [ ] Appropriate changes to README are included in PR



================================================
FILE: .github/SECURITY.md
================================================
# Security Policy

## Supported Versions
| Version | Status             | Comment                                                               |
|---------|--------------------|-----------------------------------------------------------------------|
| 8.x     | :white_check_mark: |                                                                       | 
| 7.x     | :warning:          | Bugs, vulnerabilities, compatibility enhancements, performance issues |
| 6.x     | :warning:          | Critical bugs and vulnerability fixes                                 |
| < 6.0   | :x:                | **No longer supported**, please consider upgrade options              |


## Reporting a Vulnerability
Please use https://g.co/vulnz to report security vulnerabilities.

We use https://g.co/vulnz for our intake and triage. For valid issues we will do coordination and disclosure here on
GitHub (including using a GitHub Security Advisory when necessary).

The Google Security Team will process your report within a day, and respond within a week (although it will depend on the severity of your report).



================================================
FILE: .github/codeql/codeql-config.yml
================================================
paths:
  - .github
  - docs
  - examples
  - man
  - src
  - scripts
  - test
  - test-d
paths-ignore:
  - build



================================================
FILE: .github/pages/index.html
================================================
Here be dragons



================================================
FILE: .github/workflows/codeql.yml
================================================
name: 'CodeQL Advanced'

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']
  schedule:
    - cron: '28 6 * * 3'

permissions: {}

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    timeout-minutes: 60
    permissions:
      # required for all workflows
      security-events: write

      # required to fetch internal or private CodeQL packs
      packages: read

      # only required for workflows in private repositories
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
          - language: javascript-typescript
            build-mode: none
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          config-file: ./.github/codeql/codeql-config.yml
          languages: ${{ matrix.language }}
          build-mode: ${{ matrix.build-mode }}

      - if: matrix.build-mode == 'manual'
        shell: bash
        run: |
          echo 'If you are using a "manual" build mode for one or more of the' \
            'languages you are analyzing, replace this with the commands to build' \
            'your code, for example:'
          echo '  make bootstrap'
          echo '  make release'
          exit 1

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: '/language:${{matrix.language}}'



================================================
FILE: .github/workflows/dev-publish.yml
================================================
name: Dev Publish

on:
  workflow_dispatch:

permissions: {}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - run: npm ci
      - run: npm test
        env:
          FORCE_COLOR: 3
      - run: |
          node scripts/build-jsr.mjs
          node scripts/prepublish-clean.mjs
      - uses: actions/upload-artifact@v4
        with:
          name: build-${{ github.run_id }}
          path: |
            build
            jsr.json
            package.json
            node_modules/depseek
          retention-days: 1

  npm-publish:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      checks: read
      statuses: write
      contents: write
      packages: write
      id-token: write
    env:
      GOOGLE_NPM_REGISTRY: wombat-dressing-room.appspot.com
      GOOGLE_NPM_TOKEN: ${{ secrets.AUTH_TOKEN }}
      GH_NPM_REGISTRY: npm.pkg.github.com
      GH_NPM_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - name: Get zx version info
        run: |
          echo SHA_SHORT=$(git rev-parse --short HEAD) >> $GITHUB_ENV
          echo ZX_VERSION=$(jq -r '.version' package.json) >> $GITHUB_ENV
      - run: |
          echo ZX_DEV_VERSION="${{ env.ZX_VERSION }}-dev.${{ env.SHA_SHORT }}" >> $GITHUB_ENV
          echo ZX_LITE_DEV_VERSION="${{ env.ZX_VERSION }}-lite-dev.${{ env.SHA_SHORT }}" >> $GITHUB_ENV
      - name: Configure npmrc
        run: |
          echo "//${{ env.GOOGLE_NPM_REGISTRY }}/:_authToken=$GOOGLE_NPM_TOKEN" >> .npmrc
          echo "//${{ env.GH_NPM_REGISTRY }}/:_authToken=$GH_NPM_TOKEN" >> .npmrc

      - uses: actions/download-artifact@v4
        with:
          name: build-${{ github.run_id }}

      - name: pushing to ${{ env.GOOGLE_NPM_REGISTRY }}
        run: |
          cat <<< $(jq '.version="${{ env.ZX_DEV_VERSION }}"' package.json) > package.json
          npm publish --provenance --access=public --no-git-tag-version --tag dev --registry https://${{ env.GOOGLE_NPM_REGISTRY }}

      - name: pushing to ${{ env.GH_NPM_REGISTRY }}
        run: |
          cat <<< $(jq '.name="@${{ github.repository }}"' package.json) > package.json
          npm publish --no-git-tag-version --access=public --tag dev --registry https://${{ env.GH_NPM_REGISTRY }}

      - name: pushing lite snapshot to ${{ env.GOOGLE_NPM_REGISTRY }}
        run: |
          cat <<< $(jq '.name="zx"' package.json) > package.json
          cat <<< $(jq '.version="${{ env.ZX_LITE_DEV_VERSION }}"' package.json) > package.json
          node scripts/prepublish-lite.mjs
          npm publish --provenance --access=public --no-git-tag-version --tag dev --registry https://${{ env.GOOGLE_NPM_REGISTRY }}

      - name: pushing to jsr.io
        run: |
          cat <<< $(jq '.version="${{ env.ZX_DEV_VERSION }}"' jsr.json) > jsr.json
          npx jsr publish --allow-dirty

  # https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images
  docker-publish:
    needs: build
    runs-on: ubuntu-latest
    # Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: ${{ github.repository }}

    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - uses: actions/download-artifact@v4
        with:
          name: build-${{ github.run_id }}

      - name: Set zx version
        run: |
          echo SHA_SHORT=$(git rev-parse --short HEAD) >> $GITHUB_ENV
          echo ZX_VERSION=$(jq -r '.version' package.json) >> $GITHUB_ENV

      # Uses the `docker/login-action` action to log in to the Container registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 #v3.4.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` "meta" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 #v5.7.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha
            type=semver,pattern={{version}},value=v${{ env.ZX_VERSION }}-dev.${{ env.SHA_SHORT }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the "meta" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 #v6.18.0
        with:
          context: ./
          file: ./dcr/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true



================================================
FILE: .github/workflows/docs.yml
================================================
name: Deploy docs
on:
  workflow_dispatch:
  release:
    types: [created]

concurrency:
  group: 'pages'
  cancel-in-progress: false

permissions: {}

jobs:
  deploy:
    permissions:
      contents: read
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          ref: main

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Install deps
        run: npm i

      - name: Add additional deps
        run: npm i @rollup/rollup-linux-x64-gnu@4.44.1

      - name: Build docs
        run: npm run docs:build

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'docs/build'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



================================================
FILE: .github/workflows/jsr-publish.yml
================================================
name: JSR Manual Publish

on:
  workflow_dispatch:

permissions: {}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - run: npm ci
      - run: npm test
        env:
          FORCE_COLOR: 3
      - run: node scripts/build-jsr.mjs
      - uses: actions/upload-artifact@v4
        with:
          name: build-${{ github.run_id }}
          path: |
            build
            jsr.json
          retention-days: 1

  jsr-publish:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - uses: actions/download-artifact@v4
        with:
          name: build-${{ github.run_id }}

      - name: Get zx version info
        run: |
          echo SHA_SHORT=$(git rev-parse --short HEAD) >> $GITHUB_ENV
          echo ZX_VERSION=$(jq -r '.version' jsr.json) >> $GITHUB_ENV

      - name: pushing to jsr.io
        run: |
          cat <<< $(jq '.version="${{ env.ZX_VERSION }}-dev.${{ env.SHA_SHORT }}"' jsr.json) > jsr.json
          npx jsr publish --allow-dirty



================================================
FILE: .github/workflows/osv.yml
================================================
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# A sample workflow which sets up periodic OSV-Scanner scanning for vulnerabilities,
# in addition to a PR check which fails if new vulnerabilities are introduced.
#
# For more examples and options, including how to ignore specific vulnerabilities,
# see https://google.github.io/osv-scanner/github-action/

name: OSV-Scanner

permissions: {}

on:
  pull_request:
    branches: ['main']
  merge_group:
    branches: ['main']
  schedule:
    - cron: '45 6 * * 5'
  push:
    branches: ['main']

jobs:
  scan-scheduled:
    if: ${{ github.event_name == 'push' || github.event_name == 'schedule' }}
    permissions:
      security-events: write
      contents: read
      actions: read
    uses: 'google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@40a8940a65eab1544a6af759e43d936201a131a2' # v2.0.3
    with:
      # Example of specifying custom arguments
      scan-args: |-
        -r
        ./
  scan-pr:
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'merge_group' }}
    permissions:
      security-events: write
      contents: read
      actions: read
    uses: 'google/osv-scanner-action/.github/workflows/osv-scanner-reusable-pr.yml@40a8940a65eab1544a6af759e43d936201a131a2' # v2.0.3
    with:
      # Example of specifying custom arguments
      scan-args: |-
        -r
        ./



================================================
FILE: .github/workflows/publish.yml
================================================
name: Publish

on:
  workflow_dispatch:
  release:
    types: [created]

permissions: {}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - run: npm ci
      - run: npm test
        env:
          FORCE_COLOR: 3
      - run: |
          node scripts/build-jsr.mjs
          node scripts/prepublish-clean.mjs
      - uses: actions/upload-artifact@v4
        with:
          name: build-${{ github.run_id }}
          path: |
            build
            package.json
            jsr.json
            node_modules/depseek
          retention-days: 1

  npm-publish:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      checks: read
      statuses: write
      contents: write
      packages: write
      id-token: write
    env:
      GOOGLE_NPM_REGISTRY: wombat-dressing-room.appspot.com
      GOOGLE_NPM_TOKEN: ${{ secrets.AUTH_TOKEN }}
      GH_NPM_REGISTRY: npm.pkg.github.com
      GH_NPM_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
      - name: Get zx version info
        run: echo ZX_VERSION=$(jq -r '.version' package.json) >> $GITHUB_ENV
      - name: Configure npmrc
        run: |
          echo "//${{ env.GOOGLE_NPM_REGISTRY }}/:_authToken=$GOOGLE_NPM_TOKEN" >> .npmrc
          echo "//${{ env.GH_NPM_REGISTRY }}/:_authToken=$GH_NPM_TOKEN" >> .npmrc
      - uses: actions/download-artifact@v4
        with:
          name: build-${{ github.run_id }}

      - name: pushing to ${{ env.GOOGLE_NPM_REGISTRY }}
        run: npm publish --provenance --access=public --registry https://${{ env.GOOGLE_NPM_REGISTRY }}

      - name: pushing to ${{ env.GH_NPM_REGISTRY }}
        run: |
          cat <<< $(jq '.name="@${{ github.repository }}"' package.json) > package.json
          npm publish --no-git-tag-version --access=public --registry https://${{ env.GH_NPM_REGISTRY }}

      - name: pushing lite snapshot to ${{ env.GOOGLE_NPM_REGISTRY }}
        run: |
          cat <<< $(jq '.name="zx"' package.json) > package.json
          node scripts/prepublish-lite.mjs
          npm publish --provenance --access=public --no-git-tag-version --tag lite --registry https://${{ env.GOOGLE_NPM_REGISTRY }}

      - name: pushing to jsr.io
        run: npx jsr publish --allow-dirty

  docker-publish:
    needs: build
    runs-on: ubuntu-latest
    # Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: ${{ github.repository }}

    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - uses: actions/download-artifact@v4
        with:
          name: build-${{ github.run_id }}

      - name: Get zx version
        run: echo ZX_VERSION=$(jq -r '.version' package.json) >> $GITHUB_ENV

      - name: Log in to the Container registry
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 #v3.4.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 #v5.7.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha
            type=semver,pattern={{version}},value=v${{ env.ZX_VERSION }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 #v6.18.0
        with:
          context: ./
          file: ./dcr/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true



================================================
FILE: .github/workflows/test.yml
================================================
name: Test

on:
  push:
  pull_request:
  schedule:
    - cron: '0 12 */4 * *'

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'

      - run: npm ci
      - run: |
          npm run build
          cd build && ls -l
      - uses: actions/upload-artifact@v4
        with:
          name: build
          path: |
            build
            package.json
          retention-days: 1

  checks:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: ${{ github.event_name == 'pull_request' && '15' || '1' }} # to ensure we have enough history for commitlint

      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'

      - uses: actions/download-artifact@v4
        with:
          name: build
      - run: npm ci

      - name: Format
        run: npm run fmt:check

      - name: License
        run: npm run test:license

      - name: Size
        run: npm run test:size

      - name: Dep audit
        run: npm run test:audit

      - name: Circular
        run: npm run test:circular

      - name: Bundles
        run: npm run test:npm
        timeout-minutes: 1

      - name: JSR dry-run
        run: npm run test:jsr

      - name: Conventional Commits
        if: github.event_name == 'pull_request'
        run: npx commitlint --from ${{ github.event.pull_request.base.sha }} --to ${{ github.event.pull_request.head.sha }} --verbose

  test:
    needs: build
    runs-on: ubuntu-latest
    env:
      FORCE_COLOR: 3

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'

      - uses: actions/download-artifact@v4
        with:
          name: build
      - run: npm ci

      - name: Unit tests
        run: npm run test:coverage
        timeout-minutes: 1

      - name: Type tests
        run: npm run test:types

  docker-test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - uses: actions/download-artifact@v4
        with:
          name: build
      - run: |
          npm run build:dcr
          npm run test:dcr

  smoke-win32-node16:
    runs-on: windows-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Use Node.js 16.x
        uses: actions/setup-node@v4
        with:
          node-version: 16.x
          cache: 'npm'

      - uses: actions/download-artifact@v4
        with:
          name: build

      - run: npm run test:smoke:win32
        timeout-minutes: 1
        env:
          FORCE_COLOR: 3

  smoke-bun:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Setup Bun
        uses: antongolub/action-setup-bun@f0b9f339a7ce9ba1174a58484e4dc9bbd6f7b133 # v1.13.2
      - uses: actions/download-artifact@v4
        with:
          name: build
      - run: |
          bun test ./test/smoke/bun.test.js
          bun ./test/smoke/ts.test.ts
        timeout-minutes: 1
        env:
          FORCE_COLOR: 3

  smoke-deno:
    runs-on: ubuntu-latest
    needs: build
    name: smoke-deno${{ matrix.deno-version }}
    strategy:
      matrix:
        deno-version: [1, 2]
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Setup Deno
        uses: denoland/setup-deno@909cc5acb0fdd60627fb858598759246509fa755 # v2.0.2
        with:
          deno-version: ${{ matrix.deno-version }}
      - run: deno install npm:types/node npm:types/fs-extra
      - uses: actions/download-artifact@v4
        with:
          name: build
      - run: deno test --allow-read --allow-sys --allow-env --allow-run ./test/smoke/deno.test.js
        timeout-minutes: 1
        env:
          FORCE_COLOR: 3

  smoke-node:
    runs-on: ubuntu-latest
    needs: build
    name: smoke-node${{ matrix.node-version }}
    strategy:
      matrix:
        node-version: [12, 14, 16, 18, 20, 22, 24, 25-nightly]
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - uses: actions/download-artifact@v4
        with:
          name: build
      - name: cjs smoke test
        run: npm run test:smoke:cjs
      - name: mjs smoke test
        run: npm run test:smoke:mjs
      - name: strip-types
        if: matrix.node-version >= 22
        run: npm run test:smoke:strip-types

  smoke-graal:
    needs: build
    runs-on: ubuntu-latest
    name: smoke-graal${{ matrix.version }}
    strategy:
      matrix:
        version: [17, 20]
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: graalvm/setup-graalvm@7f61f4917e70cddcfee9df637f280f10d5ae3566 #v1
        with:
          java-version: ${{ matrix.version }}
          distribution: 'graalvm-community'
          components: 'nodejs'
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - uses: actions/download-artifact@v4
        with:
          name: build
      - name: smoke tests
        run: |
          which node
          node -v
          npm run test:smoke:cjs

  smoke-ts:
    runs-on: ubuntu-latest
    needs: build
    name: smoke-ts${{ matrix.ts }}
    strategy:
      matrix:
        ts: [4, 5, rc, next]
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: 'npm'
      - name: Install deps
        run: npm ci
      - name: Install TypeScript ${{ matrix.ts }}
        run: npm i --force --no-package-lock --no-fund typescript@${{ matrix.ts }}
      - uses: actions/download-artifact@v4
        with:
          name: build
      - name: tsc
        run: npm run test:smoke:tsc
      - name: tsx
        run: npm run test:smoke:tsx
      - name: ts-node
        run: npm run test:smoke:ts-node



================================================
FILE: .github/workflows/zizmor.yml
================================================
name: Zizmor

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['**']

permissions: {}

jobs:
  zizmor:
    name: zizmor
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Install the latest version of uv
        uses: astral-sh/setup-uv@bd01e18f51369d5a26f1651c3cb451d3417e3bba #v6.3.1
        with:
          enable-cache: false

      - name: Run zizmor
        run: uvx zizmor@1.11.0 .github/workflows -v -p --min-severity=medium


